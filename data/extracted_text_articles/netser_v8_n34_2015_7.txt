Deriving Robust Distributed Business Processes with Automated Transformations of
Fallible Component Processes
Lei Wang,
Lu´ıs Ferreira Pires
and Marten J. van Sinderen
CTIT, University of Twente,
the Netherlands
Emails: {l.wang-1, l.ferreirapires, m.j.vansinderen}@utwente.nl
Andreas Wombacher
Achmea, the Netherlands
Postbus 866
3700 AW Zeist
Email: andreas.wombacher@achmea.nl
Chi-Hung Chi
CSIRO, Australia
3-4 Castray Esplanade,
Hobart, Tasmania, 7000
Email: chihungchi@gmail.com
Abstract—Due to the possibility of system crashes and network
failures, the design of robust interactions for collaborative busi-
ness processes is a challenge. If a process changes state, it
sends messages to other relevant processes to inform them about
this change. However, server crashes and network failures may
result in a loss of messages. In this case, the state change is
performed by only one process, resulting in global state/behavior
inconsistencies and possibly deadlocks. Our idea to solve this
problem is to (automatically) transform the original processes into
their robust counterparts. The robust initiator process re-tries
failed interactions by resending the request message. The robust
responder then replies with the possibly lost response message,
without processing the request again. We illustrate our solution
using a subset of Web Services Business Process Execution
Language (WS-BPEL). A WS-BPEL process is modeled using
a so called Nested Word Automata (NWA), to which we apply
our transformation solution and on which we perform correctness
proof. We have also analyzed the performance of our prototype
implementation. In our previous work, we assumed that a certain
pre-deﬁned interaction follows the failed interaction. In this work,
we lift this limitation by allowing an arbitrary behavior to
follow the failed interaction, making our solution more generally
applicable. This paper is an extension of our previous paper [1].
The additional contents of this paper is the following.
Keywords–robust; collaborative processes; control ﬂow; WS-
BPEL; interactions; system crash; network failure; automata.
I.
INTRODUCTION
The electronic collaboration of business organizations has
grown signiﬁcantly in the last decade. Often data interchange
is based on processes run by different parties exchanging
messages to synchronize their states. If a process changes
state, it sends messages to other relevant processes to in-
form them about this change. However, server crashes and
network failures may result in a loss of messages. In this case,
the state change is performed by one process, resulting in
global state/behavior inconsistencies and possible deadlocks.
In general, a state inconsistency is not recovered by the
process engine that executes the process. This can be seen
from a screen dump of errors after a system crash of the
process engines such as Apache ODE and Oracle BPM, as
is shown in Figure 1. Figure 1a shows that in the Apache
ODE process engine the initiator sends the message to an
unavailable server. Figure 1b shows that in the Apache ODE
process engine the initiator sends a request message, and
the responder crashes without sending the response message.
Figure 1c shows the Oracle process engine 12c, which sends
message to an unavailable server (see Figure 1).
Figure 2a shows that normally, a business process is
deployed to a process engine, which runs on the infrastructure
services (OS, database, networks, etc.), where system crashes
and network failures may happen. Our solution to recover
from failures is to transform business processes into their
robust counterparts, as shown in Figure 2b. The robust process
is deployed on the unmodiﬁed infrastructure services and is
recoverable from some interaction failures caused by system
crashes and network failures. Our solution has the following
properties: (1) the application protocols are not modiﬁed. We
do not modify the message format nor message sequence, e.g.,
by adding message ﬁelds that are irrelevant for the application
logic or adding acknowledge messages to the original message
sequence. The service autonomy is kept in that if one party
transforms the process according to our approach and the
other party does not, they can still interact with each other,
although without being able to recover from system crashes
and network failures. (2) the process transformation is trans-
parent for process designers. (3) the solution conforms to the
process language speciﬁcation. We use the standard process
language constructs without extending the language to avoid
making the robust process depend on a speciﬁc engine. In
this paper, we illustrate our solution using WS-BPEL. WS-
BPEL is a language for specifying business process behavior
192
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

(a) Service unavailable
(b) Pending response
(c) Service unavailable
Figure 1. Interaction failures
Networks
Operating
System
Process
Engine
Business
Processes
(a) Interaction failures
Networks
Operating
System
Process
Engine
Business
Processes
Robust
Processes
Processes
Transform
(b) Robust process transformation
Figure 2. Our idea to cope with failures.
based on web services. As an OASIS standard, it is widely
used by enterprises. However, other process languages may be
applicable as long as they support similar workﬂow patterns.
This paper is an extension of our previous paper [1]. The
additional contents of this paper is the following.
1)
We analyze the possible synchronization failures in
more detail.
2)
More Nested Word Automata models of WS-BPEL
activities are described inthis paper,suchas, “invoke”,
“receive” and “reply” activities.
3)
Omitted information on the correctness criteria and
correctness evaluation process is presented in this
paper.
4)
Process transformation complexity of our soultion is
analyzed.
This paper is based on our previous work [2][3][4][5],
where we assumed that a certain pre-deﬁned interaction fol-
lows the failed interaction, i.e., the only sequence control is
assumed that the further interaction is sequentially following
the failed interaction. In this paper, we lift this limitation
by allowing an arbitrary behavior to follow the failed inter-
action, making our solution more generally applicable. We
support conditional control ﬂow and loops and their arbitrary
combination as possible further interaction after interaction
failure. The structure of the paper is the following: Section
II analyzes possible interaction failures. Section III proposed
our process transformation-based solution. Section IV validates
our solution. Section V discusses related work and Section VI
concludes our paper.
II.
INTERACTION FAILURE ANALYSIS
This section analyzes possible interaction failures of col-
laborative processes caused by system crashes and network
failures.
A. Process Interaction Patterns
Process interaction failures are speciﬁc to interaction pat-
terns. In [6], 13 interaction patterns are identiﬁed. In this paper,
we focus on the send, receive and send-receive patterns. This
limitation is not severe because more complex patterns can
be composed using these basic interaction patterns. Figure 3a
shows an initiator that sends a one-way message to a responder.
The initiator behavior corresponds to the send pattern, while
the responder behavior corresponds to the receive pattern. In
pattern send-receive in Figure 3b the initiator combines one
send and one receive pattern. We call this pattern asynchronous
interaction in the sequel of the paper. In Figure 3c, the initiator
starts a synchronous interaction by sending a request and
getting a response, which characterize the send-receive pattern.
B. Process Interaction Failures
Table I shows a failure classiﬁcation scheme [7]. Crash
failure, omission failure and timing failure are considered in
this work. Crash failure is referred as system crashes in this
paper. Omission failure and timing failure occur when the
network fails to deliver the messages (in a speciﬁed time
interval) and are referred to as network failures in this paper.
However, response failures due to a ﬂaw in the process design
and arbitrary failure, also referred to as Byzantine failure,
which is more of a security issue, are out of the scope of
this work.
193
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Initiator
responder
(a) send and receive
Initiator
responder
(b) send-receive case I
Initiator
responder
XSU
XSU
XREQ
XRESP
XRESP
(c) send-receive case II
Figure 3. Process interaction patterns.
TABLE I. Failure Scheme.
Type of failure
Description
Crash failure
Server halts, bus is working correctly until it halts.
Omission failure
Server fails to respond to incoming requests.
Receive omission
A server fails to receive incoming messages.
Send omission
A server fails to send messages.
Timing failure
Server’s response lies outside the speciﬁed time interval.
Response failure
Server’s response is incorrect.
Value failure
The value of the response is wrong.
State transition failure
The server deviates from the correct ﬂow of control.
Arbitrary failure
Server may produce arbitrary responses at arbitrary times.
Interaction failures caused by system crashes and network
failures are pending request failure, pending response failure
and service unavailable [3]. As all failures possible in the
interaction patterns of Figure 3a and Figure 3b are covered
by Figure 3c, we look only into the interaction failures of the
interaction pattern in Figure 3c. Service unavailable (marked
as XSU) is caused by a responder system crash or a network
failure of the request message delivery. At process level, the
initiator is aware of the failure through a catchable exception of
the process implementation language. Pending request failure
(marked as XREQ) is caused by initiator system crashes
after sending a request message. The initiator is informed
of the failure after restart, e.g., through catchable exceptions.
However, the responder is not aware of the failure, so that
it replies with the response message and continues execution.
Pending response failure (marked as XRESP ) is caused by a
responder system crash or a network failure of the response
message delivery. In both cases, the responder replies with
the response message (after a restart if the responder system
crashes) and continues execution. However, the connection gets
lost and the initiator cannot receive the response message. The
initiator is aware of this failure after a timeout.
C. Assumptions concerning the failure behavior
Due to the heterogeneous infrastructure, e.g., different
process engine implementations or network environments, we
have to make the following assumptions concerning the failure
behavior of the infrastructure:
1) Persistent execution state. The state of a business process
(e.g., values of process variables) are kept persistent and
survive system crashes.
2) Atomic activity execution (e.g., invoke, receive, reply).
A system crash means that the execution is stopped only after
the previous activity is ﬁnished and the next activity has not
started. A restart means that execution resumes from the pre-
vious stopped activity. These assumptions correspond with the
default behavior of the most popular process engines, such as
Apache ODE or Oracle BPEL Process Manager (released as a
component of Oracle SOA Suite). In Apache ODE’s term, this
is named as persistent processes in their default conﬁguration.
Otherwise, this conﬁguration can be modiﬁed to “in-memory”
at deployment time [8]. For Oracle BPEL Process Manager,
this is named as “durable” processes, otherwise is named as
“transient” processes. By default all the WS-BPEL processes
are durable processes and their instances are stored in the so
called dehydration tables, which survives system crashes [9].
3) Network Failures interrupt the established network con-
nections and the messages that are in transit get lost.
III.
PROCESS TRANSFORMATION BASED SOLUTION
Figure 4 shows our approach based on process transforma-
tion. The transformation is implemented at an abstract level
by using NWA (Nested Word Automata) [10]. NWA is an
extension of the classical automata, which maintains the nested
syntax of WS-BPEL process. Furthermore, its automata based
deﬁnition, which facilitates the description of reliable inter-
action principles, correctness proof and complexity analysis
formalized. Figure 4 shows that the process transformation
is divided into three steps: Transform1 transforms a business
process into a NWA, Transform2 transforms the NWA to the
NWA’ of a robust process, and ﬁnally, transform3 generates
the robust process from the NWA’.
A. Business Processes
We choose WS-BPEL [11] as process speciﬁcation lan-
guage in our work. However, other process languages may be
applicable as long as they support similar workﬂow patterns
[12]. A WS-BPEL process is a container where relationships
to external partners, process data and handlers for various
purposes and, most importantly, the activities to be executed
are declared. As an OASIS standard, it is widely used by
enterprises. We use Nested Word Automata (NWA) [10] to
194
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Process 
Transform
Transform2
NWA of
Business
Processes
Robust
Processes
Transform3
Transform1
Business
Processes
Robust
Processes
Figure 4. Process transformation
<process>
</process>
NWA(act)
q0
q1
q2
q3
Figure 5. NWA model of a process.
describe the underlying semantics of WS-BPEL and use them
as a basis for our formal evaluation. We choose NWA be-
cause we need to model the nested structure of WS-BPEL
syntax. While traditional ﬁnite state automata can be used for
describing all possible states of messages, and their sending
and receiving sequences, they lack the capability of describing
nested structures of activities.
An NWA is an automaton that has hierarchical nesting
structures. Formally, an NWA A over an alphabet Σ is a
structure (Q, q0, Qf, P, p0, Pf, δc, δi, δr) consisting of
• a ﬁnite set of (linear) states Q,
• an initial (linear) state q0 ∈ Q,
• a set of (linear) ﬁnal states Qf ⊆ Q,
• a ﬁnite set of hierarchical states P,
• an initial hierarchical state p0 ∈ P,
• a set of hierarchical ﬁnal states Pf ⊆ P,
• a call-transition function δc : Q × Σ 7→ Q × P,
• an internal-transition function δi : Q × Σ 7→ Q, and
• a return-transition function δr: Q × P × Σ 7→ Q.
The deﬁnition of Q, q0, Qf, δi corresponds to the deﬁnition
of a ﬁnite state automata over an alphabet Σ [13]. The alphabet
Σ represents all possible process behaviors, e.g., <process> ∈
Σ represents the starting of a business process, ?mi ∈ Σ rep-
resents receiving a message while !mj ∈ Σ represents sending
a message. An internal transition δi(qi, !mi) = qj represents
that the process replies a message !mi at the state qi and then
enters the state qj. The hierarchical states P, p0, Pf are used to
describe the nesting structure of an NWA. A call transition δc
enters the nested automaton while a return transition δr leaves
the nested automaton. The other transitions are also found in
traditional automata, and called internal transitions. A nested
structure is graphically represented as dashed box. The NWA
model of a WS-BPEL process is shown in Figure 5. A call
transition δc(q0, <process>) = (q1, pa) starts from the initial
state and a return transition δr(q2, pa, </process>) = q3 leads
to the accepted state. The NWA model of an activity NWA(act)
is nested within the NWA of the process. This is described by
the hierarchical state pa.
WS-BPEL activities are divided into two categories,
namely basic and structured activities. The currently supported
structured activities are if, pick, while and sequence, as shown
in Figure 6. The conditional branch (if), repeat (while), and
sequential (sequence) activities are modeled as shown in Figure
6a, 6c, 6d, respectively. Figure 6b shows the model of a pick,
which is another case of conditional control ﬂow that depends
on the type of the incoming message. The ﬂow (concurrent
execution) or the other forms of loops (RepeatUntil, ForEach)
are not considered now and will be considered in future
work. Each structured activity model has exactly one call
transition and one return transition to enter and leave its nested
structure(s), which is represented as a dash box.
The models of basic activities are visualized in Figure
7. These models can be nested (to replace the dash box in
Figure 6) in the models of structured activities. However, the
model of exit is an exception. Once the transition exit ﬁres, the
NWA goes to a terminated state. From this state, the NWA is
deactivated (no transition will leave this state), which breaks
the well-nested structure.
B. Transformation Method
An operation that can be safely repeated is called idem-
potent [7]. Idempotent operations can be recovered by re-
sending the request message. However, a request resent to
non-idempotent operations (such as bank transfer operations)
triggers potentially incorrect executions. Our solution for non-
idempotent operation is that when a failure happens, a resent
message is replied with a copy of the previous processing
result.
In the example of Figure 8a, the WS-BPEL snippet receives
a message m1, performs some (non-idempotent) processing,
then replies with a message m2. The next incoming messages
could be m3 or m4. If the initiator sends request m3 or
m4, this implies that the initiator has successfully received
the response message m2. If due to an interaction failure, for
example, the initiator crashes and fails to receive the response
message m2, the initiator can recover by resending request
message m1. Thus, the responder can be aware of whether
failures have happened by inspecting the incoming message.
If the incoming message is a resent message, this implies that
a failure happened in the previous interaction. In this section,
we will ﬁrst present our formal method of calculating the
set of failure-resent messages at a state. We then transform
the responder process to use a copy of the previous result as
response. Figure 8b shows that in order to make a copy of
the response message, we use an assign activity to keep the
result value in a process variable $copy. In the pick activity,
we add an onMessage branch to accept the resent message m1
and use the variable $copy as the response. However, a resent
message could be sent multiple times before the response is
ultimately received. We nest the pick activity in a while to cope
195
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

<if>
true
end_true
NWA(act)
NWA(act)
false
end_false
</if>
(a) if
<pick>
<?m1>
</onMsg>
NWA(act)
NWA(act)
<?mn>
</onMsg>
</pick>
.
.
.
(b) pick
false
</while>
true
end_true
NWA(scope)
<while>
(c) while
<seq>
NWA(act)
</seq>
NWA(act)
next
(d) sequence
Figure 6. NWA model of WS-BPEL structured activities.
?msg
(a) receive
!msg
(b) reply
assign
(c) assign
wait
(d) wait
exit
(e) exit
<invoke> req#m1
resp#m2
</invoke>
(f) invoke
Figure 7. NWA model of WS-BPEL basic activities.
<sequence>
    <receive variable="m1" ... />
    <!-- some process -->
    <reply variable="m2" ... />
    <pick>
        <onMessage variable="m3".../>
        <onMessage variable="m4".../>
    </pick>
</sequence>
(a) example WS-BPEL snippet
<sequence>
    <receive variable="m1" ... />
    <!-- some process -->
    <reply variable="m2" ... />
    <assign>$copy := $m2</assign>
    <pick>
        <onMessage variable="m3".../>
        <onMessage variable="m4".../>
        <onMessage variable="m1"
>
            <reply variable="copy" 
/>
        </onMessage>
    </pick>
</sequence>
(b) transformation, step I
Figure 8. WS-BPEL example of our solution.
with the duplicate resent message. Our process transformation
algorithm is presented as follows.
1) Responder Transformation Algorithm: For a WS-BPEL
process, given its NWA model (Q, q0, Qf, P, p0.Pf, δc, δi, δr)
over the alphabet Σ, we assume that the alphabet that rep-
resents the response messages is Σresp and the alphabet that
represents the request messages is Σreq, thus Σreq ⊆ Σ and
Σresp ⊆ Σ. The transformation algorithm is as Figure 9.
The algorithm iterates through all combinations of a state
q, a request message ?mreq and a response message !mresp.
In line 2, we check if the message pair (?mreq, !mresp)
corresponds to the request and response for a synchronous
operation and at state q, the response message !mresp is sent,
represented by a transition δi(q, !mresp). This is the failure
point that the response message may be lost due to interaction
failures and where our transformation method applies. As
deﬁned in line 3, we ﬁrst make a copy of the response message,
as shown in Figure 10. The NWA model of reply activity in
Figure 10a is replaced by an NWA model of a sequence activity
1: for all q ∈ Q, ?mreq ∈ Σreq and !mresp ∈ Σresp do
2:
if (mreq, mresp) is a synchronous message pair and
δi(q, !mresp) is deﬁned in NWA then
3:
save reply(q, !mresp)
4:
N ← next receive(q, !mresp)
5:
for all ?mnext ∈ N and qnext ∈ Q do
6:
if δi(qnext, ?mnext) is deﬁned in NWA then
7:
transform receive(qnext, ?mnext)
8:
else if δc(qnext, ?mnext) is deﬁned in NWA then
9:
transform pick(qnext, ?mnext)
10:
end if
11:
end for
12:
end if
13: end for
Figure 9. Responder process transformation algorithm
in Figure 10b, in which a reply activity model and an assign
activity model are nested. The assign activity model represents
196
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

!m_resp                         .
(a) reply activity
<seq> !m_resp
assg
mcopy:=m_resp </seq>
(b) Transformed reply activity
Figure 10. Responder process transformation, reply activity.
?mnext
!mresp
q0
q1
q2
Σ/Σrec
Σ
Figure 11. The automaton A(!mi, ?mnext).
the copy of the reply message into the variable mcopy. In order
to process the possible resent request message ?mreq due to
the lost of the message !mresp sent at state q, we calculate the
set of all possible next incoming messages, which is deﬁned as
next receive(q, !mresp) in line 4. We construct an automaton
A(!mresp, ?mnext) as in Figure 11 to describe that a process
replies with a message !mresp and waits for some possible
next incoming message ?mnext. δ(q0, !mresp) = q1 models
the reply of the response message !mresp. δ(q1, Σ/Σreq) = q1
represents some process execution in which no messages
are received. δ(q1, ?mnext) = q2 represents that the process
receives an incoming message ?mnext. δ(q2, Σ) = q2 models
any process execution. For the process NWA model, at some
state q, a reply of a message !mresp is represented by an
internal transition δi(q, mresp). We change the initial state
of the process NWA model to from q0 to q, and call this
automaton NWA(q). Starting at q, after replying the message
!mresp, if one possible next incoming message is ?mnext, then
NWA(q) ∩ A(!mresp, ?mnext) ̸= ∅, i.e., the process modeled
by NWA has the behavior described by A(!mresp, ?mnext).
The intersection operation ∩ between an NWA and an
ﬁnite state automaton is deﬁned to check whether the busi-
ness process modeled by the NWA has the message send-
ing and receiving behavior modeled by the automaton. The
intersection operation is based on ﬁnite state automata. We
“ﬂatten” an NWA to a ﬁnite state automaton by skipping
hierarchical information, described as follows. Given a NWA
(Q, q0, Qf, P, p0, Pf, δc, δi, δr) over the alphabet Σ, the “ﬂat-
tened” automaton is A(Q, q0, Qf, Σ, δ), where Q, q0, Qf and
Σ are the same as the NWA, the transition function δ is deﬁned
as
1)
δ(qi1, a) = qi2, if the NWA has an internal transition
δi(qi1, a) = qi2.
2)
δ(qc1, a) = qc2, if the NWA has a call transition
δc(qc1, a) = (p, qc2).
3)
δ(qr1, a) = qr2, if the NWA has a return transition
δr(qr1, p, a) = qr2.
Both call transitions and return transition are treated as ﬂat
transitions that the hierarchical state p is not considered. The
intersection operation can be done between two ﬁnite state
automata, as deﬁned in [13].
We deﬁne the set of all possible next incoming messages
as next receive(q, !mresp) = {?mnext|?mnext ∈ Σreq∧
NWA(q) ∩ A(!mresp, ?mnext) ̸= ∅}.
For all ?mnext ∈ next receive(q, !mresp) and qnext ∈ Q,
if at the state qnext the next incoming message ?mnext
is received, two cases of transition may be deﬁned in
NWA: in a model of a receive activity as an internal tran-
sition δi(qnext, ?mnext) or in the model of a pick ac-
tivity as a call transition δc(qnext, ?mnext). For the ﬁrst
case (line 6), as shown in Figure 12a, the procedure
transform receive(qnext, ?mnext) is introduced as follows.
We replace the transition with a pick activity with two
branches, as shown in Figure 12b. One onMessage branch
models the receive of the resent message ?mreq and the reply
of the result message mcopy. The other onMessage branch
models the receive of the message ?mnext, and after that
we set the ﬂag success to true to indicate that the previous
interaction is ﬁnished successfully.
However, a possible loss of the response message mcopy
triggers multiple resending of the request mreq. Therefore, the
pick activity is deﬁned in a while iteration so that multiple
requests ?mreq can be accepted. Figure 12c shows that the
while iteration ends when the ﬂag success is set to true.
For the second case (line 8), as shown in Figure 13a, the
message ?mnext is one of the messages in m1, ..., mn. Figure
13b shows that we then add a call transition <?mreq > to
model that the process accepts the resent message, and an
internal transition !mcopy to represent the reply using a copy
of the previously cached result mcopy. In the other branches,
the nested NWA(act) is replaced by the model of a sequence
activity, in which we model the assignment of the ﬂag variable
success to true, followed by the original NWA(act). Similarly,
in order to cope with a possible loss of the response message
mcopy, the pick activity model is nested in a while iteration
to handle multiple resent messages, as shown in Figure 12c.
We do not directly prove the correntness of this algorithm,
however, the correctness of the transformed processes by this
algorithm have been proved in Section IV.
After the transformation, at some states the responder can
receive more messages than the original process, because the
resent message can be accepted and be replied. However, the
request is not processed again. In this sense, we do not give
malicious initiators any chance of jeopardizing the process by
changing the sequence of requests or sending the same request
multiple times.
C. Initiator Transformation
The initiator starts the interaction by executing the invoke
activity. An invoke activity, which is shown as Figure 14a, is
replaced by the model of a scope activity, which consists of
an NWA of a fault handler and a sequence activity model.
Nested in the sequence activity model there is the model of
the original invoke activity, followed by an assignment of the
false value to a process variable w. The whole NWA of the
scope activity is nested in a while activity model.
The whole model represents the process behavior of invo-
cation. If failure happens and gets caught by a fault handler, the
process waits for a speciﬁc time period and ﬁnishes the scope
activity, then the outside while makes the invoke activity be
executed again, until it ﬁnishes successfully and the variable
w is assigned to false. The possible interaction failure is
modeled as the transition fail. This is a reasonable failure
model since that if a failure happens the control ﬂow is
deviated from the normal ﬂow to the end of the scope to which
a fault handler is attached, rather than leading the process to
an exceptional end.
197
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

?mnext
(a) Responder, receive activity
<pick>
<?mreq>
</onMsg>
<?mnext>
</onMsg>
</pick>
!mcopy
assg
(success := true)
(b) Transformed responder, part I
false
</while>
assign
(success:=false)
<while>
(success==false)
true
<pick>
</pick>
NWA(pick)
(c) Transformed responder, part II
Figure 12. Responder process transformation, receive activity.
<pick>
<?m1>
</onMsg>
NWA(act)
NWA(act)
<?mn>
</onMsg>
</pick>
.
.
.
(a) Responder, pick activity
<pick>
<?m1>
</onMsg>
NWA(act)
<?mn>
</onMsg>
</pick>
.
.
.
<?mreq>
<seq>
assg
(success := true)
</seq>
NWA(act)
<seq>
assg
(success := true)
</seq>
</onMsg>
!mcopy
(b) Transformed responder, part I
Figure 13. Responder process transformation, pick activity.
<invoke> req#m1
resp#m2
</invoke>
(a) Initiator
<invoke> req#m1
resp#m2
</invoke>
<seq>
assg
(w=false)
</seq>
<scope>
</scope>
NWA(seq)
NWA(scope)
<faultHandlers>
<catch>
wait
NWA(faultHandlers)
</catch>
</faultHandlers>
fail
(b) Transformed initiator, part I
false
</while>
assign
(w:=true)
<while>
(w==true)
true
<scope>
</scope>
NWA(scope)
(c) Transformed initiator, part II
Figure 14. Initiator process transformation.
1) Recoverable Assumption: Assume that (?mreq, !mresp)
is a pair of synchronous request and response messages,
the process receives request message ?mreq, then at state q,
the process sends the response message !mresp. However, if
?mreq ∈ next receive(q, mresp), then one of the next possi-
ble messages is still ?mreq, in this case, the responder cannot
distinguish a resent message due to a failure from a normal
request message. Thus, we have to require that in the process
design the condition ?mreq /∈ next receive(q, !mresp) can be
met. However, by following a few process design principles
during the design of the original process, this condition can
be met. An example is a split of message ?mreq into two
different messages, ?mreq1 and ?mreq2 (for example, one
message is used to send request, the other asks for results). The
initiator sends the two messages back to back. If a responder
receives ?mreq1, then it waits for ?mreq2, rather than waiting
for ?mreq1 again.
IV.
EVALUATION
This section presents the correctness validation of our
solution. We also evaluate the performance overhead of our
prototype under different workloads. Finally, we analyze the
complexity of the transformed process by comparing it with
the original process.
A. Correctness Validation
The correctness proof shows that the solution introduced
in Section III provides a robust process. The core of the
proof is to deﬁne the correctness criteria for asynchronous and
synchronous interactions and represent them such that they can
be automatically evaluated.
198
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Robust BPEL 
Processes
Original BPEL 
Test Set
Transform
Validate
Fail
Validate
Success
Correctness
Criteria
Figure 15. The setup of the correctness proof.
Figure 15 shows the setup of our correctness proof. We
take the test set of 726 example WS-BPEL processes, which
implement all possible Internet Open Trading Protocol (IOTP)
interactions [14], and we transform them into the NWA model
of the corresponding robust business process. The proof is
ﬁnished by checking that the NWA process model is a subset of
the correctness criteria, which are modeled as automata. Given
an automaton A(Q, Σ, δ, q0, F), each state in Q represents
a state of the messages sending and receiving status. Set Σ
models of all possible process behaviors, e.g., sending and
receiving messages. δ is transition function: Q × Σ → Q that
models the state transition triggered by process execution, e.g.,
for states qi, qj ∈ Q and !m ∈ Σ, δ(qi, !m) → qj represents
that at state qi, the process replies with message !m and then
enters state qj. The correctness criteria automata models the
set of correct message sending and receiving sequences. We
present the correctness criteria as follows.
1) Initiator Side Correctness Criteria: There are two cri-
teria due to the interaction patterns: the criteria for a single
message sending and the criteria for synchronous request and
response message pair. In this paper, we discuss only the latter
due to the page limitations. The automaton is visualized as
Figure 16a. A correct interaction is regarded as, a request
message ?m1 can be sent at state q0 and can be resent multiple
times at state q1 until a response message !m2 is received at
state q2. The correctness criteria automaton is formally deﬁned
as {Q, q0, Qf, Σ, δ}, where
•
Σ = {?m1, !m2}. ?m1 and !m2 are the synchronous
request and response messages.
•
Q = {q0, q1, q2} and Qf = {q2}.
•
For the transition δ(q0, ?m1) = q1, the state changes
from q0 to q1 on the input ?m1 and stays on state q1
on the input ?m1 (transition δ(q1, ?m1) = q1). This
represents that a request could be sent multiple times
due to failures. Transition δ(q1, !m2) = q2 represents
that if the response is received the initiator is in an
accepted state and any transition is accepted (transition
δ(q2, Σ) = q2).
2) Responder Side Correctness Criteria: The property we
want to validate is that any resent message can be accepted
by the transformed process and replied. Given a process,
assume that the synchronous request and response messages
are mj and mi. If the transformed robust process model
is NWA’, for state qi and transition !mi, we have ?mj ∈
next receive(qi, !mi). The idea behind it is that after the reply
message !mi is sent, the robust process can accept possible
resent messages due to failures. In this case, the response
should be sent without reprocessing. The criteria are shown
as Figure 16b.
The process control ﬂows can be designed in arbitrary
ways, and since we cannot exhaust all possibilities, we use
a WS-BPEL test set that implements all possible IOTP inter-
actions, which is a total of 726 BPEL processes. After the
transformation of the test processes into automata, we apply
the subset check to evaluate the correctness of the WS-BPEL
test processes, i.e., we prove that for all processes and their
NWA model and criteria automaton A, NWA ∈ A, i.e., all
messages sending and receiving sequences are correct.
We take the process in Figure 8 to illustrate the correctness
validation. An original WS-BPEL snippet shown in Figure 8a
is transformed into the robust counterpart, and their automata
models are shown as Figures 17a and 17b, respectively. At
state q2, where the message !m2 is to be replied, the set
of the possible next incoming messages of the responder is
next receive(q2, !m2) = {?m1, ?m3, ?m4}. The criteria for
the synchronous request ?m1 and the response !m2 is shown as
Figure 18. First, we do a subset check to prove that the original
is not a subset of the criteria. Actually, we can see that the
message sequence (.., ?m1, !m2, .., ?m1, !m2, ..?m3, ..) can be
accepted by the criteria automaton. However, this sequence
cannot be accepted by the model of the original process, since
there is no transition deﬁned for the second ?m1. Second, we
do a subset check to prove the transformed automata model is
a subset of the criteria, i.e., all sending and receiving message
sequences are correct.
B. Performance Evaluation
In Figure 2 of the whole setup, if the infrastruc-
ture (OS, process engine, hardware and network conﬁgu-
ration) is the same, performance depends mainly on the
process design and the workload, i.e., performance =
Test(ProcessDesign, workload).
We use similar setup of our performance test with our
previous performance tests [15], which is shown in Figure 19.
We use the cloud infrastructure from Amazon EC2. The ini-
tiator and responder processes are deployed on two computing
instances and we use a local client to collect the performance
data. At the node initiator, the original and transformed initator
processes are deployed. At the node responder, the original and
transformed responder processes are deployed. At the node
performance data collector, a local client is deployed.
We evaluated the performance overhead of our transformed
process under different workloads. The number of requests
sent per minute by the local client complies with a Poisson
distribution with parameters λ = 5 and λ = 10 requests per
minute. We used these workloads because according to our
tests under the available hardware and software conﬁgurations,
higher workloads would exhaust the server resources. We
use the open source Apache ODE process engine where an
embedded Derby [16] database is used. The Amazon EC2
instance type is t1.micro with 1 vCPU and 0.594GiB memory.
Each test run lasted for 60 minutes, but only the response
times in the 30 minutes in the middle of this period have been
considered (steady state).
The performance data is shown as Table II. Under the
workload of λ = 5, the average performance overhead of our
transformation mechanism is 92 ms. Under the workload of
λ = 10, the average overhead is 130 ms. We conclude then
that the performance overhead increases with the workload.
199
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

!m2
?m1
q0
q1
q2
?m1
Σ
(a) Initiator
?mj
!mi
q0
q1
q2
Σ/next_receive(qi, !mi)
Σ/!mi
!mi
next_receive(qi, !mi)/?mj
q3
Σ
(b) Responder
Figure 16. Correctness criteria of process transformation.
<pick>
<?m3>
</onMsg>
<?m4>
</onMsg>
</pick>
<seq> ?m1 !m2
</seq>
q0
q1
q2
q3
(a) Automaton model of the original process
<pick>
<?m1>
</onMsg>
<?m4>
</onMsg>
</pick>
end_true
q3
<seq> ?m1 !m2
q0
q1
q2
assign 
$copy:=m2 <while> false </while></seq>
true
<?m3>
assign 
$success:=
true
</onMsg>
assign 
$success:=
true
!m2
(b) Automaton model of the transformed process
Figure 17. Illustration of the correctness validation, robust NWA model of Figure 8.
?m1
!m1
q0
q1
q2
Σ/{?m1,?m3,?m4}
Σ/!m1
!m2
{?m3,?m4}
q3
Σ
Figure 18. Correctness criteria for the illustrative process.
Initiator
Responder
Performance 
Data Collector
Figure 19. Setup of pperformance test.
TABLE II. PERFORMANCE OVERHEAD.
Origin
Trans
Overhead
Origin
Trans
Overhead
Workload λ = 5
Workload λ = 10
287 ms
379 ms
92 ms
322 ms
452 ms
130 ms
However, we expect lower performance overhead when the
infrastructure is scalable, like in a cloud environment.
C. Process Design Complexity
We have implemented the process designed in Figure 10,
Figure 12 and Figure 13 using WS-BPEL. The number of
activities before and after the process transformation is shown
as Table III. The transformation is applied to one reply activity
and the receive (or pick) activities in the set next receive().
As an example, by applying our process transformations, a
reply activity is replaced by one sequence structured activity
and two basic activities: reply and assign nested in it.
<r e c e i v e
. . . / >
<a s s i g n
name=” assg1 ”
. . .
/>
<i f
. . .>
<c o n d i t i o n
. . . / >
<a s s i g n
name=” assg2 ”
. . . / >
<e l s e>
<!−− Some Processing −−>
<a s s i g n
name=” assg3 ”
. . . / >
</ e l s e>
</ i f>
<r e p l y
. . . / >
V.
RELATED WORK
Solutions based on exception handling [17][18] is process-
speciﬁc. WS-BPEL supports compensations of well-deﬁned
exceptions using exception handlers. However, elaborate pro-
cess handler design requires process-speciﬁc knowledge of
failure types and their related recover strategies. Alternatively,
we try to ease the process designers from dealing with synchro-
nization failures by a transparent process transformation from
a given business process to its recovery-enabled counterpart.
A fault tolerant system can be built by coping with the
occurrence of failures by applying redundancy [7]. Three kinds
of redundancy are possible: information redundancy, time
redundancy and physical redundancy. However, the existing
solution either requires more effort of the business process
designers, or additional infrastructure support, or both.
On physical layer, the robust solutions on process engine
level [19][20] dependend on a speciﬁc process engine. We
deﬁned our solution based on the WS-BPEL building blocks
without requiring extensions at the engine level. However, the
200
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

TABLE III. Number of activities before and after transformation.
Before transformation
After transformation
Initiator
1 (invoke)
7 (2 sequence, 2 assign, 1 while, 1 scope, 1 invoke)
Responder
1 (reply in the set next receive())
3 (1 sequence, 1 reply, 1 assign)
Responder
1 (pick with n onMessage branches in the set next receive())
2n + 5 (1 pick, n + 1 sequence, 1 reply, n + 1 assign, 1 while)
transformed process can still be migrated to other standard pro-
cess engines. Reliable network protocols such as HTTPR have
been proposed to provide reliable synchronization. However,
the deployment of these solutions increases the complexity
of the network infrastructure. We assume that system crashes
and network failures are rare events, thus extending the in-
frastructure may introduce too much overhead. Further, the
solutions are not applicable in some outsourced deployment
environments. For example, in some cloud computing envi-
ronments, user-speciﬁc infrastructure conﬁguration to enhance
synchronization is not possible. Dynamic service substitution
[21][22] is a way to perform recovery by replacing the target
services by equivalent services. In [23][24], the QoS aspects
of dynamic service substitution are considered. In our work,
we do not change the business partners at runtime.
Information redundancy recovery is based on replication.
Our cache-based process transformation is information redun-
dant because a cache is a kind of replication. Time redundancy
solutions include web services transactions. The WS-AT [25]
standard speciﬁes atomic web services transactions, while
WS-BA [26] standard speciﬁes relaxed transactions so that
the participant can choose to leave the transaction before
it commits. However, if a transaction rolls back, a process-
speciﬁc compensation is required. Actually, transactions can
deal with well-deﬁned failures. The 2-phase commit distributed
transaction protocol can not deal with system crash (referred
to as cite failure in [27]). However, in a special case of process
in which all participants send vote results to a coordinator, if
the coordinator crashes before sending the vote results to any
participant, all the participants are blocked and the ﬁnal results
of the transaction remain unknown.
VI.
CONCLUSION AND FUTURE WORK
In this paper, we have identiﬁed three types of interaction
failures caused by system crashes and network failures and we
have proposed a process interaction failure recovery method
to cope with system crashes and network failures. This paper
is an extension of our previous work [2][3][4][5], where we
assumed that a certain pre-deﬁned interaction follows the failed
interaction. In this paper, we lift this limitation by allowing an
arbitrary behavior to follow the failed interaction, making our
solution more generally applicable. The challenge is to accept
the resent message due to failures with the arbitrary control
ﬂow of the responder process. We transformed the business
process design into nested word automata model. At a state
that models the reception of an incoming message, we add
an additional transition to accept the resent message due to
failure. We have proved the correctness of our process trans-
formations and we implemented a prototype to test the runtime
performance of our method. The transformation complexity
of our solution is analyzed. Currently, the transformation
process is semi-automatic. We have implemented the automatic
transformation from a WS-BPEL process to the NWA model,
however, the transformation of the NWA model to the robust
counter part is manually. In future, we will automate the
transformation process and we will investigate more complex
process interaction patterns.
REFERENCES
[1]
L. Wang, A. Wombacher, L. Ferreira Pires, M. J. van Sinderen, and
C. Chi, “Robust interactions under system crashes and network failures
of collaborative processes with arbitrary control ﬂows,” in The Seventh
International Conferences on Advanced Service Computing, SERVICE
COMPUTATION, 2015.
[2]
L. Wang, A. Wombacher, L. Ferreira Pires, M. J. van Sinderen, and C.-
H. Chi, “An illustrative recovery approach for stateful interaction failure
of orchestrated processes,” in IEEE 16th EDOC Workshops, 2012, pp.
38–41.
[3]
——, “A state synchronization mechanism for orchestrated processes,”
in IEEE 16th Intl. EDOC Conf., 2012, pp. 51–60.
[4]
——, “Robust client/server shared state interactions of collaborative
process with system crash and network failures,” in 10th IEEE Intl.
Conf. on Services Computing (SCC), 2013.
[5]
——, “Robust collaborative process interactions under system crash
and network failures,” Intl. J. of Business Process Integration and
Management, vol. 6, no. 4, 2013, pp. 326–340.
[6]
A. Barros, M. Dumas, and A. Hofstede, “Service interaction patterns,”
in Business Process Management, ser. Lecture Notes in Computer
Science.
Springer Berlin Heidelberg, 2005, vol. 3649, pp. 302–318.
[7]
A. S. Tanenbaum and M. van Steen, Distributed Systems: Principles
and Paradigms, 2nd ed.
Upper Saddle River, NJ, USA: Prentice Hall,
2006, ch. 8, pp. 321–375.
[8]
Apache ODE, “Create a process,” https://ode.apache.org/creating-a-
process.html#in-memory-execution.
[9]
SOA Technology for beginners and learners, “Transient vs. durable
bpel
processes,”
http://ofmxperts.blogspot.nl/2012/11/transient-vs-
durable-bpel-processes.html, Nov. 2012.
[10]
R. Alur and P. Madhusudan, “Adding nesting structure to words,” J.
ACM, vol. 56, no. 3, May 2009, pp. 16:1–16:43.
[11]
OASIS,
Web
Services
Business
Process
Execution
Language,
2nd ed., OASIS, http://docs.oasis-open.org/wsbpel/2.0/OS/wsbpel-v2.0-
OS.html, [retrieved: Feb., 2015], Apr. 2007.
[12]
W.M.P. van der Aalst, A.H.M. ter Hofstede, B. Kiepuszewski, and
A.P. Barros, “Workﬂow patterns,” Distributed and Parallel Databases,
vol. 14, no. 1, Jul. 2003, pp. 5–51.
[13]
J. E. Hopcroft, Introduction to Automata Theory, Languages, and
Computation, 3rd ed.
Pearson Addison Wesley, 2007.
[14]
J. Schiedung, “Analysing and modelling of IOTP transactions by CPNs
and BPEL,” Master’s thesis, Darmstadt University of Technology, 2004.
[15]
L. Wang, A. Wombacher, L. Ferreira Pires, M. J. van Sinderen, and C.-
H. Chi, “A colloborative processes synchronization method with regards
to system crashes and network failures,” in the 29th Symp. on Applied
Computing (SAC), 2014.
[16]
Apache
Software
Foundation,
“Ode
database
setup,”
http://ode.apache.org/databases.html.
[17]
N. Russell, W. Aalst, and A. Hofstede, “Workﬂow exception patterns,”
in Advanced Information Systems Engineering, ser. Lecture Notes in
Computer Science, E. Dubois and K. Pohl, Eds.
Springer Berlin
Heidelberg, 2006, vol. 4001, pp. 288–302.
[18]
B. S. Lerner, S. Christov, L. J. Osterweil, R. Bendraou, U. Kan-
nengiesser, and A. E. Wise, “Exception handling patterns for process
modeling,” IEEE Transactions on Software Engineering, vol. 36, no. 2,
2010, pp. 162–183.
201
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[19]
S. Modafferi, E. Mussi, and B. Pernici, “Sh-bpel: a self-healing plug-in
for ws-bpel engines,” in the 1st workshop on Middleware for Service
Oriented Computing.
NY, USA: ACM, 2006, pp. 48–53.
[20]
A. Charﬁ, T. Dinkelaker, and M. Mezini, “A plug-in architecture for
self-adaptive web service compositions,” in IEEE Intl. Conf. on Web
Services, Jul. 2009, pp. 35–42.
[21]
M. Fredj, N. Georgantas, V. Issarny, and A. Zarras, “Dynamic service
substitution in service-oriented architectures,” in IEEE Congress on
Services - Part I, Jul. 2008, pp. 101–104.
[22]
L. Cavallaro, E. Nitto, and M. Pradella, “An automatic approach to
enable replacement of conversational services,” in Service-Oriented
Computing, L. Baresi, C.-H. Chi, and J. Suzuki, Eds.
Springer Berlin
Heidelberg, 2009, vol. 5900, pp. 159–174.
[23]
O. Moser, F. Rosenberg, and S. Dustdar, “Non-intrusive monitoring and
service adaptation for ws-bpel,” in the 17th intl. conf. on World Wide
Web.
NY, USA: ACM, 2008, pp. 815–824.
[24]
F. Moo-Mena, J. Garcilazo-Ortiz, L. Basto-Diaz, F. Curi-Quintal,
S. Medina-Peralta, and F. Alonzo-Canul, “A diagnosis module based
on statistic and qos techniques for self-healing architectures supporting
ws based applications,” in Intl. Conf. on Cyber-Enabled Distributed
Computing and Knowledge Discovery, Oct. 2009, pp. 163 –169.
[25]
OASIS Web Services Transaction (WS-TX) TC, Web Services Atomic
Transaction
(WS-AtomicTransaction),
http://docs.oasis-open.org/ws-
tx/wstx-wsat-1.2-spec.html, [retrieved: Feb., 2015], OASIS Standard,
Rev. 1.2, Feb. 2009.
[26]
——,
Web
Services
Business
Activity
(WS-BusinessActivity),
http://docs.oasis-open.org/ws-tx/wstx-wsba-1.2-spec-os/wstx-wsba-1.2-
spec-os.html, [retrieved: Feb., 2015], OASIS Standard, Rev. 1.2, Feb.
2009.
[27]
M. T. Ozsu, Principles of Distributed Database Systems, 3rd ed. Upper
Saddle River, NJ, USA: Prentice Hall Press, 2007, ch. 12.
202
International Journal on Advances in Networks and Services, vol 8 no 3 & 4, year 2015, http://www.iariajournals.org/networks_and_services/
2015, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

