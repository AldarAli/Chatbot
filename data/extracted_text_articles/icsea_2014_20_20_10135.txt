On the Use of Ontology for Dynamic Reconï¬guring Software Product Line Products
Thyago TenÂ´orio
Computing Institute
Federal University of Alagoas (UFAL)
MaceiÂ´o, Brazil
ttmo@ic.ufal.br
Diego Dermeval
Department of Computer and Systems
Federal University of Campina
Grande (UFCG)
Campina Grande, Brazil
diegodermeval@copin.ufcg.edu.br
Ig Ibert Bittencourt
Computing Institute
Federal University of Alagoas (UFAL)
MaceiÂ´o, Brazil
ig.ibert@ic.ufal.br
Abstractâ€”Software Product Line (SPL) is a set of software
systems that have a particular set of common features and that
satisfy the needs of a particular market segment or mission. The
traditional SPLs focus on building software platforms at develop-
ment time. In contrast, modern systems of emerging domains (e.g.,
ubiquitous computing, service robotics and autonomic systems)
require new settings to perform dynamic reconï¬guration. In this
context, Dynamic Software Product Line (DSPL) extends the
SPL concept to provide an efï¬cient way to deal with software
adaptation at runtime. A key artifact in SPL is the feature
model. Such model is very important in the speciï¬cation of SPLs,
representing the variability of the software and also supporting
the instantiation of applications. However, this model has some
limitations regarding its usage in DSPL. In order to effectively
provide dynamic reconï¬guration of features, it is necessary to
represent such model in a formal way thus it can be automatically
monitored, retrieved and modiï¬ed during the execution of a
product. Hence, we propose an ontology for feature modeling,
regarding its capabilities to handle changes in the feature models,
demanding less effort to be reconï¬gurable at runtime. In order to
illustrate the use of the ontology, a set of reconï¬guration scenarios
in the domain of ubiquitous computing are presented.
Keywordsâ€“Ontology; Software Product Lines; Dynamic Soft-
ware Product Lines;
I.
INTRODUCTION
Software Product Line (SPL) engineering is a paradigm
that advocates the reusability of software artifacts and the
rapid development of new applications for a particular domain.
These objectives are achieved by capturing the commonal-
ities and variabilities between the products from the same
domain in variability models (e.g., feature models). Software
Product Line engineering methods offer characteristics such
as rapid product development, reduced time-to-market, quality
improvement, and more affordable development costs [1].
The traditional methods for designing SPL focus on its
construction at development time, thus each product conï¬g-
uration is instantiated before a product is delivered to the
customer. However, the modern systems of emerging domains
such as ubiquitous computing, service robotics, unmanned
space and autonomic systems are increasingly requiring new
mechanisms capable to reconï¬gure their variability models
at runtime, i.e., without stopping the systemâ€™s execution. In
this context, Dynamic Software Product Lines (DSPL) extend
existing Software Product Line engineering approaches to
provide ways to handle with software adaptation at runtime
[2].
One of the key artifacts used in SPL engineering is the
feature model. Such model is widely used in the context of
SPLs to capture the common and variable functionalities of
products from a same domain. However, its informal repre-
sentation has several limitations regarding its usage in DSPLs,
for instance, it is difï¬cult to automatically monitor, retrieve
and modify them at runtime [2].
In order to effectively provide dynamic reconï¬guration
of products, it is necessary to represent feature models in a
formal way, as a result it can be automatically reasoned or
queried during the execution of a product. Meanwhile, some
studies use ontologies as an effective way to formally represent
feature models [3][4]. However, none of the existing studies
on ontology-based feature modeling provides explicit elements
(e.g., status of the features and product conï¬guration model)
capable to allow product reconï¬guration at runtime with less
effort.
Facing the potential beneï¬ts of using ontologies to repre-
sent feature models for DSPL purposes and the limitations of
existing ontology-based feature modeling approaches regard-
ing dynamic reconï¬gurations, we propose the OntoSPL ontol-
ogy. Such ontology presents an alternative way for modeling
ontology-based feature models. OntoSPL was conceived with
the purpose to be as much ï¬‚exible as possible, since it speciï¬es
a predeï¬ned structure of classes and properties and suggests
the creation of features model as OWL instances/individuals
of such structure. In addition, we present a set of SPARQL
queries, in different scenarios, that can be executed to auto-
matically reconï¬gure SPL products speciï¬ed in OntoSPL.
The remainder of this paper is organized as follows. Section
II describes in details the OntoSPL ontology. Section III
presents the OntoSPL for DPSL Products and a set of SPARQL
queries for reconï¬guring SPL products. Section IV compares
our work to related ones. Finally, Section V presents our
conclusions and points out future works.
II.
ONTOSPL
This section presents the OntoSPL ontology. According to
the Guarinoâ€™s ontologies classiï¬cation [5], such ontology is
a domain one, which aims to describe the main concept of
Software Product Line through the feature model diagram. The
variability of SPLs is commonly expressed through features
represented in this model. A feature is a property of the system
which is relevant to some stakeholder and is used to capture
similarities and variabilities in software systems.
Feature modeling has been proposed as an approach for
545
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

describing variable requirements for Software Product Lines
[6]. It is an important activity of the Software Product Line
development process, since it is in such phase that the common
and variable features of the product family are speciï¬ed. In this
sense, OntoSPL provides an explicit conceptualization of the
essential elements involved in such diagram and is described
by the following elements: concepts, properties and relations.
In the sequel, the ontology is informally described (through
the description of feature model elements) and its concepts,
properties and relationships are further presented.
A. Informal description of the ontology
The ontology is inserted in the SPL Domain Engineering.
It describes the concepts involved in feature modeling, as
proposed by the Feature-Oriented Domain Analysis (FODA)
notation [7]. A feature model provides a graphical tree-like
notation that shows the hierarchical organization of features.
The root of the tree represents the whole SPL node, all other
nodes represent different types of features which are part of a
SPL.
Features are organized in feature models and can be one
the following types: mandatory, optional, alternative and or-
features. The mandatory type must be present in all products
derived from a Software Product Line. The optional one may or
may not be included into a product derived from a SPL, hence
its presence is optional. In the alternative feature, exactly one
feature from a set of features must be included in a product.
In the or-feature type, one or more features from a set of
features can be included in a product from a SPL. Moreover,
dependency rules between features may exist and can be of two
types: (i) Requires, when one feature requires the existence of
another feature (they are interdependent); and (ii) Excludes,
when one feature is mutually exclusive to another one (they
can not coexist). The Group element indicates a constraint in
a set of grouped features.
A feature constraint has also a name and can be classiï¬ed in
Depend (Require), Exclude or Group. The Depend constraint
has a name, a set of source features and a set of target features.
Such constraint means that if all source features are selected
in a product, then, in the same product derived from a SPL, all
the target features must be selected too. The Exclude constraint
has exactly the same properties of the Depend one. It only has
a semantic difference, since if all source features are selected
in a product then any target features may not be selected in
such product. Finally, the Group constraint has a name, a set
of features and a constraint type which indicates a type of the
constraint on the group.
B. Description of the classes, properties and relationships
In this section, the classes, properties and relationships
of the OntoSPL are described. Figure 1 illustrates its hi-
erarchy of classes. Note that the description of the classes
on below follows the format â€Class Name(Class Attribute 1,
Class Attribute 2,...,Class Attribute n)â€.
â€¢
SoftwareProductLine
(name,
description,
Feature-
Model): this class represents an arbitrary Software
Product Line. It has primitive elements such as: name
and description. Moreover, a SPL contains a Feature
Model.
â€¢
FeatureModel (name, Feature, FeatureConstraint): this
class describes a Feature Model which represents the
Figure 1. OntoSPL classes hierarchy (OntoViz plugin
visualization).
hierarchy organization of the features of a SPL. It has
a set of features and a set of featureâ€™s constraints.
â€¢
Feature (name, current state): this class represents a
resource available in the Software Product Line. It
may be classiï¬ed into Mandatory, Optional, Alterna-
tive, OrFeature and RootFeature:
â—¦
Mandatory (name): this class represents a
mandatory resource of the SPL, i.e., it must
be present in all products
â—¦
Optional (name): this class represents an op-
tional resource of the SPL, i.e., it is optionally
present in any product.
â—¦
Alternative (name, exclusive, AlternativeFea-
ture): this class represents an alternative re-
source of the SPL. An alternative resource
speciï¬es that two or more resources may not
co-exist.
â—¦
OrFeature
(name,
AlternativeFeature):
this
class represents an or exclusive resource of the
SPL. An or exclusive resource speciï¬es that
two or more resources may or may not co-
exist.
â—¦
RootFeature (name): this class represents a
root feature. A root feature represents the root
of the features tree. It is on top of a feature
model.
â€¢
FeatureConstraint (name): this class represents a con-
straint in the feature model. It may be classiï¬ed into
Depend, Exclude or Group:
â—¦
Depend (name, SourceFeature, TargetFeature):
This class represents a constraint of the De-
pend type. As mentioned above, it has a set of
source features and a set of target features.
â—¦
Exclude (name, SourceFeature, TargetFeature):
this class represents a constraint of the Exclude
type. As mentioned above, it has a set of source
features and a set of target features.
â—¦
Group (name, SetFeatures, typeConstraint):
this class represents a constraint of the Group
type. It has a set of features and a String
typeConstraint which indicates the type of the
546
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

constraint. The types can be: (i) zero-or-one
feature exactly (0 or 1); (ii) At-least-one fea-
ture (1 or more); (iii) Exactly-one feature (1);
(iv) Any feature (0 or more); (v) All features
(n);
OntoSPL speciï¬es a set of relationships between the ontol-
ogy classes. The two classes between the parentheses following
the property name represents, respectively, the source and
target classes of such property.
â€¢
hasRootFeatures (FeatureModel, RootFeature): speci-
ï¬es that a FeatureModel contains a set of root features
(which may not be empty);
â€¢
hasSetOfAlternativeFeatures
(Alternative,
Alternative): speciï¬es that an alternative feature
must have at least one feature alternative. It is a
symmetric property;
â€¢
hasSetOfConstraints
(FeatureModel,
FeatureCon-
straint): speciï¬es that a FeatureModel contains a set
of featureâ€™s constraints;
â€¢
hasSetOfFeatures (Group, Feature): speciï¬es that a
Group constraint contains a set of features (which may
not be empty);
â€¢
hasSourceFeatures (Depend/Exclude, Feature): speci-
ï¬es that a Depend or Exclude constraint has a set of
source features (which must have at least one feature);
â€¢
hasTargetFeatures (Depend/Exclude, Feature): speci-
ï¬es that a Depend or Exclude constraint has a set of
target features (which must have at least one feature);
â€¢
isBasedOn
(SoftwareProductLine,
FeatureModel):
speciï¬es
that
a
SPL
is
based
on
exactly
one
FeatureModel. It is a functional property;
â€¢
isChildOf (Feature, Feature): speciï¬es that a feature
is child of exactly one another Feature. It is a func-
tional property and it is also the inverse property of
isParentOf;
â€¢
isParentOf (Feature, Feature): speciï¬es that a feature
contains a set of children features. It is the inverse
property of isChildOf.
C. Axioms of the ontology
The classes and relationships described above express a
taxonomy of the OntoSPL ontology. In order to describe it in
a detailed and formal way, it must be governed with axioms.
All axioms of the OntoSPL are deï¬ned in description logics
(DL) and the OWL syntax used to represent it is summarized
in Table I. The data properties, classes axioms and object
properties are, respectively, presented in Tables II, III and IV.
TABLE I. SUMMARY OF DL SYNTAX.
Notations
Explanation
âŠ¤
Superclass of all OWL classes
A âŠ‘ B
A is a subclass of B
A âŠ‘ Â¬ B
A and B are disjoint class
A âŠ“ B
Class intersection
A âŠ” B
Class union
A â‰¡ B
Class equivalence
âŠ¤ âŠ‘ âˆ€ P.A
Range of property is class A
âˆƒ / âˆ€ P.A
allValuesFrom/someValuesFrom restriction
that for every instance of this class that has instances of property P, all
some of the values of the property are members of the class A
TABLE II. DATA PROPERTIES AXIOMS OF ONTOSPL.
Data Property
Source
Data Type
description
SoftwareProductLine
String
name
SoftwareProductLine;
FeatureModel;Feature;
String
FeatureConstraint
exclusive
Alternative
String
typeConstraint
Group
String
currentState
Feature
Boolean
TABLE III. CLASSES AXIOMS OF ONTOSPL.
Class
Axioms
Alternative âŠ‘ F eature
Alternative
Alternative âŠ‘ Â¬Optional
Alternative âŠ‘ Â¬Mandatory
Alternative âŠ‘ Â¬ORF eature
Alternative âŠ‘ Â¬Root
Depend âŠ‘ F eatureConstraint
Depend âŠ‘ Â¬Exclude
Depend
Depend âŠ‘ Â¬Group
Exclude âŠ‘ F eatureConstraint
Exclude âŠ‘ Â¬Depend
Exclude
Exclude âŠ‘ Â¬Group
Feature
F eature âŠ‘ âŠ¤
Feature Constraint
F eatureConstraint âŠ‘ âŠ¤
Feature Model
F eatureModel âŠ‘ âŠ¤
Group âŠ‘ F eatureConstraint
Group
Group âŠ‘ Â¬Depend
Group âŠ‘ Â¬Exclude
Mandatory âŠ‘ F eature
Mandatory
Mandatory âŠ‘ Â¬Optional
Mandatory âŠ‘ Â¬Alternative
Mandatory âŠ‘ Â¬ORF eature
Mandatory âŠ‘ Â¬Root
Optional âŠ‘ F eature
Optional
Optional âŠ‘ Â¬Mandatory
Optional âŠ‘ Â¬Alternative
Optional âŠ‘ Â¬ORF eature
Optional âŠ‘ Â¬Root
ORF eature âŠ‘ F eature
ORFeature
ORF eature âŠ‘ Â¬Mandatory
ORF eature âŠ‘ Â¬Alternative
ORF eature âŠ‘ Â¬Optional
ORF eature âŠ‘ Â¬Root
Root âŠ‘ F eature
Root
Root âŠ‘ Â¬Mandatory
Root âŠ‘ Â¬Alternative
Root âŠ‘ Â¬ORF eature
Root âŠ‘ Â¬Optional
Software Product Line
SoftwareP roductLine âŠ‘ âŠ¤
III.
DSPL PRODUCTS RECONFIGURATION
In SPL engineering, the applications are built by reusing
domain artifacts and by exploiting the product line variability.
To create instances (products) of a Software Product Line, one
must choose the features that will be present in the product,
following the constraints of the features model.
A SPL product contains a speciï¬c subset of features. In
the DSPL context, by contrast, the requirements (expressed as
feature models) of these products vary at runtime. Thus, these
models must be reasoned or queried during the execution of
a product, allowing it to be self-reconï¬gured at runtime, as
required by DSPL engineering.
In this sense, OntoSPL may represent a single product
based on a SPL feature model speciï¬ed. It is used as the
decision model on where the SPL variations are selected.
Hereafter, we present how to represent a product on the
ontology. Then, we present a set of dynamic reconï¬guration
scenarios which were applied to a running example of the
547
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

TABLE IV. OBJECT PROPERTIES AXIOMS OF ONTOSPL.
Object Property
Axioms
hasRootFeatures
âˆƒ hasRootFeatures Thing âŠ‘ FeatureModel
âŠ¤ âŠ‘ âˆ€ hasRootFeatures (âˆƒ hasRootFeatures RootFeature)
hasSetOfAlternativeFeatures
hasSetOfAlternativeFeatures â‰¡ hasSetOfAlternativeFeaturesâˆ’
âˆƒ hasSetOfAlternativeFeatures Thing âŠ‘ Alternative
âŠ¤ âŠ‘ âˆ€ hasSetOfAlternativeFeatures (â‰¥ 1 hasSetOfAlternativeFeatures Alternative)
hasSetOfConstraints
âˆƒ hasSetOfConstraints Thing âŠ‘ FeatureModel
âŠ¤ âŠ‘ âˆ€ hasSetOfConstraints (âˆ€ hasSetOfConstraints (Depend âŠ” Exclude âŠ” Group))
hasSetOfFeatures
âˆƒ hasSetOfFeatures Thing âŠ‘ Group
âŠ¤ âŠ‘ âˆ€ hasSetOfFeatures (âˆƒ hasSetOfFeatures Feature)
hasSourceFeatures
âˆƒ hasSourceFeatures Thing âŠ‘ Depend
âˆƒ hasSourceFeatures Thing âŠ‘ Exclude
âŠ¤ âŠ‘ âˆ€ hasSourceFeatures (â‰¥ 1 hasSourceFeatures Feature)
hasTargetFeatures
âˆƒ hasTargetFeatures Thing âŠ‘ Depend
âˆƒ hasTargetFeatures Thing âŠ‘ Exclude
âŠ¤ âŠ‘ âˆ€ hasTargetFeatures (â‰¥ 1 hasTargetFeatures Feature)
isBasedOn
âŠ¤ âŠ‘ â‰¤ 1 isBasedOn Thing
âˆƒ isBasedOn Thing âŠ‘ SoftwareProductLine
âŠ¤ âŠ‘ âˆ€ isBasedOn (= isBasedOn FeatureModel)
isChildOf
isChildOf â‰¡ isParentOf âˆ’
âŠ¤ âŠ‘ â‰¤ 1 isChildOf Thing
âˆƒ isChildOf Thing âŠ‘ Feature
âŠ¤ âŠ‘ âˆ€ isChildOf (= isChildOf Feature)
isParentOf
isChildOf â‰¡ isParentOfâˆ’
âŠ¤ âŠ‘ â‰¤ 1 isParentOfâˆ’ Thing
âˆƒ isParentOf Thing âŠ‘ Feature
âŠ¤ âŠ‘ âˆ€ isParentOf Feature
ubiquitous domain published in the literature, a simpliï¬ed
smart hotel [8].
A. DPSL products conï¬guration
OntoSPL supports the instantiation of products based on
the SPL in order to facilitate the reconï¬guration of the product
when it is necessary. In this sense, the property current state
of the Feature class indicates whether the feature belongs or
not to a particular product. This property presents the follow-
ing range of values: {â€eliminatedâ€ : string, â€selectedâ€ :
string}. Such a property can only receive the values: selected,
case the feature must be in the product, or eliminated, case the
feature must not be in the product.
Hence, one can reason in the ontology to perform dynamic
reconï¬guration in an arbitrary product. After deï¬ning the
features that may be present in the product to be created, there
is only necessary to set the property current state for each
feature instantiated in a product.
For instance, Figure 2 depicts the feature model of the
Simpliï¬ed Smart Hotel (extracted from [8]). Its mandatory
features are represented by a small ï¬lled circle above the
feature name (e.g., Automated Illumination). Optional features
are represented by a small circle not ï¬lled (e.g., Piped Music,
Security and Alarm). Alternative features share the same parent
feature and are graphically represented by a not ï¬lled arc below
the parent feature; such arc means that one and only one of
the child features must be chosen (e.g., Silent Alarm,Siren and
Visual Alarm). Finally, the or-features (e.g., Infrared Sensor
and Volumetric Sensor) are represented by a ï¬lled arc, in a
similar way to alternative features.
As shown in Figure 2, the gray features indicate which are
the selected features for a product conï¬guration. The current
conï¬guration of the simpliï¬ed smart hotel includes the Piped
Music, Security, In Room Detection, Volumetric Sensor, Alarm,
Silent Alarm, Automated Illumination features and Lighting
by Occupancy features. However, the white features represent
potential variants of a product conï¬guration [8].
B. Dynamic reconï¬guration scenarios
Once a product is speciï¬ed in the OntoSPL ontology, it can
be reconï¬gured dynamically according to different scenarios.
This section describes scenarios directly related to changes
in the type of a feature and also changes related to product
conï¬guration.
In this sense, to specify this product in the OntoSPL ontol-
ogy, one must set the current state property of these features
to the â€selectedâ€ value and â€eliminatedâ€ for the others features.
For instance, in our running example, the gray features of
Figure 2 assume the â€selectedâ€ value in the OntoSPL, whereas
the white features assume the â€elimatedâ€ value.
In the sequel, we present three scenarios (speciï¬ed in
SPARQL 1.1 [9]) which can be executed for changing SPL
products at runtime. Note that these scenarios are presented by
applying them to our running example, but they have generic
purposes.
1) Changing an optional feature to mandatory feature:
Changing an optional feature to a mandatory one demands
a simple change scenario in the requirements of a particular
feature. Such change does not have a great impact in the feature
model, since it is not necessary to create/remove features on
the feature model.
Letâ€™s suppose, for an arbitrary reason, that an Smart Hotel
requires security requirements. In this context, there is the
need to make the â€Securityâ€ feature a mandatory one. This
way, the query on Figure 3 could be used to perform such
reconï¬guration.
This query updates the property type of the feature being
changed. Note that, the optional type is deleted while the
mandatory type is inserted. As consequence, the feature will
be mandatory in the product.
2) Selecting an optional feature in a product: This is one
of the most common changing scenarios in SPLs. Usually, a
product is ï¬rstly generated according to customerâ€™s needs at
548
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

Figure 2. Feature model of the simpliï¬ed smart hotel (extracted from [8]).
	
	

	


		
 !!	
"
#
 !!	
$%
#
 !	
!&'(&
#
Figure 3. Changing an Optional feature to Mandatory feature.
development time and includes several features and, in such
moment, a optional feature would not be selected to be in
the product. However, in a later moment, it is possible that a
client demands the inclusion of an optional feature that was
not previously addressed by the conï¬gured product.
In the DSPL context, it is important to specify a mechanism
which can reconï¬gure the product to reï¬‚ect the current re-
quirements of the client. For instance, in our running example,
despite the hotel having alarm, the feature Bliking lights was
not originally selected to be in the Smart Hotel conï¬guration.
However, in a changing scenario, the client would like to
include it in his product.
To achieve such change, it is necessary to change the
property that indicates that the feature is present or not in the
system in the ontology of the product at runtime. The update of
this property can be realized by the SPARQL query on Figure
4.
	
	

	


	
	 ! 
"

	
	 	! 
"
	
 #$	 "
Figure 4. Selecting An Optional Feature in a Product.
As can be seen in the query, after setting the status of the
Bliking Lights feature as â€Selectedâ€, such feature is included
in the product.
3) Changing an Alternative Feature: Usually, it is neces-
sary to select alternative ways to realize a product requirement.
The alternative type of features speciï¬es a design space of
variations on which a product can use. A product conï¬guration
requires the selection of one of the variants on such kind of
features, but it is possible that a client would be not satisï¬ed
with the variant selected and wants to reconï¬gure a product
with another variant.
For instance, in our running example, the selected variant of
alarm is the silent type. However, one could require to change
from the Silent Alarm feature to the Siren one.
Figure 5 speciï¬es a SPARQL query which makes such
variant change. This query is similar to the one presented in
Subsection III-B2, however, it is not only a selection of a new
feature, but rather the substitution of one feature by another.
Thus, there is the need to remove the existing feature and then,
add the new feature.
	
	

	


	 	! 
"	 ! 
#

	 ! 
"	 	! 
#

"	
  
	
 $ 

Figure 5. Changing an Alternative Feature.
As deï¬ned in the query, the Silent Alarm would be elim-
inated from the hotel and the Siren would be enabled in the
product. After executing this query, the selected type of Alarm
is the Siren feature.
IV.
RELATED WORKS
Using ontologies in the development of SPLs has been
addressed by several studies in the literature. In fact, it was
found some studies with the particular aim of using ontology
for representing feature models [3][4]. Furthermore, we have
549
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

found only one study which makes use of ontology-based
feature modeling in the design of DSPLs [10].
Wang et al. [3] presents a technique to design ontology-
based feature models, by representing feature models as OWL
classes and properties. Moreover, they use OWL reasoning
engines to check for inconsistences of feature conï¬gurations
automatically. However, since the features in such modeling
are represented as OWL classes and properties, every change
in the feature model requires a structural modiï¬cation in the
ontology.
OntoSPL ontology presents an alternative way for model-
ing ontology-based feature models. It proposes a predeï¬ned
structure of classes and properties and suggests the creation of
features model as OWL instances/individuals of such structure.
This alternative way for feature modeling is more suitable than
the one of [3] for dynamic reconï¬gurations of features.
In order to change a feature model using Wangâ€™s ontology
[3], for instance, adding a new feature, it would be necessary
to change the structure of the ontology and then it would be
also necessary to generate the ontology mapping code again.
Thus, applying such changes in an application would require to
stop the execution of the system. On the other hand, using the
OntoSPL, changes are performed at the instances level. This
characteristic allows to change instances at runtime, i.e., it is
not necessary to generate the ontology mapping code again
and hence, it would not be necessary to stop the application.
The work by Zaid et al. [4] also presents an ontology
to represent feature models based on OWL instances which
is similar to our ontology. However, it is focused on the
automatic consistency veriï¬cation of feature models and it was
not conceived to support dynamic reconï¬guration of features.
Thus, it does not consider important issues regarding changes
at runtime, for example, properties related to the status of the
feature.
Regarding the use of ontology in the development of dy-
namic Software Product Lines, Kaviani et al. [10] use ontology
to annotate feature models covering non-functional require-
ments modeling in the context of ubiquitous environments.
However, it also represents feature models as proposed in [3],
thus the same limitations regarding the impact of changes
in the feature model are also applicable to it. Moreover, it
is noteworthy that the dynamic reconï¬guration effort using
the OntoSPL ontology is lower, since it is only necessary
to change product conï¬gurations through SPARQL queries
without needing to generate code to manipulate a product.
V.
CONCLUSION AND FUTURE WORKS
In this paper, we presented the OntoSPL ontology, which
is used to specify feature models in a formal way with the
special aim to support automatic reconï¬gurations of products
in the context of Dynamic Software Product Line.
To illustrate how to reconï¬gure DSPL products using such
ontology, we also speciï¬ed three SPARQL queries that were
applied to an existent running example in the literature.
This study can be considered as a ï¬rst step towards
selecting a suitable way for formalizing feature models to be
used in the context of DSPLs. Future works should include
the conduction of a controlled experiment in different con-
texts to evaluate the effectiveness of OntoSPL in comparison
with other ontologies regarding its capabilities (e.g., time to
realize some change, ï¬‚exibility and so on) for performing
reconï¬guration at runtime. Moreover, we intend to incorporate
some consistency checking mechanism in OntoSPL to validate
product reconï¬gurations. We also intend to deï¬ne a DSPL
process based on the OntoSPL.
ACKNOWLEDGMENTS
This work has been supported by the Brazilian institu-
tions: Conselho Nacional de Desenvolvimento CientÂ´Ä±ï¬co e
TecnolÂ´ogico (CNPq) and CoordenacËœao de Aperfeicoamento de
Pessoal de NÂ´Ä±vel Superior (CAPES).
REFERENCES
[1]
K. Pohl, G. Bockle, and F. Van Der Linden, Software product line
engineering.
Springer, 2005, vol. 10.
[2]
M. Hinchey, S. Park, and K. Schmid, â€œBuilding dynamic software
product lines,â€ Computer, vol. 45, no. 10, 2012, pp. 22â€“26.
[3]
H. H. Wang, Y. F. Li, J. Sun, H. Zhang, and J. Pan, â€œVerifying feature
models using owl,â€ Web Semantics: Science, Services and Agents on
the World Wide Web, vol. 5, no. 2, 2007, pp. 117â€“129.
[4]
L. A. Zaid, F. Kleinermann, and O. De Troyer, â€œApplying semantic
web technology to feature modeling,â€ in Proceedings of the 2009 ACM
symposium on Applied Computing.
ACM, 2009, pp. 1252â€“1256.
[5]
N. Guarino, Formal Ontology in Information Systems: Proceedings of
the 1st International Conference June 6-8, 1998, Trento, Italy, 1st ed.
Amsterdam, The Netherlands, The Netherlands: IOS Press, 1998.
[6]
K. Czarnecki, C. H. Peter Kim, and K. T. Kalleberg, â€œFeature models
are views on ontologies,â€ in Proceedings of the 10th International on
Software Product Line Conference, ser. SPLC â€™06.
Washington, DC,
USA: IEEE Computer Society, 2006, pp. 41â€“51.
[7]
K. Kang, S. Cohen, J. Hess, W. Nowak, and S. Peterson, Feature-
Oriented Domain Analysis (FODA) Feasibility Study, 1990.
[8]
C. Cetina, P. Giner, J. Fons, and V. Pelechano, â€œPrototyping dynamic
software product lines to evaluate run-time reconï¬gurations,â€ Science
of Computer Programming, vol. 78, no. 12, 2013, pp. 2399 â€“ 2413,
special Section on International Software Product Line Conference 2010
and Fundamentals of Software Engineering (selected papers of {FSEN}
2011).
[9]
W3C,
â€œSparql
1.1
query
language,â€
Available
in
http://www.w3.org/TR/2012/PR-sparql11-query-20121108/,
retrieved:
October, 2014.
[10]
N. Kaviani, B. Mohabbati, D. Gasevic, and M. Finke, â€œSemantic annota-
tions of feature models for dynamic product conï¬guration in ubiquitous
environments,â€ in Proceedings of the 4th International Workshop on
Semantic Web Enabled Software Engineering, in collaboration with
International Semantic Web Conference (ISWC), Karlsruhe, Germany,
2008.
550
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

