On the Use of Ontology for Dynamic Reconﬁguring Software Product Line Products
Thyago Ten´orio
Computing Institute
Federal University of Alagoas (UFAL)
Macei´o, Brazil
ttmo@ic.ufal.br
Diego Dermeval
Department of Computer and Systems
Federal University of Campina
Grande (UFCG)
Campina Grande, Brazil
diegodermeval@copin.ufcg.edu.br
Ig Ibert Bittencourt
Computing Institute
Federal University of Alagoas (UFAL)
Macei´o, Brazil
ig.ibert@ic.ufal.br
Abstract—Software Product Line (SPL) is a set of software
systems that have a particular set of common features and that
satisfy the needs of a particular market segment or mission. The
traditional SPLs focus on building software platforms at develop-
ment time. In contrast, modern systems of emerging domains (e.g.,
ubiquitous computing, service robotics and autonomic systems)
require new settings to perform dynamic reconﬁguration. In this
context, Dynamic Software Product Line (DSPL) extends the
SPL concept to provide an efﬁcient way to deal with software
adaptation at runtime. A key artifact in SPL is the feature
model. Such model is very important in the speciﬁcation of SPLs,
representing the variability of the software and also supporting
the instantiation of applications. However, this model has some
limitations regarding its usage in DSPL. In order to effectively
provide dynamic reconﬁguration of features, it is necessary to
represent such model in a formal way thus it can be automatically
monitored, retrieved and modiﬁed during the execution of a
product. Hence, we propose an ontology for feature modeling,
regarding its capabilities to handle changes in the feature models,
demanding less effort to be reconﬁgurable at runtime. In order to
illustrate the use of the ontology, a set of reconﬁguration scenarios
in the domain of ubiquitous computing are presented.
Keywords–Ontology; Software Product Lines; Dynamic Soft-
ware Product Lines;
I.
INTRODUCTION
Software Product Line (SPL) engineering is a paradigm
that advocates the reusability of software artifacts and the
rapid development of new applications for a particular domain.
These objectives are achieved by capturing the commonal-
ities and variabilities between the products from the same
domain in variability models (e.g., feature models). Software
Product Line engineering methods offer characteristics such
as rapid product development, reduced time-to-market, quality
improvement, and more affordable development costs [1].
The traditional methods for designing SPL focus on its
construction at development time, thus each product conﬁg-
uration is instantiated before a product is delivered to the
customer. However, the modern systems of emerging domains
such as ubiquitous computing, service robotics, unmanned
space and autonomic systems are increasingly requiring new
mechanisms capable to reconﬁgure their variability models
at runtime, i.e., without stopping the system’s execution. In
this context, Dynamic Software Product Lines (DSPL) extend
existing Software Product Line engineering approaches to
provide ways to handle with software adaptation at runtime
[2].
One of the key artifacts used in SPL engineering is the
feature model. Such model is widely used in the context of
SPLs to capture the common and variable functionalities of
products from a same domain. However, its informal repre-
sentation has several limitations regarding its usage in DSPLs,
for instance, it is difﬁcult to automatically monitor, retrieve
and modify them at runtime [2].
In order to effectively provide dynamic reconﬁguration
of products, it is necessary to represent feature models in a
formal way, as a result it can be automatically reasoned or
queried during the execution of a product. Meanwhile, some
studies use ontologies as an effective way to formally represent
feature models [3][4]. However, none of the existing studies
on ontology-based feature modeling provides explicit elements
(e.g., status of the features and product conﬁguration model)
capable to allow product reconﬁguration at runtime with less
effort.
Facing the potential beneﬁts of using ontologies to repre-
sent feature models for DSPL purposes and the limitations of
existing ontology-based feature modeling approaches regard-
ing dynamic reconﬁgurations, we propose the OntoSPL ontol-
ogy. Such ontology presents an alternative way for modeling
ontology-based feature models. OntoSPL was conceived with
the purpose to be as much ﬂexible as possible, since it speciﬁes
a predeﬁned structure of classes and properties and suggests
the creation of features model as OWL instances/individuals
of such structure. In addition, we present a set of SPARQL
queries, in different scenarios, that can be executed to auto-
matically reconﬁgure SPL products speciﬁed in OntoSPL.
The remainder of this paper is organized as follows. Section
II describes in details the OntoSPL ontology. Section III
presents the OntoSPL for DPSL Products and a set of SPARQL
queries for reconﬁguring SPL products. Section IV compares
our work to related ones. Finally, Section V presents our
conclusions and points out future works.
II.
ONTOSPL
This section presents the OntoSPL ontology. According to
the Guarino’s ontologies classiﬁcation [5], such ontology is
a domain one, which aims to describe the main concept of
Software Product Line through the feature model diagram. The
variability of SPLs is commonly expressed through features
represented in this model. A feature is a property of the system
which is relevant to some stakeholder and is used to capture
similarities and variabilities in software systems.
Feature modeling has been proposed as an approach for
545
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

describing variable requirements for Software Product Lines
[6]. It is an important activity of the Software Product Line
development process, since it is in such phase that the common
and variable features of the product family are speciﬁed. In this
sense, OntoSPL provides an explicit conceptualization of the
essential elements involved in such diagram and is described
by the following elements: concepts, properties and relations.
In the sequel, the ontology is informally described (through
the description of feature model elements) and its concepts,
properties and relationships are further presented.
A. Informal description of the ontology
The ontology is inserted in the SPL Domain Engineering.
It describes the concepts involved in feature modeling, as
proposed by the Feature-Oriented Domain Analysis (FODA)
notation [7]. A feature model provides a graphical tree-like
notation that shows the hierarchical organization of features.
The root of the tree represents the whole SPL node, all other
nodes represent different types of features which are part of a
SPL.
Features are organized in feature models and can be one
the following types: mandatory, optional, alternative and or-
features. The mandatory type must be present in all products
derived from a Software Product Line. The optional one may or
may not be included into a product derived from a SPL, hence
its presence is optional. In the alternative feature, exactly one
feature from a set of features must be included in a product.
In the or-feature type, one or more features from a set of
features can be included in a product from a SPL. Moreover,
dependency rules between features may exist and can be of two
types: (i) Requires, when one feature requires the existence of
another feature (they are interdependent); and (ii) Excludes,
when one feature is mutually exclusive to another one (they
can not coexist). The Group element indicates a constraint in
a set of grouped features.
A feature constraint has also a name and can be classiﬁed in
Depend (Require), Exclude or Group. The Depend constraint
has a name, a set of source features and a set of target features.
Such constraint means that if all source features are selected
in a product, then, in the same product derived from a SPL, all
the target features must be selected too. The Exclude constraint
has exactly the same properties of the Depend one. It only has
a semantic difference, since if all source features are selected
in a product then any target features may not be selected in
such product. Finally, the Group constraint has a name, a set
of features and a constraint type which indicates a type of the
constraint on the group.
B. Description of the classes, properties and relationships
In this section, the classes, properties and relationships
of the OntoSPL are described. Figure 1 illustrates its hi-
erarchy of classes. Note that the description of the classes
on below follows the format ”Class Name(Class Attribute 1,
Class Attribute 2,...,Class Attribute n)”.
•
SoftwareProductLine
(name,
description,
Feature-
Model): this class represents an arbitrary Software
Product Line. It has primitive elements such as: name
and description. Moreover, a SPL contains a Feature
Model.
•
FeatureModel (name, Feature, FeatureConstraint): this
class describes a Feature Model which represents the
Figure 1. OntoSPL classes hierarchy (OntoViz plugin
visualization).
hierarchy organization of the features of a SPL. It has
a set of features and a set of feature’s constraints.
•
Feature (name, current state): this class represents a
resource available in the Software Product Line. It
may be classiﬁed into Mandatory, Optional, Alterna-
tive, OrFeature and RootFeature:
◦
Mandatory (name): this class represents a
mandatory resource of the SPL, i.e., it must
be present in all products
◦
Optional (name): this class represents an op-
tional resource of the SPL, i.e., it is optionally
present in any product.
◦
Alternative (name, exclusive, AlternativeFea-
ture): this class represents an alternative re-
source of the SPL. An alternative resource
speciﬁes that two or more resources may not
co-exist.
◦
OrFeature
(name,
AlternativeFeature):
this
class represents an or exclusive resource of the
SPL. An or exclusive resource speciﬁes that
two or more resources may or may not co-
exist.
◦
RootFeature (name): this class represents a
root feature. A root feature represents the root
of the features tree. It is on top of a feature
model.
•
FeatureConstraint (name): this class represents a con-
straint in the feature model. It may be classiﬁed into
Depend, Exclude or Group:
◦
Depend (name, SourceFeature, TargetFeature):
This class represents a constraint of the De-
pend type. As mentioned above, it has a set of
source features and a set of target features.
◦
Exclude (name, SourceFeature, TargetFeature):
this class represents a constraint of the Exclude
type. As mentioned above, it has a set of source
features and a set of target features.
◦
Group (name, SetFeatures, typeConstraint):
this class represents a constraint of the Group
type. It has a set of features and a String
typeConstraint which indicates the type of the
546
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

constraint. The types can be: (i) zero-or-one
feature exactly (0 or 1); (ii) At-least-one fea-
ture (1 or more); (iii) Exactly-one feature (1);
(iv) Any feature (0 or more); (v) All features
(n);
OntoSPL speciﬁes a set of relationships between the ontol-
ogy classes. The two classes between the parentheses following
the property name represents, respectively, the source and
target classes of such property.
•
hasRootFeatures (FeatureModel, RootFeature): speci-
ﬁes that a FeatureModel contains a set of root features
(which may not be empty);
•
hasSetOfAlternativeFeatures
(Alternative,
Alternative): speciﬁes that an alternative feature
must have at least one feature alternative. It is a
symmetric property;
•
hasSetOfConstraints
(FeatureModel,
FeatureCon-
straint): speciﬁes that a FeatureModel contains a set
of feature’s constraints;
•
hasSetOfFeatures (Group, Feature): speciﬁes that a
Group constraint contains a set of features (which may
not be empty);
•
hasSourceFeatures (Depend/Exclude, Feature): speci-
ﬁes that a Depend or Exclude constraint has a set of
source features (which must have at least one feature);
•
hasTargetFeatures (Depend/Exclude, Feature): speci-
ﬁes that a Depend or Exclude constraint has a set of
target features (which must have at least one feature);
•
isBasedOn
(SoftwareProductLine,
FeatureModel):
speciﬁes
that
a
SPL
is
based
on
exactly
one
FeatureModel. It is a functional property;
•
isChildOf (Feature, Feature): speciﬁes that a feature
is child of exactly one another Feature. It is a func-
tional property and it is also the inverse property of
isParentOf;
•
isParentOf (Feature, Feature): speciﬁes that a feature
contains a set of children features. It is the inverse
property of isChildOf.
C. Axioms of the ontology
The classes and relationships described above express a
taxonomy of the OntoSPL ontology. In order to describe it in
a detailed and formal way, it must be governed with axioms.
All axioms of the OntoSPL are deﬁned in description logics
(DL) and the OWL syntax used to represent it is summarized
in Table I. The data properties, classes axioms and object
properties are, respectively, presented in Tables II, III and IV.
TABLE I. SUMMARY OF DL SYNTAX.
Notations
Explanation
⊤
Superclass of all OWL classes
A ⊑ B
A is a subclass of B
A ⊑ ¬ B
A and B are disjoint class
A ⊓ B
Class intersection
A ⊔ B
Class union
A ≡ B
Class equivalence
⊤ ⊑ ∀ P.A
Range of property is class A
∃ / ∀ P.A
allValuesFrom/someValuesFrom restriction
that for every instance of this class that has instances of property P, all
some of the values of the property are members of the class A
TABLE II. DATA PROPERTIES AXIOMS OF ONTOSPL.
Data Property
Source
Data Type
description
SoftwareProductLine
String
name
SoftwareProductLine;
FeatureModel;Feature;
String
FeatureConstraint
exclusive
Alternative
String
typeConstraint
Group
String
currentState
Feature
Boolean
TABLE III. CLASSES AXIOMS OF ONTOSPL.
Class
Axioms
Alternative ⊑ F eature
Alternative
Alternative ⊑ ¬Optional
Alternative ⊑ ¬Mandatory
Alternative ⊑ ¬ORF eature
Alternative ⊑ ¬Root
Depend ⊑ F eatureConstraint
Depend ⊑ ¬Exclude
Depend
Depend ⊑ ¬Group
Exclude ⊑ F eatureConstraint
Exclude ⊑ ¬Depend
Exclude
Exclude ⊑ ¬Group
Feature
F eature ⊑ ⊤
Feature Constraint
F eatureConstraint ⊑ ⊤
Feature Model
F eatureModel ⊑ ⊤
Group ⊑ F eatureConstraint
Group
Group ⊑ ¬Depend
Group ⊑ ¬Exclude
Mandatory ⊑ F eature
Mandatory
Mandatory ⊑ ¬Optional
Mandatory ⊑ ¬Alternative
Mandatory ⊑ ¬ORF eature
Mandatory ⊑ ¬Root
Optional ⊑ F eature
Optional
Optional ⊑ ¬Mandatory
Optional ⊑ ¬Alternative
Optional ⊑ ¬ORF eature
Optional ⊑ ¬Root
ORF eature ⊑ F eature
ORFeature
ORF eature ⊑ ¬Mandatory
ORF eature ⊑ ¬Alternative
ORF eature ⊑ ¬Optional
ORF eature ⊑ ¬Root
Root ⊑ F eature
Root
Root ⊑ ¬Mandatory
Root ⊑ ¬Alternative
Root ⊑ ¬ORF eature
Root ⊑ ¬Optional
Software Product Line
SoftwareP roductLine ⊑ ⊤
III.
DSPL PRODUCTS RECONFIGURATION
In SPL engineering, the applications are built by reusing
domain artifacts and by exploiting the product line variability.
To create instances (products) of a Software Product Line, one
must choose the features that will be present in the product,
following the constraints of the features model.
A SPL product contains a speciﬁc subset of features. In
the DSPL context, by contrast, the requirements (expressed as
feature models) of these products vary at runtime. Thus, these
models must be reasoned or queried during the execution of
a product, allowing it to be self-reconﬁgured at runtime, as
required by DSPL engineering.
In this sense, OntoSPL may represent a single product
based on a SPL feature model speciﬁed. It is used as the
decision model on where the SPL variations are selected.
Hereafter, we present how to represent a product on the
ontology. Then, we present a set of dynamic reconﬁguration
scenarios which were applied to a running example of the
547
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

TABLE IV. OBJECT PROPERTIES AXIOMS OF ONTOSPL.
Object Property
Axioms
hasRootFeatures
∃ hasRootFeatures Thing ⊑ FeatureModel
⊤ ⊑ ∀ hasRootFeatures (∃ hasRootFeatures RootFeature)
hasSetOfAlternativeFeatures
hasSetOfAlternativeFeatures ≡ hasSetOfAlternativeFeatures−
∃ hasSetOfAlternativeFeatures Thing ⊑ Alternative
⊤ ⊑ ∀ hasSetOfAlternativeFeatures (≥ 1 hasSetOfAlternativeFeatures Alternative)
hasSetOfConstraints
∃ hasSetOfConstraints Thing ⊑ FeatureModel
⊤ ⊑ ∀ hasSetOfConstraints (∀ hasSetOfConstraints (Depend ⊔ Exclude ⊔ Group))
hasSetOfFeatures
∃ hasSetOfFeatures Thing ⊑ Group
⊤ ⊑ ∀ hasSetOfFeatures (∃ hasSetOfFeatures Feature)
hasSourceFeatures
∃ hasSourceFeatures Thing ⊑ Depend
∃ hasSourceFeatures Thing ⊑ Exclude
⊤ ⊑ ∀ hasSourceFeatures (≥ 1 hasSourceFeatures Feature)
hasTargetFeatures
∃ hasTargetFeatures Thing ⊑ Depend
∃ hasTargetFeatures Thing ⊑ Exclude
⊤ ⊑ ∀ hasTargetFeatures (≥ 1 hasTargetFeatures Feature)
isBasedOn
⊤ ⊑ ≤ 1 isBasedOn Thing
∃ isBasedOn Thing ⊑ SoftwareProductLine
⊤ ⊑ ∀ isBasedOn (= isBasedOn FeatureModel)
isChildOf
isChildOf ≡ isParentOf −
⊤ ⊑ ≤ 1 isChildOf Thing
∃ isChildOf Thing ⊑ Feature
⊤ ⊑ ∀ isChildOf (= isChildOf Feature)
isParentOf
isChildOf ≡ isParentOf−
⊤ ⊑ ≤ 1 isParentOf− Thing
∃ isParentOf Thing ⊑ Feature
⊤ ⊑ ∀ isParentOf Feature
ubiquitous domain published in the literature, a simpliﬁed
smart hotel [8].
A. DPSL products conﬁguration
OntoSPL supports the instantiation of products based on
the SPL in order to facilitate the reconﬁguration of the product
when it is necessary. In this sense, the property current state
of the Feature class indicates whether the feature belongs or
not to a particular product. This property presents the follow-
ing range of values: {”eliminated” : string, ”selected” :
string}. Such a property can only receive the values: selected,
case the feature must be in the product, or eliminated, case the
feature must not be in the product.
Hence, one can reason in the ontology to perform dynamic
reconﬁguration in an arbitrary product. After deﬁning the
features that may be present in the product to be created, there
is only necessary to set the property current state for each
feature instantiated in a product.
For instance, Figure 2 depicts the feature model of the
Simpliﬁed Smart Hotel (extracted from [8]). Its mandatory
features are represented by a small ﬁlled circle above the
feature name (e.g., Automated Illumination). Optional features
are represented by a small circle not ﬁlled (e.g., Piped Music,
Security and Alarm). Alternative features share the same parent
feature and are graphically represented by a not ﬁlled arc below
the parent feature; such arc means that one and only one of
the child features must be chosen (e.g., Silent Alarm,Siren and
Visual Alarm). Finally, the or-features (e.g., Infrared Sensor
and Volumetric Sensor) are represented by a ﬁlled arc, in a
similar way to alternative features.
As shown in Figure 2, the gray features indicate which are
the selected features for a product conﬁguration. The current
conﬁguration of the simpliﬁed smart hotel includes the Piped
Music, Security, In Room Detection, Volumetric Sensor, Alarm,
Silent Alarm, Automated Illumination features and Lighting
by Occupancy features. However, the white features represent
potential variants of a product conﬁguration [8].
B. Dynamic reconﬁguration scenarios
Once a product is speciﬁed in the OntoSPL ontology, it can
be reconﬁgured dynamically according to different scenarios.
This section describes scenarios directly related to changes
in the type of a feature and also changes related to product
conﬁguration.
In this sense, to specify this product in the OntoSPL ontol-
ogy, one must set the current state property of these features
to the ”selected” value and ”eliminated” for the others features.
For instance, in our running example, the gray features of
Figure 2 assume the ”selected” value in the OntoSPL, whereas
the white features assume the ”elimated” value.
In the sequel, we present three scenarios (speciﬁed in
SPARQL 1.1 [9]) which can be executed for changing SPL
products at runtime. Note that these scenarios are presented by
applying them to our running example, but they have generic
purposes.
1) Changing an optional feature to mandatory feature:
Changing an optional feature to a mandatory one demands
a simple change scenario in the requirements of a particular
feature. Such change does not have a great impact in the feature
model, since it is not necessary to create/remove features on
the feature model.
Let’s suppose, for an arbitrary reason, that an Smart Hotel
requires security requirements. In this context, there is the
need to make the ”Security” feature a mandatory one. This
way, the query on Figure 3 could be used to perform such
reconﬁguration.
This query updates the property type of the feature being
changed. Note that, the optional type is deleted while the
mandatory type is inserted. As consequence, the feature will
be mandatory in the product.
2) Selecting an optional feature in a product: This is one
of the most common changing scenarios in SPLs. Usually, a
product is ﬁrstly generated according to customer’s needs at
548
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

Figure 2. Feature model of the simpliﬁed smart hotel (extracted from [8]).
	
	

	


		
 !!	
"
#
 !!	
$%
#
 !	
!&'(&
#
Figure 3. Changing an Optional feature to Mandatory feature.
development time and includes several features and, in such
moment, a optional feature would not be selected to be in
the product. However, in a later moment, it is possible that a
client demands the inclusion of an optional feature that was
not previously addressed by the conﬁgured product.
In the DSPL context, it is important to specify a mechanism
which can reconﬁgure the product to reﬂect the current re-
quirements of the client. For instance, in our running example,
despite the hotel having alarm, the feature Bliking lights was
not originally selected to be in the Smart Hotel conﬁguration.
However, in a changing scenario, the client would like to
include it in his product.
To achieve such change, it is necessary to change the
property that indicates that the feature is present or not in the
system in the ontology of the product at runtime. The update of
this property can be realized by the SPARQL query on Figure
4.
	
	

	


	
	 ! 
"

	
	 	! 
"
	
 #$	 "
Figure 4. Selecting An Optional Feature in a Product.
As can be seen in the query, after setting the status of the
Bliking Lights feature as ”Selected”, such feature is included
in the product.
3) Changing an Alternative Feature: Usually, it is neces-
sary to select alternative ways to realize a product requirement.
The alternative type of features speciﬁes a design space of
variations on which a product can use. A product conﬁguration
requires the selection of one of the variants on such kind of
features, but it is possible that a client would be not satisﬁed
with the variant selected and wants to reconﬁgure a product
with another variant.
For instance, in our running example, the selected variant of
alarm is the silent type. However, one could require to change
from the Silent Alarm feature to the Siren one.
Figure 5 speciﬁes a SPARQL query which makes such
variant change. This query is similar to the one presented in
Subsection III-B2, however, it is not only a selection of a new
feature, but rather the substitution of one feature by another.
Thus, there is the need to remove the existing feature and then,
add the new feature.
	
	

	


	 	! 
"	 ! 
#

	 ! 
"	 	! 
#

"	
  
	
 $ 

Figure 5. Changing an Alternative Feature.
As deﬁned in the query, the Silent Alarm would be elim-
inated from the hotel and the Siren would be enabled in the
product. After executing this query, the selected type of Alarm
is the Siren feature.
IV.
RELATED WORKS
Using ontologies in the development of SPLs has been
addressed by several studies in the literature. In fact, it was
found some studies with the particular aim of using ontology
for representing feature models [3][4]. Furthermore, we have
549
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

found only one study which makes use of ontology-based
feature modeling in the design of DSPLs [10].
Wang et al. [3] presents a technique to design ontology-
based feature models, by representing feature models as OWL
classes and properties. Moreover, they use OWL reasoning
engines to check for inconsistences of feature conﬁgurations
automatically. However, since the features in such modeling
are represented as OWL classes and properties, every change
in the feature model requires a structural modiﬁcation in the
ontology.
OntoSPL ontology presents an alternative way for model-
ing ontology-based feature models. It proposes a predeﬁned
structure of classes and properties and suggests the creation of
features model as OWL instances/individuals of such structure.
This alternative way for feature modeling is more suitable than
the one of [3] for dynamic reconﬁgurations of features.
In order to change a feature model using Wang’s ontology
[3], for instance, adding a new feature, it would be necessary
to change the structure of the ontology and then it would be
also necessary to generate the ontology mapping code again.
Thus, applying such changes in an application would require to
stop the execution of the system. On the other hand, using the
OntoSPL, changes are performed at the instances level. This
characteristic allows to change instances at runtime, i.e., it is
not necessary to generate the ontology mapping code again
and hence, it would not be necessary to stop the application.
The work by Zaid et al. [4] also presents an ontology
to represent feature models based on OWL instances which
is similar to our ontology. However, it is focused on the
automatic consistency veriﬁcation of feature models and it was
not conceived to support dynamic reconﬁguration of features.
Thus, it does not consider important issues regarding changes
at runtime, for example, properties related to the status of the
feature.
Regarding the use of ontology in the development of dy-
namic Software Product Lines, Kaviani et al. [10] use ontology
to annotate feature models covering non-functional require-
ments modeling in the context of ubiquitous environments.
However, it also represents feature models as proposed in [3],
thus the same limitations regarding the impact of changes
in the feature model are also applicable to it. Moreover, it
is noteworthy that the dynamic reconﬁguration effort using
the OntoSPL ontology is lower, since it is only necessary
to change product conﬁgurations through SPARQL queries
without needing to generate code to manipulate a product.
V.
CONCLUSION AND FUTURE WORKS
In this paper, we presented the OntoSPL ontology, which
is used to specify feature models in a formal way with the
special aim to support automatic reconﬁgurations of products
in the context of Dynamic Software Product Line.
To illustrate how to reconﬁgure DSPL products using such
ontology, we also speciﬁed three SPARQL queries that were
applied to an existent running example in the literature.
This study can be considered as a ﬁrst step towards
selecting a suitable way for formalizing feature models to be
used in the context of DSPLs. Future works should include
the conduction of a controlled experiment in different con-
texts to evaluate the effectiveness of OntoSPL in comparison
with other ontologies regarding its capabilities (e.g., time to
realize some change, ﬂexibility and so on) for performing
reconﬁguration at runtime. Moreover, we intend to incorporate
some consistency checking mechanism in OntoSPL to validate
product reconﬁgurations. We also intend to deﬁne a DSPL
process based on the OntoSPL.
ACKNOWLEDGMENTS
This work has been supported by the Brazilian institu-
tions: Conselho Nacional de Desenvolvimento Cient´ıﬁco e
Tecnol´ogico (CNPq) and Coordenac˜ao de Aperfeicoamento de
Pessoal de N´ıvel Superior (CAPES).
REFERENCES
[1]
K. Pohl, G. Bockle, and F. Van Der Linden, Software product line
engineering.
Springer, 2005, vol. 10.
[2]
M. Hinchey, S. Park, and K. Schmid, “Building dynamic software
product lines,” Computer, vol. 45, no. 10, 2012, pp. 22–26.
[3]
H. H. Wang, Y. F. Li, J. Sun, H. Zhang, and J. Pan, “Verifying feature
models using owl,” Web Semantics: Science, Services and Agents on
the World Wide Web, vol. 5, no. 2, 2007, pp. 117–129.
[4]
L. A. Zaid, F. Kleinermann, and O. De Troyer, “Applying semantic
web technology to feature modeling,” in Proceedings of the 2009 ACM
symposium on Applied Computing.
ACM, 2009, pp. 1252–1256.
[5]
N. Guarino, Formal Ontology in Information Systems: Proceedings of
the 1st International Conference June 6-8, 1998, Trento, Italy, 1st ed.
Amsterdam, The Netherlands, The Netherlands: IOS Press, 1998.
[6]
K. Czarnecki, C. H. Peter Kim, and K. T. Kalleberg, “Feature models
are views on ontologies,” in Proceedings of the 10th International on
Software Product Line Conference, ser. SPLC ’06.
Washington, DC,
USA: IEEE Computer Society, 2006, pp. 41–51.
[7]
K. Kang, S. Cohen, J. Hess, W. Nowak, and S. Peterson, Feature-
Oriented Domain Analysis (FODA) Feasibility Study, 1990.
[8]
C. Cetina, P. Giner, J. Fons, and V. Pelechano, “Prototyping dynamic
software product lines to evaluate run-time reconﬁgurations,” Science
of Computer Programming, vol. 78, no. 12, 2013, pp. 2399 – 2413,
special Section on International Software Product Line Conference 2010
and Fundamentals of Software Engineering (selected papers of {FSEN}
2011).
[9]
W3C,
“Sparql
1.1
query
language,”
Available
in
http://www.w3.org/TR/2012/PR-sparql11-query-20121108/,
retrieved:
October, 2014.
[10]
N. Kaviani, B. Mohabbati, D. Gasevic, and M. Finke, “Semantic annota-
tions of feature models for dynamic product conﬁguration in ubiquitous
environments,” in Proceedings of the 4th International Workshop on
Semantic Web Enabled Software Engineering, in collaboration with
International Semantic Web Conference (ISWC), Karlsruhe, Germany,
2008.
550
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

