Optimization and Evaluation of
Bandwidth-Efﬁcient Visualization for Mobile Devices
Andreas Helfrich-Schkarbanenko, Roman Reiner, Sebastian Ritterbusch, and Vincent Heuveline
Engineering Mathematics and Computing Lab (EMCL)
Karlsruhe Institute of Technology (KIT)
Karlsruhe, Germany
{andreas.helfrich-schkarbanenko, roman.reiner, sebastian.ritterbusch, vincent.heuveline}@kit.edu
Abstract—The visual analysis of large numerical simulations
on mobile devices needs remote parallelizable visualization
methods for low-bandwidth and high-latency networks. Based
on a mathematical model for multi-layered planar impostor
representation of arbitrary complex and unbounded scenes,
we adapt an algorithm for optimal viewport placement from
the theory of optimal experimental design. The results are
evaluated in a realistic setting, proving the practical relevance
of the theoretical ﬁndings, leading to a bandwidth-efﬁcient
remote visualization concept for high performance computing
simulation results.
Keywords-Remote Visualization, Mobile Visualization, Optimal
Experimental Design, Bandwidth Efﬁciency.
I. INTRODUCTION
Remote visualization is vital wherever local storage,
data transfer rates or graphical capabilities are limited.
Even though the capabilities of modern smartphones are
increasing rapidly, without efﬁcient visualization methods as
introduced in [1] many desirable applications are impeded
by limitations of the current hardware [2].
Image-based rendering techniques [3] are widely used to
reduce the geometric complexity of virtual environments by
replacing parts of a scene with a textured representation
approximating the original geometry. Since these so-called
impostors have a signiﬁcantly simpliﬁed geometry, parallax
errors [4] occur when rendering the approximation. An
impostor is generated for an initial viewport (that is, a
position and viewing direction) and is said to be valid as
long as the visual difference to the (hypothetically rendered)
original geometry is below a certain threshold.
In our application, these impostors are rendered remotely
on render servers and streamed to a mobile device where
they are used to approximate the scene. One substantial
advantage of the impostor approach [5] is that the render
time on the device only depends on the number of impostors
and the resolution of the textures, not on the amount of data
they display. As long as servers can generate and transfer the
impostor textures sufﬁciently fast, every scene can be dis-
played remotely, regardless of its actual complexity. In this
setting, network bandwidth is the bottleneck and a careful
analysis of bandwidth consumption becomes mandatory.
We develop a mathematical model that allows us to quan-
tify the display error and propose an approximation method
that proves to be optimal with respect to the derived error
metric. We can show that our method signiﬁcantly reduces
the total amount of image data that needs to be transferred.
The key aspects of our method are illustrated in Figure 1:
In this simpliﬁed two-dimensional case, a traditional remote
visualization using one layer would need at least 32 images
to provide the same visual accuracy as one layer set of 5
images. This effect is ampliﬁed by each additional degree
of freedom of the viewer. Based on the error metric that
was already presented in [1], this paper extends the method
described in [6] with respect to optimally chosen viewport
sets locations for ﬁxed numbers of layers, and evaluates the
realistic performance of the concepts.
In the following Section II, we discuss related work.
Then we introduce the underlying mathematical model in
Section III, on which we derive the fundamental error
metrics. In Section IV, this leads us to the optimal impostor
placement and directly corresponding bounds for the visu-
alization error of one impostor set. The practical outcome
of the ﬁndings, using as many impostor sets as needed,
is proven and evaluated theoretically in Section V. The
general placement of viewports for impostor sets is solved by
adaption of an algorithm from optimal experimental design
to the visualization problem in Section VI. The proposed
method is evaluated in Section VII in a realistic setting,
which leads us to the conclusions in Section VIII.
II. RELATED WORK
A variety of image-based rendering techniques are re-
viewed in [5] and [3]. The ﬁrst paper focuses mainly on
techniques using planar impostors but also mentions more
exotic approaches like depth images (planar impostors with
per-pixel depth information) and light ﬁelds. These and other
techniques, such as view morphing and view dependent
textures, are examined in more detail in the second paper.
In the majority of cases, planar impostors stacked with
increasing distance to the observer are used (see [4], [7],
178
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

(a) 32 impostor sets with one layer each
(b) Four impostor sets with three layers each
(c) One impostor set with ﬁve layers
Figure 1.
An impostor representation is only valid inside a small region around the initial viewport for which it was originally created. For observer
viewports within this validity region (indicated by the dotted line) the display error does not exceed a given maximum value. To faithfully approximate
the scene for all observer viewports inside the shaded area, several impostor sets have to be transmitted.
The validity regions can be enlarged (while keeping the maximum error unaltered) by increasing the number of layers per impostor set. As the number
of required impostor sets decreases faster than the number of layers per set increases, this signiﬁcantly reduces the total number of layers needed to
approximate the scene to a given accuracy .
[8]), usually to approximate distant parts of the scene or
single objects. In contrast, our approach uses impostors to
represent the full scene.
For large objects, different parts of continuous surfaces
can end up on different impostors which makes them tear
apart when viewed from a shallow angle. Avoiding this
particular problem was one focus of the method developed in
[4]. Another interesting use of planar impostors is [9], which
treats the rendering of volume data on mobile phones.
Several approaches using geometrically more complex
impostors can be found in [8], [10] and [11]. In [5], so-
called billboard clouds are used to approximate the shape
of an object using several intersecting planar impostors.
While the impostor creation process for this approach is
quite costly, the result allows examination from different
viewing directions.
A very current example is Street Slide [12]. Street Slide
sticks photos of front facades of urban environments to
“panorama strips” that can be browsed by sliding sideways.
The need for accurate analysis of bandwidth and accuracy
estimates is discussed in [5], [7], without further specifying
how to choose which viewports to load. A more in-depth
analysis on the subject of pre-fetching is given in [13] and
[14]. The former deﬁnes a so-called beneﬁt integral, indicat-
ing which parts of the scene – quality-wise – contribute most
to the ﬁnal image, the latter deals with rendering an indoor
scene remotely. The task of remote rendering on mobile
devices is addressed in [15] and [16], which mostly focuses
on the technical aspects of the server-client communication.
Usually, depending on the complexity of the approxima-
tion, an impostor is either easy to generate but only valid
inside a small region and thus needs to be updated very
often, or it is valid inside a large domain but complex and
difﬁcult to generate and display [3]. Since the former strains
bandwidth and the latter strains render speed, any image-
based rendering approach is usually a trade-off between
these limiting factors.
III. VISUALIZATION MODEL AND ERROR METRICS
To begin with, a mathematical model describing viewports
and projections thereon needs to be established, with which
the rendering and approximation processes can be described.
This yields an error function describing the maximum paral-
lax error of a scene as a function of the observer movement,
called domain error.
Finally, modeling the observer movement as a probability
distribution, we can describe the expected value of this error.
This interaction error will be the cost function that we intend
to minimize.
A. Perspective projection
Using homogeneous coordinates and projective transfor-
mations [17], we can express perspective projection as a
4 × 4 matrix multiplication on the projective space P3:
Deﬁnition 1. The perspective projection onto the plane x3 =
d towards the origin is a function
πd :
(
P3\{(0, 0, 0, 1)⊤}
−→
x
7−→
P3
Pdx
with the parameter d > 0 deﬁning the proximity of the
projection plane.
From the intercept theorems, one can easily see that
the perspective projection of a point v = (v1, v2, v3)⊤ ∈
R3, v3
̸=
0 onto the plane x3
=
d is given by
179
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

( d
v3 v1, d
v3 v2, d)⊤ which, using homogeneous coordinates,
equals (v1, v2, v3, v3
d )⊤. This yields the projection matrix
Pd :=




1
0
0
0
0
1
0
0
0
0
1
0
0
0
1/d
0



 .
B. Viewports
Any viewport can be described by ﬁve values c1, c2, c3 ∈
R, ϑ ∈ [−π/2, π/2], ϕ ∈ [−π, π), deﬁning an afﬁne transfor-
mation χ, which is the combination of a translation by the
vector (c1, c2, c3)⊤ followed by a rotation around the x1-
axis with the angle ϑ and a rotation around the x2-axis with
the angle ϕ (cf. Figure 2). Actually, there is a sixth value
which represents a rotation around the viewing direction.
Such a rotation, however, does not change the image besides
rotating it. We assume the rotation to be lossless, which is
why we do not need it for our purposes.
Figure 2.
The angles ϕ and ϑ of a viewport χ
We
condense
all
ﬁve
values
into
a
single
vector
c := (c1, c2, c3, ϑ, ϕ)⊤. When describing viewports, we
will use this vector c and the associated transformation
χc interchangeably. In particular, we will identify sets of
viewports with subsets of R5:
Deﬁnition 2. The set
X := R3 × [−π/2, π/2] × [−π, π) ⊂ R5
will be called the viewport set. For all practical purposes,
however, we want to restrict to viewports inside a given set
of feasible viewports Λ ⊂ X.
Projective matrix representations of χc and its inverse are
Qc =

 Bϑ,ϕ
Bϑ,ϕc
0
1


and
Q−1
c
=

 B⊤
ϑ,ϕ
−c
0
1


where
Bϑ,ϕ :=


cos ϕ
− sin ϕ sin ϑ
− sin ϕ cos ϑ
0
cos ϑ
− sin ϑ
sin ϕ
cos ϕ sin ϑ
cos ϕ cos ϑ

 .
We can now calculate a matrix representation of a projec-
tion onto an arbitrary viewport, by combining the matrices
above with the matrix representations of the default projec-
tion πd.
Deﬁnition 3. Let χ be a viewport with an associated matrix
representation Q and let πχ denote a projection onto the
viewport χ. Then, a matrix representation of πχ is given
by Pχ,d = QPdQ−1, where Pd is the perspective projection
matrix deﬁned in Deﬁnition 1.
C. Rendering process
Let renderable objects be located in a domain Ω. We aim
to simplify the scene by dividing Ω into m disjoint parts
Ωi called cells, replacing each with a planar representation
of their contained objects. These so-called impostors will be
created for the same initial viewport(s), that is, for a certain
viewport we will create an impostor set with one impostor
per cell, all for that particular viewport. This will be done
for n initial viewports resulting in n impostor sets with m
impostors each.
As long as the current viewport matches the initial view-
port for which the impostors have been created, the impostor
representation coincides with the image of the actual scene.
Changing the viewport, however, will introduce parallax er-
rors, since depth information is lost in the impostor creation
process.
To determine this error, we will ﬁrst regard a single cell
Ωi and a single vertex v ∈ Ωi. For a ﬁxed initial viewport χ1
we calculate the impostor representation v of the actual point
v. Then we consider a variable viewport χ and calculate the
screen coordinates v′ of v and v′ of v as functions of the
viewports χ and χ1 (cf. Figure 3).
Figure 3.
Rendering process for changed viewport
D. The domain error
If we reiterate the procedure above, we obtain two images
for each point in Ω: one image of itself (v′, depending on
χ) and one of its impostor representation (¯v′, depending on
both χ and χ1). The screen distance of these two, measured
in (sub-)pixels is called the screen space error. As we are
not interested in the error of a single point, but rather in
error functions expressing the error of the entire scene, for
example the mean error or the maximum error, we aggregate
the screen space error over all points in Ω. As the distribution
180
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

of vertices inside Ω is supposed to be unknown, we assume
a uniform distribution and integrate the screen space error
over the entire domain Ω. We will be using the maximum
error which replaces the integral with a supremum.
Deﬁnition 4. Denote the number of cells with m. For an
initial viewport χ1 we deﬁne the domain error
D(χ, χ1)
:=
sup
v∈Ω
v′(χ) − ¯v′(χ, χ1)

2
=
max
0≤i≤m
n
sup
v∈Ωi
v′(χ) − ¯v′(χ, χ1)

2
o
.
This domain error depends on a variable observer view-
port χ and the ﬁxed viewport χ1, for which the displayed
impostor set was initially created. The dependence on χ
implies that we cannot evaluate our impostor approximation
without knowledge of the observer movement. Clearly, we
want to optimize our setup a priori, and hence we need to
ﬁnd a way to evaluate it without knowledge of χ.
E. The interaction error
Assume that we have n impostor sets at hand for view-
ports χ1, . . . , χn ∈ Λ ⊂ X. As before, we denote the
observer’s viewport with χ ∈ Λ. Since we can choose
from several impostor sets, we display that set whose initial
viewport χk satisﬁes
D(χ, χk) = min
1≤j≤n D(χ, χj).
For 1 ≤ k ≤ n let Ξk denote that subset of Λ, on which
D(χ, χk) is the smallest of all domain errors:
Ξk :=

χ ∈ Λ
 D(χ, χk) = min
1≤j≤n D(χ, χj)
	
.
(1)
Next, we deﬁne a probability distribution P with an asso-
ciated probability density function µ on Λ, for instance,
a uniform distribution over Λ or a normal distribution
around the current viewport χ. These distributions represent
the probability for the respective viewport to occur, thus
modeling the expected observer movement. We can then
calculate the expected value of the error by integrating
the domain error D over Λ with respect to the probability
distribution P.
Deﬁnition 5. Let n ≥ 1. We deﬁne the interaction error
I : Λn → R, where
I(χ1, . . . , χn)
:=
Z
Λ
min
1≤j≤n D(χ, χj) dP(χ)
(2)
=
n
X
j=1
Z
Ξj
D(χ, χj) dP(χ).
The following Lemma shows that the interaction error will
decrease as we add more viewports.
Lemma 1. Let χ1, . . . , χn ∈ Λ. Then
I(χ1) ≥ I(χ1, χ2) ≥ · · · ≥ I(χ1, . . . , χn).
Proof: For 1 ≤ k ≤ n, it is
I(χ1, . . . , χk)
=
Z
Λ
min
1≤j≤k D(χ, χj) dP(χ)
≤
Z
Λ
min
1≤j≤k−1D(χ, χj) dP(χ)
=
I(χ1, . . . , χk−1).
IV. IMPOSTOR PLACEMENT AND ERROR BOUNDS
The efﬁciency of the proposed method is based on an
optimal choice of initial viewports for the impostor sets, as
well as an optimized cell partition for each set.
Theorem 2. Given renderable objects located in
Ω :=

(x1, x2, x3, 1)⊤ ∈ P3  0 < a0 < x3 < am+1 ≤ ∞
	
,
the optimal cell boundaries for viewport translations are
given by ai = (1/a0 − iδ)−1, i = 1, . . . , m for a suitable
δ(m) > 0, and the optimal impostor placement with respect
to the error metric is
di = 2aiai+1
ai + ai+1
.
Note that m is ﬁnite even for domains with inﬁnite depth,
that is, when am+1 = ∞ for which dm = 2am.
Proof: For viewport translations the minimum of the
domain error D with respect to the projection plane distance
d ∈ [a, b] can be found analytically. For details see [18,
Theorem 3.2].
With this impostor placement, we have the following
asymptotic behavior of the error with respect to viewport
translations:
Theorem 3. For a ﬁxed maximal screen space error
ε > 0, the radius r of maximal permissible viewport change
is proportional to the number of impostors per set m.
Proof: This property emerges during the proof of The-
orem 2. For details see [18, Remark 3.5].
This Theorem shows that increasing the number of im-
postors per set will strongly decrease the interaction error,
but the number of displayable impostors is bounded by
the graphical capabilities of mobile devices. Due to such
limitations, several impostors sets have to be transmitted.
Denote the number of impostor sets with n. Under certain
assumptions we can show that the inspection error can be
bounded by
C1n−1/5 ≤ I(χ1, . . . , χn) ≤ C2n−1/5,
for constants C1/2 = C1/2(Λ, m). Proving these bounds will
be the endeavor of the next section.
181
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

V. MODEL EVALUATION
Proposition 1. Using the R5-parametrization of the view-
port space, we can regard the domain error D(χ, χk) as a
continuous function f : R5 × R5 → R which, for moderate
viewport changes, behaves almost linear.
More precisely, we can ﬁnd positive constants a1, . . . a5
and ¯a1, . . . , ¯a5 such that
∥A1(x − y)∥ ≤ f(x, y) ≤ ∥A2(x − y)∥
(3)
where A1 := diag(a1, . . . , a5) and A2 := diag(¯a1, . . . , ¯a5).
Proposition 2. The matrices A1 and A2 depend on the
number of cells m. For viewport translations they are
proportional to m−1 as a direct consequence of Theorem 3.
Before proceeding, we need the following Lemmata.
Remark 1. In the following A = B+C means that the set A
is the direct sum of the sets B and C, that is, A = B∪C and
B ∩ C = ∅. In particular, vol (A + B) = vol (A) + vol (B) .
Similarly, A = B − C means that B = A + C, that is,
C ⊂ B and vol (B − C) = vol (B) − vol (C).
Lemma 4. Let G be a bounded, measurable, d-dimensional
subset of Rd and let B be a d-dimensional ball (with respect
to a norm ∥·∥) of equal volume (cf. Figure 4a). Then
Z
G
∥x∥ dx ≥
Z
B
∥x∥ dx.
Proof: Denote the radius of B with R. Due to G =
G ∩ B + G\B and B = G ∩ B + B\G, we can express G
as G = (B − B\G) + G\B. As the volumes of G and B
are equal, this also implies vol (G\B) = vol (B\G).
Moreover, the distance from the origin to all points in
G\B is larger than R while for all points in B\G it is
smaller. Hence,
Z
G\B
∥x∥ dx ≥
Z
G\B
R dx = R vol (G\B)
and, conversely,
Z
B\G
∥x∥ dx ≤
Z
B\G
R dx = R vol (B\G) .
This implies
Z
G
∥x∥ dx
=
Z
B
∥x∥ dx −
Z
B\G
∥x∥ dx +
Z
G\B
∥x∥ dx
≥
Z
B
∥x∥ dx − R

On the right-hand side, we have to evaluate n integrals of
the form
R
G f(x, y) dx. Using (3) we deﬁne a transformation
of coordinates Φ(x) := A1(x − y) (which is the same for
all n integrals) and obtain
Z
G
f(x, y) dx ≥
Z
G
∥Φ(x)∥ dx =
1
det(A1)
Z
Φ(G)
∥x∥ dx.
Applying this to (4) yields
I(χ1, . . . , χn) ≥ (det(A1)vol (Λ))−1
n
X
k=1
Z
Φk(Ξk)
∥x∥ dx.
(5)
Using Lemmata 4 and 5 (with d = 5), we obtain
n
X
k=1
Z
Φk(Ξk)
∥x∥ dx ≥
n
X
k=1
Z
Bk
∥x∥ dx ≥ n
Z
B
∥x∥ dx,
where
vol (B)
=
1
n
n
X
k=1
vol (Bk) = 1
n
n
X
k=1
vol (Φk(Ξk))
=
1
n det(A1)vol (Λ) .
(6)
With this, the estimation (5) yields
I(χ1, . . . , χn) ≥ (det(A1)vol (Λ))−1 n
Z
B
∥x∥ dx
(7)
Now, we choose to use the Euclidean norm ∥·∥ = ∥·∥2 for
which a 5-dimensional ball with radius R has the volume
vol (B) =
8
15π2R5. Then, (6) implies
R =
 15
8nπ2 det(A1)vol (Λ)
1/5
.
Hence, using Lemma 6,
Z
B
∥x∥ dx = 5
6n det(A1)vol (Λ)
 15
8nπ2 det(A1)vol (Λ)
1/5
.
Inserting this into (7) we ﬁnally obtain
I(χ1, . . . , χn) ≥ 5
6
 15
8nπ2 det(A1)vol (Λ)
1/5
.
This theorem shows, that the efﬁciency of any choice of
impostor sets cannot be better than the given estimate. The
following theorem constructively proves, that a choice of
impostor sets with the desired asymptotic dependence exists,
that is, that this estimate is actually achievable.
Theorem 8. Let Λ be bounded with a uniform distribution
and let ˜Λ ⊃ Λ be an enclosing cuboid. Then, there is a set of
viewports χ1, . . . χn for which the interaction error satisﬁes
I(χ1, . . . , χn) ≤ C2n−1/5,
with the constant
C2 := π2
36
(max{¯a1, . . . , ¯a5}diam(˜Λ))6
det(A2)vol (Λ)
,
where A2 := diag(¯a1, . . . , ¯a5) with constants ¯ai > 0 as in
Proposition 1.
Proof: To begin with, we will prove the assertion for
those n which are the ﬁfth power of a whole number, that
is, for n
1/5 ∈ N. The general case will be derived from this
case later.
First, a bounded set Λ can be embedded into a cuboid ˜Λ.
For an n chosen as above, there is a regular decomposition
of ˜Λ into ﬁve-dimensional cuboids Ξk with initial viewports
χk at their respective centers.
Using the estimation f(x, y) ≤ ∥A2(x − y)∥ = ∥Ψ(x)∥
with the same arguments as in the proof of Theorem 7, we
obtain
I(χ1, . . . , χn) ≤ vol (Λ)−1
n
X
k=1
Z
Ξk
D(χ, χk) dχ
≤ (det(A2)vol (Λ))−1
n
X
k=1
Z
Ψk(Ξk)
∥x∥ dx
≤ (det(A2)vol (Λ))−1 n
Z
B
∥x∥ dx,
(8)
where we used that all cuboids Ψk(Ξk) are identical and
can be embedded into a ball B in the last step. For this the
radius needs to be at least
R = 1
2diam(Ψk(Ξk)) ≥ max{¯a1, . . . , ¯a5}diam(˜Λ)
2n
1/5
.
With this and Lemma 6 we ﬁnally obtain from (8)
I(χ1, . . . , χn) ≤ π2
72
(max{¯a1, . . . , ¯a5}diam(˜Λ))6
det(A2)vol (Λ)
n−1/5.
Now, for the general case, we divide ˜Λ into ˜n :=
⌊n
1/5⌋5 ≤ n cubes. This is possible because ˜n is the ﬁfth
power of a whole number (˜n
1/5 ∈ N). Moreover,
˜n−1/5
n−1/5 =
n
1/5

n
1/5 ≤

n
1/5
+ 1

n
1/5
= 1 +
 1
n
1/5 ≤ 2,
that is, ˜n−1/5 ≤ 2n−1/5. Hence, by this and Lemma (1)
I(χ1, . . . , χn)
≤
I(χ1, . . . , χ˜n)
≤
π2
72
(max{¯a1, . . . , ¯a5}diam(˜Λ))6
det(A2)vol (Λ)
˜n−1/5
≤
π2
36
(max{¯a1, . . . , ¯a5}diam(˜Λ))6
det(A2)vol (Λ)
n−1/5.
Remark 2. As stated earlier, the matrices A1, A2 depend on
the number of cells m. With the assumptions in Proposi-
tion 2, it follows that I = O(m−1n−1/5).
183
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

VI. POSITIONING OPTIMIZATION
In general, the space decomposition into cuboids as uti-
lized in Theorem 8 is far from being optimal. For a given
number n of viewports, the optimal placement of viewports
is a high dimensional optimization problem, similar to
optimal experimental design (OED) problems.
OED provides techniques, that help to optimize the pro-
cess of computing unknown parameters in experiments from
measurements. The goal is to design the data collection pro-
cess in such a way that the sensitivity of the measurements
with respect to changes in the parameters is maximal, that is,
the covariance of the measurement errors is to be minimized.
For the most part, this section follows the description in
[19], mainly because of its conciseness. For more profound
descriptions refer to (in order of extent) [20], [21], [22].
We assume a compact experimental region Ω ⊂ Rd and
denote the unknown parameters with θ = (θ1, . . . , θp)⊤ ∈
Θ ⊆ Rp. Let yθ(x) denote the outcome of the experiment
at the location x ∈ Ω. At ﬁxed locations ξ = (ξ1, . . . , ξn)⊤,
ξk ∈ Ω we take measurements
z (ξk) = yθ (ξk) + εk
for
k = 1, 2, . . . , n,
(9)
which are prone to measurement errors modeled as indepen-
dently and identically distributed random variables εk with
mean zero and variance σ2.
To begin with, we assume a linearized model yθ (ξk) =
f(ξk)⊤θ with a response function f = (f1, . . . , fp)⊤, fk ∈
C(Ω), which allows us to rewrite (9) in matrix notation as
Z = Xθ + ε. where Z = (z(ξ1), . . . , z(ξn))⊤ ∈ Rn,
X =



f1(ξ1)
· · ·
fp(ξ1)
...
...
...
f1(ξn)
· · ·
fp(ξn)


 ∈ Rn×p ,
and ε = (ε1, . . . , εn)⊤ ∈ Rn. If X⊤X is regular, we can
compute the least squares estimate (e.g., [20, Th. 1.2.1])
ˆθ = (X⊤X)−1X⊤Z. Then, at a point x ∈ Ω, the predicted
response is
ˆz(x) := f(x)⊤ˆθ
(10)
with covariance
cov(ˆz(x)) = σ2f(x)⊤(X⊤X)−1f(x) = f(x)⊤M −1f(x),
(11)
where
M = M(ξ) := 1
σ2 X⊤X.
(12)
The design problem is to ﬁnd an optimal design ξ such
that (10) is optimal in describing the actual experiment, that
is, that cov(ˆz) is minimal, often implemented for example
in optimization of the determinant of M for D-optimality,
or of the eigenvalues of M denoted as E-optimality.
Any design ξ can be regarded as a measure on Ω [19, p.
16]: Suppose we are taking n measurements at the locations
ξ1, . . . , ξn. Then we can interpret ξ as a probability measure
on Ω if we deﬁne
ξ(x) := 1
n
n
X
k=1
δξk(x).
For such a design ξ, we can deﬁne M by
mi,j (ξ) := 1
σ2
Z
Ω
fi (x) fj (x) dξ
for i, j = 1, . . . , p, M(ξ) := (mi,j(ξ)). Similarly, the
variance function (11) can be generalized to
d(x, ξ) := f(x)⊤M(ξ)−1f(x).
An algorithm due to Wynn, Mitchell and Miller for a ﬁxed
number n-point design optimization for D-optimality reads
[19, p. 20]:
1) Begin with an arbitrary n-point design ξ(0)(n).
2) Find ξn+1 such that
d

2.
repeat
3.
I0 ← I(χ1, . . . , χn)
4.
Imin ← I0
5.
for χ ∈ Λ
6.
if I(χ1, . . . , χn, χ) < Imin
7.
χn+1 ← χ
8.
Imin ← I(χ1, . . . , χn, χ)
9.
Add χn+1 to the set of viewports
10.
Imin ← I0
11.
for i ← 1 to n + 1
12.
if I(χ1, . . . , χi−1, χi+1, . . . , χn+1) < Imin
13.
k ← i
14.
Imin
←
I(χ1, . . . , χk−1, χk+1, . . . , χn+1)
15.
Remove χk from the set of viewports
16.
(χ1, . . . , χn) ← (χ1, . . . , χk−1, χk+1, . . . , χn+1)
17. until I0 − Imin < κ
Lemma 9. Algorithm 1 is monotonically decreasing in I.
Proof: At the j-th iteration of the algorithm denote
the set of starting viewports with Xj and the viewports
added and removed in the intermediate steps with χn+1 and
χk respectively. Let further Xj+ 1
2 := Xj ∪

χn+1
	
and
Xj+1 := Xj+ 1
2 \

χk
	
. Then, I(Xj+1) = I(Xj+ 1
2 \{χk}) =
min
i
[ I(Xj+ 1
2 \{χi }) ]
≤
I(Xj+ 1
2 \{χn+1})
=
I((Xj ∪
{χn+1})\{χn+1}) = I(Xj).
We implement the algorithm for our well-understood
reduced problem of parallel viewport translations. This has
several advantages. Firstly, it is rather simple to implement;
secondly, since the domain error does not need to be
calculated by integration, it has moderate calculation times;
and lastly, since Λ is only two-dimensional, the results can
be easily displayed.
We observe that, rather than converging to a design with
n points, the algorithm, after a while, cyclically generates
subsets of cardinality n of one design with n + 1 points (cf.
Figure 5).
Figure 5.
Cyclically generated subsets for n = 7
Further analysis shows, that at this point the ﬁrst step
of the algorithm always reproduces the same (n + 1)-
point design, from which in the second step one point is
removed resulting in a subsets with n elements. That the
points are removed cyclically is due to the fact, that in
our implementation of the algorithm, from several points of
equal weakness the ﬁrst one is removed, while new elements
are always added at the end. Since, in a way, the algorithm
converges to an (n + 1)-point design, we can eradicate that
problem by simply switching the two steps of the algorithm.
Then the algorithm converges to a design with n-points, and
the subsets of cardinality n−1 are those generated between
the steps. Once the optimal n-point design has been reached,
the algorithm cyclically picks a point from the set, removes
it from the design in the ﬁrst step and immediately adds
it again in the second step. Hence, the algorithm converges
once n iterations in a row do not result in a different design.
With the two steps interchanged the algorithm does in-
deed converge to an n-point design as desired. However,
especially for large n, it requires quite a lot of steps to turn
the arbitrary initial design into a “reasonable” design which
is then optimized further. Therefore, rather than starting with
a random design, we hope to improve the algorithm by
generating an initial design as follows.
Emulating the OED optimization algorithm by Federov,
described in [19], we start with an empty design and
successively add points, which are in some sense optimal,
until we get to an n-point design. We do this by simply
running the second step of the algorithm n times. This
way, every point added to the initial design maximizes the
decrease of the inspection error, resulting in an initial design
which is rather good already. Note, that even though the
point added in the k-th step in this manner is the optimal
choice, the resulting k-point design is usually not optimal.
For example, for n = 3 and a normal distribution, the ﬁrst
point will end up in the center and the second and third point
will end up opposite of each other forming a line with the
ﬁrst point, while the optimal design would be three points
forming an equilateral triangle around the center.
An updated version of our algorithm including the gener-
ation of an initial design is given below.
Algorithm 2
1.
for j ← 1 to n
2.
Imin ← ∞
3.
for χ ∈ Λ
4.
if I(χ1, . . . , χj−1, χ) < Imin
5.
χj ← χ
6.
Imin ← I(χ1, . . . , χj−1, χ)
7.
Add χj to the set of viewports
8.
repeat
9.
I0 ← I(χ1, . . . , χn)
10.
Imin ← I0
11.
for i ← 1 to n
12.
if I(χ1, . . . , χi−1, χi+1, . . . , χn) < Imin
13.
k ← i
14.
Imin
←
I(χ1, . . . , χi−1, χi+1, . . . , χn)
185
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

15.
Remove χk from the set of viewports
16.
(χ1, . . . , χn−1) ← (χ1, . . . , χk−1, χk+1, . . . , χn)
17.
Imin ← I0
18.
for χ ∈ Λ
19.
if I(χ1, . . . , χn−1, χ) < Imin
20.
χn ← χ
21.
Imin ← I(χ1, . . . , χn−1, χ)
22.
Add χn to the set of viewports
23.
if I0 = Imin
24.
m ← m + 1
25.
else
26.
m ← 0
27. until m = n
Lemma 10. After step 7, Algorithm 2 is monotonically
decreasing in I.
Proof: At the j-th iteration of the algorithm denote the
set of starting viewports with Xj and the viewports added
and removed in the intermediate steps with χn+1 and χk
respectively. Let further Xj+ 1
2 := Xj\

χk
	
and Xj+1 :=
Xj+ 1
2 ∪

χn+1
	
. Then, I(Xj+1) = I(Xj+ 1
2 ∪ {χn+1}) =
min
χ∈Λ
h
I(Xj+ 1
2 ∪{χ})
i
≤ I(Xj+ 1
2 ∪{χk}) = I((Xj\{χk})∪
{χk}) = I(Xj).
The following Figure shows the resulting patterns of the
initial and the optimal design. The numbering of the points
reﬂects their order of appearance in phase 1, i.e., after step 7.
(a) Initial design after step 7.
(b) Optimal design after step 27.
Figure 6.
Testing Algorithm 2 for n = 12 and a normal distribution.
As long as the observer is not moving, pre-fetching the
viewports as proposed by the algorithm results in an optimal
set of data sets. However, in general, the optimal viewport
distribution for any two different observer locations do not
share any viewports. Hence, if we always pre-fetch those
data sets which are optimal for the current observer location,
we need to update all data sets whenever the observer is
moving, rendering this approach useless. Instead, since the
algorithm works by optimizing a given viewport distribution,
it can be used adaptively. That is, rather than pre-fetching
those data sets for the optimal distribution, we can update
the current state, where all updates are in order of their
importance. This way, even though the intermediate steps
might not be optimal, every update is taking account of
ΩΩ
Figure 7.
Test setup for evaluation
-10
-5
 0
 5
 10
-10
-5
 0
 5
 10
 0
 0.2
 0.4
 0.6
 0.8
 1
 1.2
 1.4
 1.6
(a) Error in x1, x2 for x3 = 0.
-10
-5
 0
 5
 10
-10
-5
 0
 5
 10
 0
 0.5
 1
 1.5
 2
 2.5
(b) Error in x1, x3 for x2 = 0.
Figure 8.
Screen space error distribution in pixels over view position
change in pixels for 5-layer viewport centered in X.
the data sets already available on the device. An optimal
distribution is only attained, if the observer is standing still
long enough for all data sets to be updated to their optimal
viewport.
VII. NUMERICAL TESTS
Since the positioning optimization is not trivial, we
present the actual performance of the method in a test
setup. In Figure 7, we see a half-inﬁnite cylinder Ω ∈ R3
with diameter w representing the visualization volume. The
unmoved camera is placed in distance d from Ω and the
visualization screen is ﬁxed at distance s from the camera.
When the camera is moving away from the center of
viewport set X, the screen is moving with the camera, but
Ω remains ﬁxed.
In the following evaluation, the parameters w = 100, d =
s = 100, and X = [−10, 10]3 with uniform distribution
were used. For illustration, the camera is not rotated, and
thus we have a three dimensional viewport space and expect
to achieve I = O(m−1n−1/3) in this setup.
First of all, Figure 8 presents the error distribution for
one viewport with 5 layers in two cut-planes through X for
camera motion x3 = 0 and x2 = 0. Moving the camera in
constant distance yields a symmetric error distribution, as it
can be seen in Figure 8 (a). Moving towards Ω results in
higher errors than moving away in Figure 8 (b), due to the
displayed size increase of nearer objects.
Figures 9 and 10 each evaluate the average interaction
error in pixels for an increasing number of viewports and
layers. As expected, the evaluation of the error appears
to be proportional to the inverse of the number of layers
I = O(m−1), as presented in Theorem 3. The increase of
186
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

 0
 1
 2
 3
 4
 5
 6
 7
 0
 20  40  60  80  100
(a) Interaction error over m layers.
-3
-2
-1
 0
 1
 2
 0
 1
 2
 3
 4
 5
(b) Log-Log scale.
Figure 9.
Interaction error for n = 1 viewport.
 0
 1
 2
 3
 4
 5
 6
 7
 0
 20  40  60  80  100
random
optimized
(a) Interaction error over n view-
ports.
 0
 1
 2
 3
 0
 1
 2
 3
 4
 5
random
optimized
(b) Log-Log scale.
Figure 10.
Interaction error for m = 1 layer.
viewports, on the other hand, involves choosing the locations
of each reference viewport.
The theoretic results detail the asymptotic behavior, but
they are quite rough for viewport numbers other than ﬁfth
power of whole numbers. Thus, the performance could
deviate from our expectations for speciﬁc cases in real
scenarious. But this is not the case, as Figure 10 illustrates
the validity of the asymptotics for realistic cases.
Due to the computational costs for viewport position
optimization, the results were compared to random distribu-
tion of viewports within X. To avoid unnecessarily skewed
results for random placing, the ﬁrst viewport was set to the
center of X. In general, the optimized placement improves
the performance, but both methods expose nearly the same
order of convergence of I ≈ O(n−1/3). The optimized curve
also shows some irregularities due to geometric effects for
certain viewport numbers, for example a cubic number of
viewports can be place positioned more efﬁciently in a cube
than any other number. The gain of optimization is signif-
icant, as for example the interaction error of 2 is reached
for n = 36 in the optimized version, whereas the random
method needs n = 59. Also the rate of convergence appears
to be slightly worse, but considering the computational costs
for optimization, a trade-off can be considered for real-time
applications.
Figure 11 illustrates the pixel errors for 27 randomly
chosen viewports with 27 layers each in two cut-planes
through X for x3 = 0 and x2 = 0, corresponding to
Figure 8. The ﬁrst viewport located at x1 = x2 = x3 = 0 is
the only viewport placed on the cut-plane, all others were
randomly distributed in X. Depending of the position, the
scene will be visualized using the layers from the viewport
-10
-5
 0
 5
 10
-10
-5
 0
 5
 10
 0
 0.02
 0.04
 0.06
 0.08
 0.1
 0.12
 0.14
 0.16
 0.18
 0.2
(a) Error in x1, x2 for x3 = 0.
-10
-5
 0
 5
 10
-10
-5
 0
 5
 10
 0
 0.02
 0.04
 0.06
 0.08
 0.1
 0.12
 0.14
 0.16
 0.18
 0.2
(b) Error in x1, x3 for x2 = 0.
Figure 11.
Screen space error distribution in pixels over view position
changes in pixels for 27 random viewports with 27 layers.
     1.5
    1.25
       1
    0.75
     0.5
    0.25
 0
 100
 200
 300
 400
 500
 0
 5
 10
 15
 20
(a) Bandwidth over layers.
       1
       0
      -1
      -2
      -3
      -4
 0
 1
 2
 3
 4
 5
 6
 7
 8
 9
 0
 1
 2
 3
 4
 5
(b) Log-Log-Log contour lines.
Figure 12.
Error contour lines for number of total images over layers.
with lowest error contribution, leading to a continuous error
function over X.
The actual performance of the method is evaluated in
Figure 12, plotting the interaction error over the total band-
width in dependence of number of layers needed. The total
bandwidth is estimated by the number of images nm for n
viewports each having m layers that need to be transmitted.
There is a problem of sparse data for evaluation, for example
15 total images can result from either 3 viewports with 5
layers, and vice versa. This was overcome by using differing
layer numbers during the tests, yielding the fractional layer
number needed, for example 15 total images split on 2
viewports with 7.5 layers, in average. Figure 12 (a) denotes
the total images on the x-axis, and average layers on the y-
axis. The graphs are contour-lines of same interaction error.
It is clearly visible, that both the increase of bandwidth and
the increase in layers with constant bandwidth reduces the
error. This clearly shows, that given a limited bandwidth, the
interaction error can be as low as how many layers the output
device can handle. Additionally, Figure 12 (b) presents the
performance I ≈ O(m−1n−1/3) in the experiment, as it was
predicted before.
VIII. CONCLUSION
In this paper, we developed a mathematical model which
allows to measure, analyze and optimize the display error
of image-based approximation techniques, presented an al-
gorithm for viewport location optimization, and evaluated
the performance of the method under realistic conditions.
Both the error asymptotics derived for our method based on
parallelized rendering, as well as the experimental results,
show a clear advantage over traditional remote visualization
187
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

concepts like Virtual Network Computing (VNC) which,
under ideal conditions, represent the scene by one image
m = 1 without image warping, leading to doubled interac-
tion errors than presented here.
In contrast to this, m = 10 impostors with n = 1
viewport cover the same volume of permissible viewports as
m = 1 impostors for n = 100000 optimally chosen viewport
sets. The latter is using a bandwidth of O(mn) that is
10000-fold higher. Comparing this to the bandwidth needed
for transmission of impostors compared with their error
contribution O(m−1n−1/5), the method offers signiﬁcant de-
crease of bandwidth consumption. By avoiding high network
latencies, the user experiences low latency rendering.
The proposed method strongly beneﬁts from graphical
capabilities of clients, such as mobile devices, and will
increase its efﬁciency for each new generation providing
increased graphical performance. Due to the parallelization
of server-sided image generation, and the proven efﬁciency
thereof, the method is applicable to large and distributed data
sets for visualization on mobile devices and thin clients, also
including augmented reality applications [23].
ACKNOWLEDGMENT
The authors appreciate the support of the ’Federal Min-
istry of Education and Research’ and ’Eurostars’ within the
Project E! 5643 MobileViz. The Eurostars Project is funded
by the European Union.
REFERENCES
[1] A. Helfrich-Schkarbanenko, V. Heuveline, R. Reiner, and
S. Ritterbusch, “Bandwidth-efﬁcient parallel visualization for
mobile devices,” in INFOCOMP 2012, The Second Interna-
tional Conference on Advanced Communications and Com-
putation, 2012, pp. 106–112.
[2] F. Lamberti and A. Sanna, “A streaming-based solution for
remote visualization of 3D graphics on mobile devices,”
Visualization and Computer Graphics, IEEE Transactions on,
vol. 13, no. 2, pp. 247–260, march-april 2007.
[3] H.-Y. Shum and S. B. Kang, “A review of image-based
rendering techniques,” in IEEE/SPIE Visual Communications
and Image Processing, 2000, pp. 2–13.
[4] S. Jeschke and M. Wimmer, “An error metric for layered
environment map impostors,” Institute of Computer Graphics
and Algorithms, Vienna University of Technology, Technical
Report TR-186-2-02-04, 2002.
[5] S. Jeschke, M. Wimmer, and W. Purgathofer, “Image-based
representations for accelerated rendering of complex scenes,”
Eurographics 2005 STAR Report, vol. 1, 2005.
[6] V. Heuveline, M. Baumann, S. Ritterbusch, and R. Reiner,
“Method and system for scene visualization,” Mar. 1 2013,
wO Patent 2,013,026,719.
[7] S.
Jeschke,
M.
Wimmer,
and
H.
Schuman,
“Layered
environment-map impostors for arbitrary scenes,” Graphics
Interface, pp. 1–8, May 2002.
[8] W.-C. Wang, K.-Y. Li, X. Zheng, and E.-H. Wu, “Layered
Textures for Image-Based Rendering,” Journal of Computer
Science and Technology, vol. 19, no. 5, pp. 633–642, Septem-
ber 2004.
[9] M. Moser and D. Weiskopf, “Interactive volume rendering
on mobile devices,” in 13th Fall Workshop: Vision, Modeling,
and Visualization 2008, O. Deussen, D. Keim, and D. Saupe,
Eds.
Akademische Verlagsgesellschaft AKA GmbH, 2008,
p. 217.
[10] J. Cohen, D. Manocha, and M. Olano, “Simplifying polygonal
models using successive mappings,” in VIS ’97: Proceedings
of the 8th Conference on Visualization ’97.
Los Alamitos,
CA, USA: IEEE Computer Society Press, 1997, p. 395.
[11] P. Debevec, Y. Yu, and G. Boshokov, “Efﬁcient view-
dependent image-based rendering with projective texture-
mapping,” University of California at Berkeley, Berkeley, CA,
USA, Technical Report, 1998.
[12] J. Kopf, B. Chen, R. Szeliski, and M. Cohen, “Street slide:
browsing street level imagery,” ACM Transactions on Graph-
ics (TOG), vol. 29, no. 4, pp. 1–8, 2010.
[13] J. Shade, D. Lischinski, D. H. Salesin, T. DeRose, and
J. Snyder, “Hierarchical image caching for accelerated walk-
throughs of complex environments,” in SIGGRAPH ’96:
Proceedings of the 23rd Annual Conference on Computer
Graphics and Interactive Techniques.
New York, NY, USA:
ACM, 1996, pp. 75–82.
[14] T. A. Funkhouser, “Database management for interactive
display of large architectural models,” in GI ’96: Proceedings
of the Conference on Graphics Interface ’96.
Toronto, Ont.,
Canada, Canada: Canadian Information Processing Society,
1996, pp. 1–8.
[15] M. Hoffmann and J. Kohlhammer, “A Generic Framework for
Using Interactive Visualization on Mobile Devices,” Commu-
nications in Computer and Information Sciene, vol. 53, no. 4,
pp. 131–142, 2009.
[16] F.
Lamberti,
C.
Zunino,
A.
Sanna,
A.
Fiume,
and
M. Maniezzo, “An accelerated remote graphics architecture
for PDAs,” in Web3D ’03: Proceedings of the Eighth Interna-
tional Conference on 3D Web Technology.
New York, NY,
USA: ACM, 2003, pp. 55–61.
[17] A. Beutelspacher and U. Rosenbaum, Projective Geometry:
From Foundations to Applications.
Cambridge University
Press, February 1998.
[18] R. Reiner, “Numerical Methods for Optimal Impostor Pre-
fetching in Scientiﬁc Visualization,” Diploma Thesis, Karls-
ruhe Institute of Technology, 2011.
[19] R. C. St.John and N. R. Draper, “D-optimality for regression
designs: a review,” Technometrics, vol. 17, no. 1, pp. 15–23,
1975.
[20] V. B. Melas, Functional Approach to Optimal Experimental
Design (Lecture Notes in Statistics).
Springer-Verlag New
York, Inc., 2005.
188
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[21] A. F. Emery and A. V. Nenarokomov, “Optimal experiment
design,” Measurement Science and Technology, vol. 9, no. 6,
pp. 864–876, 1999.
[22] D. Ucinski, Optimal measurement methods for distributed
parameter system identiﬁcation.
CRC Press, 2004.
[23] V. Heuveline, S. Ritterbusch, and S. Ronnas, “Augmented
reality for urban simulation visualization,” in INFOCOMP
2011, The First International Conference on Advanced Com-
munications and Computation.
IARIA, 2011, pp. 115–119.
189
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

