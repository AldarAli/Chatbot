A Formal Method for the Evaluation of Component-based Embedded Systems:
Application to Technical Choices for CSTBox Toolkit
Daniel Cheung-Foo-Wo, ´Eric Pascual
Centre Scientiﬁque et Technique du Bˆatiment (CSTB)
Sophia Antipolis, France
daniel.cheung@cstb.fr, eric.pascual@cstb.fr
Abstract—When designing applications for sensor or actuator
network management, deployed networks of equipments often
use an underlying component-oriented approach, such as
OSGi (formerly Open Services Gateway Initiative, now OSGi
Alliance), which provides ﬂexibility in terms of software devel-
opment and maintenance. It also leads to combining sensors
and actuators from different manufacturers using different
protocols, libraries, and communication media. To make the
interface between components compatible, additional software
layers are implemented on top of heterogeneous libraries and
protocols. Our intention in this paper is to confront our OSGi
applied software solution coping with these heterogeneity and
ﬂexibility to contextual timing constraints in order to propose
solutions in terms of OSGi extensions and generalization. We
formally describe the performance function of the connectors
of our toolkit called CSTBox (CSTB Sensing Telemonitoring
Box) faced to soft real-time constraints derived from real-world
deployments of European projects in domains such as ambient
assisted living for the elderly and energy use in ofﬁces according
to a simple classiﬁcation of underlying middleware in terms of
performance. Running applications, result analyzes, and timing
measurements are performed on the SOC (System on Chip)
card Raspberry Pi hardware for low-consumption and other
embedded systems like routers and gateways.
Keywords-component; soft real-time constraints; OSGi; D-
Bus; sensor network data processing measurement;
I. INTRODUCTION
The problem addressed in this paper is derived from
research projects [1]–[3] in ambient instrumentation of
buildings. The objective is to provide software managing
networks of equipments in the form of an OSGi-based
toolkit for embedded systems in ambient assisted living
and analysis of energy use. However, these domains impose
some requirements on systems. Firstly, in order to protect
privacy in home activity monitoring, external data transfer is
securely kept minimal. Besides, the system must be robust
to network failures to avoid information loss. As a result,
most of the data processing is done in-place, which promotes
the systems from simple data acquisition and transfer units
to full processing units. Secondly, these domains concern
monitoring for gathering statistical information and require
sufﬁcient soft real-time (RT) constraints on observation rate
and reaction delay. Various applications from assisted living
and energy use accordingly share a great part of functionali-
ties, and emphasize the need for a component-based solution.
The system must also be ﬂexible in supporting multiple
sensor networks connecting from local and remote sites.
Furthermore, the hardware equipments, such as sensors,
actuators and network coordinators, might differ because
of their origin and their protocol. These heterogeneous
equipments are thereby mixed for a given instrumentation
of buildings (see Figure 1).
Figure 1.
Operation principle of the CSTBox abstraction mechanism
On account of these requirements, our software toolkit is
characterized by its assembly of soft RT components using
heterogeneous equipments. We proposed a solution [4] tack-
ling sensor-actuator heterogeneity by means of representing
an equipment (decomposed into parts) as a set of readable or
writable state variables associated with a type, an identiﬁer
of the associated part and the state of the equipment part.
This paper deals with the confrontation of this OSGi
approach to timing constraints induced by assisted-living
and energy-use domains and its consequences on the choice
and the design of the component communication provided
by the underlying OSGi platform, i.e., software connectors.
The remainder of this paper is organized as follows: next
section presents some related works. Section III introduces
the model of our toolkit and presents a formal approach
for scoring its performance. In Section IV, we detail the
problem of applying constraints and the way it addresses
the issue of the proper selection of connectors. We conclude
in Section V on perspectives.
157
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-296-7
SENSORCOMM 2013 : The Seventh International Conference on Sensor Technologies and Applications

II. RELATED WORK
Software connector design and choice can be studied in
several ways. For instance, connector choice can be achieved
by querying an existing classiﬁcation of connectors [5]
organized in terms of the following six main dimensions: the
amount of transferred data, delivery intervals, performance
requirements, the number of consumers, access policies, and
geographic distribution of components. A data distribution
scenario is then expressed as a query against the above
dimensions. The selection algorithm is thus tasked with
deciding what available connectors will suit a given scenario,
which is accomplished by maintaining a knowledge base
of connector proﬁles. A connector proﬁle contains metadata
including locality, number of providers/subscribers, through-
put, delivery semantics, and routing. The authors’ focus is
on automatizing the selection algorithm for fetching software
connectors based on the key dimensions. Although automa-
tion represents a great beneﬁt to software engineering, we
are more interested in a formal tool helping the developer
ﬁguring out the adequate use of connectors.
Another related area of research relies on software archi-
tecture programming dealing with frequent updates. Refer-
ence [6] presents the design of connectors by combining
white-box components which semantics and routing are
known. The authors focus on mathematical properties, such
as associativity of the combination, forming an algebraic
way of designing connectors. They use this algebra to
integrate, swap or remove functionalities expressed in terms
of components. They consider that the set of all adaptations
that may be deployed cannot be anticipated at design time,
which is beyond our requirements. In such case, adaptations
may interfere when they are combined. However, they model
the assembly of components as a directed graph (data-ﬂow)
providing them with a formal tool to identify properties and
errors. We consider designing a formal model compatible
with this graph representation and algebra.
Finally, in a software engineering point of view, OSGi
provides all the requirements expressed in the Section I.
However, based on a qualitative experience, [7][8] decided
not to use OSGi as a connector implementation for three
reasons. Firstly, existing good quality legacy components
shall not be rewritten in Java for costs saving. Secondly,
components of the system should sometimes be written by
specialists who have their speciﬁc language of domain (e.g.,
Matlab). Thirdly, unless distributed, OSGi runs the applica-
tion in a single virtual machine, i.e., every bundle shares the
same memory area, so the lowest quality bundle determines
the quality of the entire system. Consequently, they choose
D-Bus (Desktop Bus) which is an inter-process communi-
cation solution with the following claimed properties: lan-
guage independence and efﬁciency (however, no quantitative
results is given for that case). Hence, components become
separate processes directly managed by the operating system
beneﬁting from its RT properties if available. D-Bus is
heavily used in GNU/Linux both in desktop and system
applications, and it is also ported to other operating systems
including Windows. There exists bindings for a wide range
of programming languages. Furthermore, it is also possible
to connect several D-Buses running on different computers
making distributed computing possible, which becomes in
competition with initiatives like DOSGi [9] (Distributed
OSGi). As a result, a D-Bus-based toolkit provides two
new characteristics: language independence and component
separation (see Section IV-B).
As a result, although these approaches propose complete
solutions for component connection abstract and concrete
model, none considers applying it to the widely used OSGi
concrete model and perform a quantitative study of its
incremental extension and provide a systematic methodology
to score existing solutions to ensure the most adequate
solutions rise to the top, which is the focus of this paper.
III. CONSTRAINED MODEL OF COMPONENTS
To present our connector model, we introduce in this
section the model of our component system. We abstract
it from any speciﬁc notation and represent it as a directed
graph as in [6].
Deﬁnition 1. (Component graph) A component graph G is
a set of vertices V and directed edges E, noted G = (V, E).
A vertex v has the attribute v.typ, a type. An edge e from v1
to v2 of V is written as e = (v1, v2, l) where l is a label.
Each vertex has a type which depends on the underlying
system, i.e., communication bus or programming language.
Deﬁnition 2. (Input and Output) Let G = (V, E) be a
directed graph. For each vertex v ∈ V , its inputs are labels
I1, . . . , Im noted v.I such that ∀k ∈ [1, m], (vk, v, Ik) ∈ E.
Similarly, its outputs are O1, . . . , On, noted v.O such that
∀k ∈ [1, n], (v, v′
k, Ok) ∈ E.
In this model, a software connector is simply represented by
a vertex as a component.
A. Updating state variables
The state variables, as introduced in Section I for solving
heterogeneity problems, are represented by a set S where
each element σ ∈ S has the attributes σ.sta, its state, σ.id,
its identiﬁer, and σ.typ, its type.
To update state variables, we deﬁne a ﬁxed and contextual
common message structure. The ﬁxed part contains the
time stamp of the message, the type of the associated state
variable, a regular expression (regexp) id matching one or
several state variable ids, and the state. The contextual part
is a key-value map function on contextual information, such
as the unit of the state, etc. Special connectors implementing
the hardware abstraction layer are exhibited from the com-
ponent graph. We call them HAC connectors (Deﬁnition 3).
158
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-296-7
SENSORCOMM 2013 : The Seventh International Conference on Sensor Technologies and Applications

Deﬁnition 3. (HAC) Let G = (V, E) be a directed graph.
A hardware abstraction connector (HAC) is a vertex γ ∈ V
such that for all π ∈ {I, O}, γ.π = γ has the attributes ts
(time stamp), sta (state), re (regexp id), typ (type), and m
(key-value map).
HAC connectors translate a regexp id from its input into
a constant string id. On the one hand, as collected data are
related to physical events, i.e., measurements of quantities
(temperature, energy consumption, etc.) or notiﬁcations of
state change (door opening, motion detection, etc.), the input
regexp id is then reduced to a constant string representing
the id of the state variable (e.g., living-room.light.ceiling).
On the other hand, a sub-assembly of components should
compute the matching of the state variable handling the
action and translate the command to the proper communica-
tion frames. It allows us to specify the target using pattern
matching rules, such as living-room.light.* (id is supposed to
follow a predeﬁned format), which will alter state variables
matching the rule receiving the appropriate command.
Property 1. (HAC invariant) For all HAC noted γ in a
component graph, the state of γ reﬂects the state of one
or several state variables according to the matching of γ’s
regexp, i.e., for all HAC γ ∈ V and σ ∈ S, if σ.typ = γ.typ
and σ.id ∼= γ.re, then σ.sta = γ.sta where the symbol ’∼=’
stands for a regexp matching function.
Deﬁnition 1 highlights the ﬂexibility beneﬁted from HAC
connectors to target multiple state variables. Such an ap-
proach of the communication between the building blocks
of the application allows us to decouple component imple-
mentations. We presented above the model of the toolkit and
its properties. We propose in the next paragraphs one way
of applying constraints to express a notion of performance.
B. Soft real-time constraints
Soft RT constraints impose that system response time
should be adequate in average. At the connector level, this
means that its delays should be compatible with these con-
straints. Thus, we propose to work with the ratio τ (called
performance) of the duration noted dC of a function call in
C language as our yardstick reference to be independent
of the CPU (central processing unit) load, i.e., the time
between the function is invoked in a source component and
the execution of its ﬁrst instruction in a target component,
over its own duration. We choose C for its widespread use
as a simple procedural abstraction. This ratio is computed
experimentally (see Section IV).
Deﬁnition 4. (Connector performance) The connector per-
formance τ
of a connector type v.typ is a function
τ(v.typ) =
dC
d
scoring its performance between 0 (low)
and 1 (high performance) where d is the computation time
of v.typ.
To compute the overall performance of the connectors of the
system, we propose to take the average sum of all connector
performances on the path of the predominant control ﬂows.
We do not seek to provide a predictive calculus for a given
application, but rather a metric comparison between the
different systems, achieved by a simple arithmetic average
without weighted control ﬂow.
Deﬁnition 5. (Performance of system) The performance P
of a set of n types of connector (t1, . . . , tn) and control-ﬂow
paths F is:
P =
1
|F|
X
f∈F


1
P
j∈[1,n] kf,j
X
i∈[1,n]
kf,i.τ(ti)


(1)
where kf,i is the number of times the path f traverses a
connector of type ti and |F|, the cardinal of F.
We built a model with a global performance function (Equa-
tion 1) which purpose is to provide a way to score the
performance of a middleware. We show in the next section
how to apply it to evaluate development solutions.
IV. D-BUS AS AN OSGI MIDDLEWARE EXTENSION
A. Connectors in iPOJO/OSGi
Apache Felix was selected as the OSGi implementation
and iPOJO [10] (injected Plain Old Java Object) is used on
top of it to provide an extensible and declarative component-
oriented model. Thus, additional “handlers”, i.e., connec-
tors, can be implemented by means of extensions of the
PrimitiveHandler class to intercept access to attributes and
method invocations of pojos, i.e., functional codes. The ﬁrst
requirement in our projects was to specify service ﬁlters in
a conﬁguration ﬁle that selected the components associated
with a required service. The existing connector Require
handler of iPOJO proposes only a design-time service ﬁlter.
We created a new handler (called VariableRequire) based on
the latter to read a conﬁgurable property initialized with a
given conﬁguration ﬁle before adding ﬁltering information
during the assignment of a component. Secondly, we created
another handler called RegexpSubscriber extending the event
Subscriber of iPOJO to listen to broadcasted OSGi events. It
provided a regexp HAC connector matching the OSGi topic
as a complementary information instead of the internal OSGi
speciﬁc ﬁlter. We do not detail the implementation of both
connectors in this paper, but we focus on scoring them to
provide a quantitative analysis of the system performance.
We measured the C method call duration dC = 7µs on
average on Raspberry Pi (240 measures during 4h on low
CPU load < 1%) by using gettime() function. Two control
ﬂows are implemented. The ﬁrst one writes sensor values
into the database and traverses two connector types: 1
HAC (type t0) and 2 iPOJO calls (type t1). The second
one logs battery level traversing the same connector types.
Performance computation is shown in Table I.
159
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-296-7
SENSORCOMM 2013 : The Seventh International Conference on Sensor Technologies and Applications

B. Towards D-Bus extension
We introduced D-Bus in our architecture as in [7], in
particular, by incrementally replacing the OSGi middleware.
The idea was to gradually put the language-agnostic D-
Bus (or other effective middleware) at the center of the
communication between software components (see Figure 2)
and observe the evolution in performance.
Figure 2.
The operation principle of the CSTBox abstraction mechanism
D-Bus implementation requires a single process per bus
entity, manages the process interface registration, and keeps
overlaps in naming coherent by queuing bus requests. It also
manages the life-cycle of processes. We have implemented
the same sub-assembly as in Section IV-A, but in Python
and D-Bus. The control ﬂows are the same and traverse 2
types of connectors: 1 HAC (t′
0) and 2 Python calls (t′
1).
Table I
OSGI/IPOJO AND D-BUS PERFORMANCE COMPARISON
1 HAC (RegexpSubscriber OSGi)
τ(t0) =
7µs
46000µs ≃ 0.02%
2 iPOJO service call connectors
τ(t1) =
7µs
13749µs ≃ 0.05%
Performance of OSGi: POSGi = 1
3 (τ(t0) + 2τ(t1)) ≃ 0.04%
1 HAC (CSTBoxEvent D-Bus)
τ(t′
0) =
7µs
4061µs ≃ 0.17%
2 Python method call connectors
τ(t′
1) =
7µs
31µs ≃ 22.58%
Performance of D-Bus: PD-Bus = 1
3

