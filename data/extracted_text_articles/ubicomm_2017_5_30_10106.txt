Probabilistic CCRN: Reliability Analysis of Ubiquitous Computing Scenarios
Using Probabilistic Model Checking
Reona Minoda, Masakazu Ishihata and Shin-ichi Minato
Graduate School of Information Science and Technology
Hokkaido University
Sapporo, Hokkaido 060–0814, Japan
Email: minoda@meme.hokudai.ac.jp, {ishihata.masakazu, minato}@ist.hokudai.ac.jp
Abstract—This paper proposes the method of reliability analysis
of ubiquitous computing (UC) scenarios. In UC scenarios, various
devices communicate with each other through wireless network,
and this kind of communications sometimes break due to external
interferences. To discuss the reliability in such situation, we
introduce the notion of probability into context catalytic reaction
network (CCRN), which is a description model of UC scenarios.
This enables us to conduct quantitative analyses such as consid-
erations of a trade-off between the reliability of UC scenarios
and the costs which may be necessary for their implementations.
To conduct a reliability analysis of UC scenarios, we use the
technique of probabilistic model checking. We also evaluate
our method experimentally by conducting a case study using
a practical example assuming a museum.
Keywords–Ubiquitous Computing; Catalytic Reaction Network;
Probabilistic Model Checking; Smart Object.
I.
INTRODUCTION
Nowadays, we are surrounded with various kinds of devices
with computation and communication capabilities and we
carry these devices every day. In this paper, we call these
devices “smart objects (SO)”. SOs include personal computers
(PCs), mobile phones, sensor devices, embedded computers
and radio frequency identiﬁer (RFID) tags. But we can also
treat physical things like foods, medicine bottles and cups
as SOs by embedding RFID tags in those. Here, we use
the term federation to denote the deﬁnition and execution of
interoperation among resources that accessible either through
the Internet or through peer-to-peer ad hoc communication.
For example, let us consider that there are a phone, a medicine
bottle and food, and RFID tags are embedded in a medicine
bottle and food. Imagine that this food and the medicine have
a harmful effect when eaten together. If all these things are
close to each other, a phone rings to inform a user to warn not
eat them together. This phenomenon is a federation. Indeed,
we can also consider federations related to other SOs and
these federation may be involved in each other. We call these
federation “ubiquitous computing application scenarios (UC
scenario)” (see Figure 1).
In our previous works, we showed an approach to verify
UC scenarios by proposing context catalytic reaction network
(CCRN) and its veriﬁcation through model checking [1]. We
also proposed more efﬁcient method of this kind of veriﬁca-
tions through symbolic model checking [2]. These contribu-
tions enabled us to verify the property of UC scenario, which
is described in formal logic formulation and these veriﬁcations
Federation
...
Federation
Federation
Federation
Involved in
Each Other
Other
Federations
Embeded Chips
(e.g., RFID tags, etc.)
Close to
Each
Other
Ring!
   Ring!
Food
Phone
Medicine
Bottle
Figure 1. Example of Ubiquitous Computing Application Scenario
are conducted systematically thanks to various model checking
veriﬁers, such as NuSMV2 [3].
However, there are still challenges of our approach. For
example, UC scenarios are assumed that SOs typically com-
municate with each other by the wireless communication.
This means that we need to consider these communications
sometimes break due to various external causes. For this
reason, it is important to discuss this kind of interference
formally. In this paper, we show an approach to reliability
analysis of UC scenarios by introducing a notion of probability
to CCRN, which is a description model of UC scenarios.
To analyze this kind of reliability, we use the technique of
probabilistic model checking [4].
The rest of this paper is organized as follows. Section 2
introduces related works of our research. Section 3 provides
preliminaries of this paper, such as basic deﬁnitions and
notations including CCRN and probabilistic model checking.
Using them, we introduce a notion of probability to CCRN in
Section 4. In Section 5, we propose the method of reliabil-
ity analysis of probabilistic CCRN using probabilistic model
checking. Then, we evaluate our approach by conducting the
case study assuming a practical scenario in Section 6. Finally,
we conclude our contributions in Section 7.
II.
RELATED WORKS
In this section, we introduce related works of our work.
A. Reconﬁgurable hardware veriﬁcation for Ubiquitous Sys-
tems
In the ﬁeld of implementations for ubiquitous systems,
Guellouz, et al. use probabilistic model checking to verify
the behavior of devices [5]. These devices have reconﬁgurable
function blocks, which is standardized as IEC 61499 and a
85
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-598-2
UBICOMM 2017 : The Eleventh International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Gate
Headset
Phone
IC card
Scope of
(iii) Phone     and headset     
                  are federated (denoted by      ).
expressed as
makes    and    federated.
(ii)
(i) A user enters into
the scope of      .
(This action is triggered by   .)
Figure 2. Example of a Catalytic Reaction
part of each blocks behaves probabilistically. Guellouz, et al.
analyzed this behavior by using probabilistic model checking.
B. Formal Veriﬁcation of Cyber Physical Systems
Similarly to ubiquitous computing, a lot of devices, such
as sensors measure physical phenomena, such as temperature,
humidity, acceleration and so on, while actuators manipulate
the physical world, like in automated robots. The combination
of an electronic system with a physical process is called cyber
physical system (CPS). In the ﬁeld of CPS, Drechsler and
K¨uhne use timed automata [6] as a state transition model to
conduct formal veriﬁcations of given systems’ properties [7].
C. Context Inconsistency Detection
In the ﬁeld of ambient computing, Xu and Cheung propose
a method of context inconsistency detection [8]. This method
detects inconsistencies from a series of gathered events, such
as “a user entered a room” and “the temperature of room is
30◦C” by logical deduction. Unlike a formal veriﬁcation, this
method can be applied only after the system begins to work.
Instead, a formal veriﬁcation can ﬁnd the failed cases from a
given system in advance.
III.
PRELIMINARIES
In this section, we give deﬁnitions and notations which is
necessary for this paper.
A. Basic Deﬁnitions and Notation
Let X and Y be any two sets, we use X ∪ Y, X ∩ Y and
X \ Y to denote the union, intersection and difference of X
and Y respectively. For a set X, we denote its power set (i.e.,
all subsets) by 2X and its cardinality by |X|. For a set X, we
denote a set of k-elements subsets of X by

c2 makes a and b federated without a stimulus. In a similar
way, we consider the decomposition reactions, such as Figure
3 (iii) and (iv). In type (iii), if a user who has two SOs that
are federated into ab enters into the scope of context c3, c3
decomposes these SOs ab into a and b triggered by SO s. Type
(iv) is a decomposition reaction without a stimulus.
The output SO of a reaction may promote other reactions
as a stimulus or become an input SO of other reactions. In this
way, catalytic reactions form a network of reactions.
Now we deﬁne these notions, contexts and SOs, formally.
Basically, we regard that there are two types of SOs. One is a
set of SOs which can federate with other smart objects denoted
by O and the other one is a set of SOs which can only promote
SOs in O to federate with each other denoted by C. Latter in
this paper, SOs c ∈ C are called “context” and SOs o ∈ O
are called just “SO” for convenience. We denote contexts and
their corresponding reactions by ci and ri respectively.
Next, we deﬁne catalytic reactions formally by following
deﬁnition
Deﬁnition 1 (Catalytic Reaction): Let
O
be
a
set
of
SOs, a catalytic reaction r is deﬁned as an action tuple
⟨pre(r), add(r), del(r)⟩. Every catalytic reaction r satisﬁes
following conditions:
•
pre(r) ⊆ 2O, add(r) ⊆ 2O and del(r) ⊆ 2O,
•
pre(r), add(r) and del(r) are pairwise disjoint sets
respectively,
•
del(r) ⊆ pre(r), and
•
S add(r) = S del(r).
pre(r), add(r) and del(r) of catalytic reaction r corre-
spond to the precondition for the reaction application, the
addition of federation after the reaction, and the deletion
of federation after the reaction respectively. We give some
examples of catalytic reactions. Given O
=
{a, b, s}, a
catalytic reaction of Figure 3 (i) and (iii) can be deﬁned
by r1 ≜ ⟨{{a}, {b}, {s}}, {{a, b}}, {{a}, {b}}⟩ and r3 ≜
⟨{{a, b}, {s}}, {{a}, {b}}, {{a, b}}⟩ respectively. Note that
Deﬁnition 1 is more general deﬁnition of catalytic reactions
compared to four types of catalytic reactions in Figure 2. If
we represent only these catalytic reactions by this deﬁnition,
we just set cardinality constraints of pre(r), add(r) and del(r).
If r is a composition reaction (i.e., Figure 2 (i) and (ii)), r
should satisfy |pre(r)| = 2 or 3, |add(r)| = 1 and |del(r)| = 2;
otherwise, if r is a decomposition reaction (i.e., Figure 2 (iii)
and (iv)), r should satisfy |pre(r)| = 1 or 2, |add(r)| = 2 and
|del(r)| = 1.
Finally, a catalytic reaction network is deﬁned as follows:
Deﬁnition 2 (Catalytic Reaction Network): A catalytic re-
action network R is a set of catalytic reactions.
C. Context Catalytic Reaction Network
This section describes a segment graph and a CCRN.
1) Segment Graph: As we discussed in previous section, a
catalytic reaction is occurred when required SOs enter into the
scope of the corresponding context. To analyze the property of
a given catalytic reaction network as a state transition system,
it is necessary to formalize the movement of SOs. For example,
in Figure 4 (i), there are contexts c1 and c2 and these scopes
have an overlap. A user can walk around the path αβ shown
Scope of
Scope of
Context
Context
A user can walk around a path     .
Given Situation
Corresponding Segment Graph
Scope of
Scope of
Figure 4. Example of Segment Graph
in Figure 4 (i). This situation can be represented as a segment
graph shown in Figure 4 (ii). We consider that the user walk
around this segment graph and the user is always located at one
of the nodes of this segment graph. Each node of a segment
graph has a corresponding set of scopes of contexts. In this
way, the given situation like Figure 4 (i) including overlaps of
scopes of contexts can be represented as a discrete structure.
Now we deﬁne a segment graph as follows.
Deﬁnition 3 (Segment Graph): Let C be a set of contexts,
a segment graph G is a tuple (S, E, F), where
•
S is a ﬁnite set of segments,
•
E ⊆ S × S is a set of directed edges between two
segments, and
•
F : S → 2C is a function returning scopes of contexts
at corresponding segments.
2) Context Catalytic Reaction Network: A context catalytic
reaction network (CCRN) is a discrete structure of a situation
involving SOs in a catalytic reaction network. A CCRN is
deﬁned as a conbination of a segment graph and a catalytic
reaction network.
Deﬁnition 4 (Context Catalytic Reaction Network): Let O
be a set of SOs, a CCRN C is a tuple (R, G, fi, l0), where
•
R is a set of catalytic reactions (i.e., CRN),
•
G is a segment graph (S, E, F),
•
fi ⊆ O is a set of SOs ﬁxed to segment si ∈ S, and
•
l0 ∈ S is the initial segment locating mobile SOs
(mobile SOs can be represented as O \ S fi).
D. Model Checking
A model checking is a method to verify a property of a
state transition system. It has been often used in various ﬁelds,
which ranges from electronic-circuit-design veriﬁcation [11]
to secure-network-protocol (e.g., Secure Sockets Layer (SSL)
protocol) design veriﬁcation [12]. In the model checking, it is
typically assumed to use a Kripke structure as a state transition
system. The property of a Kripke structure is described by a
87
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-598-2
UBICOMM 2017 : The Eleventh International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

modal logic. There are two kind of commonly used modal
logics, such as linear temporal logic (LTL) and computational
tree logic (CTL). In this paper, we use LTL to describe the
property of the Kripke structure.
1) Kripke Structure: Before we look on the detail of a
model checking, we give the deﬁnition of a Kripke struc-
ture [13], which is necessary for a modal logic and a model
checking.
Deﬁnition 5 (Kripke Structure): Let AP be a set of atomic
propositions, a Kripke structrue M is a tuple (S, I, R, L),
where
•
S is a ﬁnite set of states,
•
I ⊆ S is a set of initial states,
•
R ⊆ S ×S is a set of transition relation such that R is
left-total, i.e., ∀s ∈ S, ∃s′ ∈ S such that (s, s′) ∈ R,
and
•
L : S → 2AP is a labeling function.
2) Linear Temporal Logic: Linear temporal logic (LTL)
is one of the most well-known modal logic. LTL was ﬁrst
proposed for the formal veriﬁcation of computer programs by
Amir Pnueil in 1977 [14]. First, we give a deﬁnition of LTL
syntax.
Deﬁnition 6 (Linear Temporal Logic Syntax): Let AP be a
set of atomic propositions, a linear temporal logic formula φ
is deﬁned by the following syntax recursively.
φ ::= ⊤ | ⊥ | p | ¬φ | φ ∨ φ | X φ | G φ | F φ | φ U φ
(1)
where p ∈ AP.
These right-hand terms denote true, false, p, negation, disjunc-
tion, next time, always, eventually and until respectively.
Next, we deﬁne a transition path π of a Kripke structure
M.
Deﬁnition 7 (Transition Path): Let M be a Kripke struc-
ture, π = (π0, π1, π2, . . . ) is a transition path in M if it
respects M’s transition relation, i.e., ∀i.(πi, πi+1) ∈ R. πi
denotes π’s ith sufﬁx, i.e., πi = (πi, πi+1, πi+2, . . . ).
Also it can be shown that
(πi)j = (πi, πi+1, πi+2, . . . )j
= (πi+j, πi+j+1, πi+j+2, . . . )
= πi+j.
(2)
Now, we focus on the semantics of linear temporal logic.
First, we deﬁne the binary satisfaction relation, denoted by |=,
for LTL formulae. This satisfaction is with respect to a pair
– ⟨M, π⟩, a Kripke structure and a transition path. Then, we
enumerate LTL semantics as follows:
•
M, π |= ⊤ (true is always satisﬁed)
•
M, π ̸|= ⊥ (false is never satisﬁed)
•
(M, π |= p) iff (p ∈ L(π0)) (atomic propositions are
satisﬁed when they are members of the path’s ﬁrst
element’s labels)
And there are two LTL semantics of boolean combinations as
follows:
•
(M, π |= ¬φ) iff (M, π ̸|= φ)
•
(M, π |= φ ∨ ψ) iff [(M, π |= φ) ∨ (M, π |= ψ)]
And there are four LTL semantics of temporal operators as
follows:
•
(M, π |= X φ) iff (M, π1 |= φ)
•
(M, π |= F φ) iff

∃i.(M, πi |= φ)

•
(M, π |= G φ) iff

∀i.(M, πi |= φ)

•
(M, π |= φ U ψ) iff

(∃i.(M, πi |= ψ)) ∧ (∀j < i.(M, πj |= φ))

3) Model Checking Problem: Intuitively saying, a model
checking problem is to judge whether a given Kripke structure
M satisﬁes a given property described in a modal logic formula
φ. A model checking problem is formally stated as follows.
Deﬁnition 8 (Model Checking Problem): Given a desired
property described by a modal logic formula φ (in this paper,
we use LTL) and a Kripke structure M, a model checking
problem is a decision problem whether the following formula
∀π.(M, π |= φ)
(3)
is satisﬁed or not. Note that a set {π | (M, π ̸|= φ)} is
particularly called a set of counterexamples.
It is known that a model checking problem can be reduced to
a graph search if M has ﬁnite states.
There are several implementations of the model checking
veriﬁer, such as Simple Promela INterpreter (SPIN) [15] and
Label Transition System Analyzer (LTSA) [16].
E. Probabilistic Model Checking
Probabilistic model checking is another method of relia-
bility analysis for given Kripke structure. In original model
checking, the reachability between two states of Kripke struc-
ture is deﬁned as the existence of the directed edge between
these states. Instead, in probabilistic model checking, the
reachability between two states of Kripke structure is repre-
sented as a probability. This probability of the reachability is
normalized with respect to each states as follows
X
s′,(s,s′)∈R
P(s′ | s) = 1 for all s ∈ S.
(4)
1) Probabilistic LTL: Probabilistic LTL is extended prop-
erty description language of LTL for probabilistic model
checking. In probabilistic LTL, temporal operators G and F
has an additional bound parameter k denoted by G≤k and
G≤k. These temporal operators have following semantics:
•
(M, π |= F≤k φ) iff

∃i ≤ k.(M, πi |= φ)

•
(M, π |= G≤k φ) iff

∀i ≤ k.(M, πi |= φ)

To discuss the probability of the transition path, probabilistic
LTL also has quantitative operator P=?. Given a LTL property
φ, P=? φ evaluates the existence probability of transition paths
which satisﬁes the LTL property φ.
2) Probabilistic Model Checking Problem: Intuitively say-
ing, a probabilistic model checking problem evaluates the
existence probability of transition paths with length k which
satisﬁes the property φ described by probabilistic LTL. This
transition assumes discrete-time Markov chain. A probabilistic
model checking problem is deﬁned as follows:
Deﬁnition 9: Given a Kripke structure M, τs,s′ = P(s′ |
s), a probabilistic LTL φ and a length of bound k, a
88
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-598-2
UBICOMM 2017 : The Eleventh International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

probabilistic model checking problem evaluates the following
probability:
X
∀π.(M,π|=φ ∧|π|=k)
k
Y
t=1
P(πt | πt−1)
(5)
One of the most famous implementation of probabilistic
model checkers is Probabilistic Symbolic Model Checker
(PRISM) [4]. In this paper, we use PRISM to conduct a case
study in Section 6.
IV.
PROBABILISTIC CCRN
In this section, we propose probabilistic CCRN (P-CCRN),
which is the extended model of CCRN by adding a notion of
probability. To introduce a notion of probability, we consider
two kinds of probability in CCRN. One is the probability of a
user behavior, and the other one is the probability of each of
catalytic reactions. We denote the probability of users’ moving
from segment i to segment j by τi,j and for all segments i ∈ S
of a given segment graph, it is satisﬁed that
X
j,(i,j)∈E
τi,j = 1
(6)
where E is a set of edges in a given segment graph. We denote
the probability of the occurrence of catalytic reaction r by
θr = [0, 1]. By getting them together, we deﬁne a probabilistic
function P as follows.
Deﬁnition 10 (Probabilistic Component): A probabilistic
component P is a tuple ⟨T, Θ⟩ where T = {τi,j ∈ [0, 1] |
(i, j) ∈ E}, Θ = {θr ∈ [0, 1] | r ∈ R}, E is a set of edges in
a segment graph and R is a set of catalytic reactions.
Deﬁnition 11 (Probabilictic CCRN): Let C and P be a
CCRN and a probabilistic component respectively. A prob-
abilistic CCRN (P-CCRN) is a tuple of ⟨C, P⟩.
V.
FORMULATION OF P-CCRN RELIABILITY ANALYSIS
This section shows a reliability analysis method by using
P-CCRN. To do so, we deﬁne states of P-CCRN and repre-
sent transitions between two states as a probability function.
Finally, we propositionize states of P-CCRN to conduct prob-
abilistic model checking.
A. State Representation
Let U be a set of states included in CCRN. Each of states
of given CCRN u can be represented as a pair of states of the
user’s location Sseg and states of SOs’ federation Sfed denoted
by ⟨Sseg, Sfed⟩ where Sseg ∈ S and Sfed ∈ P(O) (i.e., Sfed is a
partition set of O). We also assume the independence between
two events a user behavior and catalytic reactions’ success or
failure.
B. Transition Representation
A transition (u, unext) between two states are occurred
when a user who has SOs moves along with a directed edge
in given segment graph. Sseg is changed directly when the
user moves and Sfed is changed by catalytic reactions of
corresponding contexts located at the segment that the user
aims to go. We deﬁne the function of ri(Sfed) to represent
applications of catalytic reactions.
Deﬁnition 12 (Catalytic Reaction Application): Let ri and
Sfed be a catalytic reaction and a state of SOs’ federation
respectively. ri : P(O) → P(O) is a function of catalytic
reaction application which is a procedure of following update
of given Sfed:
ri(Sfed) =
Sfed \ del(ri) ∪ add(ri)
if pre(r) ⊆ Sfed
Sfed
otherwise
(7)
When the state of CCRN is ⟨Sseg, Sfed⟩ and a transition
(⟨Sseg, Sfed⟩ ,

Snext
seg , Snext
fed

) occurs, ∃Snext
seg .(Sseg, Snext
seg ) ∈ E
and ∃r.(r ∈ R(Snext
seg , Sfed)) are selected probabilistically where
R(s, A) = {ri | ci ∈ F(s) ∧ pre(ri) ⊆ A}.
C. Assigning the probability of a transition between two states
Now
we
assign
the
probability
of
a
transition
(⟨Sseg, Sfed⟩ ,

Snext
seg , Snext
fed

)
between
two
states
of
given
probabilistic
CCRN.
This
probability
is
represented
as
P(

Snext
seg , Snext
fed

|
⟨Sseg, Sfed⟩). Using the assumption of
the independence between two events a user behavior and
catalytic reactions’ success or failure, we can rewrite this
probability as follows:
P(

Snext
seg , Snext
fed

| ⟨Sseg, Sfed⟩)
= P(Snext
seg | Sseg)P(Snext
fed | Snext
seg , Sfed)
(8)
P(Snext
seg | Sseg) can be deﬁned from T directly, namely,
P(Snext
seg | Sseg) ≜ τSseg,Snext
seg .
(9)
On the other hand, P(Snext
fed
| Snext
seg , Sfed) can be deﬁned by
several ways. For example, if there are more than one catalytic
reaction that can be applied when a user enters into a segment
Snext
seg
with federated devices Sfed, at ﬁrst, we evaluate the
probability of all catalytic reactions independently like we try
a coin ﬂip with the number of these reactions of coins and
assume that heads are reactions that are applied. In this paper,
we give three strategy to deal with this kind of situation.
1)
If there are more than one head, we choose one of
them uniformly. This represents mutual exclusion of
concurrent processes among multiple devices.
2)
If there are more than one head, we do not choose
any of these. This assumes that the mutual exclusion
does not work and of course this kind of situation
should be avoided properly.
3)
Let all the catalytic reactions be indexed in order of
reaction rate and if there are more than one head, we
choose the catalytic reaction with lowest number from
them. This represents that fastest catalytic reaction is
applied at the highest priority.
In this paper, we use the ﬁrst strategy to conduct case studies
in Section 6. This strategy can be represented as follows:
P(Snext
fed | Snext
seg , Sfed) =
(Q
i∈R′(1 − θi)
if Snext
fed = Sfed
P|R′|
j=1
P
χ∈Xij
1
j
Q
k∈χ θk
Q
ℓ∈R′\χ(1 − θℓ)
otherwise
such that Snext
fed \ Sfed = add(ri)and ri ∈ R′,
where Xij = {i} ∪
R′ \ {i}
j − 1

and R′ = R(Snext
seg , Sfed).
(10)
89
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-598-2
UBICOMM 2017 : The Eleventh International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

(Outside)
,    and    are mobile SOs.
Catalytic Reactions:
and    are fixed SOs located at      and     respectively.
(Entrance)
(Room A)
(Room B)
Headset
Phone
Ticket
Exhibit
Exhibit
At first, a user locates at     .
: a scope of a context.
Figure 5. A CCRN assuming a museum
D. Propositionizing
To conduct probabilistic model checking, we assign two
kinds of propositions fed(O′ ⊆ O) and seg(s ∈ S) to each
states of given P-CCRN. Given a state ⟨Sseg, Sfed⟩, semantics
of these propositions are deﬁned as follows:
•
seg(s ∈ S) |= ⊤ iff s = Sseg
(a user locates at segment s)
•
fed(O′ ⊆ O) |= ⊤ iff O′ ∈ Sfed (a federation O′ exists)
VI.
CASE STUDY OF RELIABILITY ANALYSIS
We have conducted a case study of a reliability analysis
of a given P-CCRN, using probabilistic model checking. We
assume that a CCRN is given by the designer who intend to
design applications of ubiquitous computing. Here we use a
CCRN of a museum example as shown in Figure 5. Left hand
side and right hand side of this ﬁgure represent the segment
graph G and the catalytic reaction network R of this CCRN
respectively. In this example, a user enters the entrance of a
museum, carrying a phone a, a headset b and a ticket s. Once
the user entered the entrance, the phone a and the headset b
are federated by a reaction associated with the scope of c1,
which is triggered by the ticket s. Then, the federated SOs ab
are worked as a voice guide of the museum. Next, if the user
enters into room A, the federated SO ab and an exhibit d are
federated by a reaction associated with the scope of c2. By
the federated SO abd, an explanation of the exhibit d can be
provided to the user. After this, the user leaves the room A and
the federated SO abd is decomposed and becomes ab again by
a reaction associated with the scope of c3. The similar reactions
occur in the room B, which is for an explanation of an exhibit
e. If the user leaves one of the exhibition rooms and returns
to the entrance, the federated SO ab is decomposed before
leaving the museum.
Next we assign the probability to the user movement and
catalytic reactions. In Figure 5, every directed edges of the
segment graph is colored with blue or red. Blue edges assume
the regular route of the museum to tour and red edges assume
the opposite (i.e., wrong) way. The user can move along with
these edges but here we use parameter α ∈ [0, 1] to decide how
frequent he or she tends to go along with the regular route.
More precisely, in every segments, the user chooses blue edges
with a probability of α, otherwise, he or she chooses red edges
with a probability of 1 − α. Then, if there are more than one
edge after he or she chooses color of edge, he or she chooses
an one edge uniformly from them. For all (i, j) ∈ E, we can
set τi,j as follows:
τi,j =
α/|BLUEi|
if τi,j is a blue edge
(1 − α)/|REDi|
if τi,j is a red edge
(11)
where BLUEi is a set of {(i, j) ∈ E | (i, j) is a blue edge}
and REDi is a set of {(i, j) ∈ E | (i, j) is a red edge}. In
regards to catalytic reactions, we assign the same probability
β ∈ [0, 1] to occurrences of all catalytic reactions. Namely, we
set θr = β for all r ∈ R.
In this conﬁguration, we conducted an experiment of
reliability analysis of P-CCRN. We use PRISM to evaluate the
probability of following properties with the bound parameter
k = 20.
φ1 = P=? [G≤k (¬seg(s3) ∨ fed({a, b, d}))]
(12)
φ2 = P=?[F≤k((seg(s3) ∧ fed({a, b, d})) ∨
(seg(s6) ∧ fed({a, b, e})) )]
(13)
Intuitively, φ1 means that how frequent the user can be always
provided the explanation of exhibition d when he or she is
at segment s2 and φ2 means that how frequent the user can
be provided the explanation of exhibition d or e even just
once when he or she enters the corresponding room of the
exhibition.
Figure 6 shows results of these probability evaluation of
property φ1 and φ2 by changing parameters α and β from 0
to 1. When α and β are 1, this is the most ideal case. In other
words, the user always moves along with the regular route
only and catalytic reactions always react when the conditions
of them satisfy. In this case, both of properties φ1 and φ2
are satisﬁed with a probability of 1. However, if α and β
are decreased (i.e., the user behaves unpleasantly and catalytic
reactions do not ﬁre even if the conditions of them satisfy),
probabilities of properties φ1 and φ2 are also decreased. The
90
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-598-2
UBICOMM 2017 : The Eleventh International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Property
Property
Figure 6. Results of Experiments
most important aspect of this reliability analysis is that we can
evaluate precisely and quantitatively how reliable this kind of
UC scenarios are. For a particular example, quantitative eval-
uation of UC scenarios help us to consider trade-offs between
the reliability of UC scenarios and the cost of implementation
for the satisfaction of the reliability by changing parameters of
probabilities, such as α and β in this case study. In this case,
if β is closer to 1, this means we may need more costs for the
implementations.
VII.
CONCLUSION
In this paper, we proposed the method of reliability analysis
for UC scenarios described by P-CCRN. By our method, we
can discuss the reliability of UC scenarios even if these scenar-
ios are in rather practical situation than ideal cases. Reliability
analyses are important because these analyses are quantitative,
and this means we can discuss about trade-offs between the
reliability and the cost for the satisfaction of the reliability.
Once we design a UC scenario by P-CCRN, we may actually
implement this which usually takes the cost. In that sense,
our approach for reliability analysis is not only theoretical but
also practical. In future work, we analyze various kinds of
UC scenarios assuming more various interferences including
possible situations in real places.
ACKNOWLEDGMENT
This work was partly supported by JSPS KAKENHI (S)
Grant Number 15H05711.
REFERENCES
[1]
R. Minoda, Y. Tanaka, and S.-i. Minato, “Verifying Scenarios of
Proximity-based Federation among Smart Objects through Model
Checking,” in Proceedings of UBICOMM 2016 The Tenth International
Conference on Mobile Ubiquitous Computing, Systems, Services and
Technologies, no. c, 2016, pp. 65–71.
[2]
R. Minoda and S.-i. Minato, “Efﬁcient Scenario Veriﬁcation of
Proximity-based Federations among Smart Objects through Symbolic
Model Checking,” in Proceedings of the 7th International Joint Con-
ference on Pervasive and Embedded Computing and Communication
Systems (PECCS2017), 2017, pp. 13–21.
[3]
A. Cimatti, E. Clarke, and E. Giunchiglia, “Nusmv 2: An opensource
tool for symbolic model checking,” Computer Aided Veriﬁcation, vol.
2404, 2002, pp. 359–364.
[4]
M. Kwiatkowska, G. Norman, and D. Parker, “PRISM 4.0: Veriﬁca-
tion of Probabilistic Real-Time Systems,” in Proc. 23rd International
Conference on Computer Aided Veriﬁcation (CAV’11), ser. LNCS,
G. Gopalakrishnan and S. Qadeer, Eds., vol. 6806.
Springer, 2011,
pp. 585–591.
[5]
S. Guellouz, A. Benzina, M. Khalgui, and G. Frey, “ZiZo : A Complete
Tool Chain for the Modeling and Veriﬁcation of Reconﬁgurable Func-
tion Blocks ZiZo : A Complete Tool Chain for the Modeling and Ver-
iﬁcation of Reconﬁgurable Function Blocks,” International Conference
on Mobile Ubiquitous Computing, Systems, Services and Technologies,
no. c, 2016, pp. 144–151.
[6]
R. Alur and D. L. Dill, “A theory of timed automata,” Theoretical
Computer Science, vol. 126, no. 2, apr 1994, pp. 183–235.
[7]
R. Drechsler and U. K¨uhne, Eds., Formal Modeling and Veriﬁcation of
Cyber-Physical Systems. Wiesbaden: Springer Fachmedien Wiesbaden,
2015.
[8]
C. Xu and S. C. Cheung, “Inconsistency Detection and Resolution
for Context-aware Middleware Support,” Proceedings of the 10th
European Software Engineering Conference Held Jointly with 13th
ACM SIGSOFT International Symposium on Foundations of Software
Engineering, 2005, pp. 336–345.
[9]
S. Kauffman, Investigations.
Oxford New York: Oxford University
Press, 2002.
[10]
Y. Tanaka, “Proximity-based federation of smart objects: liberat-
ing ubiquitous computing from stereotyped application scenarios,” in
Knowledge-Based and Intelligent Information and Engineering Sys-
tems.
Springer, 2010, pp. 14–30.
[11]
J. R. Burch, E. M. Clarke, K. L. McMillan, and D. L. Dill, “Sequential
circuit veriﬁcation using symbolic model checking,” in Proceedings of
the 27th ACM/IEEE Design Automation Conference, ser. DAC ’90.
New York, NY, USA: ACM, 1990, pp. 46–51.
[12]
J. C. Mitchell, V. Shmatikov, and U. Stern, “Finite-state Analysis of
SSL 3.0,” in Proceedings of the 7th Conference on USENIX Security
Symposium - Volume 7, ser. SSYM’98. Berkeley, CA, USA: USENIX
Association, 1998, p. 16.
[13]
S. A. Kripke, “Semantical Analysis of Modal Logic I Normal Modal
Propositional Calculi,” Zeitschrift f¨ur Mathematische Logik und Grund-
lagen der Mathematik, vol. 9, no. 5-6, 1963, pp. 67–96.
[14]
A. Pnueli, “The temporal logic of programs,” 18th Annual Symposium
on Foundations of Computer Science (sfcs 1977), 1977, pp. 46–57.
[15]
G. Holzmann, “The model checker SPIN,” IEEE Transactions on
Software Engineering, vol. 23, no. 5, may 1997, pp. 279–295.
[16]
J. Magee and J. Kramer, Concurrency State Models and Java Programs.
New York, New York, USA: John Wiley and Sons, 1999.
91
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-598-2
UBICOMM 2017 : The Eleventh International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

