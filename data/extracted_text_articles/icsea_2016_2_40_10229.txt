Modeling and Formal Speciﬁcation Of Multi-scale Software Architectures
Ilhem Khlif1,2,3, Mohamed Hadj Kacem1, Khalil Drira2,3 and Ahmed Hadj Kacem1
1 University of Sfax, ReDCAD Research Laboratory, Sfax, Tunisia
2 CNRS, LAAS, 7 avenue du colonel Roche, F-31400 Toulouse, France
3 Univ de Toulouse, LAAS, F-31400 Toulouse, France
ikhlif@laas.fr, mohamed.hadjkacem@isimsf.rnu.tn, khalil.drira@laas.fr, ahmed.hadjkacem@fsegs.rnu.tn
Abstract—Modeling correct complex systems architecture is a
challenging research direction that can be mastered by providing
modeling abstractions. For this purpose, we provide an iterative
modeling solution for a multi-scale description of software archi-
tectures. We deﬁne a step-wise iterative process starting from a
coarse-grained description, and leading to a ﬁne-grained descrip-
tion. The reﬁnement process involves both system-independent
structural features ensuring the model correctness, and speciﬁc
features related to the expected behavior of the modeled domain.
We provide a visual notation extending the graphical UML
(Uniform Modeling Language) notations to represent structural
as well as behavioral features of software architectures. The
proposed approach mainly consists of two steps. In the ﬁrst step,
the architecture is modeled graphically according to the UML
notations. In the second step, the obtained graphical models are
formally speciﬁed using the Event-B method. We implement the
resulting models describing structural and behavioral properties
using the Rodin platform and prove their correctness. We apply
our approach for a methodological design of a smart home
scenario for the homecare monitoring of disabled and elderly
persons.
Keywords–Software; Architecture; multi-scale; iterative; model-
ing; UML; formal; speciﬁcation; structural; behavioral; reﬁnement;
Event-B.
I.
INTRODUCTION
Software architecture design has become the key factor
for the success of the development of large and complex
software systems, for mastering the costs and the quality of
their development. The design of a software architecture is a
complex task. On the one hand, we have to describe the system
with enough details for understanding without ambiguity and
implementing in conformance with architects requirements and
users expectations. On the other hand, we have to master
the complexity induced by the increasing model details both
at the human and automated processing levels. Some high
level properties can be expressed on informal descriptions
with a high level of abstractions and checked on simple
formal descriptions. Some other properties need more detailed
descriptions to be expressed and deep speciﬁcations to be
elaborated. Description details may be application-independent
and mainly structural such as component decomposition, or
system-speciﬁc and mainly behavioral, such as message or-
dering in interaction protocols. An iterative modeling process
that helps architects to elaborate complex but yet tractable
and appropriate architectural models and speciﬁcations can be
implemented by successive reﬁnements. Different properties
of correctness and traceability have to be maintained between
the models and the speciﬁcations at the different levels of
iterations. Providing Rules for formalizing and conducting
such a process is our objective, which we implemented in
visual modeling notations and formally speciﬁed in a formal
description technique. For this purpose, we propose to con-
sider different architecture descriptions with different levels
of modeling details called “the scales”. We deﬁne a step-wise
iterative process starting from a coarse-grained description and
leading to a ﬁne-grained description. The proposed approach
mainly consists of two steps. In the ﬁrst step, multi-scale
architectures are modeled graphically using UML notations.
In the second step, the obtained models are formalized with
the Event-B method, and validated by its supporting Rodin
platform [11]. In order to illustrate our solution, we experiment
our approach with a case study dedicated to the smart home
system for the homecare monitoring of elderly and disabled
persons. The remainder of the paper is organized as follows.
We describe the UML modeling approach in Section II. In
Section III, we present the generated Event-b speciﬁcations.
Section IV presents the case study. In Section V, we present
a survey of related work. We conclude and outline some
perspectives in Section VI.
II.
ITERATIVE MODELING
At the level of abstraction, a software architecture is repre-
sented as a collection of interconnected components, and it is
at this level that the structural and behavioral properties of soft-
ware systems are addressed. We deﬁne multi-scale modeling
as an incremental process where we constantly reﬁne software
systems descriptions. We propose to illustrate UML notations
for describing software architectures at different description
levels. In the ﬁrst iteration, an abstract model is deﬁned.
At each iteration, design modiﬁcations are made and new
details are added. We consider both structural and behavioral
descriptions. In model-driven engineering, traceability links are
established from the application requirements. The traceability
links specify which parts of the design contribute to the
satisfaction of each requirement [9].
A. Structural modeling
We propose structural modeling for describing software
architectures using a visual notation based on UML. To de-
scribe the structure of a multi-scale architecture, we model the
ﬁrst scale by a given coarse-grained description using a UML
component diagram. This model is reﬁned until reaching a
ﬁne-grained description representing the necessary modeling
details. We deﬁne a vertical description scale “Sv+1.h” as
a model that provides additional details of the design, that
pertain to “Sv.h” and more abstraction related to “Sv+2.h”.
A vertical scale can be further reﬁned into several horizontal
description scales (“Sv.h”, “Sv.h+1”,...) thus providing more
details. We consider that v, resp. h, represents the vertical and
55
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-498-5
ICSEA 2016 : The Eleventh International Conference on Software Engineering Advances

C0
S0.0   
S1.1
C0
C1
C2
C0
C1
C2
S1.2
S2.1
C0
C2
C2.1
C1.1
C2.2
C1
C1.2
S2.4
« Publish-Subscribe » 
C0
«Producer-Consumer»
C2
C2.1
C1.1
«Event-Dispatcher» 
C1
Vertical Iterations
…
Horizontal Iterations
C2.2
C1.2
Figure 1. Structural modeling
horizontal iterations (v,h ≥ 0). We, ﬁrst, elaborate an initial
abstract architecture description from the user requirements.
At the ﬁrst scale S0.0, application requirements are speciﬁed
(a unique component C0 is identiﬁed). This is the beginning
of the traceability. A ﬁrst vertical iteration from S0.0 to S1.1
is required in order to provide details on the application, and
reﬁne it with several components. In Figure 1, two components
named C1 and C2 are added. At the same scale, an hori-
zontal iteration is needed to specify the interactions between
components. We represent a link between C1 and C2 in the
scale S1.2. A second vertical iteration is helpful for reﬁning
components with new sub-components, and checking that at
the scale S2.1, the components identiﬁcation is preserved, as
we keep traceability of a component from one scale to another.
This notation is used for identifying a component: Cm where
m represents a cursor on the current component (m ≥ 0). It can
be decomposed in the next scale. The component C1, is reﬁned
with two sub-components identiﬁed as C1.1, C1.2, etc. The
component C2 is reﬁned with two sub-components (C2.1 and
C2.2). Several horizontal iterations are needed in the second
vertical scale to show more speciﬁc details (related to the UML
description). An horizontal iteration called S2.2 adds details
on data relating to the components: roles are associated with
components such as “Event-Dispatcher”, “Producer”, “Con-
sumer”, “Producer-Consumer”, “Client”, “Service”, etc. The
scale S2.2 is inserting communication ports and more details;
the scale S2.3 allows the addition of component interfaces.
Finally, we obtain the model S2.4 where connections are
established between components to deﬁne the architectural
style of the application. In the illustrated example, we are
limited on three vertical iterations to show the necessary
details. However, the iterative process continues while there are
still components to reﬁne. The number of iterations depends on
the application requirements. Each new iteration does not only
include new sub-components but also adds necessary design
details on the information ﬂow between components. In the
scale S2.4, we propose to reﬁne the interaction (link) between
the two components C1 and C2 illustrated at the scale S1.2
with respect to the following traceability constraints: if the
component C1 performs the role of an “Event-Dispatcher” and
the component C2 is a “Producer-Consumer”, the link between
C1 and C2 in S2.1 will be decomposed into a double assembly
connection in the scale S2.4 connecting (C1.1 and C2.1). We
preserve the model traceability from one scale to another by
decomposing links, at the abstract scale, and reﬁning them,
at the next scale, to show possible connections established
between components. Traceability is a desired characteristic
for software management. However, it is not always possible
to trace every design (or architectural) component back to
requirements. To ensure this property, we check during the
iterative process that the interface compatibility is preserved
in the multi-scale architecture: First, we verify through added
details on component roles that each required interface is asso-
ciated with a producer component and each provided interface
is associated with a consumer component. The main issue
is to ensure the well-typed and the well-connected in UML
component diagram. For this purpose, we have implemented
a tool supporting our approach in visual modeling notation
as an Eclipse plug-in to providethe designerwith an editor for
UML modeling architecture. Using this editor, we make sure
that reﬁned models are correct by design. Second, we check
the interface compatibility through constraints on different
scales using the OCL (Object Constraint Language) interactive
console associated with the Eclipse.
B. Behavioral modeling
To specify behavioral features, we use UML sequence
diagram that provides a graphical notation to describe dynamic
aspects of software architectures [7]. The application is ini-
S2.4
S1.2
S0 .0  
C2
C1
M1. Transmit Message M 1
M2. Return ACK Message M 2
C2.1
C1.1
C1.2
C2.2
par
par
M1.1. Transmit Message M 1.1
M1.2. Transmit Message M 1.2
M2.1 Return ACK Message M 2.1
M2.2. Return ACK Message M 2.2
C0
Figure 2. Behavioral modeling
tialized (at the ﬁrst scale), and after successive iterations, the
sets of components and interactions among them are identiﬁed
in a way that supports the required behavior of the abstract
application level. We describe the speciﬁed behavior of an
application using the UML sequence diagram in Figure 2.
The sequence diagram is helpful for describing the message
ordering in interaction protocols during the iterative modeling.
In the ﬁrst scale, the whole application is presented as a
black box to illustrate the System Sequence Diagram (SSD)
named “C0”. The main issue here is to secure the message
transmission and how elements cooperate to ensure correct
information propagation. Several events may reﬁne an abstract
event: The single message (M1) between actors in the scale
(S1) is reﬁned with a set of messages (M1.1, M1.2, M2.1, and
56
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-498-5
ICSEA 2016 : The Eleventh International Conference on Software Engineering Advances

M2.2) in the scale (S2), or the content of translated messages
depends on earlier received message. The sequence diagram,
represented in Figure 2, speciﬁes the behavioral features of the
publish-subscribe architecture. When the Producer-Consumer
component C1 sends a message (M1) to the Event dispatcher
component C2 at the scale S1, the Event-dispatcher tracks this
message and, it replies to the Event-dispatcher by sending an
acknowledgement message (M2). At the next scale S2, the two
messages will be reﬁned into a parallel sequence of messages
while keeping track of the type of message sent or received in
the abstract scale.
Our approach is based on a multi-scale modeling that helps
to automate the construction of correct design architectures.
So, we need to specify the software architecture model that
describes the software components and their composition. In
fact, each model is represented as a set of scales, and each
scale denotes a set of architectures. Following our approach,
the designer starts by modeling the ﬁrst scale architecture
which is reﬁned to give one or many architectures for the next
scale. Then, these architectures are reﬁned in turn to give the
following scale architectures and so on until reaching the last
scale. The transition between scales is ensured by applying
speciﬁc rules deﬁned using the Event-B speciﬁcations. After
constructing the architectures of software architecture model,
we apply the relation between the two models in order to obtain
model-based architectures with different description levels.
III.
EVENT-B FORMAL SPECIFICATION
The aim of formal modeling is to achieve a precise speciﬁca-
tion of the intended structures and behaviors in the design [1].
The advantage of such speciﬁcations is to determine whether
a modeled structure can successfully satisfy a set of given
properties derived from the user requirements. We consider
here specifying a multi-scale architecture using the reﬁnement-
based formal method: the Event-B [11]. We use the Event-
B method and its event based deﬁnition to formalize UML
models. Our approach facilitates layering and mapping the
informal requirements to traceable formal models. An Event-
B model is made of two types of components: contexts and
machines [2]. The obtained UML models are mapped to Event-
B speciﬁcations: the component diagram constitutes the static
part of the architecture, it is speciﬁed with the Event-B method
in the Context part. The sequence diagram constitutes the
dynamic part of the architecture, it is speciﬁed with the Event-
B method in the Machine part. A context describes the static
part of a model, and a machine describes the dynamic behavior
of a model. Each context has a name and other clauses like
“Extends”, “Constants”, “Sets” to declare a new data type
and “Axioms” that denotes the type of the constants and the
various predicates which the constants obey. Machines and
contexts can be inter-related: a machine can be reﬁned by
another, can see one or several contexts, while a context can be
extended by another [8]. A multi-scale software architecture
is described with structural features and behavioral features.
Structural features are speciﬁed with one or several contexts
and behavioral features are speciﬁed with one or several
machines.
A. Structural speciﬁcations
In the component diagram we specify components that con-
stitute the architecture, their types and their connections. This
diagram constitutes the static part of the deﬁned architecture. It
is speciﬁed in the Context part. In the ﬁrst scale S0, the graph-
ical model is transformed into an Event-B speciﬁcation called
Context0. In the Context0, we specify the whole application
with a Component as constants. The component, that composes
the architecture at scale S0.0, is named C0. This is speciﬁed
by using a partition in the AXIOMS clause (C0 partition).
CONTEXT
Context0
SETS
Component
CONSTANTS
C0
AXIOMS
C0 partition : partition(Component, {C0})
END
In the next scales, we use the reﬁnement techniques to gradu-
ally add details until obtaining the ﬁnal scale speciﬁcation.
A new context named Context1 extends the Context0 and
speciﬁes new components in the application. We deﬁne two
components C1 and C2 as constants and the established link
between them. Formally, links are speciﬁed with an Event-B
relation between two components (Link partition).
CONTEXT
Context1
EXTENDS
Context0
CONSTANTS
C1, C2, Link
AXIOMS
C1 partition : partition(Component, C0, {C1}, {C2})
Link partition : Link ∈ C1 ↔ C2
END
A Context2 is extending the previous Context1, and is adding
sub-components of each component. We specify the role of
each component (producers, consumers and event-dispatcher)
as constants. Connectors are speciﬁed with an Event-B relation
between two components. The set of Connectors is speciﬁed
formally with two partitions (Ct1 part, Ct2 part).
CONTEXT
Context2
EXTENDS
Context1
SETS
Role
CONSTANTS
C1.1, C1.2, C2.1, C2.2, P rod,
Cons, EventDis, P rod1, P rodn,
Cons1, Consn, ED1, EDn, Connector1, Connector2
AXIOMS
C2 partition :
partition(Component, {C1.1}, {C1.2}, {C2.1}, {C2.2})
Ct1 part : Connector1 ∈ C1.1 ↔ C2.1
Ct2 part : Connector2 ∈ C1.2 ↔ C2.2
Role part :
partition(Role, {P rod}, {Cons}, {EventDis})
Cons = {C1, .., Cn} ∧ C1 ̸= C2 ∧ ..∧ ̸= Cn
EventDis = {ED1, .., EDn} ∧ ED1 ̸= ED2 ∧ ..∧ ̸= EDn
P rod = {P 1, .., P n} ∧ P 1 ̸= P 2 ∧ ..∧ ̸= P n
END
B. Behavioral speciﬁcations
The Event B machine is used formally, to ﬁnd structural
errors and to verify the semantic of the UML model. To specify
behavioral features, we specify the abstract description scale
with a machine at a high level of abstraction. Then, we add all
57
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-498-5
ICSEA 2016 : The Eleventh International Conference on Software Engineering Advances

necessary details to the ﬁrst machine by using the reﬁnement
process. In the ﬁrst machine, we only specify the modeled
application by extending Context0.
MACHINE
Machine0
SEES
Context0
VARIABLES
C0
INVARIANTS
inv : C0 ∈ BOOL
EVENTS
INITIALISATION
BeginAct
act : C0 := T RUE
EndAct
END
Machine1 is a reﬁnement of the Machine0, using the context
Context1 and adding communication between the components
C1 and C2. The behavior is described as follows: the compo-
nent C1 sends a Message to the component C2. When the
component C2 becomes available, it receives the Message,
processes it and sends the Acknowledgement Message. When
the component C1 becomes available, it receives the ACK-
Message. The invariants (Send Message, Receive Ack) spec-
iﬁes what is the sent message, who is the sender and the
receiver. The Machine1 has a state deﬁned by means of a
number of variables and invariants. Some of variables can be
general as the variable Send, which denotes the sent message
and the variable Receive, which denotes the received message.
The variable Send is deﬁned with the invariant (Send Msg)
which specify that Send is a relation between two components
so that the sender, the receiver and the message are known.
MACHINE
Machine1
REFINES
Machine0
SEES
Context1
VARIABLES
Send, Receive
INVARIANTS
Send Message : Send ∈ BOOL
Receive ACK : Receive ∈ BOOL
EVENTS
INITIALISATION
BeginAct
act1 : Send := F ALSE
act2 : Receive := F ALSE
EndAct
EVT
init1 : Send ∈ C1 → C2
init2 : Receive ∈ C1 → C2
init3 : T ransmit := C1 → T rue, C2 → F alse
END
We follow the same method to specify a second ma-
chine named Machine2 which reﬁnes Machine1, using the
context Context2 and adding communication between the
sub-components C1.1, C1.2, C2.1 and C2.2. The invariants
(SendMsg1.1 , SendMsg1.2 , ReceiveAck2.1 , ReceiveAck2.2)
are speciﬁed in the INVARIANTS clause to check that each
sub-component can’t send a message or receive an acknowl-
edgment only if it is authorised.
MACHINE
Machine2
REFINES
Machine1
SEES
Context2
VARIABLES
SendMsg1.1, SendMsg1.2, ReceiveAck2.1, ReceiveAck2.2
INVARIANTS
Send Message : SendMsg1.1, SendMsg1.2 ∈ BOOL
Receive ACK : ReceiveAck2.1, ReceiveAck2.2 ∈ BOOL
EVENTS
INITIALISATION
BeginAct
a1 : SendMsg1.1 := F ALSE
a2 : SendMsg1.2 := F ALSE
a3 : ReceiveAck2.1 := F ALSE
a4 : ReceiveAck2.2 := F ALSE
EndAct
EVT
init1 : SendMsg1.1 ∈ C1.1 → C2.1
init2 : SendMsg1.2 ∈ C1.2 → C2.2
init3 : ReceiveACK2.1 ∈ C1.1 → C2.1
init4 : ReceiveACK2.2 ∈ C1.2 → C2.2
init5 : transmit1 := C1.1 → T rue, C2.1 → F alse
init6 : transmit2 := C1.2 → T rue, C2.2 → F alse
END
The Event-B machine is used formally, to ﬁnd structural errors
and to verify the semantic of the UML model. Besides, behav-
ioral properties are checked like liveness and reachability. The
reachability means that the components are able to capture all
exchanged messages. We formulate those properties as predi-
cates (INVARIANTS, AXIOMS). We check that each compo-
nent only sends a message if it is authorised. This is controlled
by the invariants (Send-Msg, Receive-ACK). Reaching the last
scale description by using reﬁnement techniques, we guarantee
that reﬁned models are not contradictory and we ensure that
they are correct by design. The multi-scale modeling helps to
automate the construction of correct design architectures. The
aim is to derive those UML models by applying correctness
preserving transformations, i.e. reﬁnements, that conform to
the constraints deﬁned by the application and by the adopted
architecture styles. The reﬁnement techniques proposed by this
method allow to represent architectures at different abstraction
levels and are implemented using the Rodin platform.
IV.
APPLICATION TO THE SMART HOME
This section focuses on modeling the smart home system
for the homecare monitoring of elderly and disabled persons.
The main issue is to ensure efﬁcient management of the
optimized comfort, and the safety of the elderly and disabled
person at home [5]. We illustrate, in Figure 3, the constituent
elements of the smart home application. The monitoring center
is composed of three systems: the Environment Control and
Comfort Management, the Emergency Surveillance Center,
and the Medical Surveillance Center. The Home Care Actor
interacts with the monitoring center, by setting medical or
emergency conditions; the Equipment includes sensors and
house devices; the emergency surveillance center controls
critical situations using the activity sensors. Activity sensors
include fall sensors, presence sensors, video camera and micro-
phone. The medical surveillance center monitors physiological
sensors. While there are problems, the center requires the med-
ical assistant intervention (the doctor, the nurse). The comfort
management and the environment control system guarantees a
comfort life for the users. This center enables communications
between users, control the environment sensors (Humidity
58
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-498-5
ICSEA 2016 : The Eleventh International Conference on Software Engineering Advances

Smart 
Phone
Tablet
PC
Fall
Sensor
Presence
Sensor
Humidity
Sensor
Air Conditionner
Video
Camera
Microphone
Convector
Blood 
Pressure
Sensor
Oximeter
Pulse
WeightScale
sensor
Temperature
Sensor
Doctor Nurse
HomeCare Actor
Medical Surveillance 
Center
Environment Control & 
Comfort Management
Monitoring Center
Equipement
Wifi
Device
Physiological Sensor
Medical
Assistant
Emergency 
Service
Emergency Surveillance
Center
Eldery
Person
Relatives
User
Activity Sensor
Environment Sensor
Figure 3. Smart Home application
and Temperature Sensors), and commands the house devices
(Convectors, Air conditioners).
A. Smart Home Model
We experiment our approach by applying successive iter-
ations to the smart home application. We obtained then the
SmartHome
Monitoring-
Center
HomeCare-
Actor
Equipement
SmartHome
S0.0
S1.2
S3.4
« Publish-Subscribe»  
SmartHome
«Producer-Consumer» 
Homecare-Actor
«Producer-Consumer» 
Equipement
«Network-Dispatcher»
Monitoring-Center
User
Medical
Assistant
Emergency
Service
Doctor
Nurse
Relative
Disabled
/Eldery
Person
Emergenc
Center
Environement
Control&Comfort
Management
Medical
Surveillance
Center
Emergency
Surveillance
System
Environement
Sensor
PhysiologicalS
ActivitySensor
HouseDevice
HumidityS
TemperatureS
Convector
AirConditi
PressureS
WeightScaleS
Oximeter
Fall Sensor
PresenceS
VideoCamr
a
Microphon
« Publish-Subscribe » 
SmartHome
Physiological
Sensor
ActivitySensor
Environement
Sensor
«Producer-Consumer»
Equipement
HouseDevice
«Network-Dispatcher»
Monitoring-Center
Medical
SurveillanceCentr
Emergency
Surveillance
Environement&
ComfortManagem
Medical
Assistant
Emergency
Service
«Producer-Consumer »
Homecare-Actor
User
S2.4
Figure 4. The Smart Home model
following results: In S0.0, we deﬁne the application named
“SmartHome”. The constituent systems of the smart home
are described (in S1.1): HomeCare-Actor, Equipment, and
MonitoringCenter). Those systems communicate with each
other via the monitoring center. Those relationships are rep-
resented (in S1.2) as links. In Figure 4, We illustrate the
iterative process applied to the smart home system. In the
next scale, the three components are reﬁned and speciﬁed
with an associated role as shown in Figure 4. The Mon-
itoringCenter plays the role of an “EventDispatcher”. The
HomeCare-Actor and Equipment play the role of “Producer-
Consumer” in the application. We brieﬂy describe the list of
required/provided services of the HomeCare-Actor component.
The MedicalAssistant receives information about the patient’s
situation from the MedicalSurveillanceCenter, he manages the
patient’s medical care (provides) and returns a report after the
care. The EmergencyService receives information about a crit-
ical situation EmergencySurveillanceCenter, reacts to save the
patient (provides), and returns a report after the intervention.
The User receives not only emergency and medical services
but also comfort services like online communication or house
device command provided by the EnvironementControl And
ComfortManagement component. During the iteration process,
we apply the link decomposing rule with respect to the
component role: if C1 plays the role of an “Event-dispatcher”
and C2 acts as a “Producer-Consumer”, the link in the scale
S1.2 between C2 which is related to “HomeCareActor” or
“Equipment” and C1 in the scale S1.2 will be decomposed
into a double assembly connection in the scale S2.4 between
C1.1 which is related to “MonitoringCenter” and C2.1 which
is related to ‘HomeCareActor” or “Equipment”. While there
are still components to reﬁne in the smart home, we move
to the third scale to add more design details. We focused on
mastering the system complexity description details through
including the third scale. This scale has not only included
new sub-components but also detailed the information ﬂow
between them. Each added sub-component (e.g. the doctor) is
important for the design process. It inﬂuences the abstract level
where smart home requirements are speciﬁed. We illustrate the
last horizontal scale S3.4 adding new sub-components (Doctor,
Emergency Service, Video Camera, etc), and their connections.
B. Smart Home system-speciﬁc properties
In Figure 5, we present one of three fragments of the
UML sequence diagram to demonstrate the behavior of con-
stituent elements. The sequence diagram shows the instances
participating in the interaction having two dimensions: the
vertical dimension represents time; the horizontal dimension
represents different objects which is related to the behavior
of the smart home components. We illustrate the ﬁrst scale
S0.0 using the SSD named “Smart Home” to show the whole
system (as a black box). A vertical reﬁnement called S1.2
allows to describe the objects HomeCare-Actor, Equipment,
and MonitoringCenter) and the exchanged messages in the
diagram “Sd Monitoring”. An object of class Equipment starts
the behavior by sending an alert message to an object of class
MonitoringCenter). This object responds by an acknowledg-
ment message to the equipment and sets the Sleep mode.
The monitoring center sends the information to the object
HomeCare-Actor that will respond immediately and send re-
turn message describing the situation after the care.
59
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-498-5
ICSEA 2016 : The Eleventh International Conference on Software Engineering Advances

SmartHome
Sd EmergencySurveillance
User
1.1 SendAlert on an accident
EmergencyService
3.1.Send an alert to react
4.1 Respond
to save
5.1 Send a report 
on the patient situation
Sd Emergency Surveillance
Emergency
Center
EmergencySurveillance
Center
1.1.1 Send alert on an accident
1.1.4 Send sound alert on a detected emergency situation
Presence
Sensor
2.1.1 Send ACK & Set Sleep Mode for    the Presence sensor
Eldery
person
Video
Camera
Microphone
1.1.2 Send signal on the preseence of the  person in a place
1.1.3 Send video alert on a detected emergency situation
2.1.4 Send ACK & Set Sleep Mode for    the microphone
4.1.1Respond 
2.1.2 Send ACK & Set Sleep Mode for    the Fall sensor
2.1.3 Send ACK & Set Sleep Mode for    the video camera 
Fall
Sensor
Sd Monitoring
HomeCareActor
MonitoringCenter
Equipement
1.Send Status/Alert
2.Send-ACK & set Sleep Mode
3.Send Information
5.Send a report after the care
4. Respond
2.1Send-ACK & set Sleep Mode
Emergency
SurveillanceCenter
S2.4
S1.2
S0.0
S3.4
3.1.1Send  an alert on an
emergency case to react
5.1.1 Send a report on the
patient situation
ActivitySensor
par
par
Figure 5. Fragment of the UML Sequence Diagram
C. Event-B speciﬁcations
We apply the Event-B reﬁnement techniques to check the
correctness of the multi-scale architecture applied to the Smart
Home. We illustrate the Context2 that is extending the previous
Context1, and is adding all sub-components in the smart home.
They are speciﬁed with three partitions: equipment-partition,
Monitoring-partition and Actor-partition. We specify in the
Context2 the components type role (producer-consumers and
event-dispatcher) as constants. There are many connections
between components. The Connectors are speciﬁed with con-
stants in the CONSTANTS clause. The set of Connectors is
composed of all Connectors. This is speciﬁed formally with a
partition (Connector-partition).
CONTEXT
Context2
EXTENDS
Context1
CONSTANTS
ActSensor, Device, EnvSensor, P hysSensor,
EmerSurvCenter, EnvControl, MedSurvCenter,
User, MedAssistant, EmerService, Connector1, ..
AXIOMS
Eq partition :
partition(Component, {ActSensor}, {Device},
{EnvSensor}, {P hysSensor})
Eq partition :
partition(Component, {EmerSurvCenter
{EnvControl}, {MedSurCenter})
Connector = Connector1, .., Connector15⊤
END
To specify behavioral features, we have two steps. First,
we specify the ﬁrst machine at a high level of abstraction.
Second, we add all necessary details by using the reﬁnement
technique. We illustrate an example of machines called Ma-
chine1 that is reﬁning the Machine0, adding communication
between the Smart Home components. The behavior is de-
scribed as follows: the Monitoring-Center sends a Message to
Equipment and then remains released from resources. When
the component Equipment becomes available, it receives the
Message, process it and sends the Acknowledgement Message.
When Monitoring-Center becomes available, it receives the
ACK-Message, process it and then becomes deactivated. The
invariants (Send Message, Receive Ack) speciﬁes what is the
sent message, who is the sender and the receiver (The same
description for the message from the Monitoring-Center to the
HomeCare-Actor Component).
MACHINE
Machine1
REFINES
Machine0
SEES
Context1
VARIABLES
Send, Receive
INVARIANTS
Send Message : Send ∈ BOOL
Receive ACK : Receive ∈ BOOL
EVENTS
INITIALISATION
EVT
i1 : Send ∈ MonitoringCenter → Equipment
i2 : Receive ∈ MonitoringCenter → Equipment
i3 : transmit := MonitoringCenter → T rue,
Equipment → F alse
i4 : transmit := MonitoringCenter → T rue,
HomeCareActor → F alse
END
During the reﬁnement process, we check the correct transmis-
sion of messages between actors and we prove the correctness
property using the Event-B speciﬁcations. We demonstrate
that there is no conﬂict problem between messages sent and
received in parallel sequence which is not possible and correct
with UML notations. Dispatchers cooperate together to route
information from the producer-consumers to the subscribed
event-dispatcher (Monitoring-Center). This interaction is gov-
erned by a principle of information dissemination requiring
that produced information have to reach all subscribed con-
sumers. This is to check the correct message transmission
between dispatchers and producer-consumers.
The Event-b speciﬁcations allow to guarantee a correct
by construction architectures. This formal method provides
three steps. At the ﬁrst step, the designer describes the nec-
essary information for the software architecture model and
the relation between them. Then, the second step consists in
generating automatically all the correct design architectures
following a multi-scale modeling approach. In fact, for each
model, a scale is deﬁned by the designer. Then, it is reﬁned
by successively adding smaller scale details. This reﬁnement
process is performed by applying speciﬁc rules. Finally, the
third step is the selection of the efﬁcient architecture according
to resource constraints.
V.
RELATED WORK
Considerable research studies have been proposed on the
description of software architectures. Multi-level modeling
approaches [10] have been proposed to represent the different
abstraction levels. Baresi et al. [3] presented a UML based
approach and proposed formal veriﬁcation and validation of
embedded systems. The approach is implemented using the
“CorrettoUML”: a formal veriﬁcation tool for UML models.
Other research studies have been proposed for the speciﬁcation
60
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-498-5
ICSEA 2016 : The Eleventh International Conference on Software Engineering Advances

of software systems using formal methods. Model veriﬁcation
activity [12] is performed to ensure the correctness of model.
Formal veriﬁcation means that any errors found in the design
of the system should be corrected. Ben Younes et al. [4]
proposed a meta-model transformation between UML Activity
Diagram and Event B models. A formal framework is deﬁned
to ensure the correctness of the proposed transformations,
and the event B method is used for the formal veriﬁcation
of applications. Bryans et al. [6] presented a model-based
approach to assist in the integration of new or modiﬁed con-
stituent systems into a System of Systems. The authors deﬁned
two levels for system composition, the high-level structural
view that considers the connections within the system, and
the low-level behavioral view that deals with the behavior of
contractual speciﬁcations. They treated an industrial case study
for modeling Audio/Video system.
We can note that the research activities [3], [4], [6] deal
only with structural features during the design of the architec-
ture. They do not take into account the respect of behavioral
featuress to validate the architecture. Whereas, in our work,
we deal with both structural and behavioral features.
We analyze that several studies have been performed on
the modeling of multi-level architectures based on UML.
These semi-formal approaches did not, however, include the
concept of reﬁnement. Although formal techniques and, more
speciﬁcally, works based on graph transformations allow the
architecture reﬁnement, they require certain expertise in mathe-
matics for architects. Moreover, only few studies have provided
a clearly deﬁned process that takes the compatibility between
different description levels into account, a challenging condi-
tion for the multi-level description of software architectures.
Model-based methods have addressed signiﬁcant challenges
in software Engineering. Semi-formal models are used in
the architectural description of complex software systems.
This representation has advantages, mainly with regard to
comprehension, and can help to clarify areas of incompleteness
and ambiguity in speciﬁcations.
In this study, we have considered that a given modeling
level can be described by both vertical and horizontal scales.
Our work will help the architect to design a correct and
elaborated solutions for modeling multiple different levels of
description of the same modeling level through the scales.
Thus, we applied our model-based approach for describing
multi-scale architecture , deﬁning both the structure and the
behaviour of the complex system and interactions between
them. Event-B as a formal method support an interactive and
an automatic theorem proving so that the resulted speciﬁcation
after the transformation process can be proved automatically.
With the notion of reﬁnement, we can to perform successive
reﬁnement to the Event-B model in order to specify different
description scales.
VI.
CONCLUSION
In this paper, we have presented a multi-scale modeling
and speciﬁcation approach for software architectures. We have
proposed UML notations to represent the structure and the
behavior for modeling different description scales, and second
formally speciﬁed the models with the Event-B method. The
formalisation phase allows to formally specify both structural
and behavioural features of these architectures at a high level
of abstraction using Event-B method. We implemented the
elaborated speciﬁcations under the Rodin platform. We have
also presented the application of our approach to the smart
home scenario. Finally, we have presented some research
studies discussing multi-level modeling for software architec-
tures using semi-formal and formal methods. Currently, we
are working on the improvement of the formal veriﬁcation
of architectural properties, and the model transformation from
UML to Event-B. In our future work, we expect to apply the
multi-scale approach to other use-cases for modeling complex
systems architectures (e.g. System of Systems (SoS)) and
implement a tool supporting the approach.
REFERENCES
[1]
Compatibility and inheritance in software architectures.
Science of
Computer Programming, 41(2):105 – 138, 2001.
[2]
J.-R. Abrial. Modeling in Event-B: System and Software Engineering.
Cambridge University Press, New York, NY, USA, 1st edition, 2010.
[3]
L. Baresi, G. Blohm, D. S. Kolovos, N. Matragkas, A. Motta, R. F.
Paige, A. Radjenovic, and M. Rossi. Formal veriﬁcation and validation
of embedded systems: The UML-based mades approach. Softw. Syst.
Model., 14(1):343–363, Feb. 2015.
[4]
A. Ben Younes, Y. Hlaoui, and L. Jemni Ben Ayed. A meta-model
transformation from uml activity diagrams to event-b models. In Com-
puter Software and Applications Conference Workshops (COMPSACW),
2014 IEEE 38th International, pages 740–745, July 2014.
[5]
S. Bonhomme, E. Campo, D. Esteve, and J. Guennec. Methodology and
tools for the design and veriﬁcation of a smart management system for
home comfort. In Intelligent Systems, 2008. IS ’08. 4th International
IEEE Conference, volume 3, pages 24–2–24–7, Sept 2008.
[6]
J. Bryans, J. Fitzgerald, R. Payne, A. Miyazawa, and K. Kristensen.
Sysml contracts for systems of systems. In System of Systems Engi-
neering (SOSE), 2014 9th International Conference on, pages 73–78,
June 2014.
[7]
S. Cˆımpan, F. Leymonerie, and F. Oquendo.
Software Architecture:
2nd European Workshop, EWSA 2005, Pisa, Italy, June 13-14, 2005.
Proceedings, chapter Handling Dynamic Behaviour in Software Archi-
tectures, pages 77–93. Springer Berlin Heidelberg, Berlin, Heidelberg,
2005.
[8]
T. S. Hoang, H. Kuruma, D. Basin, and J.-R. Abrial.
Integrated
Formal Methods: 7th International Conference, IFM 2009, D¨usseldorf,
Germany, February 16-19, 2009. Proceedings, chapter Developing
Topology Discovery in Event-B, pages 1–19. Springer Berlin Heidel-
berg, Berlin, Heidelberg, 2009.
[9]
I. Omoronyia, G. Sindre, S. Bifﬂ, and T. St˚alhane. Relating Software
Requirements and Architectures, chapter Understanding Architectural
Elements from Requirements Traceability Networks, pages 61–83.
Springer Berlin Heidelberg, Berlin, Heidelberg, 2011.
[10]
P. Petrov, U. Buy, and R. Nord. The need for a multilevel context-
aware software architecture analysis and design method with enterprise
and system architecture concerns as ﬁrst class entities.
In Software
Architecture (WICSA), 2011 9th Working IEEE/IFIP Conference on,
pages 147–156, June 2011.
[11]
W. Su, J. Abrial, and H. Zhu. Formalizing hybrid systems with event-b
and the rodin platform. Sci. Comput. Program., 94:164–202, 2014.
[12]
B. Uchevler and K. Svarstad. Assertion based veriﬁcation using psl-like
properties in haskell. In Design and Diagnostics of Electronic Circuits
Systems (DDECS), 2013 IEEE 16th International Symposium on, pages
254–257, April 2013.
61
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-498-5
ICSEA 2016 : The Eleventh International Conference on Software Engineering Advances

