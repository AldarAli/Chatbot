A DSL for Multi-Scale and Autonomic Software Deployment
Raja BOUJBEL, Jean-Paul ARCANGELI
Universit´e de Toulouse UPS - IRIT
France
Raja.Boujbel@irit.fr, Jean-Paul.Arcangeli@irit.fr
S´ebastien LERICHE
Universit´e de Toulouse ENAC
France
Sebastien.Leriche@enac.fr
Abstract—In this paper, we present an ongoing work which
aims at deﬁning and experimenting a Domain-Speciﬁc Language
(DSL) dedicated to multi-scale and autonomic software deploy-
ment. Autonomic software deployment in open environments
is an open issue. There, the topology of target hosts is not
always known due either to unforeseen hardware failures or
limitations (network links, hosts, etc.) or to device arrival and
disappearance. In a previous work, we proposed to describe de-
ployment constraints using a DSL and then to satisfy them using
a middleware for autonomic deployment, rather than classically
building and executing a deployment plan. As deployment of
multi-scale distributed systems demands the expression of speciﬁc
constraints related to dimensions and scales, it is necessary to
think over and deﬁne a new Domain-Speciﬁc Language. In this
paper, we propose a new DSL designed to support the expression
of constraints and properties related to multi-scale and autonomic
software deployment.
Index Terms—Deployment, Multi-Scale, DSL, Component-
Based Software System
I. INTRODUCTION
Pervasive computing, on the one hand, and cloud comput-
ing, on the other hand, are central topics in several recent
research studies. Contributions in both domains have reached
a good level of maturity. Nowadays, new research works have
identiﬁed the need to make pervasive and cloud computing
systems collaborate, so to build systems which are distributed
over several scales, called “multi-scale” systems.
The INCOME project [1] aims at designing software solu-
tions for multi-scale context management, not only in ambient
networks but also in the Internet of Things and clouds, able to
operate at different scales and to deal with the passage from a
scale to another one. Context management is a complex service
in charge of the gathering, the management (processing and
ﬁltering), and the presentation of context data to applications,
which realization is distributed on the different devices which
compose the system. So, context managers are open multi-
scale applications which must be deployed, i.e., made and kept
available for use, in a situation of mobility and variability of
the quality of the resources. In this project, our work focuses
on software deployment and our goal is to develop a frame-
work for supporting the deployment of multi-scale applications
such as context managers. Deployment strategies should take
into account the multi-scale aspects like geography, network,
device, and user, as well as non functional properties such as
efﬁciency and privacy. In multi-scale systems, decentralization,
autonomy and adaptiveness are essential features.
In this paper, we present an ongoing work which aims
at deﬁning and experimenting a Domain-Speciﬁc Language
(DSL) dedicated to multi-scale and autonomic software de-
ployment.
The paper is structured as follows. Section II introduces
the two main aspects of our working context: multi-scale dis-
tributed systems and software deployment. Section III provides
an example of deployment of a multi-scale software system,
analyses the requirements, and proposes to use a DSL to
support autonomic deployment. Section IV discusses related
work on DSL for software deployment. Our DSL is presented
in Section V using the example presented in Section III.
Section VI concludes and discusses some perspectives.
II. CONTEXT OVERVIEW
This section introduces the novel concept of multi-scale
system and provides an overview of software deployment.
A. Multi-scale distributed systems
The term “multi-scale system” is present in several recent
research papers [2], [3], [4]: in these works, authors consider to
make collaborate very small systems (objects from the Internet
of Things paradigm as, for example, swarms of tiny sensors
with very low computing capabilities) with very big systems
(such as those found in cloud computing). They agree that
new issues arise, mainly those related to huge heterogeneity.
In [5], authors argue that the multi-scale nature of a dis-
tributed system should be analyzed independently in several
speciﬁc dimensions such as geography, network, device, data,
user, etc. Thus, a distributed system can be described as multi-
scale when, for at least one dimension, the elements of its
projection onto this dimension are associated with different
scales. Fig. 1, extracted from [6], shows an example of scales
in the “Device processing power” dimension.
Fig. 1: Scales in the “Device processing power” dimension
However, the concept of “multi-scale system” is not actually
mature. The construction of future multi-scale distributed
systems will necessitate a new kind of languages, middleware
and patterns, allowing to take in consideration the multi-scale
aspects of the systems.
291
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

B. Software deployment
Software deployment is a post-production process which
consists in making software available for use and then keeping
it operational. It is a complex process that includes a number of
inter-related activities such as installation of the software into
its environment (transfer and conﬁguration), activation, update,
reconﬁguration, deactivation and deinstallation [7]. Fig. 2
represents the sequence of the activities. Software release and
software retire are carried out on the “producer site”, while
the other activities are carried out on the “deployment site”,
some of them at runtime.
Fig. 2: Software deployment life cycle
Deployment design is handled by an engineer called “de-
ployment designer”. He has to gather information not only
about the software system to deploy and the properties of each
of its components but also about the distributed organization
of the software at runtime. Designing deployment may consist
in expressing properties (commands, requirements, etc.) and
constraints. For instance, the deployment designer may express
that a particular software component should be installed on
some speciﬁc devices or on any device, even on incoming
ones in case of dynamic systems, while satisfying a set
of constraints. As a concrete example, consider a software
component C which should be deployed on each smartphone
which runs Android, has the GPS function active, and is
connected by WiFi.
A deployment plan is a mapping between a software system
and the deployment domain, increased by data for conﬁgura-
tion. The deployment domain is a distributed set of machines
which host the software system and provides resources to it.
The ultimate purpose of deployment design is to produce a
deployment plan which complies with the expressed properties
and constraints. Usually, this task is undertaken by a human
actor.
At runtime, software must be deployed on the domain
according to the deployment plan, this task being possibly
undertaken or controlled by an operator called “deployment
operator”. Automatization of deployment aims at avoiding (or
limiting) human handling in the management of deployment.
Fig. 3 shows the timeline of deployment.
Fig. 3: Software deployment timeline
III. DEPLOYMENT OF MULTI-SCALE SOFTWARE SYSTEMS
In this work, we focus on the design phase of the deploy-
ment process, and precisely on the ways for a deployment
designer to express deployment properties and constraints.
Here is an example, in order to illustrate our aim. Let’s
consider a software system made of different components,
each of them having speciﬁc individual runtime requirements
(memory, OS, etc.). The deployment designer may want to
express not only these requirements, but also some other ones
related to the distribution of the components. For instance, the
deployment designer may want that (C1...C5 are software
components):
• a resource-consuming component C1 runs on a cloud,
• C2 runs on several machines in a given geographical area,
e.g., a city,
• C3 runs on the same device than C1,
• C4 runs on any smartphone of the domain,
• C5 runs on the same network than C4,
• C4 runs on any new smartphone entering in the domain
at runtime.
Moreover, some components may have constraints to run
properly, such as:
• C1 requires that the component C0 is installed and
activated locally,
• C2 must run on a Linux OS and an Arduino (single-board
microcontroller) must be connected to the hosting device,
• C3 requires 40M of free RAM at activation time (Con-
str1),
• C5 requires a 100G hard drive (Constr2).
Fig. 4 illustrates such an example.
This section analyses the problem of software deployment
of multi-scale systems from the design point of view, and
then motivates the use of a Domain-Speciﬁc Language which
supports the expression of multi-scale deployment properties
and constraints.
A. Analysis
Software deployment in large-scale and open distributed
systems (such as ubiquitous, mobile or peer-to-peer systems)
is still an open issue [8]. There, existing tools for software
deployment are reaching their limits: they use techniques
292
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

Fig. 4: Example of multi-scale deployment
that do not suit the complexity of the issues encountered in
such infrastructures. Indeed, they are only valid within ﬁxed
network topology and do not take into account neither host
and network variations of quality of service nor failures of
machines or links which are typical of these environments.
In addition, users of the deployment tools are required
to manage manually the deployment activities, which needs
a signiﬁcant human involvement, possibly out of reach of
concerned end-users (for example, in case of personal devices
like smartphones): for large distributed component-based ap-
plications with many constraints and requirements, it is too
hard and complicated to accomplish the deployment process
manually. Consequently, there is a need for new infrastructures
and techniques that automate the deployment process and
allow a dynamic reconﬁguration of software systems with few
or without human intervention.
Additionally, in our opinion, decentralization, openness and
dynamics (mobility, variations of resources availability and
quality, disconnections, failures) are in favour of autonomy:
the autonomic computing approach [9], where the system self-
manages some properties (self-conﬁguration, self-healing),
may support solutions which satisfy the requirements of dis-
tributed multi-scale software systems deployment. This idea
lead us to “autonomic software deployment” [8].
B. Our approach
Instead of directly expressing a statically deﬁned deploy-
ment plan, we propose to express deployment constraints and
properties from which the deployment plan can be computed.
In this paper, we focus on the expression of the constraints
and properties, not on the construction of the plan. For this
last point, our idea is use a constraint solver, supplying it with
an up-to-date description of a domain (available hosts and their
properties).
So, in order to build the plan, and moreover to allow
management of deployment at runtime, data about the domain
must be collected. Thus, a system of probes should run and
collect data ranging from the domain properties such as free
RAM to more abstract ones related to multi-scale (dimensions
and scales). Relations between probes and properties can be
made explicit at the same level as the deployment properties
and constraints in order to allow the speciﬁcation of the system
of probes at the deployment design time.
C. Towards a DSL for autonomic software deployment of
multi-scale systems
In this ongoing work, our aim is to provide a solution for the
expression of the deployment design, concerning in particular
the dimensions and other signiﬁcant properties of multi-scale
software systems.
Deployment is a speciﬁc operation on software. Its design
requires particular skills. Thus, we think that the deployment
designer could beneﬁt from a dedicated language when stating
the properties and constraints. So, we propose a DSL dedicated
to the description of deployment constraints and properties.
DSLs present several advantages: they use idioms and ab-
stractions of the targeted domain, so they can be used by
domain experts; they are light, so easy to maintain, portable,
and reusable; they are most often well documented, coherent
and reliable, and optimized for the targeted domain [10], [11],
[12].
IV. RELATED WORK ON DSL FOR SOFTWARE
DEPLOYMENT
Existing deployment platforms propose several formalisms
to express deployment constraints, software dependencies,
and hardware preferences of software to deploy. Usually, the
formalisms include architecture description languages (ADL),
deployment descriptors (like XML descriptor deployment),
and dedicated languages (DSL). In this section, we overview
some works on software deployment that propose the use of
a DSL.
Dearle et al. [13], [14] present a framework for autonomic
management of deployment and conﬁguration of distributed
applications. To facilitate the work of the deployment designer,
they deﬁne a DSL, Deladas. Using it, a set of available
resources and a set constraints are speciﬁed. These deﬁ-
nitions permit to generate an applicable deployment plan.
The constraint-based approach avoids the deployment designer
specifying precisely the location of each component, and then
rewriting all the plan in case of problems with a resource.
Deladas does not allow to express multi-scale properties and
constraints. Openness is neither taken into account, the set
of hosts is statically deﬁned in a ﬁle by the deployment
manager. Deployment is still autonomic: at runtime, when
the deployment middleware detects a constraint violation
(dependencies between components), it tries to solve it by a
local adaptation. The new deployment plan is computed by a
centralized management component called MADME.
293
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

Matougui et al. [8] present a middleware framework de-
signed to reduce the human cost for setting up software
deployment and to deal with failure-prone and change-prone
environments. This is achieved by the use of a high-level
constraint-based language and an autonomic agent-based sys-
tem for establishing and maintaining software deployment. In
the DSL (called j-ASD), some expressions dedicated to deal
with autonomic issues are proposed. But they target large-scale
or dynamic environments such as grids or P2P systems, only
within the same network scale.
Sledviewsky et al. [15] present an approach that incorporate
DSL for software development and deployment on the cloud.
Firstly, the developer deﬁnes a DSL in order to describe a
model of the application with it. Secondly, this model is
translated into speciﬁc code and automatically deployed onto
the Cloud. This approach is speciﬁc to deployment on the
cloud. It highlights the need to facilitate the work of the
deployment designer, and that using DSL is a solution for
that.
V. PROPOSITION OF A DSL
In this section, we describe by means of an example our
proposition of a DSL dedicated to the autonomic deployment
of multi-scale distributed systems. Tokens and keywords are
presented further and the grammar is deﬁned in EBNF syntax.
The grammar is available at http://www.irit.fr/∼Raja.Boujbel/
ebnf-jasd.html.
A. Example
We give below (Listing 1) a full example of code for
the deployment of the multi-scale distributed software system
presented in Section III. Then, we use this code to present and
explain the main elements of the language.
1
Include "base.jasd"
2
//base.jasd defines some probes
3
//like OS, RAM, CPU, Network, and HD
5
Component C0 {
6
Version 1
7
URL "http://test.fr/plopC0.jar"
8
}
10
Component C1 {
11
Version 1
12
URL "http://test.fr/plopC1.jar"
13
Require C0
14
DeploymentInterface fr.enac.plop.DIimpl
15
}
17
Probe Arduino {
18
ProbeInterface fr.irit.arduino.DIimpl
19
URL "http://irit.fr/INCOME/arduinoProbe.jar"
20
}
22
Constraint AliveArduino {
23
Arduino Exist, Alive
24
}
26
Constraint LinuxCstr {
27
OS.Name = "Linux"
//OS probe
28
}
31
Constraint Constr1 {
32
RAM.FreeSpace >= 40
//RAM probe
33
}
35
Constraint Constr2 {
36
CPU.Load < 80
//CPU probe
37
Network.BandWith > 1024
//Network probe
38
}
40
Constraint Constr3 {
41
HD.size > 100
//HD probe
42
}
44
Component C2 {
45
Version 1
46
URL "http://test.fr/plopC2.jar"
47
DeploymentInterface fr.enac.plop.DIimpl
48
Constraint Constr1, LinuxCstr, AliveArduino
49
Soft Constraint Constr2
50
}
52
Component C3 {
53
Version 1
54
URL "http://test.fr/plopC3.jar"
55
DeploymentInterface fr.enac.plop.DIimpl
56
Soft Constraint Constr1
57
}
59
Component C4 {
60
Version 1
61
URL "http://test.fr/plopC4.jar"
62
DeploymentInterface fr.enac.plop.DIimpl
63
Soft Constraint Constr1, Constr2
64
}
66
Component C5 {
67
Version 2
68
URL "http://irit.fr/plopC5.jar"
69
Constraint Constr3
70
}
72
MultiScaleProbe Geography {
73
MultiScaleProbeInterface
74
eu.telecom-sudparis.GeographyProbeImpl
75
URL "http://it-sudparis.eu/INCOME/GeoProbe.jar"
76
}
78
//other MultiScale probes are described
79
//the same way
80
//{...}
82
Deployment {
83
AllHosts LinuxCstr
85
C1 @ Constr2, Device.Cloud
86
C2 @ 2..4 Geography.City("Toulouse")
87
C3 @ SameValue Device(C1)
88
C4 @ All Device.SmartPhone
89
C5 @ SameValue Network.MAN(C4)
90
}
Listing 1: Example of code for the deployment of the multi-scale distributed
software system
B. Elements of the language
1) Component: The keyword Component deﬁnes a com-
ponent. The Version ﬁeld is useful for the update activity.
The URL ﬁeld speciﬁes the address where the component
is reachable for download. The DeploymentInterface
ﬁeld speciﬁes the interface of the component, necessary for
the interactions with the deployment system: the latter must
294
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

interact with the component, for conﬁguring and starting
it, for managing it at runtime, and for stopping it. The
Require ﬁeld lists required components: at installation time
of the component, if the required component is not installed,
the deployment system must install it on the device. The
Constraint ﬁeld lists hardware and software constraints
of the component. By default, these constraints are hard, i.e.,
they must be satisﬁed both when generating the deployment
plan and at runtime (so, the deployment system must check
that there is no constraint violation). For the keyword Soft,
see 6).
2) Probe: The keyword Probe deﬁnes a probe. A probe
has two mandatory ﬁelds. The ﬁrst one, the Probe-
Interface, speciﬁes the interface of the probe. This in-
terface is needed for interactions with the deployment system
for information retrieval. The second one, the URL, speciﬁes
the address where the probe is reachable for download.
3) Constraint: The keyword Constraint deﬁnes a con-
straint on a component. It has one kind of ﬁeld, a probe value
test. There can be several tests in a Constraint, like in
Constr2 (line 35). A probe value test is composed by two
or three parts. If the constraint is related to the existence or
the liveliness of a hardware or a software component, the
probe value test is composed by the probe name and keywords
Exists or Alive. These keywords are deﬁned for any probe
interface. For example, at line 23, the used probe is Arduino,
and the constraint uses default methods Exists and Alive.
If the constraint is about a value, the probe value is composed
by the probe name, a method call, a comparator, and a value.
There, the method is probe speciﬁc, and deﬁned in the probe
interface For example, at line 27, the used probe is OS, the
information method used is Name, and its value is compared
to the string "Linux".
4) Multi-scale Probe: The keyword MultiScaleProbe
deﬁnes a multi-scale probe, useful for the deployment. Like
Probe, it has only two ﬁelds. The ﬁrst one, MultiScale-
ProbeInterface, speciﬁes the interface of the probe. The
second one, URL speciﬁes the address where the implemen-
tation of the probe is reachable for download. In our current
solution, scales are deﬁned in the implementation of probes,
and the probes allows to identify the scale of a given device.
5) Deployment:
The
keyword
Deployment
deﬁnes
the deployment properties and constraints. The keyword
AllHosts allows to specify and delimit the deployment
domain: line 83 expresses that the deployment covers all hosts
which satisfy the constraint LinuxCstr. The operator @
allows to specify deployment constraints speciﬁc to a com-
ponent. These constraints can take several forms: the device
hosting the component C1 must satisfy Constr2 and be on
the scale Cloud on the dimension Device (line 85); the
component C2 must be deployed on 2 to 4 devices, in the city
Toulouse (line 86); the component C4 must be deployed
on all devices of the dimension Device.Smartphone, i.e.,
on all smartphones of the domain (line 88). The keyword
SameValue expresses that the component must be in the
same dimension or scale as a referred one: the component C3
(line 87) must be deployed on one device (implicit) which
has the same value in the dimension Device as the device
hosting C1 (in other words, C3 should be deployed on the
same device as C1); the component C5 must be deployed on
a device which is situated in the same medium area network
(MAN) as the device hosting C4 (line 89).
6) Dynamics and openness: Some constructions of the DSL
are particularly well-adapted for the expression of properties
related to dynamics and openness. By default, the constraints
should be satisﬁed during the entire application runtime, and
so must be checked dynamically. The keyword Soft is used
to specify that a constraint should be satisﬁed initially by
the generated deployment plan, but maybe not satisﬁed at
runtime. When specifying the Deployment, the keyword
All allows to specify that a component should be deployed
on a subdomain which satisﬁes (even dynamically) a property
or a constraint. In the example, the component C4 should be
deployed on every smartphone of the domain, including those
which enter in the domain at runtime; so, the deployment
plan evolves dynamically depending on entering and leaving
devices.
The ﬁle must have at least one deﬁnition of a component and
one expression of the deployment. Other ﬁelds are optional. As
the code can be split in several ﬁles, the keyword Include
permits to include other ﬁles (line 1).
VI. CONCLUSION AND FUTURE WORK
In this paper, we present the ﬁrst version of a DSL for
multi-scale and autonomic deployment, and explain the various
elements of the language by means of an example. This DSL
allows to express the deployment constraints of a multi-scale
software system and its components. These constraints drive
the computation of the deployment plan, and are used by the
autonomic deployment system do detect (and possibly repair)
any constraint violation at the application runtime.
Another part of our work concerns the realization of this
autonomic deployment system. We are designing it as a
middleware, on the same basis than ﬁrst experiments described
in our previous work [8]. This middleware will enable deploy-
ment in multi-scale environments. It will provide the probes
needed to gather informations about the hosts.
We believe that a DSL is the best way for a deployment
designer to describe deployment constraints. A DSL has much
more expressiveness than any Markup Language (such as
XML), and is more efﬁcient since the deployment designer
expresses (and read) directly concepts of its ﬁeld of expertise.
Moreover, modern tools for making DSL allows their design-
ers to integrate several level of validation (not only syntactic
but also semantic).
Presently, the DSL targets the installation and activation
activities. Other activities and features, as constraint infringe-
ment at application runtime, are hard coded in the deployment
manager system. In the future, we can move some of them
at the DSL level, to increase expressiveness and ﬂexibility
when designing deployment. For example, we can add in the
grammar the keyword on-deinstall or on-update to
295
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

deﬁne actions to perform when deinstalling or updating a
component.
Focusing on multi-scale systems, we do need a sound and
extensible vocabulary to describe the dimensions and their
scales. In the INCOME project, another ongoing work aims at
deﬁning an ontology for multi-scale distributed systems. We
plan to integrate these concepts in our DSL.
Besides, we are currently working on a toolchain for our
DSL. Using Xtext and Xtend frameworks [16], we have real-
ized an Eclipse plugin for the edition of the DSL that makes
it multi-platform compliant and easy-to-use for a deployment
designer. The DSL and the Eclipse plugin are part of the
deliverables of the INCOME project.
ACKNOWLEDGMENTS
This work is part of the French National Research Agency
(ANR) project INCOME [17] (ANR-11-INFR-009, 2012-
2015). The authors thank all the members of the project that
contributed directly or indirectly to this paper.
REFERENCES
[1] J.-P. Arcangeli, A. Bouzeghoub, V. Camps, C. M.-F. Canut, S. Chabri-
don, D. Conan, T. Desprats, R. Laborde, E. Lavinal, S. Leriche,
H. Maurel, A. P´eninou, C. Taconet, and P. Zarat´e, “INCOME - Multi-
scale context management for the internet of things,” in AmI, ser.
Lecture Notes in Computer Science, F. Patern`o, B. E. R. d. Ruyter,
P. Markopoulos, C. Santoro, E. v. Loenen, and K. Luyten, Eds., vol.
7683.
Springer, 2012, pp. 338–347, doi:10.1007/978-3-642-34898-3.
[2] G. Blair and P. Grace, “Emergent middleware: Tackling the interoper-
ability problem,” Internet Computing, IEEE, vol. 16, no. 1, pp. 78–82,
Jan.-Feb. 2012, doi:10.1109/MIC.2012.7.
[3] M. Kessis, C. Roncancio, and A. Lefebvre, “DASIMA: A ﬂexible man-
agement middleware in multi-scale contexts,” in Information Technol-
ogy: New Generations, 2009. ITNG ’09. Sixth International Conference
on, April 2009, pp. 1390–1396, doi:10.1109/ITNG.2009.338.
[4] M. van Steen, G. Pierre, and S. Voulgaris, “Challenges in very large
distributed systems,” Journal of Internet Services and Applications,
vol. 3, no. 1, pp. 59–66, 2012, doi:10.1007/s13174-011-0043-x.
[5] S. Rottenberg, S. Leriche, C. Lecocq, and C. Taconet, “Vers une
d´eﬁnition d’un syst`eme r´eparti multi-´echelle,” in Journ´ees francophones
Mobilit´e et Ubiquit´e (UBIMOB).
C´epadu`es Editions, 2012, In French.
[6] S. Rotteneberg, S. Leriche, C. Taconet, C. Lecocq, and T. Desprats,
“From Smartdust to Cloud: The emergence of multiscale distributed
systems,” 2013, Unpublished.
[7] A. Carzaniga, A. Fuggetta, R. S. Hall, D. Heimbigner, A. Van Der Hoek,
and A. L. Wolf, “A characterization framework for software deployment
technologies,” DTIC Document, Tech. Rep., 1998.
[8] M. E. A. Matougui and S. Leriche, “A middleware architecture
for autonomic software deployment,” in ICSNC ’12 : The Seventh
International Conference on Systems and Networks Communications.
Lisbon, Portugal: XPS, 2012, pp. 13–20, 12619 12619 . [Online].
Available: http://hal.archives-ouvertes.fr/hal-00755352
[9] J.
O.
Kephart
and
D.
M.
Chess,
“The
vision
of
autonomic
computing,”
Computer,
vol.
36,
no.
1,
pp.
41–50,
2003,
doi:10.1109/MC.2003.1160055.
[10] A. Van Deursen, P. Klint, and J. Visser, “Domain-speciﬁc languages:
An annotated bibliography,” ACM Sigplan Notices, vol. 35, no. 6, pp.
26–36, 2000.
[11] M. Strembeck and U. Zdun, “An approach for the systematic develop-
ment of domain-speciﬁc languages,” Software: Practice and Experience,
vol. 39, no. 15, pp. 1253–1292, 2009, doi:10.1002/spe.936.
[12] J.-P. Tolvanen and S. Kelly, “Integrating models with domain-speciﬁc
modeling languages,” in Proceedings of the 10th Workshop on Domain-
Speciﬁc Modeling, ser. DSM ’10.
New York, NY, USA: ACM, 2010,
pp. 10–1, doi:10.1145/2060329.2060354.
[13] A. Dearle, G. N. C. Kirby, and A. J. McCarthy, “A framework for
constraint-based deployment and autonomic management of distributed
applications,” in ICAC, ser. 1st International Conference on Autonomic
Computing (ICAC 2004), New York, NY, USA.
IEEE Computer
Society, May 2004, pp. 300–301, doi:10.1109/ICAC.2004.3.
[14] A. Dearle, G. N. C. Kirby, and A. McCarthy, “A middleware frame-
work for constraint-based deployment and autonomic management of
distributed applications,” CoRR, vol. abs/1006.4733, 2010.
[15] K. Sledziewski, B. Bordbar, and R. Anane, “A DSL-based approach to
software development and deployment on cloud,” in AINA, ser. 24th
IEEE International Conference on Advanced Information Networking
and Applications, AINA 2010, Perth, Australia, 20-13. IEEE Computer
Society, April 2010, pp. 414–421, doi:10.1109/AINA.2010.81.
[16] M. Eysholdt and H. Behrens, “Xtext: implement your language faster
than the quick and dirty way,” in SPLASH/OOPSLA Companion,
ser. Companion to the 25th Annual ACM SIGPLAN Conference on
Object-Oriented Programming, Systems, Languages, and Applications,
SPLASH/OOPSLA 2010, Reno/Tahoe, Nevada, USA, W. R. Cook,
S. Clarke, and M. C. Rinard, Eds.
ACM, October 2010, pp. 307–309,
doi:10.1145/1869542.1869625.
[17] “INCOME,” http://anr-income.fr, February 2012, last access 2013.
296
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

