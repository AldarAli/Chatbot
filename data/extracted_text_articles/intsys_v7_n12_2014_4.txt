39
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Determining Robustness of Synchronous
Programs under Stuttering
Ingram Bondin and Gordon J. Pace
University of Malta
Malta
ingrambondin@gmail.com, gordon.pace@um.edu.mt
Abstract—Robustness
of
embedded
systems
under
potential
changes in their environment is crucial for reliable behaviour.
One typical environmental impact is that of the inputs being
slowed down — due to which, the system may no longer satisfy
its speciﬁcation. In this paper, we present a framework for
analysing the behaviour of synchronous programs written in
Lustre under such environmental interference. Representing slow
input by stuttering, we introduce both strong and weak slowdown
robustness constraints with respect to this phenomenon. Fur-
thermore, static and dynamic algorithmic techniques are used to
deduce whether such constraints are satisﬁed, and the relationship
between stateful programs and the slowdown model considered
is explored.
Keywords–Synchronous Languages; Lustre; Slowdown; Stutter
I.
INTRODUCTION
Software is increasingly becoming more prominent as a
controller for a variety of devices and processes. Embedded
systems operate within an environment, by which they are
affected and with which they interact — this tight interaction
usually means that changes to the environment directly change
the behaviour of the embedded system. One such situation
can occur when the environment slows down its provision
of input to the system, possibly resulting from a variety of
reasons. For example, the system producing the inputs or the
communications channel on which these inputs pass to the
program might be under heavy load, delaying the inputs; or
the program is deployed on a faster platform, therefore making
the input relatively slower.
One question that arises immediately in such scenarios is
how the system behaves when its input slows down. Does it
act in an expected manner, or does the slow input cause it to
produce unwanted output? In this paper (which is an extended
version of [1]), we develop an approach to study whether
a system continues to behave correctly when the inputs are
slowed down. This leads us to different notions of robustness
to slow input since, for instance, in some cases we may desire
the output to be delayed by the same amount as the inputs,
whereas in others, the values but not the actual delays on the
outputs are important.
The theory we develop is applied to the synchronous
language Lustre [2], which enables the static deduction of a
program’s resource requirements, making it ideal for the design
of embedded systems. Although retiming analysis techniques
for continuous time can be found in the literature [3], our
approach adapts them for discrete time, the timing model used
by Lustre and other synchronous languages.
Such a theory requires addressing a number of considera-
tions. In Section II we deﬁne streams [4], which are inﬁnite
sequences of values, as well as the Lustre programs that
manipulate them. In the model we adopt, streams can be
slowed down through the repetition of values, which is also
called stuttering. Stuttering can be a valid model for slow input
under several scenarios:
•
If a memory’s clock signal becomes slower, the mem-
ory will take more time to read new input, and thus
will maintain its present output for a longer time. A
program that samples the values of this memory at the
same rate will then experience repetition in its input.
•
The system providing the input might not be ready to
provide its output, or it might experience a fault from
which it needs time to recover. In these situations,
some systems might keep their present output constant
until they are ready once again. In this case, the
receiving program will also experience repetition in
its input.
•
A physical process that is being sampled in order
to provide input to a program might slow down.
Under certain sampling conditions, the resulting input
received by the program corresponds to experiencing
stutter in its inputs.
The effect of slow input on program behaviour when
modelled through stutter, provides a more complex scenario
than that considered in the literature [3], [4], [5], [6], [7]. In
particular, additional input symbols from a slow stream can
change a program’s internal state, requiring a more complex
analysis to determine whether it behaves correctly. Our use of
the Lustre language (with its simple semantics) will provide a
useful setting for studying how program state and this type of
slow input interact.
In Section III we identify a number of robustness properties
that characterise acceptable program behaviour to slow input
in a number of different scenarios. We consider both properties
similar to those found in simpler slowdown models as well as
weaker ones which are useful in our kind of model.
Given a robustness property, one desires an algorithmic
way of checking whether or not it holds for a given program.
Sections IV and V address this issue. Section IV considers
a method based on the static analysis of the program’s text,
and yields compositionality results for the properties being
considered. On the other hand, Section V focuses on a method
based on the dynamic analysis of a program’s state space.

40
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
The analysis techniques we present focus on Boolean (or ﬁnite
type) Lustre programs. Although a number of results can be
lifted to programs over arbitrary types, this does not apply in
general and will be regarded as outside the scope of this work.
To demonstrate the application of the analysis techniques,
we apply the two aforementioned approaches to various
Boolean Lustre programs in Section VI. Finally, in Section
VII we compare our work to existing results, while in Section
VIII we give some concluding remarks. It should be noted that
this paper is an extended version of [1]. The main extensions
are the following.
•
In Section III, we provide a proof that all robustness
properties considered are relaxations of a strong prop-
erty known as stretch robustness.
•
In Section IV, we provide detailed proofs for all the
static analysis results stated.
•
In Section V, we give a new strong condition for
showing that a program is not stretch robust, and a
new condition for showing that a program is stretch ro-
bust without relying on the program being effectively
stateless. This resolves the question of whether there
are non-trivial stateful programs that satisfy stretch ro-
bustness when using a stutter based slowdown model.
•
In Section VI, we apply the new conditions discussed
in Section V to the programs considered in [1].
II.
STREAMS, SLOWDOWN AND LUSTRE PROGRAMS
We adopt the standard view of a stream s as an inﬁnite
sequence of values over a particular type, representing the
value of the stream over a discrete time domain. We shall
write s(t) to denote the value taken by stream s at time t.
Given a number of streams s1, . . . , sn we will ﬁnd it conve-
nient to collect these into a vector of streams v = ⟨s1, . . . , sn⟩.
In this case, we shall use the notation v(si) to denote the
stream si in the vector. Two vectors v1 and v2, can be
combined, modulo renaming of streams, into one vector v1∪v2,
containing all the streams from these two vectors.
Assuming a vector of streams v = ⟨s1, . . . , sn⟩, we denote
the behaviour of all streams at a particular time t by v(t),
which will yield the tuple of values (s1(t), . . . , sn(t)).
By slowing down a stream, one obtains the same sequence
of values, but possibly with some of the values repeated a
number of times, representing stutter. A slowdown can be
characterised using a latency function — a total function that
returns the number of times each value in the stream will
stutter for. Given a stream s that is slowed down according
to a latency function λ, one obtains the slowed down stream
sλ:
sλ = s(0), . . . s(0)
|
{z
}
λ(0)+1
, s(1), . . . s(1)
|
{z
}
λ(1)+1
, . . . s(n), . . . s(n)
|
{z
}
λ(n)+1
. . .
Note that sλ is obtained from s by replacing the value of s at
time t by a block of of λ(t) + 1 copies of this value. We will
write Startλ
t to denote the time instant at which the tth such
block begins: Pt−1
i=0 λ(i). Similarly, Endλ
t denotes the time
instant at which the block ends and is analogously deﬁned.
Note that the constant zero latency function leaves the
stream untouched. If a latency function is a constant function,
we shall refer to it as uniform.
As before, we will extend this notation for vectors of
streams, with ⟨s1, . . . sn⟩λ being equivalent to ⟨s1λ, . . . , snλ⟩.
From this it is easy to derive the useful fact that latency
functions distribute over vector union, giving us the identity
(v1 ∪ v2)λ = (v1λ ∪ v2λ).
Lustre [2] provides a way of symbolically specifying
systems that process streams in a declarative manner. A Lustre
program P = ⟨V, I, O, E⟩ is deﬁned over a set of stream
variables V , with two disjoint subsets I and O consisting of the
input and output stream variables of the program, respectively,
and a set of equations E that explains how to compute the
value of each output variable at every instant of time in terms
of other program variables. Equations can take one of the
following forms:
y
=
⊗(x1, . . . xn)
y
=
pre x1
y
=
x1 -> x2
y
=
x1 fby x2
Instantaneous operators ⊗ are used to represent computation
performed at each time instant. For instance, the equation
y = ∧(x1, x2) would update the value of stream variable y
with the value of the conjunction of the stream variables x1
and x2 at each time instant: y(t) = x1(t) ∧ x2(t). The delay
operator pre allows access to the previous value of a given
stream variable: (pre x)(t+1) = x(t) with the resulting stream
being undeﬁned for the initial time point, at which it is said
to take the value Nil. In fact, pre behaves like an uninitialised
memory. The initialisation operator x1 -> x2 yields a stream
behaving like x1 at the ﬁrst time instant, and like x2 elsewhere:
(x1 -> x2)(0) = x1(0) and (x1 -> x2)(t+1) = x2(t+1).
These last two operators are frequently combined to produce
an initialised memory using the followed-by operator, with
x1 fby x2 being equivalent to x1 -> pre x2.
Below we illustrate two sample programs. The program
TOGGLE represents a toggle switch that starts in the Boolean
state true, and which outputs its present state if its toggle input
is false and inverts and outputs its present state if the toggle
input is true. On the other hand, the program SISO is a 4-bit
serial in serial out register, which starts with all its memories
set to true.
node TOGGLE(toggle : bool)
returns(out : bool);
var X, Y : bool;
let
out = if toggle then x else y;
x = not y;
y = true fby out
tel;
node SISO(i1 : bool)
returns(i5 : bool);
var i2, i3, i4 : bool;
let
i2 = true fby i1;
i3 = true fby i2;
i4 = true fby i3;
i5 = true fby i4;
tel;
We will use the notation Pinst, Pdelay, Pinit, and Pfby for
the primitive programs with just one equation consisting of a
single application of an instantaneous, delay, initialisation or

41
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
followed-by operator, respectively. For each primitive program,
the variable occurring on the left hand side of its equation is
an output variable, those appearing on the right are inputs.
For a Lustre program P, dep0(P) ⊆ V × V relates a
stream variable y to a stream variable x if y is deﬁned in
P by an equation with x appearing on the right hand side.
The irreﬂexive transitive closure of this relation denotes the
dependencies between the stream variables and is written as
dep(P). Another important concept is that of an instantaneous
dependency relation. This relation can be obtained by starting
from the relation inst0(P) ⊆ V × V , which relates a stream
variable y to a stream variable x only if y’s deﬁning equation
involves x, and x does not appear in a pre equation or on the
right hand side of an fby equation. The irreﬂexive transitive
closure of this relation, inst(P) denotes the instantaneous
dependencies between stream variables. A Lustre program P is
said to be well-formed if none of its variables instantaneously
depend on themselves: ∀s · (s, s) /∈ inst(P).
Given two Lustre programs P1 and P2 (with inputs I1, I2
and outputs O1, O2, respectively) their composition, written
P1 | P2, is the Lustre program whose equation set is the union
of the equation sets of the respective programs. Its inputs are
the inputs of either program not appearing as outputs of the
other (I = (I1 ∪I2)\(O1 ∪O2)), and vice versa for its outputs
(O = (O1∪O2)\(I1∪I2)). In particular, certain speciﬁc types
of composition shall be referred to as follows:
•
Disjoint composition, if O2 ∩ I1 = O1 ∩ I2 = ∅.
•
Composition without feedback, if O2 ∩I1 = ∅ or O1 ∩
I2 = ∅.
•
Fully connected composition, if O2∩I1 = ∅ and O1 =
I2, or conversely O1 ∩ I2 = ∅ and O2 = I1.
Another important operation is that of adding a feedback
loop to a program P by connecting an output y to an input x
written P[y → x], provided that y does not depend in any way
on x, that is, (y, x) ̸∈ dep(P). Adding a feedback loop can
also be deﬁned in terms of composition of the original program
with the Lustre program P ′ = ⟨{x, y}, {y}, {x}, {x = y}⟩, as
follows:
P[y → x]
df= P | P ′
Assuming the existence of an ordering on the program’s
variables, given a Lustre program P, and a vector i that assigns
a stream to each of the program’s input variables, P(i) denotes
the vector o of output streams corresponding to the output
variables of P as computed by the semantics of Lustre [2].
Our goal is therefore that of identifying Lustre programs
P such that upon slowing down their inputs i according to a
latency function λ, will result in P still being well behaved. In
the next section we will identify different forms of robustness
of P(iλ) with respect to the unslowed behaviour P(i).
Boolean Lustre programs can also be compiled into au-
tomata spanning over the state space they cover [8]. This can
be deﬁned for Lustre programs using fby (instead of delays)
as follows:
Deﬁnition 1: (Lustre Automaton). Let P be a Boolean
Lustre program with n input variables, m output variables, and
k fby equations of the form y = x1 fby x2. Then, this program
can be compiled into an automaton A = ⟨S, sinit, τ, δ⟩, where
S is its set of states, sinit is its initial state, τ : Bn × S → S
is its transition function and δ : Bn × S → Bm is its output
function. The automaton, processes the input vector provided
to the program one tuple at a time. During each instant, it
uses its current input tuple and its present state to (i) move to
a new state under the guidance of its transition function τ and
(ii) output an output tuple as deﬁned by its output function δ,
which represents the values of the program’s output variables
at that particular time instant. The program P can be converted
into automaton A using the following procedure.
External Initialisation: A program is said to be initialised
externally if in at least one of its fby statements x1 fby x2,
the initial variable x1 depends on one of the program’s input
variables.
States: Each fby statement x1 fby x2 corresponds to a memory
element in the program, whose value is determined by the
variable x1 at the ﬁrst instant and by the variable x2 at all
further instants. Since each such memory can either be true
or false, we create 2k states, with each state representing
one possible conﬁguration of the program’s memories. If the
program is initialised externally, we also add a special initial
state init to the set of states.
Initial State: If the program is initialised externally, the
initial state is init. Otherwise, the initial state is the state
corresponding to the conﬁguration obtained by evaluating the
variables of the form x1 within the program’s fby statements.
Transition Function: With n input variables, there are 2n
possible input tuples. Each state therefore has 2n transitions,
with each transition labelled with the associated input tuple.
Given a state s ̸= init and input tuple a, the next state τ(a, s)
is computed as follows (i) assign the conﬁguration represented
by present state s to the respective variables of the form
x2 occurring on the right hand side of fby statements, (ii)
assign the input values represented by tuple a to the respective
input variables and (iii) simulate the Lustre program, using the
deﬁning equations of the variables of the form x2 to determine
the conﬁguration of the memories at the next time instant,
allowing the selection of the appropriate next state. The initial
state init, if present, also has 2n transitions. The next states are
determined as follows (i) assign the input values represented
by tuple a to the respective input variables, (ii) use the deﬁning
equations of variables of the form x1 to compute the value of
the initialisation variables and (iii) simulate the Lustre program
using the deﬁning equations of the variables of the form x2,
which determine the next state. Again, these values determine
the conﬁguration of the memories at the next time instant and
allow the selection of the appropriate next state.
Output Function: Each transition is associated with an m-
tuple, which represents the values of the output variables when
the automaton ﬁnds itself in a certain state and processes a
certain input tuple. The procedure for obtaining the output
tuple is similar to that for obtaining the next state, except that
the output tuple is constructed by simulating the program and
considering the values of the output variables.

42
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 1 shows the automaton that would be obtained by
applying the above procedure to the toggle switch program
TOGGLE. The two states represent the two possible conﬁgu-
rations that the memory corresponding to the program’s only
fby equation can be in. Meanwhile, for each transition, the
value on the left shows the value of the toggle input variable
that causes the transition, and the value on the right shows the
output value computed by the program. We shall return to this
representation of the TOGGLE program at a later stage.
true
start
false
true/false
true/true
false/true
false/false
Figure 1.
Automaton obtained from toggle switch program
We now consider a number of different forms of program
robustness to slow input.
III.
SLOWDOWN ROBUSTNESS
Whether a program behaves in an acceptable way depends
on the scenario it is operating in. In this section, the four
robustness properties of stretch robustness, stutter robustness,
fast-enough robustness and immediate-at-ﬁrst robustness are
introduced, characterising desirable behaviour under different
circumstances.
A. Stretch Robustness
Stretch robustness (STR) speciﬁes the fact that if the
input of a program slows down by some amount, then the
output of a program should slow down by the same amount.
This property can be formalised by requiring that whenever a
latency function λ is applied to a program’s input, the program
will respond by applying the same latency to its output.
Deﬁnition 2: (Stretch Robustness). A program P is said to
be stretch robust with respect to a latency function λ, if for
any input vector i: P(iλ) = P(i)λ. P is simply said to be
stretch robust if it is stretch robust with respect to all latency
functions.
The ﬁgure below shows the relationship between a slow
input vector iλ and the required program output P(iλ):
iλ
i(0), . . . i(0)
|
{z
}
λ(0)+1
,
i(1), . . . i(1)
|
{z
}
λ(1)+1
,
. . .
i(n), . . . i(n)
|
{z
}
λ(n)+1
. . .
P(iλ)
o(0), . . . o(0)
|
{z
}
λ(0)+1
,
o(1), . . . o(1)
|
{z
}
λ(1)+1
,
. . .
o(n), . . . o(n)
|
{z
}
λ(n)+1
. . .
One immediate consequence of this property is that ad-
ditional repetition of the program’s input does not cause the
program to change its output. Stretch robustness is thus useful
in situations where one requires the program not to change its
output when faced with additional latency. Stretch robustness
is a very strong property, which can be relaxed in a number
of ways to obtain weaker criteria that may be sufﬁcient in
certain circumstances. We shall now consider these criteria,
leaving the proof that these are indeed relaxations of stretch
robustness to Theorem 6.
B. Stutter Robustness
Stutter robustness (STU) requires that if the input of a
program slows down by some amount, the output of the
program should also slow down, but possibly at a different rate.
This will be modelled by requiring that whenever a latency
function λ is applied to a program’s input, the program will
respond by applying some latency function λ′ to its output.
Unlike stretch robustness, λ and λ′ need not be equal:
Deﬁnition 3: (Stutter Robustness). A program P is stutter
robust with respect to a latency function λ if there exists a
latency function λ′ such that for every input vector i: P(iλ) =
P(i)λ′. P is said to be stutter robust if it is stutter robust with
respect to any latency function.
The relationship between a slow vector of inputs iλ and
the required program output P(iλ) is shown below:
iλ
i(0), . . . i(0)
|
{z
}
λ(0)+1
,
i(1), . . . i(1)
|
{z
}
λ(1)+1
,
. . .
i(n), . . . i(n)
|
{z
}
λ(n)+1
. . .
P(iλ)
o(0), . . . o(0)
|
{z
}
λ′(0)+1
,
o(1), . . . o(1)
|
{z
}
λ′(1)+1
,
. . .
o(n), . . . o(n)
|
{z
}
λ′(n)+1
. . .
Thus for a stutter robust program, the output under slow
input can be obtained from the original output by adding any
number of repetitions to the values appearing in the original
output, without adding any other artifacts nor removing any
values. This means that stutter robustness is useful in situations
where one needs to ensure that the output under slow input
has the same structure as the original output, but one is able
to tolerate additional repetition in the slow output.
C. Fast-Enough and Immediate-at-First Robustness
In stretch robustness, the value of the outputs remains equal
to the original value in the unslowed system. In fast-enough
robustness (FE) this constraint is relaxed by requiring only that
the program converge to the original output before the slowed
down input ends. Formally, we shall say that a program is
fast-enough robust if, when we apply a latency function λ to
the program’s input, the slow output has the property that its
value at the end of each block of repetitions (at points of the
form Endλ
t ) is equal to the value taken by the original output
at the points t (i.e., those points that were expanded into the
blocks of repetitions).
Deﬁnition 4: (Fast-Enough Robustness). A program P is
fast-enough robust with respect to a latency function λ if for
any input vector i:
∀t : T · P(iλ)(Endλ
t ) = P(i)(t)

43
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
P is said to be fast-enough robust if it is fast-enough robust
with respect to any latency function.
Fast-enough robustness will be primarily of interest for
particular latency functions. As a property, it can be visualised
as follows (using ? to indicate don’t-care values):
iλ
i(0), . . . i(0)
|
{z
}
λ(0)+1
,
i(1), . . . i(1)
|
{z
}
λ(1)+1
,
. . .
i(n), . . . i(n)
|
{z
}
λ(n)+1
. . .
P(iλ)
?, . . .?, o(0)
|
{z
}
λ(0)+1
,
?, . . .?, o(1)
|
{z
}
λ(1)+1
,
. . .
?, . . .?, o(n)
|
{z
}
λ(n)+1
. . .
This robustness property is useful in scenarios in which one
can tolerate the fact that additional latency on the input might
produce undesirable intermediate results as long as the original
value is produced by the end of the latency period.
The dual of fast-enough robustness is immediate-at-ﬁrst
robustness (IAF) — instead of constraining the slow input to
converge to the original value before a block of repetitions
ends, it requires it to produce the original value as soon as a
block of repetitions starts, leaving it free to assume any value
until that block of repetition ends.
Deﬁnition 5: (Immediate-At-First Robustness). A program
P is said to be immediate-at-ﬁrst robust with respect to latency
function λ if for any input vector i:
∀t : T · P(iλ)(Startλ
t ) = P(i)(t)
P is said to be immediate-at-ﬁrst robust if it satisﬁes the
above constraint with respect to any latency function.
Immediate-at-ﬁrst robustness can be visualised as follows:
iλ
i(0), . . . i(0)
|
{z
}
λ(0)+1
,
i(1), . . . i(1)
|
{z
}
λ(1)+1
,
. . .
i(n), . . . i(n)
|
{z
}
λ(n)+1
. . .
P(iλ)
o(0), ?, . . .?
|
{z
}
λ(0)+1
,
o(1), ?, . . .?
|
{z
}
λ(1)+1
,
. . .
o(n), ?, . . .?
|
{z
}
λ(n)+1
. . .
This robustness property is useful in scenarios in which one
requires the program to react immediately as soon as the la-
tency on a previous input value wears off, but in which further
repetition of the input can be safely ignored by outputting any
result.
We now prove that the stutter robustness, immediate-
at-ﬁrst robustness and fast-enough robustness properties are
relaxations of the stretch robustness property. To achieve this,
it will be convenient to treat each property as the set of all
Lustre programs that satisfy it.
Theorem 6: (Stutter robustness, immediate-at-ﬁrst robust-
ness and fast-enough robustness are relaxations of stretch
robustness) STR ⊆ STU, IAF, FE.
Proof: We ﬁrst show that STR ⊆ STU. Let P be a stretch
robust program. We shall prove that it is also stutter robust.
For program to be stutter robust, it must respond to a latency
function λ on its input by applying some latency function λ′ to
its output. Since P is stretch robust, when a latency function λ
is applied to its input, it will respond by applying an identical
λ to its output. Hence P also satisﬁes stutter robustness.
To prove the other two inclusions, we ﬁrst note that when
P is stretch robust, its output under slow input, P(iλ) is
organised into successive blocks, with the tth block lying
between Startλ
t and Endλ
t . In addition, the symbols within
the tth block are all of the form P(i)(t), that is, equivalent to
the tth output of P under the unslowed input i. From this, it
follows directly that P(iλ) at the points of the form Startλ
t is
equal to P(i)(t) as required by immediate-at-ﬁrst robustness.
It also follows that P(iλ) at the points of the form Endλ
t is
equal to P(i)(t), thus satisfying fast-enough robustness. Hence
the directions STR ⊆ IAF and STR ⊆ FE are also proven.
□
We now proceed to consider algorithmic means for detect-
ing whether a Lustre program satisﬁes a robustness property.
IV.
DETECTING ROBUSTNESS: STATIC ANALYSIS
The ﬁrst approach to checking whether a Boolean Lustre
program satisﬁes a robustness property is based on a static
analysis of the structure of the Lustre program. The analysis
is based on two kinds of result: (i) Theorem 7, which identiﬁes
those primitive programs that satisfy certain robustness prop-
erties and; (ii) Theorems 8, 9, 10 and 11,which identify those
robustness properties that are preserved upon composition of
two robust programs. We now proceed to state these theorems.
Theorem 7: Primitive Lustre programs all come with a
level of guaranteed robustness: (i) instantaneous programs
are robust under all four forms; (ii) delay and followed-by
programs are robust under stutter and immediate-at-ﬁrst robust-
ness; and (iii) primitive initialisation programs are immediate-
at-ﬁrst robust.
Proof: (i) Instantaneous programs apply a pointwise operator
to their input streams to obtain their output streams. Thus,
the same input tuple always causes the same output tuple.
Repetition of inputs through latency will therefore cause
repetition of outputs, which makes the program stretch robust.
(ii) The output of delay and fby programs has an additional
initial value with respect to the input stream. Slowing the input
stream down by a latency function, causes the program to
attach this value to the slow stream. The output under slow
input can therefore be obtained from the original input through
a latency function, which does not repeat the attached element,
and which repeats all subsequent elements accordingly. These
programs are therefore stutter robust. The programs are also
immediate-at-ﬁrst robust as can be inferred from the ﬁgure
below, which shows how the values of the original output (ﬁrst
row) are associated to the corresponding blocks of the output
under latency (second row). It is clear that the value at the
beginning of each block is equal to the corresponding value
in the original output.
P (i)
Nil
x1(0)
x1(1)
P (iλ)
Nil, x1(0)...x1(0)
|
{z
}
λ(0)
x1(0), x1(1)...x1(1)
|
{z
}
λ(1)
x1(1), x1(2)...x1(2)
|
{z
}
λ(2)

44
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
(iii) Initialisation programs take the ﬁrst value of stream
x1, and attach to it the stream x2 from its second value
onwards. The ﬁgure below shows how the blocks of output
under slow input, relate to the original output, illustrating the
fact that the value at the beginning of each block is equal to
the corresponding value in the original output.
P (i)
x1(0)
x2(1)
x2(2)
P (iλ)
x1(0), x2(0)...x2(0)
|
{z
}
λ(0)
x2(1)...x2(1)
|
{z
}
λ(1)+1
x2(2)...x2(2)
|
{z
}
λ(2)+1
□
We shall now consider the effect of composing robust pro-
grams.
Theorem 8: The composition without feedback of stretch
robust programs is stretch robust.
Proof: We consider two stretch robust programs P1 and P2
that are composed without feedback, as shown in Figure 2. As
a remark we note that P2 obtains some input from P1 (the
vector j) and some input from an external source (the vector
i2), which can be collectively represented by the vector j ∪i2.
On the other hand, the output of the complete system, consists
of some output from P1 (the vector o1) and some output from
P2 (the vector o2), which is collectively represented by the
vector o1 ∪ o2.
P1
P2
i1
i2
j
o2
o1
λ
λ
λ
λ
λ
Figure 2.
Composition without feedback preserves STR
Since the composed program reacts to input i1 ∪ i2 with
output o1∪o2, we aim to show that given slow input (i1∪i2)λ,
the program will react with the output (o1 ∪ o2)λ.
To see why this is true, we observe that P1 is stretch robust,
and thus will react to the input i1λ with the output vector
(o1 ∪ j)λ. Since latency functions distribute over the union of
vectors, we can conclude that P1 outputs two sets of streams,
corresponding to the two output vectors o1λ and jλ. P2 will
thus receive as input the vectors jλ and i2λ, which we can
represent by a single input vector (jλ ∪ i2λ) or equivalently,
(j ∪ i2)λ. Being stretch robust itself, it must then output the
slow output vector o2λ. Combining the output vectors of the
system o1λ and o2λ we obtain the vector (o1λ ∪ o2λ), which
is equivalent to (o1 ∪ o2)λ as expected.
□
Theorem 9: Adding a feedback loop to a stretch robust
program gives a stretch robust program.
Proof: Let P be a stretch robust program, and consider adding
a feedback loop between one of its outputs y and one of its
inputs x. Our deﬁnition of adding a feedback loop also requires
y not to depend in any way on x, that is, (y, x) ̸∈ dep(P).
This situation is shown in Figure 3, where the triangle shows
that y can only be a function of a set of inputs I∗ ⊆ I that
excludes x.
x
y
I∗
P
Figure 3.
Adding a feedback loop to a program
To prove that this program remains stretch robust, we
proceed by constructing an equivalent program that ’unwinds’
the feedback loop, and which we can prove to be stretch robust
by the application of Theorem 8. The new program will contain
two copies of P, which we call P1 and P2. These are connected
as shown in Figure 4.
y
x
I∗
I∗
P1
P2
Figure 4.
Unwinding the feedback loop
We shall use P1 to compute the value of y from I∗,
discarding all outputs but y. Following this, P2 can be used
to recompute all of the outputs, by using the inputs I∗, and
by feeding the output y from P1 to the input x in P2 in order
to simulate the feedback equation x = y. Since the feedback
loop plays no further role in computing output of the original
program, we simply discard y from the output of P2 and keep
the rest of the outputs. Note that in Figure 4, the parallelogram
inside P2 is meant to indicate that the outputs of P2 that are
relevant to the ﬁnal computation can now depend on all of its
inputs).
We now notice that i) P1 and P2 are copies of P, ii)
P is stretch robust and iii) the construction reduces to a
composition without feedback of stretch robust programs. By
Theorem 8, the composition without feedback of stretch robust
programs is stretch robust. Hence, the equivalent program with
the feedback loop is also stretch robust, as required.
□
Theorem 10: The fully connected composition of two stut-
ter robust programs is stutter robust.
Proof: We consider two arbitrary stutter robust programs P1
and P2, and show that their fully connected composition is

45
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
also stutter robust. Since P1 and P2 are being composed in
a fully connected way, every output of P1 is connected to an
input of P2, and there are no feedback connections. This is
shown in Figure 5.
i
P1
j
P2
o
λ
λ′
λ′′
Figure 5.
Fully connected composition preserves STU
Now suppose that if we pass a vector i to P1, the program
responds by outputting vector j. Also suppose that when P2
receives vector j it outputs vector o in response. We need to
show that if a latency function λ is applied to the composite
program’s input vector i, the composite program applies some
latency function to its output vector o. Since P1 is stutter
robust, applying λ to the input vector i will make P1 apply
some latency function λ′ to its output j. Hence, P2 receives
the vector j slowed down by λ′ as input. Since P2 is also
stutter robust it will apply some other latency function λ′′ to
its output o. Thus, applying a latency function to the input
of the composed program, causes the composed program to
slow its output by some latency function, proving that stutter
robustness is preserved by fully connected composition.
□
Theorem 11: The disjoint composition of two immediate-
at-ﬁrst robust programs is immediate-at-ﬁrst-robust.
Proof: We consider two immediate-at-ﬁrst robust programs P1
and P2 in disjoint composition, as shown in Figure 6. We
note that P1 computes output vector P1(i1) given input vector
i1, while P2 computes output vector P2(i2) when given input
vector i2. Thus, if the composed program is given the input
vector (i1 ∪ i2), it will react with an output vector (P1(i1) ∪
P2(i2)).
P1
P2
i1
i2
P1(i1)
P2(i2)
λ
λ
λ
λ
Figure 6.
Disjoint composition preserves IAF
We now note that both P1 and P2 are immediate-at-ﬁrst
robust, and that under slow input, will generate two disjoint
output vectors with the following properties. The output vector
P1(i1λ) of P1 will have the property that for every stream s:
s(Startλ
t ) = P1(i1)(s)(t)
(1)
while the output vector P2(i2λ) of P2 will have the following
property for every one of its streams s.
s(Startλ
t ) = P2(i2)(s)(t)
(2)
On the other hand, to prove that the composite program is
immediate-at-ﬁrst-robust, we would need to show that each of
the streams s in its output vector (P1(i1λ) ∪ P2(i2λ)) obeys
the following property:
s(Startλ
t ) = (P1(i1) ∪ P2(i2))(s)(t)
However, we note that we are always able to determine
whether a stream s in (P1(i1λ) ∪ P2(i2λ)) originates from P1
or P2. Hence, it is sufﬁcient to ensure that such a stream s
always satisﬁes the property
s(Startλ
t ) = Pn(in)(s)(t)
(3)
where n is the index of the program generating s. By equation
(1), we know that property (3) holds when s is generated by
P1 (when n=1), while equation (2) ensures that property (3)
holds when s is generated by P2 (when n=2). The theorem is
thus proved.
□
We now consider a method that analyses the behaviour
of the particular program under examination, rather than its
structure.
V.
DETECTING ROBUSTNESS: DYNAMIC ANALYSIS
The theorems in Section IV allow us to conclude robustness
of composed programs in a syntactically compositional man-
ner. In this section, we give richer, although more expensive,
semantic analysis techniques for Boolean Lustre programs
allowing for dynamic robustness analysis of their behaviour.
Through the use of symbolic methods, such as with Binary
Decision Diagrams (BDDs), the analysis can be applied either
on whole programs or to subprograms. In the latter case, the
static analysis theorems can then be used to obtain results about
the composition of the subprograms.
The techniques we shall discuss rely on identifying condi-
tions on the Lustre automaton that are sufﬁcient to guarantee
that certain robustness properties are satisﬁed by that program.
Two types of conditions are deﬁned: (i) latency independent
conditions, which check whether a robustness property holds
in general, and (ii) latency dependent conditions, which check
whether a property holds when some particular latency func-
tion is applied to the program’s input.
The conditions identiﬁed can be checked using either an
exhaustive analysis of the automaton’s state space, or prefer-
ably using a symbolic representation of the automaton such as
BDDs to ensure that the approach scales up to larger systems.

46
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
A. Latency Independent Conditions
We start by identifying properties that guarantee slowdown
robustness for any latency function. The ﬁrst condition we shall
consider checks whether being in different states can cause the
program’s output to change. If this is not the case, the program
is stretch robust.
Theorem 12: (Condition 1 — Stretch Robustness). Pro-
grams satisfying the following condition are stretch robust:
∀a, s, s′ · δ(a, s) = δ(a, s′)
Proof: Under such a condition, a particular input tuple always
generates the same output tuple, independently of the state
the automaton ﬁnd itself in. Thus, any repetition of an input
tuple caused by a latency function causes a repetition of the
corresponding output tuple. This is sufﬁcient to ensure stretch
robustness.
□
We now consider a condition that stops a program from
being stretch robust. Condition 2 states that if we can ﬁnd a
state s, which under some tuple a moves to s′, such that s and
s′ yield different outputs under a, then the program must fail
to be stretch robust.
Theorem 13: (Condition 2 — Failure of Stretch Robust-
ness) Programs satisfying the following condition are not
stretch robust:
∃ a, b, b′, s, s′ ·
τ(a, s) = s′ ∧ δ(a, s) = b
δ(a, s′) = b′ ∧ b ̸= b′
Proof: We show that the existence of reachable states s and s′
described by the theorem is sufﬁcient to ﬁnd an input vector
and a latency function λ such that the program fails to be
stretch robust.
We ﬁrst build the input vector as follows. Starting from
the initial state of the automaton, we follow any path of some
length n leading to state s. This path gives us the ﬁrst n tuples
of the input vector i1. At state s, we then follow the transition
for tuple a. The rest of the input vector can then be selected
arbitrarily, yielding i1 a i2.
Given the input vector i1 a i2, the automaton will ﬁrst
process the tuples in i1 and output the ﬁrst n tuples of the
output vector o1. Since the automaton is now in state s, it will
output tuple b, followed by some sequence of tuples o2.
To prove the theorem, we select a latency function that
adds one repetition at time instant n + 1, and 0 repetitions
elsewhere. Applying this latency function to the input vector
thus gives i1 a a i2.
On this slow vector the automaton will ﬁrst output o1 b,
as before, but being now in state s′, will output some tuple
b′ ̸= b, followed by the rest of the output vector o3. It is clear
that o1 b b′ o3 is different from (o1 b o2)λ = (o1 b b o2). Thus
the program is not stretch robust, as required.
□
Condition 1 indicates that programs whose states do not
affect program output are stretch robust. The states in such
programs are effectively redundant, in the sense that automata
corresponding to these programs can be minimised (say, using
the partitioning minimisation procedure [9]) into equivalent
automata having just one state. Through condition 2, we also
know that programs having two successive states yielding
different output tuples under the same input tuple cannot be
stretch robust. This raises the question of whether there are any
non-trivial stateful programs that satisfy stretch robustness.
This question can in fact be given a positive answer by
identifying a condition that lies between these two extremes.
The intuition behind condition 3 is as follows. Given any
state s, which under input a yields output b, we will allow
it to transition to state s′ if i) s′ under a also yields b, thus
escaping condition 2, and ii) s′ self-loops under a. The effect
of the second requirement is that s′ becomes a ‘sink’ for
repetitions of a, and preserves the output b experienced under
s, guaranteeing stretch robustness. Note that as long as the
requirements for transitions between states are satisﬁed, there
can very well be states with different output behaviours. This
is something that is not covered by condition 1.
Theorem 14: (Condition 3 — Stretch Robustness) Pro-
grams satisfying the following condition are stretch robust:
∀a, b, s, s′ ·
(τ(a, s) = s′ ∧ δ(a, s) = b)
=⇒ (τ(a, s′) = s′ ∧ δ(a, s′) = b)
Proof: When processing its input vector i, the automaton will
use the current input i(t) and state s(t), to compute the output
o(t) and next state s(t + 1). When input i has latency λ, the
program receives consecutive blocks of constant inputs, with
the nth block consisting of tuples of the form i(n). To satisfy
stretch robustness, the program must apply λ to its output, thus
yielding blocks of constant outputs such that the nth block
consisting of tuples of the form o(n).
We observe that if the automaton ﬁnds itself in state s(n)
at the beginning of input block n, the condition guarantees that
(i) at the ﬁrst time instant in the block the automaton outputs
o(n) and moves to state s(n + 1); (ii) during the rest of the
time instants in the block it will again output o(n) and self
loop to state s(n+1) and (iii) it will ﬁnd itself in state s(n+1)
at the start of the (n + 1)th input block.
Noting that in the case of block 0, the automaton starts in
the initial state s(0), provides the base case for an inductive
argument which guarantees that the automaton ﬁnds itself in
state s(n) at the start of the nth block, causing the output to
be o(n) throughout that block as required.
□
Although condition 3 shows that there are non-trivial state-
ful stretch robust programs, it also sets a strong requirement for
this to be the case. We now investigate conditions for weaker
robustness properties, starting from stutter robustness.
Under stutter robustness, slowing a program’s input by a
latency function λ, causes the program to slow its output by
a latency function λ′. In practice, this means that the output
under slow input can be obtained through the repetition of the
original output tuples only. We show that if the automaton has
a certain feature, then this property cannot hold.

47
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Theorem 15: (Condition 4 — Failure Of Stutter Robust-
ness). Programs satisfying the following condition are not
stutter robust:
∃a, b, s, s′, j, k, l ·
δ(a, s) = j ∧ τ(a, s) = s′∧
δ(a, s′) = k ∧ k ̸= j∧
δ(b, s′) = l ∧ b ̸= a ∧ l ̸= k
Proof: Condition 4 looks for the presence of reachable states s
and s′ having the following properties: (i) under input tuple a,
state s outputs tuple j and passes to state s′; (ii) under input
tuple a, state s′ outputs k ̸= j and (iii) under input tuple b ̸= a,
state s′ outputs tuple l ̸= k.
We now show that if this structure is present in the
automaton, there will always be some input vector and some
latency function that breaks the stutter robustness property. We
ﬁrst construct the input vector as follows. Choose a path from
the start state sinit to the state s. By following this path of
n transitions, we obtain the ﬁrst n tuples of the input vector,
which we denote by i1. We also obtain the ﬁrst n tuples of
the output vector, denoted by o1. To this initial segment of the
input vector, one appends the input tuples a b, which causes the
resulting output vector to be augmented by the output tuples
j l. The rest of the input vector i2 can be chosen arbitrarily.
We now choose a latency function, which when applied
to the input vector i1 a b i2 above, breaks the property.
The chosen latency function will insert 1 repetition for the
input tuple at time instant n + 1, and 0 repetitions elsewhere.
Applying this latency function to the input vector chosen
earlier will yield i1 a a b i2. Through the presence of the
regularity identiﬁed in the theorem, the resulting output will
be the initial segment of the output vector o1 followed by
the output tuples j k, which means that with respect to the
original output an l tuple has been deleted. This fact alone
makes it impossible to derive the output under slow input from
the original output through the addition of repetitions only. □
Finally, we can also identify a sufﬁcient condition for
immediate-at-ﬁrst robustness, which we can obtain by relaxing
condition 3. We shall still insist that if a state s transitions to
s′ under some input, then it must loop in s′ under that input.
However, we will not require input in s and s′ to yield the
same output. As the proof shows this is enough to guarantee
that the program is immediate-at-ﬁrst robust.
Theorem 16: (Condition
5
—
Immediate-At-First
Ro-
bustness). Programs satisfying the following condition are
immediate-at-ﬁrst-robust:
∀a, s, s′ · (τ(a, s) = s′) =⇒ (τ(a, s′) = s′)
Proof: When processing an input vector i, the automaton uses
the current input i(t) and state s(t), to compute the output o(t)
and next state s(t+1). When input i has latency λ, the program
receives consecutive blocks of constant inputs, with the nth
block consisting of tuples of the form i(n). For the program
to be immediate-at-ﬁrst robust, the output at the beginning of
the nth block must have the form o(n).
We observe that if the automaton ﬁnds itself in state s(n)
at the beginning of block n, the condition guarantees that (i)
at the ﬁrst time instant in the block the automaton moves to
state s(n+1); (ii) it stays in state s(n+1) for the remainder of
the block and (iii) the (n + 1)th block starts in state s(n + 1).
Noting that in block 0, the automaton starts in the initial state
s(0), provides the base case for an inductive argument which
guarantees that the automaton ﬁnds itself in state s(n) at the
beginning of the nth block, causing the output to be o(n) as
required.
□
B. Latency Dependent Conditions
So far, we tried to identify programs that are robust under
an input slowed down by an unknown latency. If one knows
that the inputs of a program are going to slow down by some
uniform latency function λ(t) = c, where c is a constant, it
is possible to check whether the program is robust for that
particular scenario using the following weakened conditions.
Condition 6 requires that for any state s, the state reached
by the automaton after the occurrence of a speciﬁc input tuple,
τ(a, s), is the same state reached after the occurrence of c + 1
such input tuples, which we denote by τ c+1(a, s).
Theorem 17: (Condition
6
—
Immediate-At-First-
Robustness). Programs satisfying the following condition for
some positive natural number c ≥ 2, are immediate-at-ﬁrst
robust for latency functions of the form λ(t) = c:
∀a, s · τ(a, s) = τ c+1(a, s)
Proof: When processing an input vector i, the automaton uses
the current input i(t) and state s(t), to compute the output
o(t) and next state s(t + 1). When input i has latency λ, the
program receives consecutive blocks of constant inputs of size
c+1, with the nth block consisting of tuples of the form i(n).
For the program to be immediate-at-ﬁrst robust, the output at
the beginning of the nth block must have the form o(n).
Suppose that at the beginning of the nth block the au-
tomaton ﬁnds itself in state s(n). Then at the beginning of
the (n + 1)th block it is in state s(n + 1) on account of (i)
at the ﬁrst time instant in the nth block the automaton moves
to s(n + 1) and (ii) the condition guarantees that after c + 1
steps of the same input the automaton will return to s(n + 1).
Noting that in block 0, the automaton starts in the initial state
s(0), provides the base case for an inductive argument which
guarantees that the automaton ﬁnds itself in state s(n) at the
beginning of the nth block, causing the output to be o(n) as
required.
□
The ﬁnal condition that will be considered requires that if
an automaton is in state s, it will return to the same state s
after c repetitions of the input.
Theorem 18: (Condition 7 — Immediate-At-First and Fast-
Enough Robustness). Programs satisfying the following condi-
tion for some positive natural number c ≥ 2, is immediate-at-
ﬁrst robust and fast-enough robust for latency functions of the
form λ(t) = c:
∀a, s · τ c(a, s) = s
Proof: When processing an input vector i, the automaton uses
the current input i(t) and state s(t), to compute the output o(t)
and next state s(t+1). When input i has latency λ, the program
receives consecutive blocks of constant inputs of size c + 1,

48
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
with the nth block consisting of tuples of the form i(n). For
the program to be immediate-at-ﬁrst robust, the output at the
beginning of the nth block must have the form o(n). Similarly,
for a program to be fast-enough robust, the output at the end
of the nth block must have the form o(n).
Suppose that at the beginning of the nth block the automa-
ton ﬁnds itself in state s(n). Then at the end of the nth block
it is in state s(n) on account of the fact that the automaton
returns to its original state after c transitions of the same input.
This state also combines with input i(n) to ensure passage to
state s(n+1) at beginning of the (n+1)th block. Noting that in
block 0, the automaton starts in the initial state s(0), provides
the base case for an inductive argument which guarantees that
the automaton always ﬁnds itself in state s(n) at the end of
the nth block, causing the output to be o(n) as required for
fast-enough robustness, and in state s(n + 1) at the beginning
of the (n+1)th block guaranteeing that the output is o(n+1)
as required by immediate-at-ﬁrst robustness.
□
We now apply the static and dynamic analysis techniques
discussed earlier via a case study.
VI.
CASE STUDY
The static and dynamic analysis theorems were applied to
six Boolean Lustre programs to examine whether these are
strong enough to deduce slowdown robustness. For comparison
purposes, a manual analysis of these programs was also
performed in order to discover which robustness properties
each program satisﬁes or fails to satisfy. The programs under
consideration, with the actual properties satisﬁed by each are
listed below:
•
RCA, a (stateless) ripple carry adder that satisﬁes
stretch robustness.
•
RISE, a program that receives a Boolean stream and
detects the presence of rising edges, and which satis-
ﬁes immediate-at-ﬁrst robustness.
•
SWSR, a switch with a set and reset input, which
satisﬁes stretch robustness.
•
TOGGLE, a switch with a toggle input, which does not
satisfy any property for every latency function.
•
SISO, a serial in serial out register, which satisﬁes
stutter robustness.
•
PIPO, a parallel in parallel out register, which satisﬁes
stutter robustness and immediate-at-ﬁrst robustness.
We shall now discuss the application of the static and
dynamic analysis theorems to the programs in question. To
illustrate how the static analysis theorems can be employed to
reason about a program, we will consider their use to prove
that the SISO register program is stutter robust.
Example 1: Since the SISO program has 4 equations, we
ﬁrst break it down into four separate primitive programs SISO1,
SISO2, SISO3 and SISO4 as shown in Figure 7, where SISOj =
⟨{ij, ij+1}, {ij}, {ij+1}, {ij+1 = true fby ij}⟩
It is clear that each such program is an fby primitive
program, and that these primitive programs can be composed
through fully connected composition to obtain the program
i1
SISO1
i2
SISO2
i3
SISO3
i4
SISO4
i5
Figure 7.
SISO program broken into primitive programs
SISO. This can be done by starting from SISO1 and sequen-
tially composing the programs SISO2, SISO3 and SISO4. Since
SISO can be built from stutter robust primitives and through
stutter robustness preserving compositions, we can conclude
that it is stutter robust.
Table I illustrates the results that can be obtained in a
similar manner through the static analysis of the programs
in question. An entry in the table indicates whether the
corresponding program can be shown to satisfy a particular
robustness property or not through this technique. Within an
entry, a ✓ symbol indicates that the program was found to
satisfy the property. In addition, a ? symbol indicates that the
static analysis yielded an inconclusive result, while a − symbol
indicates that a test was unnecessary since the program was
found to satisfy the stronger property of stretch robustness.
TABLE I.
RESULTS OBTAINED THROUGH STATIC ANALYSIS
Property/Program
RCA
RISE
SWSR
TOGGLE
SISO
PIPO
STR
✓
?
?
?
?
?
STU
-
?
?
?
✓
?
IAF
-
?
?
?
?
✓
As one can see, the static analysis reveals that the ripple
carry adder is stretch robust, that the SISO register is stutter
robust and that the PIPO register is immediate-at-ﬁrst robust.
Static analysis thus yields results when the programs have a
simple structure in terms of the interconnections between the
component primitive programs.
We now illustrate how dynamic analysis can be applied
by means of another example. We shall show that the Toggle
Switch program TOGGLE is both immediate-at-ﬁrst robust as
well as fast-enough robust for the latency function λ(t) = 2.
Example 2: Starting from the TOGGLE program, we ﬁrst
obtain the automaton representation of the program by using
the construction outlined in Deﬁnition 1. This yields the
automaton depicted earlier in Figure 1. By observing the
structure of the automaton, we note that from any state, taking
2 transitions with the same input tuple returns the automaton
to the same state. The program thus satisﬁes the properties in
question through the use of Theorem 18.
Table II summarises the results obtained through the
dynamic analysis of the programs under consideration. In
addition to the earlier conventions, an × symbol indicates that
the program was found not to satisfy the property in question,
while a ✓ symbol with subscript c = 2, indicates that the
program has been proven to satisfy the property for the latency
function λ(t) = 2 through the use of a latency dependent
condition. In practice, BDD techniques were used to evaluate
the conditions, and the evaluation was instantaneous for the
programs in question.

49
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
TABLE II.
RESULTS OBTAINED THROUGH DYNAMIC ANALYSIS
Property/Program
RCA
RISE
SWSR
TOGGLE
SISO
PIPO
STR
✓
×
✓
×
×
×
STU
-
×
-
×
?
?
IAF
-
✓
-
✓c=2
?
✓
FE
-
?
-
✓c=2
?
?
Dynamic analysis enlarges the scope of automatically de-
rived robustness results to programs that have more complex
structures. In particular, this approach gives the following
results.
•
Stretch Robustness: The ripple carry adder is shown
to be stretch robust, a fact also discovered through
the static analysis. On the other hand, the switch with
set and reset is shown to be stretch robust through
condition 3, while all other programs fail to be stretch
robust by condition 2. The latter two results are an
improvement over the analysis conducted in [1].
•
Stutter Robustness: The rising edge and toggle switch
programs are shown not to be stutter robust, something
which is not possible to discover through the static
analysis, since no conditions for the failure of a
property are considered.
•
Immediate-At-First Robustness: The PIPO register and
the rising edge program are shown to be immediate-
at-ﬁrst robust. While the former fact was discovered
by the static analysis, the latter one was not.
•
Latency Dependent Conditions: The toggle switch
program is shown to satisfy immediate-at-ﬁrst and
fast-enough robustness for the speciﬁc latency func-
tion λ(t) = 2.
While not all of the properties satisﬁed by the programs
have been discovered through the automated analysis, the
combination of static and dynamic analysis has revealed many
details about the robustness of the programs in question. The
conditions for stretch robustness have in particular been ef-
fective at classifying the programs considered. The number of
programs proven to be immediate-at-ﬁrst robust also indicates
that the condition which detects it might be applicable for
some interesting set of programs. On the other hand, the
results obtained using the latency dependent conditions are
encouraging as they indicate the possibility of satisfying a
property under a particular slowdown scenario even though
the program might not satisfy it in general. One can also note
that the two approaches can be complementary; in particular
while dynamic analysis allows discovery of programs that are
not stutter robust, static analysis allows reasoning about those
that satisfy this property.
VII.
RELATED WORK
The discrete theory of slowdown considers the effect of
slowing down all the input streams of a stream processing
program by the same amount through the addition of stutter.
There are various other models of slowdown that can be found
in the literature. The theory of latency insensitive design [6]
allows streams to slow down through the addition of explicit
stall moves into those streams. In reaction to performing a stall
move on an input stream, a program reacts by performing a
procrastination effect, that is by inserting additional stall moves
in its other streams to ensure that causality between the events
of a program is preserved. A program is said to be patient if it
knows how to perform a procrastination effect in response to
any possible stall move. In other words, the program is always
able to delay its operation in response to slow input without
breaking. Patience is thus a form of robustness to delays in
the process’ streams, but which, unlike our properties, does
not dictate the exact form that this robustness should take.
In the theory of polychronous processes [5], used to give
a semantics to the synchronous language Signal [4], streams
do not have to take a value at every time instant. Given
a particular program behaviour, consisting of the input and
output streams of a program, the operations of stretching and
relaxation can be used to obtain a slower program behaviour.
Stretching remaps the time instants at which the values occur
on each stream, preserving the order of values in each stream,
and the simultaneity of values between different streams. The
stretching operation stretches all the streams by exactly the
same amount and is similar to how a stretch robust program
would behave when its inputs are slowed down. On the other
hand, when relaxation slows a behaviour, it only guarantees
that the order of values within each stream is preserved. The
notion of relaxation that arises when all input streams are
slowed down by one amount, and all output streams by another
amount, is similar to how to a stutter robust program would
behave under input slowdown. Signal guarantees that all its
programs are stretch closed (a property analogous to stretch
robustness), but this is only possible because no additional
values are ever inserted as a result of slowing down a stream.
Reasoning about slowdown and speedup for continuous
time behaviour has been investigated in [3]. The behaviour of
a program can be slowed down by stretching these real-time
signals through time by using the concept of time transforms.
The concept of a latency function can be seen as a discrete
time version of a time transform. When one slows a behaviour
through a time transform, all streams are slowed down exactly
by the same amount. This manner of slowing down a behaviour
corresponds to how one would expect a stretch robust system
to react in our discrete theory.
Stutter invariance for Linear Temporal Logic (LTL) proper-
ties has been investigated in [7], in which a stuttered path slows
down all inputs and outputs of a program by the same amount.
Stutter invariant properties are ones which, if they are satisﬁed
by a program, then they are also satisﬁed by all stutterings of
its behaviour. If a Lustre program is stretch robust, then its
inputs can be safely slowed down without the risk of breaking
the constraint imposed by a stutter invariant property on the
program.
The theory of stability [10] considers programs whose
outputs ﬂuctuate when their inputs are kept constant. Programs
that do not exhibit such a phenomenon are said to be stable;
when the inputs of these programs are unchanged, the outputs
will converge to stable values after a ﬁnite period of time.
The concept of stability relates to the concept of fast-enough
robustness. An input that has stopped changing is similar to
an input which is stuttering when considered over some ﬁnite
horizon of time. While the theory of stability requires the
output of a system to eventually converge to some particular

50
International Journal on Advances in Intelligent Systems, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/intelligent_systems/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
value, fast-enough robustness requires an output to converge
to an expected value before the sequence of repetitions ends.
Instead of checking whether a system exhibits certain
classes of behaviour when an environment changes, it is
possible to check whether a system degrades gracefully when
the environment misbehaves. In [11], the authors consider a
robustness approach in response to environments that fail to
obey the assumptions made during system design. A system
is said to be robust, if a small number of violations of
the environment assumptions causes only a small number of
violations of the system speciﬁcation.
It is also possible to use a probabilistic approach to
understand how changes in the environment are propagated
through the system’s components, and how the behaviour of
these components under changed or missing input contributes
to cause unacceptable system wide behaviour [12]. From our
perspective, the general approach is interesting because it can
help to isolate those components that misbehave under slow
input, causing a complex system to fail.
VIII.
CONCLUSIONS
Since input stutter can arise in various situations, especially
in systems that ﬁnely sample input, it is crucial that such
systems do not change their behaviour as such transformations
on their input occur. In this paper, we have identiﬁed a number
of different levels of robustness with respect to slowdown
which one may require, and presented sound checks using
static analysis of the code or using symbolic veriﬁcation
techniques over the system’s behaviour.
One important observation regards the strong (and highly
compositional) property of stretch robustness. This property is
found in various guises in slowdown models that are simpler
than our own. These models are often found to either assume
that programs will be stateless, or else will deﬁne slow input
in a way that does not bear on program state. In our model,
stutter is able to interact with the internal state of the programs
under consideration resulting in outputs with more complex
relationships to those generated under the unslowed input.
Nonetheless it was found that even under these conditions,
there are non-trivial stateful programs that remain stretch
robust to input slowdown.
Nonetheless, the restrictions that are imposed by stretch
robustness in the complex slowdown scenario considered are
quite strong, and consequently it is useful to possess weaker
properties for those situations in which stretch robustness does
not apply. Weaker robustness properties are however not as
compositional as stretch robustness, making a static analysis
approach less powerful than it would be with the stronger
property. On the other hand, we have seen that dynamic
analysis allows for the analysis of programs on a global
level, allowing greater effectiveness in checking all kinds of
robustness property - albeit at an increased computational cost.
The two approaches can, however, be combined, allowing for
the analysis of more complex programs.
One major restriction of our results is that we assume that
all the inputs of the system are slowed down by the same
amount. In practice, this may be too strong a restriction, for
instance with some nodes using a combination of external
inputs and streams coming from other nodes and which may
have been slowed down further.
Another restriction is that we limit our analysis techniques
to Boolean Lustre programs or circuits. The static analysis
results, depending only on abstract properties of primitive
programs and the way they are interconnected, can be applied
to programs over non-ﬁnite types. On the other hand, all
dynamic analysis results can only be applied on Boolean
Lustre programs. In the future, we plan to relax this constraint
by using control graph analysis techniques to programs with
numeric values, using approaches similar to [13].
REFERENCES
[1]
I. Bondin and G. Pace, “Static and dynamic analysis for robustness under
slowdown,” Proc. 4th International Conference on Computational Logics,
Algebras, Programming, Tools, and Benchmarking (COMPUTATION
TOOLS ’13), IARIA, May 2013, pp. 14–22.
[2]
P. Caspi, D. Pilaud, N. Halbwachs, and J. Plaice, “Lustre: a declarative
language for programming synchronous systems,” Proc. 14th ACM
SIGACT-SIGPLAN symposium on Principles of programming languages
(POPL ’87), ACM, Jan. 1987, pp. 178–188.
[3]
C. Colombo, G. Pace, and G. Schneider, “Safe runtime veriﬁcation
of real-time properties,” Proc. 7th International Conference on Formal
Modelling and Analysis of Timed Systems (FORMATS ’09), Springer
Verlag, Sep. 2009, pp. 103–111.
[4]
A. Gamati´e, Designing embedded systems with the SIGNAL program-
ming language - synchronous reactive speciﬁcation. Springer, 2010.
[5]
P. Le Guernic, J.-P. Talpin, and J.-C. Le Lann, “Polychrony for system
design,” Journal of Circuits, Systems and Computers, vol. 12(3), Jun.
2003, pp. 261–304.
[6]
L. Carloni, K. Mcmillan, and A. Sangiovanni-Vincentelli, “Theory of la-
tency insensitive design,” IEEE Transactions on Computer-Aided Design
of Integrated Circuits and Systems, vol. 20(9), Sep. 2001, pp. 1059–1076.
[7]
D. Peled and T. Wilke, “Stutter-invariant temporal properties are express-
ible without the next-time operator,” Information Processing Letters, vol.
63(5), Sep. 1997 pp. 243–246.
[8]
N. Halbwachs, P. Raymond, and C. Ratel, “Generating efﬁcient code
from data-ﬂow programs,” Proc. 3rd International Symposium on Pro-
gramming Language Implementation and Logic Programming (PLILP
’91), LNCS 528, Springer Verlag, Aug. 1991, pp. 207–218.
[9]
S. Brown and Z. Vranesic, Fundamentals of Digital Logic with VHDL
Design, second edition. McGraw-Hill Higher Education, 2005, pp. 522–
531.
[10]
N. Halbwachs, J.-F. H´ery, J.-C. Laleuf, and X. Nicollin, “Stability of
discrete sampled systems,” Proc. 6th International Symposium on Formal
Techniques in Real-Time and Fault-Tollerant Systems (FTRTFT ’00),
Springer Verlag, London, Sep. 2000, pp. 1–11.
[11]
R. Bloem, K. Greimel, T. Henzinger, and B. Jobstmann, “Synthesizing
robust systems,” Proc. Formal Methods in Computer-Aided Design
(FMCAD ’09), IEEE Computer Society, Nov. 2009, pp. 85–92.
[12]
X. Ge, R. Paige, and J. McDermid, “Probabilistic failure propagation
and transformation analysis,” Proc. 28th International Conference on
Computer Safety, Reliability and Security (SAFECOMP ’09), LNCS
5775, Springer Verlag, Sep. 2009, pp. 215–228.
[13]
B. Jeannet, N. Halbwachs, and P. Raymond, “Dynamic partitioning
in analyses of numerical properties,” Proc. Static Analysis Symposium
(SAS’99), LNCS 1694, Springer Verlag, Sep. 1999, pp. 39–50.

