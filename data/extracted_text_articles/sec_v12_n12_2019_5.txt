53
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Secure Cooperation of Untrusted Components Using a Strongly Typed Virtual Machine
Roland Wism¨uller and Damian Ludwig
University of Siegen, Germany
E-Mail: {roland.wismueller, damian.ludwig}@uni-siegen.de
Abstract—A growing number of computing systems, e.g., smart
phones or web applications, allow to compose their software
of components from untrusted sources. For security reasons,
such a system should grant a component just the permissions
it really requires, which implies that permissions must be sufﬁ-
ciently ﬁne-grained. This leads to two questions: How to know
and to specify the required permissions, and how to enforce
access control in a ﬂexible and efﬁcient way? We present the
design and implementation of a novel approach based on the
object-capability paradigm with access control at the level of
individual methods, which exploits two fundamental ideas: we
simply use a component’s published interface as a speciﬁcation
of its required permissions, and extend interfaces with optional
methods, allowing to specify permissions that are not strictly
necessary, but desired for a better service level. These ideas have
been realized within a static type system, where interfaces specify
both the availability of methods, as well as the permission to use
them. In addition, we support deep attenuation of rights with
automatic creation of membranes, where necessary. Thus, our
access control mechanisms are easy to use and also efﬁcient, since
in most cases permissions can be checked when the component
is deployed, rather than at run-time. Based on our type system,
we have deﬁned a secure intermediate representation, speciﬁed
its semantics and sketched a correctness proof. The presented
concepts have been implemented in a virtual machine called
COSMA. When a component is loaded, COSMA type checks
its intermediate representation and then compiles it into native
machine code, thus enabling its execution with minimal run-time
overhead. Thus, COSMA enables the secure, efﬁcient, and ﬂexible
cooperation of untrusted software components.
Keywords–Security; software component; type system; object-
capability model; membrane; virtual machine.
I.
INTRODUCTION
In today’s computer based systems, the software envi-
ronment is often composed of components developed by an
open community. Prominent examples are web applications,
and smart phones with their app stores. A major problem
in such systems is the fact that the components’ origin and
therefore the components themselves may not be trusted [1]
[2]. In order to ensure security in systems composed of un-
trusted components, the Principle Of Least Authority (POLA)
should be obeyed, i.e., each component should receive just
the permissions it needs to fulﬁll its intended purpose [3]. The
term ’authority’ denotes the effects, which a subject can cause.
These effects can be restricted via permissions, which control
the subject’s ability to perform actions. An appealing and
popular approach to implement POLA is the use of the object-
capability model [4] [5], where unforgeable object references
are used as a capability allowing to use the referenced object.
Based on the object-capability paradigm, several secure
languages have been devised, such as the E language [4], Joe-
E [6] or Emily [7]. In order to allow a ﬁne grained access
control at the level of individual methods, the programmer
has to manually implement security-enforcing abstractions,
e.g., membranes [5]. An inherent problem of language based
approaches is that security is achieved mainly by restrictions
of the source language and associated compile-time checks.
Thus, they not only conﬁne interactions between different com-
ponents, but also limit the programmer’s capabilities within
a single component. A second drawback is that security can
only be guaranteed, if all components are available in the form
of source code, which in practice is infeasible for reasons of
protecting intellectual property rights.
The second problem can be addressed by enforcing security
at the level of a Virtual Machine (VM). However, existing
VMs like Oviedo3 [8] only provide basic mechanisms for the
management of access rights, i.e., adding and removing the
permission to execute a method for a given object reference,
and must check all these permissions at run-time. Thus, they
are neither easy to use nor efﬁcient.
To overcome the drawbacks of existing approaches, the
goal of our work is to provide a VM that eliminates the
shortcomings of existing capability systems and secure high-
level languages, and addresses the special needs for the secure
cooperation of untrusted components. In particular, it
•
allows components to be distributed and deployed in
binary form while still providing security,
•
enables ﬁne-grained access control without putting a
relevant annotation or implementation burden on the
components’ programmers,
•
does not restrict the code’s expressiveness within a
single component, and
•
minimizes the number of required run-time checks
by performing most checks when a component is
deployed.
Our paper is organized as follows: We start with a dis-
cussion of related work in Section II, before in Section III,
we present our security model and a component model, where
each component speciﬁes its minimal and desired permissions
in a natural way using interfaces. We then outline the details of
a type system that allows ﬁne-grained access restrictions and
optional methods (Section IV). In addition, we introduce the
concepts and the implementation of a virtual machine based
on a secure, strongly-typed byte code, which allows static type
checking at deployment time and the automatic creation of
membranes (Section V). We conclude the paper by giving
an outlook to our future work (Section VI). The appendix
contains the deﬁnition of the formal semantics of the virtual
machine’s instruction set and sketches a proof of its primary
security property. This paper is an extended version of [1],
which includes an elaborate discussion of our type system, the

54
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
automatic creation of membranes and the implementation of
our virtual machine.
II.
RELATED WORK
Component-based software development has a long tradi-
tion in software engineering. Large software systems are built
by composing smaller parts, which interact only via well-
deﬁned interfaces. Recent research on composition aspects
focuses on how to specify the semantics of these interfaces,
such that properties of the system can be derived from the
properties of the individual components [9] [10] [11]. While
typically components are assumed to be trustworthy, secure
cooperation of untrusted components is gaining more and more
attention, e.g., in the area of telecommunication systems [12]
or web application [2]. In many cases, the security is based on
the object-capability model.
Capability based protection mechanisms date back as early
as the 1960-ies with, e.g., the IBM System/38 and the Hydra
operating system as prominent examples [13]. A good intro-
duction to the object-capability model and the principle of least
authority is provided in [14]. The general properties of capa-
bility systems, as well as some common misconceptions about
capabilities are clearly pointed out in [15]. The authors show
that capabilities have strong advantages over access control
lists and can support both conﬁnement and revocation of access
rights. More details about the object-capability paradigm as
well as revocation and conﬁnement are discussed in [3]. A
detailed discussion of several common object-capability pat-
terns, including membranes, together with a formal modeling
and proofs has been presented by Murray [5].
The object-capability paradigm has been used as a basis
for secure languages. A pioneer in this area is the work of
Mark Samuel Miller [4] on the E language, which points out
the prerequisites for secure languages: memory safety, object
encapsulation, no ambient authority, no static mutable state,
and an API without security leaks. In addition to these features,
E provides capabilities for access control at the object level.
Access control at the granularity of methods is also possible,
but requires the programmer to explicitly implement security-
enforcing abstractions like membranes. Based on E, Joe-E [6]
restricts Java such that access to objects is only possible via
capabilities that have been explicitly passed to a component.
It also supports immutable interfaces allowing to implement
secure plug-ins. Joe-E uses compile-time checking and secure
libraries to disable insecure features of Java like, e.g., reﬂection
and ambient authority. In a similar spirit, Emily [7] is a
secure subset of OCaml. Emily does not have the notion of
components, but dynamically grants permissions to launched
applications via explicit use of the powerbox pattern. Maffeis
et al. [2] speciﬁcally address the problem of mutual isolation
of (third-party) web applications written in JavaScript. They
deﬁne a language to be authority safe, if it satisﬁes the proper-
ties “only connectivity begets connectivity” and “no authority
ampliﬁcation”, and formally show that authority safety implies
isolation.
An implementation of capability-based access control at
method granularity within a virtual machine is presented in
[8] [16] [17]. Oviedo3 consists of an object oriented abstract
machine and an accompanying operating system. It provides
basic mechanisms for the management of access rights, i.e.,
adding and removing the permission to execute a method for
a given object reference, and checks all these permissions at
run-time.
A different area of research examines the use of type
systems for enforcing security constraints. One goal that has
been achieved is alias control, i.e., a means to restrict the
sharing of references. Several different concepts have been
developed, e.g., universes [18], ownership types [19] [20] [21]
or conﬁned types [22]. In [23], Philip Fong shows that these
concepts can be used at the byte code level, enabling to
enforce conﬁned types at link time, while in [24] [25] the same
author discusses how to formally model capabilities, such that
conﬁnement can be guaranteed. The common idea of these
approaches is to augment class types, such that references to
instances of these classes created in some context x cannot be
passed to another context y.
There are also several proposals to assign more powerful
and ﬂexible security restrictions to types. As an example, both
[26] and [27] allow the type system to enforce restrictions on
information ﬂow, similar to the Bell-LaPadula model. A pow-
erful, but also complex capability type system is introduced
in [28], which allows the programmer to deﬁne sequences of
aliasing events that may occur to a reference type.
In [29], the authors present the idea of adding hidden
capabilities to the interface description of components in
order to separate protection deﬁnition from application code.
Capabilities are implemented in the classical way using OS
protection mechanisms. An approach to deﬁne the semantics
of common type annotations used to specify access rights for,
e.g., reading and writing objects is outlined in [30]. While the
code can be checked statically in this approach, it does not
support ﬁne-grained access permissions for methods. Strategies
for ﬁne-grained access control with link-time enforcement have
been developed in ISOMOD [31]. Based on the idea that if a
loaded module does not know the name of an entry point,
it cannot call the corresponding service, ISOMOD deﬁnes a
powerful, but also rather complex policy deﬁnition language.
A problem, which is inherited from the underlying Java VM
is that there are no explicit interfaces between the modules,
making it extremely hard to determine the minimal rights
required by a module. In addition, only nominal typing is
supported and rights cannot be attenuated at run-time. The
Safe Language Kernel [32] employs a similar basic idea by
introducing type capabilities, which are checked at link time.
However, since the paper was never ofﬁcially published the
concept is not fully worked out and has not been integrated
into a type system.
The above discussion shows that although there are some
partial solutions for supporting the secure cooperation of
untrusted components, there is no satisfying practical approach
for this problem yet. The language-based approaches achieve
security by imposing restrictions on the programming lan-
guage, which also affects its expressiveness for programming
within a single component. In addition, they require compo-
nents to be distributed as source code, which is not desirable.
Approaches based on the object-capability paradigm or on type
systems for alias control in general just support access control
at the object-level, but not at the method-level. Fine-grained
access control either requires manually programmed security

55
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
abstractions or a run-time management and enforcement of
method permissions implying a signiﬁcant overhead. The more
sophisticated type based approaches, like [28] result in a sig-
niﬁcant annotation burden for the programmer, which hinders
their widespread usage.
The contribution of our work is to provide an approach
that avoids the mentioned shortcomings by combining existing
techniques with completely new ideas. Our solution is based
on a VM executing a strongly typed intermediate language
where types are used to represent permissions. A central
idea is to specify ﬁne-grained access control by just using
standard interface deﬁnitions, thus avoiding complex code
annotations. Since the VM performs a static type check, which
in our approach also corresponds to a permission check, when
a new component is loaded, most run-time checks can be
avoided. If necessary, the VM automatically builds the required
membranes for method-level access restrictions. The VM’s
underlying type system has been designed in such a way
that it does not limit expressiveness within a component,
but just restricts the permissions of object references passed
from one component to another. While we did not implement
annotations for alias control yet, this may easily be added in
future.
III.
COMPONENT AND SECURITY MODEL
A. Component Model
Our work is based on the established deﬁnition of a
software component, as given by Szyperski: “A software
component is a unit of composition with contractually speciﬁed
interfaces and explicit context dependencies only. A software
component can be deployed independently and is subject to
composition by third parties” [33]. We assume that components
are distributed as compiled byte code for a VM, rather than
source code. Their internal structure is not relevant, however,
we require that a component deﬁnes a purely object oriented
interface, i.e., to its environment it appears to be composed
of classes. One of these classes, the principal class, is the
component’s entry point, i.e., when the component is loaded,
an instance of the principal class is created and its constructor
is invoked.
B. Security Model
In order to support qualiﬁed statements about security prop-
erties, we structure the computing system under consideration
into a disjoint set of security domains that we call contexts.
We assume that the system features a trusted computing base,
which just consists of the VM and a minimal operating system
(OS) kernel, and is referred to as OS context. Any other service
available in the system is implemented by loading components
from an external, untrusted source. When the OS loads a
component, it creates a new context c and instantiates the
component’s principal class within this context. In turn, when
a method of any object in context c instantiates a new object,
the new object will also be enclosed in c. Thus, c comprises
all objects created on behalf of the loaded component.
Our threat model now is as follows: Code executing within
a context c may try to compromise the conﬁdentiality, integrity,
authenticity and availability of any data contained in or service
LISTING 1. CALENDAR INTERFACE
principal class Calendar {
interface Appointment {
int startTime();
int endTime();
String subject();
String notes();
// confidential notes
}
void createAppointment(...) { ... }
// return next upcoming appointment
Appointment getNextAppointment() { ... }
...
}
provided by a context c′ by accessing or invoking data or code
in other contexts, including the OS context.
As a prerequisite, we assume that all interactions between
different contexts are based on the object-capability paradigm,
i.e., access to data or code is possible only via references
that can be passed between contexts and act as capabilities.
In addition, data can be accessed only by calling an object’s
methods. This implies that there is no ambient authority, thus,
the OS kernel must also exhibit a purely object oriented
interface.
The goal of our work now is to parry the depicted threat
by enforcing the following property: Code of a component
that has been loaded into a context c can only perform actions
(i.e., execute methods on objects) in contexts different from c,
which (1) have been explicitly documented by that component,
and (2) have been explicitly permitted to context c.
Compared to the traditional object-capability model, there
are two signiﬁcant extensions. First, the granularity of access
control is more ﬁne grained, since our model controls the
ability to execute certain actions on an object, rather than just
the overall access to the object. Second, components include
an explicit deﬁnition of their required permissions.
C. An Example
Consider a component Calendar that manages and pro-
vides appointments. In a Java-like language (where access
modiﬁers have been omitted for brevity), this component may
be deﬁned as shown in Listing 1.
Now assume that there is a component C whose task
is just to display the next upcoming appointment in some
widget. In this situation, POLA requires that C can just get
the next appointment, but not, e.g., create a new one. However,
the standard object-capability model will allow C to invoke
createAppointment() once it receives a reference to
a Calendar object. This is true, even when the reference
is passed using a restricted type (i.e., an interface type just
containing getNextAppointment()), since virtually all
popular object oriented languages will allow C to downcast
the reference to the type Calendar again.
D. Fine Grained Access Control
In principle, an object-capability system can be extended
with a more ﬁne grained access control by supplementing

56
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Let Tpc
denote the type of the principal class of C,
Targ(T) the set of the argument types of all methods deﬁned in a type T,
Tres(T) the set of the result types of all methods deﬁned in type T,
Tin
the set of all types of references (or values) that component C receives from its environment
(required interface), and
Tout
the set of all types of references (or values) passed from component C to its environment
(provided interface).
Then (Tin, Tout) is the least ﬁxed point of the following equations:
Tin
=
Targ(Tpc) ∪ Targ(Tout) ∪ Tres(Tin)
Tout
=
{Tpc} ∪ Tres(Tout) ∪ Targ(Tin)
Figure 1. Computation of the provided and required interfaces of a component C.
each reference with a list of permissions, which allow or
disallow the available methods. However, this approach, which
is, e.g., implemented in Oviedo3 [8] [17] imposes a sig-
niﬁcant overhead both for storing the access rights in each
reference and for checking them at run-time whenever the
reference is used. In addition, it does not directly allow to
restrict the permissions for references returned by calls to a
permitted method. In our example, permissions included in the
Calendar reference passed to C can prevent C from calling
createAppointment(), but not from calling notes()
on the appointment returned by getNextAppointment().
A better solution is to use the membrane pattern [4] [5]:
Instead of providing C with a reference to the real calendar, we
create a membrane object, which acts similar to a proxy in the
sense that it delegates method calls to the calendar object. The
important difference is that the membrane will only provide a
getNextAppointment() method. In addition, it can also
wrap the returned appointment into another membrane that
does not provide the notes() method. Thus, membranes can
also support deep attenuation of rights.
However, the classical membrane pattern has two severe
drawbacks: First, the manual creation of membranes to enforce
a minimal set of permissions is a difﬁcult and error prone
task for large object systems, since the necessary membrane
structure may be deeply nested or may even be recursive.
Second, if permissions are attenuated in several steps (e.g.,
component A passes an attenuated version of the calendar to
B, which passes a more attenuated version to C), membranes
will be cascaded, thus sacriﬁcing run-time performance due
to multiple delegation. As we will show, both drawbacks
can be avoided by automatically generating membranes, when
necessary.
E. Specifying Required Permissions
Another general problem related to POLA is that the user of
a component C must know the minimal permissions required
by C in order to work properly. One of the central ideas of
our work is to use the already available type deﬁnition of an
object reference as a speciﬁcation of the permissions that are
requested (in the case of an input variable) or granted (in the
case of an output variable) by this reference. This perception of
type deﬁnitions is possible when the run-time system executing
the code of a component does not allow any of its input
references to be downcasted to a less restrictive type.
Now, given our purely object oriented component model,
we can exactly determine the minimal permissions that a
component C requires from its environment by determining the
types of all references that C can receive. Vice versa, we also
can identify the permissions that C grants to its environment
from the types of all references that C returns. In order to
increase the model’s ﬂexibility, we also allow optional methods
(i.e., permissions) in interfaces. In this way, the type of a
component C’s principal class explicitly deﬁnes
•
Tin : the minimum and maximum permissions that
C requests from its environment, where C will use
optional methods, if they are available, but does not
require them for its correct operation, and
•
Tout : the minimum and maximum permissions that
C grants to its environment, where for each optional
method, C may decide at run-time whether or not to
provide it.
The set Tin (Tout) is determined by recursively computing
the types of all references that the component can receive from
(pass to) its environment, as shown in Figure 1.
As an example, consider the calendar component in
Listing 1. As the component has no input (we omitted
the parameters of createAppointment() for simplicity),
Calendar does not request any permissions from its en-
vironment, so Tin = ∅. However, it grants permission to
use the appointment returned by getNextAppointment()
via the Appointment interface, which results in Tout =
{Calendar, Appointment, int, String}.
The calendar client displaying upcoming appointments may
now have an interface similar to Listing 2.
This
interface
speciﬁes
the
permissions
the
client
needs from a Provider: it must be able to call the
getNextAppointment() method, which returns an object
of type Event. On an Event, the client must be able
to call startTime() and endTime(), and it will use
subject(), if available. Thus, for the calendar client com-
ponent we have Tout = {CalendarClient} and Tin =
{Provider, Event}. Since we use structural typing for
component interfaces, a reference to the Calendar compo-
nent can be passed to setProvider(), as Appointment
provides all the methods required by Event.

57
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
LISTING 2. CALENDAR CLIENT INTERFACE
principal class CalendarClient {
interface Provider {
Event getNextAppointment();
}
interface Event {
int startTime();
int endTime();
optional String subject();
}
void displayEvents();
void setProvider(Provider c);
}
Client
Client
Calendar
Appointment
Calendar
Appointment
startTime()
endTime()
Figure 2. Full access to Appointment (left) versus restricted permissions
(right): the client has access to Calendar only through a membrane. The
membrane’s getNextAppointment() method in turn returns a
membrane for the Appointment object, which only allows two methods
to be called.
In this example, the calendar client will not be able
to call the notes() method on events received from any
Provider, because it is not part of the Event interface.
Formally, a component C can invoke method m on an object
o from another component, only if o can be assigned to
a reference of some type T ∈ Tin, which allows to call
m. Especially, a component can only execute the operations
explicitly speciﬁed in its published interface. This means that
everything the component can do is explicitly visible in its
published interface, so the user can decide not to install
the component or to only provide it with a reference to a
restricted object where (some of) the optional permissions are
not granted. Traditionally, this requires to manually program
a membrane for the Calendar component, such that the
object returned by getNextAppointment() does not have
a subject() method (see Figure 2). In our model, the same
effect can be achieved by just casting the Calendar reference
to a more restricted interface, where the subject() method
is missing.
In principle, if the Calendar component declared the
subject() method in Appointment as optional, it also
could decide at run-time whether or not to expose this
method to the client invoking getNextAppointment(),
e.g., based on some authentication procedure. However, we
believe that this decision should usually be left to the user
assembling the components.
Note that a component’s published interface (what it pre-
tends to do) may differ from its actually implemented interface,
e.g., a component may try to call a method not declared in
its published interface. However, because the component will
always be used via its published interface, such a deviation
TABLE I. INTENDED SEMANTICS OF A TYPE T .
Status of
Assertion that the
Permission
method m
referenced object
to call
in type T
has method m
method m
m is not in T
no
no
m is optional in T
no
yes
m is required in T
yes
yes
will result in a type error when the component is loaded. We
will present a detailed discussion of our type system in the
next section.
IV.
TYPE SYSTEM
In order to ease the presentation of our type system,
we make a few simplifying assumptions for the following
discussion: First, we assume that components are written in a
statically typed, object oriented language. This will usually be
the case today and is also assumed by our current implementa-
tion. However, the only real requirement of our approach is just
that the interface between a component and its environment is
purely object oriented. Second, the presentation only covers
object types, i.e., class and interface types, although our
implementation of the type system also provides simple types
and array types. Finally, we will assume the use of structural
typing for interface types. An extension allowing a ﬂexible
mixture of structural and nominal typing is currently being
developed (see Section VI).
A. Types as Permissions
A central idea of our type system is to interpret a com-
ponent’s type as a speciﬁcation of access permissions at
the granularity of single methods. In addition, we retain the
traditional interpretation, which asserts that all objects of a
given type will offer the methods speciﬁed by that type. We
achieve both goals by using the concept of optional methods,
as speciﬁed in Table I.
As the main goal of our type system is security, it must
enforce the access restrictions deﬁned by Table I in such a way
that no component can amplify its rights by type conversions,
i.e., downcasting. Whenever possible, we ensure this property
statically, i.e., at the time a component is deployed, rather than
by using run-time checks. In addition, we avoid delayed type
failures: once a component C is deployed and a reference to
C’s primary object has successfully been assigned to a variable
of some type I, all methods in I can be invoked without run-
time type errors. Finally, the type system supports an easy
attenuation of rights by just upcasting a reference, without the
need to manually code a membrane.
B. Subtyping Rules
From Table I, we can immediately derive the subtype rules
required for our type system: if we have two types S and
T, which only differ in the status of a method m, then S is
subtype of T, if and only if
•
S contains m, but T does not (classical situation),

58
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
S-REFL
S <: S
S-TRANS
S <: U
U <: T
S <: T
S-RCD
{li i∈1..n} ⊆ {kj j∈1..m}
kj = li ⇒ (nj ⇒ oi) ∧ (Sj <: Ti)
{(kj : Sj, nj) j∈1..m} <: {(li : Ti, oi) i∈1..n}
S-ARROW
T1 <: S1
S2 <: T2
S1 → S2 <: T1 → T2
Figure 3. Subtyping rules
CC-REFL
S ≺:c S
CC-TRANS
S ≺:c U
U ≺:c T
S ≺:c T
CC-RCD
{li i∈1..n | oi} ⊆ {kj j∈1..m}
kj = li ⇒ (nj ⇒ oi) ∧ (Sj ≺:c Ti)
{(kj : Sj, nj) j∈1..m} ≺:c {(li : Ti, oi) i∈1..n}
CC-ARROW
T1 ≺:c S1
S2 ≺:c T2
S1 → S2 ≺:c T1 → T2
Figure 4. Deﬁning rules for ≺:c. If S ≺:c T, then r : S can be assigned to
r′ : T without the need for a type check at run-time.
•
or m is required in S, but optional in T (since
this means that every object implementing S also
implements T).
The formal subtyping rules are shown in Figure 3. We
model classes and interfaces as record types, whose members
are functions. Functions have just one argument and return
type, however, multiple argument and/or result values are
possible, since the type can again be a record. The notation
{(li : Ti, oi) i∈1..n} denotes a type with n methods named
li modeled as functions of type Ti = T ′
i → T ′′
i , where
the Boolean value oi indicates whether or not the method
is optional. Compared to traditional type systems (see, e.g.,
[34]), the rule S-RCD representing structural subtyping is
modiﬁed with an extension for optional methods: assume that
S = {(kj : Sj, nj) j∈1..m} and T = {(li : Ti, oi) i∈1..n},
then for S <: T we additionally require that for all common
members m of S and T either m is not optional in S, or it is
also optional in T.
C. Well-Typed Programs
For safety and security reasons, we may allow the VM
to load a component only if the component’s code is well-
typed. According to Cardelli [35], this means that the code will
not exhibit any unchecked run-time errors (although controlled
exceptions are allowed). The main question in this context is:
when can we allow to assign a reference from a variable r
of type S to a variable r′ of type T? Compared to traditional
type systems, the important restriction here is that we must not
allow r′ to gain more permissions than r via downcasting.
Assume that there exists a method m that is optional in
CM-REFL
S ≺:m S
CM-TRANS
S ≺:m U
U ≺:m T
S ≺:m T
CM-RCD
{li i∈1..n} ⊆ {kj j∈1..m}
kj = li ⇒ Sj ≺:m Ti
{(kj : Sj, nj) j∈1..m} ≺:m {(li : Ti, oi) i∈1..n}
CM-ARROW
T1 <: S1
S2 <: T2
S1 → S2 ≺:m T1 → T2
Figure 5. Deﬁning rules for ≺:m. If S ≺:m T, then r : S can be assigned
to r′ : T without the need to introduce a membrane.
C-REFL
S ≺: S
C-TRANS
S ≺: U
U ≺: T
S ≺: T
C-RCD
{li i∈1..n | oi} ⊆ {kj j∈1..m}
kj = li ⇒ Sj ≺: Ti
{(kj : Sj, nj) j∈1..m} ≺: {(li : Ti, oi) i∈1..n}
C-ARROW
T1 ≺:c S1
S2 ≺:c T2
S1 → S2 ≺: T1 → T2
Figure 6. Deﬁning rules for ≺:. If S ≺: T, then r : S can be assigned to
r′ : T.
S, but required in T. Table I shows that there are no security
concerns in this situation, since both S and T allow to call m.
However, since T asserts that the referenced object has method
m, we must check this condition at run-time when assigning
r to r′. Thus, we can assign r : S to r′ : T without a run-time
type check, if and only if
•
there is no optional method in S that is required in T,
•
each required method of T is also present in S,
•
each method of S can be assigned to its corresponding
method in T without a run-time check, i.e., all its
arguments and results can be assigned without check
(this avoids delayed type failures).
Using the rules shown in Figure 4, we denote this situation as
S ≺:c T.
A different situation arises if there exists a method m that
is optional in T, but is not present in S. In this case, Table I
shows that T actually allows to call m (which may, however,
result in a run-time error, if the referenced object o does not
provide that method), while S does not. Thus, we actually can
assign r : S to r′ : T in a secure way, if after this assignment
r′ references an object that does not provide m. We ensure
this by using a coercion semantics, where the result of the
assignment is a reference to a membrane for o that does not
provide method m. Vice versa, this means that we can assign
r : S to r′ : T without introducing a membrane, if and only if
•
each method of T is also declared in S, and

59
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
•
all methods of S can be assigned to the corresponding
method of T without a need for a membrane.
This is formalized in Figure 5. Note the rule CM-ARROW,
which states that when we assign a method m : S1 → S2 to a
method m′ : T1 → T2, and must perform a run-time check or
introduce a membrane for the method’s argument or its result
(i.e., T1 ̸<: S1 or S2 ̸<: T2), we need to wrap m with some
code performing these tasks when it is called at run-time. This
is done by introducing a membrane for the object providing
m.
We can summarize the above considerations into a single
relation ≺: deﬁned by the rules in Figure 6. S ≺: T denotes
that an assignment from r : S to r′ : T is (statically) type safe,
if and only if
•
each required method of T is also declared in S, and
•
all methods of S can be assigned to the corresponding
method of T.
The latter is only the case, if the argument and result can be
assigned without a run-time type check. This is a deliberate
decision in order to avoid delayed type failures, as mentioned
in the second paragraph of Section IV-A.
D. Run-Time Actions
With the relations introduced above, a component’s code
is well-typed, if for each assignment from r : S to r′ : T
the condition S ≺: T holds. However, when at run-time an
assignment with S
̸≺:c T is about to execute, we need to
perform an additional type check. Likewise, when S ̸≺:m T,
we need to introduce a membrane. If we must both create a
membrane and perform a run-time check, the run-time check
will be the last action. For the following detailed discussion,
we assume that variable r : S contains a reference to an object
o of class C.
During the run-time type check, we must simply verify
that a reference to o can be assigned to r′ without any further
actions, i.e., C <: T.
Introducing a membrane is more complex. The coercion
semantics requires that after r : S has been assigned to r′ : T,
r′ refers to an object (i.e., the membrane) that actually has
type T. This membrane must be computed from the types S
and T, and the class C of the object o referenced by r. We
perform this computation in two steps: First, from S and T
we compute the cast action a that needs to be performed by
the membrane. This can be done at the component’s load-
time. Second, we apply a to the actual object o at run-time in
order to obtain the concrete membrane. The rules to compute
the cast action are shown in Figure 7. Informally speaking,
the cast action instructs the membrane to (recursively) retain
only those methods that are allowed by both S and T. Thus,
the application of a cast action a to an object o results in a
membrane for o that (recursively) provides just these methods.
This is formalized in Figure 8, where fa is the actual run-time
operation performed for the cast action a.
A special case occurs, if o already is a membrane (with
cast action a′) for some other object o′. In this case, the
membranes will not be cascaded, but applying a to o will
We deﬁne the set CA of cast actions inductively as follows:
1)
⊤ ∈ CA
⊤ denotes that the membrane does not need to
perform any action, i.e., no need for a membrane.
2)
∀i=1..n : ai ∈ CA ⇒ {li : ai i=1..n} ∈ CA
This means that the membrane (just) provides the
methods li that perform the actions deﬁned by ai.
3)
a ∈ CA ∧ b ∈ CA ⇒ (a, b) ∈ CA
This denotes that a method ﬁrst applies the action
a to its argument, then forwards the call to the
real object, and ﬁnally applies the action b to the
result.
For two types S and T, the cast actions ca(S, T) that need
to be performed when assigning r : S to r′ : T are deﬁned
by the following rules:
CA-NONE
S ≺:m T
ca(S, T) = ⊤
CA-RCD
S = {(kj : Sj, nj) j∈1..m}
T = {(li : Ti, oi) i∈1..n}
S ≺: T
S ̸≺:m T
ca(S, T) = {li : ca(Sj, Ti) i∈1..n, j∈1..m, kj=li}
CA-ARROW
S = S1 → S2
T = T1 → T2
S ≺: T
S ̸≺:m T
ca(S, T) = (ca(T1, S1), ca(S2, T2))
Figure 7. Rules for the cast actions specifying the behavior of a membrane.
result in a merged membrane for o′, reﬂecting both cast
actions a and a′, as shown in Figure 9. Informally, the merge
operation corresponds to the (recursive) intersection of the
allowed methods.
E. Downcasting
The type system outlined above achieves its security prop-
erties by strictly limiting downcast operations. However, this
limitation is only necessary when code executing in a context
x has a reference to an object in a different context y. If the
reference points to an object o in the local context x, i.e., an
object created by context x, there are no security issues at all.
This is because x is able to retain the original (unrestricted)
reference when it creates o, thus, it can not gain additional
authority by downcasting any reference to o. So in order not
to restrict the expressiveness of our type system, we should
allow downcasting in this situation.
We achieve this by a simple extension: We distinguish
between local types, which assert that references of this type
will always point to objects contained in the local context,
and non-local types, which do not provide such a guarantee.
We then extend the subtyping rules from Figure 3, such that
S <: T does not hold if T is local, but S is non-local. It is
still possible to assign from a variable r with a non-local type

60
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
fa(null)
=
null
f⊤(o)
=
o
f{kj:aj
j∈1..m}({li : mi
i∈1..n})
=
{li : faj(mi) i∈1..n, j∈1..m, kj=li}
f(a,b)(m)
=
fb ◦ m ◦ fa
Figure 8. Semantics of the generated membrane.
Assume that o is a membrane, i.e., o = f{k′
j:a′
j
j∈1..m}(o′). Then
f{kj:aj
j∈1..m}(o)
=
f{kj:aj
j∈1..m}(f{k′
j:a′
j
j∈1..m}(o′))
=
(f{kj:aj
j∈1..m} ◦ f{k′
j:a′
j
j∈1..m})(o′)
=
fmerge({kj:aj
j∈1..m},{k′
j:a′
j
j∈1..m})(o′)
where the function merge is deﬁned by
merge(⊤, a)
=
a
merge(a, ⊤)
=
a
merge({li : ai
i∈1..n}, {kj : bj
j∈1..m})
=
{li : merge(ai, bj) i∈1..n, j∈1..m, kj=li}
merge((a1, b1), (a2, b2))
=
(merge(a2, a1), merge(b1, b2))
Figure 9. Fusion of cascaded membranes.
S to a variable r′ with local type T, provided that a run-time
check is performed to ensure that r actually refers to an object
in the local context. With this extension, we can allow all the
traditional downcast operations when the source type is local.
F. An Example
Assume
that
we
have
the
types
Calendar
and
Appointment from Section III, as well as the three restricted
interfaces shown in Listing 3.
LISTING 3. RESTRICTED CALENDAR PROVIDER INTERFACES
interface Provider1 {
Event1 getNextAppointment();
}
interface Event1 {
int startTime();
int endTime();
}
interface Provider2 {
Event2 getNextAppointment();
}
interface Event2 {
int startTime();
int endTime();
optional String subject();
}
interface Provider3 {
Event3 getNextAppointment();
}
interface Event3 {
int startTime();
int endTime();
String subject();
}
In this example, the type Calendar can be converted to
Provider1 without any precautions, since Calendar <:
Provider1 (Rules S-RCD and S-ARROW in Figure 3). Note
that in this case the restricted access permissions, like the fact
that it is not allowed to call subject() on the object returned
by getNextAppointment(), are statically enforced by the
type Provider1 without a need for any run-time checks.
A further conversion from Provider1 to Provider2
is also allowed, since Provider1 ≺: Provider2 (Rule
C-RCD in Figure 6). However, we have Provider1
̸≺:m
Provider2 (Rules CM-RCD and CM-ARROW in Figure 5),
since the members of Event2 are a not a subset of the
members of Event1. Thus, at run-time a membrane for
the Calendar object is created that wraps the method
getNextAppointment(), such that its return value is
wrapped into a second membrane that does not have a method
subject() (c.f. Figure 2). Now, the access restrictions are
enforced by the membrane.
Our type system does not allow a conversion from
Provider2 to Provider3. Although this conversion would
be safe if the reference actually points to an object of type
Calendar, allowing it could result in unexpected run-time
errors: A component that has a reference of type Provider3
would assume that getNextAppointment() always re-
turns an object that provides the method subject(). How-
ever, since subject() is declared as optional in Event2,
the implementation of getNextAppointment() in the
referenced object may actually return a reference that does
not allow to call this method.
V.
COSMA
The Component Oriented Secure Machine Architecture
(COSMA) is a secure VM based on the outlined component
model and type system. It comes with a speciﬁcation for an
object oriented byte code, called Component Intermediate Lan-
guage. As outlined in Figure 10, the structure of this byte code

61
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
2
1..*
1..*
1
1
*
*
*
1
1
...
...
contains
PrincipalClass
Class
Method
Attribute
StorageLocation
ConstantOrVariable
Constant
Imove
Variable
Type
BasicBlock
Instruction
MethodImpl
*
Operand
indices
1
*
1
0..1
1..*
1..*
1
*
*
returnTypes
Figure 10. Simpliﬁed structure of a COSMA program
reﬂects that of a component: The entry point for a component’s
code always is its principal class, which logically contains all
other classes. Method implementations are structured into basic
blocks, which are sequences of instructions (cf. Figure 11).
Basic blocks within the local method are the only admissible
targets of branch instructions. Instructions do not allow direct
access to the memory. Instead, they use typed operands to
access abstract storage locations. There is also no visible call
stack, but a high-level method call instruction, where lists of
operands are passed for arguments and results. This ensures
that a malicious program cannot forge references (e.g., by
abusing an untyped stack), which is the major requirement
for a secure object-capability system. Since the byte code
does not contain any names except the obligatory method
names in interfaces, it also protects the component developer’s
intellectual property rights.
We need a secured byte code, since secure high-level
languages “can still be attacked from below” [36]. In order
to prevent such attacks, we must use “computers on which
only capability-secure programs are allowed” [36]. Thus, new
programs can only be loaded into COSMA as components
represented in our byte code.
When a component is deployed into the VM, it is associ-
ated with a new context that serves as a trust (or protection)
unit. Within this context, the component’s principal class is
instantiated, and a reference (capability) to this principal object
is returned and gets casted to the component’s published
interface. Initially, this reference is the only way to interact
with the component. When an object in a context c creates
another object, the new object also is associated with c. Thus,
a context comprises all objects that are (transitively) created by
the principal object of a loaded component. COSMA ensures
that references can point to objects in a different context, only
if they have a non-local type and therefore are subject to the
security restrictions outlined in Section IV. References with
local types can only point to objects in the local context.
Thus, we do not restrict the code’s expressiveness within a
component.
During deployment, a component’s complete byte code is
checked for consistency, which includes type checking. Since
the byte code does not allow any untyped data accesses, this
call r m args res
Calls method m on the reference r passing args
as arguments and res as write-back operands.
cjmp src nz block
Jumps to block if src ̸= 0 (nz = true) or if
src = 0 (nz = false).
chktype r t dst
Tests whether r has type t and stores the result
in dst.
inv r id args
Invokes a method whose name is stored in the
string referenced by operand id on the reference
r and passes args as the arguments.
jmp b
Jumps to block b.
load const dst
Loads the constant const into dst.
mov src dst
Assigns src to dst.
new c dst
Creates a new object of the given class c and
stores the reference in dst.
op lhs rhs op dst
Calculates lhs oop rhs (with oop ∈ {+, −, ∗, /,
mod, ...}) and stores the result in dst.
ret r
Returns the given operands to the caller.
test lhs rhs op dst
Tests for lhs oop rhs (with oop ∈ {=, ̸=, <, ≤,
>, ≥}) and writes the result to dst.
Figure 11. Instructions supported by the virtual machine (without
array-speciﬁc instructions).
can be done on a per-instruction basis, without a need for a
complex veriﬁcation of instruction sequences, as it is neces-
sary, e.g., in Java byte-code [37]. Based on the type informa-
tion available in the component’s code, COSMA automatically
generates the code for all required membranes, relieving the
programmer from this burden. At run-time, membranes are
automatically inserted via coercion semantics when security
relevant downcasting is performed. Thus, security constraints
are enforced mainly statically, leaving only a few run-time
checks.
The ﬁrst component that is deployed into the VM can
receive a reference to a native kernel object as the ﬁrst
parameter of its constructor. This object offers basic operating
system services (system calls), which are not expressible
through the instruction set for security reasons. As described
in Section III-B, the kernel object is part of the trusted
computing base and built into COSMA. At the moment, we
have implemented only a few indispensable services, thus, the
reference has the interface type shown in Listing 4 (the type
Any used here is a special type, which can be assigned to any
reference type, using a run-time type check; the type String
is currently implemented as an integer array).

62
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
LISTING 4. KERNEL INTERFACE
interface Kernel {
// load component IR and
// return principal object
Any loadComponent(String filename);
// print string to stdout
void print(String msg);
// read string from stdin
String scan();
// create a thread
Thread createThread(Runnable r);
}
interface Thread {
void start();
void join();
}
interface Runnable {
void run();
}
The initial component can share the reference to the
kernel object with other components, while all the rules from
Section IV still apply. In particular, utilization of the operating
system can be restricted and checked at load time as if it were
a normal object.
The basic idea is that the ﬁrst component, wrapping the
functionality of the native kernel object, provides additional
operating system services with a cleaner and more powerful
interface.
A. Implementation
We have implemented two variants of the COSMA virtual
machine: A pure interpreter as a reference implementation of
the machine’s semantics (see Appendix), and a more realistic
version that uses an ahead-of-time (AOT) compiler to trans-
late a component’s intermediate representation (IR) to native
machine code at load time.
The AOT version of COSMA consists of two processes:
One of them implements the loader and type checker, which
are programmed in Java, while the other one executes the gen-
erated native code of all loaded components. When COSMA
starts, the loader reads the IR of the initial component, per-
forms type and consistency checks for each element of the IR,
and then compiles the IR into C code, which is then compiled
into a shared library using the GNU C compiler. This library is
then dynamically loaded and linked into the native execution
process using the dynamic linker (i.e., dlopen() in Linux
systems).
The constructor of the initial component’s principal class
receives a reference to the kernel object described above.
When the kernel’s loadComponent() method is invoked, a
synchronous request is sent to the loader process (using inter-
process communication via UNIX pipes), which will then load
the component’s IR as described above.
When the native code executes an assignment, it may
be necessary to perform a run-time type check and/or to
introduce a membrane. Since a na¨ıve implementation of these
operations would require a recursive traversal of the involved
type deﬁnitions, which is prohibitively expensive, we follow
a different strategy. In the native code, each type is just
represented as a globally unique integer number, which is
assigned by the loader when it ﬁrst sees the type. The loader
also precomputes the relation <: into a hash table, so that
a type-check at run-time just requires a hash table lookup.
The hash table is extended incrementally whenever a new
component is loaded.
Furthermore, the loader precomputes the information that
is needed to create the native code for the classes of all
membranes that may be required at run-time. In Section IV-D,
we have shown that when a reference r pointing to an object
o of class C is converted from type S to T, the required
membrane is determined in two steps:
1)
compute the cast actions ca(S, T) from S and T,
2)
generate the membrane for o from ca(S, T) and C.
In order to generate all membrane classes that may be required
at run-time, we execute a simple data ﬂow analysis that
determines for each statement s performing a relevant type
cast from S to T the set of all classes C, such that a reference
to an object of class C may reach s. We then generate the
code for the required membrane class from ca(S, T) and C.
Since the instances of these membrane classes may again need
to be wrapped by a membrane, resulting in new membrane
classes, we perform a ﬁxed point iteration, which stops when
the set of membrane classes does not change any more. The
termination of this ﬁxed point iteration is actually guaranteed
by the fact that we avoid cascading of membranes by fusing
them as outlined in Fig 9. As with the subtype relation, we
incrementally expand the set of generated membrane classes
whenever a new component is loaded.
Although the creation of all possibly required membrane
classes at load-time requires additional time and storage when
a component is loaded, it makes the creation of membranes
at run-time extremely fast: We just need a hash table lookup
(with the type number of the object’s class as the key) to ﬁnd
the membrane class that must be instantiated.
B. Performance Considerations
Since in the majority of cases, the necessary access restric-
tions are enforced statically by COSMA’s type system, we can
achieve ﬁne grained access control between components with
minimal run-time overhead. This overhead, as compared to
traditional designs for object oriented virtual machines, arises
from the following three sources:
•
The IR does not have a ﬁxed format, like tradi-
tional byte codes, and therefore cannot be directly
interpreted with comparable efﬁciently. However, as
modern virtual machines are based on just-in-time
or ahead-of-time compilation techniques, an efﬁcient
direct interpretation of the IR is no longer a necessity.
If really required, a simple ahead-of-time compiler
could easily transform the IR into a ﬁxed format byte
code at load time.
•
Method calls on component interfaces require a more
expensive dispatch mechanism, since we use a mod-
iﬁed form of structural typing instead of nominal

63
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
typing. However, there is a number of established
methods to minimize this overhead [38] [39].
•
Finally, we need an additional method call for each
method invoked via a membrane. Ignoring possible
low-level optimizations, this effectively doubles the
time required for an (empty) method call. However,
membranes are only introduced for component inter-
faces that include optional methods, thus, this sit-
uation will not occur at high frequencies. We also
will investigate the beneﬁt of dynamically testing
when membranes can safely be removed again. In the
example in Section IV-F, the membrane introduced
when the reference to the Calendar object was
converted from Provider1 to Provider2 can be
removed again when the reference is converted back to
Provider1. The problem is that we need to trade the
time required for this run-time test when assigning a
reference against the time saved when calling methods
via this reference. Thus, this optimization requires
a more elaborate analysis during the ahead-of-time
compilation, which is part of our future work.
So the only unavoidable run-time overhead of our approach is
due to the introduction of membranes. However, membranes
are only needed when a decision on the granted permissions
should be possible at run-time, which imperatively implies that
also the permission checks must be performed at run-time.
In summary, the implementation of COSMA proves that
using our intermediate representation and type system, we can
efﬁciently execute components while offering a high degree of
protection by enforcing ﬁne grained access permissions.
VI.
CONCLUSION AND FUTURE WORK
In this paper, we proposed a novel concept for the secure
cooperation of untrusted components. This involves a compo-
nent model, where each component declares its required and
granted permissions via a self-explanatory public interface.
This interface can then be used to connect it to other com-
ponents. Components are distributed in the form of a secure
byte code with high-level instructions that preserves typing
information, but still protects intellectual property rights. The
corresponding VM implements a type system ensuring that a
component cannot gain more permissions than those explicitly
deﬁned in its public interface. Type checking is done at
deployment time, with some additional run-time checks, where
necessary. Coercion semantics is used to automatically insert
membranes.
At present we have a fully operational implementation of
the type system and the VM, as well as a compiler translating
a Java-like language into our byte code. The implementation
is freely available at the COSMA website [40]. A formal spec-
iﬁcation of the type system, including subtyping and coercion,
is also available, along with the semantics of the implemented
instructions and a formal proof that no instruction sequence
can amplify a component’s permissions (see Appendix).
In the current implementation all components are executed
by the same VM, thus, security of network connections is not
an issue. In the future, the model can be extended to distributed
systems using remote method invocation, provided that the
communication link between the VMs uses a secure protocol
ensuring authentication and integrity.
We are currently working on an extension of our type sys-
tem that integrates structural and nominal typing into a uniﬁed
framework by explicitly considering the required semantics
of methods. In this way, we enable a ﬂexible and safe reuse
of components and at the same time fulﬁll all the subtyping
desiderata outlined in [41] (i.e., ﬂexible assignment of respon-
sibility, modular extensibility of the subtyping relation, unique
name introduction and traceability) without the idiosyncrasies
of that approach, especially avoiding non-transitiveness of the
subtype relation.
We are also working on a more complete operating sys-
tem that meets the special requirements of safe and secure
component-based software. This includes in particular memory
management for strongly interacting components, such as pag-
ing and garbage collection. The latter is especially interesting
in combination with fault tolerance and error recovery: If
an error occurs in one component, the effects for all other
components interacting with it must be as small as possible.
To this end, we are looking for a solution to make reloading
or replacing a component mostly transparent to its users.
Based on our current work, we will investigate the perfor-
mance of our VM in more detail, comparing it against plain
Java, in order to assess the costs for run-time checks and the in-
direction caused by the use of membranes. Other topics, which
we will address in future are the integration of alias control
(cf. Section II), error and exception handling, mechanisms for
the revocation of permissions and optimizations such as the
removal of unnecessary membranes discussed in Section V-B.
Our ultimate goal is to provide a complete programming
system, consisting of a VM, an OS and a high-level language
compiler, which can be used to develop and deploy component-
based software in an easy, secure and efﬁcient way.
REFERENCES
[1]
R. Wism¨uller and D. Ludwig, “Secure Cooperation of Untrusted Com-
ponents,” in Twelfth Intl. Conf. on Emerging Security Information,
Systems and Technologies (SECURWARE 2018).
Venice, Italy:
IARIA, Sep. 2018, pp. 103–107.
[2]
S. Maffeis, J. C. Mitchell, and A. Taly, “Object Capabilities and
Isolation of Untrusted Web Applications,” in Proc. of IEEE Symp.
Security and Privacy.
Oakland, CA, USA: IEEE, May 2010, pp. 125–
140.
[3]
M. S. Miller and J. S. Shapiro, “Paradigm Regained: Abstraction
Mechanisms for Access Control,” in Advances in Computing Science
- ASIAN 2003. Progamming Languages and Distributed Computation,
ser. LNCS, vol. 2896.
Springer, 2003, pp. 224–242.
[4]
M. S. Miller, “Robust composition: Towards a uniﬁed approach to
access control and concurrency control,” Ph.D. Thesis, Johns Hopkins
University, Baltimore, Maryland, May 2006.
[5]
T. Murray, “Analysing object-capability security,” in Proc. of the Joint
Workshop on Foundations of Computer Security, Automated Reasoning
for Security Protocol Analysis and Issues in the Theory of Security,
Pittsburgh, PA, USA, Jun. 2008, pp. 177–194.
[6]
A. Mettler, D. Wagner, and T. Close, “Joe-E: A Security-Oriented
Subset of Java,” in Network and Distributed Systems Symposium.
Internet Society, Jan. 2010, pp. 357–374.
[7]
M. Stiegler, “Emily: A High Performance Language for Enabling
Secure Cooperation,” in Fifth Intl. Conf. on Creating, Connecting and
Collaborating through Computing C5’07.
Kyoto, Japan: IEEE, Jan.
2007, pp. 163–169.

64
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[8]
D. A. Gutierrez, F. T. Mart´ınez, F. A. Garc´ıa, M. A. D. Fond´on, R. I.
Castanedo, and J. M. C. Lovelle, “An Object-Oriented Abstract Machine
as the Substrate for an Object-Oriented Operating System,” in Object-
Oriented Technology ECOOP, Workshop Reader, ser. LNCS, vol. 1357.
Jyv¨askyl¨a, Finland: Springer, Jun. 1997, pp. 537–544.
[9]
R. P. e Silva and R. T. Price, “Component Interface Pattern,” in Proc.
9th Conf. on Pattern Language of Programs, Monticello, IL, USA,
Sep. 2002. [Online]. Available: http://hillside.net/plop/plop2002/ﬁnal/
plop2002 rpsilva0 1.pdf [last access: 17.05.2019]
[10]
S. Mouelhi, K. Agrou, S. Chouali, and H. Mountassir, “Object-Oriented
Component-Based Design using Behavioral Contracts: Application to
Railway Systems,” in Proc. 18th International ACM SIGSOFT Sym-
posium on Component-Based Software Engineering (CompArch ’15).
Montreal, QC, Canada: ACM, May 2015, pp. 49–58.
[11]
F. Bachmann, L. Bass, C. Buhman, S. Comella-Dorda, F. Long,
J. Robert, R. Seacord, and K. Wallnau, “Volume II: Technical
Concepts of Component-Based Software Engineering, 2nd Edition,”
Carnegie Mellon University, Software Engineering Institute, Pittsburgh,
PA, USA, Technical Report CMU/SEI-2000-TR-008, ESC-TR-2000-
007, May 2000. [Online]. Available: https://resources.sei.cmu.edu/
asset ﬁles/TechnicalReport/2000 005 001 13715.pdf
[last
access:
17.05.2019]
[12]
J. Andronick, D. Greenaway, and K. Elphinstone, “Towards proving
security in the presence of large untrusted components,” in Proc.
5th Intl. Workshop on System Software Veriﬁcation, Vancouver, BC,
Canada, Oct. 2010. [Online]. Available: https://www.usenix.org/legacy/
events/ssv10/tech/full papers/Andronick.pdf [last access: 17.05.2019]
[13]
H. M. Levy, Capability-Based Computer Systems. Digital Press, 1984.
[Online].
Available:
http://homes.cs.washington.edu/∼levy/capabook
[last access: 17.05.2019]
[14]
M. S. Miller, B. Tulloh, and J. S. Shapiro, “The Structure of Authority:
Why Security Is not a Separable Concern,” in Proc. 2nd Intl. Conf.
on Multiparadigm Programming in Mozart/Oz.
Charleroi, Belgium:
Springer, 2004, pp. 2–20.
[15]
M. S. Miller, K. P. Yee, and J. Shapiro, “Capability Myths Demolished,”
Systems Research Laboratory, Johns Hopkins University, Technical
Report SRL2003-02, 2003. [Online]. Available: http://srl.cs.jhu.edu/
pubs/SRL2003-02.pdf [last access: 17.05.2019]
[16]
M. A. D. Fondon, D. A. Gutierrez, L. T. Martinez, F. A. Garcia,
and J. M. C. Lovelle, “Capability-based protection for integral object-
oriented systems,” in Proc. Computer Software and Applications Conf.
COMPSAC ’98.
Vienna, Austria: IEEE, Aug. 1998, pp. 344–349.
[17]
M. A. D. Fondon, D. A. Gutierrez, A. G. M. S´anchez, F. A.
Garc´ıa, F. T. Mart´ınez, and J. M. C. Lovelle, “Integrating capabilities
into
the
object
model
to
protect
distributed
object
systems,”
in
Proc.
Intl.
Symp.
on
Distributed
Objects
and
Applications.
Edinburgh, GB: IEEE, Sep. 1999, pp. 374–383. [Online]. Available:
http://dx.doi.org/10.1109/DOA.1999.794067 [last access: 17.05.2019]
[18]
P. M¨uller and A. Poetzsch-Heffter, “Universes: A type system for
controlling representation exposure,” in Programming Languages and
Fundamentals of Programming, A. Poetzsch-Heffter and J. Meyer, Eds.
Fernuniversit¨at Hagen, 1999, pp. 131–140, Technical Report 263.
[19]
W. Dietl and P. M¨uller, “Ownership Type Systems and Dependent
Classes,” in Intl. Workshop on Foundations of Object-Oriented Lan-
guages (FOOL’08), San Francisco, CA, USA, Jan. 2008.
[20]
D. G. Clarke, J. M. Potter, and J. Noble, “Ownership types for
ﬂexible alias protection,” in Proc. 13th ACM SIGPLAN Conf. on
Object-Oriented Programming, Systems, Languages, and Applications
(OOPSLA ’98), Vancouver, Canada, Oct. 1998, pp. 48–64.
[21]
S. Balzer, T. Gross, and P. M¨uller, “Selective ownership: Combining
object and type hierarchies for ﬂexible sharing,” in Foundations of
Object-Oriented Languages (FOOL), J. Boyland, Ed., 2012.
[22]
B. Bokowski and J. Vitek, “Conﬁned Types,” in Proc. 14th ACM SIG-
PLAN Conf. on Object-Oriented Programming, Systems, Languages,
and Applications (OOPSLA ’99), Denver, CO, USA, Nov. 1999, pp.
82–96.
[23]
P. W. L. Fong, “Link-Time Enforcement of Conﬁned Types for JVM
Bytecode,” in Proc. 3rd Annual Conf. on Privacy, Security and Trust
(PST’05), St. Andrews, Canada, Oct. 2005, pp. 191–202.
[24]
——, “Discretionary capability conﬁnement,” in Proc. 11th European
Symposium On Research In Computer Security (ESORICS’06), ser.
LNCS, vol. 4189.
Hamburg, Germany: Springer, Sep. 2006, pp. 127–
144.
[25]
——, “Discretionary Capability Conﬁnement,” International Journal of
Information Security, vol. 7, no. 2, Apr. 2008, pp. 137–154.
[26]
D. Volpano and G. Smith, “A Type-Based Approach to Program Secu-
rity,” in TAPSOFT ’97: Theory and Practice of Software Development,
ser. LNCS, M. Bidoit and M. Dauchet, Eds., vol. 1214. Springer, 1997,
pp. 607–621.
[27]
A. Gollamudi and S. Chong, “Automatic Enforcement of Expressive
Security Policies using Enclaves,” in Proc. 2016 ACM SIGPLAN
Intl. Conf. on Object-Oriented Programming, Systems, Languages, and
Applications (OOPSLA ’16), Amsterdam, Netherlands, Nov. 2016, pp.
494–513.
[28]
P. W. L. Fong and C. Zhang, “Capabilities as alias control: Secure
cooperation in dynamically extensible systems,” Dept. of Computer
Science, Univ. of Regina, Regina, Canada, Technical Report CS-2004-3,
Apr. 2004.
[29]
D. Hagimont, J. Mossi`ere, X. R. de Pina, and F. Saunier, “Hidden Soft-
ware Capabilities,” in Proc. 16th Intl. Conf. on Distributed Computing
Systems (ICDCS ’96), Hong Kong, May 1996, pp. 282–289.
[30]
J. Boyland, J. Noble, and W. Retert, “Capabilities for Sharing - A
Generalisation of Uniqueness and Read-Only,” in 15th European Conf.
on Object-Oriented Programming (ECOOP ’01), Budapest, Hungary,
Jun. 2001, pp. 2–27.
[31]
P. W. L. Fong and S. Orr, “A Module System for Isolating Untrusted
Software Extensions,” in Proc. 22nd Annual Computer Security Appli-
cations Conf. (ACSAC’06), Miami Beach, Florida, USA, Dec. 2006,
pp. 203–212.
[32]
C. Hawblitzel, C. C. Chang, G. Czajkowski, D. Hu, and T. von Eicken,
“SLK: A Capability System Based on Safe Language Technology,”
Cornell University, Technical Report, Mar. 1997. [Online]. Available:
http://www.cs.cornell.edu/slk/papers/slk.pdf [last access: 17.05.2019]
[33]
C. Szyperski, Component Software: Beyond Object-Oriented Program-
ming, 2nd ed.
Boston, MA, USA: Addison-Wesley, 2002.
[34]
B. C. Pierce, Types and programming languages.
MIT Press, 2002.
[35]
L. Cardelli, “Typeful Programming,” in Formal Description of Program-
ming Concepts, E. Neuhold and M. Paul, Eds.
Springer, 1991, pp.
431–507.
[36]
M. Stiegler, “The E Language in a Walnut,” 2000. [Online]. Available:
http://www.skyhunter.com/marcs/ewalnut.html [last access: 17.05.2019]
[37]
X. Leroy, “Java bytecode veriﬁcation: Algorithms and formalizations,”
Journal of Automated Reasoning, vol. 30, no. 3, May 2003, pp. 235–
269.
[Online].
Available:
https://doi.org/10.1023/A:1025055424017
[last access: 17.05.2019]
[38]
A. M. Schiffman and L. P. Deutsch, “Efﬁcient Implementation of the
Smalltalk-80 System,” in Proc. 11th ACM SIGACT-SIGPLAN Symp.
on Principles of Programming Languages (POPL ’84), 1984, pp. 297–
302.
[39]
J. Gil and I. Maman, “Whiteoak: Introducing Structural Typing
into Java,” in Proc. 23rd ACM SIGPLAN Conf. on Object-Oriented
Programming Systems Languages and Applications (OOPSLA ’08),
Nashville, TN, USA, Oct. 2008, pp. 73–90.
[40]
“COSMA – A Virtual Machine Supporting the Secure Cooperation
of
Untrusted
Components.”
[Online].
Available:
https://www.bs.
informatik.uni-siegen.de/forschung/cosma [last access: 28.05.2019]
[41]
K. Ostermann, “Nominal and Structural Subtyping in Component-Based
Programming,” Journal of Object Technology, vol. 7, no. 1, Jan. 2008.
[Online].
Available:
http://www.jot.fm/issues/issue 2008 01/article4
[last access: 17.05.2019]

65
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
APPENDIX
In this section we present the semantics of COSMA’s
instruction set. The auxiliary rules we use here can be found in
Figure 12. We also provide a proof sketch that the semantics
successfully prevents an ampliﬁcation of access rights.
A. Basic Deﬁnitions
According to the structure of the intermediate representa-
tion, we use the following (abstract) types (cf. Figure 10):
•
V for instances of Variable
•
F for instances of Attribute
•
L = V ∪ F for storage locations
•
B for instances of BasicBlock
•
T for instances of Type
◦
τref ∈ T is a reference type
◦
τobj ∈ T is an object type
◦
τval ∈ T is a value type
•
Id for method names
•
N, Z as usual
•
B for Boolean values
•
Impl : (name : Id) × (var : V ∗) × (nargs : N) ×
(resT : T ∗) × (blocks : B∗) × (clazz : Class) for
method implementations
•
Decl : (name : Id)×(opt : B)×(argT : T ∗)×(resT :
T ∗) for method declarations
•
Class : (pub : Impl∗) × (priv : Impl∗) × (attr :
F ∗) × (child : Class∗) for classes and class types
•
Iface : (methods : Decl∗) for interface types.
•
CA for type cast actions
•
RT for generic run-time values
◦
Val for numeric run-time values
◦
Obj : (methods : Impl∗) × (conﬁg : F ∗) for
objects
◦
Mem : (obj : Obj) × (actions : (Id × CA∗)∗)
for membranes
•
Γ for the type environment
A Frame is deﬁned as a tuple (obj : Obj) × (method :
Impl) × (block : N) × (pc : N) × (var : V ∗) × (res : L∗) ×
(resT : T ∗) × (mem : fA(obj)), where obj represents the
current object, method the currently executing method with
the basic block number block and its program counter pc. The
current values of the method’s variables are stored in var, and
res is a list of operands to write back the method’s results to
the caller. resT holds the result types expected by the caller. If
the current method was called on a membrane, a reference to
the membrane is stored in mem. For simpliﬁcation we assume
that the last instruction in each basic block is either a return
statement or an unconditional jump into the following basic
block, i.e., we do not need to model overﬂows of the program
counter. A state S is a stack of frames. We write s :: t to split
S into the topmost frame s and the tail t.
BlockIndex(m, b) = i holds, if there exists exactly one
basic block in m’s implementation that is b and this block
is the i-th block in m.
BLOCKINDEX
m : Impl
b : B
∃1i ≥ 0 : m.blocksi = b
BlockIndex(m, b) = i
To lookup a method implementation for a method named
id inside an object o:
LOOKUP
o : Obj
∃1m ∈ o.methods : m.name = id
lookup(id, o) = m
Object creation follows the INSTANTIATE rule:
INSTANTIATE
class : Class
⟨class.pub ∪ class.priv, class.attr⟩ = o
Instantiate(class) = o
Figure 12. Semantic functions and auxiliary rules
All semantic rules are formulated as a state transition of
one stack conﬁguration to another. Possible effects of these
transitions are:
1)
the top-most frame is changed,
2)
a new frame is pushed onto the stack,
3)
the top-most frame is removed from the stack, or
4)
any meaningful combination of that.
If a frame is changed, we only write down the differences in
the transition. Everything remaining unchanged is not shown.
If for example the program counter is increased, but everything
else is not touched, we just write s[pc ← pc + 1] :: t. For
new frames we assume that the program counter pc and the
block number block are set to 0 and refrain from writing this
explicitly.
B. Constants, Branching and Arithmetic Operations
In this subsection we present the semantics for simple
instructions, such as conditional and unconditional jumps,
loading constants and arithmetic operations and relations.
JMP
BlockIndex(s.method, b) = blk
s :: t
jmp b
−→ s[block ← blk, pc ← 0] :: t
JMP jumps to the given block and resets the program
counter. It holds, iff the given block is part of the current
method.
CJMP-T
BlockIndex(s.method, b) = blk
v → val : Val
(v ̸= 0) = nz
s :: t
cjmp v nz b
−→
s[block ← blk, pc ← 0] :: t
CJMP-T jumps to the given block and resets the program
counter. It holds, if:
1)
the block is part of the current method,

66
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
2)
v contains a value val (e.g., integer),
3)
val ̸= 0 and nz is set to true (jump on non-zero), or
val = 0 and nz is false.
CJMP-F
BlockIndex(s.method, b) = blk
v → val : Val
(v ̸= 0) ̸= nz
s :: t
cjmp v nz b
−→
s[pc ← pc + 1] :: t
CJMP-F increments the program counter. It holds, iff
CJMP-T fails only on the third premise.
LOAD
const : Z
Γ ⊢ dst : τref ⇒ const = 0
s :: t
load const dst
−→
s[pc ← pc + 1, dst ← const] :: t
LOAD loads the constant const into the operand dst and
increases the program counter. It holds for every dst having
a value type. If dst has a reference type, const must be 0
(“null”).
OP
lhs → val1 : Val
rhs → val2 : Val
Γ ⊢ dst : τval
f ∈ {÷, −, mod, ·, +}
s :: t
op lhs rhs f dst
−→
s[pc ← pc + 1, dst ← val1 ◦f val2] :: t
TEST
lhs → val1 : Val
rhs → val2 : Val
Γ ⊢ dst : τval
f ∈ {=, ̸=, <, ≥, >, ≤}
s :: t
test lhs rhs f dst
−→
s[pc ← pc + 1, dst ← val1 ◦f val2] :: t
OP and TEST increase the program counter and calculate
val1 ◦f val2 to store it in the given operand dst. Both rules
hold, if:
1)
both source operands point to values,
2)
the target operand has a value type and
3)
the operator is valid.
C. Object Creation and Assignments
NEW
c : Class
Γ ⊢ c : τ1
Γ ⊢ dst : τ2
Instantiate(c) = o
fca(τ1,τ2)(o) = o′
s :: t
new c dst
−→
s[pc ← pc + 1, dst ← o′] :: t
NEW increases the program counter and stores a reference
to a newly created object (or to a membrane for that object).
It holds, if:
1)
the given class has type τ1,
2)
the target operand has type τ2, and
3)
an object o is created from the given class and
4)
can be assigned to the target operand.
MOV
Γ ⊢ src : τ1
Γ ⊢ dst : τ2
src → o : RT
fca(τ1,τ2)(o) = o′
s :: t
mov src dst
−→
s[pc ← pc + 1, dst ← o′] :: t
MOV increases the program counter and assigns src to
dst, performing the necessary cast actions. It holds, if src is
initialized, and o is assignable to the target operand.
D. Calling Methods and Returning Results
CHKTYPE
Γ ⊢ r : τref
t : T
τref ≺: T = assignable : B
s :: t
chktype r t dst
−→
s[pc ← pc + 1, dst ← assignable] :: t
CHKTYPE increases the program counter and writes True
to dst, iff r is assignable to the given type t.
CALL
r → o : Obj ∧ Γ ⊢ r : τ ∧ τ : Iface
m : Decl
m ∈ τ.methods
lookup(m.name, o) = m′ : Impl
args = (a1, . . . , an) ∧ Γ ⊢ ai : τi
n = m′.nargs
(fca(τ1,m.argT 1)(a1), . . . , fca(τn,m.argT n)(an)) = Var′
m.resT : T k ∧ res : Lk
s :: t
call r m args res
−→
[o, m′, Var′, res, m.resT, ⊥] :: s :: t
CALL creates a new frame containing the target object,
the called method implementation and the method’s list of
variables including the parameters. The frames also carries the
result operands and the result types, as expected by the caller.
The rule holds, if:
1)
r points to an object o and has type τ,
2)
m is a method declaration and available in τ,
3)
o’s class type has an implementation of m, and
4)
the given arguments can be casted to the formal
parameter types of m,
5)
the number of formal result types matches the given
write-back operands.

67
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
CALL-M
r → o′ = fA(o) ∧ o : Obj ∧ Γ ⊢ r : τ
m : Decl
m ∈ τ.methods
lookup(m.name, o) = m′ : Impl
args = (a1, . . . , an) ∧ Γ ⊢ ai : τi
n = m′.nargs
(fca(τ1,m.argT 1)(a1), . . . , fca(τn,m.argT n)(an)) = Var′
m.resT : T k ∧ res : Lk
(m.name, (A1, . . . , An)) ∈ o′.actions
(fA1(Var′1), . . . , fAn(Var′n)) = Var′′
s :: t
call r m args res
−→
[o, m′, Var′′, res, m.resT, o′] :: s :: t
CALL-M does the same as CALL, but additionally adds the
membrane to the new frame. The rule holds, if:
1)
r points to a membrane o′ for object o,
2)
CALL would hold for r 7→ o, and
3)
o′ holds method actions for m that can be applied to
the casted parameters.
INV-M
r → o′ = fA(o) ∧ o : Obj ∧ Γ ⊢ r : Any
id → name : Id
lookup(name, o) = m : Impl
args = (a1, . . . , an), Γ ⊢ ai : Any
n = m.nargs
m.resT : ()
(m.name, (A1, . . . , An)) ∈ o′.actions
(fA1(a1), . . . , fAn(an)) = Var′
s :: t
inv r id args
−→
[o, m′, Var′, (), (), o′] :: s :: t
INV-M creates a new frame containing the target object
and the called method implementation, as well as the given
arguments. Since inv is only allowed on references of type
Any, the reference always points to a membrane, which is
added to the new frame. Result operands and result types are
not set, since the instruction does not support results. The rule
holds, if
1)
r r has type Any and points to a membrane o′ for o,
2)
o has an implementation for a method named name,
3)
all arguments have type Any,
4)
o′ holds method actions for the called method, which
can be applied to the arguments.
RET
m : Impl ∧ m.resT : T n
r : Ln ∧ Γ ⊢ ri : τi ∧ ri 7→ oi : RT
res : Ln ∧ Γ ⊢ resi : ηi
resT : T n
fca(resT i,ηi)(fca(τi,m.resT i)(ri)) = Vi
[. . . , m, . . . , res, resT, ⊥] :: s :: t
ret r
−→
s[pc ← pc + 1, resi ← Vi] :: t
RET removes the top-most frame (the callee frame) from
the stack and increases the program counter in the caller
frame. The operand list res in the callee frame references
storage locations available in the caller frame. Writing to
these operands changes the caller frame, which is the intended
behavior. The instruction performs two typecasts. First, the
actual results ri must be casted to the formal result type of the
method implementation m.resT i. Finally, we need to apply a
cast action, casting from the interface’s result type resT i to
the target operand’s type ηi.
RET-M
m : Impl ∧ m.resT : T n
r : Ln ∧ Γ ⊢ ri : τi ∧ ri 7→ oi : RT
res : Ln ∧ Γ ⊢ resi : ηi
(m.id × (A1, . . . , An)) ∈ o′.actions
resT : T n
fca(resT i,ηi)(fAi(fca(τi,m.resT i)(ri))) = Vi
[. . . , m, . . . , res, resT, o′] :: s :: t
ret r
−→
s[pc ← pc + 1, resi ← Vi] :: t
In case the method was invoked through a membrane as in
RET-M, an additional cast is needed between the two type casts
mentioned in RET. This cast addresses differences between the
method implementation’s formal result types and interface’s
result types.
E. Proof Sketch: No Ampliﬁcation of Rights
Assumption 1. X is a context, and o ∈ X is an object
providing method m. X′ is a different context (X′ ̸= X)
holding references that point to o or a membrane for o. For
all references r ∈ X′ pointing to o or a membrane for o, we
assume that m is not callable.
Notation: For a method m and an interface type T we write
m ∈ T ⇔ (m : U, η) ∈ T. For a reference r we write
m ∈ r ⇔ Γ ⊢ r : T ∧m ∈ T. For a membrane mem we write
m ∈ mem ⇔ (m.name, ca) ∈ mem.actions. For cast ac-
tions ca(S, T) we write m ∈ ca(S, T) ⇔ (m : A) ∈ ca(S, T).
With this notation, the assumption can be formalized as
∀r ∈ X′ :
Γ ⊢ r : T ∧ m /∈ T
r 7→ o
m /∈ membrane(o)
r 7→ membrane(o)
Observation 1. For assignments from type S = {(kj
:
Sj, ηj)j∈1...z} to type T = {(li : Ti, σi)i∈1...n} we have three
cases:
1)
S ̸≺: T
⇒ assignment is not possible ⇒ no need to consider
2)
S ≺:m T
⇒ {li i∈1...n} ⊆ {kj j∈1...z} ∧ ca(S, T) = ⊤
3)
S ≺: T ∧ S ̸≺:m T
⇒ ca(S, T) = {li : ca(Sj, Ti) i∈1...n, j∈1...z, kj=li}
Theorem 1. There is no sequence of instructions executed in
context X′ involving any r ∈ X′ that results in successfully
calling m on o, unless m is called by some method in a
different context X′′ or X′′ returns a reference to o allowing
m.
Proof: COSMA supports 14 instructions of which four
(mov, call, ret, inv) are able to create or copy object

68
International Journal on Advances in Security, vol 12 no 1 & 2, year 2019, http://www.iariajournals.org/security/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
references. The new-instruction is of no interest. We perform
an induction over the length ℓ of the instruction sequence.
For ℓ = 0, m is not callable on any reference r ∈ X′ by
assumption (induction hypothesis).
Instruction: mov r r’
Let r ∈ X′ be a reference of type S and r′ a new reference
of type T.
1)
S ≺:m T
a)
r 7→ o
Ass
⇒ m /∈ S ⇒ m /∈ T
MOV
⇒ r′ = r ⇒
m /∈ r′
b)
r
7→
o′
=
fca(S′,T ′)(o)
Ass
⇒
m
/∈
ca(S′, T′)
MOV
⇒ r′ 7→ o′ ⇒ m /∈ r′
2)
S ≺: T ∧ S ̸≺:m T
a)
r 7→ o
Ass
⇒ m /∈ S ⇒ m /∈ ca(S, T) ⇒ m /∈
fca(S,T )(o)
MOV
⇒ m /∈ r′
b)
r 7→ o′ = fca(S′,T ′)(o)
Ass
⇒ m /∈ ca(S′, T′)
MOV
⇒
r′
=
fca(S,T )(fca(S′,T ′)(o))
=
fmerge(ca(S,T ),ca(S′,T ′))(o)
merge
⇒
m /∈ r′
The second case needs more explanation: If r has type S
and points directly to o, S has no m (induction hypothesis).
Then, m is not part of ca(S, T) following CA-RCD. By
applying this cast action to o, m is not callable on the resulting
membrane.
If r points to a membrane, following the induction
hypothesis m is not callable on this membrane. But the
membrane results from applying a type cast action ca(S′, T′)
to the object o, so m was not a part of that type cast action.
When merging this cast action with any other type cast action,
m cannot be part of the result. Therefore it is also not callable
through r′.
Instruction: call ref m args res
Let method foo accept an argument of type U and S ≺: U.
We assume that foo is callable through some reference ref
and the actual implementation accepts arguments of type T,
with U ≺: T. Let r′ be the name of a parameter in foo. The
instruction pushes a new frame onto the stack so that the stack
will look like this: [. . . , Var′ = (r′, . . . ), . . . ] :: s :: t.
•
m = (foo, opt, argT = (. . . , U, . . . ), resT = (. . . ))
•
args = (. . . , r, . . . ),
res = (. . . ),
ref 7→ obj ∨
ref 7→ fA(obj)
•
ref 7→ obj ⇒ U ≺:m T ⇒ ca(U, T) = ⊤
Again, we look at the different cases:
1)
S ≺:m U ∧ U ≺:m T ⇒ S ≺:m T
a)
r 7→ o
Ass
⇒ m /∈ S ⇒ m /∈ T
CALL
⇒
r′ 7→
f⊤(o) = o ⇒ m /∈ r′
b)
r 7→ fca(S′,T ′)(o)
Ass
⇒ m /∈ ca(S′, T′)
CALL
⇒
r′ 7→ f⊤(fca(S′,T ′)(o)) = fca(S′,T ′)(o) ⇒
m /∈ r′
2)
S ̸≺:m U ∨ U ̸≺:m T ⇒ S ̸≺:m T
a)
r 7→ o
Ass
⇒ m /∈ S ⇒ m /∈ ca(S, U) ⇒ m /∈
fca(S,U)(o)
⇒ m /∈ fca(U,T )(fca(S,U)(o))
CALL
⇒ m /∈ r′
b)
r 7→ o′ = fca(S′,T ′)(o)
Ass
⇒ m /∈ ca(S′, T′)
CALL
⇒ r′ = fca(U,T )(fca(S,U)(fca(S′,T ′)(o)))
merge
⇒
m /∈ r′
The proof for method calls performed on a membrane follows
directly from CALL-MEM and merge.
Instruction: inv x mth r
The inv-instruction accepts only arguments of type Any. In
order to pass r as an argument to mth it needs to be casted
it to this special type. This always introduces a membrane
fca(S,Any)(r) allowing exactly the methods that are callable
through r, because S ̸≺:m Any. This membrane can then be
assigned to a reference r′ of the methods formal parameter
type T with just a type check (Any ≺:m T ∧ Any ̸≺:c T).
m /∈ r
INV-M
⇒ m /∈ r′
Instruction: ret
Let bar be the current method with formal return type
(. . . , U, . . . ) that was invoked through an interface bar : X 7→
(. . . , V, . . . ). Let s′ :: s :: t be a snapshot of the system’s state
right before the execution of the return-instruction.
s′ = [
obj,
bar,
Var′ = (. . . , r, . . . ),
ResT′ = (. . . , V, . . . ),
Res′ = (. . . , r′ . . . ),
⊥ ]
Let Γ ⊢ r :: S ∧ Γ ⊢ r′ :: T and S ≺: U.
•
S ≺: U ⇒ ca(S, U) ̸= ⊥
•
V ≺: T ⇒ ca(V, T) ̸= ⊥
•
U <: V ⇒ ca(U, V ) = ⊤ (follows directly from
CM-ARROW)
Again, look at the different cases:
1)
S ≺:m U ∧ V ≺:m T ⇒ S ≺:m T
a)
r 7→ o
Ass
⇒ m /∈ S ⇒ m /∈ T ⇒ m /∈ r′
b)
r 7→ fca(S′,T ′)(o)
Ass
⇒ m /∈ ca(S′, T′)
RET
⇒
r′ 7→ fca(S′,T ′)(o) ⇒ m /∈ r′
2)
S ̸≺:m U ∨ V
̸≺:m T ⇒ S ̸≺:m T
a)
r 7→ o
Ass
⇒ m /∈ S
⇒ m /∈ merge(merge(ca(S, U), ⊤), ca(V, T))
RET
⇒ r′ 7→ fmerge(merge(ca(S,U),⊤),ca(V,T ))(o)
⇒ m /∈ r′
b)
r 7→ fM=ca(S′,T ′)(o)
Ass
⇒ m /∈ r
⇒ m /∈ ca(S′, T′)
RET
⇒ r′ = fY (fM(o)) with
Y = merge(merge(ca(S, U), ⊤), ca(V, T))
⇒ r′ = fmerge(Y,M)(o)
⇒ m /∈ r′
The proof for returning from a method called on a membrane
follows directly from RET-M and merge.

