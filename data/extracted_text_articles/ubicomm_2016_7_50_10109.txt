ZiZo: A Complete Tool Chain for the Modeling and Verification
of Reconfigurable Function Blocks
Safa Guellouz, Adel Benzina
LISI Laboratory, INSAT and
Tunisia Polytechnic School,
University of Carthage, Tunis, Tunisia
Email: guellouz.safa@gmail.com,
adel.benzina@isd.rnu.tn
Mohamed Khalgui
School of Electro-Mechanical Engineering,
Xidian University,
Xi’an 710071, China
Email: khalgui.mohamed@gmail.com
Georg Frey
Chair of Automation and Energy Systems,
Saarland University,
Saarbrücken, Germany
Email: georg.frey@aut.uni-saarland.de
Abstract—Ubiquitous systems support reconfigurable hardware
and software self-adapted components to external changes for
a better performance. IEC 61499 is the most suitable manufac-
turing standard that designs distributed ubiquitous systems. All
the available IEC 61499 development tools ensure the design,
simulation and code generation of function block systems. There
is no complete tool chain which supports design, modeling with
Petri nets and automatic verification with model checking. This
paper presents ZiZo v3 tool that supports the whole process for
a new extension of IEC 61499 named Reconfigurable Function
Block (RFB). ZiZo automates the transformation from RFB
design diagrams to the Generalized Reconfigurable Timed Net
Condition/ Event Systems GR-TNCES model that preserves its
behavioural semantics and also exports it to the probabilistic
symbolic model checker PRISM. A case study is presented to
demonstrate the whole process from the design with RFB to
verification.
Keywords–IEC 61499; Reconfiguration; Reconfigurable dis-
tributed system; Automatic transformation; GR-TNCES.
I.
INTRODUCTION
The flexibility and reconfigurability of manufacturing is
one of the major drivers of IEC 61499 [1]. Several works
address various aspects of hardware and software reconfigura-
tion using this standard. These include works on down-timeless
evolution [2] and real-time implementations [3]. Other works
focus on agent-based reconfiguration [4], ontology-based re-
configuration agent [6] and even reconfiguration protocol [7].
We notice that these approaches of reconfiguration following
IEC 61499 increase engineering efficiency and also the design
complexity. In fact, the number of function blocks and the
interconnections between them in the design system become
very complex as well as their verification. In order to make the
design easier, we propose an extension to the function block,
named Reconfigurable Function Block (RFB) that encapsulates
many scenarios of reconfiguration related to the changes in
the controlled process. We aim to modify first of all the
implementation of a function block by modifying the execution
control chart model and the interface by adding a new event
type to support reconfiguration, as well as the probabilistic
aspect. Probabilistic events and scenarios are suggested to add
a degree of uncertainty to events, thus it will be possible to
evaluate after words the probability of occurrence of some
unwanted states or scenarios like deadlocks.
On another hand, the verification and validation of au-
tomation software for reconfigurable distributed systems is an
especially hard task. Many research works model manually
the system with Petri nets [18] to verify it with a model
checker. To handle the design and the modeling of systems
with RFBs and automate their transformation to GR-TNCES
[8], a class of Petri nets that preserves the behavioral semantics
of RFB, we developed a complete tool ZiZo v3 as an extension
to an existing tool ZiZo v2 [9] that models and simulates
adaptive probabilistic discrete event control systems with GR-
TNCES. Thanks to ZiZo, the verification of functional and
temporal properties becomes easy: The designer can export
the GR-TNCES model to PRISM model checker [10]. He/She
can verify the functional correctness and safety of individual
function blocks and entire control applications.
The remainder of this paper is structured as follows: We
begin with the state of the art. In Section III, we present
the reconfigurable function block as a new extension to IEC
61499. Then, we discuss the transformation of RFBs models to
GR-TNCES model through a well-defined set of transforma-
tion rules in Section IV. We continue presenting the way that
ZiZo v3 supports and automates the transformation process in
Section V. This is followed by a presentation of the BROS
system, which we have considered as a case study for our
approach. Finally, we summarize this work.
II.
STATE OF THE ART
A. IEC 61499 Modeling
Today, in industry, ubiquitous computing software must
operate in conditions of radical change [5]. That is why
several component-based technologies have been proposed
to develop ubiquitous embedded control systems. Among all
these technologies, the Industrial International Standard IEC
61499 is a component-based technology that defines Function
Blocks (FBs) to model and implement distributed Industrial
Process Measurement and Control Systems (IPMCSs).
A function block is an event triggered unit encapsulating
some functionalities in algorithms. It contains data/event inputs
and outputs to interact with the external environment. The
activation of the block is ensured by events while data contain
valued information. The algorithms encapsulated in the func-
tion block use data associated with incoming events to update
internal and output data. The functionality of function block
is defined by a state machine called execution control chart. It
controls the algorithms execution and produces output events.
Each state is assigned to actions (ECAction) that include
144
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

algorithms to be executed before sending output events. The
states are connected to each other with ECtransitions that fire
if the corresponding event occurs and the guard conditions are
met. The conditions are based on internal variables or data
inputs but not events.
Several tools have been developed in the past years to
design IPMCSs following the standard: FBDK [11], IsaGRAF
[12], nxtSTUDIO [13] and other IEC 61499 IDEs. Neverthe-
less, they do not offer verification support. The most important
tool for that is VEDA [14] that mainly focuses on the modeling
and verification of the function block execution control. In fact,
the modeling and verification of reconfigurable manufacturing
systems attract many researchers. Pang et al. [15] present a pro-
totype model generator, which aims to automatically translate
IEC 61499 function blocks into Net Condition/Event Systems
following sequential execution semantics. Gerber et al. [16]
present a formal model for integer-valued data types. This
allows automatic model generation from arbitrary function
block programs. Suender et al. [17] present a new formal
validation of “on-the-fly” modification of control software
in IEC 61499 automation systems. The main objective of
modeling with Petri nets is to validate the system before its
deployment. The above works use Petri nets to verify the
correctness of the IEC61499 designs. But none of them has
proposed a way for considering and modeling probabilistic
reconfiguration scenarios within the function block paradigm
and none has provided a complete tool that supports the design
of function blocks, modeling with Petri nets and verification
using model checking. In this work, a reconfigurable function
block is formalised to support probabilistic reconfigurations in
the current standard IEC 61499. Furthermore, a complete tool
chain supports the whole process from the design of RFB to
verification with model checking.
B. GR-TNCES
Petri nets [18] are widely used for the modeling of dis-
tributed control systems and support formal analysis such
as model checking. GR-TNCES is a class of Petri nets
considering reconfiguration and probability of occurrence of
events. A GR-TNCES, as defined in [8], is an extension
of the formalism Reconfigurable Timed Net Condition/Event
Systems (R-TNCES) [19], which models unpredictable sys-
tems under memory and energy constraints and has a real-
time probabilistic reconfigurable supervised control architec-
ture. It is defined as a structure G = {∑ R − TNCES}.
R − TNCES = (B, R), where R is the control module
consisting of a set of reconfiguration functions. B is the
behavior module that is a union of multi TNCES, represented
as follows:
B = (P, T, F, W, CN, EN, DC, V , Z0) where: (i) P
(respectively, T) is a set of places (respectively, transitions),
(ii) F is a set of flow arcs F ⊆ (P × T) ∪ (T × P), (iii) W:
(P × T) ∪ (T × P) → {0, 1} maps a weight to a flow arc,
W(x, y) > 0 if (x, y) ∈ F, and W(x, y) = 0 otherwise, where
x, y ∈ P ∪ T, (iv) CN (respectively, EN) is a set of condition
(respectively, event) signals with CN ⊆ (P ×T) (respectively,
EN ⊆ (T ×T)), (v) DC: F(P ×T) → {[l, h]} is a super-set of
time constraints on output arcs, (vi) V: T → {∨, ∧} maps an
event-processing mode (AND or OR) to each transition, (vii)
Z0= (T0, D0) where T0: P → {0, 1} is the initial marking
and D0: P → 0 is the initial clock position.
A reconfiguration function r ∈ R is a structure r =
(Cond, P, E, M, S, X) where: (a) Cond → {true, false}:
The precondition of r, (b) P: F → [0..1] is the TNCES
probability, (c) E: P → [0..max]: controls the energy re-
quirements, (d) M: P
→ [0..max] controls the memory
requirements, (e) S: TN(•r) → TN(r•) is the structure
modification instruction for reconfiguration scenario, (f) X:
laststate(•r) → initialstate(r•) is the state processing
function.
We note, finally, that ZiZo v2 is the only tool that models
GR-TNCES models. It is an extension to ZiZo v1 [20], devel-
oped in LISI Laboratory of INSAT Institute in collaboration
with Saarland University in Germany. It edits, simulates and
checks adaptive systems modeled with R-TNCES formalism.
Furthermore, Zizo v2 allows designers to edit, simulate and
export GR-TNCES models to the probabilistic model checker
PRISM [10]. PRISM is a useful tool to verify functional and
temporal properties of GR-TNCES. We apply it in our work
to verify adaptive probabilistic discrete event control systems.
C. Originality
The design of reconfigurable systems following the IEC
61499 standard using the available tools is complex and
difficult. To optimize the network of FBs and make it more ad-
justable to external changes, we propose a new function block
named RFB that provides a simple model of reconfigurable
systems. An RFB allows several ways of functioning thanks
to reconfiguration. Hence, it reduces the number of FBs used in
the design as well as its complexity. Consequently, we extend
the Petri nets editor ZiZo v2 to support: (i) design with RFB,
(ii) automatic transformation from RFB to GR-TNCES model,
and (iii) verification with model checking. ZiZo v3 is the only
tool that supports the whole process from the design with RFB
to verification.
III.
RECONFIGURABLE FUNCTION BLOCKS
An RFB is a new extension of IEC 61499 that includes
reconfiguration and probability aspects. It encapsulates several
reconfiguration scenarios within a single FB and incorporates
the probability of triggering each scenario. It is able to self-
adapt the behavior of the system when changes occur in the
environment. An RFB, as illustrated in Fig. 1, has new events
and data of reconfiguration. It has also a specific architecture
of the known execution control chart ECC: an ECCcontroller
for the supervision of the elementary ECCs named ECCslaves
such that each one executes a scenario of reconfiguration.
When an input event of reconfiguration occurs, ECCcontroller
becomes active and reads the associated data of reconfiguration
to select which scenario of reconfiguration will be active, and
therefore, which ECCslave will be executed. If the guard
condition of the transition in ECCcontroller is met, then
the corresponding ECCslave waits for the occurrence of an
input event to run the suitable algorithm, updates data and
sends output events. At the end of all algorithms execution,
ECCcontroller receives an event from the active ECCslave. It
updates the data of reconfiguration and generates output events
of reconfiguration to communicate with the next RFBs.
The formalization of an RFB is defined as a tuple:
RFB=(Interface, ECCcontroller, ECCslave), where:
145
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Figure 1. RFB interface.
1) Interface: The interface of an RFB is determined by
the tuple Interface=(IE, OE, ID, OD, IW, OW, IER,
OER, IDR, ODR, IWR, OWR), where (i) IE (respectively
OE) is a set of input (respectively output) events; (ii) ID
(respectively OD) is a set of data inputs (respectively outputs);
(iii) IW (respectively OW) is a set of WITH-associations for
inputs (respectively outputs); (iv) IER (respectively OER) is
a set of input (respectively output) events of reconfiguration,
each ier ∈ IER has a probability p ∈ [0, 1]; (v) IDR (respec-
tively ODR) is a set of input (respectively output) data which
corresponds to all distinct ECCslaves in this RFB (respectively
in the next RFBs); (vii) IWR ⊆ IER × IDR is a set of
WITH-associations for inputs of reconfiguration. Each input
event of reconfiguration is associated with the corresponding
ECCslave ∈ IDR that will be activated; (viii) OWR ⊆
OER×ODR is a set of WITH-associations for output events
of reconfiguration. Each output event of reconfiguration is
associated with the corresponding ECCslave ∈ nextRFB
that will be activated. (ix) Each event in the interface has
a probability of occurrence pij ∈ [0, 1] / j ∈ N and each
ECCslave has a probability of activation pr ∈ [0, 1].
2) ECCcontroller: Is the main component in an RFB. It
controls the activation of ECCslaves, as illustrated in Fig.
2a. It is defined as a tuple: ECCcontroller = (Statecontroller,
Transitioncontroller, Conditioncontroller, Actioncontroller),
where: (i) Statecontroller is a set of states where s0 ∈
Statecontroller
is the initial state; each state can have
zero or more ActionController; (ii) TransitionController ⊆
Statecontroller × Statecontroller is a set of arcs representing
transitions, a transition may have a probability pr ∈ [0, 1],
which corresponds to the probability of activation of an
ECCslave. The sum of probabilities of transitions issued
from the same state must be equal to one ∑ pri = 1. The
probabilities in the interface are the same as those on the
ECCcontroller transitions; (iii) ConditionController is a guard
condition defined on an input event and data of reconfigura-
tion; (iv) Actioncontroller : Statecontroller \ {s0} −→ ECA
where ECA = ECCslave × OER is a set of actions. Each
action should select one ECCslave and one output event of
reconfiguration.
3) ECCslave: Let us consider n ECCslavei ∈ RFB where
i ≤ n. Each ECCslavei is controlled by ECCcontroller, it en-
capsulates all algorithms to execute. According to the received
data of reconfiguration, ECCcontroller selects the correspond-
ing ECCslave. As illustrated in Fig. 2b, an ECCslavei =(S, Tr,
C, A), where: (i) S is a set of states; (ii) Tr ⊆ S × S is a
set of arcs representing transitions from one state to another;
(iii) C is a set of guard conditions defined over input, internal
and output variables of RFB; and (iv) A is a set of actions
sequences. Each action is related to an algorithm that can
change only internal variables and output data of the RFB.
(a) ECCcontroller.
(b) ECCSlave1.
Figure 2. RFB components.
As a result, a reconfigurable distributed system is modeled
as a network of interconnected RFBs linked by data and event
flows. At the end of each scenario of reconfiguration encap-
sulated in an ECCslave, each output data of reconfiguration
contains the next ECCslave, which will be active in the next
RFB. When its value is updated, the associated output event
of reconfiguration occurs to trigger the suitable RFBs.
IV.
TRANSFORMATION RULES
The main objective of this transformation is to validate the
system before its deployment. Each functional component of
the RFB is modeled by a GR-TNCES [8] module. RFB =
{GInterface, GECCController, GECCSlave} where GInterface
={ GIE, GOE, GID, GOD, GIER, GOER, GIDR, GODR,
GIW , GOW , GIW R, GOW R} where GX models the X compo-
nents of the RFB. GX = ∑ GXi. We have GXi=(B,R) where
B=(P, T, F, W, CN, EN, DC, V , Z0) and R = ∑ ri;
ri=(cond, P0, E0, M0, S, X) a reconfiguration function.
All the input and output events have the same structure.
The graphical models presented in Fig. 3 and Fig. 4 explain
the transformation rules for all the components. As an example,
let us detail the transformation rule for an input event:
Rule1: ie ∈ IE −→ GIEi
The objective of this rule is to transform each input event
of RFB to a GIEi module. The graphical model is pre-
sented in Fig. 3a. The behavior of GIEi
is composed
of: P={p1,p2};T={t1,t2}; F={(p1,t1),(t1,p2),(p2,t2),(t2,p1)};
W={} ;CN={}; EN={ie1, ie2, oe1}; DC={}; V (t1)=∧;
146
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

V (t2)=∧;
Z0={T0,D0}
where
T0(p1)=1,
T0(p2)=0
and
D0(p1)=0;
Rule2: IW ∈ Interface (respectively OW) is translated to
GIW :GIE → GID (respectively GIW :GOE → GOD) where
an output event oe ∈ GIE (respectively eo ∈ GOE) is linked
to an input event ie ∈ GID (respectively ie ∈ GOD.
IWR
∈
Interface (respectively OWR) translated to
GIW R:GIER
→
GIDR (respectively GIW R:GOER
→
GODR) where an output event oe ∈ GIER (respectively
oe ∈ GOER) is linked to an input event ie ∈ GIDR
(respectively ie ∈ GODR).
The ECCController transformation rule is different from
Rule1, it is modeled in Fig. 5 as follows:
Rule3: ECCController −→ GECCcontroller
An ECCController is transformed to a GECCcontroller module.
GECCcontroller is composed of: An initial marked place and a
transition from which emerge n branches such that each one
has a certain probability (probability of each reconfiguration
scenario) where n is the number of ECCslave in the current
RFB. Each branch is composed of: two places and two
transitions. The first place is linked to an input condition
“ECCslavei true” (i ∈ [1..n]), which indicates that the ECCslavei
must be activated. This place is linked to a transition T2 from
which emerge n output events for activating the ECCslavei
and deactivating the rest of the ECCslave. This ensures that a
single scenario of reconfiguration is active at a given time.
The second place is linked to an input condition “ECCslavei
finished”, which marks the end of execution of the current
active ECCslavei. Each branch finishes with a transition that
sends 2 output events: the first one is for setting the output
events of reconfiguration oer ∈ OER and the second one
for unsetting the input event of reconfiguration ier ∈ IER.
Let us consider that there are n ECCslaves and m output
events of reconfiguration in an RFB, the model of the
GECCcontroller has then n reconfiguration function ri. B will
be composed of: P = {p1..p2n+1}; T = {t1..tn+2}; F=
{(p1,t1),(t1,p2),(t1,p3)..(t1,pn+1),
(p2,t2),(p3,t3)..(pn,tn),
(t2,pn+2),(t3,pn+3)..(tn,p2n)..(p2n+1,tn+2),(tn+2,p1};
EN={oe1..oe2n+1+m}; CN= {ci1..ci2n} (for each slave
an input condition ECCslave true and an input condition
ECCslavefinshed); W={}; DC={}; V (ti)=∧; Z0={T0,D0}
where T0(p1)=1, T0(pi)=0 and D0(p1)=0;
Rule4: ECCslavei ∈ ECCSlave −→ GECCslavei
An ECCslavei is transformed to a GECCslavei module. ECCSlave,
as we aforementioned, is a standard execution control chart
so it contains states, transitions and actions.
The initial state is transformed to an initial marked place
linked to a transition that is fired with the arrival of an
input event for activating ECCslavei. As shown in Fig. 6,
each state is transformed to two places “state run alg” and
“state finish alg” as well as a transition between them. Each
action is modeled with: an initial place “wait”, an initial
transition T14 that is fired when the input condition “start
algorithm” is true and M places linked to M transitions
for running Algoj (where M is the number of algorithms
within the action) and j ∈ [1..M]). When all the algorithms
in the different actions finish their execution, the ECCslave
generates an output condition indicating the end of the slave.
Let us consider k states and k actions in ECCslavei, j guard
conditions on transition, each action contains an algorithm
and an output event of reconfiguration then B(GECCslavei)
is composed of: P={ p1...p5k+2}; T={t1...t4k+4}; F
⊆
(P × T)U(T × P); EN={ie1, ie2,oe1,...,oek}; CN={ci1,
ci2, cij+k} W={};DC={}; V (ti)=∧; Z0={T0,D0} where
T0(p1)=1, T0(pi)=0 and D0(p1)=0;
V.
ZIZO V3
The third version of ZiZo allows to model any reconfig-
urable distributed system with RFB formalism by modeling
the different reconfiguration scenarios and save it as “.nrfb”
file. It supports new probabilistic events named “input and
output event of reconfiguration” and new data types named
“input and output data of reconfiguration” that present the
ECCslaves. As shown in Fig. 7, ZiZo v3 is more than
a basic RFB editor, but it allows the system designer to
transform automatically the RFB system into GR-TNCES that
supports random reconfigurations with real-time constraints.
Each component of RFB corresponds to a GR-TNCES module.
This transformation is from “.nrfb” file to “.zz” file and it helps
to verify functional and real-time properties after exporting it
to PRISM model checker. During the exportation, a “.pm”
file is generated to contain the places and the probability
between them. This process is not sufficient to prove the
correctness of the RFB system as it lacks the formal properties
that is described in computation tree logic (CTL) [19] and
Probabilistic Computation Tree Logic (PCTL) [21] language.
VI.
CASE STUDY
The presented case study consists of a surgical robotized
platform BROS [22] that is able to change its behavior in an
unpredictable way during run-time processes. BROS [23] is a
new automated intelligent platform developed for an optimal
orthopaedic surgery to treat supracondylar elbow fractures in
children. It is a complex system that contains the following
interactive components: An intelligent robotic arm P-BROS to
place the pins, two intelligent manipulator arms (B-BROS1
and B-BROS2) for the blocking and the reduction of the
fracture respectively, a system browser (BW), a control unit
(CU), which orchestrates the various components and finally a
middleware between the CU and the BW. The surgeon triggers
the system and selects the operating mode. Based on the
fracture coordinates determined by BW, the CU calculates the
new coordinates to reduce the fracture by B-BROS2 (move the
patient arm to the calculated position). CU asks MW to check
the correctness of the reduction. If the reduction is successful,
then the CU orders B-BROS1 to block the patient’s arm. Else,
the system repeats the reduction. Under the request of CU and
according to the identified fracture type, P-BROS performs
the single or double pinning in the elbow. Once the pinning
is successful, CU asks B-BROS1 to unblock the limb.
Using “ZiZo v3“, we begin with modeling the three robotic
arms in BROS with RFB formalism. The whole architecture,
as shown in Fig. 8, is composed of four interconnected RFBs
(A: RFBmode, B: BBROS1, C: BBROS2 and D: PBROS).
RFBMode has five ECCslaves each corresponds to an operat-
ing mode. BBROS1 has four ECCslaves: (i) ECCB offering
the automatic blocking; (ii) ECCManualB deactivating the
blocking if datarec is equal to manual; (iii) ECCU activating
the automatic unblocking; (iv) ECCManualU deactivating the
robotized unblocking.
B-BROS2 has two ECCslaves: ECCR to activate re-
duction and ECCnotR to deactivate the robotized reduction;
147
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

(a) GR-TNCES model of an
input event “ie”.
(b) GR-TNCES model of
an output event “oe”.
(c) GR-TNCES model of an
input event of reconfiguration
“ier”.
(d) GR-TNCES model of
an output event of
reconfiguration “oer”.
(e) GR-TNCES model of
an output data “od”.
Figure 3. GR-TNCES model of events.
(a) GR-TNCES model of an input
data of reconfiguration “idr”.
(b) GR-TNCES model of an output
data of reconfiguration “odr”.
Figure 4. GR-TNCES model of reconfiguration data.
Figure 5. GR-TNCES model of an ECCcontroller.
finally, PBROS not only depends on the operation mode but
also on the fracture type that determines the pins number. It has
ECCManualP , ECC1P in (respectively ECC2P in) encapsu-
lating the single (respectively double) pinning algorithms that
require the current P-BROS position, P-BROS orientation and
the patient arm position. In the case of automatic reduction,
blocking or unblocking the CU checks each functionality and
returns reductionOK, blockingOK and PinningOK when it
is successful. In the other case (manual reduction, manual
blocking or manual unblocking), the system waits for these
events from the surgeon to continue the operation. When
exporting RFB model to GR-TNCES model, a file “.zz” is
generated. The transformed model of BROS, according to the
transformation rules in Section IV, is composed of four parts,
as shown in Fig. 9, where: (i) A= ∑ GR − TNCES modules
Figure 6. GR-TNCES model of ECCslave1.
Figure 7. Flow diagram of the verification process using ZiZo and PRISM.
of RFBmode; (ii) B=∑ GR − TNCES modules of B-BROS1;
(iii) C=∑ GR − TNCES modules of B-BROS2; (iv) and D=
∑ GR − TNCES modules of P-BROS.
Let us detail RFBmode presented in Fig. 10 that permits to
activate one operating mode between five (AM, SAM, DMP,
DMB, BM). The ECCcontroller1 of “RFBmode” (Fig. 11a),
reads input data of reconfiguration idr1 . If the guard condition
ier1&idr1 = AM is met (an event of reconfiguration ier1
arrives and idr1 equal to “AM”) then it activates the ECCslave
“AM” detailed in Fig. 11b.
Fig. 12 presents the transformed GR-TNCES model of
RFBMode, which is composed of GR-TNCES modules colored
in yellow. Each module is composed of places, transitions,
events and conditions that preserve the behavioral semantic
of an RFB component. ier1 module models the input event
of reconfiguration ier1 ∈ RFBMode, which is associated to
idr1 that can be equal to one of the ECCslaves (AM, SAM,
DMP, DMB or BM). idr6 contains the fracture type, which
148
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Figure 8. BROS model with RFB.
Figure 9. GR-TNCES model of the whole system.
Figure 10. “RFBMode” internal components.
can be equal to IIB or IIC that involves single pin, IIA or
III that involves double pins. If the pinning is robotized (the
operation mode must be AM, SAM or DMP as detailed in [22])
then BROS must activate ECC1P in or ECC2P in according
(a) ECCcontroller of “RFBMode”
(b) ECCslaveAM
(c) Update data AM algorithm
Figure 11. RFBMode details.
to the fracture type, else ECCManualP will be executed. The
module idr1 has five output conditions, only one is true,
which corresponds to the selected ECCslave. ECCcontroller,
shown in Fig. 13a, activates the scenario to execute and
deactivates the others. At the end of the algorithm execution
(init0 and UpdatedataAM, UpdatedataSAM, UpdatedataDMP,
UpdatedataDMB or UpdatedataBM), the slave depicted in
Fig. 13b returns an output condition to the ECCcontroller
and an output event acki where i ∈ {1..5}. ECCcontroller1
generates three output events of reconfiguration oer1, oer2
149
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Figure 12. GR-TNCES model of RFBMode.
(a) ECCcontroller.
(b) ECCslave AM.
Figure 13. Some GR-TNCES modules of RFBMode.
and oer3 that activate respectively the controller of BBROS1,
BBROS2 and PBROS. Each output event of reconfiguration is
associated with an output data of reconfiguration: odr1, odr2
and odr3 that contain ECCslave in the next RFB. Therefore,
odr1 module activates ECCB, ECCU, ECCManualB or
ECCManualU module of BBROS1 and vice versa.
After transforming the RFB model automatically to GR-
TNCES, we have verified the functional correctness and safety
of individual RFBs as well as the entire system using PRISM.
It is used as a model checker that offers a probabilistic
model checking for run-time verification of adaptive systems
and analyses systems that exhibit random or probabilistic
behaviors.
ZiZo facilitates the verification process by converting the
GR-TNCES model to MDP model readable by PRISM. A
“.pm” file is generated that contains model descriptions written
in the PRISM language. CTL and PCTL are used to check
the following safety properties: (i) The deadlock problem
in each RFB and in the RFBs system, using the formula:
“E[F“deadlock”]”, which was proven to be false; (ii) BROS
never executes pinning and unblocking simultaneously thanks
to the following formula “P=?[F p=1& p=2]”, where “p=1” is
the unblocking and “p=2” is the pinning, which returns zero.
(iii) Let us attach a probability 0 to the event “reductionOK”
in BBROS1. What is the probability to change the mode
of pinning in PBROS from automatic to manual? Using the
formula “P =?[Fp = 11&(p = 12|p = 13|p = 14|p = 15)]”,
where p=11 (AM), p=12 (SAM), p=13 (DMP), p=14 (DMB)
and p=15 (BM), we proved that the probability of switching
from automatic pinning to manual is 0.9.
VII.
CONCLUSION AND FUTURE WORK
In order to enhance and simplify the system design and
the verification process of reconfigurable systems, we have
defined a new extension to IEC 61499 standard named RFB.
We introduce in our RFB the probability associated to each
reconfiguration scenario. We defined then a set of trans-
formation rules for the RFB design to GR-TNCES model,
implemented by ZiZo v3 that automates the transformation
and the verification with PRISM. We have found our approach
very helpful in the development process of reconfigurable dis-
tributed automation systems. In our future work, we will focus
on the code generation of RFB to deploy it in manufacturing.
We are also working on translating R-UML requirements to
RFB design to promote reusability.
References
[1]
V. Vyatkin, “IEC 61499 as enabler of distributed and intelligent automa-
tion: State-of-the-art review,” Industrial Informatics, IEEE Transactions
on, vol. 7, no. 4, pp. 768–781, 2011.
[2]
M. N. Rooker et al., “Zero downtime reconfiguration of distributed au-
tomation systems: The epsiloncedac approach.” in HoloMAS. Springer,
pp. 326–337, 2007.
[3]
A. Zoitl, G. Grabmair, F. Auinger, and C. Sunder, “Executing real-time
constrained control applications modelled in IEC 61499 with respect
to dynamic reconfiguration,” in Industrial Informatics, 2005. INDIN’05.
2005 3rd IEEE International Conference on. IEEE, pp. 62–67, 2005.
[4]
R. W. Brennan, M. Fletcher, and D. H. Norrie, “A holonic approach
to reconfiguring real-time distributed control systems,” in Multi-Agent
systems and applications II. Springer, pp. 323–335, 2001.
[5]
T. Kindberg, and A. Fox, System software for ubiquitous computing.
IEEE pervasive computing, vol. 1, no. 1, pp.70-81, 2002.
[6]
Y. Al-Safi and V. Vyatkin, “An ontology-based reconfiguration agent for
intelligent mechatronic systems,” in Holonic and Multi-Agent Systems
for Manufacturing. Springer, pp. 114–126, 2007.
[7]
M. Khalgui, O. Mosbahi, Z. Li, and H.-M. Hanisch, “Reconfiguration
of distributed embedded-control systems,” Mechatronics, IEEE/ASME
Transactions on, vol. 16, no. 4, pp. 684–694, 2011.
[8]
O. Khlifi, O. Mosbahi, M. Khalgui, and G. Frey, “GR-TNCES: new
extensions of R-TNCES for modelling and verification of flexible
systems under energy and memory constraints,” in ICSOFT-EA 2015
- Proceedings of the 10th International Conference on Software Engi-
neering and Applications, Colmar, Alsace, France, 20-22 July, 2015.,
pp. 373–380, 2015.
150
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

[9]
O. Khlifi, “ZiZo 2015,”
http://www.aut.unisaarland.de/forschung/forschung-zizo-tool-khlifi/, [ac-
cessed: Jun,2016].
[10]
M. Kwiatkowska, G. Norman, and D. Parker, “Prism: Probabilistic sym-
bolic model checker,” in Computer performance evaluation: modelling
techniques and tools. Springer, pp. 200–204, 2002.
[11]
Holobloc Inc., FBDK 2.5 - The Function Block Development Kit,
http://www.holobloc.com/fbdk2/, [accessed: September,2016].
[12]
ICS Triplex ISaGRAF., ISaGRAF Workbench, http://www.isagraf.com,
[accessed: September,2016].
[13]
NxtControl.,
nxtSTUDIO
-
Engineering
software
for
all
tasks,
http://www.nxtcontrol.com/en/engineering/, [accessed: September,2016].
[14]
V. Vyatkin and H.-M. Hanisch, “Verification of distributed control sys-
tems in intelligent manufacturing,” Journal of Intelligent Manufacturing,
vol. 14, no. 1, pp. 123–136, 2003.
[15]
C. Pang and V. Vyatkin, “Automatic model generation of IEC 61499
function block using net condition/event systems,” Industrial Informatics,
2008. INDIN 2008. 6th IEEE International Conference on, pp. 1133–
1138, 2008.
[16]
C. Gerber, I. Ivanova-Vasileva, and H.-M. Hanisch, “Formal modelling
of IEC 61499 function blocks with integer-valued data types,” Control
and cybernetics, vol. 39, no. 1, pp. 197–231, 2010.
[17]
C. Suender, V. Vyatkin, and A. Zoitl, “Formal validation of down-
timeless system evolution in embedded automation controllers,” ACM
Transactions on Embedded Control Systems, vol. 12, no. 17, pp. 17:1–
17:17, 2013.
[18]
J. Ezpeleta, J. M. Colom, and J. Martinez, “A petri net based deadlock
prevention policy for flexible manufacturing systems,” IEEE transactions
on robotics and automation, vol. 11, no. 2, pp. 173–184, 1995.
[19]
J. Zhang, M. Khalgui, Z. Li, O. Mosbahi, and A. M. Al-Ahmari,
“R-tnces: a novel formalism for reconfigurable discrete event control
systems,” Systems, Man, and Cybernetics: Systems, IEEE Transactions
on, vol. 43, no. 4, pp. 757–772, 2013.
[20]
M.
O.
B.
Salem,
“ZiZo:
a
tool
to
model,
simulate
and
verify
reconfigurable
real
time
control
systems,”
http://www.aut.unisaarland.de/forschung/forschung-zizo-tool-bensalem/,
[accessed: Jun, 2016].
[21]
V. Forejt, M. Kwiatkowska, D. Parker, H. Qu, and M. Ujma, “Incremen-
tal runtime verification of probabilistic systems,” in Runtime verification.
Springer, pp. 314–319, 2012.
[22]
M. O. B. Salem, O. Mosbahi, M. Khalgui, and G. Frey, “Zizo: Model-
ing, simulation and verification of reconfigurable real-time control tasks
sharing adaptive resources - application to the medical project BROS,”
in HEALTHINF 2015 - Proceedings of the International Conference on
Health Informatics, Lisbon, Portugal, 12-15 January, 2015, pp. 20–31,
2015.
[23]
M.
O.
B.
Salem,
“BROS:
a
robotic
platform
for
the
treatment
of
the
supracondylar
humerus
fracture,”
http://www.aut.unisaarland.de/forschung/forschung-bros-platform/,
[accessed: Jun, 2016].
151
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

