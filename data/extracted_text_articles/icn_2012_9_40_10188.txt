A Redundancy Information Protocol for P2P Networks in Ubiquitous Computing
Environments: Design and Implementation
Rafael Dias Ara´ujo, Hiran Nonato Macedo Ferreira, Pedro Frosi Rosa, Renan Gonc¸alves Cattelan
Universidade Federal de Uberlˆandia
Uberlˆandia, MG, Brazil
{rdaraujox,hirannonato}@gmail.com, {frosi,renan}@facom.ufu.br
Abstract—The ubiquitous computing vision brings high com-
putational and communication demands. In this paper, we
propose a high availability protocol for information replica-
tion in ubiquitous computing environments. Running at the
application layer, on top of a P2P overlay network based on
JXTA, our protocol allows the transfer of multimedia contents
automatically generated by multimedia capture systems. We
formalize the characteristics of the protocol and present its
design rules and procedures.
Keywords-Redundancy protocol; P2P networks; ubiquitous
computing; multimedia content sharing.
I. INTRODUCTION
The concept of ubiquitous computing [15] has been
widely used nowadays. In particular, automated systems that
allow the capture of live experiences are a recurring research
theme [1]. Classrooms instrumented with electronic white-
boards, microphones and video cameras produce multimedia
artifacts that reconstruct the captured experience for future
use and review. In order to reach true ubiquity, the produced
contents should be available to users in a transparent way,
i.e., independent of their physical location.
In instrumented settings for multimedia capture, we face
the problem of high computational and communication
demands [8]. Traditional implementations reported in the
literature have scalability problems caused by centralized
entities that become the system bottlenecks [3]. Satya-
narayanan [10] notes that issues like remote access, high
availability, power management, mobile information access
have increased and, in parallel, ubiquitous and pervasive
computing take advantage of distributed and mobile com-
puting. Thereby, systems must provide high availability [13]
to ensure the transparency requirements. The main aspect of
high availability is the redundancy of information that must
be transmitted to different points of the network by reliable
communication channels.
To solve these issues, we developed a peer-to-peer (P2P)
architecture for the storage and distribution of captured
multimedia content. P2P networks have the potential to make
the process of sharing information much easier. Studies
show P2P are responsible for more than 50% of the overall
Internet trafﬁc in some regions [12]. Another key advantage
of P2P networks is the direct availability of resources to
the network participants, without the need for any central
coordination by servers or stable hosts [11]. Furthermore,
its robustness is increased because it removes the single
failure point commonly observed in a client-server based
solution [7].
In order to contribute to the proper capture and storage of
multimedia content, it becomes indispensable the creation of
a protocol that ensures communication and interoperability
features for heterogeneous devices. Thus, in this paper,
we propose a P2P based protocol that aims at minimizing
the aforementioned problems of large data transfers and
ensures the availability of the information captured from the
environment. We based our approach in the general idea of
cooperation among user devices joining a P2P network.
The remaining of the paper is structured as follows: in
Section II, we present a real multimedia capture scenario
which inspired the design of our protocol; in Section III,
we detail the abstraction layer deﬁned for the protocol;
in Section IV, we describe our protocol speciﬁcation and
design, i.e., its environment, encoding, vocabulary, services
and procedure rules; in Section V, we present the imple-
mentation details behind our approach; in Section VI, we
present related works; and ﬁnally, in Section VII, we make
our ﬁnal remarks.
II. CLASSROOM INFORMATION CAPTURE
Consider classrooms equipped with electronic devices
(e.g., mobile phones, notebooks, tablets, electronic white-
boards, video cameras, etc.) and responsible for capturing
multimedia raw data from the environment. The resulting
captured data, in the form of multimedia artifacts, may be
useful both for instructors that need to reuse them later and
for students to review what was presented.
Take, for example, iClass [9], an open-source capture plat-
form for ubiquitous learning environments. iClass comprises
a federation of capture clients and an access servers. Capture
clients are software components for a particular capture
device and generates a corresponding multimedia artifact
(e.g., an audio capture component monitors a microphone
and generates audio streams). Access servers are daemon
applications which collects multimedia artifacts sent by
capture clients and merges then into a single, synchronized
215
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

document. Users have access to those documents by using
an integrated Webserver. iClass infrastructure is thus pre-
dominant based on a client-server approach: clients produce
content which is sent to a server for user access.
iClass presents characteristics that provide some interest-
ing insights for our research context:
• The captured data have widely varying formats such as
video, audio, image and text.
• Data reaches large volumes over time, thus requiring
scalable and high availability software and hardware
infrastructures.
• Moreover, it is important that storage do not be cen-
tralized and be made in a reliable way to protect users’
personal annotations.
• Finally, it is also worth to observe that, once created and
stored, such data artifacts usually do not change. This
characteristic allows a simpler data replication policy
and reduces consistency problems.
With these characteristics in mind, we extended iClass
original architecture by adapting it to the P2P paradigm. We
conceived the concept of capture agents, software compo-
nents with well deﬁned interfaces that capture information
and distribute it not through a single, a priori known server,
but through an access service run by cooperative peers on a
P2P overlay.
III. CONTENT ABSTRACTION LAYER
In order to abstract the content transferring services, we
created a layer using the widely available JXTA open-source
P2P protocol [14]. The main goals of JXTA are: operating
system independence, language independence and providing
services and infrastructure for P2P applications.
We use JXTA services to make content transferring trans-
parent to the application. Such approach creates an abstrac-
tion capable of aggregating and providing many services for
content storage and synchronization. The proposed layer was
named CAL (Content Abstraction Layer).
Thus, capture peers implement the JXTA protocol to
communicate among themselves and intermediate peers may
be used to route messages to external peers without direct
connection. For this, there is a concept that should be
explored: peer grouping. In JXTA, a peer group is deﬁned
as a collection of peers that have agreed upon a common set
of services. Each peer group is identiﬁed by a unique peer
group ID and each one can determine its own membership
policy from open to highly secure and protected (credentials
are required to join). Peers may belong to more than one peer
group simultaneously.
When devices ﬁnish a capture session, they can search for
an available storage service running on some peer group by
using the discovery service. Devices need to join the network
only when they wish to transfer content, i.e., they can work
ofﬂine while capturing content.
IV. PROTOCOL SPECIFICATION AND DESIGN
The ﬁve essential protocol elements (environment, vo-
cabulary, encoding, services and procedure rules) [4] are
described in this session. The environment takes into account
the physical and logical characteristics where the protocol
is used, as architecture, computer’s organization, etc. The
vocabulary is the set of events (name of messages) used to
specify the state transitions of protocol and the encoding the
format of each message. The service is an abstract element
that deﬁnes a feature and its behavior is deﬁned by procedure
rules (automaton).
CAL was designed to be used over P2P networks and
each peer can perform both roles of producer or consumer.
The producer is the one that captures the real world data
through user devices. The consumer is the one that stores
the data received from the producer and also shares them
with other consumers. Thus, peers can share their contents
to provide redundancy and high availability on the network.
Another aspect of this layer that should be considered
is the connection-oriented networking, i.e., the upper layer
must ﬁrst establish a communication session with the other
node and, after that, it becomes capable to deliver data in
the same order it was sent [4].
After these considerations about the environment, we for-
malize the protocol vocabulary, which deﬁnes the semantic
of messages used in communication [4]. Our protocol’s set
of messages consists of:
• LIST STATUS REQUEST: message sent to a peer to
request a list of its contents. This message can be sent
only by consumer peers. This is the ﬁrst step for two
peers to synchronize content between themselves;
• SEND SEG REQUEST: message used to send a con-
tent segment. When the content to be sent is to large,
then they have to be broken into smaller pieces before
being sent;
• SEND SEG RESPONSE-: this message represents a
SEND SEG REQUEST unacknowledgement. It is sent
when the last SEND SEG REQUEST was not recog-
nized. Note that the positive SEND SEG RESPONSE
is not adopted because this message is used by a service
with negative acknowledgment [4];
• FT GET REQUEST: message used to request a spe-
ciﬁc content using its identiﬁer obtained by calling the
list status service. This message can be sent only by
the consumer;
• FT PUT REQUEST: message used to send a content
that was just created. This message can be sent only by
the producer;
• SEND MSG RESPONSE+: this message represents an
acknowledgment. It is used to indicate that the last
SEND MSG RESPONSE primitive was properly rec-
ognized. This message represents the positive response
for the JXTA SEND MSG service;
216
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

• SEND MSG RESPONSE-: this message represents an
unacknowledgement. It is used to indicate that the last
SEND MSG RESPONSE primitive was not properly
recognized.
These messages are encoded by a character-oriented
method and have the same format and comprising header,
body and trailer.
In the message header, there is a ﬂag named MORE BIT
that is used to indicate whether there are more segments
to be transferred. This situation can occur when a consumer
wants to synchronize to another and the second has so many
ﬁles that it exceeds the maximum primitive’s length, or when
a producer wants to send a content so large that it need to
be broken into smaller pieces. The SERVICE ﬁeld represents
the called service’s name that is encoded in a binary number.
As CAL has seven available services, then three bits are
enough for this ﬁeld in order to represent all services (23 =
8). Finally, there is a ﬁeld to store the length of the current
content and, hence, the data ﬁeld can be variable. The trailer
stores the data hash code for further error checking.
Now, we can deﬁne the services provided by CAL and
present its behavior. As previously mentioned, the layer
contains eight services: publish, start session, end session,
list status, ft get, ft put, send seg and reject.
The ﬁrst one, publish, is used to make a new consumer
peer available on the network. It means the new peer
wishes to provide its disk space to store content for other
peers (acting as a server). The peer uses this service to
become available for connection to other peers. This is not
a conﬁrmed service, i.e., the peer sends this primitive and
do not expect a conﬁrmation.
The start session service represents the connection es-
tablishment phase from a peer to another. Regardless of
the role played by the peer in the network, this phase is
mandatory. Fig. 1 shows the automaton for this service.
The application that uses CAL requires a connection by
calling the service mentioned above. This service starts the
connection establishment process. The ﬁrst action is to ﬁnd
some available peer in the network. For this, CAL uses
the discovery service from JXTA platform and waits the
discovery conﬁrmation with the needed peer’s information
to allow the communication. If timeout is reached, it retries
n times, where n is a previously deﬁned constant. When the
service receives a positive discovery conﬁrmation, it calls
the connect service from JXTA and waits a conﬁrmation,
which can be positive or negative. In the ﬁrst case, i.e.,
if it receives a positive connect conﬁrmation, it goes to
the CONNECTED state. Otherwise, or if timeout, it tries
to discover and to connect to other peer during the pre-
established number of attempts.
As the previous one, the end session is also mandatory
and represents the disconnection phase. When the applica-
tion wants to close the connection with the other peer, it
calls this service and, then, CAL instantiates the disconnect
Figure 1.
start session service behavior
service from JTXA, returns to IDLE state and become ready
to establish a new connection to another peer. This behavior
is shown in Fig. 2.
Figure 2.
end session service behavior
The list status service is available only to the consumer
peer. This service is responsible for asking the other con-
nected peer what contents it has stored. As a result, the appli-
cation obtains a list of contents identiﬁers. Once connected,
the application sends a ls request (ls is an abbreviation for
list status) and CAL sends a send msg request with the
ls request inside its data ﬁeld. CAL waits for the conﬁrma-
tion that can be positive or negative. If the incoming message
is a negative conﬁrmation, it returns to CONNECTED state.
If the incoming message is a positive conﬁrmation, CAL
sends a send msg response+ to conﬁrm the message. If the
received message has any error, the send msg response- is
sent to refuse the message. This conﬁrmation message is sent
inside the send msg request data ﬁeld. After this message,
CAL becomes ready to receive the list. There are cases that
the peer has so many ﬁles that the list must be partitioned
in segments to be sent as small pieces, as shown in Fig. 3.
In this case, each segment is sent with the MORE BIT ﬂag
equals to 1 until there is no more segments to be sent. This
automaton also considers the timeout while waiting for the
ls conﬁrmation message, while waiting for a segment or
while receiving a segment.
For clarity, Fig. 4 shows the temporal order diagram for
217
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

Figure 3.
list status service behavior
the list status service. One can observe that the incoming
messages at CAL are transmitted inside the data ﬁeld of
the send msg primitive of JXTA. This behavior can also be
observed in other services, once they were designed to have
grater abstraction from those provided by JXTA.
Figure 4.
Temporal order diagram for list status
The ft get service is also only available to the consumer
peer. It is used to request a speciﬁc content transfer, using
the identiﬁers that were obtained by calling the list status
service. Fig. 5 shows the ft get service behavior. When
the application is already connected, it can request the
transfer of some content by sending the ft get request
primitive and, then, CAL sends a ft get req within the
send msg request primitive data ﬁeld. If it receives a neg-
ative ft get conﬁrmation, it returns to the CONNECTED
state, otherwise it sends a send msg response+ message to
conﬁrm the receipt of the primitive and indicates that it is
ready to receive the segments of the required content. Thus,
the segments are sent until the whole content is transferred.
Note the ﬂag MORE BIT to indicate that there are more
segments to be sent. When the transfer is ﬁnished, CAL
sends a conﬁrmation message to the application indicating
the content transferring is complete.
The ft put service is available only to the producer peer.
Figure 5.
ft get service behavior
This service is used to send contents to be stored in other
peers (those who are consumers). When the application is
already connected, it sends a ft put request message to CAL
and waits conﬁrmation from the consumer. If CAL receives
a negative conﬁrmation, it returns to the CONNECTED state
and indicates to the application that the transfer has failed.
This happens to let the decision of trying to resend the
content to the same peer or connect to another peer as a
responsibility of the upper layer. If the received message
is a positive conﬁrmation, it becomes ready to receive the
content segments. Once ﬁnished the segments transferring
(i.e. MORE BIT = 0), CAL goes to the CONNECTED state
and sends a positive ft put conﬁrmation message to the
application, indicating that the content upload was done.
This service automaton is shown in Fig. 6.
Figure 6.
ft put service behavior
The send seg is available to both producer and consumer
peers. It is responsible for sending segments of contents.
In this scenario of multimedia content sharing, the data are
218
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

usually too large to be sent in a single transfer. So, data
must be broken and sent in small segments, as indicated
by the MORE BIT ﬂag. Its behavior is shown inside the
automata of the previously presented list status, ft get and
ft put services.
An interesting behavior observed in list status, ft get
and ft put services refers to the message conﬁrmation
technique used while sending the content segments. We
opted for a negative acknowledgment approach, which
means that CAL do not wait for a positive conﬁrma-
tion for each send seg request. Instead, CAL receives a
send seg response- when an error is found in the transmitted
message.
Finally, the last service named reject is also available to
both producer and consumer peers. CAL can receive faulty
primitives or worse, it may receive some primitive whose
service should not be recognized by the peer in question,
i.e., those messages that are only recognized by peers who
play a particular role. In these cases, this service must be
used to refuse the mistaken incoming primitives. Eventually,
these errors may cause side effects in CAL because there
could be burst errors that the link layer is not able to handle
in consequence of false positives. The service behavior
is very simple. In every state of all services mentioned
before, the layer may receive mistaken primitives from the
application. Then, if it happens, CAL sends a message with
the reject service and goes back to the same state and waits
another message. Therefore, it ensures the consistency of
communication between the application and CAL.
V. IMPLEMENTATION DETAILS
Our initial implementation was written in Java. One of
the main reasons for this choice is due to its portability and
wide use by the community. In this section, we describe the
prototype implementation of our P2P protocol and discuss
several implementation decisions that were taken during its
and design and development.
As previously mentioned, CAL sits between the JXTA
platform and the P2P application. Our implementation was
proposed this way in order to give full autonomy for the
P2P application to create its own content transfer policies.
Thus, the transferring information rules are not deﬁned by
CAL but by the P2P application.
Each service in CAL (publish, start session, end session,
list status, ft get, ft put, send seg and reject) was imple-
mented through a well-deﬁned interface, allowing applica-
tions to use its functionality with the least possible effort.
The implementation details of each service are shown below.
publish: This interface is invoked to provide a storage
service. It uses native JXTA primitives to publish an adver-
tisement. Advertisements are XML documents that describe
network resources [14]. Our publish interface consists of
only one method named publish() that receives the
provided service’s name.
start session: This interface is used to establish a connec-
tion to a storage service available on the network. Among
the various available JXTA services, this interface uses
discovery and connect. One of the greatest potential
abstractions of our protocol is achieved through this service,
because the network search happens completely transpar-
ently to the application. It is optional to the peer querying
the network to inform or not the storage service it wants to
connect to. If the connection is successfully established, a
JxtaBiDiPipe is created between the two peers to perform
the various connections about to come. The JxtaBiDiPipe
uses the core JXTA uni-directional pipes (InputPipe and
OutputPipe) to simulate bi-directional pipes in the J2SE
binding [14].
end session: This interface is responsible for ﬁnalizing a
connection with a storage service. The end_session()
method is responsible for disconnecting the pipe created in
start_session() and releasing the peer to create new
connections or simply cease to exist.
list status: The consumer peer uses this interface to know
the contents of a peer storage service. The communica-
tion between the peers happens through the messaging
service provided by JXTA, which is implemented by the
StringMessageElement() method. The main meth-
ods used for this service are: getMessageElement(),
addMessageElement() and sendMessage(). In this
interface the data are trafﬁcked through content segments.
A MORE BIT ﬂag is used to indicate if there are more
threads for each request. After all segments are received,
the information is collated and reported to the application
as previously requested.
ft get: This interface is called by a consumer peer that
wishes some content that is unavailable in its repository.
Content is sent through the network in segments, thus
employing the same methods used by the list_status
service. Among the various methods used by this interface,
we can mention the check_free_space(), which is
used to check whether there is enough free disk space to
receive such ﬁle.
ft put: This interface is used by producers to send content
to a storage service. As in ls status and ft get, contents
are sent into segments in the network, using always the
MORE BIT ﬂag to identify the last segment.
send seg: This interface is responsible for segmenting
the content and sends it over the network. As previously
mentioned, it is used by various services of this protocol,
as: list_status, ft_get and ft_put.
reject: This interface is called whenever a new packet is
received. it is used to inform the sender that the received
package has some error and then it was rejected. This
interface, as well as some mentioned above, also uses the
messaging services provided by JXTA to send it inside its
data ﬁeld.
219
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

VI. RELATED WORK
The use of P2P platforms in ubiquitous computing sys-
tems is not a completely new idea. For example, eComP [6]
focuses on designing P2P networks for everyday objects.
eComP is a decentralized XML-based messaging system that
abstracts the underlying network and communication pro-
tocol and provides services through well-deﬁned interfaces.
Similar to our JXTA-based approach, the underlying network
infrastructure requires no ﬁxed infrastructure or the support
of any other entity except computing peers. However, a user-
deﬁned ID (like a familiar, personal or rational textual name)
is deemed necessary to identify resources.
Hong et al. [5] developed an effective scheme to manage
multimedia sharing based on specially designed proﬁles and
a virtual community. Their multimedia sharing layer is re-
sponsible for sharing multimedia contents, and is constructed
as a specially designed scheme based on locality. They
focuses on an effective community construction scheme
performed by community construction layer.
Barolli and Xhafa present JXTA-Overlay [2], a JXTA-
based P2P middleware for distributed and collaborative sys-
tems. JXTA-Overlay allows the integration of end devices,
such as sensors and personal/mobile computers, providing
transparency and security for sharing, contributing and con-
trolling available resources. JXTA-Overlay comprise a set
of primitive operations: peer discovery, resource allocation,
ﬁle/data sharing, discovery and transmission, instant com-
munication, among other services. Such primitive operations
can be exchanged between connected peers and support dif-
ferent types of applications related to collaborative activities.
Besides presenting a similar layered structure, differently
from JXTA-Overlay, where the application must know the
identity of peers to which it desires to connect, our protocol
does not require any a priori knowledgement of peer identi-
ties. In our proposal, CAL provides such network abstraction
and still ensures the reliability and security properties offered
by JXTA during content transfers.
VII. CONCLUSION AND FUTURE WORK
We presented CAL, a P2P-based protocol designed to
transfer multimedia information captured by different types
of devices installed in instrumented environments. As a
result, devices that produce multimedia contents do not need
to have any previous knowledgement of the network to be
able to transfer contents to other devices. CAL creates ab-
stractions for discovering peers offering storage capabilities
with safety and reliability properties.
Complementing our approach and as future work, we
are currently developing an effective access mechanism for
retrieval of the multimedia information stored in our plat-
form. Its query approach is based on contextual preferences
that uses information available about users, devices and
the environment in order to automatically recommend and
personalize returned content.
ACKNOWLEDGMENTS
The authors would like to thank the Brazilian Research
Agencies CNPq and FAPEMIG for supporting this work.
REFERENCES
[1] G. D. Abowd and E. D. Mynatt.
Charting past, present,
and future research in ubiquitous computing.
ACM Trans.
Comput.-Hum. Interact., 7:29–58, 2000.
[2] L. Barolli and F. Xhafa. Jxta-overlay: A p2p platform for
distributed, collaborative, and ubiquitous computing. IEEE
Trans. on Industrial Electronics, 58(6):2163–2172, 2011.
[3] R. Hasan, Z. Anwar, W. Yurcik, L. Brumbaugh, and R. Camp-
bell.
A survey of peer-to-peer storage techniques for dis-
tributed ﬁle systems. In Proc. of the Intl. Conf. on Information
Technology: Coding and Computing, pages 205–213, 2005.
[4] G. J. Holzmann. Design and validation of computer protocols.
Prentice-Hall, Inc., Upper Saddle River, NJ, USA, 1991.
[5] C.-P. Hong, E.-H. Lee, and S.-D. Kim. An efﬁcient scheme to
construct virtual community for multimedia content sharing
based on proﬁle in a ubiquitous computing environment. In
Proc. of the Intl. Joint Conf. on INC, IMS and IDC, pages
1271–1276, 2009.
[6] A. Kameas, I. Mavrommati, D. Ringas, and P. Wason. ecomp:
An architecture that supports p2p networking among ubiqui-
tous computing devices. In Proc. of the Intl. Conf. on Peer-
to-Peer Computing, pages 57–, 2002.
[7] E. K. Lua, J. Crowcroft, M. Pias, R. Sharma, and S. Lim.
A survey and comparison of peer-to-peer overlay network
schemes. Commun. Surveys Tuts., 7(2):72–93, 2005.
[8] F. Perich, A. Joshi, T. Finin, and Y. Yesha.
On data
management in pervasive computing environments.
IEEE
Trans. on Knowl. and Data Eng., 16:621–634, 2004.
[9] M. Pimentel, L. A. Baldochi Jr., and R. G. Cattelan. Proto-
typing applications to document human experiences. IEEE
Pervasive Computing, 6:93–100, 2007.
[10] M. Satyanarayanan. Pervasive computing: vision and chal-
lenges. IEEE Pers. Commun., 8(4):10 –17, 2001.
[11] R. Schollmeier. A deﬁnition of peer-to-peer networking for
the classiﬁcation of peer-to-peer architectures and applica-
tions. In Proc. of the Intl. Conf. on Peer-to-Peer Computing,
pages 101–102, 2001.
[12] H. Schulze and K. Mochalski.
Internet study 2008/2009,
2009.
http://www.ipoque.com/en/resources/internet-studies.
Retrieved: Dec. 2011.
[13] Sun BluePrints Online. High availability fundamentals, 2000.
http://www.sun.com.br/blueprints. Retrieved: Dec. 2011.
[14] Sun Microsystems, Inc. Project JXTA v2.5: Java program-
mer’s guide, 2007.
[15] M. Weiser.
The computer for the 21st century.
Scientiﬁc
American, 265(3):94–104, 1991.
220
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

