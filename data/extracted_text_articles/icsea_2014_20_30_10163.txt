A Formal Model of Use-Cases and Its Application in Generating
A Hierarchical Class-Structure
Sukhamay Kundu
Department of Computer Science
Louisiana State University, Baton Rouge, LA 70803
Email: kundu@csc.lsu.edu
Arnab Ganguly
Department of Computer Science
Louisiana State University, Baton Rouge, LA 70803
Email: agangu4@lsu.edu
Abstract—Creating an object-oriented design from user require-
ments, given as a set of use-cases, means deriving a detailed
class structure that can support an implementation of those
requirements. We introduce here the Augmented Finite-State
(AFS) model for a set of use-cases. An AFS model of a single use-
case U incorporates the inputs, outputs, and operations for each
interaction in U, including the ”internal” dataﬂows among those
interactions. The AFS model for a set of use-cases U combines
the AFS models of individual use-cases Uj ∈ U to account for
common interactions among Uj’s and the control-ﬂows among
Uj’s. After we decompose the combined model into a unique set
of disjoint Maximal Linear Segments (MLSs), we derive one class
from each MLS and ﬁnally create the class-hierarchy based on
the next-relationship among the MLSs. One advantage of our
approach over those based on the concept-analysis is that the
AFS model gives a simple controller for the call-sequences of the
class-methods corresponding to each Uj.
Keywords–Augmented ﬁnite-state model; class hierarchy; object-
oriented design; refactoring; use-case model.
I.
INTRODUCTION
Software design is an essential part of any software de-
velopment effort. For an object-oriented software, the design
consists of the classes (their attributes, methods, and method-
parameters) and the relationships among those classes, which
includes the class-hierarchy and other associations. The design
gives a global view of the functionalities and structure of the
software, and plays a critical role in understanding, implemen-
tation, and analysis of the software.
Semi-automated generation of UML-models and class-
diagrams from natural language description of requirements
are discussed in [1][2]. Automated generation of UML-models
are discussed in [3][4]. These works are based on Natural
Language Processing, and rely on use-cases deﬁned using a
semi-formal syntaxes and semantics. Cockburn [5] argued that
there is no formal syntax or semantics for writing use-cases.
Roussev [6] uses an informal notion of ”balance” of objects
involved in a use-case, and assumes the use-cases are given in
terms of pre-conditions, post-conditions and invariants on the
objects involved in the use-cases. The identiﬁcation of objects
is a key missing step in [6]; also, the notion of ”balance” of
objects has a basic ﬂaw because ”information” do not behave
like the physical quantities force, energy, and mass, and we
don’t have a principle like the ”conservation of energy” for
”information”.
Modeling means choosing a proper abstraction and a
suitable representation of it to facilitate its use. Finite-state
models and interaction-diagrams are often used in explaining
a class-structure design [7]. We use a reverse approach: we
ﬁrst create an Augmented Finite-State (AFS) model of the use-
cases (interactions) that describe the requirements and then we
build the classes and their relationships from this model. This
gives a more systematic and precise (semi-formal) technique
compared to the other methods in the literature. A class design
involves identiﬁcation and grouping of operations and their
supporting variables (inputs and outputs of the operations,
and other intermediate stored data to avoid recomputation)
in a way that minimizes the information overload. The AFS
model facilitates both of these steps by capturing the essential
operational details of the system’s functional requirement. The
identiﬁcation of operational details for each use-case plays a
key role in our approach. The method presented here can be
regarded as a reﬁnement of that in Kundu [8].
Many models are used in software engineering as effective
tools. For example, Finite-state machines are used by Chow
[9] for automated software testing. Our AFS model has some
resemblance to X-machines [10]. In X-machines, a transition
between two states is labeled by an operation whereas in AFS
the labels are constraints; the dataﬂow items in AFS model
correspond to the concept of ”memory” in X-machines.
In Section II, we give the detailed formal deﬁnition of a
use-case, and Section III deﬁnes the AFS model of a set of
use-cases Sections IV and V explain our AFS-based approach
for generating a class-hierarchy using a simpliﬁed set of use-
cases for a bank’s ATM machine. Section VI provides a brief
conclusion.
II.
A FORMAL DEFINITION OF USE-CASE
Jacobson [11] deﬁnes a use-case as a sequence (chain)
of interactions U = ⟨t1, t2, · · · , tn⟩, which provides the user
a useful service, i.e., corresponds to a complete high-level
functional requirement. If U1 and U2 are two use-cases, then
clearly U1U2 is also a use-case. Henceforth, a use-case U will
mean an elementary use-case, which cannot be decomposed
into a sequence of two or more disjoint smaller use-cases.
A. Interaction tj
Formally, an interaction tj = (inj, opj, outj) is a triplet,
where inj = in(tj) is a set of input data-items, opj = op(tj)
is an operation, and outj = out(tj) is a set of output data-items.
551
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances
.

The inputs inj consist of two disjoint parts: user-inputs inu
j
and other ”external” (with respect to U) inputs ine
j. The term
”interaction” means inu
j ̸= ∅; however, one possible exception
to this is that the last interaction tn in U may have inu
n = ∅
(cf. Theorem 1). An operation opj may have multiple parts and
a user may provide different parts of inu
j at different stages of
opj, with inj and outj interleaved. The inputs to opj may also
include zero or more additional ”internal” data-items di that
are generated by previous opi’s, i < j and ti ∈ U. We refer to
such di’s as dataﬂows. The outputs outj also consists of two
parts: user-outputs outu
j and external-outputs oute
j; because
parts of outu
j maybe saved for use in other use-cases and hence
included in oute
j, we may have outu
j ∩ oute
j ̸= ∅. Clearly,
inj = inu
j ∪ ine
j and outj = outu
j ∪ oute
j. Henceforth, we use
tj and opj interchangeably when no confusion is likely. Figure
1 shows the structure of an interaction tj. We can regard opj
as a function of inj and zero or more di, i < j, i.e., in(opj) =
S
i≤j ini. In contrast, in(tj) = inj and thus tj is not exactly
the same as opj. The dataﬂow dj is not determined by opj but
by tk, k > j in U; also, dj need not be a subset of outj.
t j
inu
j
ine
j
d j1
⋅⋅⋅
d j p
"internal" dataﬂow inputs d j1, d j2, ⋅⋅⋅, d j p
( j1 < j2 ⋅⋅⋅ < j p < j) for op j
outu
j
oute
j
d j
⋅⋅⋅
d j
d j generated by op j to zero or more opk, k > j
Figure 1. Structure of an interaction tj.
B. Use-Case U
We formally deﬁne a use-case as a sequence of interactions
U = ⟨t1, t2, · · · , tn⟩ with the properties (1)-(4) below.
(1) inu
i ∩ inu
j
= ∅ for i ̸= j. A user should not be
required to provide the same input more than once in a use-
case. If opj, j > i, requires parts of the user-input inu
i , then
opi may include those parts of inu
i in the internal dataﬂow
item di generated by opi. However, outu
i ∩ outu
j may be non-
empty because parts of outu
i might be repeated in outu
j (e.g., a
”conﬁrm operation” prompt to the user for a critical operation
like deleting a ﬁle). We assume each inj is as small as possible,
i.e., no unnecessary ”early” inputs and all of inj is used in opj.
Likewise, we assume each outj is as large as possible, i.e., no
”late” outputs. For efﬁcient input/output operations involving
ﬁles and databases, one may want to maximize each chunk of
information exchange but for modeling purpose these ”early”
and ”late” viewpoints are more logical.
(2) ine
i ∩ ine
j = ∅ = oute
i ∩ oute
if opj, j > i, requires parts of inej for i ̸= j. As before,
i, then opi may include
those parts of ine
i in di. This is desirable if accessing the
external input data-items are computationally expensive. We
may also include parts of outi in di to avoid recomputing
them in opj, j > i. (A non-empty oute
i ∩ oute
j would mean
parts of oute
i is overwritten by opj, j > i, based on additional
information available at opj.) Because opj does not use any
ink or dk, k > j, there is no cyclic dependency among opj’s.
(3) di ∩ dj = ∅ for i ̸= j. Any part of di can be made
available to each opj, j > i, as needed.
(4) Each (tj, tj+1)-pair has an associated transition-
condition cj,j+1 which needs to be satisﬁed after opj is
completed in order for opj+1 to start; cj,j+1 = true means
the condition is trivially satisﬁed. The condition cj,j+1 does
not depend on ink, k > j, and may depend only on parts
of in(opj). All non-trivial conditions ci,i+1, i ≤ j, contribute
directly or indirectly to the pre-condition for opj+1. We assume
for now that cj,j+1 is evaluated by opj.
We write Iu
U = S inu
j and Ie
U = S ine
are taken over all j, and ﬁnally IU = Iu j, where the unions
U ∪ Ie
U. Similarly, we
write Ou
U = S outu
j , Oe
U = S oute
j, OU = Ou
U ∪ Oe
U, DU =
S dj, and CU = {cj,j+1 : 1 ≤ j < n}. The entities in IU,
OU, and DU are the names of data-items and not any speciﬁc
values for them. (An instance of a use-case U, with concrete
values for the data-items in IU and hence concrete values for
the data-items in DU ∪ OU, is called a scenario.)
If the use-case U ′ is used after the use-case U and we need
to use parts of inu
j at tj ∈ U as parts of inu
j′ at tj′ ∈ U ′, then
we can include those parts of inu
j into oute
j and those parts
of oute
j can now become a part of ine
j′. This avoids having to
provide the common parts of inu
j and inu
j′ more than once.
A proper choice of the individual interactions tj in mod-
eling a use-case U is a non-trivial task. A simpler or smaller
tj can help to reduce errors in determining in(opj), out(opj),
and cj,j+1, but it can also introduce unnecessary details in
the design of a class-structure for U. A complex or larger tj
can, on the other hand, prevent sharing interactions between
different use-cases. These issues are described next.
C. Merging Interactions
If we merge tj, tj+1 ∈ U into a single interaction tj,j+1,
then we have inu
j,j+1 = inu
j ∪ inu
j+1 and similarly for ine
j,j+1,
outu
j,j+1, and oute
j,j+1. In general, dj,j+1 ⊆ dj ∪ dj+1, with
tj,j+1 hiding dataﬂows from tj to tj+1 (making them internal
to opj,j+1); in the extreme case, we may have dj,j+1 = dj+1.
Also, opj,j+1 = opj◦opj+1, the composition (roughly speaking
in view of cj,j+1) of opj and opj+1, in that order. The new in-
teraction sequence ⟨t1, t2, · · · , tj−1, tj,j+1, tj+2, · · · , tn⟩ has
less information about opj,j+1 (equivalently, tj,j+1) because
we know less about which parts of inj,j+1 are used by which
parts of opj,j+1 to produce which parts of outj,j+1 and dj,j+1.
There is, however, no change in Iu
U, Ie
U, Ou
U, and Oe
U.
Except for the loss of some information as noted above, it
is safe to merge tj and tj+1 when cj,j+1 = true. In this case,
each use-case U ′ containing tj will also contain tj+1 and thus
we can replace tj and tj+1 by tj,j+1 in each U ′.
The merging of tj and tj+1 has no impact on the condition
from tj−1 to tj,j+1, i.e., cj−1,(j,j+1) = cj−1,j, which will
be evaluated by opj−1. However, determining the condition
c(j,j+1),j+2 from tj,j+1 to tj+2 might pose a problem as shown
below. Consider the situation on the left-side in Figure 2. The
part ¯cj,j+1: ”x + z ̸= 0” in c(j,j+1),j+2 = ¯cj,j+1 ∧ cj+1,j+2
shown on the rightside in Figure 2 is the result of ”pushing
down” the condition cj,j+1: ”x ̸= 0” through opj+1, which
gives xnew = xold − z, i.e., xold = xnew + z, and thus cj,j+1:
”x ̸= 0” = ”xold ̸= 0” becomes ¯cj,j+1: ”xnew + z ̸= 0” =
”x+z ̸= 0”. But a difﬁculty arises if we replace ”x = x−z” in
opj+1 by ”x = x2−z” because we cannot express now xold in
552
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

terms of xnew. We can, however, add the computation ”xold =
x” at the end of opj and call it op′
j, let opj,j+1 = op′
j ◦ opj+1
and c(j,j+1),j+2: (xold ̸= 0) ∧ (y > x). But such tricks do not
always sufﬁce as would be the case if ”x = x − z” in opj+1
is replaced by ”x = x − z/x”; opj+1 now needs x ̸= 0 and
thus we cannot afford to do the test ”xold ̸= 0” after opj,j+1.
op j
x
out j
op j+1:
{y = y + z;
x = x − z}
z
out j+1
c j, j+1: x≠0
c j+1, j+2: y > x
op j, j+1 ≡
op j
op j+1
x, z
out j, j+1
c( j, j+1), j+2: (x + z≠0) ∧ (y > x)
Figure 2. Illustration of a simple case of c(j,j+1),j+2.
Even if we could deﬁne a suitable c(j,j+1),j+2, the creation
of tj,j+1 would prevent sharing just one of tj and tj+1
with another use-case U ′, and this can be a good reason not
to create tj,j+1. On the other hand, if we have a use-case
U ′ = ⟨· · · , tj, tj+1, t′
j+2, · · · ⟩ containing both tj and tj+1 but
a different t′
j+2, with c′
j+1,j+2 = ”y ≤ x” = ¬cj+1,j+2 for
the pair (tj+1, t′
j+2), then after we create tj,j+1 we will have
c′
(j,j+1),j+2 = (x + z ̸= 0) ∧ (y ≤ x) in U ′. Obviously, we
cannot merge tj and tk, k > j + 1, and keep U acyclic.
Theorem 1. For a use-case U = ⟨t1, t2, · · · , tn⟩, there is
no loss of generality to assume that each inj ̸= ∅ for j < n
if some use-cases U ′ share ti ∈ U exactly upto tj.
Proof. If inj = ∅ and j < n, then cj,j+1 depends only
on S
i<j ini and thus we can create the shortened use-case
U by merging tj into tj+1 as follows. We let cj−1,j+1 =
cj−1,j ∧lift(cj,j+1), where lift(cj,j+1) is the result of ”lifting
up” cj,j+1 through opj, and replace opj+1 by opj+1
=
opj ◦ opj+1. Note that cj−1,j+1 can be evaluated by opj−1.
If there is another use-case U ′ = ⟨· · · , tj−1, tj, t′
j+1, · · · ⟩,
which is identical to U upto tj, then we can likewise create
the shortened use-case U ′ by merging tj into t′
j+1, with op′
j+1
replaced by op′
j+1 = opj ◦ op′
j+1 and letting c′
j−1,j+1 =
cj−1,j ∧ lift(c′
j,j+1), where c′
j,j+1 is the condition for the
pair (tj, t′
j+1). Note that cj−1,j+1 ∧ c′
j−1,j+1 = cj−1,j ∧
lift(cj,j+1) ∧ lift(c′
j,j+1) = cj−1,j ∧ lift(cj,j+1 ∧ c′
j,j+1) =
cj−1,j ∧lift(false) = cj−1,j ∧false = false, as desired. The
shortened use-cases U and U ′ now share only upto tj−1. □
Two remarks are due here. First, merging tj with tj+1 to
avoid inj ̸= ∅ does not cost us in terms of its effect on the
class design. The methods for opj+1 and op′
j+1 in the classes
for U and U ′ will now have some commonalities because opj
is a part of both opj+1 and op′
j+1. However, we can refactor
the common part, if needed, to a parent class. Second, we do
not merge tj into tj−1 in the proof of Theorem 1 because if
there is an use-case U ′′ that is identical to U only upto tj−1
then the merging would create an overloaded tj−1,j in terms
of outputs and the operation opj−1,j = opj−1 ◦ opj, and this
can cause problems with the condition for (tj−1,j, t′′
j )-pair for
U ′′. If there is no U ′′, we could form tj−1,j to eliminate tj.
D. Decomposing an Interaction
If we can decompose an opj into a chain of suboperations
⟨opj.1, opj.2, · · · , opj.m⟩, m ≥ 2, then should we replace tj in
U by the chain of interactions ⟨tj.1, tj.2, · · · , tj.m⟩, where opj.p
corresponds to tj.p? If we did, then we will have cj−1,(j.1) =
cj−1,j, c(j.m),j+1 = cj,j+1, and cj.p,j.(p+1) = true, 1 ≤ p <
m. This implies that it is safe to merge tj.p’s and hence the
decomposition is unnecessary. Note that because cj.p,j.(p+1) =
true, there is no use-case U ′ that includes tj.p but not tj.(p+1).
E. Deleting an Interaction
In general, the deletion of a tj ∈ U may not give a valid
use-case ⟨t1, t2, · · · , tj−1, tj+1, tj+2, · · · , tn⟩. For example, if
tk, k > j, requires dj generated by opj then removal of tj
makes opk inapplicable; hence tk needs to be removed. This
may, in turn, require other tm, m > k, to be removed and
so on. On the other hand, if k > j is the smallest index such
that tk requires dj then ⟨t1, t2, · · · , tj−1, tj+1, tj+2, · · · , tk−1⟩
may not be a valid use-case because the output of tk−1 may
involve a prompt to the user to provide an input (inu
k ̸= ∅).
The same argument shows that deletion of tk−1 may create a
problem, and so on. A similar argument shows that an initial
part of a use-case may not be a valid use-case. Likewise, a
tail part ⟨tk+1, tk+2, · · · , tn⟩ of a use-case may not be a valid
use-case because the output of tk may involve a prompt to the
user to provide an input and without that prompt tk+1 becomes
meaningless.
III.
AUGMENTED FINITE STATE (AFS) MODEL
The AFS model of a set of use-cases U, denoted by
AFS(U), combines the notions of ﬁnite state machines,
ﬂowcharts, and Dataﬂow Diagrams (DFDs, which can be
regarded as high-level dataﬂow-abstractions of ﬂowcharts). As
a ﬁnite-state machine, each state sj in AFS(U) corresponds
to an interaction tj in a use-case in U. Each transition (sj, sk)
corresponds to the next-interaction tk of tj in a use-case in U
that contains tj, and associated with the transition (sj, sk) we
have the corresponding condition cj,k. Clearly, cj,k is indepen-
dent of the use-case in which tk is the next interaction after tj,
and it can be likened to a branching-condition in a ﬂowchart.
We also have the dataﬂows di between interactions or states.
As before, we consider a state sj = tj to be synonymous
with the operation opj associated with tj. If |U| = 1, then
AFS(U) takes the form of a single chain. The condition
cj,k associated with transition (sj, sk) must be satisﬁed for
the transition to take place. For two transitions (sj, sk) and
(sj, s′
k), sk ̸= s′
k, the conditions cj,k and cj,k′ must be disjoint,
i.e., cj,k ∧ cj,k′ = false. Unlike a ﬂowchart, an AFS(U)
by deﬁnition does not have a cycle and this prevents cyclic
data-dependencies. The usual use-dependencies among data-
items in assignments and other computations in a ﬂowchart are
replaced in AFS(U) by the higher-level abstractions inputs,
outputs, and dataﬂows associated with a state.
We formally deﬁne AFS(U) = (S, s0, Sfinal, C, D, Iu,
Ie, Ou, Oe, τ, δ, φu, ψu, φe, ψe), where
1)
S ̸= ∅ is a set of states and s0 ∈ S is the start-state;
each state sj is reachable from s0 by a sequence of
transitions and has an associated operation opj.
553
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

2)
Sfinal ⊆ S is the subset of ﬁnal (terminal) states,
from which there are no transitions.
3)
C = {ci,j: conditions associated with transitions
(si, sj)} = S CU, union over the use-cases U ∈ U.
4)
D = {di: the internal dataﬂow item generated by opi
at si} = S DU, union over the use-cases U ∈ U.
5)
Iu = S Iu
U, Ie = S Ie
U, Ou = S Ou
U and Oe =
S Oe
U, each union over the use-cases U ∈ U.
6)
τ : S × C → S is the transition function.
7)
δ : D → S × P+(S) is the function representing
the dataﬂows, where P+(S) = the set of non-empty
subsets of S, δ(dj) = (sj, Sj) = (δ1(dj), δ2(dj))
means Sj = {sk: sk uses dj generated at sj}, and
di ̸= dj means si = δ1(di) ̸= δ1(dj) = sj.
8)
φu : Iu → P+(S) is the user-input function; φu(u′)
= {sk: sk requires user-input u′}.
9)
φe : Ie → P+(S) is the external-input function;
φe(e′) = {sk: sk requires external-input u′}.
10)
ψu : Ou → P+(S) is the user-output function.
11)
ψe : Oe → P+(S) is the external-output function.
12)
For each si /∈ Sfinal, the conditions ci,j are mutually
disjoint (i.e., ci,j ∧ ci,k = false for j ̸= k). We may
also assume that W ci,j = true because otherwise
we can add a ”graceful” exit-transition to a new ﬁnal
state s′
i with the transition-condition ci,i′ = ¬ W ci,j.
13)
For any si, sj ∈ φu(u′) for an user-input u′, neither
of si and sj is reachable from the other. Similarly for
φe and ψe. (But this is not required for ψu.)
In what follows, we consider only the special case where
AFS(U) has a tree-structure. Recall that not all paths in a
ﬂowchart, even in absence of cycles, may represent a valid
execution-path; likewise, if the transitions in AFS(U) form a
general acyclic digraph, then we may have paths from the start-
state s0 to a ﬁnal-state that do not represent a valid use-case
and this can severely complicate the derivation of a suitable
class-structure from AFS(U). In the case of a tree-structured
AFS(U), each path from the start-state s0 to a ﬁnal-state
represents a valid use-case in AFS(U).
AFS(U) helps us to see the relationships among the use-
cases U in terms of their shared interactions. In particular,
it helps us to identify inconsistencies inconsistent order of
operations, invalid dataﬂow dependencies, and missing in-
puts/outputs for the use-cases U. One must, indeed, resolve
all inconsistencies before attempting to create a class-structure
from U for the desired software.
IV.
METHODOLOGY
Given the AFS-model of a single use-case U, we use the
Class-Creation-Rules below to obtain a class that supports an
implementation of U. These rules can be used also, more
generally, for any linear chain of interactions. Initially, the
class-methods have no parameters and this has the advantage
of a simple control mechanism for executing the methods
in a class (see Section V-C). We may later use refactoring
to introduce new methods (possibly, with parameters) for
common or similar parts of the original class-methods, and
replace the common parts in the original methods by calls to
the new refactored methods with suitable parameter-values.
Class-Creation-Rules for a single use-case U:
1.
The variables are the internal dataﬂows, which
may include parts of IU ∪ OU.
2.
The class-methods are the operations opj ∈ U or
parts of them.
If |U| > 1, we can ﬁrst create one class for each use-case
in U and then refactor common class-variables and methods to
create the ﬁnal class-structure. A better method is to build the
class-structure directly from the combined model AFS(U),
whose tree-structure directly leads to a tree-structured class-
hierarchy, with one class for each maximal linear segment
(MLS) of the tree. A linear segment in AFS(U) is a path
π in AFS(U), where each state in π other than those at the
start and end of π has a single child (next) node.
We remark that the notation tj = (inj, opj, outj) implies
that if tj ∈ U is shared and equals t′
j = (in′
j, op′
j, out′
j) ∈ U ′,
then inj = in′
j, opj = op′
j, and outj = out′
j. However, the
dataﬂow dj from opj in U may differ from the dataﬂow d′
j
from op′
tj = t′ j in U ′. For a tree-structured AFS(U), with U, U ′ ∈ U,
j implies opj = op′
j can compute dj ∪ d′
j, and thus we
can replace both dj in U and d′
j in U ′ by dj ∪ d′
j. Viewed
another way, this simply points out that while the classes for
U and U ′ obtained by the Class-Creation-Rules may contain
different class variables due to dj ̸= d′
j, when we merge those
classes to create a class-hierarchy the class containing opj =
op′
j can include the variables for both dj and d′
j.
We illustrate below our method by deriving a class-
structure for a bank’s ATM-system with three high-level func-
tional requirements or use-cases U = {U1, U2, U3}, where
U1 = successful withdrawal, U2 = failed withdrawal due to
insufﬁcient funds, and U3 = balance enquiry. We ﬁrst derive a
class for each Uj using the Create-Class-Rules and then show
that the class-structure obtained by refactoring these classes
can be obtained directly from U.
A. Informal Description of ATM
A user swipes a debit card in the ATM’s card-slot. The
ATM reads the debit card and prompts the user to enter the
PIN. We assume for simplicity that no invalid ATM card or
PIN is used, and there is no cash dispenser malfunction. The
ATM validates the PIN and asks the user to choose one of
two displayed options ”withdrawal” and ”balance-enquiry”. If
the user selects withdrawal-option, the ATM calculates and
displays the maximum allowable withdrawal amount based on
the available ATM cash and debit-card-account-information.
Then, the ATM asks the user to enter the withdrawal amount
and it reads that amount. Then, either the ATM displays the
updates to debit-card-account-info and dispenses the desired
cash, or it displays a transaction-fail-message when withdrawal
amount is too large. If the user selects balance-enquiry option,
the ATM displays the debit-card-account-balance. In each case,
the ATM writes a transaction-log for future audit analysis as
part of session-closing operation.
B. Formal Description of Use-Case U1
We show below the decomposition of U1 into four
interactions t1-t4 and also show each opj in detail, including
its lower level operations. This simpliﬁes the identiﬁcation of
inputs inj, outputs outj, dataﬂow items dj, and the transition
conditions cj,j+1 for U1, which are shown in Tables I and
554
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

II. The data-item ATMidAndOtherInfo in ine
3 includes ATM-
cash-balance among others. The Transaction-Log-Information
(TLI) has many parts, including dateTime of transaction,
transaction
amount,
update
of
Bank-Debit-card-Account-
Detail-Info, etc. Different oute
j includes different parts of TLI.
U1: Successful withdrawal
t1:
User swipes the debit card in the ATM’s card slot and
enters PIN when requested. [op1:
ATM reads the
debit card number, then reads Bank-Debit-Card-PIN
Information based on the debit card number, displays
”Enter PIN” message, reads the PIN entered and vali-
dates it with Bank-Debit-Card-PIN information, reads
Bank-Debit-Card-Account-Detail Information for the
debit card number, and writes part-1 (debit card num-
ber, PIN, and transaction dateTime) of TLI]
t2:
User sees the displayed transaction options and se-
lects the ”withdrawal” option. [op2:
ATM displays
the transaction-options ”balance-enquiry” and ”with-
drawal”, requests the user to select an option, reads the
selected option (= ”withdrawal” for U1), and writes
part-2 (transactionOption = withdrawal) of TLI.]
t3:
User sees the displayed max allowed withdrawal
amount and enters the desired withdrawal amount.
[op3:
ATM calculates and displays the max al-
lowed withdrawal amount based on the ATM-cash-
balance (which is part of the external input AT-
MidAndOtherInfo) and the debit-card-account-detail
information (such as the single-transaction-limit, the
daily-withdrawal-limit for the card, today’s-current-
total-withdrawal, and the debit-card-account-balance).
Then, ATM requests user to enter the desired-
withdrawal-amount, reads it, and writes part-3 (max
allowed withdrawal amount) of TLI.]
t4:
User takes the dispensed cash. [op4:
ATM up-
dates ATM-cash-balance part of ATMidAndOther-
Info and the Bank-Debit-Card-Account-Detail infor-
mation (such as today’s-total-withdrawal and debit-
card-account-balance), displays the updated debit-
card-account-balance, displays ”collect-cash” message
(which includes the amount withdrawn), dispenses
cash for the withdrawal amount, and writes part-4 (up-
dates of ATM-cash-balance, this withdrawal amount,
debit-card-account-balance) of TLI.]
TABLE I. Inputs inj and outputs outj for U1
in1
u: Debit-card number,
PIN number
e: Bank-Debit-Card-
PIN Info,
Bank-Debit-Card-
Account-Detail Info
in2 u: Selected Transaction
Option
in3
u: Desired Withdrawal
Amount
ATM-id-And-Other
Info
in4 u: Cash Collected
out1 u: "Enter PIN" message
e: Part-1 of TLI
out2
u: Transaction-options display,
"Select Option" message
e: Part-2 of TLI
out3
u: Max Allowable Withdrawal
Amount display,
"Enter Desired Withdrawal
Amount" message
e: Part-3 of TLI
out4
u: New BankAccountDetailInfo,
"Collect Cash" message
e: New BankAccountDetailInfo,
New ATMidAndOtherInfo,
Part-4 of TLI
TABLE II. Conditions cj,j+1 and data-items dj for U1
c1,2 true (no invalid card or PIN)
c2,3 "Withdrawal" = Selected
Transaction Option
c3,4
Max Allowable Withdrawal
Amount ≥ Desired
Withdrawal Amount
d1 Bank-Debit-Card-Account-
Detail Info
d2 Selected Transaction Option
d3
Max Allowable Withdrawal
Amount,
Withdrawal Amount Desired
In general, the conjunction of cj,j+1’s for the interaction-
sequence of a use-case U does not give a pre-condition for U
because each cj,j+1 is stated in terms of values of data-items
”after” the operation opj. For U1, c2,3 ∧c3,4 does give its pre-
condition. We consider d2 to be an ”implicit” dataﬂow from
op2 to op3 because execution of op3 requires c2,3 to be true.
Similarly, we consider d3 to be an implicit dataﬂow from op3
to op4. (The controller to drive the execution of the methods
in the class for U1 will use d2 and d3; see Section V-C.) See
Figure 3, which shows the ﬁnite-state machine model and the
dataﬂow model for U1. There is no dataﬂow from t1 to t2.
s1
s2
s3
s4
c1,2 = true
c2,3
c3,4
op1
op2
op3
op4
in1
out1
in2
out2
in3
out3
in4
out4
d2
d1
d3
Figure 3. FSM (left) and DFD (right) for the use-case U1
s1
s2
s3
s4
in1
out1
in2
out2
in3
out3
in4
out4
d1
d2
d3
c1,2 = true
c2,3
c3,4
SuccessfulWithdrawal
ATMidAndOtherInfo
bankDebitCardPINinfo
bankDebitCardAccountDetailInfo
selectedTransactionOption
maxAllowableWithdrawalAmount
desiredWithdrawalAmount
// d1
// d2
// d3
// d3
readDebitCardPINinfo()
displayEnterPINmssg()
readAndValidatePIN()
readBankAccountDetailInfo()
writePart1TransactionLonInfo()
displayTransactionOptions()
readSelectedTransactionOption()
writePart2TransactionLogInfo()
displayMaxWithdrawalAmount()
displayEnterWithdrawalAmountMssg()
readDesiredWithdrawalAmount()
writePart3TransactionLogInfo()
updateATMandBankAccountInfo()
displayAccountDetailInfo()
displayCollectCashMssg()
dispenseCashOperation()
writePart4TransactionLogInfo()
// op1
// op1
// op1
// op1
// op1
// op2
// op2
// op2
// op3
// op3
// op3
// op3
// op4
// op4
// op4
// op4
// op4
Figure 4. AFS model (left) and class (right) for use-case U1
C. AFS Model of U1
Figure 4 shows AFS(U1), obtained by combining the
DFD and the FSM shown in Figure 3. It also shows the
SuccessfulWithdrawal-class obtained from AFS(U1) based
on Tables I and II and the Class-Creation-Rules, and it is
555
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

suitable for implementing U1. The detailed analysis of each
tj identiﬁed several low level functions (methods) for the
associated opj, and we have labeled each of those low-level
functions as ”//opj” in SuccessfulWithdrawal-class. One could
merge the functions with the same label ”//opj” into a single
function, and call it opj. If we let each merged function
opj have parameters corresponding to the dataﬂows to it and
let each opj call opj+1, then we can eliminate all the class
variables except d1; even d1 can be eliminated if we use a
parameter in op2 and pass d1 for it when called by op1. But
we keep the class variables as shown to simplify the design of
a single general purpose controller for any sets of use-cases.)
D. Merging and Decomposing Interactions in U1
We can merge interactions t1 and t2 or, equivalently, states
s1 and s2 in Figure 4 into a single state because c1,2 = true.
This will not adversely affect handling U2 and U3 because
both t1 and t2 are common to U2 and U3. We do not merge
s2 and s3 because that would prevent sharing s2 (and its
associated operations, inputs, and outputs) between U1 and the
use-cases U2 and U3. On the other hand, we do not decompose
a tj, 1 ≤ j ≤ 4, into several tj.k’s corresponding to the
methods in Figure 4 having the label ”//opj” because that
does not give us a better sharing of tj,k’s among the use-cases
U = {U1, U2, U3}, and thus does not help in the design of a
class-structure for U.
E. Classes and Formal Description of Use-Cases U2 and U3
Shown below are the decompositions of the use-cases U2
and U3 into their component interactions. The use-case U2
shares its ﬁrst three interations with U1 and U3 shares its ﬁrst
two interactions with U1. Note that t10 ∈ U3 is the same as
t2 ∈ U1, even though the value of data-item inu
10 = inu
2 is
different in U1 and U3; that difference is reﬂected in c2,3 ̸=
c10,11. The condition c7,8 = ¬c3,4 gives c7,8 ∧ c7,8 = false
and c3,4 ∨ c7,8 = true. The pre-condition for U2 is c2,3 ∧ c3,8
and that for U3 is c2,11.
U2: Failed withdrawal due to insufﬁcient funds
tj+4:
Same as tj in U1 for 1 ≤ j ≤ 3.
t8:
User sees ”insufﬁcient funds” message. [op8: ATM
displays insufﬁcient funds message for the desired
withdrawal amount, and writes part-5 (”failed with-
drawal”, withdrawalAmount = 0) of TLI.]
U3: Balance enquiry
t9:
Same as t1 in U1.
t10:
Same as t2 in U1 except that the user selects the
”balance-enquiry” option.
t11:
User sees account balance information. [op11: ATM
displays the account balance and writes part-6 (”bal-
ance enquiry”) of TLI.]
Table III gives the inputs and outputs for the interactions
t8, t10 and t11 in the use-cases U2 and U3. Table IV gives the
conditions for these new interactions.
TABLE III. Inputs and outputs for U2 and U3 that are different from U1
in8
∅ (empty)
in10
= in2
u: Selected
Transaction
Option
in11
∅ (empty)
out8
u: "Insufﬁcient Funds" message
e: Part-5 of TLI
out10
= out2 ∅ (empty)
out11
u: Account Balance
e: Part-6 of TLI
TABLE IV. Conditions cj,k for U2 and U3 that are different from U1
c7,8 = c3,8 =
¬c3,4
Max Allowable Withdrawal
Amount < Withdrawal Amount Desired
c9,10 = c1,2
true (no invalid Card)
c10,11 = c2,11 "Balance Enquiry" = Selected Transaction Option
F. AFS Models for U2 and U3
We do not show the FSM and DFD for U2 and U3, but
their AFS models and the corresponding classes are shown in
Figures 5 and 6. As in the case of U1, we could merge the
functions (methods) with the same label ”//opj” in Figures 5
and 6 into a single function and call it opj.
G. Merging of States for U2 and U3
We do not merge s2 with s3 or s11 because c2,3 and c2,11
are disjoint; likewise, we do not merge s3 with s4 or s8.
V.
CLASS STRUCTURE AND IMPLEMENTATION
The classes in Figures 4-6 together allow us to implement
the ATM described in section IV-A. We get the class-hierarchy
shown in Figure 8 when we eliminate the duplicate attributes
and methods in these classes using refactoring and combine
the classes into a hierarchy. We can also directly get the same
class-hierarchy, without creating the classes in Figures 4-6,
from the combined AFS model for U1-U3 shown in Figure 7.
A. Combining AFS Models
We use the following notion of equivalent states to combine
two AFS models M = AFS(U) and M ′ = AFS(U′) for the
sets of use-cases U and U′. Two states sj ∈ M and s′
j ∈ M ′
are equivalent if all computations along the path π(sj) from
the start-state of M upto sj are identical to those along the
path π′(s′
j) from the start-state of M ′ upto s′
j in terms of the
s1
s2
s3
s8
in1
out1
out2
in2
out3
in3
out8
in8
d1
d3
d2
c1,2 = true
c2,3
c3,8 = ¬c3,4
InsufﬁcientFund
ATMidAndOtherInfo
bankDebitCardPINinfo
bankDebitCardAccountDetailInfo
selectedTransactionOption
maxAllowableWithdrawalAmount
desiredWithdrawalAmount
// d1
// d2
// d3
// d3
readDebitCardPINinfo()
displayEnterPINmssg()
readAndValidatePIN()
readBankAccountDetailInfo()
writePart1TransactionLogInfo()
displayTransactionOptions()
readSelectedTransactionOption()
writePart2TransactionLogInfo()
displayMaxWithdrawalAmount()
displayEnterWithdrawalAmountMssg()
readDesiredWithdrawalAmount()
writePart3TransactionLogInfo()
displayInsufﬁcientFundsMssg()
writePart5TransactionLogInfo()
// op1
// op1
// op1
// op1
// op1
// op2
// op2
// op2
// op3
// op3
// op3
// op3
// op8
// op8
Figure 5. AFS model and class for use-case U2
556
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

order of computations and the underlying constraints. To be
precise, sj and s′
j are equivalent if
1)
For k < j, sk is equivalent to s′
k.
2)
The dataﬂows to sj and s′
j are identical in terms of
the data-sources and the data-items.
3)
The operations at sj and s′
j are the same: opj = op′
j,
including the inputs inu
j = in′u
j and ine
j = in′e
j and
the outputs outu
j = out′u
j and oute
j = out′e
j .
4)
The dataﬂows from sj and s′
j are the same (dj = d′
j).
5)
The condition cj−1,j in M is the same as c′
j−1,j in
M ′, i.e., cj−1,j = c′
j−1,j.
s1
s2
s11
in1
out1
out2
in2
out11
in11
d1
c1,2 = true
c2,11
d2
BalanceEnquiry
ATMidAndOtherInfo
bankDebitCardPINInfo
bankAccountDetailInfo
selectedTransactionOption
// d1
// d2
readDebitCardPINinfo()
displayEnterPINmssg()
readAndValidatePIN()
readBankAccountDetailInfo()
writePart1TransactionLogInfo()
displayTransactionOptions()
readSelectedTransactionOption()
writePart2TransactionLogInfo()
displayAccountBalance()
writePart6TransactionLogInfo()
// op1
// op1
// op1
// op1
// op1
// op2
// op2
// op2
// op11
// op11
Figure 6. AFS model and class for use-case U3
The conditions (1)-(3) and (5) above imply we can assume
dj = d′
j, i.e., condition (4) holds without loss of generality.
This can be seen as follows. Because opj = op′
j can compute
each of dj and d′
j, it can compute dj ∪ d′
j and thus we can
replace each of dj and d′
j by dj ∪ d′
j. The equivalence of
sj and s′
j depends only on the states on the paths π(sj) and
π′(s′
j), the inputs, outputs, and dataﬂows to and from those
states, and the transition-conditions along π(sj) and π′(s′
j).
Note that the above deﬁnition of equivalence differs in many
ways from that in ﬁnite-state automata theory, where the state-
equivalence depends on what can happen in future from those
states; in particular, the ﬁnal states play a critical role. In our
deﬁnition, the ﬁnal-states have no special role.
B. Combining AFS models
Suppose U and U ′ are two (elementary) use-cases with one
or more equivalent states. (We can always imagine a dummy
start-state for a use-case, which just displays ”starting...” and
having no dataﬂow from this state. This will make the start-
state of all use-cases equivalent.) We can merge the pairs of
equivalent-states, one in each of AFS(U) and AFS(U ′), and
the result is an AFS model having a tree-structure with two
terminal nodes (ﬁnal states). We can repeat the process for
a set of use-cases U, merging a state in AFS(Uj) with its
equivalent-state (if any) the result of merging AFS(Ui), 1 ≤
i < j. The ﬁnal AFS model AFS(U) does not depend on
the order in which we merge AFS(Ui)’s. Figure 7 shows the
merged AFS model obtained from those in Figures 4-6.
The path π = ⟨s1, s2⟩ in Figure 7 gives the class ATM-
Transaction in Figure 8. The other classes in Figure 8 are
obtained from the single-state paths ⟨s3⟩, ⟨s4⟩, ⟨s8⟩, and ⟨s11⟩.
The next-relationship between the paths ⟨s1, s2⟩ and ⟨s3⟩
makes Withdrawal-class a subclass of ATMTransaction-class
in Figure 8, and likewise for the other subclass-relationships.
We obtain the same class structure in Figure 8 if we start with
the classes in Figures 4-6 and apply refactoring [7].
s1
s2
s3
s4
s8
s11
in1
out1
in2
out2
= ∅
in3
out3
in11
= ∅
out11
in4
out4
in8
= ∅
out8
c1,2 = true
c2,3
c2,11
c3,4
c3,8
d1
d1
d2
d3
Figure 7. Combined AFS model for U1-U3.
ATMtransaction
ATMidAndOtherInfo
bankDebitCardPINinfo
bankDebitCardAccountDetailInfo
selectedTransactionOption
// d1
// d2
readDebitCardPINinfo()
displayEnterPINmssg()
readAndValidatePIN()
readBankAccountDetailInfo()
writePart1TransactionLogInfo()
displayTransactionOptions()
readSelectedTransactionOption()
writePart2TransactionLogInfo()
//op1
//op1
//op1
//op1
//op1
//op2
//op2
//op2
BalanceEnquiry
displayAccount-
Balance()
writePart6Tran-
sactionLogInfo()
//op11
//op11
Withdrawal
maxAllowableWithdrawalAmount
desiredWithdrawalAmount
// d3
// d3
displayMaxWithdrawalAmount()
displayEnterWithdrawalAmountMssg()
readDesiredWithdrawalAmount()
writePart3TransactionLogInfo()
//op3
//op3
//op3
//op3
SuccessfulWithdrawal
updateATMandBankAccountInfo()
displayAccountDetailInfo()
displayCollectCashMssg()
dispenseCashOperation()
writePart4TransactionLogInfo()
//op4
//op4
//op4
//op4
//op4
InsufﬁcientFund
displayInsufﬁcient-
FundMssg()
writePart5Tran-
sactionLogInfo()
//op8
//op8
Figure 8. Class-hierarchy from the AFS model in Figure 7
It is worth pointing out that if we apply the concept analysis
technique [12] to the attributes (variables) and methods of the
classes in Figures 4-6, based on the use-relationship between
those variables and methods, then we would arrive basically
at the same ﬁnal class structure in Figure 8, except that each
of the classes ATMtransaction and Withdrawal will become a
chain of simpler classes (involving a partitioning of variables
and methods in those classes). We will then simply merge those
chains to form the classes ATMtransaction and Withdrawal as
given in Figure 8. Note that a major part of building AFS(U)
involves, via the details of the interactions in the use-case
U, the identiﬁcation of all class variables and methods, and
their use-relationships, and the latter are the inputs to concept
analysis. The only part of AFS(U) which does not explicitly
appear in the class-structure and is not used in concept analysis
557
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

is the transition-conditions; they play, however, a critical role
in the correctness of the tree-structure of AFS(U), its unique
decomposition into maximal linear segments (like ⟨s1, s2⟩),
and in developing the controller (see Section V-C) to drive
the execution of the methods in the class-structure. In this
sense, our approach based on the AFS model is superior to the
concept analysis method. After all, there is not much value in
a class-structure design unless we clearly understand how to
control the calls to its methods.
C. Implementation
Figure 9 shows the execution dependencies among the
methods for the AFS model in Figure 7. Here, fj represents
the group of methods corresponding to opj (see Figure 8) for
state sj. A link (fi, fj) implies the execution of fj follows
that of fi, partly because di generated by fi is required by fj
for its computations or di is needed in determining whether fj
can execute or not. It is not surprising that the links (fi, fj)
in Figure 9 parallel the links (si, sj) in Figure 7.
all
user and
external
inputs
(in8 =
in11 = ∅)
Memory
for
all class
variables
Controller for executing f j’s
f1
f2
f3
f4
f8
f11
d1
d1, d2
d1, d2
d2
d3
d3
d3
in1
in2
in3
in4
Figure 9. The execution dependency among methods fj
corresponding to opj in Figure 8; dj’s are the dataﬂows.
There are many ways [13] to implement the dependencies
in Figure 9. The simplest and the best solution is a central
controller that works as follows. It ﬁrst calls the root function
f1, and following the execution of an fj it tests the disjoint
conditions cj,k for the ”child” functions fk of fj and calls
fk if cj,k is true. Another approach is to start with the root
function f1 as before but let each fj evaluate the conditions
cj,k and call fk, if cj,k is true, as its last step, Here, changes in
U may require small modiﬁcations to several fj’s, depending
on how many classes are affected. In the ﬁrst approach,
the modiﬁcations to the central controller can be completely
automated. As a third alternative, we can introduce parameters
to fj’s and let each fj store dj as a local variable in it and use
it as one of the parameters in the call to an fk. For Figure 9.
this means f1 executes ﬁrst and ends with a call to f2, with d1
as the parameter. Next, f2 ends with a call to f3 or f11, with
d1 and d2 as parameters. Likewise, f3 ends with a call to f4
with d1, d2, and, d3 as parameters, etc. This approach requires
fewer class-variables, but changes in requirements may cause
many changes in the deﬁnition and selection of the parameters.
This approach clearly gives a poor quality software.
VI.
CONCLUSION
We have presented here a systematic, semi-formal method
to obtain a hierarchical class-structure, including the attributes
and methods for each class in the hierarchy, for an object-
oriented design of a software from its requirements given in
the form of a set of use-cases. We use two formal models:
(1) a detailed model of a use-case in terms of its inter-
actions (operations), which includes the user and external
inputs/outputs of each operation and the dataﬂows to/from
it, and (2) an Augmented Finite State (AFS) model for a
set of use-cases, which captures shared operations among the
use-cases, the points-of-divergence between use-cases and the
related control-ﬂow conditions. The AFS model can help to
identify missing use-cases, missing interactions in the use-
cases, and the potential need to decompose some interactions
into simpler ones. If the AFS model has a tree structure, then
this directly gives a hierarchical class-structure suitable for
an object oriented implementation of the requirements. This
means, in principle, one could start from, say, a C-program P
and reverse engineer it to obtain an AFS model for it, and if the
AFS model has a tree structure then create a hierarchical class-
structure from that AFS model, and ﬁnally obtain an object-
oriented program P ′ with the same functionality as P.
ACKNOWLEDGMENT
The authors would like to thank the anonymous referees
for some useful comments to improve the presentation.
REFERENCES
[1]
D. K. Deeptimahanti and R. Sanyal, “Semi-automatic generation of uml
models from natural language requirements,” Proc. of the 4th India
Software Engineering Conference, pp. 165–174, 2011.
[2]
L. Li, “Translating use cases to sequence diagrams,” Proc. of 15th IEEE
Intern. Conf. on Automated Software Engineering, pp. 293–296, 2000.
[3]
D. Liu, K. Subramaniam, B. Far, and A. Eberlein, “Automating tran-
sition from use-cases to class model,” IEEE Canadian Conference on
Electrical and Computer Engineering (CCECE), vol. 2, pp. 831–834,
2003.
[4]
G. S. A. Mala and G. V. Uma, “Automatic construction of object
oriented design models [uml diagrams] from natural language require-
ments speciﬁcation,” Proc. of 9th Paciﬁc Rim Intern. Conf. on Artiﬁcial
Intelligence, pp. 1155–1159, 2006.
[5]
A. Cockburn, “Structuring use cases with goals,” Journal of Object-
Oriented Programming, 1997.
[6]
B. Roussev, “The value added invariant: A newtonian approach for
generating class diagrams from a use case model,” WITUML, 16th
European Conf. on Object Oriented Programming, ECOOP-2002, 2002.
[7]
M. Fowler, K. Beck, J. Bryant, W. Opdyke, and D. Roberts, Refactoring:
Improving the Design of Existing Code.
Boston, MA, USA: Addison-
Wesley Longman Publishing Co., Inc., 1999.
[8]
S. Kundu, “Structuring software functional requirements for automated
design and veriﬁcation,” Proc. 31st Annual IEEE Intern. Computer
Software and Applications Conf, COMPSAC-07, Jul 24-27, 2007.
[9]
T. Chow, “Testing software design modeled by ﬁnite-state machines,”
IEEE Trans. Softw. Eng., vol. SE-4, no. 3, pp. 178–187, 1978.
[10]
S. Eilenberg, Automata, Languages, and Machines. Orlando, FL, USA:
Academic Press, Inc., 1976.
[11]
I. Jacobson, Object-Oriented Software Engineering: A Use Case Driven
Approach.
Redwood City, CA, USA: Addison Wesley Longman
Publishing Co., Inc., 2004.
[12]
G. Snelting and F. Tip, “Understanding class-hierarchies using concept
analysis,” ACM Trans. Prog. Lang. Syst., vol. 22(3), pp. 540–582, 2000.
[13]
S. Kundu, “A canonical functional design based on the domination-
relationship among data,” Proc. 8th Asia Paciﬁc Software Engineering
Conference, APSEC-2001, Dec. 4-7, 2001.
558
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

