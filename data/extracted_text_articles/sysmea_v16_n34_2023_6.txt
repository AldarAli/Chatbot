Finite Memory Arithmetic and the Number
Representations on Computing Machines
Pavel Loskot
ZJU-UIUC Institute
Haining, China
e-mail: pavelloskot@intl.zju.edu.cn
Abstract—Numerical values on computing machines are nor-
mally represented as finite-memory data objects. Such values
can be mapped to a finite set of integers, so the computing ma-
chines effectively perform only the integer arithmetic operations.
Consequently, all programs and algorithms implemented on the
computing machines can be modeled by Diophantine equations.
This is also true for the computations that are performed by
analog computers with a limited resolution. In order to study
the Diophantine systems, this paper introduces a dual modulo
operator to select the subsets of digits in the string representations
of machine numbers, which is also useful when the number
equality is replaced by a modulo equivalence. Moreover, it is
shown that the solutions of Diophantine equations such as the
Fermat Last Theorem can be obtained in the domain of integers
that are offset by the same constant real value. The Fermat metric
is newly introduced to define the distances between integers
and other discrete sets of numbers. Finally, a two-dimensional
quantization is devised for mixed arithmetic operations to allow
the computations to be equivalently performed either between
discrete analog values, or between the integer indices. The key
claim of this paper is that all practical computing problems can
be exactly and completely represented by an integer arithmetic.
Keywords—dual modulo arithmetic; Fermat last theorem; Fer-
mat metric; natural numbers.
I. INTRODUCTION
Numbers are abstract mathematical objects that can also
carry a semantic meaning of quantity. The former leads to rich
axiomatic algebraic systems, and the latter enables performing
arithmetic operations on computing machines. Numerical algo-
rithms generate and transform numerical values by performing
various arithmetic and non-arithmetic operations. Since the
computing machines have limited resources, they must ex-
ecute numerical algorithms in a time and memory efficient
manner. The computed numerical values are stored as the
precisely defined finite size objects in software and hardware,
usually referred to as data structures. Consequently, these
values cannot directly represent unconstrained real numbers
in a mathematical sense, but it requires specifying a mapping
from an infinite set of real numbers that are assumed in the
definitions of computing problems into a finite set of selected
discrete values that can be effectively represented in software
and hardware as indicated in Figure 1.
The problem of representing numerical values on computing
machines as integers when these values are stored in finite-
memory data structures was introduced and examined in
[1, SIGNAL’23]. The current paper extends our conference
representation
hardware
representation
software
representation
mathematical
numerical
values
algorithms
computing
problems
numerical
Figure 1. Embedded representations of numbers on computing machines.
paper by adding more background knowledge, providing more
comprehensive literature review as well as by presenting the
new results on the quantization of real values and the related
mixed arithmetic operations.
Many programming languages used in computing appli-
cations such as Fortran, Matlab, Python, Julia and even C
define integer and floating point numbers as their native data
structures. Some of these languages allow further specifying
the number of bytes used for storing the integer values,
whether they are stored as signed or unsigned integers, and
whether floating point numbers are stored with single or dou-
ble precision. Furthermore, since the total number of unique
values that can be represented by finite size data structures
is finite, it limits the largest and the smallest numerical
values as well as the precision that can be considered in
any given computing application. For example, in Matlab, the
functions, realmin, realmax, intmin, intmax and eps can be
used to explore what numerical values are actually available
to perform the computations.
Majority of real numbers are not computable [2], i.e., there
is no algorithm that can express these numbers explicitly with
an arbitrary precision (note that the constant π and
√
2 are
both computable). On the other hand, a set of integers is said
to be computably enumerable, if there exists an algorithm that
150
International Journal on Advances in Systems and Measurements, vol 16 no 3 & 4, year 2023, http://www.iariajournals.org/systems_and_measurements/
2023, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

eventually lists all the elements in this set, even though such
an algorithm may never halt.
Any algorithm described or implemented in any program-
ming language can only compute numbers from a finite set,
N = {N1 < N2 < ...}, such that,
∀i : −∞ < inf(N ) ≤ Ni ≤ sup(N ) < ∞.
(1)
Thus, the machine numbers, Ni, and, Nj, can be compared,
i.e., ordered, and their smallest difference, mini̸=j |Ni −Nj| =
ε0, defines the precision. Moreover, the set, N , is necessarily
computable [3].
Most computing machines use floating point and fixed point
number representations. These representations including the
basic arithmetic operations are precisely defined by the IEEE
754 standard [4]. They enable efficient utilization of hardware
and software resources to achieve time and space efficiency in
implementing and executing the computing algorithms. Uni-
versal numbers (unums) were recently introduced as a superset
of the IEEE-754 standard. However, their latest version known
as posits is no longer the IEEE-754 format compatible, as they
were primarily designed to mitigate the hardware constraints
in representing the floating point numbers [5]. These modern
number representations enable variable-width storage, support
the interval (posit) arithmetic, and they also guarantee that
the exact result of arithmetic operations is within the defined
bounds.
The interval arithmetic assumes that numbers are repre-
sented by open or closed intervals rather than typical point
values [6]. It then induces corresponding arithmetic operations
between such intervals. For instance, if the two numbers have
their values within the intervals, [x1,x2], and, [y1,y2], then their
addition and multiplication is defined, respectively, as [7],
[x1,x2]+[y1,y2] = [x1 +y1,x2 +y2]
[x1,x2]·[y1,y2] = [min(x1y1,x1y2,x2y1,x2y2),
max(x1y1,x1y2,x2y1,x2y2)].
(2)
Similarly, the univariate function values of interval numbers
are computed as,
f([x1,x2]) = [min(f(x1), f(x2)),max(f(x1), f(x2))].
(3)
However, the interval arithmetic is not consider further in this
paper, although it is an interesting and relevant topic for future
investigations.
The multi-precision arithmetic can be implemented recur-
sively by tracking a small number of the most recent digits
of the arithmetic operands. Some languages (e.g., Python)
support infinite-precision integer arithmetic, or perform the
computations at the user-defined precision (e.g., Mathematica).
The GNU library [8] is a popular and efficient implementation
of the multi-precision arithmetic for integer and floating-point
numbers in C programming language. This library is also used
in several commercial software products (e.g., Mathematica
and Maple). There is another the GNU library that is intended
for multiple-precision floating point numbers [9], and another
similar library for multiple-precision complex numbers [10].
Both these libraries are supported in all major programming
languages. They focus on implementing the basic but fast
arithmetic operations involving univariate polynomials and
interpolations, however, without controlling the rounding of
the results. The smallest and the largest integers and single
and double precision floating point numbers are defined in the
Matlab toolbox Elementary Matrices, and in the C standard
libraries limits.h and float.h.
In general, the algorithms described in various programming
languages represent the numbers as strings of digits in a
given basis. In particular, the number, N ∈ N , in basis, B,
is represented as,
N =
imax
∑
i=imin
Di ×Bi
↔
DimaxDimax−1 ···D1D0 ...D−1 ···Dimin
(4)
where the digits, Di ∈ {0,1,...,9,A,B,C,...B − 1}, and the
orders, imin ≤ 0 ≤ imax. Furthermore, it is customary to place a
decimal point between the digits, D0, and, D−1, which divides
the digits into an integral and a fractional part, respectively.
More importantly, the decimal point has a purely syntactical
meaning to align the numbers in the arithmetic operations and
comparisons.
In programming and computing applications, the most
common bases are decimal (B = 10), hexadecimal (B = 16),
and binary (B = 2). However, internally, the numbers are
stored much more efficiently in a byte-size oriented basis, i.e.,
B = 28×#bytes−1, with one bit reserved for a sign to indicate
whether the number is negative. The total number of bytes
used for each numerical value is usually fixed for different
classes (types) of numbers including short and long integers,
and single and double precision floating point numbers. The
conversions between the string notation and the internal rep-
resentation are performed automatically by the compiler.
The textbook [4] provides a comprehensive overview of the
number systems that are used on computers. The computability
of functions of natural numbers is established in [11]. The
mismatch between the exact mathematical description and
practical implementation of algorithms using the approximate
number representations has been studied in [12] including
the methods how to mitigate the discrepancies. A construc-
tion of the large-scale real numbers, which are suitable for
software implementation is considered in [13]. The binary
approximations of real-numbers are investigated in [14]. Other
representations of real numbers such as binary expansions,
Dedekind cuts and Cauchy sequences are compared in [3].
The p-adic number systems allow defining real-numbers as
the arithmetic of rational numbers [15]. The logical statements
involving comparisons of real-numbers are studied with the
help of satisfiability modulo theories in [16]. The article [17]
argues that finite precision is often sufficient in many prac-
tical engineering applications. The most important number-
theoretic theorems and conjectures can be found in [18].
In this paper, it is argued that the number systems commonly
used on computers can be assumed to be integer-valued,
151
International Journal on Advances in Systems and Measurements, vol 16 no 3 & 4, year 2023, http://www.iariajournals.org/systems_and_measurements/
2023, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

which also includes single and double precision floating point
numbers and the corresponding arithmetic operations. Conse-
quently, the computing machines are inherently governed by
integer algebras and arithmetic. The paper contributions are
formulated as three claims, a proposition and several lemmas.
In particular, in Section II, dual modulo operator is introduced
to select or to discard the digits in the string representations of
numbers. It can be exploited to define equivalences between
numbers in integer arithmetic. In addition, it is proposed
that natural numbers can be offset by a real-valued constant,
and still be considered as being integers. The Fermat last
theorem (FLT) is studied in Section III as an example of
Diophantine equation involving integers. The Fermat metric
is newly defined, which is then used to compute the distances
between natural numbers, and to cluster natural numbers
into subsets. A new Section IV has been added to devise
a quantization scheme that supports arithmetic operations.
Discussion is provided in Section V, and the paper is concluded
in Section VI.
II. MACHINE INTEGERS AND ARITHMETIC
The key observation is that finite-size data structures can
only represent a finite set of numerical values. Constraining
machine computations to the numbers, N , has several funda-
mental consequences. First, the results of arithmetic operations
can overflow the limits, inf(N ), or, sup(N ). Second, the
results of arithmetic operations can underflow the precision,
ε0, so the results may have to be truncated, rounded, or
otherwise approximated. Third, the decimal point to align the
numbers can be arbitrarily placed in-between any digits as
long as the placement is consistent in the number system and
the arithmetic considered. This is formalized in the following
claim.
Claim 1. The machine numbers that are allocated a finite
memory space can be uniquely represented by a set, N , which
is isomorphic to a finite ordered subset of integers, Z ⊆ Z.
The important consequence is that (without a formal proof)
any machine arithmetic is isomorphic to the integer arithmetic.
However, implementing such a integer arithmetic at large scale
and precision to be efficient and also error-free is non-trivial.
It raises important questions about how to optimally represent
mathematical models on computers under the number repre-
sentation constraints as well as how to model the underlying
computations.
The memory allocated by the compilers of programming
languages allows adding only a finite number of digits before
and after the decimal point. If the numbers are padded by
zero-digits from both ends, the numbers are represented by
the strings of the same length, and the decimal point becomes
a hypothetical construct. The non-zero digits at the right end of
the number string represent the precision (resolution), whereas
the first non-zero digits from the left represent the scale.
The algorithms usually contain many logical statements
(predicates). These statements involve comparisons of numer-
ical values. Even analog computers can compare numerical
values, e.g., against a threshold, only with a certain resolution.
In general, any two numerical values can only be compared
reliably, if they are represented with an infinite precision. On
the other hand, two integers are said to be exactly equal,
provided that all digits in their string representations are the
same. The exact comparison can be rather restrictive in some
applications, where the differences in scale and precision
could be or must be tolerated. Specifically, if the differences
are tolerated in precision (the right-end sub-strings), it is
equivalent to comparing the quantized values. On the other
hand, if the differences are tolerated at scale (the left-end
sub-strings), it induces the periodicity, and it is equivalent to
comparing the periodically repeated values.
Mathematically, removing the right-end or the left-end sub-
strings from the string representation of a number can be
expressed by a canonical modulo operator. In particular, for
any integer a, and any positive integer b, let, (a mod b) =
(|a| mod b) ∈ {0,1,...,b−1}, be a reminder after the integer
division of a by b. Note that this can be readily extended
to the real numbers as, 0 ≤ (a mod b) = (|a| mod b) < b,
assuming the real division of, a ∈ R , by an integer, b. Then,
the numbers, a1, and, a2, are said to be equivalent in the sense
of congruence, provided that, a1 ≡ a2 (modb). Both equality
(indicated by the symbol, =) and equivalence (indicated by
the symbol, ≡) satisfy the axiomatic properties of reflexivity,
symmetry, and transitivity, and the equality implies the equiv-
alence. Moreover, if the two numbers are not congruent after
comparing their modulo values, then these numbers are not
equal even without using modulo operator.
If the machine numbers, Ni = ∑L−1
i=0 DiBi, are represented by
the strings of L digits in some basis B, then the first L1 digits
and the last L2 digits, (L1+L2) < L, can be zeroed by applying
a dual modulo operator, which is introduced next.
Definition 1. The dual modulo operator has two parameters,
m1, and, m2, and it is defined as the difference,
Ni Mod(m1,m2) = (Ni mod m1)−(Ni mod m2)
= 0···0
| {z }
L1
DL−L1−1 ···DL2+1DL2 0···0
| {z }
L2
.
(5)
where m1 = BL−L1, and m2 = BL2.
It should be noted that representing the numbers in different
bases does not change their semantic meaning. There is a one-
to-one mapping between different representations, so they are
mathematically equivalent. However, they are not equivalent
in the string operations.
The modular arithmetic with dual modulo operator has
similar properties as the arithmetic involving canonical modulo
operator. In particular, given the integers, a, b, m1, and m2,
then,
a Mod(0,m2) = a−(a mod m2)
a Mod(m1,1) = a mod m1
a Mod(m1,m1) = 0.
(6)
152
International Journal on Advances in Systems and Measurements, vol 16 no 3 & 4, year 2023, http://www.iariajournals.org/systems_and_measurements/
2023, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Furthermore, it is straightforward to prove that,
a+b ≡ a Mod(m1,m2)+b Mod(m1,m2) (Mod(m1,m2))
a−b ≡ a Mod(m1,m2)−b Mod(m1,m2) (Mod(m1,m2))
a·b ≡ a Mod(m1,m2)·b Mod(m1,m2) (Mod(m1,m2)).
(7)
However, in general, assuming the integer division with a
reminder, one has,
a/b ̸≡ a Mod(m1,m2)/b Mod(m1,m2) (Mod(m1,m2)).
(8)
The Chinese reminder theorem [18] can be restated for the
dual modulo operator as follows. If m11 and m12 are co-prime,
and,
Ni ≡ a1 (Mod(m11,m2))
Ni ≡ a2 (Mod(m12,m2))
(9)
for some integers, Ni, and, m2, then there is a unique integer,
a, such that,
Ni ≡ a (Mod(m11m12,m2)).
(10)
The proof is based on the property that, if Ni ≡ a (mod m1),
then also, Ni ≡ a (Mod(m1,m2)).
It is useful to consider how the machine integers used in
algorithms are the approximations of infinite precision real-
numbers that are normally obtained from the mathematical
analysis. The dual modulo operator defined in (5) produces
a finite-length integer, x Mod(m1,m2), from a real number,
x ∈ R . This introduces a periodicity due to truncation from
the left (specified by the parameter, m1), and the quantization
due to truncation from the right (specified by the parameter,
m2).
Furthermore, define countably infinite integer sets,
˜Nx = {x,x+1,x+2,...}
(11)
which are parameterized by a finite real-valued constant, x ∈
R , so that, ˜N0, is the set of natural numbers. Such integer sets
can provide the exact solutions to some integer (Diophantine)
problems, which otherwise do not have any such a solution.
More importantly, for all finite x, the integers, ˜Nx, satisfy
Peano axioms except the first one, i.e., that the first element
in the integer set represents a zero [18]. Peano arithmetic
includes both addition and multiplication, and it is known to
be incomplete and undecidable whilst its consistency cannot
be proven as can be shown by the G¨odel’s incompleteness
theorems. However, when multiplication is dropped, Peano
arithmetic becomes Presburger arithmetic, which is consistent,
complete and decidable. More importantly, both Peano as well
as much weaker Presburger arithmetic can be used to define
the set of natural integers.
III. CASE STUDY: FLT PROBLEMS
The FLT is the most famous special case of a Diophantine
equation. It is considered here for illustration of the effects
of the number representations used on computing machines.
The FLT states that there are no positive integers a, b, c, and
n > 2, such that,
an +bn = cn.
(12)
This has been first verified numerically on computers for
very large exponents until a formal mathematical proof was
established only recently [18]. It is straightforward to show
that the case of coefficients, a, b, and c being rational numbers
(i.e., they are expressed as the integer fractions) is only a
special case of the more general FLT. This is also the case
when the exponent, n, is a rational number, and so neither this
special case have any solution among the integer coefficients.
Specifically, if n = m/(m + k), where m and k are integers,
k ̸= −m, we get, ak +bk = (ab/c)k, i.e., a special case of the
FLT. Interestingly, the FLT can be equivalently rewritten as a
condition for the arithmetic average of the integer products,
i.e.,
anbncn = 1
2 ((an+1)(bn+1)(cn −1)+(an −1)(bn −1)(cn+1)).
(13)
Another equivalent formulation of the FLT involves the infinite
sets, S1 = {an +bn : a,b ∈ N0}, and, S2 = {cn : c ∈ N0}; the
FLT then states that the intersection, S1 ∩S2 = /0 (empty set),
for all the exponents, n > 2.
In addition, constraining the maximum difference as, |an +
bn−cn| ≤ 1, has a trivial solution, a = 1, and, b = c, for ∀n ≥ 1.
Note also that the Fermat Number Transform (FNT) resembles
the Discrete Fourier Transform (DFT), however, the former
assumes the sums modulo a prime [19].
More importantly, the original formulation of the FLT can
be modified as follows to allow the solutions to exist.
Claim 2. For every n, there exist infinitely many natural
integers a, b, c, m1 and m2 satisfying the congruence,
an +bn ≡ cn (Mod(m1,m2)).
(14)
For example, assuming the first 100 natural numbers repre-
sented as the strings of l = 9 digits in the basis, B = 8, and,
B = 10, respectively, the total number of solutions, nl, and, nr,
of (14), for the first l1 digits, and for the last l2 = l −l1 digits
is given in Table I. We can observe that, always, nl > nr, since
the number strings often contain zeros at the left end in order
to make up the given string width, l.
TABLE I. The number of solutions of (14) among the first 100 integers
B = 8
B = 10
n = 3
n = 4
n = 3
n = 4
(l1,l2)
(3,6)
(4,5)
(3,6)
(4,5)
(3,6)
(4,5)
(3,6)
(4,5)
nl
69627
22278
5505
2318
1284
44532
10666
3622
nr
212
644
730
2076
198
207
230
596
The following FLT formulation utilizes the integers with a
fixed offset that were defined in (11).
Claim 3. For any integer exponent, n ≥ 1, the equation,
an +bn = cn
(15)
153
International Journal on Advances in Systems and Measurements, vol 16 no 3 & 4, year 2023, http://www.iariajournals.org/systems_and_measurements/
2023, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

has infinitely many solutions among the integers, a,b,c ∈
∪x ˜Nx, for specific real-values, x > 0.
Proof. Let c = y ∈ R , a = y−d1, and, b = y−d2, where d1 and
d2 are the arbitrarily chosen positive natural integers. Then,
for any n, the polynomial (15) has at least one real-valued
solution, y > max(d1,d2). Let d0 = ⌊y⌋ (floor function), so
that x = (y−d0) < 1. This defines the positive integer solution,
c = d0+x, a = d0−d1+x, and b = d0−d2+x, from the integer
set, ˜Nx.
■
The Euler’s conjecture from the year 1769 states that the
n-th power of a positive integer cannot be expressed as a sum
of a fewer than n, n-th powers of other integers. This has
been disproved in 1966 by finding the counterexample, 275 +
845 +1105 +1335 = 1445, using a computer search [20]. An-
other counterexample, 26824404 +153656394 +187967604 =
206156734, was obtained in [21] using theoretical methods.
More precise formulation of determining the number of m-
th power summands is known as the Waring’s problem [22].
The further generalization of the Euler-Fermat equation was
examined in [23] by assuming a weighted sum of the m-th
power summands with the integer weights. Another variation
of the Euler’s sum was recently considered in [24].
A weaker form of the Euler’s conjecture can be stated as
follows.
Proposition 1. For any natural integer, n, there exists an
integer, m ≥ n, such that the expression,
m
∑
i=1
an
i = bn
(16)
is satisfied for a set of natural integers, {a1,a2,...,am}∪{b}.
The proof of Proposition 1 appears to be rather non-trivial,
except when n = 1 and n = 2 (Pythagorean theorem); the
interested readers are referred to [21]–[24] for more in-depth
investigations of this problem. However, it is easy to find
examples among the smallest integers satisfying expression
(16), i.e.,
32 +42 = 52 (m = n = 2)
33 +43 +53 = 63 (m = n = 3)
24 +24 +34 +44 +44 = 54 (m = n+1 = 5)
195 +435 +465 +475 +675 = 725 (m = n = 5).
(17)
In general, the sequence, an +bn, obtained by enumerating
all natural integers, a, and, b, becomes rapidly very sparse as
the exponent, n, is increased. Moreover, given n, it is easy to
show that the best approximation of (an+bn) by cn is obtained
for, c = ⌊(an + bn)1/n⌉ (rounding function). It motivates the
following distance metric for the pairs of natural integers.
Definition 2. The Fermat metric for positive numbers, a, and,
b, is computed as,
Fn(a,b) = an +bn −⌊(an +bn)1/n⌉n
(18)
where n = 2,3,... is a natural number, and, F1(a,b) = 0, for
any a and b. The Fermat distance between the numbers, a,
and, b, is then the absolute value of the Fermat metric, i.e.,
Dn(a,b) = |Fn(a,b)|.
(19)
Note that rounding in (18) can be replaced with the floor
function or the ceil function to obtain the Fermat metric values
that are always positive or always negative, respectively. The
floor and ceil functions can be also used to find the largest
integer, cmax, and the smallest integer, cmin, respectively, that
are bounded as, cn
max < an +bn < cn
min, for n > 2.
The distributions of the Fermat metric values by enumerat-
ing all pairs of natural integers up to 105 are shown in Figure 2,
for n = 2 and n = 3, respectively. It can be observed that the
Fermat metric values are spread much more evenly for n = 2,
and these distributions have no obvious symmetry.
-1000
-500
0
500
1000
0
5
10 5
(A)
-1000
-500
0
500
1000
0
5
10 5
(B)
Figure 2. The counts of the Fermat distance values for all pairs of natural
integers up to 105, and the exponent n = 2 (A), and n = 3 (B).
The Fermat distance can be used to cluster natural integers
into subsets. Figure 3 shows a dendrogram of the Fermat dis-
tances, F2(a,b). The corresponding assignment of the first 50
natural numbers into the four subsets based on the distances,
D2, D3, D4, and D5 are then shown in Figure 4.
IV. CASE STUDY: MIXED ARITHMETIC AIDED
QUANTIZATION
The unconstrained real-valued numbers that are used in
mathematically defined computing models must be eventually
represented as numerical values that are constrained by the
representations in software and hardware. As discussed above,
the numerical values that are represented as finite-memory
data objects can be equivalently considered to represent finite
sets of integers. The process of approximating continuous real
values by discrete values is referred to as quantization. The
normally assumed equidistant quantization levels may become
problematic, when the number of quantization levels that can
be represented by the finite-size data structures is relatively
small. A common solution is to scale-down the real values,
154
International Journal on Advances in Systems and Measurements, vol 16 no 3 & 4, year 2023, http://www.iariajournals.org/systems_and_measurements/
2023, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

 4 211117  1 1422  2 1518  3  5  7  6  9 20  8 1224131019162325
10
20
30
40
50
60
70
Figure 3. The dendrogram of natural numbers constructed assuming the
Fermat distance, D2(a,b), defined in (19).
0
10
20
30
40
50
n=2
n=3
n=4
n=5
Clust. 1
Clust. 2
Clust. 3
Clust. 4
Figure 4. The first 50 natural numbers partitioned into four clusters (subsets)
using the Fermat distances, Dn(a,b), for n = 2,3,4, and 5.
and to limit these values to a finite-length interval prior to
quantization. However, this reduces the resolution as well as
the dynamic range that can be represented by the quantized
values. Here, we consider designing a quantization scheme
that is constrained by the modular and mixed arithmetic in
order to obtain a non-uniform quantization with more effective
mapping of real numbers to unique positive integers.
In particular, any real number, v ∈ R , can be expressed as,
v =q·w+r,
r =v mod w
(20)
where the quotient, q ∈ Z, and, −w < r < w, denotes the
reminder for the chosen real positive parameter, w ∈ R +.
Since q can be stored as a signed integer, or it can be
completely dropped in some applications, our task is to define
the quantization function as the mapping,
Q : [−w,w] 7→ {r0,r1,...,rK}
(21)
which maps the reminder, r, to a unique value from the set of
(K +1) values, such that,
−w ≤ r0 < r1 < ··· < rK ≤ w.
(22)
It is customary to select the quantized values that minimize
the Euclidean distance to the input sample, r, i.e.,
rk = argmin0≤k≤K ∥r −rk∥.
(23)
The quantization levels, rk, should be defined as an increas-
ing function of the quantization labels, k, i.e., rk1 < rk2, if and
only if, k1 < k2. Furthermore, it is desirable to control the non-
uniformity of the quantization levels, and to also compute the
index, k, from the quantized value, rk. These requirements can
be satisfied by an n-th order polynomial having a single root
with multiplicity, n. Hence, define,
rk = Ja,z,n(k) = a(k +z)n
(24)
where a > 0 and z ∈ R are the real constants. Note that the
function, Ja,z,n(k), has an even symmetry about the vertical
axis at the point, k = −z, if k is even, and it has an odd
symmetry about the point, k = −z, if k is odd. Moreover, for
any n, the minimum of |Ja,z,n| occurs at k = −z.
In addition, function (24) is invertible, i.e.,
k = J (−1)
a,z,n (rk) =

± np
rk/a−z,
rk > 0, n−even
np
rk/a−z,
n−odd.
(25)
More importantly, the quantization can be further con-
strained to achieve the equivalence between the arithmetic of
real quantization values, rk, and the arithmetic of correspond-
ing quantization indices, k. In particular, provided that,
rk1 ⃝rk2 = rk3
(26)
where ⃝ denotes a binary arithmetic operation, such as
addition, subtraction, multiplication or division, it is required
that the corresponding quantization indices satisfy another
arithmetic relation (in general, different from the one used
for quantization values above), i.e.,
k1 □ k2 = k3.
(27)
For instance, assuming binary addition for both the quan-
tized values and the corresponding quantization indices, it is
required that,
rk1 +rk2
=
rk3
Ja,z,n(k1)+Ja,z,n(k2)
=
Ja,z,n(k3)
a(k1 +z)n +a(k2 +z)n
=
a(k3 +z)n.
(28)
The solution of (28) is formalized by the following lemma.
Lemma 1. For any integers, k1,k2,k3 ∈ Z, eq. (28) has exactly
one real solution in z, if n is odd, and there are exactly two
real solutions, when n is even.
Proof. For addition, the multiplicative constant, a > 0, can
be eliminated, and we need to solve, (k1 + z)n + (k2 + z)n =
(k3+z)n, for z. The function, Ja,z,n(k), defined in (24) is strictly
convex for n being even, and non-negative for any k and z. The
155
International Journal on Advances in Systems and Measurements, vol 16 no 3 & 4, year 2023, http://www.iariajournals.org/systems_and_measurements/
2023, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

sum of convex functions remains convex [25]. The minimum
of the left-hand side addition occurs for z = −(k1 + k2)/2,
which is independent of n. It is then straightforward to show
that any two convex functions, which have an unlimited
support intersect at exactly two points. On the other hand, the
function, Ja,z,n(k), for n-odd, is strictly increasing everywhere,
and there is exactly one point where two such functions with
an infinite support intersect. The solution can be obtained
in a closed form for n ≤ 3, otherwise it can be computed
numerically.
■
Note that the scaling by a used in (28) affects numerical
accuracy of the solution, especially for larger values of n.
Moreover, z = −k2 is the solution of (28), if and only if,
k1 = k3, for any exponent, n. In addition, provided that the
quantization values were defined as, Ja,z,n = kn − b, where
b ∈ Z, then eq. (28) becomes, kn
1 + kn
2 = kn
3 + b, and it can
be satisfied for any integer coefficients k1, k2 and k3, by
appropriate choice of b.
Assuming multiplication instead of summation in (28), we
need to solve,
a2(k1 +z)n(k2 +z)n = a(k3 +z)n
(29)
for z, which is formalized by the next lemma.
Lemma 2. For any integers, k1,k2,k3 ∈ Z, eq. (29) has exactly
two real solutions,
z = 1
2a

1−ak1 −ak2
±
q
(1−ak1 −ak2)2 −4(ak1ak2 −ak3)

(30)
provided that, (1 − ak1 − ak2)2 > 4(ak1ak2 − ak3), and n is
odd. If n is even, there are two more solutions,
z = −1
2a

1+ak1 +ak2
±
q
(1+ak1 +ak2)2 −4(ak1ak2 +ak3)

(31)
provided that, (1+ak1 +ak2)2 > 4(ak1ak2 +ak3).
Proof. Eq. (29) can be converted to a quadratic equation, for
which the solution is well known.
■
The properties stated in Lemma 1 and Lemma 2 can be
exploited to define the mixed arithmetic, such that binary com-
putations between analog quantized values can be equivalently
performed as binary computations between the corresponding
discrete indices as illustrated in Figure 5. It may be desirable,
but not necessary to assume that the same binary operation
is used in both the analog and the digital domains. For
example, the quantization levels can be defined, so that the
sum, r1 +r2 = r3, in the analog domain is fully equivalent to
computing the sum, k1 +k2 = k3, in the discrete domain. This
is formalized by the following lemma.
Lemma 3. Consider a binary arithmetic operation, k3 =
k1 □ k2, such as addition, subtraction, multiplication, or
division. Then, for any two integers k1 and k2 from the set,
{0,1,2,...,K}, and a given exponent, n, there exist, z ∈ R ,
and, a ∈ R +, so that, a binary computation, Ja,z,n(k1) ⃝
Ja,z,n(k2) = Ja,z,n(k3), is exact, where the function, Ja,z,n, has
been defined in (24).
Proof. The key result for addition and multiplication has been
proven in Lemma 1 and Lemma 2, respectively. However, now,
the proof is further constrained by requiring that k3 = k1 □ k2.
The cases of subtraction and division can be converted to
addition and multiplication, respectively; for the latter, one
should consider, k3 = k1/(1 + k2), in order to avoid division
by zero, when k2 = 0.
■
□ ∈ {+, −,×,÷}
⃝ ∈ {+, −,×,÷}
rk1 ⃝ rk2 = rk3
J (k)
k1 □ k2 = k3
J (−1)(r)
Figure 5. Binary computations for discrete indices (on the left) can be
uniquely mapped to binary computations between the corresponding
quantized values (on the right).
In practice, it is useful to compute a look-up table of z values
that are indexed by the integer tuples, (k1,k2) as shown in
Table II and Table III assuming binary operations of addition
and multiplication, respectively. For example, if k1 = 1 and
k2 = 3, then k3 = 1+3 = 4, and we can numerically compute,
z .= 5.01; then, a(k1 +z)3 .= 435.78, a(k2 +z)3 .= 1030.72, and
a(k3 +z)3 .= 1466.50 = 435.78+1030.72. This calculation can
be verified for all other rows in Table II and Table III.
More importantly, the quantization levels generated by
function (24) are symmetric as shown in the next lemma. This
can be used to calculate the quantized values also for negative
indices.
Lemma 4. The addition of quantized values has the following
symmetry:
Ja,−z,n(−k1)+Ja,−z,n(−k2) =







Ja,z,n(k1)+Ja,z,n(k2),
n−even
−Ja,z,n(k1)−Ja,z,n(k2),
n−odd.
(32)
Proof. The property is a direct consequence of the even or
odd symmetry of function Ja,z,n defined in (24), for n being
even or odd, respectively.
■
It should be emphasized that the calculated values of z are
functions of the indices k1 and k2 as well as of the binary
operations considered. The real-valued offsets, z, of the integer
indices in the analog domain are necessary in order to enable
a one-to-one mapping between the binary calculations in the
discrete and the analog domains, respectively. Consequently,
such a mapping defines a two-dimensional non-uniform vector
quantization as indicated in Figure 6 assuming the examples
156
International Journal on Advances in Systems and Measurements, vol 16 no 3 & 4, year 2023, http://www.iariajournals.org/systems_and_measurements/
2023, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

TABLE II. The index addition, k1 +k2, corresponding to the analog
summation, r1 +r2 = Jz(k1)+Jz(k2), for a = 2.0 and n = 3
k1
k2
r1
r2
r1 +r2
z
0
0
0
0
0
0
0
1
0.00
2.00
2.00
0.00
0
2
−0.00
16.00
16.00
−0.00
0
3
−0.00
54.00
54.00
−0.00
1
0
2.00
0.00
2.00
0.00
1
1
113.89
113.89
227.79
2.84
1
2
258.27
443.89
702.16
4.05
1
3
435.78
1030.72
1466.50
5.01
2
0
16.00
−0.00
16.00
−0.00
2
1
443.89
258.27
702.16
4.05
2
2
911.16
911.16
1822.32
5.69
2
3
1453.61
1994.59
3448.20
6.99
3
0
54.00
−0.00
54.00
−0.00
3
1
1030.72
435.78
1466.50
5.01
3
2
1994.59
1453.61
3448.20
6.99
3
3
3075.17
3075.17
6150.34
8.54
TABLE III. The index multiplication, k1 ·k2, corresponding to the analog
multiplication, r1 ·r2 = Jz(k1)·Jz(k2), when a = 2.0 and n = 3
k1
k2
r1
r2
r1 ·r2
z
0
0
1.00
1.00
1.00
+0.79
0
1
−0.01
1.22
−0.01
−0.15
0
2
−0.00
16.00
−0.00
−0.00
0
3
−0.00
54.00
−0.00
−0.00
1
0
1.22
−0.01
−0.01
−0.15
1
1
1.00
1.00
1.00
−0.20
1
2
1.00
11.54
11.54
−0.20
1
3
1.00
43.60
43.60
−0.20
2
0
16.00
−0.00
−0.00
−0.00
2
1
11.54
1.00
11.54
−0.20
2
2
10.13
10.13
102.77
−0.28
2
3
9.51
38.56
366.81
−0.31
3
0
54.00
−0.00
−0.00
−0.00
3
1
43.60
1.00
43.60
−0.20
3
2
38.56
9.51
366.81
−0.31
3
3
35.75
35.75
1278.73
−0.38
in Table II and Table III. For n = 1, the quantized values are
spaced uniformly, and they become more expanded when n
is increased. The quantization values can be also scaled by
adjusting the parameter, a.
0
500
1000
1500
2000
2500
3000
3500
xx
0
1000
2000
3000
yy
Addition
-10
0
10
20
30
40
50
60
xx
0
20
40
60
yy
Multiplication
Figure 6. A two-dimensional vector quantization levels for the examples in
Table II and Table III.
V. DISCUSSION
The main claim of this paper is that all numerical values
that are represented by the finite-memory data structures on
any computing machine can be considered to be integers. It is
a mathematical property, which is unaffected how the values
are actually stored in software and hardware, e.g., using the
fixed point or floating point number representations. This has
a number of fundamental consequences. In particular, math-
ematical models on computing machines can be represented
by systems of Diophantine equations. These equations have
been studied extensively in the literature, and there is a rich
mathematical theory available to understand their properties.
It may be claimed that any computer program or algorithm
implemented in actual software and hardware can be modeled
as a generator of the integer sequences. The integer sequences,
in turn, can be generated by multivariate polynomials with
the integer coefficients and integer variables. Such integers
are then referred to as Diophantine sets; these sets are com-
putably enumerable by Diophantine polynomials (the MRDP
theorem). Unfortunately, there is no algorithm that could find
the integer roots of general polynomials in several variables
with the integer coefficients, or just to determine, if such a
solution might even exist. Hence, there is a large gap between
mathematical description based on the real analysis, and the
actual implementation of algorithms on the computers [12].
Furthermore, once the numbers on computing machines
are considered to be integers, the meaning of decimal point
becomes mainly syntactical to allow aligning the operands
in arithmetic operations. Improving the accuracy of machine
numbers by p-adic representations [15] and by Diophantine
approximations [26] is impractical, since the corresponding
arithmetic operations would require more time and consume
more memory. There are several efficient multi-precision arith-
metic C-libraries that are available as open-source. Crucially,
in many practical applications, the finite accuracy is often
sufficient [17]. There are, however, scenarios when the full
accuracy is required, for example, in cryptography [27].
The FLT was considered as an example of a Diophantine
equation. Several modifications of the FLT were considered to
allow the solutions to exist, and to explore how the different
number representations affect the solution. Exchanging the
numbers equality for their modulo equivalence immediately
provides many solutions for the FLT, and likely for other
Diophantine problems. The number congruence defined by a
newly introduced double modulo operator induces periodicity,
when the number is cut-off from the left, and it induces
quantization, when the number is cut-off from the right.
Whereas quantization problems have been studied extensively,
it would be very useful to identify the scenarios where the
induced periodicity is not only acceptable, but also useful, for
example, to increase the range of the numerical values that
can be considered.
Another promising strategy for solving Diophantine equa-
tions is to offset all the integers by a constant real value. This
strategy can provide a solution for the roots of at lest some
157
International Journal on Advances in Systems and Measurements, vol 16 no 3 & 4, year 2023, http://www.iariajournals.org/systems_and_measurements/
2023, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

multivariate Diophantine polynomials including the FLT. The
proof was presented for the FLT, but it is likely also feasible for
more general cases. The caveat is that the offsetted integers
break down the validity of arithmetic operations, unless the
offset is determined for each pair of numbers involved in the
specific arithmetic operation. The offsetted integers can be
exploited to define the mixed arithmetic aided quantization,
so that arithmetic operations can be performed either in
the analog domain, or equivalently, in the discrete domain
for the integer indices. This was achieved by assuming a
simple exponential function mapping the integer indices to the
discrete real values, which can be also used for quantization.
Other functions could be considered for other binary arithmetic
operations and even more complex computations.
The future work can define and prove other mathematical
properties of the machine numbers and the associated integer
arithmetic. It can lead to more efficient design of integer-
based models and architectures for large-scale computing
machines as well as the improved approximations of complex
mathematical models. The focus should be on transforming
mathematical models using unconstrained numerical values to
their constrained representations on the computing machines
with limited resources. The interval arithmetic, which was
briefly mentioned, but otherwise not considered, could be
developed further towards this goal. Moreover, the rich theory
involving integer sets including Diophantine equations, ordinal
and cardinal arithmetic could be utilized to more formally
describe the key characteristics of computing systems as the
integer processing machines. There are also many fundamental
theoretical results that can be adopted for the integer rep-
resentations of computer programs, which are provided by
Presburger and Peano arithmetic, interval arithmetic, and the
G¨odel’s incompleteness theorems.
VI. CONCLUSION
The paper investigated the problem of representing the
numerical values on computing machines as the finite-memory
data objects. Such numbers can be then treated as integers.
The other key ideas introduced in the paper were defining the
equivalences between the numbers assuming only subsets of
digits in their number string representations, and considering
the sets of natural numbers offset by the real-valued constants.
The dual modulo operator was introduced, which allows
removing the most significant and the least significant digits.
The basic properties of arithmetic involving the dual modulo
operator were presented. The FLT was studied as an example
of Diophantine equation. The Fermat metric was introduced to
measure the distances between natural numbers as well as to
cluster general sets of any numbers. Finally, a two-dimensional
non-uniform quantization was introduced to support the mixed
arithmetic with binary operations that can be equivalently
performed in the analog and the discrete domains.
ACKNOWLEDGMENT
This work was funded by a research grant from Zhejiang
University.
REFERENCES
[1] P. Loskot, “On machine integers and arithmetic,” in Proc. 8th Interna-
tional Conference on Advances in Signal, Image and Video Processing
(SIGNAL), Barcelona, Spain, March 13–17, 2023, pp. 63–66.
[2] T. Rado, “On non-computable functions,” Bell System Technical Journal,
vol. 41, no. 3, pp. 877–884, May 1962.
[3] X. Zheng and R. Rettinger, “Weak computability and representation of
reals,” Mathematical Logic Quarterly, vol. 50, no. 4–5, pp. 431–442,
Sep. 2004.
[4] R. T. Kneusel, Numbers and Computers, 2nd ed. Springer International
Publishing, Cham, Switzerland, 2017.
[5] J. L. Gustafson and I. Yonemoto, “Beating floating point at its own game:
Posit arithmetic,” Supercomputing Frontiers and Innovations, vol. 4,
no. 2, pp. 71–86, Jun. 2017.
[6] R. E. Moore, Methods and Applications of Interval Analysis.
Society
for Industrial and Applied Mathematics, Philadelphia, PA, USA, 1979.
[7] T. Hickey, Q. Ju, and M. H. van Emden, “Interval arithmetic: From
principles to implementation,” Journal of the ACM, vol. 48, no. 5, pp.
1038–1068, Sep. 2001.
[8] T. Granlund, “The GNU multiple precision arithmetic library, GNU MP
6.2.1,” https://gmplib.org, Jan. 2020, accessed: 2023-01-30.
[9] G. Hanrot, V. Lef´evre, P. P´elissier, P. Th´eveny, and P. Zimmermann,
“The GNU floating-point computations with correct rounding library
GNU MPFR 4.2.1,” https://www.mpfr.org/, Aug. 2023, accessed: 2023-
09-30.
[10] A. Enge, M. Gastineau, P. Th´eveny, and P. Zimmermann, “The GNU
multi-precision c library rounding library GNU MPC 1.3.1,” https:
//www.multiprecision.org/mpc/, Dec. 2022, accessed: 2023-09-30.
[11] M. Wrocłlawski, “Representations of natural numbers and computability
of various functions,” in Conference on Computability in Europe, 2019,
pp. 298–309.
[12] R. Krebbers and B. Spitters, “Type classes for efficient exact real
arithmetic in Coq,” Logical Methods in Computer Science, vol. 9, no.
1:01, pp. 1–27, Feb. 2013.
[13] R. O’Connor, “A monadic, functional implementation of real numbers,”
Mathematical Structures in Computer Science, vol. 17, no. 1, pp. 129–
159, 2007.
[14] J. van der Hoeven, “Computations with effective real numbers,” Theo-
retical Computer Science, vol. 351, pp. 52–60, 2006.
[15] F. Q. Gouvˆea, p-adic Numbers: An Introduction, 3rd ed.
Springer,
Cham, Switzerland, 2020.
[16] G. Kremer, F. Corzilius, and E. ´Abrah´am, “A generalised branch-and-
bound approach and its application in SAT modulo nonlinear integer
arithmetic,” in Computer Algebra in Scientific Computing, vol. 9890,
2016, pp. 315–335.
[17] NASA/JPL
Edu,
“How
many
decimals
of
Pi
do
we
really
need?”
https://www.jpl.nasa.gov/edu/news/2016/3/16/
how-many-decimals-of-pi-do-we-really-need, Oct. 2022, accesssed:
2023-01-30.
[18] T. Gowers, J. Barrow-Green, and I. Leader, The Princeton Companion
to Mathematics. Princeton University Press, Princeton, NJ, USA, 2008.
[19] M. Kˇri´ıˇzek, , F. Luca, and L. Somer, 17 Lectures on Fermat Numbers:
From Number Theory to Geometry.
Springer New York, USA, 2001,
ch. Fermat Number Transform and Other Applications, pp. 165–186.
[20] L. J. Lander and T. R. Parkin, “Counterexample to Euler’s conjecture
on sums of like powers,” Bulletin of AMS, p. 1079, Nov. 1966.
[21] N. D. Elkies, “On A4+B4+C4=D4,” Mathematics of Computation,
vol. 51, no. 184, pp. 825–835, Oct. 1988.
[22] W. K. Hayman, “Waring’s theorem and the super Fermat problem for
numbers and functions,” Complex Variables and Elliptic Equations,
vol. 59, pp. 85–90, Jan. 2014.
[23] L. N. Vaserstein and E. R. Wheland, “Vanishing polynomial sums,”
Communications in Algebra, vol. 31, no. 2, pp. 751–772, 2003.
[24] T. Cai and Y. Zhang, “A variety of Euler’s sum of powers conjecture,”
Czechoslovak Mathematical Journal, vol. 71, pp. 1099–1113, May 2021.
[25] S. Boyd and L. Vandenberghe, Convex Optimization.
Cambridge
University Press, Cambridge, UK, 2004.
[26] B. Church, “Diophantine approximation and transcendence theory,” Apr.
2019, Lecture Notes.
[27] J. Hoffstein, J. Pipher, and J. H. Silverman, An Introduction to Mathe-
matical Cryptography, 2nd ed.
Springer, New York, NY, USA, 2014.
158
International Journal on Advances in Systems and Measurements, vol 16 no 3 & 4, year 2023, http://www.iariajournals.org/systems_and_measurements/
2023, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

