Multiple-World Extension of Clausal Logical Structures
Kiyoshi Akama
Information Initiative Center
Hokkaido University
Sapporo, Hokkaido, Japan
Email: akama@iic.hokudai.ac.jp
Ekawit Nantajeewarawat
Computer Science Program
Sirindhorn International Institute of Technology
Thammasat University
Pathumthani, Thailand
Email: ekawit@siit.tu.ac.th
Tadayuki Yoshida
Faculty of Computer Science
Hokkaido University
Sapporo, Hokkaido, Japan
Email: tadayuki@sh.rim.or.jp
Abstract—In a simple clausal logical structure, a set of clauses
determines models, each of which is a subset of some prede-
termined set G and represents a possible state of a world. A
multiple-world clausal logical structure is an extension of a simple
clausal logical structure, wherein multiple worlds are considered
simultaneously. Each world model may be related not only to
its corresponding set of clauses, but also to other world models.
We deﬁne a method for multiple-world extension of a clausal
logical structure. By applying this extension, we propose a new
multiple-world clausal logical structure for S-expression atoms
with deﬁnitions of several concrete constraints, which together
provide rich expressive power including function variables and
concepts such as argmax and negation.
Keywords–Multiple-world logical structure; Referential con-
straint; Specialization system; Declarative description.
I.
INTRODUCTION
An abstract notion of a logical structure has been in-
troduced since 2006 [1], by which the general concepts of
descriptions (formulas), interpretations, models, and their inter-
relations are formalized axiomatically. Let G denote the set of
all ground ﬁrst-order atoms. First-order formulas constitute a
logical structure, where interpretations and models are subsets
of G. Similarly, clause sets form another logical structure,
where interpretations and models are again subsets of G. A
logical structure deﬁnes a relation between a description k
and a model x of k, i.e., x ∈ Models(k), where Models is
a mapping that determines the set of all models of a given
description.
Basic methods for construction of logical structures have
been proposed by Akama and Nantajeewarawat [2], including
generation of a logical structure from a specialization system,
construction of a conjunctive logical structure, and logical
structure morphing. Such construction methods are essential
for formulating and understanding new logical structures and
extending existing logical structures to obtain richer expressive
power, computation efﬁciency, and computation completeness
[3].
This paper proposes a new method for constructing logi-
cal structures, by which a logical structure for dealing with
multiple worlds is constructed from simple clausal logical
structures. This is typically explained by the following system
of membership constraints:
xJ ∈ Models(kJ, xJ, xH)
xH ∈ Models(kH, xJ, xH)
They together represent a situation in which there are two
persons, say John and Henry, and their beliefs, say xJ and
xH, respectively, are described by kJ and kH together with the
beliefs themselves.
There are two main important features:
1)
There may be multiple worlds; a pair of a description
and a set of possible models is called a world.
2)
The mapping Models is used and it takes models as
arguments.
By applying this construction method to an S-expression
clausal logical structure, we propose a multiple-world clausal
logical structure for S-expression atoms. We show that this
extension provides rich expressive power.
For example, when we want to ﬁnd all persons who earn
maximum salary in a department, we may write the following
clause:
(h ∗name) ← (argmax ∗name (∗n ∗s) ((emp ∗n ∗a ∗s ∗d))).
The predicate argmax takes three arguments. The third one is
in general a sequence of atoms. Its second and third arguments
are used to represent a relation between names and salaries:
S = {(n, s)|(emp n a s d)}.
We need to maximize s by changing n in the set S. The
predicate argmax can not be deﬁned by usual clauses. By
the theory to be proposed in this paper, argmax is deﬁned as
a new type of constraint. By adding a clause C, given by
C = ((p ∗n ∗s) ← (emp ∗n ∗a ∗s ∗d)),
to a set Cs of clauses, the new multiple-world semantics
proposed in this paper allows us to construct a constraint that
refers to a model of Cs ∪ {C}, and thus, to refer to its subset
S.
Multiple-world extension of clausal logical structures is
also useful for representing other database constraints such
as max, min, summation, and average. Moreover negation
is also represented by using the same semantics. Together
with function variables, the proposed logical structure has a
very rich expressive power that is purely declarative and it
is rigorously formulated based on an abstract deﬁnition of a
logical structure.
55
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-354-4
ADVCOMP 2014 : The Eighth International Conference on Advanced Engineering Computing and Applications in Sciences

The rest of the paper is organized as follows: Section II
recalls an abstract notion of a logical structure and its related
basic concepts, and identiﬁes the main objective of the paper.
Section III provides a general notion of a specialization system,
and deﬁnes a specialization system for S-expressions and
that for function variables and function constants. Section IV
formalizes constraints, deﬁnes declarative descriptions along
with their models, associates with a declarative description a
system of membership constraints, and formulates a logical
structure for declarative descriptions. Section V shows rich
expressive power of an S-expression-based logical structure,
which is directly created by instantiation of the general theory,
by deﬁning constraints and func-atoms, which cannot be sup-
plied by the conventional ﬁrst-order logic. Section VI provides
conclusions.
Preliminary Notation
The following notation will be used. For any sets A and
B, pow(A) denotes the power set of A, Map(A, B) the set
of all mappings from A to B, and partialMap(A) the set of
all partial mappings on A (i.e., from A to A itself). Given a
binary relation r, dom(r) and ran(r) denote the domain and
the range of r, respectively. For any partial mappings f and
g such that dom(f) ⊇ ran(g), f ◦ g denotes the composition
of f with g, i.e., for each a ∈ dom(g), (f ◦ g)(a) = f(g(a)).
Let Bool = {true, false}.
II.
LOGICAL STRUCTURES AND BASIC RELATED
CONCEPTS
A. Logical Structures
An abstract notion of a logical structure [1] is recalled ﬁrst.
Deﬁnition 1: Let G be a set. A logical structure L on G
is a triple ⟨K, I, ν⟩, where
1)
K is a set,
2)
I = pow(G),
3)
ν : K → Map(I, Bool).
An element of K is called a description. An element of I is
called an interpretation.
Given an arbitrary set G, a logical structure L = ⟨K,
I, ν⟩ on G is a representation system. Intuitively, when we
have a subset G of G in mind as a target atom set to be
represented, we can provide information about the target atom
set G using some description k ∈ K, i.e., G satisﬁes the
condition ν(k)(G) = true.
The concept of an interpretation in Deﬁnition 1 is very
different from an interpretation in the usual logic [4][5]. The
set G in Deﬁnition 1 is more similar to the Herbrand Base
[6] for a given description, but they are not exactly the same.
The Herbrand Base depends on a given description (logical
formula). There is no common set like G in the deﬁnition of
the Herbrand Base. However, in our theory, a unique set G
is ﬁrstly given. The objective of deﬁning a logical structure
is to deﬁne a representation system in which a description
determines a set of possible subsets of G.
Despite its simplicity, the abstract notion given by Deﬁni-
tion 1 provides a sufﬁcient structure for deﬁning the concepts
of logical equivalence, models, satisﬁability, and logical con-
sequence, which will be given in Deﬁnition 2.
Deﬁnition 2: Let L = ⟨K, I, ν⟩ be a logical structure. Two
descriptions k1, k2 ∈ K are logically equivalent in L, denoted
by k1 ≡L k2, iff ν(k1) = ν(k2). An interpretation I ∈ I is
a model in L of a description k ∈ K iff ν(k)(I) = true. A
description k ∈ K is satisﬁable in L iff there exists a model
in L of k. A description k1 ∈ K is a logical consequence in
L of a description k2 ∈ K, denoted by k2 |=L k1, iff every
model in L of k2 is a model in L of k1.
For these concepts to have practical meanings, it is neces-
sary to give appropriate structure to elements of K and I and
also to the mapping ν. This process is called logical structure
instantiation, which is illustrated below.
B. Logical Structure Instantiation: Examples
Instantiation of the abstract notion of a logical structure into
ﬁrst-order logic and into a clausal logical system is illustrated
below.
1) First-Order Logic: Let G be the set of all variable-free
atomic formulas (atoms) and K the set of all closed ﬁrst-order
formulas. Let ν be deﬁned by: for any k ∈ K and any G ⊆ G,
ν(k)(G) = true iff k is true with respect to G. Then ⟨K,
pow(G), ν⟩ is a logical structure on G.
2) Clausal Logical Systems: Let G be the set of all variable-
free atoms and K the set of all sets of clauses. Let ν be deﬁned
by: for any k ∈ K and any G ⊆ G, ν(k)(G) = true iff all
clauses in k are true with respect to G. Then ⟨K, pow(G), ν⟩
is a logical structure on G.
C. The Primary Objective of the Paper
The objective of the paper is twofold:
1)
To develop a method for multiple-world extension of
logical structures (Section IV).
2)
To introduce a concrete logical structure in the S-
expression space by the instantiation of the proposed
method (Section V).
The resulting concrete logical structure provides multiple-
world knowledge representation based on an extended space
with (i) clauses and iff-formulas, and with (ii) function vari-
ables and function constants.
III.
SPECIALIZATION SYSTEMS
A. Specialization Systems
The notion of a specialization system [7] is recalled below.
Deﬁnition 3: A specialization system Γ is a quadruple ⟨A,
G, S, µ⟩ of three sets A, G, and S, and a mapping µ from S
to partialMap(A) that satisﬁes the following conditions:
1)
(∀s′, s′′ ∈ S)(∃s ∈ S) : µ(s) = µ(s′) ◦ µ(s′′).
2)
(∃s ∈ S)(∀a ∈ A) : µ(s)(a) = a.
3)
G ⊆ A.
Elements of A, G, and S are called atoms, ground atoms,
and specializations, respectively. The mapping µ is called the
56
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-354-4
ADVCOMP 2014 : The Eighth International Conference on Advanced Engineering Computing and Applications in Sciences

specialization operator of Γ. A specialization s ∈ S is said to
be applicable to a ∈ A iff a ∈ dom(µ(s)).
In the sequel, assume that a specialization system Γ = ⟨A,
G, S, µ⟩ is given. A specialization in S will often be denoted
by a Greek letter such as θ. A specialization θ ∈ S will
be identiﬁed with the partial mapping µ(θ) and used as a
postﬁx unary (partial) operator on A (e.g., µ(θ)(a) = aθ),
provided that no confusion is caused. Let ϵ denote the identity
specialization in S, i.e., aϵ = a for any a ∈ A. For any
θ, σ ∈ S, let θ ◦ σ denote a specialization ρ ∈ S such that
µ(ρ) = µ(σ) ◦ µ(θ), i.e., a(θ ◦ σ) = (aθ)σ for any a ∈ A. A
subset A′ of A is said to be closed iff aθ ∈ A′ for any a ∈ A′
and any θ ∈ S.
B. A Specialization System for S-Expressions
Next, a specialization system for S-expressions is intro-
duced. It will be used for providing concrete examples of
constraints and declarative descriptions in Section V.
An alphabet ∆ = ⟨K, V⟩ is assumed, where K is a
countably inﬁnite set of constants, V is a countably inﬁnite set
of variables, K and V are disjoint, and nil ∈ K. Assume that
K includes the set of all numbers. As notational conventions,
each variable begins with an asterisk (e.g., ∗x), while constants
do not.
An S-expression (symbolic expression) on ∆ is deﬁned
inductively as follows:
1)
A constant in K is an S-expression on ∆.
2)
A variable in V is an S-expression on ∆.
3)
If a and a′ are S-expressions on ∆, then (a|a′) is an
S-expression on ∆.
An S-expression (a1|(a2| · · · |(an|nil) · · · )) is often written as
(a1 a2 · · · an). The S-expression nil is often written as ().
A
substitution
on
∆
is
a
ﬁnite
set
of
bindings
{v1/a1, . . . , vn/an} such that for each i ∈ {1, . . . , n}, vi ∈ V
and ai is an S-expression on ∆ such that vi ̸= ai.
A specialization system ΓS
=
⟨A, G, S, µ⟩ for S-
expressions is deﬁned by:
1)
A is the set of all S-expressions on ∆.
2)
G is the set of all variable-free S-expressions on ∆.
3)
S is the set of all substitutions on ∆.
4)
µ : S → partialMap(A) such that for any a ∈ A and
any s ∈ S, µ(s)(a) is the S-expression obtained from
a by simultaneously applying all bindings in s to a.
C. A Specialization System for Function Variables and Func-
tion Constants
The conventional Skolemization is not a meaning-preserv-
ing transformation [6]. Meaning-preserving Skolemization was
recently developed in [3], in which function variables are used
in place of Skolem functions. For example,
(motherOf ∗x ∗y) ← ⟨ffunc, h1, ∗y, ∗x⟩
is used for representing the statement “every person has his/her
mother”, where h1 is a function variable, which determines
a mother ∗x of ∗y by ∗x = f1(∗y) using some unknown
function f1 obtained by instantiation of h1. The specialization
system ΓF is introduced below for function variables and their
instantiations.
Let FV be the set of all function variables, and let
FC =
[
n∈N
Map(Gn, G),
where N is the set of all nonnegative integers. Elements of
FC are called function constants. Let ΓF be deﬁned as a
specialization system ⟨AF, GF, SF, µF⟩ as follows:
1)
AF = FV ∪ FC,
2)
GF = FC,
3)
SF the set of all substitutions on ⟨FV, FV ∪ FC⟩,
4)
µF : SF → partialMap(AF) such that for any f ∈
AF and any s ∈ SF, µ(s)(f) is obtained from f by
applying the substitution s to it.
IV.
DECLARATIVE DESCRIPTIONS AND THEIR MODELS
A description, called a declarative description, is intro-
duced in this section. Declarative descriptions form a knowl-
edge representation scheme with the following characteristics:
(i) multiple-world representation, (ii) clauses and iff-formulas,
and (iii) function variables and function constants.
A. Constraints
Assume that Γ = ⟨A, G, S, µ⟩ and Γc = ⟨Ac, Gc, S, µc⟩
are specialization systems with the set S of specializations in
common. They are used below, along with the specialization
system ΓF (Section III-C), for deﬁning constraints, clauses,
and declarative descriptions.
A constraint is an expression such that the truth value of its
ground instantiation is predetermined. In this paper, constraint
is represented by using a tuple enclosed by a pair of angle
brackets. A constraint of the simplest type uses only terms as
its arguments, e.g., an equality constraint ⟨feq, t1, t2⟩. We also
use function variables/constants as arguments. For example
⟨ffunc, h0, t, t′⟩ is a constraint with a unary function variable
h0, and it is true iff h0(t) = t′. The most important type of con-
straints for multiple-world semantics is the one that refers to
models of some sets of clauses. For example, ⟨fnot, (p ∗x), l2⟩
is a not-constraint, which has a world label l2 that refers to a
model of a set of clauses. Intuitively, ⟨fnot, (p ∗x), l2⟩ means
that (p ∗x) /∈ model(l2), where model(l2) is a model of the
world l2.
Deﬁnition 4: Let L be a set of labels. A constraint on
⟨Γ, Γc, L, ΓF⟩ is an (m + 1)-tuple ⟨φ, d1, d2, . . . , dm⟩, where
1)
m ≥ 0,
2)
φ : (Gc ∪ G ∪ pow(G) ∪ GF)m → Bool, and
3)
for each i ∈ {1, . . . , m}, di ∈ Ac ∪ A ∪ L ∪ AF.
A constraint ⟨φ, d1, d2, . . . , dm⟩ on ⟨Γ, Γc, L, ΓF⟩ is called
a referential constraint if di is a label in L for some i ∈
{1, . . . , m}. It is called a simple constraint otherwise. It is
called a ground constraint iff for any i ∈ {1, . . . , m}, di ∈ Gc∪
G ∪ L ∪ GF. Let CON(Γ, Γc, L, ΓF) and GCON(Γ, Γc, L, ΓF)
denote the set of all constraints and that of all ground con-
straints, respectively, on ⟨Γ, Γc, L, ΓF⟩.
57
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-354-4
ADVCOMP 2014 : The Eighth International Conference on Advanced Engineering Computing and Applications in Sciences

A specialization θ ∈ S is always applicable to labels and
elements in AF and its application does not change them, i.e.,
for any label l and any a ∈ AF, the results of applying θ
to l and a, denoted by lθ and aθ, are l and a, respectively,
themselves. Given a constraint c = ⟨φ, d1, d2, . . . , dm⟩ and
a specialization θ ∈ S, (i) θ is applicable to c iff it is
applicable to each of d1, d2, . . . , dm, and (ii) when applicable,
the result of applying θ to c, denoted by cθ, is deﬁned by
cθ = ⟨φ, d1θ, d2θ, . . . , dmθ⟩. A specialization θ ∈ SF is
always applicable to elements of Ac∪A∪L, and its application
does not change them. A specialization θ ∈ SF is always
applicable to an element f in AF , and its application changes
it into fθ.
B. Clauses and Iff-Formulas
A declarative description proposed in this paper consists
of clauses and iff-formulas. Some set of clauses can be
equivalently and more concisely represented by an iff-formula
with higher chance of transformation. For example, the set of
three clauses
(q ∗A ∗B), (r ∗B) ← (p ∗A ∗B),
(p ∗A ∗B) ← (q ∗A ∗B),
(p ∗A ∗B) ← (r ∗B)
can be represented by the iff-formula
(p ∗ A ∗ B) ↔ ({(q ∗A ∗B)} ∨ {(r ∗B)}).
Deﬁnition 5: Let L be a set of labels. A clause C on
⟨Γ, Γc, L, ΓF⟩ is an expression of the form
a1, a2, . . . , am ← b1, b2, . . . , bn,
where (i) m, n ≥ 0, (ii) for each i ∈ {1, . . ., m}, ai is an atom
in A, and (iii) for each j ∈ {1, . . . , n}, bj is an atom in A or a
constraint on ⟨Γ, Γc, L, ΓF⟩ (i.e., bj ∈ A∪CON(Γ, Γc, L, ΓF)).
The set {a1, a2, . . . , am} is called the left-hand side of C,
denoted by lhs(C), and the set {b1, b2, . . . , bn} is called the
right-hand side of C, denoted by rhs(C). The set rhs(C) − A
is denoted by con(C). C is called a referential clause if there
exists i ∈ {1, . . . , n} such that bi is a referential constraint.
It is called a simple clause otherwise. It is called a ground
clause iff (i) for each i ∈ {1, . . ., m}, ai ∈ G, and (ii)
for each j ∈ {1, . . . , n}, bj ∈ G ∪ GCON(Γ, Γc, L, ΓF).
Let CL(Γ, Γc, L, ΓF) and GCL(Γ, Γc, L, ΓF) denote the set
of all clauses and that of all ground clauses, respectively,
on ⟨Γ, Γc, L, ΓF⟩. Let GCL(G) denote the set of all ground
clauses that consist only of atoms in G.
Given a clause C = (a1, a2, . . . , am ← b1, b2, . . . , bn) and
a specialization θ ∈ S ∪ SF, (i) θ is applicable to C iff it
is applicable to each of a1, a2, . . . , am, b1, b2, . . . , bn, and (ii)
when applicable, the result of applying θ to C, denoted by Cθ,
is deﬁned by Cθ = (a1θ, a2θ, . . . , amθ ← b1θ, b2θ, . . . , bnθ).
Deﬁnition 6: An if-and-only-if formula (for short, iff-
formula) I on ⟨Γ, Γc, L, ΓF⟩ is a formula of the form
a ↔ (conj1 ∨ conj2 ∨ · · · ∨ conjn),
where (i) n ≥ 0, (ii) a ∈ A, and (iii) each of the conji is a ﬁ-
nite subset of A∪CON(Γ, Γc, L, ΓF). For each i ∈ {1, . . ., n},
conji corresponds to the conjunction V{b | b ∈ conji}
of atoms and constraints in conji, and this conjunction is
denoted by F(conji). The atom a is called the head of the
iff-formula I, denoted by head(I); n is called the number
of conjunctions in I, denoted by #Conj(I); and for each
i ∈ {1, . . . , n}, conji is called the ith conjunction in the right-
hand side of I, denoted by rhsi(I). The set of all constraints
occurring in I is denoted by con(I). I is called a ground iff-
formula if a, conj1, conj2, . . . , conjn are all ground. When
emphasis is given to its head, an iff-formula whose head
is an atom a is often referred to as iff(a). An iff-formula
I = (a ↔ (conj1∨· · ·∨conjn)) corresponds to the universally
quantiﬁed formula ∀(a ↔ (F(conj1)∨· · ·∨F(conjn))), which
is denoted by F(I). Let IFF(Γ, Γc, L, ΓF) and GIFF(Γ, Γc,
L, ΓF) be the set of all iff-formulas and that of all ground iff-
formulas, respectively, on ⟨Γ, Γc, L, ΓF⟩. Let GIFF(G) denote
the set of all ground iff-formulas that consist only of atoms in
G.
If I is an iff-formula a ↔ (conj1 ∨ conj2 ∨ · · · ∨ conjn)
on ⟨Γ, Γc, L, ΓF⟩, then:
•
For any θ ∈ S ∪ SF and any i ∈ {1, . . ., n}, if
conji = {b1, b2, . . . , bk}, then (i) θ is applicable to
conji iff it is applicable to each of b1, b2, . . . , bk, and
(ii) when applicable, the result of applying θ to conji,
denoted by conjiθ, is deﬁned by conjiθ = {b1θ, b2θ,
. . . , bkθ}.
•
For any θ ∈ S ∪ SF, (i) θ is applicable to I iff it is
applicable to a and each of conj1, conj2, . . . , conjn,
and (ii) when applicable, the result of applying θ to I,
denoted by Iθ, is deﬁned by Iθ = (aθ ↔ (conj1θ ∨
conj2θ ∨ · · · ∨ conjnθ).
C. Declarative Descriptions
A declarative description consists of clauses and iff-
formulas. They may have labels inside referential constraints,
by which we can have richer expressive power. For example,
the constraint in the right-hand side of the iff-formula
l3 : (odd ∗x) ↔ {⟨φnot, (even ∗x), l3⟩, (int ∗x)}
means that ∗x is an odd number iff ∗x is an integer that is not
even.
Deﬁnition 7: Let L be a set of labels. A declarative
description D on ⟨Γ, Γc, L, ΓF⟩ is a triple ⟨l, L, f⟩, where
1)
l ∈ L,
2)
L ⊆ L, and
3)
f : L → pow(CL(Γ, Γc, L, ΓF) ∪ IFF(Γ, Γc, L, ΓF)).
D is called a referential declarative description if there exists
a referential clause in the set S{f(l) | l
∈ L}. It is
called a simple declarative description otherwise. The set of
all declarative descriptions on ⟨Γ, Γc, L, ΓF⟩ is denoted by
DD(Γ, Γc, L, ΓF).
58
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-354-4
ADVCOMP 2014 : The Eighth International Conference on Advanced Engineering Computing and Applications in Sciences

D. Evaluation of Constraints
Let D = ⟨l0, L, f⟩ be a declarative description on ⟨Γ, Γc,
L, ΓF⟩ and l0, l1, . . . , lk are all the labels in L, listed according
to some predetermined order. Mappings
•
val : GCON(Γ, Γc, L, ΓF) × pow(G)k+1 → Bool,
•
TCON : pow(G)k+1 → pow(GCON(Γ, Γc, L, ΓF))
are introduced for evaluation of constraints and determination
of the sets of all true constraints with respect to ground atom
sets associated with l0, l1, . . . , lk. They are deﬁned as follows:
1)
For any constraint
c = ⟨φ, d1, d2, . . . , dm⟩ ∈ GCON(Γ, Γc, L, ΓF)
and any G0, G1, . . . , Gk ⊆ G,
val(c, G0, G1, . . . , Gk) = φ(g1, g2, . . . , gm),
where for each i ∈ {0, 1, . . ., m},
gi =

di
if di ∈ G ∪ Gc,
Gj
if di = lj for some j ∈ {0, 1, . . ., k}.
2)
For any G0, G1, . . . , Gk ⊆ G, TCON(G0, G1, . . . ,
Gk) is the set
{c ∈ GCON(Γ, Γc, L, ΓF)
| val(c, G0, G1, . . . , Gk) = true}.
E. Evaluation of Clauses and Iff-Formulas
Using the mapping TCON, ground clause sets and ground
iff-formula sets, respectively, are associated with the labels of
D by the mappings
•
gclSet : L × pow(G)k+1 → pow(GCL(G)),
•
giffSet : L × pow(G)k+1 → pow(GIFF(G)),
which are deﬁned as follows:
1)
For any j ∈ {0, 1, . . ., k} and any G0, G1, . . . , Gk ⊆
G, gclSet(lj, G0, G1, . . . , Gk) is the set
{C′ ∈ GCL(G)
| (∃C ∈ f(lj) ∩ CL(Γ, Γc, L, ΓF))
(∃θ ∈ S)(∃σ ∈ SF) :
(Cθσ ∈ GCL(Γ, Γc, L, ΓF)) &
(con(Cθσ) ⊆ TCON(G0, G1, . . . , Gk)) &
(lhs(C′) = lhs(Cθσ)) &
(rhs(C′) = rhs(Cθσ) − con(Cθσ))}.
2)
For any j ∈ {0, 1, . . ., k} and any G0, G1, . . . , Gk ⊆
G, giffSet(lj, G0, G1, . . . , Gk) is the set
{I′ ∈ GIFF(G)
| (∃I ∈ f(lj) ∩ IFF(Γ, Γc, L, ΓF))
(∃θ ∈ S)(∃σ ∈ SF) :
(Iθσ ∈ GIFF(Γ, Γc, L, ΓF)) &
(con(Iθσ) ⊆ TCON(G0, G1, . . . , Gk)) &
(head(I′) = head(Iθσ)) &
(#Conj(I′) = #Conj(I)) &
(∀i ∈ {1, 2, . . ., #Conj(I)} :
rhsi(I′) = rhsi(Iθσ) − con(Iθσ))}.
F. Models of Declarative Descriptions
Truth values of ground clauses in GCL(G) and ground iff-
formulas in GIFF(G) are deﬁned below. Let G be an arbitrary
subset of G. Then:
•
A ground clause C ∈ GCL(G) is true with respect to
G iff lhs(C) ∩ G ̸= ∅ or rhs(C) ̸⊆ G.
•
A ground iff-formula I
∈ GIFF(G) is true with
respect to G iff one of the following conditions is
satisﬁed:
1)
head(I) ∈ G and for some i ∈ {1, 2, . . .,
#Conj(I)}, rhsi(I) ⊆ G.
2)
head(I) ̸∈ G and for any i ∈ {1, 2, . . .,
#Conj(I)}, rhsi(I) ̸⊆ G.
Given these deﬁnitions, a mapping
Models : pow(GCL(G) ∪ GIFF(G)) → pow(pow(G))
is then deﬁned by: For any K ⊆ GCL(G)∪ GIFF(G) and any
G ⊆ pow(G), G ∈ Models(K) iff for any k ∈ K, k is true
with respect to G.
Now let D = ⟨l0, L, f⟩ be a declarative description on
⟨Γ, Γc, L, ΓF⟩ and l0, l1, . . . , lk are all the labels in L, listed
according to some predetermined order. For any j ∈ {0, 1, . . .,
k}, a mapping
modelj : pow(G)k+1 → pow(pow(G))
is deﬁned as follows: For any G0, G1, . . . , Gk ⊆ G,
modelj(G0, G1, . . . , Gk) = Models(Kj),
where Kj is the union of the following two sets:
•
gclSet(lj, G0, G1, . . . , Gk) ⊆ GCL(G)
•
giffSet(lj, G0, G1, . . . , Gk) ⊆ GIFF(G)
Using
the
mappings
model0, model1, . . . , modelk,
the
declarative description D determines a collection of the fol-
lowing membership constraints:
x0 ∈ model0(x0, x1, . . . , xk)
x1 ∈ model1(x0, x1, . . . , xk)
· · ·
xk ∈ modelk(x0, x1, . . . , xk)
This collection is called the system of membership constraints
for D, denoted by SMC(D).
Deﬁnition 8: [G, G1, G2, . . . , Gk] is an extended model
of D iff the set of equations {x0 = G, x1 = G1, x2 =
G2, . . . , xk = Gk} satisﬁes SMC(D).
Deﬁnition 9: G is a model of D iff there exist G1, G2,
. . . , Gk such that [G, G1, G2, . . . , Gk] is an extended model
of D.
59
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-354-4
ADVCOMP 2014 : The Eighth International Conference on Advanced Engineering Computing and Applications in Sciences

G. A Logical Structure for Declarative Descriptions
Using the class of declarative descriptions proposed so far,
a logical structure L = ⟨K, I, ν⟩ for declarative descriptions
on ⟨Γ, Γc, L, ΓF⟩ is deﬁned as follows:
1)
K = DD(Γ, Γc, L, ΓF).
2)
I = pow(G).
3)
ν : K → Map(I, Bool) is deﬁned as follows: Let
L ⊆ L. Let D = ⟨l0, L, f⟩ be a declarative descrip-
tion on ⟨Γ, Γc, L, ΓF⟩ and l0, l1, . . . , lk are all the
labels in L, where l1, . . . , lk are listed according to
some predetermined order of labels in L. Then for any
G ⊆ G, ν(D)(G) = true iff there exist G1, . . . , Gk ⊆
G such that (x0 = G; x1 = G1; . . . ; xk = Gk)
satisﬁes SMC(D).
V.
CONSTRAINTS IN THE S-EXPRESSION SPACE
Referring to the specialization system ΓS = ⟨A, G, S, µ⟩
given in Section III-B, we deﬁne important constraints in the
speciﬁc domain of S-expressions. We also show that func-
atoms can be realized in the same class of constraints. In the
rest of this paper,
•
we assume that Γ = Γc = ΓS, and we consider
DD(ΓS, ΓS, L, ΓF);
•
let H = Gc ∪ G ∪ pow(G) ∪ GF.
A. Reference to a Database
The iff-formula in Fig. 1 represents an employee table con-
sisting of four columns, i.e., name, age, salary, and department,
where eq-atoms are deﬁned by the set of iff-formulas
{((eq ¯a ¯b) ↔ (true)) |
(¯a and ¯b are variable-free S-expressions in G) &
(¯a = ¯b)}.
Reference from a world to a table in another world is
realized by the use of a referential constraint. For example,
for referring to the 4th argument (i.e., the department column)
of employee table above, the constraint ⟨φrefer, l0, emp, 4, ∗a4⟩
can be used by assuming a mapping φrefer : H4 → Bool given
by: φrefer(G, t1, t2, t3) = true iff G ⊆ G, t1, t2, t3 ∈ Gc, and
(refer t1 t2 t3) ∈ G, where refer is deﬁned by the clause
l0: (refer emp 4 ∗d) ← (emp ∗n ∗a ∗s ∗d).
Several kinds of constraints can be constructed for formu-
lating aggregate operations concerning a referenced database,
l0: (emp ∗n ∗a ∗s ∗d) ↔
({(eq ∗n John), (eq ∗a 34), (eq ∗s 8600), (eq ∗d d1)} ∨
{(eq ∗n Morgan), (eq ∗a 24), (eq ∗s 6300), (eq ∗d d2)} ∨
{(eq ∗n Lewis), (eq ∗a 42), (eq ∗s 9000), (eq ∗d d3)} ∨
{(eq ∗n Long), (eq ∗a 34), (eq ∗s 8500), (eq ∗d d2)} ∨
{(eq ∗n Henry), (eq ∗a 29), (eq ∗s 12300), (eq ∗d d1)} ∨
{(eq ∗n Thomas), (eq ∗a 31), (eq ∗s 7300), (eq ∗d d3)} ∨
{(eq ∗n Martin), (eq ∗a 45), (eq ∗s 7500), (eq ∗d d1)})
Figure 1.
Representing an employee table
including operations that are commonly supported by a stan-
dard SQL, e.g., max, min, average, and sum [8][9][10], and
those that are not, e.g., argmax and argmin. Formulation of
the sum, argmax, and argmin operations using constraints is
illustrated below.
B. Summation
Summation can be formulated using a constraint deﬁned
by the mapping
φsum : H3 → Bool,
where φsum(id, G, t) = true iff t is the sum of the elements of
the multi-set {s | (sum id n s) ∈ G}. Using φsum, the query
“ﬁnd the sum of salaries of all the employees who work in the
department d1 or the department d2” is represented by:
l0: (ans ∗ x) ← ⟨φsum, id, l0, ∗x⟩.
l0: (sum id ∗n ∗s) ← (emp ∗n ∗a ∗s d1).
l0: (sum id ∗n ∗s) ← (emp ∗n ∗a ∗s d2).
C. Argmax and Argmin
Argmax stands for the argument of the maximum. Given a
mapping f, argmax gives a value x that maximizes f(x). The
argmax constraint is deﬁned using
φargmax : H3 → Bool,
given by: φargmax(id, G, t) = true iff id ∈ Gc, G ⊆ G, t ∈ Gc,
and there exists t′ ∈ Gc such that
1)
(argmax id t t′) ∈ G, and
2)
for any t1, t2 ∈ Gc, if (argmax id t1 t2) ∈ G, then
t2 ≤ t′.
For instance, the query “ﬁnd all persons who earn the maxi-
mum salary” is represented by:
l0: (ans ∗x) ← ⟨φargmax, id, l0, ∗x⟩.
l0: (argmax id ∗n ∗s) ← (emp ∗n ∗a ∗s ∗d).
Similarly, given a mapping f, argmin gives a value x that
minimizes f(x). The argmin constraint is deﬁned using
φargmin : H3 → Bool,
given by: φargmin(id, G, t) = true iff id ∈ Gc, G ⊆ G, t ∈ Gc,
and there exists t′ ∈ Gc such that
1)
(argmin id t t′) ∈ G, and
2)
for any t1, t2 ∈ Gc, if (argmin id t1 t2) ∈ G, then
t2 ≥ t′.
The query “ﬁnd all the youngest persons who work at the
department d1,” for example, is represented by:
l0: (ans ∗x) ← ⟨φargmin, id, l0, ∗x⟩.
l0: (argmin id ∗n ∗a) ← (emp ∗n ∗a ∗s d1).
60
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-354-4
ADVCOMP 2014 : The Eighth International Conference on Advanced Engineering Computing and Applications in Sciences

D. func-atoms
Atoms of a special kind, called func-atoms, are used for
meaning-preserving Skolemization [3]. They can be repre-
sented by constraints with function variables and function
constants as arguments. A mapping
φfunc : FC × Gn+1
c
→ Bool
is deﬁned by: φfunc(f, t1, t2, . . . , tn, tn+1) = true iff f is an n-
ary function constant and t1, t2, . . . , tn, tn+1 are variable-free
terms such that f(t1, t2, . . . , tn) = tn+1.
Let a ﬁrst-order formula F be given by:
F: ∃x: (hasChild(Peter, x) ∧ (∃y: motherOf(x, y)))
By meaning-preserving Skolemization [3], F is converted into
{C1, C2}, given as follows:
C1: (hasChild Peter ∗x) ← ⟨φfunc, ∗h1, ∗x⟩
C2: (motherOf ∗x ∗y) ← ⟨φfunc, ∗h1, ∗x⟩, ⟨φfunc, ∗h2, ∗y⟩
E. Negation
Negation [8] can also be represented as constraints using
φnot : G × pow(G) → Bool,
given by: for any g ∈ G and any G ⊆ G, φnot(g, G) = true iff
g /∈ G.
Example 1: Assume that L = {l0} and a is an arbitrary
atom. Let deﬁnite clauses C1 and C2 be given by:
C1 :
a ← (not a)
C2 :
(not a) ← ⟨φnot, a, l⟩
Let D be a declarative description ⟨l0, L, f⟩, where f(l0) =
{C1, C2}. Let G = rep(a) ∪ rep(not(a)). We show that G is
a model of D as follows: Let C′
1 = (g ← (not g)) be any
ground instance of C1. C′
1 is true since g ∈ G. So C1 is true
with respect to G. Let C′
2 = ((not g) ← ⟨φnot, g, l0⟩) be any
ground instance of C2. C′
2 is true since (not g) ∈ G. So C2 is
true with respect to G.
Example 2: Assume again that L = {l0} and a is an
arbitrary atom. Let I1 and I2 be the following iff-formulas:
I1 :
a ↔ {(not a)}
I2 :
(not a) ↔ {⟨φnot, a, l⟩}
Let D be a declarative description ⟨l0, L, f⟩, where f(l0) =
{I1, I2}. We show that D is not satisﬁable as follows: Assume
that G is a model of D. Let θ ∈ S such that aθ ∈ G and let
aθ = g. From I1θ = (g ↔ {(not g)}), we have: g ∈ G iff
(not g) ∈ G. From I2θ = ((not g) ↔ {⟨φnot, g, l0⟩}), we have:
(not g) ∈ G iff φnot(g, l0) = true. From the deﬁnition of φnot,
φnot(g, l0) = true iff g /∈ G. Then g ∈ G iff g ̸∈ G, which is
a contradiction.
VI.
CONCLUSIONS
We have deﬁned a method for multiple-world extension of
a clausal logical structure, and by applying this extension, we
have introduced a multiple-world clausal logical structure for
S-expression atoms. We can consider multiple worlds simul-
taneously. Not only usual terms but also models themselves
can be considered as arguments of a relation. This class of
declarative descriptions can be used for representing open
worlds, closed worlds, and their mixtures, by using clauses
and iff-formulas. This gives one solution for unifying open
and closed world. Function variables in constraints enables us
to use func-atoms, which are essential for meaning-preserving
Skolemization [3].
ACKNOWLEDGMENT
This research was partially supported by JSPS KAKENHI
Grant Number 25280078, and the Collaborative Research Pro-
gram 2013, Information Initiative Center, Hokkaido University.
REFERENCES
[1]
K. Akama and E. Nantajeewarawat, “Logical Structures on Specializa-
tion Systems: Formalization and Satisﬁability-Preserving Transforma-
tion,” in Proceedings of the 7th International Conference on Intelligent
Technologies, Taipei, Taiwan, 2006, pp. 100–109.
[2]
——, “Construction of Logical Structures on Specialization Systems,”
in Proceedings of the 2011 World Congress on Information and Com-
munication Technologies, Mumbai, India, 2011, pp. 1030–1035.
[3]
——, “Meaning-Preserving Skolemization,” in Proceedings of the 2011
International Conference on Knowledge Engineering and Ontology
Development, Paris, France, 2011, pp. 322–327.
[4]
M. Fitting, First-Order Logic and Automated Theorem Proving, 2nd ed.
Springer-Verlag, 1996.
[5]
J. W. Lloyd, Foundations of Logic Programming, second, extended ed.
Springer-Verlag, 1987.
[6]
C.-L. Chang and R. C.-T. Lee, Symbolic Logic and Mechanical Theo-
rem Proving.
Academic Press, 1973.
[7]
K. Akama, “Declarative Semantics of Logic Programs on Parameterized
Representation Systems,” Advances in Software Science and Technol-
ogy, vol. 5, 1993, pp. 45–63.
[8]
S. Abiteboul, R. Hull, and V. Vianu, Foundations of Databases.
Addison-Wesley, 1995.
[9]
M. Dahr, Deductive Databases: Theory and Applications.
Coriolis
Group, 1996.
[10]
C. J. Date, SQL and Relational Theory, 2nd Edition.
O’Reilly Media,
2011.
61
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-354-4
ADVCOMP 2014 : The Eighth International Conference on Advanced Engineering Computing and Applications in Sciences

