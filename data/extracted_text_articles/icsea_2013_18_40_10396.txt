Ensuring Consistency of Dynamic Reconﬁguration of Component-Based Systems
Hamza Zerguine
MOVEP laboratory
USTHB University
Algiers, Algeria,
Email: hzerguine@usthb.dz
Nabila Salmi
MOVEP Laboratory, USTHB
Algiers, Algeria,
LISTIC Laboratory, Universit´e de Savoie
Annecy le Vieux, France
Email: nsalmi@usthb.dz
Malika Ioualalen
MOVEP laboratory
USTHB University
Algiers, Algeria
Email: mioualalen@usthb.dz
Abstract—The
introduction
of
dynamic
reconﬁguration
properties in a system can affect its performance and quality
of service offered to users. Thus, performance prediction of
component-based systems after reconﬁguration is important
to help software engineers to analyze their applications at
the moment of reconﬁguration and take decision to keep or
discard the analyzed reconﬁguration, so that
performance
problems are avoided. In this case, the design and veriﬁcation
of functional and non-functional properties before and after
reconﬁguration become a challenge. In particular, when a
applying a reconﬁguration on a system, the consistency of
the new resulting architecture should be checked. To this
aim, we describe, in this paper, a generic reconﬁguration
analysis approach which allows to check the reconﬁguration
consistency of a component-based architecture, starting from the
architectural description of a component-based system. A case
study of a system reconﬁguration illustrates the effectiveness of
our approach.
Keywords-Component-Based Systems; dynamic reconﬁguration;
formalization; consistency.
I. INTRODUCTION
Component-based approaches [1] are more and more essen-
tial for the development of systems and applications, to meet
the challenges of engineering systems such as administration,
autonomy. In this paradigm, components are developed in
isolation or reused and are then assembled to build a Com-
ponent Based System (CBS). Their objective is to enable a
high degree of reusability of the software, rapid development
(reducing the cost in terms of development time) and high
quality since development is based on precompiled components
In this direction, numerous component models have been pro-
posed (e.g., Enterprise Java Beans (EJB) [2], Corba Component
Model (CCM) [3], Fractal [4], etc.). They operate different
life-cycle stages, target different technical domains (embedded
systems, distributed systems, etc.) and offer different degrees of
tool support (textual modeling, graphical modeling, automated
performance simulation, etc.).
Nowadays, systems need more and more to adapt their be-
haviour to their environment changes. To do that, they should
dynamically add, remove or recompose components by the use
of computational reﬂection. These abilities are called dynamic
or runtime reconﬁguration and constitute a key element to
enable the adaptation of complex systems, such as embedded
systems (mobile phones, PDAs, etc.) and service-oriented sys-
tems, to a changing environment. Moreover, dynamic system
reconﬁguration allows to achieve continuous availability of
systems.
Dynamic reconﬁguration techniques are promising solutions
for building highly adaptable component-based systems. How-
ever, the introduction of dynamic reconﬁguration properties in a
system can affect its performance and quality of service offered
to users. To avoid this, the design and veriﬁcation of functional
and non-functional properties of a reconﬁgured system become
a challenge.
In this context, our long-term goal is to develop a method-
ology which allows analysis of component-based applications
and their correction after reconﬁguration, to help the decision to
keep or discard the analyzed reconﬁguration. The ﬁrst property
to ensure during analysis of such systems is consistency, which
is deﬁned as remaining compliant with their speciﬁcation [5].
In this paper, we introduce a new formalism for checking
consistency of dynamic reconﬁgurations of component-based
systems. We provide this formalism for general component sys-
tems characterized by the most common component properties.
Outline. The structure of the paper is as follows. We discuss
in Section II the related work. Then, we present in Section III
the most important concepts of component-based systems. We
detail our approach in Section IV and illustrate it in Section V.
We conclude in Section VI and give future works.
II. RELATED WORK
Several approaches were proposed, during last years, for
analysis of CBS; a few of them addressed dynamic reconﬁg-
uration.
In this context, two main proposals were given for dy-
namic reconﬁguration analysis of CBS. First, Grassi et al.
[6] proposed a metamodel called KLAPER, which includes a
kernel modelling language. The main goal of this language
is to act as a bridge between design models of component-
based systems (built using heterogenous languages like Uni-
ﬁed Modeling Language (UML) [7], Ontology Web Language
(OWL) (OWL-S) [8], etc.) and performance analysis models
(Markov chains [9], queueing networks [10], etc.). This ﬁrst
work did not address reconﬁguration cases study. Later, in [11],
an extension of KLAPER, called D-KLAPER, was given to
support the model-based analysis of reconﬁgurable component-
based systems, with a focus on the assessment of particular non-
functional properties, namely performance and reliability.
517
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

The second work, deﬁned by Leger [5], targeted dynamic
reconﬁgurations reliability analysis for component-based sys-
tems, where an analysis approach for the Fractal component
model was deﬁned. The approach is summarized in three steps:
the ﬁrst step is a Fractal conﬁguration modeling [5] step of
a component-based conﬁguration architecture; then, deﬁnition
of mechanisms used for maintaining systems consistency dur-
ing dynamic reconﬁgurations; ﬁnally, implementation of these
mechanisms for checking reliable reconﬁguration.
Besides, some other approaches were proposed for CBS for
checking, in particular, consistency of CBS during dynamic
reconﬁguration. Warren et al. [12] proposed to do automatic
runtime checks of reconﬁgurable component-based systems
for the OpenRec framework [13]. A formal model based on
ALLOY [14] was deﬁned for that purpose. It allows architec-
ture constraints expression and checking. Another work [15]
has introduced an extension of the Fractal model [16], called
Safran to enable the development of adaptive applications. It
consists of a dedicated programming language for adaptation
policies, as well as a mechanism to dynamically attach or
detach policies to or from Fractal basic components. Finally, M.
Simonot et al. [17] proposed a formal framework, called Fracl,
for specifying and reasoning about dynamic reconﬁguration
programs, being written in a Fractal-like programming style [4].
This framework is based on a ﬁrst order logic, and allows
properties speciﬁcation and proof concerning either functional
or control concerns. An encoding of their model using the
Focal speciﬁcation framework [18] enabled them to prove its
coherence and obtain a framework for reasoning on concrete
architectures.
These proposals are interesting, however, Safran, Fracl and
Leger’s proposals are focused on Fractal models only. In par-
ticular, Fracl was deﬁned only for applications with primitive
components. In addition, no difference is done between Manda-
tory and Optional interfaces and no subtyping notion is consid-
ered. Warren et al. [12] focused on OpenRec framework only.
Moreover, only connections between component are modelled
and not component behaviours.
In our case, we target to provide a generic formalism to
be used for checking consistency in any component-based
system. Our approach formalizes main component elements
(component, interfaces, bindings, etc.) and deﬁnes for each
reconﬁguration operation a set of constraints to build consistent
conﬁgurations. Global constraints are also introduced on a CBS
after its reconﬁguration.
III. COMPONENT BASED SYSTEMS
A software component is deﬁned as a unit of composition,
provided with contractually speciﬁed interfaces and explicit
context dependencies [19]. An interface is an access point to
the component, which deﬁnes provided or required services.
In addition, types, constraints and semantics are deﬁned by the
component model in order to describe the expected behaviour
at runtime.
Interfaces of a component allow to connect it to other com-
ponents. Consequently, we build a Component-based System
by connecting the interfaces of components. These connec-
tions are done depending on interactions between components.
Generally, two main styles of interactions are deﬁned in com-
ponent models: synchronous interactions provided by service
invocation (such as an Remote Procedure Call (RPC) or Remote
Method invocation (RMI) communication), and asynchronous
interactions given through notiﬁcation of events (asynchronous
messages). Service invocations take place between a client in-
terface requesting a service and a server interface providing the
service. Besides, event communications are deﬁned between
one or more event source interfaces generating events and one
or several event sink interfaces receiving event notiﬁcations.
The reception of a notiﬁcation causes the acknowledgment
of the reception and execution of a speciﬁed reaction called
the handler of the event. Some event services can use event
channels for mediating event messages between sources and
sinks. An event channel is an entity responsible for registering
subscriptions of a speciﬁc type of event, receiving events,
ﬁltering events according to speciﬁc modes, and routing them
to the interested sinks.
A component can contain itself a ﬁnite number of other
interacting components, called sub-components, allowing the
components to be nested at an arbitrary level. In this case, it is
said a composite component. At the lowest level, components
are said primitive. Sometimes, assembling two components
may require an adaptation of associated interfaces, whenever
these interfaces cannot directly communicate for example. In
this case, the adaptation is done with an extra entity, called
connector, modelling the interaction protocol between the two
components.
For each component model, a corresponding Architecture
Description Language (ADL) allows to describe an assembly of
components forming an application. From such a description, a
set of tools are used to compile and generate the application
code, while checking syntactical and even some semantical
properties.
IV. FORMALIZATION
Our goal is to propose a new formalism for checking con-
sistency of dynamic reconﬁgurations of component-based. For
this purpose, we give ﬁrst a set of concepts and then deﬁne our
approach for checking consistency of CBS.
A. Concepts
1) Component-based conﬁguration:
Deﬁnition 1. A component-based conﬁguration of a system S
is deﬁned as a triplet:
Cg =≺ C, I, B ≻
where
• C: is a set of components;
• I: is a set of interfaces;
• B: is a set of component connections or bindings.
Deﬁnition 2. A component c is deﬁned as:
c =≺ name, granul, state ≻
518
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

where:
• name: is the unique name of the component C;
• granul: refers to granularity wich can be Composite or
Primitive;
• state: is the current state of the component C, which can
be Started or Stopped.
Deﬁnition 3. A component interface i is deﬁned as:
i =≺ itfc, role, visib, card, contig, sign ≻
where:
• itfc: is the unique identiﬁer of the interface (being of the
form: component-name.interface-name);
• role: can be Client / Server (in the case of a service
invocation interface) or Sink / Source (in the case of an
event based interface);
• visib: refers to the visibility of the interface, which can
be Internal or External;
• card: refers to the cardinality of the interface, which is
Singleton or Collection;
• contig: characterizes the interface contingency, which
may be Optional or Mandatory;
• sign: returns the interface signature.
Deﬁnition 4. A component binding b is deﬁned with:
b =≺ itfc − clt, itfc − srv ≻
where:
• itfc-clt: refers to the invoking interface, and can be Client
or Sink;
• itfc-srv: refers to the service interface, and may be Server
or Source.
2) Reconﬁguration:
Deﬁnition 5. Let be a conﬁguration Cg1 of a system S. We
deﬁne a reconﬁguration R of S, being in the conﬁguration
Cg1, as an ordered set of primitive operations applied on
Cg1 :
R = op1, op2, ..., opn, n ≥ 1
where opi, i = 1..n, is one of the following reconﬁguration
operations:
1) Delete a component
2) Add a component
3) Replace a component
4) Delete a binding
5) Add a binding
The resulted conﬁguration after application of R is denoted
Cg2.
We denote this by:
Cg1
op
→ Cg2
3) Predeﬁned functions: To be able to specify constraints
required for performing properly a reconﬁguration, we need a
set of predeﬁned functions. For this objective, we propose the
following functions:
1) CFather(cp) : returns the parent of the component cp;
2) CInterfaces(cp) : returns the interfaces list of the compo-
nent cp;
3) CType(cp) : returns the type of the component cp;
4) IComponent(i) : returns the owner of the interface i;
5) IType(i) : returns the type of the interface i.
B. Constraints
To ensure the correction of a reconﬁguration R applied on a
system S, we deﬁne two sets of constraints:
• Constraints on primitive reconﬁguration operations :
Should be checked after each primitive operation.
• Global constraints : should be checked after the whole
reconﬁguration.
In the following, we specify these two sets of constraints.
1) Constraints on primitive reconﬁguration operations:
Let op be a primitive reconﬁguration operation, applied on a
conﬁguration Cg1 of a system S, resulting in the conﬁguration
Cg2, where :
• Cg1 =≺ C1, I1, B1 ≻
• Cg2 =≺ C2, I2, B2 ≻
We denote this by:
Cg1
op
→ Cg2
In the following, we consider :
• A component : cp =≺ name, granul, statut ≻
• A binding : b =≺ iclt, isrv ≻
Primitive reconﬁguration operations, applied on components
cp and cp′, are denoted as follows:
1) Delete a component cp :
del comp(cp)
2) Add a component cp :
add comp(cp)
3) Replace a component cp by anpther cp′:
Repl comp(cp, cp′)
4) Delete a binding b :
del bdg(b)
5) Add a binding b :
add bdg(b)
Table I gives the required constraints to be satisﬁed after each
reconﬁguration operation.
519
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

TABLE I: CONSTRAINTS ON PRIMITIVE RECONFIGURATION OP-
ERATIONS
Operation
Constraints
del comp(cp)
1) C2 = C1 − cp
2) I2 = I1 − CInterfaces(cp)
3) ∀ i ∈ CInterfaces(cp), i /∈ I2
add comp(cp)
1) C2 = C1 ∪ cp, cp /∈ C1
2) I2 = I1 ∪ CInterfaces(cp)
3) ∀i ∈ I1, ∃j ∈ I2 tq : i.itfc =
j.itfc
4) ∀i ∈ CInterfaces(cp), i /∈ I1
Repl comp(cp,cp’)
• CType(cp)
is
a
sub-
type of CType(cp′)
del bdg(b)
1) B2 = B1 − b
2) b ∈ B1
add bdg(b)
1) B2 = B1 ∪ b
2) b /∈ B1
3) ∃ b.iclt ∈ I1 ∧ b.isrv ∈ I1
4)
b.iclt.card=SINGLETON ⇒
∀
b’<
iclt′, isrv′
>∈
B1, iclt′ ̸= iclt
5)
b.isrv.card=SINGLETON ⇒
∀
b’<
iclt′, isrv′
>∈
B1, isrv′ ̸= isrv
2) Global constraints: Let R be a reconﬁguration that will
be applied to a conﬁguration Cg1 of a system S, giving as a
result a conﬁguration Cg2:
Cg1
R→ Cg2
with : R = op1, op2, ..., opn, n ≥ 1
We specify the following constraints, which must be satisﬁed
by Cg2 :
1) ∀ b ∈ B2, b.iclt.role = Client / Sink ∧ b.isrv.role = Server
/ Source
2) ∀ b ∈ B2, (b.iclt.contig = Mandatory) ⇒ (b.isrv.contig =
Mandatory)
3) ∀ b, b’ ∈ B2, b.iclt ̸= b’.iclt
4) ∀
b
∈
B2,
(CFather(IComponent(b.iclt))
=
CFather(IComponent(b.isrv)))∨ (b.iclt.visib = Internal ∧
IComponent(b.iclt) = CFather(IComponent(b.isrv))) ∨
(b.isrv.visib = Internal ∧ CFather(IComponent(b.iclt)) =
IComponent(b.isrv))
5) ∀ i ∈ I2 ( i.role = Client ∧ i.contig = Mandatory ⇒ ∃! b
∈ B2 tq: b.iclt = i )
6) ∀ b ∈ B2, IType(b.isrv) ⊆ IType(b.iclt)
C. Consistency of a conﬁguration
Theorem 1. A reconﬁguration R, applied to a conﬁguration
Cg1 of a system S, is valid if the resulting conﬁguration Cg2
satisﬁes all constraints deﬁned on primitive reconﬁguration
operations and global constraints.
Theorem 2. A conﬁguration Cgi of a system S is consistent
after a reconﬁguration R if R is valid.
V. ILLUSTRATION
To illustrate our approach, we use a navigator application
similar to Mozilla already used in [20]. In such applications,
components are usually equipped with an install manifest in
XML format, allowing, among other things, to deliver the in-
formation needed to manage the version compatibility between
components.
Fig. 1: Initial conﬁguration
So, the architecture of the application consists of a composite
component MAIN composed of three primitive components
(Figure 1):
1) M, the main application (e.g., Firefox);
2) E, an already installed plugin;
3) V M, a version manager component.
Each of the components M and E have an interface h
with a signature H, being respectively a client and server
interface. They also each have a server interface im of signature
InstallMf. M has an additional server interface g of signature
G, being the main interface exported to the global external
interface of the application.
The Main composite exports business methods from M and
supplies update, a control method implementing the upgrade
operation. This method looks for a component with same id as
E, having a more recent version and being compatible with M.
In case of success, it replaces E with the new component.
Based on our formalization, we specify the initial conﬁgura-
tion of Figure 1 as follows:
Cg1 =≺ C1, I1, B1 ≻
520
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

where:
• C1 = (Main, M, V M, E)
• I1 = (Main.g, M.g, M.im, V M.a1, V M.a2, E.im, E.h)
• B1 = (b1, b2, b3, b4)
where:
• M = (M, Primitive, Started)
• VM = (VM, Primitive, Started)
• E = (E, Primitive, Started)
• Main.g = (Main.g, Server, External, Singleton, Optional,
G)
• M.g = (M.g, Server, External, Singleton, Optional, G)
• M.h = (M.h, Client, External, Singleton, Optional, H)
• M.im = (M.im, Server, External, Singleton, Mandatory,
InstallMF)
• VM.a1 = (VM.a1, Client, External, Singleton, optional,
InstallMF)
• VM.a2 = (VM.a2, Client, External, Singleton, Optional,
InstallMF)
• E.h = (E.h, Server, External, Singleton, Optional, H)
• E.im = (E.im, External, Singleton, Mandatory, InstallMF)
• b1 = (Main.g, M.g)
• b2 = (VM.a1, M.im)
• b3 = (VM.a2, E.im)
• b4 = (M.h, E.h)
When applying on this conﬁguration a reconﬁguration R,
which removes the plugin E, we model this by the following
reconﬁguration R :
R = op1, op2, op3
where:
• op1 : Del comp(E),
• op2 : Del bdg(b3),
• op3 : Del bdg(b4).
This resulted conﬁguration is valid because it provides a new
consistent conﬁguration (given in Figure 2), which is deﬁned as
follows:
Cg2 =≺ C2, I2, B2 ≻
where:
• C2 = (Main, M, VM)
• I2 = (Main.g, M.g, M.im, M.h, VM.a1, VM.a2)
• B2 = (b1)
Fig. 2: Resulting conﬁguration after reconﬁguration
where:
• M = (M, Primitive, Started)
• VM = (VM, Primitif, Started)
• Main.g = (Main.g, Server, External, Singleton, Optional,
G)
• M.g = (M.g, Server, External, Singleton, Optional, G)
• M.h = (M.h, Client, External, Singleton, Optional, H)
• M.im = (M.im, Server, External, Singleton, Mandatory,
InstallMF)
• VM.a1 = (VM.a1, Client, External, Singleton, optional,
InstallMF)
• VM.a2 = (VM.a2, Client, External, Singleton, Optional,
InstallMF)
• b1 = (Main.g, M.g)
• b2 = (VM.a1, M.im)
By checking all deﬁned constraints, we can say that R is
valid. So, the new conﬁguration Cg2 is consistent starting from
the fact that Cg1 is consistent.
VI. CONCLUSION
In this paper, we presented a new formalism for checking
consistency of dynamic reconﬁgurations of general component-
based systems. For this purpose, we introduced formal concepts
for modelling a component-based conﬁguration and reconﬁg-
uration operations. We also deﬁned required constraints that
must be satisﬁed by the new conﬁguration resulting after ap-
plying reconﬁguration, to ensure consistency of the system.
Our approach can be instanciated to any existing component
model, allowing thus genericity of the formalism.
Work is in progress to achieve automation of the proposed
approach, by providing a toolbox based on the FOCALIZE
programming environment [21]. This latter is based on a func-
tional programming language with object-oriented features and
allows to write formal speciﬁcations and proofs of designed
programs. Proofs are build using the automated theorem prover
Zenon [22] and Coq proof-assistant [23]. Future work also
include modeling CBS before and after reconﬁguration to allow
quantitative analysis of CBS.
REFERENCES
[1] C. Szyperski, Component software: Beyond Object-Oriented Program-
ming.
Addison-Wesley Professional, 2002, vol. 2nd Edition.
[2] Sun Microsystems, “EJB 3.0 speciﬁcation,” http://www.oracle.com/
technetwork/java/docs-135218.html, jul 2007.
[3] Object Management Group, “Corba component model (ccm) (CORBA)
- speciﬁcation, version 3.1, part 3: CORBA components,” http://
www.omg.org/spec/CORBA/3.3/Interoperability/PDF (November 2008),
2008.
[4] E. Bruneton, “Fractal tutorial,” http://fractal.objectweb.org/tutorials/
fractal/index.html (September 12 2003), September 2003.
[5] M. Leger, “Reliability of dynamic reconﬁgurations in component archi-
tectures,” Ph.D. dissertation, Superior National School of Mines of Paris,
19 mai 2009.
[6] R. M. Vincenzo Grassi and A. Sabetta, “From design to analysis models:
a kernel language for performance and reliability analysis of component-
based systems,” vol. 80, no. 11, 2005, pp. 25–36.
[7] O. M. Group, “(uml) uniﬁed modeling language (3rd release),” Novem-
ber 2004.
[8] Object Management Group, “UML uniﬁed modeling language (3rd
release).”
521
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

[9] D. Freeman, Markov chains, Springer-Verlag, Ed.
Springer-Verlag,
1983.
[10] L. Kleinrock, Queueing systems. Volume I : Theory, Wiley-Interscience,
Ed.
New-York: Wiley-Interscience, 1975.
[11] V. Grassi, R. Mirandola, and A. Sabetta, “A model-driven approach to
performability analysis of dynamically reconﬁgurable component-based
systems,” pp. 103–114, 2007.
[12] I. Warren, J. Sun, S. Krishnamohan, and T. Weerasinghe, “An automated
formal approach to managing dynamic reconﬁguration,” in Automated
Software Engineering, 2006. ASE ’06. 21st IEEE/ACM International
Conference on, september 2006, pp. 37–46.
[13] J. Hillman and I. Warren, “An open framework for dynamic reconﬁgura-
tion,” in Proceedings of the 26th International Conference on Software
Engineering, ser. ICSE ’04.
Washington, DC, USA: IEEE Computer
Society, 2004, pp. 594–603.
[14] D. Jackson, “Alloy : a lightweight object modelling notation,” vol. 11,
no. 2, Novembre 2002, pp. 256 – 290.
[15] L. T. David P.-C., “An aspect-oriented approach for developing self-
adaptive fractal components,” 2006, pp. 82–97.
[16] E. Bruneton, T. Coupaye, M. Leclercq, V. Qu´ema, and J. Stefani, “The
fractal component model and its support in java,” vol. 36, no. n. 11-12,
2006, pp. 1257–1284.
[17] M. Simonot and M. Aponte, “Formal modeling of control with fractal,”
CEDRIC laboratory, CNAM-Paris, France, Tech. Rep. CEDRIC-08-
1590, 2008, http://cedric.cnam.fr/index.php/publis/article/view?id=1590.
[18] V. Benayoun, “Fractal components with dynamic reconﬁguration :
formalization with focal,” 2008, http ://reve.futurs.inria.fr/.
[19] C. Szyperski, “Component technology - what, where, and how?” in Proc.
25th Int. Conf. on Software Engineering.
IEEE, May 3–10 2003, pp.
684–693.
[20] M. Simonot and V. Aponte, “A declarative formal approach to dynamic
reconﬁguration,” pp. 1–10, 2009.
[21] INRIA and LIP6, “The focalize essential,” 2005, http://focalize.inria.fr/.
[22] D. D. R. Bonichon and D. Doligez, “Zenon : An extensible automated
theorem prover producing checkable proofs,” vol. 4790, 2007, pp. 151–
165.
[23] Y. Bertot and P. Casteran, Interactive Theorem Proving and Program De-
velopment Coq Art: The Calculus of Inductive Constructions. Addison-
Wesley, 2004.
522
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-304-9
ICSEA 2013 : The Eighth International Conference on Software Engineering Advances

