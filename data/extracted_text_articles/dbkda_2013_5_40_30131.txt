Typing XPath Subexpressions With Respect to an XML Schema
Yasunori Ishihara∗, Kenji Hashimoto†, Atsushi Ohno∗, Takuji Morimoto∗ and Toru Fujiwara∗
∗ Graduate School of Information Science and Technology, Osaka University, Suita, Japan
Email: ishihara@ist.osaka-u.ac.jp, fujiwara@ist.osaka-u.ac.jp
† Graduate School of Information Science, Nara Institute of Science and Technology, Ikoma, Japan
Email: k-hasimt@is.naist.jp
Abstract—This paper discusses typing XPath subexpressions
with respect to an XML schema, which is a new static
analysis problem of XPath expressions. More formally, the
typing problem is to decide whether there exists an XML
document conforming to a given XML schema such that the
nodes of the document matching to given subexpressions of
a given XPath expression are of the given types. Deciding
this problem is useful for query rewriting induced by schema
evolution or integration. The contribution of this paper includes
a decision algorithm for the typing problem, provided that
XPath expressions include no path union operator. Moreover,
it is shown that the typing problem is reducible to the XPath
satisﬁability problem in the presence of DTDs, for which many
tractability results are known.
Keywords-XPath; static analysis; type; XML schema
I. INTRODUCTION
Static analysis of XPath expressions is one of the major
theoretical topics in the ﬁeld of XML databases. XPath
is a query language for XML documents, where an XML
document is often regarded as an unranked labeled ordered
tree. An XPath expression speciﬁes a pattern of (possibly
branching) paths from the root of a given XML document.
The answer to an XPath expression for an XML document
t is a set of nodes v of t such that the speciﬁed path pattern
matches the path from the root to v.
The most popular subtopic of static analysis may be XPath
satisﬁability, where a given XPath expression p is satisﬁable
under a given XML schema S if there is an XML document
t conforming to S such that the answer to p for t is a
nonempty set. Many tractable combinations of XPath classes
and XML schema classes have been investigated so far [1],
[2], [3]. Another popular one is XPath containment [4], [5],
[6]. Moreover, XPath validity, which is a dual of XPath
satisﬁability, is investigated recently [7], [8].
This paper discusses a new problem of static analysis:
typing XPath subexpressions with respect to an XML schema.
We explain it by an example ﬁrst.
Example 1: Consider the following fragment of an XML
schema:
Te → teachers(M ∗
t ),
Mt → member(N Ti),
N → name(· · ·),
Ti → title(· · ·),
S → students(M ∗
s ),
Ms → member(N Ge Gr),
Ge → gender(· · ·),
Gr → grade(· · ·).
Te, Mt, etc. are types deﬁned in this XML schema, while
teachers, member, etc. are tag names or labels. Note that
the type of member is not unique in this schema.
Now, consider the following two XPath expressions:
p1 =↓∗:: member/ ↓:: name, p2 =↓∗:: member/ ↓:: gender.
The types of the subexpression ↓∗:: member of p1 are Mt
and Ms, because in both cases member has name as its child.
On the other hand, the type of ↓∗:: member of p2 is only
Ms, because member of type Mt has no gender as its child.
More formally, the typing problem is to decide whether
for a given XML schema S, an XPath expression p, and a
sequence (α1, X1), . . . , (αk, Xk) of pairs of positions of p
and types of S, there exists an XML document t conforming
to S such that the node of t matching to the subexpression
of p at αi is of type Xi for each i (1 ≤ i ≤ k).
The typing problem can be viewed as a natural extension
of the XPath satisﬁability problem, and is useful especially
for query rewriting and optimization induced by schema
evolution or integration. For example, consider again the
fragment of the schema in Example 1. Suppose that Mt →
member(NTi) has evolved into Mt → t member(NTi). In
order to keep the behavior of queries unchanged, p1 must
be rewritten to (↓∗:: member ∪ ↓∗:: t member)/ ↓:: name
while p2 is not necessarily rewritten. As another exam-
ple, suppose that Mt → member(NTi) has evolved into
Mt → member(NTiGe). Then, the associated types of
the subexpression ↓∗:: member of p2 have been changed
(i.e., the types are now both Mt and Ms). In this case, p2
must be rewritten to an expression, say ↓∗:: students/ ↓::
member/ ↓:: gender, so that the subexpression ↓∗:: member
is associated with only Ms.
Under the assumption that XPath expressions include no
path union operator, this paper adopts two approaches to
developing decision algorithms for the typing problem. The
ﬁrst one is a direct approach. In this approach, a given XML
schema and a given XPath expression are translated into
ﬁnite tree automata, and the associated types are analyzed
by computing their intersection automaton. The second
one is a reduction-based approach. In this approach, it is
shown that the typing problem is reducible to the XPath
satisﬁability problem in the presence of DTDs, for which
many tractability results are known. Moreover, a part of this
128
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

result is extended so that all the possible combinations of
types of subexpressions can be efﬁciently enumerated.
The rest of this paper is organized as follows. In Sec-
tion II several preliminary deﬁnitions are provided. Sec-
tions III and IV present the direct and the reduction-based
approaches, respectively. Section V summarizes the paper.
II. DEFINITIONS
A. Trees and XML documents
An XML document is represented by an unranked labeled
ordered tree t = (Vt, λt), where
• Vt is a preﬁx-closed, ﬁnite set of sequences of positive
integers such that if v·i ∈ Vt and i > 1 then v·(i−1) ∈
Vt; and
• λt is a mapping from Vt to a set Σ of labels.
Each element in Vt is called a node of t. The empty
sequence ϵ ∈ Vt is called the root of t. The parent-child
relation and sibling relation between nodes are deﬁned in
an ordinary way. We extend λt to a function on sequences,
i.e., for a sequence v1 · · · vn of nodes, let λt(v1 · · · vn) =
λt(v1) · · · λt(vn). Attributes are not handled in this paper.
For any tree structure t (which is not necessarily repre-
senting an XML document) and its node v, let t|v denote the
subtree of t rooted at v. For any trees t1,..., tn with the same
node set V and v ∈ V , let (t1 · · · tn)|v denote t1|v · · · tn|v.
Also, for any mapping f which returns a tree structure, let
f|v denote a mapping such that f|v(x) = f(x)|v.
B. Regular expressions
A regular expression over an alphabet Σ consists of
constants ϵ (empty sequence) and the symbols in Σ, and op-
erators · (concatenation), ∗ (repetition), and | (disjunction).
We exclude ∅ (empty set) because we are interested in only
nonempty regular languages. The concatenation operator is
often omitted as usual. The string language represented by
a regular expression e is denoted by L(e). The size of a
regular expression is the number of constants and operators
appearing in the regular expression.
C. Finite tree automata and XML schemas
A ﬁnite tree automaton TA is a quadruple (N, Σ, B, P),
where
• N is a ﬁnite set of states,
• Σ is a ﬁnite set of labels,
• B ∈ N is the initial state, and
• P is a ﬁnite set of transition rules in the form of X →
a(e) or X → Y , where X, Y ∈ N, a ∈ Σ, and e is a
regular expression over N called content model.
A ﬁnite tree automaton TA = (N, Σ, B, P) is local if for
any pair of rules X → a(e) and X′ → a′(e′) in P, a ̸= a′
whenever X ̸= X′.
An interpretation ITA
t
of a tree t for a ﬁnite tree automa-
ton TA = (N, Σ, B, P) is a mapping from Vt to the set of
ﬁnite sequences over N satisfying the following conditions:
• ﬁrst(ITA
t
(ϵ)) = B (note that ϵ is the root of t), where
ﬁrst(x) denotes the ﬁrst element of sequence x; and
• for any node v with n children (n ≥ 0), there are
transition rules X1 → X2, X2 → X3,..., Xk → a(e)
in P such that
– ITA
t
(v) = X1X2 · · · Xk,
– λt(v) = a, and
– ﬁrst(ITA
t
(v · 1)) · · · ﬁrst(ITA
t
(v · n)) ∈ L(e) (note
that v · i is the i-th child of v).
A tree t is accepted by a ﬁnite tree automaton TA if there
is an interpretation of t for TA. Let TL(TA) denote the set
of trees accepted by TA.
An XML schema S is a ﬁnite tree automaton such that
• S has no rule in the form of X → Y , and
• S has no pair of rules X → a1(e1) and X → a2(e2)
where a1 ̸= a2.
A DTD is an XML schema which is also local. In a DTD
there is a one-to-one correspondence between N and Σ, so
we often use a triple (N, B, P) to mean a DTD. A tree t
conforms to an XML schema S if t is accepted by S. In this
paper, we assume that every XML schema S = (N, Σ, B, P)
contains no useless states. That is, for each X ∈ N, there
are a tree t ∈ TL(S) and its interpretation IS
t
such that
IS
t (v) = X for some node v of t. Each state in an XML
schema is referred to as a type. The size |S| of an XML
schema S is the sum of the size of all content models.
D. XPath expressions
The syntax of an XPath expression p is deﬁned as follows:
p
::=
χ :: l | p/p | p ∪ p | p[p],
χ
::=
↓ | ↑ | ↓∗ | ↑∗ | →+ | ←+,
where l ∈ Σ. Each χ ∈ {↓, ↑, ↓∗, ↑∗, →+, ←+} is called an
axis. A subexpression in the form of χ :: l is said to be
atomic. The size |p| of an XPath expression p is deﬁned as
the number of atomic subexpressions in p.
A position of an XPath expression p is a ﬁnite sequence
of positive integers representing a node of a parse tree of p.
Precisely, the subexpression p|α of p at position α is deﬁned
as follows:
• p|ϵ = p.
• If p|α = p1/p2, then p|α·1 = p1 and p|α·2 = p2.
• If p|α = p1 ∪ p2, then p|α·1 = p1 and p|α·2 = p2.
• If p|α = p1[p2], then p|α·1 = p1 and p|α·2 = p2.
Next, we deﬁne the satisfaction relation of an XPath
expression p by a tree t with a witness mapping w, which
is a partial mapping from the set of positions of p to the set
of pairs of nodes of t. Intuitively, w(α) is a pair of nodes
that satisﬁes p|α. Note that w(α)|1 and w(α)|2 are the ﬁrst
and the second components of w(α), respectively:
• t |= (↓:: l)(w(α)) if w(α)|2 is a child of w(α)|1 and
λt(w(α)|2) = l.
129
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

• t |= (↑:: l)(w(α)) if w(α)|2 is the parent of w(α)|1
and λt(w(α)|2) = l.
• t |= (↓∗:: l)(w(α)) if w(α)|2 is w(α)|1 or a descendant
of w(α)|1, and λt(w(α)|2) = l.
• t |= (↑∗:: l)(w(α)) if w(α)|2 is w(α)|1 or an ancestor
of w(α)|1, and λt(w(α)|2) = l.
• t |= (→+:: l)(w(α)) if w(α)|2 is a following sibling
of w(α)|1 and λt(w(α)|2) = l.
• t |= (←+:: l)(w(α)) if w(α)|2 is a preceding sibling
of w(α)|1 and λt(w(α)|2) = l.
• t
|=
(p1/p2)(w(α)) if t
|=
p1(w(α · 1)), t
|=
p2(w(α · 2)), w(α · 1)|2 = w(α · 2)|1, and w(α) =
(w(α · 1)|1, w(α · 2)|2).
• t |= (p1 ∪ p2)(w(α)) if t |= pi(w(α · i)) and w(α) =
w(α · i) for some i ∈ {1, 2}. Moreover, if j ∈ {1, 2}
does not satisfy t |= pj(w(α·j)), then for any position
α′ whose preﬁx is α · j, w(α′) is undeﬁned.
• t |= (p1[p2])(w(α)) if t |= p1(w(α · 1)), t |= p2(w(α ·
2)), w(α · 1)|2 = w(α · 2)|1, and w(α) = w(α · 1).
If t |= p(w(ϵ)), we say that t satisﬁes p with witness w and
write (t, w) |= p. Note that if (t, w) |= p and p does not
include path union operator ∪, then w is a total mapping.
E. Typing problem
Suppose that an XML schema S, an XPath expres-
sion p without path union operator ∪, and a sequence
(α1, X1), . . . , (αk, Xk) of pairs of positions of p and types
of S are given. The typing problem is to decide whether
there exist t ∈ TL(S), an interpretation IS
t of t for S, and
a mapping w such that
• w(ϵ)|1 = ϵ (i.e., the root node of t),
• (t, w) |= p, and
• IS
t (w(αi)|2) = Xi for each i (1 ≤ i ≤ k).
III. A DIRECT APPROACH
This section provides an algorithm which directly decides
the typing problem. First, the algorithm translates a given
XPath expression p into a ﬁnite tree automaton TAp, main-
taining the information on the structure of p as the states
of TAp. Then, the algorithm analyzes the correspondence
between subexpressions of p and the types of a given schema
S, by taking the intersection of TAp and S.
A. Translating XPath expressions into ﬁnite tree automata
For a given XPath expression p without path union ∪, we
construct a ﬁnite tree automaton TAp with two distinguished
sets NC p and NDp of states. Roughly speaking, TAp
accepts an arbitrary tree t satisfying p. States in NC p and
NDp are associated with the “start” and “goal” nodes of t
matching p.
First, we provide the deﬁnitions of TAp = (Np, Σ, Bp,
Pp, NC p, NDp) for p = χ :: l, where Bp = B, NC p =
{C}, and NDp = {D}.
• If p = ↓:: l, then Pp consists of
– A → σ(A∗) for each σ ∈ Σ,
– B → σ(A∗BA∗) for each σ ∈ Σ,
– B → C,
– C → σ(A∗DA∗) for each σ ∈ Σ, and
– D → l(A∗).
• If p =↓∗:: l, then Pp consists of
– A → σ(A∗) for each σ ∈ Σ,
– B → σ(A∗BA∗) for each σ ∈ Σ,
– B → C,
– B′ → σ(A∗B′A∗) for each σ ∈ Σ,
– B′ → D,
– C → σ(A∗B′A∗) for each σ ∈ Σ,
– C → D, and
– D → l(A∗).
• If p =→+:: l, then Pp consists of
– A → σ(A∗) for each σ ∈ Σ,
– B → σ(A∗BA∗) for each σ ∈ Σ,
– B → B′,
– B′ → σ(A∗CA∗DA∗) for each σ ∈ Σ,
– C → σ(A∗) for each σ ∈ Σ, and
– D → l(A∗).
For axes ↑, ↑∗, and ←+, the tree automata are deﬁned by
swapping states C and D (and their associated labels) for
the ones of ↓, ↓∗, and →+, respectively.
Consider TAp = (Np, Σ, Bp, Pp, NC p, NDp) where p =
p1/p2. TAp is deﬁned as the intersection [9] of TAp1 and
TAp2, except that the states in NDp1 overlaps only the states
in NC p2, and vice versa. More precisely,
Np = (NDp1 × NC p2) ∪ ((Np1 − NDp1) × (Np2 − NC p2)).
Moreover, Bp = (Bp1, Bp2), NC p = NC p1 × Np2, and
NDp = Np1×NDp2. TAp for p = p1[p2] can be constructed
in a similar way.
Lemma 1: TAp satisﬁes Properties 1 and 2 below. Note
that each state of TAp has the same tree structure as p:
Property 1: For each mapping w such that (t, w) |= p,
there is an interpretation ITAp
t
of t for TAp such that for
each position α of p, ITAp
t
(w(α)|1)|α contains a state in
NC p|α and ITAp
t
(w(α)|2)|α contains a state in NDp|α.
Property 2: Conversely, for each interpretation ITAp
t
of
t for TAp, there is a mapping w such that (t, w) |= p and
for each position α of p, ITAp
t
(w(α)|1)|α contains a state
in NC p|α and ITAp
t
(w(α)|2)|α contains a state in NDp|α.
Proof: The lemma is shown by the induction on the
structure of p. The case where p = χ :: l is easy: If (t, w) |=
p, then there is an interpretation ITAp
t
of t for TAp such that
ITAp
t
(w(ϵ)|1) = C and ITAp
t
(w(ϵ)|2) = D. Conversely,
if ITAp
t
is an interpretation of t for TAp, then there are
unique nodes v and v′ of t such that ITAp
t
(v) = C and
ITAp
t
(v′) = D. By letting w(ϵ) = (v, v′), we have (t, w) |=
p, ITAp
t
(w(ϵ)|1) = C, and ITAp
t
(w(ϵ)|2) = D.
130
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

Consider the case where p = p1/p2. Suppose that TAp1
and TAp2 satisfy the two properties and (t, w) |= p1/p2.
Then, by the deﬁnition of |=, we have t |= p1(w(1)), t |=
p2(w(2)), w(1)|2 = w(2)|1, and w(ϵ) = (w(1)|1, w(2)|2).
Let I
TAp1
t
and I
TAp2
t
be interpretations of t for TAp1 and
TAp2, respectively, that satisfy Property 1. Deﬁne I(v) =
(I
TAp1
t
(v), I
TAp2
t
(v)) for any node v of t. Then, by the
deﬁnition of TAp, I is an interpretation of t for TAp and
satisﬁes Property 1. Conversely, suppose that ITAp
t
is an
interpretation of t for TAp. Then, by the deﬁnition of TAp,
ITAp
t
|1 and ITAp
t
|2 are interpretations of t for TAp1 and
TAp2, respectively. Let w1 and w2 be the mappings deter-
mined by ITAp
t
|1 and ITAp
t
|2, respectively, which satisfy
Property 2. Deﬁne w(1 · α) = w1(α), w(2 · α) = w2(α),
and w(ϵ) = (w1(ϵ)|1, w2(ϵ)|2). Then (t, w) |= p1/p2 and
Property 2 is satisﬁed.
The case where p = p1[p2] can be shown similarly.
B. Analyzing correspondence between XPath expressions
and schemas
Let TAS∩p be an intersection automaton of an XML
schema S and TAp, except that the states in NC p overlaps
only the initial state of S, and vice versa. TAS∩p accepts t
if and only if t satisﬁes p at its root node and t conforms to
S. Moreover, for each interpretation ITAS∩p
t
of t for TAS∩p,
ITAS∩p
t
|1 is an interpretation of t for S and ITAS∩p
t
|2 is an
interpretation of t for TAp. Since TAp satisﬁes Property 2, it
holds in turn that there is a mapping w such that (t, w) |= p
and for each position α of p, ITAS∩p
t
|2(w(α)|2)|α contains
a state in NDp|α. Conversely, by Property 1, if (t, w) |= p,
then there is an interpretation ITAp
t
of t for TAp such that
for each position α of p, ITAp
t
(w(α)|2)|α contains a state
in NDp|α. It holds in turn that for any interpretation IS
t of
t for S , mapping I deﬁned as I(v) = (IS
t (v), ITAp
t
(v)) is
an interpretation of t for TAS∩p.
This observation naturally induces the following algo-
rithm for deciding the typing problem. Suppose that an
XML schema S, an XPath expression p, and a sequence
(α1, X1), . . . , (αk, Xk) of pairs of positions of p and types
of S are given. For each i (1 ≤ i ≤ k), eliminate all the states
(X, Y ) (and associated rules) of TAS∩p such that X ̸= Xi
and Y |αi ∈ NDp|αi . Then decide the emptiness of the tree
language accepted by the resultant ﬁnite tree automaton. The
answer of the typing problem is “yes” if and only if the tree
language is not empty.
C. Discussion
It is easy to see that in the worst case, this algorithm runs
at least in exponential time in the size of p because of the
intersection operation on ﬁnite tree automata. However, this
algorithm is expected to run reasonably fast in many cases.
Indeed, ﬁnite tree automata can be translated into formulas
in a variant of µ-calculus [10], and then the typing problem
can be solved by fast decision procedures for µ-calculus
formulas. An experimental analysis is left as future work.
IV. A REDUCTION-BASED APPROACH
In this section, it is shown that the typing problem is
reducible to XPath satisﬁability in the presence of DTDs.
Then, using this result, we provide a condition where all the
possible combinations of types of atomic subexpressions can
be efﬁciently enumerated.
Let p be an XPath expression without path union ∪.
Then, for each subexpression p|α of p, there is an atomic
subexpression p|α′ of p such that for any t and w such that
(t, w) |= p, we have w(α)|2 = w(α′)|2. Therefore, in the
rest of this section, we assume without loss of generality
that all the given subexpressions of the typing problem are
atomic.
A. Reduction to XPath satisﬁability in the presence of DTDs
Let S = (N, Σ, B, P) be an XML schema. Deﬁne a
mapping ϕ as follows:
ϕ(S)
=
(N, N × Σ, B, ϕ(P)),
ϕ(P)
=
{X → (X, a)(e) | X → a(e) ∈ P}.
It is easy to show that ϕ(S) is local.
For any t ∈ TL(S) with an interpretation IS
t , let ϕ(t, IS
t )
be a tree such that Vϕ(t,IS
t ) = Vt and λϕ(t,IS
t )(v) = (IS
t (v),
λt(v)). It is easy to see that ϕ(t, IS
t ) ∈ TL(ϕ(S)). On the
other hand, for any t′ ∈ TL(ϕ(S)), let ϕ−1(t′) denote the
tree such that Vϕ−1(t′) = Vt′ and λϕ−1(t′) = λt′|2. It is also
easy to see that ϕ−1(t′) ∈ TL(S) with interpretation λt′|1.
Lemma 2: Let p be an XPath expression without path
union ∪. Also, let p′ be an XPath expression obtained by
replacing each atomic subexpression χα :: lα of p at α with
χα :: (Xα, lα) for some Xα ∈ N.
• Suppose that t ∈ TL(S) with interpretation IS
t
and
(t, w) |= p. Also suppose that for each position α of
p such that p|α is atomic, IS
t (w(α)|2) = Xα. Then,
(ϕ(t, IS
t ), w) |= p′.
• Conversely, suppose that t′ ∈ TL(ϕ(S)) and (t′, w′) |=
p′. Then, (ϕ−1(t′), w′) |= p, and interpretation λt′|1 of
t for S satisﬁes that for each position α of p such that
p|α is atomic, λt′|1(w′(α)|2) = Xα.
Proof: The lemma is shown by induction on the struc-
ture of p. Consider the case where p = χϵ :: lϵ. Suppose
that t ∈ TL(S) with an interpretation IS
t , (t, w) |= p,
and IS
t (w(ϵ)|2) = Xϵ. Since p′ = χϵ :: (Xϵ, lϵ), we have
ϕ(t, IS
t ) |= p′(w(ϵ)). Hence, the ﬁrst condition holds. It is
obvious that the second condition holds.
Consider the case where p = p1/p2. Suppose that t ∈
TL(S) with an interpretation IS
t and (t, w) |= p1/p2. Also
suppose that for each position α of p such that p|α is atomic,
IS
t (w(α)|2) = Xα. Deﬁne two mappings w1 and w2 so that
w1(α) = w(1·α) and w2(α) = w(2·α). Then, (t, w1) |= p1
131
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

and (t, w2) |= p2. By inductive hypothesis, (ϕ(t), w1) |= p′
1
and (ϕ(t), w2) |= p′
2, where p′ = p′
1/p′
2. Hence (ϕ(t), w) |=
p′. Conversely, suppose that t′ ∈ TL(ϕ(S)) and (t′, w′) |=
p′
1/p′
2. Deﬁne two mappings w′
1 and w′
2 so that w′
1(α) =
w′(1 · α) and w′
2(α) = w′(2 · α). Then, (t′, w′
1) |= p′
1 and
(t′, w′
2) |= p′
2. By inductive hypothesis, (ϕ−1(t′), w′
1) |= p1
and (ϕ−1(t′), w′
2) |= p2, and hence (ϕ−1(t′), w′) |= p1/p2.
Moreover, interpretation λt′|1 satisﬁes that for each position
α of pi such that pi|α is atomic, λt′|1(w′
i(α)|2) = Xα (i ∈
{1, 2}). Hence the second condition holds.
The case where p = p1[p2] can be shown similarly.
Theorem 1: The typing problem for an XPath class X
with respect to an XML schema S is reducible in polynomial
time to satisﬁability for XPath class X plus path union in
the presence of a DTD ϕ(S).
Proof: Let (α1, X1), . . . , (αk, Xk) be given pairs of
positions of an XPath expression p and types of S =
(N, Σ, B, P), where N = {Y1, . . . , Yn}. Let ϕ(p) denote
the XPath expression obtained by replacing each atomic
subexpression χi :: li of p at αi with χi :: (Xi, li), and
other atomic ones χ :: l with χ :: (Y1, l) ∪ · · · ∪ χ :: (Yn, l).
Suppose that there exist t ∈ TL(S), an interpretation
IS
t , and a mapping w such that w(ϵ)|1 = ϵ, (t, w) |= p,
and IS
t (w(αi)|2) = Xi for each i (1 ≤ i ≤ k). Then, by
Lemma 2, we have (ϕ(t, IS
t ), w) |= ϕ(p).
Conversely, suppose that there exist t′ ∈ TL(ϕ(S)) and a
mapping w′ such that w′(ϵ)|1 = ϵ and (t′, w′) |= ϕ(p).
Then, by Lemma 2 again, we have (ϕ−1(t′), w′) |= p
and the interpretation λt′|1 of ϕ−1(t′) for S satisﬁes that
λt′|1(w′(αi)|2) = Xi for each i (1 ≤ i ≤ k).
By Theorem 1, many known results on XPath satisﬁability
in the presence of DTDs can be used to realize tractable
combinations of classes of XPath expressions and XML
schemas. For example, from the result in [1], the typing
problem for an XPath class consisting of downward axes
with respect to an arbitrary XML schema S is tractable.
In what follows, we focus on the known results on
disjunction-capsuled DTDs [3], or DC-DTDs for short, since
satisﬁability of wide XPath classes including path union
∪ is tractable under DC-DTDs. A regular expression e is
disjunction-capsuled, or DC for short, if e is in the form of
e1e2 · · · en (n ≥ 1), where each ei (1 ≤ i ≤ n) is either
• a symbol in Σ, or
• in the form of (e′
i)∗ for a regular expression e′
i.
An XML schema S = (N, Σ, B, P) is disjunction-capsuled,
or DC for short, if for each transition rule X → a(e) in P, e
is disjunction-capsuled. Immediately from the results in [3],
we have the following corollary of Theorem 1:
Corollary 1: The typing problem for an XPath class X
with respect to a DC XML schema S is tractable if
• X consists of ↓, ↓∗, →+, ←+, and [ ]; or
• X consists of ↓, ↓∗, ↑, ↑∗, →+, and ←+.
The known time complexities are O(|p||S|4) for the former
case and O(|p|3|S|3) for the latter case.
B. Efﬁcient enumeration of types of subexpressions
The ﬁrst case of Corollary 1 can be extended so that all
the possible combinations of types of atomic subexpressions
(precisely speaking, the witness mappings ξ introduced be-
low) can be efﬁciently enumerated. To demonstrate this, we
ﬁrst brieﬂy explain how satisﬁability can be determined in
this case. We introduce a schema graph of a given DC-DTD,
which represents parent-child relationship as well as the
possible positions of the children speciﬁed by the DC-DTD.
We also deﬁne a satisfaction relation between schema graphs
and XPath expressions. The satisfaction relation coincides
the satisﬁability under DC-DTDs and is decidable efﬁciently.
In what follows, let D = (N, B, P) be a DC-DTD and p be
an XPath expression without upward axes. For each A ∈ N,
let P(A) denote the content model of the unique rule in
P whose left-hand side is A. Moreover, for a DC regular
expression e = e1e2 · · · en, let len(e) denote the number n
of subexpressions of the top-level concatenation.
Deﬁnition 1: The schema graph [3] G = (U, E) of a DC-
DTD D = (N, B, P) is a directed graph deﬁned as follows:
• A node u ∈ U is either
– (⊥, 1, −, B), where ⊥ is a new symbol not in N,
or
– (A, i, ω, A′), where A, A′ ∈ N and 1 ≤ i ≤
len(P(A)) such that A′ appears in the i-th subex-
pression ei of P(A), and ω = “−” if ei is a single
symbol in N and ω = “∗” otherwise.
The ﬁrst, second, third and fourth components of u are
denoted by λpar(u), pos(u), ω(u), and λ(u), respec-
tively.
• An edge from u to u′ exists in E if and only if λ(u) =
λpar(u′).
If t ∈ TL(D), then each node of t can be associated with
a node of the schema graph of D. More precisely, there
exists a mapping θ, called an SG mapping of t, from the set
of nodes of t to the set of nodes of the schema graph of D
with the following properties:
• θ maps the root node of t to (⊥, 1, −, B).
• Let v be a node of t with n children. Then, θ(v ·
j) = (λt(v), ij, ωij, λt(v · j)), where 1 ≤ ij
≤
len(P(λt(v))), ωij = “−” if the ij-th subexpression
of P(λt(v)) is a single symbol in N and ωij = “∗”
otherwise, and ij ≤ ij′ if j ≤ j′. Moreover, for
every maximum subsequence (v·j) · · · (v·j′) such that
ij = · · · = ij′, the ij-th subexpression of P(λt(v))
matches λt((v · j) · · · (v · j′)).
A satisfaction relation |=DC of an XPath expression p by
a schema graph G with a witness mapping ξ, which is from
the set of positions of p to the set of pairs of nodes of G, is
deﬁned as follows (some cases are omitted because of the
space limitation):
• G |=DC (↓:: l)(ξ(α)) if there is an edge from ξ(α)|1
to ξ(α)|2 in G and λ(ξ(α)|2) = l.
132
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

• G
|=DC
(→+::
l)(ξ(α))
if
λpar(ξ(α)|1)
=
λpar(ξ(α)|2), λ(ξ(α)|2)
=
l, and pos(ξ(α)|1)
<
pos(ξ(α)|2) if ω(ξ(α)|1) = “−” and pos(ξ(α)|1) ≤
pos(ξ(α)|2) if ω(ξ(α)|1) = “∗”.
• G
|=DC
(p1/p2)(ξ(α)) if G
|=DC
p1(ξ(α · 1)),
G |=DC p2(ξ(α·2)), ξ(α·1)|2 = ξ(α·2)|1, and ξ(α) =
(ξ(α · 1)|1, ξ(α · 2)|2).
• G |=DC (p1 ∪ p2)(ξ(α)) if G |=DC pi(ξ(α · i)) and
ξ(α) = ξ(α · i) for some i ∈ {1, 2}. Moreover, if j ∈
{1, 2} does not satisfy G |=DC pj(ξ(α · j)), then for
any position α′ whose preﬁx is α·j, ξ(α′) is undeﬁned.
If G |=DC p(ξ(ϵ)), we say that G satisﬁes p with witness ξ
and write (G, ξ) |=DC p.
Theorems 3 and 4 in [3] imply the following theorem:
Theorem 2: If (t, w) |= p with an SG mapping θ, then
(G, θ ◦ w) |=DC p. Conversely, if (G, ξ) |=DC p, then there
is an SG mapping θ such that ξ = θ ◦ w and (t, w) |= p.
Hence, ξ such that (G, ξ) |=DC p has enough information
to give one possible combination of the types of atomic
subexpressions of p.
Let S be a given DC XML schema and p be a given XPath
expression without path union and upward axes. Let ϕ′(p)
denote the expression obtained by replacing each atomic
subexpression χ :: l of p with χ :: (Y1, l)∪· · ·∪χ :: (Yn, l),
where Y1, . . . , Yn are all the states of S. Now, the enumer-
ation algorithm is as follows. First, construct the schema
graph G of DC-DTD D = ϕ(S). Then, compute the set
Ξ(α) of all the pairs (u, u′) such that G |=DC ϕ′(p)|α(u, u′)
for each position α of p, in a bottom-up manner with respect
to the structure of p. Finally, by traversing Ξ in a top-
down manner with respect to α, construct each ξ such that
(G, ξ) |=DC p. Each ξ can be enumerated with worst-case
delay O(|p||S|4) time.
V. CONCLUSION
This paper has discussed typing XPath subexpressions
with respect to an XML schema. An algorithm which
directly decides the typing problem has been proposed.
Moreover, it has been shown that the typing problem is
reducible to the XPath satisﬁability problem in the presence
of DTDs, for which many tractability results are known.
In the deﬁnition of the typing problem, we have excluded
the path union operator ∪ from XPath expressions. Actually,
we have found that handling path union is a challenging
task. For example, consider an XPath expression p1 ∪ p2.
If (ϵ, X) is speciﬁed, then we have to check whether X is
associated with p1 or X is associated with p2. On the other
hand, if (1, Y ) and (2, Z) are speciﬁed, then we have to
check whether Y is associated with p1 and Z is associated
with p2 simultaneously. In this sense, the meaning of ∪
changes depending on the speciﬁed pairs of positions and
types. Now we are trying to incorporate path union operator
and to ﬁnd a wider condition where the typing problem
is solvable efﬁciently. However, we are also conjecturing
that polynomial-time reduction to XPath satisﬁability in the
presence of DTDs is possible only if atomic subexpressions
are speciﬁed in the typing problem. It is also interesting to
investigate whether efﬁcient enumeration is possible in the
second case of Corollary 1.
ACKNOWLEDGMENT
The authors thank the anonymous reviewers for their
helpful comments to improve the paper. This research is
supported in part by Grant-in-Aid for Scientiﬁc Research (C)
23500120 from Japan Society for the Promotion of Science.
REFERENCES
[1] M. Benedikt, W. Fan, and F. Geerts, “XPath satisﬁability in
the presence of DTDs,” Journal of the ACM, vol. 55, no. 2,
2008.
[2] M. Montazerian, P. T. Wood, and S. R. Mousavi, “XPath
query satisﬁability is in PTIME for real-world DTDs,” in Pro-
ceedings of the 5th International XML Database Symposium,
LNCS 4704, 2007, pp. 17–30.
[3] Y. Ishihara, T. Morimoto, S. Shimizu, K. Hashimoto, and
T. Fujiwara, “A tractable subclass of DTDs for XPath satis-
ﬁability with sibling axes,” in Proceedings of the 12th Inter-
national Symposium on Database Programming Languages,
2009, pp. 68–83.
[4] P. T. Wood, “Containment for XPath fragments under DTD
constraints,” in Proceedings of the 9th International Confer-
ence on Database Theory, 2003, pp. 297–311.
[5] G. Miklau and D. Suciu, “Containment and equivalence for a
fragment of XPath,” Journal of the ACM, vol. 51, no. 1, pp.
2–45, 2004.
[6] F. Neven and T. Schwentick, “On the complexity of XPath
containment in the presence of disjunction, DTDs, and vari-
ables,” Logical Methods in Computer Science, vol. 2, no. 3,
2006.
[7] H. Bj¨orklund, W. Martens, and T. Schwentick, “Optimizing
conjunctive queries over trees using schema information,”
in Proceedings of the 33rd International Symposium on
Mathematical Foundations of Computer Science, 2008, pp.
132–143.
[8] K. Hashimoto, Y. Kusunoki, Y. Ishihara, and T. Fujiwara,
“Validity of positive XPath queries with wildcard in the
presence of DTDs,” in The 13th International Symposium on
Database Programming Languages, 2011. [Online]. Avail-
able: http://www.cs.cornell.edu/conferences/dbpl2011/papers/
dbpl11-hashimoto.pdf
[9] M. Murata, D. Lee, M. Mani, and K. Kawaguchi, “Taxonomy
of XML schema languages using formal language theory,”
ACM Transactions on Internet Technology, vol. 5, no. 4, pp.
660–704, 2005.
[10] P. Genev`es, N. Laya¨ıda, and A. Schmitt, “Efﬁcient static
analysis of XML paths and types,” in Proceedings of the
ACM SIGPLAN 2007 Conference on Programming Language
Design and Implementation, 2007, pp. 342–351.
133
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

