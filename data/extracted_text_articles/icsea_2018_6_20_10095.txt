Tracing and Reversing the Run of Software Systems
Implemented by Petri Nets
Radek Koˇc´ı and Vladim´ır Janouˇsek
Brno University of Technology, Faculty of Information Technology,
IT4Innovations Centre of Excellence
Bozetechova 2, 612 66 Brno, Czech Republic
{koci,janousek}@ﬁt.vutbr.cz
Abstract—Application run tracing and application interactive
debugging are integral part of the software systems development
process. In many cases, the possibility to execute reverse steps of
the system run would make debugging easier and quicker due to
examination of the system state before it got into the wrong or
disabled state. Currently, techniques of reversing the system run
are not widespread, but there are experimental implementations.
Nevertheless, these solutions increase overhead of the application
run due to the logging of the information needed to restore
previous states. Moreover, many of them increase overhead in a
signiﬁcant way. This article focuses on the possibility of reversing
the run of systems whose behavior is described by Petri nets.
The work follows the methodology of designing and validating
system requirements using functional models that combine formal
notation with objects of production environment and can be used
as a full-ﬂedged application. Due to the nature of Petri Nets
formalisms, it is possible to deﬁne reverse operations to reduce
the overhead of application run.
Keywords–Object Oriented Petri Nets; debugging; tracing; re-
verse debugging; requirements validation.
I.
INTRODUCTION
This work builds on the concepts of formal approach to
design and develop system requirements and, consequently,
their implementation using Petri Nets [1]. It is part of the
Simulation Driven Development (SDD) approach [2] com-
bining basic models of the most used modeling language
Uniﬁed Modeling Language (UML) [3][4] and the formalism
of Object-Oriented Petri Nets (OOPN) [5]. This approach is
based on ideas of model-driven development dealing with gaps
between different development stages and focuses on the usage
of conceptual models during the development process of sim-
ulation models—these techniques are called model continuity
[6]. Model continuity concept works with simulation models
during design stages, while the approach based on Petri Nets
focuses on live models that can be used in the deployed system.
When testing models or implementations, developers often
use the interactive debugging technique, which allows to go
through the system run and investigate its state step by step.
The logging technique and subsequent analysis of the running
system is less often used. These techniques are linked to
the limits of their use, notably the inability to make reverse
steps. In this case, it is difﬁcult to determine the system
states before stopping (e.g., at breakpoints). However, the
introduction of reverse interactive debugging leads to increased
overhead especially for running an application where it is
necessary to collect the information needed to reconstruct the
previous states. There are several approaches that differ in
their possibilities and overhead. A very important factor is,
in addition to higher demands on the runtime of application,
that there is a higher demand for memory that keeps the
collected information. Another issue is the overhead of reverse
debugging, which is not as important as the run overhead.
There are three basic approaches to solving this problem.
The ﬁrst one records the system run and then performs all the
steps from the beginning to the desired point (record-replay
approach). The second approach records all the information
needed to return to the previous step (trace-based approach).
The third approach records only selected checkpoints so they
are reliably replicated (reconstruction-based approach). Re-
verse debugging is done by reconstructing the appropriate
checkpoint state and then making forward steps. The approach
presented in this paper is based on the trace-based reverse
debugging. Due to the nature of used OOPN formalism, which
has a formal base working with unambiguously deﬁned events,
there is no problem to deﬁne and perform reverse operations
associated to each event.
The paper is organized as follows. Section II introduces
related work. Section III summarizes basic deﬁnitions of
OOPN formalism needed to deﬁne tracing concepts. Section
IV discuss the possibilities of OOPN models simulation tracing
and introduces the simple demonstrating model. Section V
focuses on recording states and event during the simulation
and Section VI describes reverse events and operation when
reverse debugging performed. The summary and future work
is described in Section VII.
II.
RELATED WORK
The solution based on recording simulation run and re-
playing it from the beginning to the breakpoint may be time
consuming and, for a long run of the application, unsuitable
due to time lags when debugging. As examples we can mention
Instant Replay debugger [7] or Microsoft Visual Studio 2010
IntelliTrace [8].
The trace-based solution logs all steps, so it is possible to
determine the current state and the sequence of steps that led to
this state. In many cases, the simulators record everything and,
therefore, it is possible to go back to one of the previous steps.
The scope of that solution is limited by what and how can
be traced, especially using multi-processors is very difﬁcult to
122
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

work. As examples we can mention Green Hills Time Machine
[9], Omniscient Debugger [10] fo Java Virtual Machine, or gnu
reverse debugger gdb 7.0 [11]. The last mentioned, gdb debug-
ger, is very slow, but is the only open-source solution. There
are tools based on Petri nets that allow reverse debugging,
e.g., the TIme petri Net Analyzer TINA [12]. Nevertheless,
these tools focus on a speciﬁc variant of Petri nets that are
not not usable for the application environment. Besides, there
are also tools suitable for these purposes, e.g., Renew [13],
that are similar to the SDD approach but do not allow reverse
debugging.
Some solutions allow to go back in the operation stack,
change the current state and proceed from this step. An
example may be the Smalltalk language [14]. Even in this case,
however, we do not have the state of the system associated with
the appropriate step, but only the current state whose image
we see in the context of methods that were called.
III.
BASIC DEFINITION OF OOPN FORMALISM
In this section we will introduce the basic deﬁnition of
Object-oriented Petri Nets (OOPN) formalism necessary for
the presented purpose.
A. System of classes and objects
For the purposes of this work, we deﬁne the Object
Oriented Petri Nets (OOPN) as a system of classes and objects
that consists of the individual elements [15].
Deﬁnition 1: System OOPN is Π = (Σ, Γ, c0, o0), where
Σ is a system of classes, Γ is a system of objects, c0 is an initial
class and o0 is an identiﬁer of the initial object instantiated
from the class c0.
Deﬁnition 2: System
of
classes
Σ
consists
of
sets
of
elements
constituting
classes
and
is
deﬁned
as
Σ
=
(CΣ, MSG, NO, NM, SP, NP, P, T, CONST, VAR),
where CΣ is a set of classes, MSG is a set of messages, NO
is a set of object nets, NM is a set of method nets, SP is a
set of synchronous ports, NP is a set of negative predicates,
P is a set of places, T is a set of transitions, CONST is a set
of constants and VAR is a set of variables. Messages MSG
correspond to method nets, synchronous ports, and negative
predicates.
Deﬁnition 3: System of objects Γ is a structure containing
sets of elements constituting the model runs (the model run
corresponds to the simulation, so that we will use the notation
of simulation). Γ = (OΓ, NΓ, MN, MT), where OΓ is a set
of object identiﬁers, NΓ is a set of method nets identiﬁers,
MN ⊂ (OΓ ∪ NΓ) × P × UM is place markings and MT ⊂
(OΓ ∪ NΓ) × T × P(BIND) is transition markings.
Deﬁnition 4: The OOPN system universe U is deﬁned
U = {(cnst, cls, oid) | cnst ∈ CONST ∧ cls ∈ CΣ ∧ oid ∈
OΓ}. The system universe represents a set of all possible values
that may be part of markings or variables.
We can use the following notation to simplify writing. For
constants, we write down their values directly, e.g., 10, ′a′. For
classes, we write down their names directly without quotes or
apostrophes. To identify an object, we will write its identiﬁer
with a @ character.
Deﬁnition 5: The set of all variable bindings BIND used
in OOPN is deﬁned BIND = {b | b : VAR −→ U}.
Deﬁnition 6: We deﬁne operators for instantiating classes
∐C and method nets ∐N that create the appropriate instances
and assign them identiﬁers from sets OΓ, resp. NΓ. When
creating a new instance of the class c ∈ CΣ, we will write
∐C(c) = o or ∐C(c, o), where o ∈ OΓ. Similarly, for the
method net instance m ∈ NM, we will write ∐N(o, m) = n
or ∐N(o, m, n), where o ∈ OΓ is an object where the method
net instance n ∈ NΓ is created.
Individual class elements are identiﬁed by their fully qual-
iﬁed names consisting of sub-element names separated by a
dot. The class is identiﬁed by its name, e.g., C. The method is
identiﬁed by class and method names, e.g., C.M, the method
place C.M.P, and so on. In the case of object net, the elements
will be written directly without method identiﬁcation, e.g.,
C.P. Similarly, we will introduce the identiﬁcation of Γ object
system elements. Objects and nets instances are uniquely
identiﬁed by their identiﬁers, net elements (transitions and
places) by their names. For instance, the transition t ∈ T of the
method net mi ∈ NΓ can be identiﬁed by following notations:
mi.t or (mi, t). The object net describes the autonomous
activities of the object, its instance is always created with the
instantiation of the class, and is just one. For this reason, the
notation o ∈ OΓ can identify the class instance as well as its
object net. Method nets describe the object’s response to the
sent message. In case the message is received, the instance
n ∈ NΓ of the respective net NM is created and its simulation
starts.
B. Place
The place is represented by a named multi-set. The multi-
set AM is a generalization of the set A such that it can contain
multiple occurrences of elements. Thus, the multi-set can be
deﬁned as a function AM : A
→ N, which assigns to each
element a ∈ A the number of occurrences in the multi-set. The
number of occurrences will be denoted by the term frequency.
We will denote |A| the cardinality of the set A, i.e., the number
of elements in the set A. We will denote |AM| the cardinality
of multi-set AM, i.e., the sum of frequencies of all elements
in the set A. For an individual element x of the place p ∈ P,
we will write x ∈ p a for its frequency m‘x.
Deﬁnition 7: The place marking corresponds to its content
and is deﬁned as a multi-set MP = {(m, o) | m ∈ N+ ∧ o ∈
U}, where m is frequency of the member o in the multi-set.
Members of multi-set will be written in the form m‘o, marking
of the place p ∈ P will be written in the form MP(p) =
{m1‘o1, m2‘o2, . . . }.
C. Arc Expression
Arc expression matches the usual approach used in Petri
nets. Each arc expression has a form of m‘o, where m ∈
N+ ∪ VAR and o
∈ U ∪ VAR. The expression element
m represents the frequency of o in the multi-set and can be
denoted by a numeric value or a variable. If the variable is
used at the position m, the frequency of the member o in
multi-set is assigned to that variable. The element o represents
the object stored in multi-set and can be deﬁned by the element
of the universe U or the variable. If a variable is used at
123
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

the position o, an object from multi-set, whose frequency
corresponds to speciﬁed m, is bound to that variable. If both
parts of an expression are deﬁned by variables, any object and
its frequency are bound to these variables. If the content of
multi-set does not match the given expression, the bounding
process fails.
D. Set of Classes
The formalism of OOPN works, in addition to the OOPN
objects (OΓ and the corresponding set of classes CΣ), with
objects that are not a direct part of the formalism. Principle
of their usage is based on Smalltalk, which is also used as the
inscription language of the formalism of OOPN. These objects
are especially basic constant objects (sometimes also called
primitive objects) such as numbers, symbols, characters, and
strings. The corresponding classes will be denoted Number,
Symbol, Character and String and their set, in sum, CC.
Objects of these classes are part of the set of constants
CONST. In addition to these basic objects, OOPN formalism
can work with other objects and classes. In particular, it cov-
ers collections, graphical user interface objects, user-deﬁned
classes, etc. We will call the set of these classes as domain
classes and denote with the symbol CD, CC ⊂ CD. A set of
object identiﬁers created from classes CD is denoted OD.
Deﬁnition 8: Let CΠ = CΣ∪CD be a set of all classes that
can be used by the formalism of OOPN. Let OΠ = OΓ∪OD be
a set of all object identiﬁers that can be instantiated (created)
from classes CΠ.
Deﬁnition 9: Extended Universe UΠ of OOPN is deﬁned
UΠ = {(cnst, cls, oid) | cnst ∈ CONST ∧ cls ∈ CΠ ∧ oid ∈
OΠ}.
IV.
SIMULATION TRACING
In this section, we brieﬂy outline the sample model and
discuss the possibilities of tracing the run of software system
described by the formalism of OOPN. We will call that run
simulation.
A. Sample Model
The basic concept will be outlined using a simple example.
Figure 1 shows classes of that example. Figure 1a) depicts the
initial class A1 with its object net and Figure 1b) depicts the
class A2 having the only method calc: with one parameter x.
a := x + 10.
b := a * 2.
calc: x
return
t2
x
x
b
o := A2 new.
r := o calc: x.
p2
t1
x
r
p1
1) 1‘10
a)
b)
2) 1‘10, 1‘20
Figure 1.
The sample model consisting of two classes A1 and A2; a) class
A1 has only object net and b) class A2 has only method net calc:.
At the simulation start, an instance o0 from the initial
class A1 is created, ∐C(A1, o0). The object net o0 creates an
instance of the class A2, ∐C(A2, o1), and calls its method net
calc: from the transition o0.t1, ∐N(o1, calc:, n1). The method
net n1 executes the transition n1.t2. This example works
with two variants of initial marking of the object net A1; 1)
MP(p1) = {1‘10} and 2) MP(p1) = {1‘10, 1‘20}.
B. Tracing Tree
The simulation progress can be recorded as a tree, where
nodes represent the relevant unit of simulation run and edges
represent a sequence of units execution including the bindings.
The relevant unit is understand as the least set of events that
the tracer records. Tree root represents the input point of the
calculation. If a parallel calculation occurs during the execution
of the relevant unit, this unit has more successors in its tree
view. The current state of the calculation is then represented
by all tree leaves. In Figure 2, we can see such a tree for
the model from Figure 1 for the variant of initial marking
MP(p1) = {1‘10, 1‘20}. In this example, the relevant unit
is one executed command. Edges are recorded with a full-
line arrow. Nodes capture on which network and transition the
command has been performed.
o0
t1 {r := o calc: x.}
o0
t1 {o := A2 new.}
o0
t2 {a := x + 10.}
o1.m1
t2 {b := a * 2.}
o1.m1
t1 {r := o calc: x.}
o0
t1 {o := A2 new.}
o0
t2 {a := x + 10.}
o2.m1
t2 {b := a * 2.}
o2.m1
(x=10)
(x=20)
(x=10,o=@o1)
(x=20,o=@o2)
(x=10)
(x=10, a=20)
(x=20)
(x=20, a=30)
Figure 2.
Scenario model of one simulation run.
The tree constructed by that way represents threads that
may appear while running the simulation. It does not, however,
capture the succession of steps that are important for making
backward steps. The sequence of steps can be different and
depends on the speciﬁc conditions of the simulation run. One
such variant is captured in Figure 2 with the dashed line
arrows.
C. Event
The simulation run is driven by events. Each executed
(ﬁred) event changes the system state, and, therefore, repre-
sents one step of model simulation. The set of states S of the
system has a character of the net instances marking, which
includes marking of places and transitions. One step from the
state s ∈ S to the state s′ ∈ S is written in the form s [ev⟩ s′,
where ev is an executed event .
Deﬁnition 10: Event is ev = (e, id, t, b), where e is a type
of event, id ∈ NΓ∪OΓ is the identiﬁer of net instance the event
124
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

executes in, t ∈ T is the transition to be executed (ﬁred), and
b ∈ P(BIND) is variables binding the event is to be executed
for.
Event types can be as follows: A represents an atomic
event, the entire transition is done in one step; F represents
sending a message, i.e., creating an instance of a new method
net and waiting for its completion; J represents completion of
the method net called at F event.
D. Event ﬂow subgraph
The object net can describe multiple scenarios, either
interconnected or totally disjoint. The structure of each net
is deﬁned by a graph of the Petri net, so we can deﬁne the
scenarios as subgraphs of such nets.
Deﬁnition 11: Let S(OΓ ∪ NΓ) be a set of all valid
subgraphs of object nets OΓ and method nets NΓ. Individual
scenarios will be denoted δc(n) = (ev0, ev1, . . . ), where
n ∈ OΓ ∧ c ∈ N.
Now, we return to the step (i.e., event) sequence entry
shown in Figure 2 and write the presented scenario in the form
of net subgraph, δ = ([A, o0, t1, (x = 10)⟩, [F, o0, t1, (x =
10, o = @o1)⟩, [A, o0, t1, (x = 20)⟩, [F, o0, t1, (x = 20, o =
@o2)⟩, [A, o1.m1, t2, (x = 10)⟩, [A, o1.m1, t2, (x = 10, a =
20)⟩, [A, o2.m1, t2, (x = 20)⟩, [A, o2.m1, t2, (x = 20, a =
30)⟩).
E. Composite Command
If the transition contains a sequence of messages, either
step-by-step or composite ones, this transition can be under-
stood, from the OOPN theory point of view, as a sequence
of simple transitions, each of which contains just one simple
command. An example of such equivalence is shown in Figure
3.
p1
p2
≈
a)
b := o doit: (n+2).
(@o1, 10), 
(@o2, 20)
(o, n)
t1
p1
p2
b)
tmp1 := (n+2).
b := o doit: tmp1.
(o, n)
t1
b
b
p1
t1_tmp1
c)
tmp1 := (n+2).
(o, n)
t1[1]
(o, n, tmp1)
p2
b := o doit: tmp1.
t1[2]
b
(o, n, tmp1)
≈
(@o1, 10), 
(@o2, 20)
(@o1, 10), 
(@o2, 20)
Figure 3.
Composite command of the transition.
This model has four variants of execution. In the following
example, only one is listed, the others are a combination of
different interleaving of two concurrently running transitions
t1. The notation of a transition using index, e.g., t1[1], refers
to the corresponding command of the composite transition.
δ1(o0)
=
([A, o0, t1[1], {o = @o1, n = 10}⟩,
[F, o0, t1[2], {o = @o1, n = 10, tmp1 = 12}⟩,
[J, o0, t1[2], {(o = @o1, n = 10, tmp1 = 12}⟩,
[A, o0, t1[1], {(o = @o2, n = 20}⟩,
[F, o0, t1[2], {o = @o2, n = 20, tmp1 = 22}⟩,
[J, o0, t1[2], {o = @o2, n = 20, tmp1 = 22}⟩)
V.
RECORDING THE SIMULATION
This section focuses on recording states during simulation.
We will describe each of the monitored events and how the
state changes are recorded. To record the entire state would
be very time consuming and memory intensive, and from
the means offered by OOPN formalism point of view also
unnecessary. For the purpose of stepping, it is sufﬁcient to save
partial state changes. This avoids storing the whole simulation
image after every step.
A. State Changes Processing
A partial state change may involve inserting or selecting
an element from a place, assigning the result to a variable,
creating or destroying an object, creating or completing a
method net instance (associated with calling and terminating
this method), and creating or completing a transition instance.
1) Changing Place State: Changing the place state is the
easiest operation corresponding to removing elements when
transition ﬁres, or adding elements when transition is complete.
Within one step, more elements can be inserted or removed
into or out of more places. The change will be recorded in the
following notation. Operation add(p, m, o) for adding element
to the place and operation del(p, m, o) for removing element
from the place, where p ∈ P is the place and m ∈ N+ is the
frequency of element o ∈ U.
2) Firing and Completing Composite Transition: Although
the composite command in the transition is always interpreted
by individual commands, it is necessary to maintain a re-
lationship to the original entire transition. Additionally, the
transition can be run multiple times for different bindings,
so it is necessary to uniquely identify the speciﬁc transition
instance. Therefore, we will introduce a special event type
B, which represents the transition ﬁring for a given binding,
and at the same time assigns a unique identiﬁer to the ﬁred
transition. Similarly, we will introduce a special C event type
to completing the ﬁred transition.
Deﬁnition 12: For the purpose of writing state changes, we
will extend the deﬁnition of the system of objects Γ to the set
of transition instance identiﬁers TΓ, i.e., transitions ﬁred with
a speciﬁc binding, Γ = (OΓ, NΓ, TΓ, MN, MT).
3) Changing Variable State: Changing the state of the
variable when executing the transition is denoted by operation
swap(ti, v, onew, oold), where ti ∈ TΓ is a transition, v ∈ VAR
is the transition variable, onew ∈ U is a universe object
assigned to the variable v and oold ∈ U is the original object
assigned to the variable v before this event occurs.
125
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

4) Creating Object: Creating an object (a class instance)
corresponds to the creation of an object net and its initial-
ization. In terms of state recording, it is important to keep
information about identiﬁcation of newly created object ∐C
and changes of the object net’s places, i.e., adding objects into
places during the net initialization process.
5) Creating Method Net Instances: Creating a method
net instance corresponds to a method invoking by sending a
message. As with the object, it is necessary to keep information
about identiﬁcation of newly created instance ∐N and inserting
objects (values) into the net’s parameter places.
6) Completing Method Net Instances: After the method net
instance is completed, two possible options can be applied to
record changes. First, the current state of entire net is recorded,
i.e., marking of all places and all ﬁred transitions (instances).
Second, no state is recorded. The ﬁrst option is more demand-
ing for time and memory space during simulation, but it is not
necessary to reconstruct the net’s state so that it matches the
state before its completion. The second option is more efﬁcient
during simulation, but it is more demanding to reconstruct the
net’s state during backward stepping. At this point we will
focus on the option without state recording. We will introduce
a special operation ∆N(mi), which indicates the completion
and cancellation of the net instance mi.
B. Example of Tracing Simulation
We demonstrate the concept of simulation tracking on the
model shown in Figure 1 for variant 1, i.e., with the initial
marking MP(p1) = {1‘10}. For the reasons given in Section
V-A2, we will modify the event deﬁnition as follows:
Deﬁnition 13: Event is ev = (e, id, t, ti, b), where e is
a kind of event, id ∈ NΓ ∪ OΓ is the identiﬁer of the net
instance the event executes in, t ∈ T is the transition to be
executed (ﬁred), and b ∈ P(BIND) is variables binding for
which this event is executed, and ti ∈ TΓ is the identiﬁer of
ﬁred transition.
The sequence of ﬁred transitions does not necessarily
correspond to the tracing tree, which also takes into account the
simulation branching. Sequence of ﬁred transitions captures a
speciﬁc sequence of events, which is always unambiguously
given. Figure 4 captures the sequence of events (scenario)
completed with state change operations. This is about tracing
a simulation with storing relevant information for backward
stepping. We can see individual state changes in the State
column. For the purpose of this text, we will simplify writing
events so that we do not specify the binding b.
VI.
REVERSE DEBUGGING
In this section, we describe steps that are performed when
stepping backwards.
A. State Changes Reverse Processing
There is a sequence of reverse operations for each state
change that allows to return to the previous step. We explain
the operations associated with each recorded event. Some of
the operations will be demonstrated on discussed example, ﬁrst
steps of reverse debugging are shown in Figure 5.
Event
State
∐C(A1, o1)
add(o1.p1, 1, (10, ε, ε))
[B, o1, t1, t11⟩
del(o1.p1, 1, (10, ε, ε))
swap(t11, x, (10, ε, ε), ε)
[A, o1, t1[1], t11⟩
∐C(A2, o2)
swap(t11, o, (ε, ε, o2), ε)
[F, o1, t1[2], t11⟩
∐N(o2, A2.calc:, m1)
add(o2.m1.x, 1, (10, ε, ε))
[B, o2.m1, t2, t21⟩
del(o2.m1.x, 1, (10, ε, ε))
swap(t21, x, (10, ε, ε), ε)
[A, o2.m1, t2[1], t21⟩
swap(t21, a, (20, ε, ε), ε)
[A, o2.m1, t2[2], t21⟩
swap(t21, b, (40, ε, ε), ε)
[C, o2.m1, t2, t21⟩
add(o2.m1.return, 1, (40, ε, ε))
[J, o1, t1[2], t11⟩
∆N(m1)
swap(t11, r, (40, ε, ε), ε)
[C, o1, t11⟩
add(o1.p2, 1, (40, ε, ε))
Figure 4.
Scenario record.
1) C-Event Type: The event C represents completing the
transition instance ti. In a step back, our goal is to reconstruct
this instance. It is necessary perform the reverse operations that
are associated with this event. Since these operations refer to
the insertion of elements into the output places, the reverse
operations are therefore the removal of these elements. The
next step is to reconstruct the state of transition instance ti.
We ﬁnd the ﬁrst entry regarding the instance ti, i.e., [B, t, ti⟩,
create this instance and perform all the swap operations. In
our example, this would be a sequence of events [B, t1, t11⟩,
[A, t1[1], t11⟩, [F, t1[2], t11⟩ and [J, t1[2], t11⟩. Event B en-
sures creation of the appropriate instance with the t11 iden-
tiﬁer. The associated sequence of swap operators is as fol-
lows: swap(t11, x, (10, ε, ε), ε), swap(t11, o, (ε, ε, o2), ε) and
swap(t11, r, (40, ε, ε), ε). This way we ﬁlled all the variables
with appropriate values, and we are in a state where the
transition instance t11 was completed. If the object, resp. its
identiﬁer, that has been destroyed (e.g., because it was removed
by a garbage collector) is assigned to the variable, it is not
essential at this point. The object will be reconstructed at the
ﬁrst access to it (state handling, work with method net, etc.).
2) J-Event Type: The event J represents completing the
call of method. The reverse swap operation is executed, i.e., the
value is removed from the variable and replaced with the origi-
nal (previous) value. The next step is to perform a reverse oper-
ation ¯
∆N(mi) to destroying the method net ∆N(mi), i.e., creat-
ing net instance mi and reconstructing its last state. Using oper-
ation ¯
∆N(mi), we get a sequence of operations over the net mi
starting with ∐N(oi, class.method name, mi) operation. From
this sequence, we will perform add and del operations on the
net instance mi. In our example, it would be a sequence of op-
erations add(o2.m1.x, 1, (10, ε, ε)), del(o2.m1.x, 1, (10, ε, ε))
and add(o2.m1, return, 1, (40, ε, ε)). As a result, we made
method net in the state, where the place return contains the
object representing number 40.
126
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

Step
State
[C, o1, t11⟩
del(o1.p2, 1, (40, ε, ε))
[J, o1, t1[2], t11⟩
swap(t11, r, ε, (40, ε, ε))
¯
∆N(m1) ⇒
∐N(o2, A2.calc:, m1)
add(o2.m1.x, 1, (10, ε, ε))
del(o2.m1.x, 1, (10, ε, ε))
add(o2.m1.return, 1, (40, ε, ε))
[C, o2.m1, t2, t21⟩
del(o2.m1.return, 1, (40, ε, ε))
swap(t21, x, (10, ε, ε), ε)
swap(t21, a, (20, ε, ε), ε)
swap(t21, b, (40, ε, ε), ε)
[A, o2.m1, t2[2], t21⟩
swap(t21, b, ε, (40, ε, ε))
Figure 5.
Reverse scenario.
It may happen that there are still instances of transitions
that are not terminated at the method net completion. These
instances must also be reconstructed. From the sequence of
operations ¯
∆N(mi), we ﬁnd such sequences that correspond to
unﬁnished transitions starting with [B, t, ti⟩ event, but having
no event [C, ti⟩. For each such sequence we perform actions
similarly to the backward step of [C, ti⟩ event.
3) F-Event Type: The event F represents the method invok-
ing on the object. In the reverse step, the appropriate instance
of method net speciﬁed in ∐N operator is destroyed.
4) A-Event Type: The event A represents the atomic execu-
tion of the operation. The reverse swap operation is executed,
i.e., the value is removed from the variable and replaced with
the original (previous) value. If the atomic operation is a
creation of a class instance ∐C, this instance is destroyed.
5) B-Event Type: The event B represents the start of
transition execution (creation of a transition instance). In the
reverse step, the transition instance ti is destroyed and the
add reverse operation is performed. There is no need to swap
variables, as the entire ﬁred transition is canceled.
B. Object Reconstruction
At the time of access to the object, e.g., due to the
reconstruction of the method net, it may happen that the object
no longer exists. The reason may be the loss of all references
to this object and its removal by the garbage collector. At
this point, it is necessary to create the object and reconstruct
its last state. Because the object was destroyed, it means
that there were no existing method nets. It is necessary to
reconstruct the state of the object net, which is done in the
same way as the method net reconstruction. The sequence of
corresponding operations on the object net oi is obtained by
using ¯
∆O(oi) operation, which is similar to ¯
∆N(oi) operation,
but the obtained sequence starts with ∐C(class, oi) operation
and the class instance is created instead of method net instance.
VII.
CONCLUSION
The paper dealt with the concept of tracing and reversing
run of software system modeled by Petri Nets, especially the
formalism of Object Oriented Petri nets. Presented concept is
fully functional, but has not yet taken into account all the pos-
sibilities of use. We were only concerned with pure Petri Nets
objects and passed the domain objects, e.g., collections, objects
of user classes etc. We have also abstracted the possibility of
having objects that have running method nets, even though they
were collected by garbage collector. The reason is an existence
od cyclic dependencies but unavailable from the initial object.
The last constraint is to omit the method from the external
(domain) object. At present, we have an experimental partial
implementation of the tool supporting reverse debugging. We
will complete the implementation in the future and focus on
the above-mentioned limitations.
ACKNOWLEDGMENT
This work has been supported by the internal BUT project
FIT-S-17-4014 and The Ministry of Education, Youth and
Sports of the Czech Republic from the National Programme
of Sustainability (NPU II); project IT4Innovations excellence
in science - LQ1602.
REFERENCES
[1]
R. Koˇc´ı and V. Janouˇsek, “Speciﬁcation of Requirements Using Uniﬁed
Modeling Language and Petri Nets,” International Journal on Advances
in Software, vol. 10, no. 12, 2017, pp. 121–131.
[2]
R. Koˇc´ı and V. Janouˇsek, “Modeling and Simulation-Based Design
Using Object-Oriented Petri Nets: A Case Study,” in Proceeding of the
International Workshop on Petri Nets and Software Engineering 2012,
vol. 851.
CEUR, 2012, pp. 253–266.
[3]
J. Rumbaugh, I. Jacobson, and G. Booch, The Uniﬁed Modeling
Language Reference Manual.
Addison-Wesley, 1999.
[4]
C. Raistrick, P. Francis, J. Wright, C. Carter, and I. Wilkie, Model
Driven Architecture with Executable UML.
Cambridge University
Press, 2004.
[5]
M. ˇCeˇska, V. Janouˇsek, and T. Vojnar, “Modelling, Prototyping, and Ver-
ifying Concurrent and Distributed Applications Using Object-Oriented
Petri Nets,” Kybernetes: The International Journal of Systems and
Cybernetics, vol. 2002, no. 9, 2002.
[6]
D. Cetinkaya, A. V. Dai, and M. D. Seck, “Model continuity in
discrete event simulation: A framework for model-driven development
of simulation models,” ACM Transactions on Modeling and Computer
Simulation, vol. 25, no. 3, 2015.
[7]
T. LeBlanc and J. Mellor-Crummey, “Debugging Parallel Programs with
Instant Replay,” IEEE Transactions on Computers, vol. 36, no. 4, 1987,
pp. 471–482.
[8]
I. Huff, “IntelliTrace in Visual Studion 2010 Ultimate,” MSDN
Blogs,
http://blogs.msdn.com/b/ianhu/archive/2009/05/13/historical-
debugging-in-visual-studio-team-system-2010.aspx, 2009.
[9]
M. Lindahl, “The Device Software Engineers Best Friend,” in IEEE
Computer, 2006.
[10]
B. Lewis and M. Ducasse, “Using Events to Debug Java Programs
Backwards in Time,” in Proc. of the ACM SIGPLAN 2003 Conference
on Object-oriented programming, systems, languages, and applications
(OOPSLA), 2003, pp. 96–97.
[11]
The GNU Project Debugger, “GDB and Reverse Debugging,” GNU
pages, https://www.gnu.org/software/gdb/news/reversible.html, 2009.
[12]
F. V. B. Berthomieu, F. Peres, “Model-checking Bounded Prioriterized
Time Petri Nets,” in Proceedings of ATVA, 2007.
[13]
O. Kummer, F. Wienberg,
and et al.,
“Renew
User Guide,”
http://www.informatik.uni-hamburg.de/TGI/renew/renew.pdf,
January
2016.
[14]
A. GoldBerk and D. Robson, Smalltalk 80: The Language.
Addison-
Wesley, 1989.
[15]
R. Koˇc´ı and V. Janouˇsek, “The Object Oriented Petri Net Component
Model,” in The Tenth International Conference on Software Engineering
Advances.
Xpert Publishing Services, 2015, pp. 309–315.
127
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

