Comparing TCP Congestion Control Algorithms 
Based on Passively Collected Packet Traces 
Toshihiko Kato, Atsushi Oda, Celimuge Wu, and Satoshi Ohzahata 
Graduate School of Information Systems 
University of Electro-Communications 
Tokyo, Japan 
e-mail: kato@is.uec.ac.jp, oda@net.is.uec.ac.jp, clmg@is.uec.ac.jp, ohzahata@is.uec.ac.jp 
 
 
Abstractâ€” Recently, traffic in the Internet increases largely 
according to the improvement of network capacity.  However, 
it is sometimes pointed out that a small number of giant users 
exhaust large part of network bandwidth.  In order to resolve 
such problems, a practical way is to suppress large traffic flows 
which do not conform to Transmission Control Protocol (TCP) 
congestion control algorithms.  For this purpose, the network 
operators need to infer congestion control algorithms of 
individual TCP flows using passively monitored packet traces 
in the middle of networks.  On the other hand, a lot of TCP 
congestion control mechanisms have been introduced recently.  
Although there are several proposals on inferring them, no 
schemes are proposed which can analyze recently introduced 
TCP congestion control algorithms based on the passive 
approach.  This paper proposes a new passive scheme to 
compare most of recently proposed congestion control 
algorithms.  It estimates the congestion window size (cwnd) at a 
TCP sender at round-trip time intervals, and specifies the cwnd 
growth as a function of the estimated value of cwnd and the 
cwnd decrease parameter at individual congestion events.  This 
paper shows the results of applying our scheme to eight 
congestion control algorithms and shows that they can be 
identified from passively monitored traces.   
Keywords- TCP congestion control; passive monitoring; 
congestion window. 
I.  INTRODUCTION 
The TCP congestion control [1] is a mechanism for a 
data sender to limit its rate of injecting data segments into 
the network when it is congested.  More specifically, a TCP 
sender transmits data segments under the limitation of the 
congestion window size (cwnd) maintained within the sender 
side, beside the advertised window reported from a TCP 
receiver.  The value of cwnd grows up as a sender receives 
acknowledgment (ACK) segments and is decreased when it 
detects congestions.  How to grow and decrease cwnd is the 
key of congestion control algorithm.   
Since the congestion control came to be used in TCP, 
only a few algorithms, such as Tahoe, Reno and NewReno 
[2], were used commonly for a long time.  According to the 
diversification of network environments, however, many 
TCP congestion control algorithms have emerged [3].  For 
example, High Speed (HS) TCP [4], CUBIC TCP [5], and 
Hamilton TCP [6] are designed for high speed and long 
delay networks.  On the other hand, TCP Westwood+ [7] is 
designed for lossy wireless links.  While those algorithms are 
based on packet losses, TCP Vegas [8] triggers congestion 
control against an increase of round-trip time (RTT).  TCP 
Veno [9] and TCP Illinois [10] combine loss based and delay 
based approaches such that congestion control is triggered by 
packet losses but the delay determines how to grow cwnd.   
Recently, the traffic in the Internet increases largely 
according to the improvement of network capacity.  
However, it is sometimes pointed out that a small number of 
giant users exhaust large part of network bandwidth.  Since 
most of traffic in the Internet uses TCP, the network 
congestions will be resolved by the TCP congestion control 
mechanisms.  However, if any giant users do not conform to 
those mechanisms, the problem will be worse.  So, an 
important approach for network operators is to infer 
congestion control algorithm using passively monitored 
packet traces and to discriminate TCP unfriendly traffic 
flows.   
This type of TCP congestion control inferring is called a 
passive approach.  It has some limitations in the testing 
ability because it needs to use packet traces as they are, but is 
non-intrusive and can be applied to any link in the Internet if 
the traffic over the link can be monitored.  So far, several 
studies are proposed for passive approaches [11]-[14].  
However, there are no proposals on inferring the recently 
introduced algorithms, in the contrast with the active 
approach, where an active tester sends test inputs to a target 
node and checks the replies [15].   
In our former paper [16], we presented a new scheme on 
the passive TCP congestion control algorithm inferring, 
which is a basis of this paper.  However, the paper has some 
problems in the sense that it focused only on the cwnd 
growth function and that it applied the idea only to a packet 
trace using TCP Reno/NewReno.   
In this paper, we propose a complete scheme to compare 
the TCP congestion control algorithms.  The scheme focuses 
on not only the cwnd growth function, as in our former paper, 
but also the decrease parameter at the congestion detection.  
This paper also applies our scheme to most of recently 
proposed congestion control algorithms implemented in the 
Linux operating system, with the experimental results 
verifying our scheme through actually collected packet traces.   
The rest of this paper consists of the following sections.  
Section 2 surveys the related works.  Section 3 proposes our 
scheme.  Section 4 gives the results that our scheme is 
applied to congestion control algorithms actually.  In the end, 
Section 5 gives the conclusions of this paper.   
135
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-439-8
ICSNC 2015 : The Tenth International Conference on Systems and Networks Communications

II. RELATED WORKS 
In the traditional methods [11][12] of the passive 
approach, a TCP senderâ€™s state machine is estimated from 
packet traces and compared with the behaviors of known 
algorithms, and the most likely algorithm is selected.  These 
methods need complicated logic and are only applied to early 
stage algorithms, such as Tahoe, Reno and NewReno.  Oshio 
et al. [13] estimates the changes of cwnd values and extracts 
characteristics, such as the ratio of cwnd increased by one.  
Based on these characteristics, it discriminates one of two 
different versions randomly selected out of fourteen TCP 
versions implemented in the Linux operating system.  Qian 
et al. [14], on the other hand, focuses on the extraction of 
statistical features based on the monitoring of one direction 
of TCP communications.  They focused on the size of initial 
congestion 
window, 
the 
relationship 
between 
the 
retransmission rate and the time required to transfer a fixed 
size of data for detecting the irregular retransmissions, and 
the extraction of flow clock to find TCP data transmissions 
controlled by the application or link layer factors.  As an 
example of the active approach, Yang et al. [15] proposes the 
scheme to actively identify the TCP algorithm of a remote 
web server.  It makes a web server send 512 data segments 
under the controlled network environment and observes the 
number of data segments contiguously transmitted without 
receiving any ACK segments.  It then estimates the window 
growth function and the decrease parameter, and using those 
estimations, determines the TCP algorithm out of all default 
TCP algorithms and most non-default TCP algorithms of 
major operating system families.   
III. PROPOSAL 
A. Design Principle 
A TCP congestion control algorithm can be described by 
the following two characteristics.   
ï‚· 
The window growth function, which determines how 
an algorithm grows cwnd while there is no 
congestion.   
ï‚· 
The multiplicative decrease parameter (denoted by 
ï¢), which determines the slow start threshold 
(ssthresh) such that  
ğ‘ ğ‘ ğ‘¡â„ğ‘Ÿğ‘’ğ‘ â„ =  ğ‘ğ‘¤ğ‘›ğ‘‘ just before congestion Ã— (1 âˆ’ ğ›½) 
The goal of our scheme is to compare TCP congestion 
control algorithms by specifying those two characteristics 
using only packet traces collected passively.   
The window growth function is defined differently by 
individual TCP congestion control algorithms.  For example, 
TCP Reno/NewReno defines it as a behavior when a sender 
receives a new ACK segment.  On the other hand, CUBIC 
TCP defines it as a function of the elapsed time from the last 
window reduction.  For the purpose of our scheme, however, 
the window growth function needs to be specified in the 
same 
framework 
for 
different 
congestion 
control 
mechanisms.  We have decided to specify it as a function of 
cwnd values estimated at RTT intervals [16].   
The multiplicative decrease parameter can be identified 
from the sequence of estimated cwnd values by detecting fast 
retransmit events.   
B. Estimating cwnd Values at  RTT Intervals 
In the passive approach, packet traces are collected at 
some monitoring point in the network.  So, the time 
associated with a packet is not the exact time when the node 
focused sends/receives the packet.  Our scheme adopts the 
following approach to estimate cwnd values at RTT intervals 
using the TCP time stamp option.   
ï‚· 
Pick up an ACK segment in a packet trace.  Denote 
this ACK segment by ACK1. 
ï‚· 
Search for the data segment whose TSecr (time 
stamp echo reply) is equal to TSval (time stamp 
value) of ACK1.  Denote this data segment by Data1.   
ï‚· 
Search for the ACK segment which acknowledges 
Data1 for the first time.  Denote this ACK segment 
by ACK2.  Denote the ACK segment prior to ACK2 
by ACK1â€™ 
ï‚· 
Search for the data segment whose TSecr is equal to 
TSval of ACK2.  Denote this data segment by Data2.   
From this result, we estimate a cwnd value at the timing 
of receiving ACK1 as in (1).   
 
ğ‘ğ‘¤ğ‘›ğ‘‘ = âŒŠ
ğ‘ ğ‘’ğ‘ ğ‘–ğ‘› ğ·ğ‘ğ‘¡ğ‘2âˆ’ğ‘ğ‘ğ‘˜ ğ‘–ğ‘› ğ´ğ¶ğ¾1â€²
ğ‘€ğ‘†ğ‘†
âŒ‹ (segments) 
(1)ï€ 
Here, seq means the sequence number, ack means the 
acknowledgment number of TCP header, and MSS is the 
maximum segment size.  âŒŠğ‘âŒ‹ is the truncation of a.   
C. Specifying Window Growth Function 
Using the sequence of cwnd values obtained above, our 
scheme specifies the window growth function of a focused 
TCP communication in the following way [16].   
ï‚· 
Plot cwnd values at RTT intervals in relation to the 
time associated with the value. 
ï‚· 
Select a portion of the cwnd vs. time graph where 
cwnd is growing up continuously.   
ï‚· 
Compute the difference of adjacent cwnd values 
(denote it by ï„cwnd) for the selected portion, and 
plot ï„cwnd versus cwnd.   
The ï„cwnd vs. cwnd graph obtained here is considered as 
a representation of the window growth function.  As 
described in the next section, the derived function will show 
characteristics 
which 
can 
distinguish 
an 
individual 
congestion control mechanism from others.   
D. Specifying Multiplicative Decrease Paremeter 
Our scheme specifies the multiplicative decrease 
parameter in the following way.   
ï‚· 
From the cwnd vs. time graph, select fast retransmit 
events by identifying portions where cwnd drops to 
some value other than one segment.   
ï‚· 
Examine the cwnd values just before and just after 
the drop.   
136
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-439-8
ICSNC 2015 : The Tenth International Conference on Systems and Networks Communications

ï‚· 
Compute 1 âˆ’ 
ğ‘ğ‘¤ğ‘›ğ‘‘ ğ‘ğ‘“ğ‘¡ğ‘’ğ‘Ÿ ğ‘¡â„ğ‘’ ğ‘‘ğ‘Ÿğ‘œğ‘
ğ‘ğ‘¤ğ‘›ğ‘‘ ğ‘ğ‘’ğ‘“ğ‘œğ‘Ÿğ‘’ ğ‘¡â„ğ‘’ ğ‘‘ğ‘Ÿğ‘œğ‘ and use it as an 
estimation of ï¢.   
IV. APPLYING PROPOSAL TO VARIOUS TCPS 
In this section, we show the expected features of 
individual congestion control algorithms identified by our 
scheme, and results of experiments applied to actual packet 
traces.   
A. Experiment Conditions 
In the experiment, sending and receiving terminals are 
connected via a bridge.  The bridge inserts 100 msec delay 
(50 msec in one way) and packet losses whose probability is 
1.0 Ã— 10âˆ’4.  These values are selected for emulating an 
wide area Internet communication.  The sending terminal 
and the bridge are connected by a 100 Mbps Ethernet link.  
The receiving terminal and the bridge are connected by an 
Ethernet link or an IEEE 802.11g WLAN.  The data sending 
is performed by iperf, and is monitored by tcpdump at the 
sender.  We used either result of an Ethernet link or a WLAN 
depending on individual algorithms.   
B. Applying to TCP Reno/NewReno 
In TCP Reno/NewReno, cnwd (in unit of segment) grows 
up, for a new ACK segment, by one in the slow start phase 
and by 1/cwnd in the congestion avoidance phase.  By 
considering the possibility that the delayed ACK is used, the 
growth of cwnd during a RTT will be ğ‘ğ‘¤ğ‘›ğ‘‘/2 â‰¤ âŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ â‰¤
ğ‘ğ‘¤ğ‘›ğ‘‘ in the slow start phase, and âŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ = 0 ğ‘œğ‘Ÿ 1 in the 
congestion avoidance phase.  As for the multiplicative 
decrease parameter, ğ›½ = 0.5.   
 Figure 1 shows experimental results for TCP Reno/ 
NewReno.  In Figure 1(a), the change of sequence number is 
shown along the time sent from the TCP sender.  This figure 
corresponds to the information included in the packet trace.  
From this result, the sequence of cwnd values at RTT 
intervals are computed by the algorithm described in II.B, 
which is given in the cwnd vs. time graph in (b) of this figure.  
In this graph, the portion marked by a circle is selected, and 
the ï„cwnd vs. cwnd graph is plotted.  The dropping portions 
in the cwnd vs. time graph generate the ï¢ vs. time graph.  
These two graphs give the features expected above.  It 
should be noted that the ratio of ï„cwnd = 0 and 1 is 1:1.  
This is reasonable because the delayed ACK sends an ACK 
segment for every other data segment and, therefore, ï„cwnd 
will be one every other RTT interval.   
C. Applying to HS TCP 
HS TCP is designed to obtain high throughput over wide 
bandwidth and long delay networks.  It grows cwnd to 
ğ‘ğ‘¤ğ‘›ğ‘‘ + ğ‘(ğ‘ğ‘¤ğ‘›ğ‘‘)
â„ğ‘ğ‘¤ğ‘›ğ‘‘
 in response to every new ACK 
segment, and decrease cwnd to (1 âˆ’ ğ‘(ğ‘ğ‘¤ğ‘›ğ‘‘)) Ã— ğ‘ğ‘¤ğ‘›ğ‘‘ at a 
congestion event.  That is, it changes the increase and 
decrease parameters, a(cwnd) and b(cwnd), depending on 
cwnd value.  More specifically, a(*) and b(*) are defined as 
follows.    
 
ğ‘(ğ‘ğ‘¤ğ‘›ğ‘‘) =
0.156Ã—ğ‘ğ‘¤ğ‘›ğ‘‘0.8Ã—ğ‘(ğ‘ğ‘¤ğ‘›ğ‘‘)
2âˆ’ğ‘(ğ‘ğ‘¤ğ‘›ğ‘‘)
 
(2)ï€ 
ï€ 
ğ‘(ğ‘ğ‘¤ğ‘›ğ‘‘) = (0.1 âˆ’ 0.5) Ã—
log ğ‘ğ‘¤ğ‘›ğ‘‘âˆ’log 38
log 83000âˆ’log 38 + 0.5ï€ 
ï€¨ï€³ï€©ï€ 
From those equations, when cwnd is 38, 118, or 221, 
a(cwnd) is 1, 2, or 3 segments and b(cwnd) is 0.50, 0.44, or 
0.41, respectively.  Considering that the passive approach 
can only detect the cwnd value in the unit of segment and 
that there is a case the delayed ACK is used, the estimated 
ï„cwnd will be as follows.   
 
âŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ = {
0 ğ‘œğ‘Ÿ 1 (ğ‘ğ‘¤ğ‘›ğ‘‘ < 38)
1 ğ‘œğ‘Ÿ 2  (38 â‰¤ ğ‘ğ‘¤ğ‘›ğ‘‘ < 118)
1, 2 ğ‘œğ‘Ÿ 3  (118 â‰¤ ğ‘ğ‘¤ğ‘›ğ‘‘ < 221)
 
(4)ï€ 
On the other hand, the estimated value of ï¢ will be the same 
as b(cwnd).   
Figure 2 shows experimental results for HS TCP.  It 
shows only the graphs obtained in our proposal.  From the 
    
100
80
60
40
20
         
10
20
30
40
50
60
70
80
90
Time (sec)
Sequence 
number 
(mega 
byte)
0
 
(a) Sequence number vs. time of monitored TCP flow 
 
(b) Estimated cwnd increasing function and decrease parameter 
Figure 1.  Experimental results for TCP Reno/NewReno 
 (using Ethernet link). 
137
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-439-8
ICSNC 2015 : The Tenth International Conference on Systems and Networks Communications

ï„cwnd vs. cwnd graph, ï„cwnd is 0 or 1 and their ratio is 1:1 
when cwnd <38.  When cwnd â‰¥ 38, ï„cwnd is 1.  This result 
is consistent with the expectation above, and especially it 
should be noted that the ï„cwnd value changes at the cwnd 
value of 38.  As for the multiplicative decrease parameter, ğ›½ 
is between 0.4 and 0.5 and this result is also consistent with 
the expectation.   
D. Applying to CUBIC TCP 
CUBIC TCP defines cwnd as a cubic function of elapsed 
time T since the last congestion event.  Specifically, it 
defines cwnd by (5). 
ï€ 
ğ‘ğ‘¤ğ‘›ğ‘‘ = ğ¶ (ğ‘‡ âˆ’ âˆšğ›½ âˆ™
ğ‘ğ‘¤ğ‘›ğ‘‘ğ‘šğ‘ğ‘¥
ğ¶
3
)
3
+ ğ‘ğ‘¤ğ‘›ğ‘‘ğ‘šğ‘ğ‘¥ï€ 
ï€¨ï€µï€©ï€ 
Here, C is a predefined constant, ğ›½ is the decrease parameter, 
and ğ‘ğ‘¤ğ‘›ğ‘‘ğ‘šğ‘ğ‘¥ is the value of cwnd just before the loss 
detection in the last congestion event.  We approximate 
ï„cwnd by ğ‘…ğ‘‡ğ‘‡ Ã—
ğ‘‘(ğ‘ğ‘¤ğ‘›ğ‘‘)
ğ‘‘ğ‘‡
 and obtain (6) by representing it in 
cwnd [16].   
 
âŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ = 3ğ‘…ğ‘‡ğ‘‡ âˆ™ âˆšğ¶
3
(âˆšğ‘ğ‘¤ğ‘›ğ‘‘ âˆ’ ğ‘ğ‘¤ğ‘›ğ‘‘ğ‘šğ‘ğ‘¥
3
)
2 
(6)ï€ 
The decrease parameter is defined by ğ›½ = 0.2 in the original 
CUBIC.  It is 0.3 in the new versions of CUBIC TCP [3].   
Figure 3 shows experimental results for CUBIC TCP.  
The curve in the ï„cwnd vs. cwnd graph has two 
characteristics.  One is that it follows a âˆšğ‘¥2
3
 curve and the 
other is that it has parts in both sides of a point of ï„cwnd = 0.  
So, it is considered that this result is consistent with (6).  As 
for the decrease parameter, the result is ğ›½ â‰ˆ 0.3 and this 
means that the used CUBIC software is a new version.   
E. Applying to Hamilton TCP 
Hamilton TCP is another example that defines cwnd as a 
function of a time.  It defines the increase parameter a of 
cwnd, similar with that of HS TCP, as a function of elapsed 
time T since the last congestion event in the following way.   
 ğ‘(ğ‘‡) = {1 + 10(ğ‘‡ âˆ’ ğ‘‡ğ‘™ğ‘œğ‘¤) + 0.25(ğ‘‡ âˆ’ ğ‘‡ğ‘™ğ‘œğ‘¤)2 (ğ‘‡ â‰¥ ğ‘‡ğ‘™ğ‘œğ‘¤)
1 (ğ‘‡ < ğ‘‡ğ‘™ğ‘œğ‘¤)
 
 
 
(7)ï€ 
Here, Tlow is a threshold for switching the low-speed mode 
and the high-speed mode.   a(T) is an increase of cwnd 
during a RTT interval, we can obtain an approximate value 
of cwnd by integrating (7).  First of all, we compute the 
square completion the upper equation of (7), and obtain (8).   
 
âŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ =
1
4 (ğ‘‡ âˆ’ ğ‘‡ğ‘™ğ‘œğ‘¤ + 20)2 âˆ’ 99 
(8)ï€ 
By integrating (8) and substituting ï„cwnd, cwnd is computed 
as a function of ï„cwnd in the following way. 
 
Figure 2.  Experimental results for HS TCP (using WLAN). 
 
Figure 3.  Experimental results for CUBIC TCP (using Ethernet link).   
 
Figure 4.  Experimental results for Hamilton TCP (using WLAN). 
138
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-439-8
ICSNC 2015 : The Tenth International Conference on Systems and Networks Communications

ğ‘ğ‘¤ğ‘›ğ‘‘ =
1
3ğ‘…ğ‘‡ğ‘‡ (âˆšâŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ + 99)
3
âˆ’
198
ğ‘…ğ‘‡ğ‘‡ âˆšâŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ + 99 + ğ¶ï€ ï€  ï€¨ï€¹ï€©ï€ 
Here, C is a constant.  This result means that cwnd is a 
function of âŠ¿cwnd
3
2.  So it is considered that, by computing 
the inverse function, ï„cwnd will be represented by a function 
of cwnd
2
3.  This is a similar result with CUBIC TCP.  But, in 
the case of Hamilton TCP, the TCP Reno part exists before a 
âˆšğ‘¥2
3
 curve, and there in only an increasing part unlike 
CUBIC TCP.  As for the multiplicative decrease parameter, 
ğ›½ = 0.5 is expected.   
Figure 4 shows experimental results for Hamilton TCP.  
The curve in the cwnd vs. ï„cwnd graph presents the exact 
characteristics described above.  As for ï¢, the result value is 
between 0.4 and 0.5, which is acceptable for the estimation.   
F. Applying to TCP Westwood+ 
TCP Westwood+ is based on the end-to-end bandwidth 
estimate using the rate of acknowledged data in returning 
ACK segments.  Its congestion control is triggered by packet 
losses.  While there are no packet losses, it increases cwnd 
by the same algorithm with TCP Reno for every new ACK 
segment.  At the same time, the estimated bandwidth (bk) is 
computed every RTT in the following way.   
 
ğ‘ğ‘˜ = ğ‘‘ğ‘˜/âˆ†ğ‘˜ 
(10)ï€ 
Here, ğ‘‘ğ‘˜  is the amount of data acknowledged during the last 
RTT ( âˆ†ğ‘˜ ).  The measured value ğ‘ğ‘˜  is applied to an 
exponential moving average filter and the averaged 
bandwidth estimation (BWEk) is obtained.   
 
ğµğ‘Šğ¸ğ‘˜ = 0.9 Ã— ğµğ‘Šğ¸ğ‘˜âˆ’1 + 0.1 Ã— ğ‘ğ‘˜ 
(11)ï€ 
When three duplicate ACKs are received, cwnd is set to the 
value of ğµğ‘Šğ¸ Ã— ğ‘…ğ‘‡ğ‘‡ğ‘šğ‘–ğ‘›/ğ‘€ğ‘†ğ‘†.  That is, cwnd is decreased 
to a specific value not using a multiplicative decrease 
parameter.  From those definitions, the expectation of ï„cwnd 
will be 0 or 1, which is the same with TCP Reno.  The 
expectation of ï¢ will be as in (12).   
 
1 âˆ’
ğµğ‘Šğ¸Ã—ğ‘…ğ‘‡ğ‘‡ğ‘šğ‘–ğ‘›
ğ‘€ğ‘†ğ‘†Ã—ğ‘ğ‘¤ğ‘›ğ‘‘ğ‘šğ‘ğ‘¥ 
(12) 
Here, cwndmax is the value of cwnd just before the last loss 
detection.   
Figure 5 shows experimental results for TCP Westwood+.  
In the ï„cwnd vs. cwnd graph, ï„cwnd takes 1 and 0, and its 
ratio is 1:1.  This is the same with TCP Reno and conforms 
to the expectation.  On the other hand, in the ï¢ vs. time graph, 
ï¢ takes various values between 0.2 and 0.5.  Basically, ï¢ 
itself has no meaning in this case, and in this sense the 
results conform to the expectation.  
G. Applying to TCP Vegas 
TCP Vegas estimates the bottleneck buffer size using the 
current values of cwnd and RTT, and the minimal RTT for 
the TCP connection, according to (13).   
ï€ 
ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ = ğ‘ğ‘¤ğ‘›ğ‘‘ Ã—
ğ‘…ğ‘‡ğ‘‡âˆ’ ğ‘…ğ‘‡ğ‘‡ğ‘šğ‘–ğ‘›
ğ‘…ğ‘‡ğ‘‡
ï€ 
ï€¨ï€±ï€³ï€©ï€ 
At every RTT interval, Vegas uses this BufferSize to 
control cwnd in the congestion avoidance phase in the 
following way.   
 
âŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ = {
1         (ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ < ğ´)
  0  (ğ´ â‰¦ ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ â‰¦ ğµ)
âˆ’1        (ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ > ğµ)
ï€ 
ï€¨ï€±ï€´ï€©ï€ 
Here, A = 2 and B = 4 (in unit of segment) are used in the 
Linux operating system.  The decrease parameter is ğ›½ = 0.5.   
Figure 6 shows the results for TCP Vegas.  In the ï„cwnd 
vs. cwnd graph, ï„cwnd is 1 while cwnd is below 40, which 
corresponds to the part of increasing cwnd.  After that, 
around cwnd is 45, the situations that ï„cwnd is 0, 1 and -1 
are mixed.  This result conforms to the expectation above.  In 
the ï¢ vs. time graph, ğ›½ = 0.5, which matches the expectation.   
 
Figure 5.  Experimental results for TCP Westwood+ (using WLAN). 
 
Figure 6.  Experimental results for TCP Vegas (using WLAN). 
139
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-439-8
ICSNC 2015 : The Tenth International Conference on Systems and Networks Communications

H. Applying to TCP Veno 
TCP Veno (Vegas and ReNO) uses the BufferSize in (13) 
to adjust the growth of cwnd in the congestion avoidance 
phase as follows.  If BufferSize > B  (B is the Vegas 
parameter B), cwnd grows by 1/cwnd for every other new 
ACK segment, and otherwise, it grows in the same manner 
with TCP Reno.  Therefore, if the delayed ACK is not used, 
ï„cwnd at RTT intervals will be as in (15).   
 
âŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ = {  1 ğ‘œğ‘Ÿ 0(ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ > ğµ)
1 (ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ â‰¦ ğµ)
ï€ 
ï€¨ï€±ï€µï€©ï€ 
If the delayed ACK is used, âŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ = 0 ğ‘œğ‘Ÿ 1  even if 
ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ â‰¦ ğµ.  But in this case, the ratio of ï„cwnd being 
1 and 0 is different for BufferSize.  It will be 1:3 for 
BufferSize >B, and 1:1 for ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ â‰¦ ğµ .  The 
multiplicative decrease parameter is defined as in (16).   
 
ğ›½ = {0.5 (ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ > ğµ)
0.2 (ğµğ‘¢ğ‘“ğ‘“ğ‘’ğ‘Ÿğ‘†ğ‘–ğ‘§ğ‘’ â‰¦ ğµ) 
(16)ï€ 
Figure 7 shows experimental results for TCP Veno.  In 
the cwnd vs. ï„cwnd graph, ï„cwnd takes 1 and 0, but its ratio 
is 1:1.  On the other hand, the ï¢ vs. time graph shows that 
ğ›½ = 0.2.  These results are consistent with the expectation 
when BufferSize is less than and equal to B.   
I. Applying to TCP Illinois 
TCP Illinois changes the increase parameter, a(Q), and 
the decrease parameter, b(Q), of cwnd, which are similar 
with those of HS TCP, according to the queuing delay, Q.  
The queuing delay is measured by the increase of RTT from 
the minimum RTT for a TCP connection.  In the Linux 
operating system, a(Q) changes from 0.1 to 10 in unit of 
segment.  b(Q) changes from 0.125 to 0.5.  Those values are 
updated once per every RTT.  In the expectation, ï„cwnd will 
be defined by 
1
2 ğ‘(ğ‘„) â‰¤ âŠ¿ğ‘ğ‘¤ğ‘›ğ‘‘ â‰¤ ğ‘(ğ‘„) and ï¢ will be b(Q).   
Figure 8 shows experimental results for TCP Illinois.  In 
the ï„cwnd vs. cwnd graph, ï„cwnd increases from 1 to 6 and 
then decreases to 1 again.  This will reflect the delay in the 
communication.  The ï¢ vs. time graph, ï¢ has the values 
between 0.2 and 0.6.  These conform to the expectations.   
V. CONCLUSIONS 
This paper presented that the TCP congestion control 
algorithms can be characterized from only passively 
collected packet traces, by specifying the cwnd growth 
function as ï„cwnd vs. cwnd, and the multiplicative decrease 
parameter.  We applied our scheme to Reno/NewReno, HS 
TCP, CUBIC, Hamilton, Westwood+, Vegas, Veno and 
Illinois, and indicated that individual algorithms show 
characteristics which can identify the individuals from others.  
Our future works include identifying congestion control 
algorithms automatically and inferring from packet traces 
which contain only one way TCP packet traces.   
REFERENCES 
[1] V. Javobson, â€œCongestion Avoidance and Control,â€ ACM 
SIGCOMM Comp. Commun. Review, vol. 18, no. 4, Aug. 
1988, pp. 314-329.   
[2] S. Floyd, T. Henderson, and A. Gurtov, â€œThe NewReno 
Modification to TCPâ€™s Fast Recovery Algorithm,â€ IETF RFC 
3728, April 2004.   
[3] A. Afanasyev, N. Tilley, P. Reiher, and L. Kleinrock, â€œHost-
to-Host Congestion Control for TCP,â€ IEEE Commun. 
Surveys & Tutorials, vol. 12, no. 3, 2010, pp. 304-342.   
[4] S. Floyd, â€œHighSpeed TCP for Large Congestion Windows,â€ 
IETF RFC 3649, Dec. 2003.   
[5] S. Ha, I. Rhee, and L. Xu, â€œCUBIC: A New TCP-Friendly 
High-Speed TCP Variant,â€ ACM SIGOPS Operating Systems 
Review, vol. 42, no. 5, July 2008, pp. 64-74.   
[6] D. Leith and R. Shorten, â€œH-TCP: TCP for high-speed and 
long distance networks,â€ Proc. Int. Workshop on PFLDnet, 
Feb. 2004, pp. 1-16. 
[7] L. Grieco and S. Mascolo, â€œPerformance evaluation and 
comparison of Westwood+, New Reno, and Vegas TCP 
congestion control,â€ ACM Computer Communication Review, 
vol. 34, no. 2, April 2004, pp. 25-38.   
 
Figure 7.  Experimental results for TCP Veno (using Ethernet link). 
 
Figure 8.  Experimental results for TCP Illinois (using WLAN) 
140
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-439-8
ICSNC 2015 : The Tenth International Conference on Systems and Networks Communications

[8] L. Brakmo and L. Perterson, â€œTCP Vegas: End to End 
Congestion Avoidance on a Global Internet,â€ IEEE J. 
Selected Areas in Commun., vol. 13, no. 8, Oct. 1995, pp. 
1465-1480.   
[9] C. Fu and S. Liew, â€œTCP Veno: TCP Enhancement for 
Transmission Over Wireless Access Networks,â€ IEEE J. Sel. 
Areas in Commun., vol. 21, no. 2, Feb. 2003, pp. 216-228.   
[10] S. Liu, T. Bassar, and R. Srikant, â€œTCP-Illinois: A loss and 
delay-based congestion control algorithm for high-speed 
networks,â€ Proc. VALUETOOLS â€™06, Oct. 2006, pp. 1-13.   
[11] V. Paxson, â€œAutomated Packet Trace Analysis of TCP 
Implementations,â€ ACM Comp. Commun. Review, vol. 27, 
no. 4, Oct. 1997, pp.167-179.   
[12] S. Jaiswel, G. Iannaccone, C. Diot, J. Kurose, and D. Towsley, 
â€œInferring TCP Connection Characteristics Through Passive 
Measurements,â€ Proc. INFOCOM 2004, March 2004, pp. 
1582-1592.   
[13] J. Oshio, S. Ata, and I. Oka, â€œIdentification of Different TCP 
Versions Based on Cluster Analysis,â€ Proc. ICCCN 2009, 
Aug. 2009, pp. 1-6.   
[14] F, Qian, A. Gerber, and Z. Mao, â€œTCP Revisited: A Fresh 
Look at TCP in the Wild,â€ Proc. IMC â€™09, Nov. 2009, pp. 76-
89.   
[15] P. Yang, W. Luo, L. Xu, J. Deogun, and Y. Lu, â€œTCP 
Congestion Avoidance Algorithm Identification,â€ Proc. 
ICDCS â€™11, June 2011, pp. 310-321.   
[16] T. Kato, A. Oda, S. Ayukawa, C. Wu, and S. Ohzahata, 
â€œInferring 
TCP 
Congestion 
Control 
Algorithms 
by 
Correlating Congestion Window Sizes and their Differences,â€ 
Proc. IARIA ICSNC 2014, Oct. 2014, pp.42-47.   
 
141
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-439-8
ICSNC 2015 : The Tenth International Conference on Systems and Networks Communications

