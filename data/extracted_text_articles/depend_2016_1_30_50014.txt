Expurgated Codes for Detecting Jamming in Multi-level Memories
Yaara Neumeier
Faculty of Engineering
Bar-Ilan University
Email: yaara.neumeier@biu.ac.il
Osnat Keren
Faculty of Engineering
Bar-Ilan University
Email: osnat.keren@biu.ac.il
Abstractâ€”Robust q-ary codes can efï¬ciently detect jamming
in multilevel memories when q is a power of two. When q
is not a power of two, a binary information word has to be
converted and encoded into a q-ary codeword. This conversion
expurgates the code; some of the q-ary codewords are never
used. Unless properly designed, expurgation can signiï¬cantly
degrade the efï¬ciency of the code in terms of its error detection
capability. This work presents a q-ary robust Quadratic-Sum
code for arbitrary qâ€™s and analyzes the error masking probability
of the expurgated code when applied to multilevel memories. It
is shown that by wisely designing the converter, this degradation
can be minimized, and in some cases, the expurgated codeâ€™s
efï¬ciency can be superior to the one of the original code. This
work suggests how to construct a converter to optimize code
properties.
Index Termsâ€”Robust codes; Multi-level Memories; Jamming
attacks; Hardware security.
I. INTRODUCTION
Memory arrays are prone to jamming attacks [1], where
an adversary injects faults into the memory to alter a stored
value. The injected fault manifests itself as an additive error
of an arbitrary multiplicity; i.e., any number of bits may be
ï¬‚ipped or distorted. [2]. Fault injection can be executed, for
example, using variations on voltage, temperature, white light,
laser, ion beams, etc. An attacker can inject faults into the
memory to change its content and then acquire information
about the system by analyzing its behavior [2].
Several countermeasures to jamming attacks on memories
have been proposed [2][3]. For example, one approach to
protect memories is to implement intrusion detection mech-
anisms based on active protection using tamper-proof box
and sensors to make the device physically inaccessible. Since
different sensors are used against different injection methods,
this method becomes expensive and inappropriate for simple,
small devices. Moreover, it is powerless against new types of
attacks that were not considered by the designers. Furthermore,
internal information about the design may help the attacker
bypass this protection. An alternative approach is to detect
the manifestation of the fault as an error using error detecting
codes.
Classic coding theory addresses the problem of the reliabil-
ity of information transmitted over a noisy channel or stored in
storage media. In classic coding theory, the errors are assumed
to be random with a relatively small probability. Consequently,
a reliability oriented code should protect the system from a
small number of random errors (small multiplicity). Many
known codes designed for reliability (such as the parity bit
code, Hamming code, BCH codes, etc) are linear [4], however;
in linear codes, all the errors that are codewords are never
detected. As a result, reliability oriented codes cannot be used
to provide security against an attacker that can inject any error.
Jamming can be detected by nonlinear robust codes capable
of detecting any non-zero error. The efï¬ciency of these codes
is measured in terms of their error masking probability QM =
maxeÌ¸=0 Q(e) where Q(e) is the probability that an error e is
masked by codewords in C. This probability depends on the
probability mass function of the codewords; that is,
Q(e) =
âˆ‘
c,c+eâˆˆC
p(c),
where p(c) is the probability that c âˆˆ C is used.
The Quadratic-Sum (QS) code [5] is a nonlinear q-ary high-
rate robust code of length n and dimension k deï¬ned over a
ï¬nite ï¬eld, i.e., for a q that is a power of a prime. When all the
codewords are equally likely to occur, the code is an optimum
code, and its error masking probability equals QC = qâˆ’(nâˆ’k)
[5]. If these conditions are not fulï¬lled, the performance of
the code may signiï¬cantly degrade [6].
The encoding complexity of a binary QS code is relatively
low with respect to other robust codes (e.g., the codes in
[7][8] which involve computations over ï¬nite ï¬elds of high
order); its k information symbols are treated as 2s symbols
from Fr
2 and its single redundant symbol x2s+1 is the sum
âˆ‘s
i=1 x2iâˆ’1x2i over Fr
2. This simple structure makes the code
an attractive countermeasure to jamming in binary and q-ary
multilevel memories, where q is a power of two.
However, in some cases, the codeâ€™s alphabet size is not a
power of two. Note that the number of levels in a multilevel
memory, l, may be a power of two. Nevertheless, the codeâ€™s
alphabet size q may be smaller than l. For example, in Write-
Once-Memory codes and rank-modulation codes the alphabet
size is smaller than the number of levels to enable several
write cycles to the same address before block-erasure. As far
as we know, all known robust codes ([5][7][8][9]) are deï¬ned
over a ï¬nite ï¬eld, i.e., where q is a power of a prime, and
15
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-492-3
DEPEND 2016 : The Ninth International Conference on Dependability

cannot be used in the case where the number of states is not
a power of a prime.
Another problem that arises when the codeâ€™s alphabet size is
not a power of two is that each binary information word has to
be converted to a q-ary word by a dedicated conversion circuit
[10]. A conversion circuit maps a binary vector of length k2 to
a q-ary vector of length kq. A conversion circuit is constructed
from sub-blocks, denoted DCCi. The input of each sub-block
is a binary w2-bit vector, and its output is a q-ary vector of
length wq. The values w2 and wq are chosen such that wq =
âŒˆw2 logq 2âŒ‰. A schematic illustration of a multilevel memory
with a conversion circuit is shown in Figure 1. Since qwq <
2w2, some of the codewords of the (original) q-ary code C are
never used. When these unused words are chosen arbitrarily,
the error masking probability of the expurgated code, denoted
by M, can become higher than the error masking probability
of the original code.
Robust codes over ï¬nite ï¬elds for a non-uniform distribution
of codewords were discussed in [6][11][12]. In [6], the authors
showed that when most of the codewords appear with low
probability, which is the case for some Final State Machines
(FSMs), it is possible to avoid the worst case scenario by pre-
mapping the information word before the encoding. In [12], a
general approach for mapping the most probable codewords to
a predeï¬ned set was suggested. In [11] the authors dealt with
the non-uniform characteristics of FSMs using randomized
masking. Another way to cope with a non-uniform distribution
of codewords is by embedding randomness [13][14]; these
codes are also deï¬ned over ï¬nite ï¬elds. However, since the
random symbols are an integral part of the codeword, their rate
is lower than the rate of (deterministic-encoding) robust codes
such as the QS and the Punctured-Cubic/Square in [7][8].
These solutions are appropriate for applications where a small
portion of the states appear with high probability; they are less
suitable for applications such as multilevel memories where
some words never occur and other words appear with uniform
probability.
This paper expands the QS construction to codes over
integer rings, proves its robustness, and examines the security
related implications of applying expurgated codes on q-ary
memory systems with data conversion circuits in cases where
q is not a power of a prime. It is shown that by choosing M
properly, the practical error masking probability QM may be
even better than QC. The main ideas and results presented in
this paper are the following:
â€¢ A QS-based code C is robust over rings.
â€¢ The maximal error masking probability QM of code M
is bounded by
(2|M| âˆ’ |C|)
p1|M|
â‰¤ QM â‰¤
|C|
p1|M| < 2QC,
(1)
where p1 is the smallest divisor of q. Since p1 â‰¥ 2, an
expurgated code is robust; it can detect any nonzero error
with a probability greater than zero.
â€¢ If p1 = 2 there exists an expurgated code M, which
Figure 1. Multilevel memory system with data conversion circuit, protected
by encoder and a checker.
provides a smaller error masking probability, i.e., QM <
QC. If p1 Ì¸= 2 and
(p1 âˆ’ 1)kq + 1 â‰¤ |C| âˆ’ |M|
(2)
there exists an M with QM <
|C|
p1|M|.
â€¢ A code construction for M which minimizes QM in
cases where p1 = 2 for a given set of parameters, and
has
(2|M| âˆ’ |C|)
p1|M|
â‰¤ QM â‰¤ QC,
is presented.
The rest of this paper is organized as follows. Section II
deï¬nes and analyzes the Quadratic-Sum code for a general
q. Section III presents the expurgated code and the security
problem that arises when applying the codes to q-ary memories
where q is not a power of two. Then, lower and upper bounds
on the error masking probability are presented. Section IV
suggests how to choose M in cases where p1 = 2 to minimize
its error masking probability and Section V concludes the
paper.
II. THE EXTENDED QS CODE
Notations: Regular lowercase letters are used to represent
scalars. Boldface lowercase letters are used to denote row
vectors, e.g., x = (x1, . . . , xn) is a vector of length n, where
wH(x) denotes the Hamming weight of x. Double stroke
capital letters are used to denote algebraic structures, e.g., Fq
is a ï¬nite ï¬eld with q elements. Regular uppercase letters are
used to represent sets, e.g., S, where |S| is the number of
elements in S. Calligraphic capital letters are used to denote
codebooks, e.g., C.
Consider a multilevel memory whose levels are mapped into
symbols in an alphabet of size q. In this paper, we refer to
such a memory as a q-ary memory. The set of q symbols
with addition and multiplication form an algebraic structure.
If q = pt and p is prime, the algebraic structure is a ï¬nite
ï¬eld Fq; otherwise, it is a ring Rq in which operations are
computed modulo q. To simplify the text, when it is clear
from the context, we denote the algebraic structure by Zq,
and denote addition and subtraction by the symbols âŠ• and âŠ–,
respectively.
16
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-492-3
DEPEND 2016 : The Ninth International Conference on Dependability

Known robust codes are deï¬ned over a ï¬nite ï¬eld, i.e., the
size of the alphabet, q, is a power of a prime. If the number
of different states (voltage levels) that a memory cell can have
in each write cycle is not a power of a prime, a robust code
over a ring is required. Note that the computation of all these
known robust codes over ï¬nite ï¬elds involves multiplication.
However, in the case of a ring, there are elements in the ring
with no multiplicative inverse, which may affect the analysis
and the resulting error masking probability. In this section we
introduce an extension of the QS code. The resulting code
is a robust code over a ring. The maximal error masking
probability of the extended code is different (higher) than the
maximal error masking probability of the original QS code
over a ï¬nite ï¬eld.
The QS code is deï¬ned in [5] for the case where q is a
power of a prime (PoP). The number of redundancy symbols
in [5] is r â‰¤ k. The code can be extended for qâ€™s which are
not necessarily PoPs as follows:
Construction 1. Let q = âˆv
i=1 piti where pi < pi+1. Let k =
2sr, where r = 1 if q is not a PoP. Let x = (x1, x2, . . . , x2s)
where xi âˆˆ Zr
q for 1 â‰¤ i â‰¤ 2s. The code QS code is
C = {(x, u) : x âˆˆ Z2s
q , u =
s
âˆ‘
i=1
x2iâˆ’1x2i âˆˆ Zr
q}.
Note that when q is not a PoP, we take r = 1 since a
larger r cannot improve the codeâ€™s efï¬ciency. To simplify the
notation, from here on, unless otherwise stated, q is not a PoP.
The case where q is a PoP can be viewed as subcase of the
general case with p1 = q.
Let e
=
(ex, eu) be an error vector, where ex
=
(ex1, . . . ex2s) âˆˆ R2s
q
and eu âˆˆ Rq. The error is masked by
a codeword c if (x âŠ• ex, u âŠ• eu) âˆˆ C. In other words, the
error masking equation of the code is
s
âˆ‘
i=1
(x2iâˆ’1 âŠ• ex2iâˆ’1)(x2i âŠ• ex2i) =
s
âˆ‘
i=1
x2iâˆ’1x2i âŠ• eu.
(3)
Equivalently,
axT = b
(4)
where a âˆˆ R2s
q
and b âˆˆ Rq are
ai =
{
exi+1
if i is odd
exiâˆ’1
if i is even
, and b = eu âŠ–
s
âˆ‘
i=1
ex2iâˆ’1ex2i.
Let B(a) be the set
B(a) = {b|âˆƒx : axT = b}.
Clearly, B(a) = B(ex). To analyze which elements are in
B(a), it is convenient to use the greatest common divisor (gcd)
over a set of nonzero integers; deï¬ne g(a) âˆˆ Rq as
g(a) = gcd({ai|ai Ì¸= 0} âˆª {q}).
The set B(a) contains all the multiples of g(a) modulo q.
Therefore |B(a)| =
q
g(a). In addition, for all 1 â‰¤ i â‰¤ 2s, ai
is also in B(a). For example, if q = 6, r = 1, k = 2 and
a = (0, 4), then g(a) = 2, B(a) = {0, 2, 4} and |B(a)| = 3.
Property 1. Let a âˆˆ R2s
q \ {0}. Then, (4) has qk|B(a)|âˆ’1
solutions if b âˆˆ B(a) and 0 solutions otherwise.
For uniformly distributed codewords, the number of solu-
tions of (4) for a given e deï¬nes the error masking probability;
Theorem 1. Let q not be a PoP. Let C be a QS code where the
codewords in C are uniformly distributed. The error masking
probability of C for any nonzero error e is Q(e) =
1
|B(a)| if
b âˆˆ B(a), and Q(e) = 0 otherwise. In particular, the maximal
error masking probability of the QS code is QC = 1/p1.
The set of all exâ€™s can be divided into subsets according to
their error masking probability. Let Ex be the set of exâ€™s that
have the maximal error masking probability. Any ex âˆˆ Ex
can be written as ex =
q
p1 Ëœex where Ëœex âˆˆ Zk
p1. Since B(ex) =
B(eâ€²x) for all ex, eâ€²x âˆˆ Ex, there are (p1k âˆ’ 1)p1 distinct
error vectors e that maximize the error masking probability.
Example 1. Consider the case where q = 6, k = 2, and
r = 1. In this case, the set Ex = {03, 30, 33} and B(Ex) =
{0, 3}. Each one of the errors 030, 033, 300, 303, 330, 333 has
an error masking probability Q(e) = 0.5 = Q.
III. THE EXPURGATED CODE
Consider a k2-bit binary word to be stored in a q-ary
memory array where q is not a power of two. For converting
the binary word into a q-ary word of length kq, the k2 bits
are divided into blocks of w2 bits which are then mapped into
blocks of wq q-ary symbols; whereas,
âŒŠ k2
w2
âŒ‹wq + âŒˆ(k2
mod w2) logq 2âŒ‰ â‰¤ kq â‰¤ âŒˆ k2
w2
âŒ‰wq.
For simplicity, we assume that k2
w2 is an integer (however, our
results equally apply to non integers). Since q is not a power
of two, some of the q-ary vectors are never used; denote by
Dw the set of the combinations over in Fwq
q
that are never
used,
|Dw| = qwq âˆ’ 2w2 < 2w2.
Denote by D âŠ† Zkq
q the set of q-ary vectors of length kq that
never occur at the output of the converter, and by M = Zkq
q \D
the set of vectors that can appear at the output of the converter.
Each vector in D corresponds to a codeword in C that is never
used; denote by D âˆˆ C the set of unused codewords, and by
M = C \ D the expurgated code,
|M|
=
|M| = 2k2 > |C|/2,
|D|
=
|D| = (qkq âˆ’ 2k2) < |C|/2.
(5)
It is assumed that the codewords in M are uniformly dis-
tributed.
Clearly the error masking probability of M may be different
from the error masking probability of C. Denote by R(e) the
17
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-492-3
DEPEND 2016 : The Ninth International Conference on Dependability

C
C
e
âŠ•
n
q
Î–

	
		



	
			

	
	
	

			

		
	
 âŠ•


 âŠ•

 âŠ•



 âŠ•

 âŠ•




 âŠ•

Figure 2. Three types of errors in expurgated codes.
number of codewords that mask the error vector e,
RC(e) = |{c|c âˆˆ C and c âŠ• e âˆˆ C}|.
For uniformly distributed codewords we have, Q(e)
=
RC(e)/|C|. Denote by Î›C1,C2(e) the cross-correlation from a
code C1 to a code C2; i.e,
Î›C1,C2(e) = |{c|c âˆˆ C1 and c âŠ• e âˆˆ C2}|.
Since C = M âˆª D and M âˆ© D = âˆ… the autocorrelation of the
code C can be rewritten as
RC(e) = RM(e) + Î›M,D(e) + Î›D,M(e) + RD(e).
(6)
Figure 2 illustrates the contribution of each component in
(6) to RC(e) for three types of errors. The codewords of
expurgated code M and its shifted set (e + M) are shown in
red, and the codewords that correspond to D appear in light
gray. RM(e) is the number of codewords in the intersection of
the two red areas. The best case is shown on the left hand side
of the ï¬gure. Since RM(e) is the autocorrelation of code M,
the best case is where RM(e) = 0, however, it is impossible
to achieve this for all errors, since for each two codewords
c1, c2 âˆˆ M there is an error vector e such that c1 âŠ• e = c2.
The worst case is where RM(e) is maximized. The desired
case is where the maximal value of RM(e) is minimized.
A standard checker of a separable code uses the kq infor-
mation symbols that are read from the memory to compute the
expected redundant symbols. If the computed value matches
the value of the rq symbols stored in memory, the checker
declares that no error has occurred, otherwise, it raises a ï¬‚ag.
Such a checker masks an error e with a probability
RM(e) + Î›M,D(e)
|M|
.
(7)
which may be higher than QM. This problem can be avoided
if the checker also veriï¬es that the received codeword belongs
to M (i.e., it veriï¬es that the information vector is a legal
output of the converter). Now the error masking probability is
reduced to the true error masking probability of M, i,e,
QM(e) = RM(e)
|M| .
In what follows we assume that the latter checker is used.
A. An upper bound on the error masking probability
Theorem 2. The expurgated code M is robust. Its error
masking probability is upper bounded by
QM â‰¤
|C|
p1|M| < 2
p1
= 2QC.
(8)
The error masking probability of the expurgated code de-
pends on the choice of the set M; in particular, QM(e) may
be larger, smaller, or identical to the error masking probability
of the original code. The following example demonstrates how
sensitive the error masking probability is to the choice of M.
Example 2. Consider the case where k2 = w2 = 6 bits of
information are converted to kq = wq = 2 symbols over alpha-
bet q = 10, and are protected by a single redundant symbol. In
this case, |C| = 102, |M| = 26 and |D| = |C|âˆ’|M| = 36. The
maximal error masking probability of the original QS code C
is QC = 0.5.
Let D = {10 âˆ’ 19, 30 âˆ’ 39, 50, 51 âˆ’ 59, 70 âˆ’ 75}. Consider
the error vector e = 050; the corresponding parameters
are a = 50 and b = 0. Note that for each x âˆˆ D,
axT = 5x1 âŠ• 0x2 Ì¸= 0; namely, all the vectors in D are
not in XC(050). Therefore, RM(050) = RC(050) = 50, and
the error masking probability is QM(050) = QM âˆ¼ 0.78.
In the following section we introduce a method to choose a
D which provides a QM of 0.3125; this D consists of the
following vectors:
{02 âˆ’ 09, 12 âˆ’ 19, 20, 21, 24, 25, 30, 31, 34, 35, 40, 41
, 50, 51, 60, 61, 70, 71, 80, 81, 90, 91}.
B. A lower bound on the error masking probability
Denote by XC(e) the set of the information words that mask
an error e,
XC(e) = {x|(x, u(x)) âˆˆ C and (x, u(x)) âŠ• e âˆˆ C}.
Note that |XC(e)| = RC(e).
The choice of Dw determines D, and hence D. Denote by
â–³(e) the difference between the number of codewords that
mask e in C and the number of codewords that mask it in M,
â–³(e) = RC(e) âˆ’ RM(e).
If â–³(e) equals zero, RC(e) = RM(e) and QM(e) is max-
imized. If â–³(e) > 0 then RM(e) < RC(e) and QM(e) is
smaller than its upper bound. From (6) it follows that
â–³(e) = Î›M,D(e) + Î›D,M(e) + RD(e).
The sum Î›D,M(e) + RD(e) is the number of codewords
that mask e in C and are in D and therefore are not in M. In
fact, it equals the size of the intersection between the set of
codewords that mask e and the set of deleted codewords, that
is,
Î›D,M(e) + RD(e) = |D âˆ© XC(e)|.
18
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-492-3
DEPEND 2016 : The Ninth International Conference on Dependability

Similarly, denote by (D âˆ’ ex) = {x âŠ– ex|x âˆˆ D}, then
Î›M,D(e) + RD(e) = |(D âˆ’ ex) âˆ© XC(e)|.
Therefore,
â–³(e) â‰¤ |D âˆ© XC(e)| + |(D âˆ’ ex) âˆ© XC(e)|.
(9)
Thus,
â–³(e) â‰¤ 2|D|.
The rationale behind the choice of M (and hence, the choice
of D), is to decrease QM by decreasing the error masking
probability of the errors that maximize it in C; these errors
form the set Ex. In other words, denote by
â–³ =
min
eâˆˆEx,bâˆˆB(ex)
â–³(e),
the minimal difference of the error masking probabilities over
all the errors that maximize QC(e). The goal is to maximize
â–³ so as to minimize QM.
Theorem 3. The error masking probability of M is
QM â‰¥ (|M| âˆ’ |D|)
p1|M|
.
(10)
Proof. Let ex âˆˆ Ex. For all bi Ì¸= bj âˆˆ B(ex), we have,
{x|axT = bi} âˆ© {x|axT = bj} = âˆ….
Recall that the size of B(ex) is p1. Therefore, for each ex âˆˆ
Ex there are p1 distinct non-empty and disjoint sets XC(e).
Consider the intersection of an arbitrary set S âŠ† Zkq
qr with
all the sets XC(e) where ex âˆˆ Ex. The minimal size of the
intersection is smaller or equal to the average; that is,
min
e,exâˆˆEx and bâˆˆB(ex)
|S âˆ© XC(e)| â‰¤ |S|
p1
.
By applying this upper bound to the sets D and (D âˆ’ex), we
get,
â–³ â‰¤ min
eâˆˆEx
|D âˆ© XC(e)| + |(D âˆ’ ex) âˆ© XC(e)| â‰¤ 2|D|
p1
.
Therefore, the minimal difference of the errors in Ex is upper
bounded by â–³ â‰¤ 2|D|/p1 for any D, and
QM = maxeÌ¸=0 RC(e) âˆ’ âˆ†
|M|
â‰¥ (|M| âˆ’ |D|)
p1|M|
.
C. The impact of the size of M on its error masking proba-
bility
Before we address the question of how to choose Dw (and
hence, D), we need to relate to cases where the choice of D
has no impact. In such cases, regardless of the choice of D,
the error masking probability coincides with the worst case
given in Th. 2; that is, â–³ = 0.
Theorem 4. If p1 = 2, it is always possible to choose D such
that â–³ > 0. If p1 Ì¸= 2 and
|D| â‰¥ (p1 âˆ’ 1)kq + 1,
it is possible to choose D such that â–³ > 0; and similarly, if
|Dw| â‰¥ (p1 âˆ’ 1)wq + 1
then it is possible to choose Dw such that âˆ† > 0.
Proof ommitted.
IV. CONVERTER STRUCTURE
Usually, a converter is built from identical sub-blocks.
Hence, it is sufï¬cient to determine the set Dw of unused
vectors for a single sub-block. In this section, it is assumed
that p1 = 2; however, with a small modiï¬cation the results
can be applied to other cases. Recall that we assume that k2
w2
is an integer, and that kq =2s. The case where
k2
w2 is not an
integer can be viewed as a subcase of this case. The output of
the converter is a q-ary vector of length wq, x = (x1, . . . xwq).
We deï¬ne a Hamming ball of dimension wq and radius p1
as the set
Hwq,p1 =
{
zj =
wq
âˆ‘
i=1
hjivi | hji âˆˆ {0, . . . , p1 âˆ’ 1}
}
,
where vi = 0iâˆ’110wqâˆ’iâˆ’1 is a unite vector of Hamming
weight one.
The size of a Hamming ball is pwq
1 . If p1 = 2 then |Hwq,p1|
divides |Dw|. Hence, Dw can be a union of shifted disjoint
Hamming balls.
The following construction is designed to maximize âˆ†,
hence to minimize the error masking probability.
We start by deï¬ning a set of offset vectors Î“wq,
Î“wq = {Î¸ âˆˆ Zwq
q
| Î¸ =
kq
âˆ‘
i=1
vip1ti,
ti âˆˆ {0, . . . , q
p1
âˆ’ 1}}.
Notice that the symbols of Î¸ are multiples of p1. Therefore,
for any two vectors Î¸1 Ì¸= Î¸2, the intersection (Î¸1 âŠ• Hwq,p1) âˆ©
(Î¸2 âŠ• Hwq,p1) is empty.
Construction 2 (Disjoint Hamming Balls). Deï¬ne the set Dw
as
Dw =
âˆª
Î¸iâˆˆÎ˜
Î¸i âŠ• Hwq,p1.
(11)
where Î˜ âŠ† Î“wq is an arbitrary subset of offsets vectors, |Î˜| =
|Dw|/p1wq.
Recall that each information word is a concatenation of
kq/wq vectors of length wq. If one of these vectors is in Dw,
the resulting information word is in D; if none of them is in
Dw, the resulting information word is in M. In other words,
the set of unused information words is
D =
âˆª
ÏˆâˆˆÎ¨
Ïˆ âŠ• Hkq,p1,
19
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-492-3
DEPEND 2016 : The Ninth International Conference on Dependability

where a vector Ïˆ is in Î¨ if at least one of its kq/wq portions
is a vector in Î˜ and the others are in Î“wq.
Theorem 5. If D is chosen according to Const. 2 and p1 = 2
then
(|M| âˆ’ |D|)
p1|M|
â‰¤ QM(e) â‰¤ 1
p1
= QC.
Proof ommitted.
Is it possible to reach the lower bound on QM? Recall the
proof of Theorem 3; in the proof, an upper bound on âˆ† was
obtained by adding the sizes of two sets. If these two sets are
disjoint, an equality holds. In other words, it is possible to
reach the lower bound on QM if for all x âˆˆ D, x /âˆˆ D âˆ’ ex.
The following example shows that in some cases this situation
cannot be avoided.
Example 3. Consider the case where q = 6, kq = wq = 3
and k2 = w2 = 7. In this case D is a union of 11 shifted
Hamming balls |D| = 11 Â· |H3,2| = 88, here |Î¨| = 11. In
fact, there are (q/2)3 = 27 possible vectors out of which
Î¨ is chosen. Therefore, there must be at least two linearly
dependent vectors in Î¨. Without loss of generality, assume
that Ïˆ1 = 002 and Ïˆ2 = 004 are in Î¨. In this case, for
ex = 003 âˆˆ Ex and x = 005 we have,
x
=
(Ïˆ2 âŠ• 001) âˆˆ D
x
=
(Ïˆ1 âŠ• 000) âŠ– 003 âˆˆ D âˆ’ ex
That is, x is both in D and D âˆ’ ex.
V. CONCLUSION
This work analyzed the efï¬ciency of robust codes when
used to protect multilevel memories. When the codeâ€™s alphabet
size, q, is not a power of two, the binary information must be
converted into a q-ary word. It was shown that this conversion
can signiï¬cantly degrade the error masking probability of
the codes. However, by wisely designing the converter, the
degradation of the code properties can be minimized. Bounds
on the practical error masking probability were given. A
construction for the converter in cases where the QS code
is applied to the multilevel memory was provided. It was
shown that this construction indeed reduces the error masking
probability of the resulting code.
ACKNOWLEDGMENT
This research was supported by the ISRAEL SCIENCE
FOUNDATION (grant No. 1200/12).
REFERENCES
[1] S. Skorobogatov and R. Anderson, â€œOptical fault induc-
tion attacks,â€ in Cryptographic Hardware and Embedded
Systems-CHES 2002.
Springer, 2003, pp. 2â€“12.
[2] A. Barenghi, L. Breveglieri, I. Koren, and D. Naccache,
â€œFault injection attacks on cryptographic devices: Theory,
practice, and countermeasures,â€ Proceedings of the IEEE,
vol. 100, no. 11, pp. 3056â€“3076, 2012.
[3] H. Bar-El, H. Choukri, D. Naccache, M. Tunstall, and
C. Whelan, â€œThe sorcererâ€™s apprentice guide to fault
attacks,â€ Proceedings of the IEEE, vol. 94, no. 2, pp.
370â€“382, 2006.
[4] R. E. Blahut, â€œTheory and practice of error control
codes,â€ Reading, 1985.
[5] M. Karpovsky, K. Kulikowski, and Z. Wang, â€œRobust er-
ror detection in communication and computational chan-
nels,â€ Spectral Methods and Multirate Signal Processing.
SMMSPâ€™2007. International Workshop on.
[6] I. Shumsky, O. Keren, and M. Karpovsky, â€œRobustness
of security-oriented binary codes under non-uniform dis-
tribution of codewords,â€ in DEPEND 2013, The Sixth
International Conference on Dependability, 2013, pp.
25â€“30.
[7] Y. Neumeier and O. Keren, â€œRobust generalized punc-
tured cubic codes,â€ IEEE Transactions on Information
Theory, vol. 60, pp. 2813â€“2822, 2014.
[8] N. Admaty, S. Litsyn, and O. Keren, â€œPuncturing, expur-
gating and expanding the q-ary bch based robust codes,â€
in Electrical Electronics Engineers in Israel (IEEEI),
2012 IEEE 27th Convention of, Nov 2012, pp. 1â€“5.
[9] M. Karpovsky and A. Taubin, â€œNew class of nonlinear
systematic error detecting codes,â€ Information Theory,
IEEE Transactions on, vol. 50, no. 8, pp. 1818â€“1819,
2004.
[10] M.
Bauer,
â€œData
path
for
multi-level
cell
memory,
methods
for
storing
and
methods
for
utilizing
a
memory
array,â€
Mar.
24
2011,
uS
Patent
App.
12/956,977.
[Online].
Avail-
able:
http://www.google.com/patents/US20110069548
[accessed: 2016-5-22]
[11] K. D. Akdemir, G. Hammouri, and B. Sunar, â€œNon-linear
error detection for ï¬nite state machines,â€ in Information
Security Applications.
Springer, 2009, pp. 226â€“238.
[12] A. Levina and S. Taranov, â€œSpline-wavelet robust code
under non-uniform codeword distribution,â€ in Computer,
Communication, Control and Information Technology
(C3IT), 2015 Third International Conference on.
IEEE,
2015, pp. 1â€“5.
[13] R. Cramer, Y. Dodis, S. Fehr, C. PadrÂ´o, and D. Wichs,
â€œDetection of algebraic manipulation with applications to
robust secret sharing and fuzzy extractors,â€ in Advances
in Cryptologyâ€“EUROCRYPT 2008.
Springer, 2008, pp.
471â€“488.
[14] Z. Wang and M. Karpovsky, â€œRobust fsms for crypto-
graphic devices resilient to strong fault injection attacks,â€
in On-Line Testing Symposium (IOLTS), 2010 IEEE 16th
International.
IEEE, 2010, pp. 240â€“245.
20
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-492-3
DEPEND 2016 : The Ninth International Conference on Dependability

