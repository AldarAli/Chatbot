469
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Reuse-Based Test Traceability:
Automatic Linking of Test Cases and Requirements
Thomas Noack, Thomas Karbe
Technische Universit¨at Berlin,
Daimler Center for Automotive IT Innovations (DCAITI)
Berlin, Germany
Email: {thomas.noack,thomas.karbe}@dcaiti.com
Steffen Helke
Brandenburg University of Technology
Cottbus - Senftenberg (BTU)
Cottbus, Germany
Email: steffen.helke@b-tu.de
Abstract—Safety standards demand full requirement traceability,
which includes a complete tracing between requirements and test
cases to stipulate how a requirement has to be veriﬁed. However,
implementing such a concept rigorously is time-consuming and
costly. Furthermore, in the automotive industry this cost is
repeatedly incurred for each vehicle series, because in contrast
to other development artefacts, reuse strategies for trace links
have not yet been sufﬁciently researched. This paper presents
the novel approach of Reuse-based Test Traceability, which allows
for a more cost-effective implementation of trace links in certain
cases. First, we identify and formalize a scenario, the so called
RT-Problem, for reusing trace links between test cases and reused
requirements, which has been observed in industry practice.
Next, based on this formalization we propose a 3-layered method,
which automatically creates links between test cases and reused
requirements. For reasons of practicality, we focus on the ﬁrst
layer, which represents a transitive test-link reuse. Finally, we
present the results of two ﬁeld studies demonstrating that our
approach is feasible in practice. As the main contribution of this
work we show that the automated reuse of test cases on the basis
of reused requirements is both possible and useful.
Keywords–Reuse; Requirements; Test cases; Traceability.
I.
MOTIVATION
New safety standards like ISO 26262 mean demand for
traceability is higher than ever. Consequently, automotive
companies must work hard to establish traceability for every
phase in the V-Model. For instance, if a software error occurs,
the speciﬁc part of the source code that has caused it should
be identiﬁed. This is achieved by trace linking development
artefacts. In hierarchical development processes, links between
requirements and test cases are some of the ﬁrst to arise.
These links are an integral part of a relationship network. For
example, an error is discovered by a test case. This test case
is trace linked with a system requirement, which in turn is
connected to the source code. Each kind of comprehensibility
necessitates links between the requirements involved.
However, rigorously implementing such a concept is time-
consuming and costly. Furthermore, in the automotive industry
this cost must be paid for each vehicle series project, repeat-
edly, because in contrast to other development artefacts, reuse
strategies that generate trace links automatically have not been
sufﬁciently researched.
Therefore, we propose a novel method for reuse-based
traceability, which extends [1] and allows for a more cost-
effective implementation of trace links in certain cases.
Among other things, the ISO standard deﬁnes a demand
for two categories of trace links. The ﬁrst is called Test
Traceability – ISO 26262 Pt. 8 [2, p.25] – and relates to a link
convention for test speciﬁcations. Each speciﬁcation in a test
case must include a reference to the version of the associated
work product. The second category relates to Reuse-based
Traceability – ISO 26262 Pt. 6 [3, p.20] – which demands
that every safety-related software component must be classiﬁed
according to information on reuse and modiﬁcation. Thus, the
standard deﬁnes four classes: newly developed, reused with
modiﬁcation, reused without modiﬁcation, and a commercial
off-the-shelf product.
Our approach contributes to both claims. First, we provide
a cost-effective technique for automatically generating trace
links between test cases and requirements, which addresses
the test traceability of the ISO standard. Secondly, we provide
the generation of trace links between requirements or test cases
from a previous project and the corresponding counterparts in
a new project, to indicate that previous artefacts have been
reused. Furthermore, our framework allows for these links to
be qualiﬁed, by using types reﬂecting whether an artefact was
modiﬁed or not.
Structure.
The next section introduces a motivating ex-
ample, illustrating a scenario where trace links can be reused.
The section also gives important deﬁnitions of development
artefacts. The section closes with the presentation of the
RT-Problem (Reuse-based Test Traceability Problem), which
forms the basis of this paper. Section III gives pointers to
related work. We brieﬂy survey existing traceability models
and methods. We also identify limitations of these approaches
to justify the need for this work. Section IV presents our 3-
layered method, where we focus on the ﬁrst layer, the so-called
RT-linking technique. Section V describes theoretical concepts
behind our RT-linking strategy. Subsequently, Section VI
presents the results of two ﬁeld studies demonstrating that our
approach is feasible in practice. We also compare our technique
with the previous manual procedure. To give the reader an
impression of the complete method, Sections VII and VIII
sketch the second and the third layer. The paper closes with
conclusions and future work in Section IX.

470
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
II.
SYSTEM REQUIREMENTS AND TEST CASES
A. Introductory example
Figure 1 shows an example based on real speciﬁcation
documents. The upper left box contains artefacts from a
previous vehicle series project, e.g., vehicle function 1000:
Interrupt of front wiping during engine start. Requirements
1001 and 1002 reﬁne vehicle function 1000. The lower box
contains test cases, e.g., test case 5376: Washing during engine
start. Requirement 1002 and test case 5376 are connected via
a trace link.
Requirements reuse.
Reuse happens in all phases of
the V-Model; therefore, reuse also applies to requirements.
Requirements are reused from previous vehicle series in or-
der to specify a new vehicle series. Technically, this reuse
is achieved by copying and adapting the old requirements
to the new vehicle series project. The upper right box in
Figure 1 shows the reuse requirements. For example, the reuse
requirement 1002-new has been changed most: the description
of the washing interruption has been moved.
Test trace reuse.
This adaptation of requirements ex-
empliﬁes the main feature of Reuse-based Test Traceability:
Is test case 5376, which already veriﬁes source requirement
1002, also suitable for verifying target requirement 1002-new?
More succinctly: Can test case 5376 be linked with target
requirement 1002-new?
Figure 1: Example requirements and test cases in DOORS
B. System Requirements Speciﬁcation (SRS)
A vehicle is described by many SRS. Every system, like
the Wiper Control or the Outside Light Control is speciﬁed
in one SRS. The main engineering artefacts in SRS are
vehicle functions and the system requirements that reﬁne
them. Individual vehicle functions can be very extensive. For
instance, the function wipe windscreen is characterized by
several activation possibilities, wipe stages, passenger and
pedestrian splash protection, etc., and therefore is reﬁned by
more than 300 requirements.
Count per vehicle series.
If one function alone can
have 300 requirements, how many requirements does a whole
vehicle series have? The following estimate gives a vague idea:
Modern vehicles have up to 100 electronic control units (ECU).
Usually, multiple automotive systems run on each ECU. For
simplicity, we assume that only one software system runs on
each ECU. Further, we assume that midsize systems have at
least 1000 requirements or more. Using these assumptions, a
modern vehicle can accumulate hundreds of thousands or even
millions of requirements.
Requirements classiﬁcation.
In addition, requirements
have classifying properties such as Automotive Safety Integrity
Levels (ASIL), testability, ownership, supplier status or depen-
dencies to other SRS. Therefore, requirement categories exist,
e.g., safety critical, testable or highly dependent requirements.
C. System Test Speciﬁcation (STS)
Each SRS has at least one associated STS, which contains
test cases to verify the correct implementation of the require-
ments. The structure of these test cases corresponds to the com-
mon schema: Pre-condition, post-condition, pass-condition,
test steps etc. [4, p.263]. Each requirement which is classiﬁed
as testable is trace linked to at least one test case. This
facilitates comprehensibility to determine the requirements-
based test case coverage.
Count per vehicle series. Again, the question arises: How
many test cases does an entire vehicle series have? Because
the test case count corresponds to the requirements count, a
modern vehicle has at least as many test cases as requirements.
Usually, more tests than requirements exist.
Test case classiﬁcation.
Like requirements, test cases
have classifying properties such as test goals, test levels or
test platforms. While test goals result from quality models as
proposed in ISO 9126 [5], test levels describe the right branch
of the V-Model. Automotive-speciﬁc test platforms include
Vehicle Network or HiL (Hardware-in-the-Loop).
D. Test Concept (TC)
The ISO 26262 dictates the existence of a TC. It deﬁnes
which test objects must be tested at which test level on which
test platform in order to fulﬁl which quality goals (What?
When? Where? Why?). The TC determines the relationship
between the left and right branches of the V-Model. We focus
on the system level of the V-Model because Reuse-base Test
Traceability uses the requirement test object type. In our case,
the TC deﬁnes which test cases must be trace linked with
which requirements to sufﬁciently verify a vehicle series.
Usage of requirements and test case classiﬁcation. The
TC does not contain speciﬁc system requirements or test cases.
It relies on the classifying properties of the artefacts involved.
For instance, a requirement’s ASIL ranking inﬂuences testing
expenses because it is strongly related to the test goal and test
level properties of the test case. The higher the ASIL ranking,
the more test cases must be trace linked with requirements.
The TC allows us to assess the trace link coverage between
SRS and STS.

471
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
E. RT-problem
Reuse-based Test Traceability relies on a speciﬁc situation
observed in industrial practice: The RT-problem. Figure 2
depicts how the RT-problem reﬂects the Reuse relationship
between two SRS and the Test relationship between an STS
and these two SRS. In the example, a requirement of the
function front wiping (fw) from the SRSSrc has been reused
by fw′ in the SRSTgt.
Figure 2: RT-problem within speciﬁcation documents
R: Reuses. Among others, one reuse method is to copy
an entire SRS into the project folder of the new vehicle series
project. Thus two SRS result: the SRSSrc of the previous
vehicle series and the adapted SRSTgt of the current vehicle
series. Both SRS are in a reuse relationship: The SRSTgt reuses
the SRSSrc.
T: Tests.
Interestingly, the STS is not copied between
vehicle series. Instead, the test cases are reused by redirecting
trace links from the SRSSrc to the reusing SRSTgt. Overall, the
RT-problem reﬂects the situation before the STS enters a test
relationship with the SRSTgt.
R- and T-links.
Technically, artefacts are connected by
trace links. An R-link fw′ →R fw points from a target
requirement fw′ to a source requirement fw. We also say
(fw′, fw) is a reuse pair. A T-link t →T fw points from a
test case t to a (source) requirement fw.
Solving the RT-problem.
The RT-problem is unsolved
if the dashed T-link in Figure 2 does not exist. In this paper,
we propose transitive RT-linking, a new technique to set the
T-link t →T fw′ to the target requirement fw′.
Business case. Earlier we estimated a whole vehicle series
might have hundreds of thousands of requirements and test
cases. Therefore, the RT-problem must be solved hundreds
of thousands or even millions of times for each vehicle
series project. Usually, test cases are T-linked during their
creation. This T-linking requires little effort in comparison to
the creation of the test case. STS are test case collections which
are maintained over multiple vehicle series generations. In each
new vehicle series project those STS must be linked manually.
We observed that both time and motivation play an important
role in why fewer and fewer T-Links exist from project to
project. The primary goal of Reuse-based Test Traceability is
that test cases only need to be T-linked with requirements once,
at the time they are ﬁrst written down.
III.
RELATED WORK
A trace link connects trace artefacts and deﬁnes the type
of relation between them [6, p.104]. In general, traceability is
the possibility to establish and use trace links [7, p.9]. Thus,
traceability enables comprehensibility. A traceability (informa-
tion) model deﬁnes all possible artefacts and their types, as
well as all possible links and their types [7, p.13]. Our work
contributes to the special ﬁeld of requirements traceability.
Requirements traces are trace links between requirements and
other software development artefacts [8, p.91]. Requirements
traces always have a direction: forwards, backwards, inter or
extra.
Link direction. A forward-trace connects a requirement
with artefacts which have been created later in the development
process. Examples of forward traces are links to architectural
artefacts, source code or test cases. A backward-trace docu-
ments the origin of a requirement. Examples are links from
laws or standards. An inter-trace links a requirement with
another requirement. These links can reﬂect dependencies,
reﬁnement or even reuse. An extra-trace links a requirement
with a non-requirement. Examples are architectural artefacts,
source code or test cases.
Link direction in the RT-problem.
An RT-problem
consists of two links: an R-link and a T-link. The R-link
connects a source and a target requirement. Therefore, it is
an inter-trace link. Simultaneously, it is a backward-trace link
because it reﬂects the origin of the target requirement. The T-
link connects a test case with a source requirement. Thus, it is
an extra- and forward-trace link. We observe that even though
the RT-problem is very simple it contains inter, extra, forward
and backward trace links.
A. Traceability models
Traceability models deﬁne the involved and linkable arte-
facts and the possible link types [9, p.106]. The RT-problem
is a traceability model. The concept of traceability models
appeared early in the development of software engineering: the
ﬁrst models appeared in the 1980s. The following paragraphs
introduce relevant traceability models from the past 25 years.
General models without explicit T-links.
The SO-
DOS model [10] represents linkable artefacts via a relational
database scheme. The trace links are freely conﬁgurable. Thus,
SODOS is capable of connecting everything with everything.
In the early 1990s, hypertext became very popular. The idea
was to specify requirements and other software engineering
artefacts by means of hypertext and link them using hyperlinks.
Examples of hypertext traceability models include HYDRA
[9], IBIS [11], REMAP [12], RETH [13], and the TOORS [14]
model. Hyperlinks are mainly generic, so everything can be
connected with everything else. Around the turn of the century,
traceability models shifted their focus from hypertext models
to UML-based traceability models [15] [16]. In accordance
with the SOTA (State of the Art), older traceability models are
more general while newer models are more speciﬁc. Newer
work focuses on links between requirements [17] or links
between requirements and design artefacts [18]. Although it
is possible to deﬁne T-links in general traceability models, the
models discussed here do not explicitly support T-links.

472
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Models with T-links.
In recent years, software testing
has become increasingly popular. Thus, T-links have become
an explicit part of traceability models. Ibrahim et al. propose
the Total Traceability Model [19]. They consider requirements
(R), test cases (T), design (D) and code (C). The model is
exhaustive because it supports pair-wise extra-traces between
the artefacts R-T, R-D, R-C, T-D, T-C and D-C. Furthermore,
it supports the inter-traces D-D and C-C. Asuncion et al.
have developed an End-to-End traceability model [20]. They
consider marketing requirements (M), use cases (U), functional
requirements (F) and test cases (T), which can be extra-linked
in a M-U, U-F and F-T pipeline. Kirova et al. propose a trace-
ability model, which uses performance requirements (PR), high
level requirements (HLR), architectural requirements (AR),
system requirements (SR), high level design (HLD), low level
design (LLD), test cases (T) and test plans (TP). Kirova’s
model allows links between PR-AR, PR-SR, PR-T, HLR-SR,
AR-SR, AR-T, AR-TP, AR-HLD, AR-LLD, SR-T, SR-TP, SR-
HLD and SR-LLD. Azri and Ibrahim propose a metamodel
[21] to allow trace links between arbitrary artefacts, including
code, roles and even output ﬁles from developer tools.
RT-problem. The related work commonly draws holistic
traceability pictures. Thus, a standard goal is to deﬁne holistic
traceability models and exhaustively list the engineering arte-
facts and possible trace link types. However, the RT-problem is
a specialized traceability model which focuses on a narrow set
of circumstances. By using T-links explicitly, it focuses on the
relationship between requirements and test cases. Additionally,
the RT-problem introduces a new factor, the representation of
requirements reuse with the help of R-links.
B. Traceability methods and techniques
The Requirements Traceability Matrix (RTM) was one of
the ﬁrst techniques that could systematically handle traceability
[22]. The RTM is simply a table of requirement rows and
linkable artefact columns. Each cell in the table represents
a possible link. Requirements engineering tools like DOORS
[23] support the RTM. Newer work is based on the idea
of automatically creating trace links between artefacts and
providing impact analysis. Two surveys [24, p.2] [25, p.31]
categorize the SOTA of traceability methods as follows: event-
based, rule-based, feature model-based, value-based, scenario-
based, goal-based and information retrieval-based.
Event-based Traceability (EBT). EBT [26] introduces an
event service where any linkable artefacts are registered. The
service takes over the traceability and artefacts are no longer
linked directly. Thus, EBT supports maintainability, as events
trigger when artefacts change.
Rule-based Traceability (RBT). RBT [27] applies gram-
matical and lexical rules to ﬁnd artefacts in structured spec-
iﬁcation documents and use case diagrams. A pairwise rule
matching algorithm looks for artefacts, which match a rule.
RBT links those related artefacts.
Feature Model-based Traceability (FBT). FBT [28] uses
the feature as a connecting element between requirements and
architecture as well as requirements and design. FBT uses
several consistency criteria, e.g., whether each feature has at
least one requirement and test case.
Value-based Traceability (VBT).
VBT [29] assumes
that a complete linkage between all involved artefacts is not
feasible. Thus, VBT supports prioritized requirements and
differently precise traceability schemes. The goal of VBT is to
distinguish between links that generate beneﬁts and links that
only produce costs.
Scenario-based Traceability (SBT).
SBT [30] uses
scenarios, such as state chart paths, which are linked with
requirements and code fragments. The creation of new links
is performed transitively via code analysis. SBT is capable of
completing links between requirements and code.
Goal-based Traceability (GBT). GBT [31] uses a quality
model to deﬁne nonfunctional quality goals. Those nonfunc-
tional goals are then connected to functional requirements. The
goal of GBT is to trace the change impact from functional
requirements to nonfunctional goals.
Information Retrieval-based Traceability (IBT).
In
recent years, IBT has become increasingly popular. Several
approaches exist to ﬁnding and linking related artefacts [32].
The general idea behind IBT is to use information retrieval
algorithms and similarity measures.
C. Alignment with SOTA (State-of-the-Art)
EBT propagates requirements change to linked artefacts.
Thus, EBT is a technical event-based method to avoid manual
tracing of impact and manual button clicks. Although it would
be interesting to automatically execute the RT-problem solving
technique after requirements reuse, we do not need EBT to
solve the RT-problem methodically. RBT uses grammatical
and lexical analysis to ﬁnd similar requirements. Although it
would be interesting to ﬁnd reuse pairs with RBT, we assume
that all R-links exist. Because of the importance of variability
in the automotive domain, other research focuses on FBT
[33]. VBT tries to reduce the number of links in order to
reduce maintenance costs. The RT-problem is a specialized
traceability model to reﬂect a simple circumstance and analyze
it holistically. Thus, we do not want to remove any links in
this way. SBT introduces an additional connecting artefact to
link requirements and code. Because we focus on requirements
and test cases, we do not desire new artefacts. Thus, SBT is
also not suitable to solve the RT-problem.
New technique: RT-linking. Firstly, we propose a new
technique to transitively link test cases by considering re-
quirements reuse: RT-linking. We present a 3-layered method
which integrates our RT-linking with parts of the SOTA. RT-
linking is the primary method layer for creating new trace
links between test cases and reusing requirements completely.
To make the linking more precise we need additional ﬁltering
techniques, which are executed during the complete RT-
linking. These ﬁltering techniques deﬁne the other two layers
of the 3-layered method. While the ﬁrst layer establishes all
links between test cases and reusing target requirements, the
second and third layers ﬁlter out or highlight suspicious linking
situations. The second layer uses the idea behind GBT to assess
the test coverage with respect to test goals and other testing
criteria. The third layer adapts IBT to search for similar RT-
problems.

473
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
IV.
3-LAYERED METHOD
Figure 3 depicts the method layers as ﬁrst proposed in
[1]. Each layer consists of the same three phases. The speciﬁc
tasks in each phase differ depending on the characteristics of
the layer. Each subsequent layer enhances its predecessor’s
phases via additional tasks. The general tasks performed in
the three phases are as follows:
•
Extract RT-problems from SRSSrc, SRSTgt and STS.
•
Set/Filter T-links from STS to SRSTgt.
•
Assess T-links and highlight the link status.
Figure 4 depicts the 3-layered method in more detail. We
will use the depicted example to brieﬂy introduce the layers.
A. First layer: Transitive RT-Linking
Extract RT-problems. Figure 4 depicts an RT-problem:
The target front wiping fwTgt reuses the source front wiping
fwSrc. Thus, (fwTgt, fwSrc) is a reuse pair. The test case fwTest
has a T-link to fwSrc. Because fwTest is not yet T-linked to
fwTgt, one RT-problem is extracted.
Set T-links.
The T-links of all extracted RT-problems
are set transitively: If a test case is T-linked with a source
requirement and this source requirement is R-linked with a
target requirement, then the test case is also T-linked with the
target requirement.
Assess T-links.
Two scenarios can occur for each RT-
linked target requirement: (a) It is textually identical to the
source requirement and hence a T-link needs no review or (b)
it has been changed and, therefore, the T-link must be reviewed
manually. The third phase of each layer highlights the SRSTgt
according to the assessment results.
B. Second layer: Test Concept-driven ﬁltering
Extract RT-problems.
Figure 4 indicates that the test
case fwTest meets the test goal correctness of interfaces. This
information is extracted from the STS and appended to the
test case of the RT-problem. We say that the RT-problem is
augmented with the classifying property test goal.
Figure 3: 3-layered method
Filter T-links.
The TC deﬁnes whether a test case is
needed to sufﬁciently verify a vehicle series. In Figure 4, the
TC deﬁnes that the test goal correctness of interfaces must be
met. Because the TC demands for a interface test case such as
fwTest, the RT-linking connects fwTest and fwTgt. Otherwise,
fwTest would have been ﬁltered out.
Assess T-links.
While the ﬁrst layer can only make
statements about the existence of T-links, the second layer
also considers the TC. Therefore, for each target require-
ment the following more detailed scenarios arise: (a) miss-
ing/superﬂuous test goals, (b) missing/superﬂuous test levels
and (b) missing/superﬂuous test platforms. The SRSTgt is
highlighted according to the TC coverage. TC-driven ﬁltering
has been proposed in [34].
C. Third layer: Case-Based ﬁltering
Extract RT-problems. We assume that the requirements
in Figure 4 have a classifying property, interfaces. While
the source requirement fwSrc has an interface to the column
switch, the target requirement has an additional interface to
the rain sensor. In other words, the interfaces of the reuse
pair (fwTgt, fwSrc) have changed. Again, we use the classifying
properties to augment the extracted RT-problem.
Filter T-links. A Case Base contains RT-cases. RT-cases
are RT-problems which include an RT-decision and a review
note. The RT-decision deﬁnes whether a T-link can be set to
a target requirement. Figure 4 depicts a simple RT-case: if
the interfaces change, interface tests must be reviewed. This
RT-case is very similar to our current RT-problem. Thus, the
RT-decision Review needed is used to solve it.
Assess T-links.
While the second layer only uses clas-
sifying test case properties, the third layer relies on fully
augmented RT-problems. That means RT-cases can be deﬁned
freely by taking any classifying property into account. Thus,
the assessment scenarios are as numerous as the RT-case
possibilities. Finally, the RT-cases’ review notes are copied
into the SRSTgt.
Figure 4: 3-layered method in more detail

474
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
V.
RT-LINKING: CONCEPTS
A. Fundamental Example
Figure 1 showed an example with real requirements and
test cases. However, real requirements and test cases are
very extensive and also conﬁdential. Therefore, the following
sections will use the abstract example in Figure 5 to simplify
the problem and concentrate on its relevant features.
Phase 1: Extract RT-Problems.
Figure 5 shows the
speciﬁcation documents SRSSrc, STS and SRSTgt. Each ex-
ample SRS contains one vehicle function, which is reﬁned
by requirements. While SRSSrc contains the source require-
ments srci, SRSTgt contains the target requirements tgti. The
Reuse column indicates for both SRS which source or target
requirements the R-links point to. The Test column in SRSSrc
indicates whether a source requirement is connected via a
T-link with a test case. The T-links: Before column in STS
displays which requirements the test cases were linked with
before RT-linked them. Figure 5 contains three RT-problems
with the following R- (→R) links and T-links (→T):
•
tgt1 →R src1 and test1
→T src1,
•
tgt2 →R src2 and test2
→T src2,
•
tgt3 →R src3 and test3/4 →T src3.
Phase 2: Execute RT-linking. The transitive RT-linking
uses the following assumption:
IF
a target requirement reuses a source requirement
AND IF
a test case veriﬁes a source requirement
THEN
the test case also veriﬁes the target requirement.
After performing the RT-linking, the T-Links: After column
contains the names of the source and target requirements which
are linked with the test case by a T-Link. The T? column in
SRSTgt indicates whether there is a T-link to a test case. The
column is set to Check if the text for the target requirement
has changed or if RT-inconsistencies (see Phase 3) have
been uncovered. As Figure 5 shows, the second layer of the
transitive RT-linking results in three solved RT-problems:
•
tgt1 →R src1 and test1
→T src1 ⇒ test1
→T tgt1,
•
tgt2 →R src2 and test2
→T src2 ⇒ test2
→T tgt2,
•
tgt3 →R src3 and test3/4 →T src3 ⇒ test3/4 →T tgt3.
Phase 3: Assess T-links. The similarity column of SRSTgt
represents the textual similarity of a reuse pair in percent. It
is calculated with the help of well-known similarity measures,
e.g., Dice, Jaro-Winkler or the Levenshtein distance [35]. As
well as textual similarity, several other inconsistencies might
occur, e.g., the SRSSrc describes a front and a rear wiper.
A test case veriﬁes both source requirements: If the reverse
gear is engaged and if the column switch is pushed then
the front and rear wipers will wipe. Now the target vehicle
series does not provide a rear wiper. However, the SRSTgt
reuses the front wiper requirement and the T-link from the test
case. The inconsistency arises because the test case veriﬁes a
functionality (rear wiping) which does not exist in the target
vehicle series.
Figure 5: Fundamental Before-After example
B. RT-Linking
The following basic sets describe the RT-problem:
SRSSrc ˆ= set of source system requirements
SRSTgt ˆ= set of target system requirements
STS ˆ= set of system test cases
The upper left circle in Figure 6 represents SRSSrc, i.e., the
set of all source system requirements. The upper right circle
analogously represents SRSTgt, i.e., the set of all target system
requirements. The lower circle shows the STS, i.e., the set
of all system test cases. All three sets are disjoint, thus the
overlapping areas in Figure 6 do not symbolize intersected
sets, but linked elements between the disjoint sets.
Reuse pairs: R-links between requirements.
An R-
link rtgt →R rsrc always points from target to source. A reuse
target requirement from SRSTgt therefore points towards a
reused source requirement from SRSSrc. Both target and source
requirements can have multiple outgoing or incoming R-links.
The following sets describe this information:
R := {(rtgt , rsrc ) ∈ SRSTgt × SRSSrc | rtgt →R rsrc }
RR,Src := {rsrc ∈ SRSSrc
| ∃rtgt : (rtgt , rsrc ) ∈ R}
RR,Tgt := {rtgt ∈ SRSTgt
| ∃rsrc : (rtgt , rsrc ) ∈ R}
The set R contains reuse pairs (rtgt , rsrc ) which show that
a R-link is pointing from rtgt to rsrc . Thus, (rtgt , rsrc ) ∈ R is a
synonym for rtgt →R rsrc . The pair (rtgt , rsrc ) is also a reuse
pair. The sets RR,Src and RR,Tgt contain all requirements that
are part of a reuse pair. Thus, RR,Src contains all reused source
requirements from SRSSrc, and RR,Tgt contains all reusing
target requirements from SRSTgt.

475
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
T-links from Test Cases to Requirements.
A T-link
t →T r points from a test case to a requirement. An active
test case points towards at least one requirement. A veriﬁed
requirement has at least one incoming T-link from a test
case. A test case can verify multiple source and/or target
requirements, depending on whether it points into SRSSrc, into
SRSTgt or both.
T : SRSSrc ∪ SRSTgt → P(STS)
T(r ) := {t ∈ STS | t →T r }
RT,Src := {rsrc ∈ SRSSrc | ∃t ∈ STS : t →T rsrc }
RT,Tgt := {rtgt ∈ SRSTgt | ∃t ∈ STS : t →T rtgt }
For a given requirement r (source or target), the function
T derives all test cases that are linked with it. The set RT,Src
contains all source requirements rsrc from SRSSrc for which
at least one T-link t →T rsrc points from a test case t from
STS to rsrc . Analogously, the set RT,Tgt contains all target
requirements rtgt that are linked with at least one test case t .
RT-linking. With these formal concepts we can reformu-
late the assumption for the transitive RT-linking:
IF
a target requirement rtgt and
a source requirement rsrc are linked by an R-link
AND IF
a test case t is linked with rsrc by a T-link
THEN
t can also be linked to rtgt by a T-link.
This is represented by the formula
rtgt →R rsrc ∧ t →T rsrc ⇒ t →T rtgt
An RT-link, i.e., a solution for one of the three RT-problems
from the abstract example in Figure 5 is shown here:
tgt1 →R src1 and test1 →T src1 ⇒ test1 →T tgt1
Figure 6: Each RT-problem is a RT-instance among others
C. RT-diagram
The RT-diagram is a means to represent the number of
linking situations between requirements and test cases. It
categorizes these situations into different types, e.g., reused but
not tested requirements, reused and tested requirements. Figure
7 show the diagram schematically. The different segments of
the diagram represent the different types of linking situations,
which result from the existence or non-existence of links
between the three basic sets SRSSrc, STS, and SRSTgt. Each
segment is labelled with a different symbol (e.g.,
,
)
that represents the type of the segment. In the industrial use
and ﬁeld studies in Section VI, the diagram segments show
the number of linking situations.
RT-instances and RT-types. From now on, we call the
different linking situations RT-instances. Every RT-instance
is assigned to an RT-type (e.g., not tested but reused require-
ment). All RT-instances from the same segment of the diagram
are also from the same RT-type. An RT-instance is denoted
by a set, which contains either
•
one artefact (meaning that this artefact is not linked)
Corresponding types:
,
,
,
•
one link (meaning that the two linked artefacts are not
linked to a third artefact)
Corresponding types:
,
,
,
•
two links (meaning that one R-link and one T-link
exists, but one T-link is missing to one of the partners
of the reuse pair)
Corresponding types:
inconsistent, or
•
three links (fully linked, a solved RT-problem with a
reuse pair and T-links to both partners of the pair)
Corresponding types:
consistent.
On the next page we will examine the segments of the
RT-diagram. Each segment will also be given a short name
for future reference.
Figure 7: Types of RT-instances

476
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Requirements without RT (
,
).
Figure 8a depicts
those requirements which have no R-link and no T-link. The
segment on the left-hand side represents all discarded SRSSrc
requirements which have not been tested (
). The segment
on the right-hand side contains all new SRSTgt requirements
which have no associated test cases (
).
: RSrc TSrc := {{rsrc} | rsrc ∈ SRSSrc \ (RT,Src ∪ RR,Src)}
: RTgt TTgt := {{rtgt} | rtgt ∈ SRSTgt \ (RT,Tgt ∪ RR,Tgt)}
Reused requirements without T (
). Figure 8b depicts
all reuse pairs (rtgt , rsrc), which have no T-link to either
rtgt or rsrc . From the perspective of the SRSTgt these are all
reusable and untested target requirements. Although we use
the word untested, requirements with missing T-links do not
remain untested in industrial practice. The mapping between
requirements and test cases is then performed by engineers in
an experience-based fashion. Of course, in this case testing
takes place in SRSTgt; it is simply less traceable.
: R TSrc∗Tgt :=
{{rtgt →R rsrc} | (rtgt , rsrc) ∈ R ∧ T(rtgt) ∪ T(rsrc) = ∅}
Tested requirements without R (
,
). Figure 8c shows
all requirements that are not in a reuse relationship but which
have associated test cases. The segment on the left-hand side
depicts source requirements which are not reused, have no R-
link but do have a T-link from a test case (
). The right-hand
side shows all new target requirements which have no R-link
but a new T-link (
).
: RSrc TSrc := {{rsrc} | rsrc ∈ RT,Src \ RR,Src}
: RTgt TTgt := {{rtgt} | rtgt ∈ RT,Tgt \ RR,Tgt}
RT-problems (
). Figure 8d shows the center of the RT-
diagram. It represents the RT-problems, i.e., all RT-instances,
which have a reuse pair (rtgt , rsrc) and a test case which is
T-linked to at least one of the reuse partners. Therefore, the
diagram center bundles three RT-types: RT-instances which
have reuse pairs (rtgt , rsrc) and a T-link to rsrc (
Src). RT-
instances with reuse pairs which are only rtgt T-linked (
Tgt).
RT-instances which have reuse pairs and a T-link to both
partners of the pair (
Both).
:R TSrc+Tgt :=



{rtgt →R rsrc , t →T rsrc} |
(rtgt , rsrc) ∈ R ∧ t ∈ T(rsrc) ∧ t /∈ T(rtgt)



∪



{rtgt →R rsrc , t →T rtgt} |
(rtgt , rsrc) ∈ R ∧ t ∈ T(rtgt) ∧ t /∈ T(rsrc)



∪



{rtgt →R rsrc , t →T rsrc , t →T rtgt} |
(rtgt , rsrc) ∈ R ∧ t ∈ T(rsrc) ∧ t ∈ T(rtgt)



Test cases without T (
Src ,
Tgt ).
Figures 8e and 8f
depict the test cases which have no T-links into SRSSrc or
SRSTgt. In the context of the corresponding SRS those test
cases are inactive.
Src : T(rsrc ) := {{t} | t /∈
[
rsrc ∈SRSSrc
T(rsrc)}
Tgt : T(rtgt ) := {{t} | t /∈
[
rtgt ∈SRSTgt
T(rtgt)}
Set of all RT-instances.
An RT-instance represents a
concrete link between one, two, or three artefacts. The set of
all possible RT-instances RTInst is deﬁned by:
RTInst :=
∪
∪
∪
∪
∪
∪
Src ∪
Tgt
The
one-artefact
instances
{rsrc}
∈
,
{rtgt}
∈
, {t}
∈
Src and {t}
∈
Tgt symbolize artefacts
which are not linked to any other artefacts. The one-
link instances {rtgt →R rsrc} ∈
, {t→T rsrc} ∈
, and
{t→T rtgt} ∈
represent a link between exactly two arte-
facts, which both are not linked to any other artefact. The
two-link instances {rtgt →R rsrc , t →T rsrc}
∈
Src, and
{rtgt →R rsrc , t →T rtgt} ∈
Tgt represent a source and a
target requirement linked by an R-link and a test case which
is linked to either the source requirement or the target require-
ment. However, the second test link is missing. The three-
link instances {rtgt →R rsrc , t →T rsrc , t →T rtgt} ∈
Src+Tgt
represent fully linked instances.
(a) RSrc TSrc or RTgt TTgt
(b) R TSrc∗Tgt
(c) RSrc TSrc or RTgt TTgt
(d) R TSrc+Tgt
(e) T(rsrc )
(f) T(rtgt )
Figure 8: Segments in the RT-diagram

477
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
D. RT-inconsistencies
We will now examine instances of the type
: R TSrc+Tgt
in more detail. In these instances, test cases are T-linked
with one or both partners of an RT-problem’s reuse pair
(rtgt , rsrc). But, in practice test cases are not only linked with
one reuse pair. Usually, they have links to multiple reuse pairs
or even requirements which have no reuse relationship to other
requirements, which causes inconsistencies. Therefore, RT-
inconsistencies are caused by missing T-links or unfavourable
overlaps of reuse pairs with other requirements which are not
part of a reuse pair, or by combining or splitting require-
ments. An RT-inconsistency is not necessarily an error, but
an engineer should look into the RT-instance to check it. The
following formulas describe the conditions for a reuse pair to
be called consistent:
Consistency rule I. The ﬁrst consistency rule says that a
T-link must point to both partners in a reuse pair. If this rule
is broken it indicates either overlooked source T-links or new
target T-links. Two forms of rule I exist:
ISrc(rtgt , rsrc) := T(rsrc ) ⊆ T(rtgt )
ITgt(rtgt , rsrc) := T(rtgt ) ⊆ T(rsrc )
The ﬁrst form ISrc says that the set of all test cases which
are T-linked with the source requirement rsrc of reuse pair
(rtgt , rsrc) must also be T-linked with the target requirement
rtgt . The second inconsistency form ITgt is analogously de-
ﬁned: all test cases which are T-linked with rtgt of a reuse pair
(rtgt , rsrc) must also be T-linked with rsrc .
Consistency rule II.
While the ﬁrst inconsistency rule
assesses a reuse pair locally, the second inconsistency rule
takes other requirements into account. It says that each test
case that is T-linked to a given reuse pair is not allowed to
test other requirements which are not part of another reuse
pair. Therefore, this second rule highlights discarded source or
newly added target functionality from the testing perspective.
Again, two forms of inconsistency rule II exist:
IISrc(rtgt , rsrc) := ∀t ∈ T(rtgt ) ∪ T(rsrc ) :
∀r′
src ∈ SRSSrc : r′
src ̸= rsrc ⇒
(t →T r′
src ⇒ ∃r′
tgt ∈ SRSTgt :
t →T r′
tgt ∧ (r′
tgt , r′
src ) ∈ R)
IITgt(rtgt , rsrc) := ∀t ∈ T(rtgt ) ∪ T(rsrc ) :
∀r′
tgt ∈ SRSTgt : r′
tgt ̸= rtgt ⇒
(t →T r′
tgt ⇒ ∃r′
src ∈ SRSSrc :
t →T r′
src ∧ (r′
tgt , r′
src ) ∈ R
The ﬁrst form IISrc says that a reuse pair (rtgt , rsrc) is
consistent if all test cases of rsrc are only T-linked with
other source requirements r′src which are part of a reuse pair
(r′tgt , r′src ), for some target requirement r′tgt . In addition, all
such test cases must be T-linked with r′tgt . To improve the
reade’rs understanding of inconsistency IISrc we will repeat the
example of front and rear wipers. The front wiping requirement
has been reused and the reuse pair (fronttgt, frontsrc) exists.
Because the test case t is T-linked with frontsrc it has been
transitively RT-linked with fronttgt. Thus, t is T-linked with
both partners of the front wiping reuse pair. Now, t is also T-
linked with the source rear wiping requirement rearsrc, which
has not been reused because the new vehicle series does not
provide any rear wiping. Since no reuse partner exists for
rearsrc, t causes (fronttgt, frontsrc) to be inconsistent IISrc: Test
case t veriﬁes functionality which does not exist in the target
vehicle series. The second form IITgt is deﬁned analogously
from the perspective of the SRSTgt.
Consistency rule III. The third consistency rule indicates
whether a target requirement has been amalgamated from
multiple source requirements or a source requirement has
been split into multiple target requirements. A T-link becomes
problematic if a source requirement has been split. It is then
unclear which target requirement needs to be T-linked. Again,
two forms of consistency rule III exist:
IIISrc(rtgt , rsrc) := ∄r′
tgt ∈ SRSTgt :
rtgt ̸= r′
tgt ∧ (r′
tgt , rsrc ) ∈ R
IIITgt(rtgt , rsrc) := ∄r′
src ∈ SRSSrc :
rsrc ̸= r′
src ∧ (rtgt , r′
src ) ∈ R
The ﬁrst form IIISrc says that the source requirement rsrc of
the reuse pair (rtgt , rsrc) must not be a source partner of another
reuse pair. IIITgt says that the target requirement rtgt of the
reuse pair (rtgt , rsrc) must not be a target partner of another
reuse pair.
Extension of the centre of the RT-diagram. The centre
of the RT-diagram counts consistencies and inconsistencies.
While consistently solved RT-problems are counted in the
upper region of the centre, the inconsistent RT-instances are
counted in the lower region. As depicted in Figure 9, we fur-
ther differentiate between source and target inconsistencies in
this lower centre region. Source inconsistencies XSrc indicate
missing T-links which pointed to source requirements but not
reusing target requirements or splits in source requirements.
Target inconsistencies XTgt indicate progress because of newly
added T-links. Source inconsistencies are bad inconsistencies
and target inconsistencies are good inconsistencies.
Figure 9: Inconsistencies in the diagram centre

478
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Inconsistency ISrc.
Figure 10a depicts the reuse pair
(rtgt , rsrc) and the dashed T-link from test case t to rsrc . The
dashed T-link causes the reuse pair to be inconsistent ISrc
because T(rsrc ) ̸⊆ T(rsrc ). This situation represents a typical
RT-problem that needs do be solved.
Inconsistency ITgt. In Figure 10a, the reuse pair (rtgt , rsrc)
would be inconsistent ITgt if the dashed T-link pointed from t
to rtgt instead of rsrc , i.e., t →T rtgt . In industrial practice, this
situation usually occurs when a new test case has been added
after reusing a requirement.
Inconsistency IISrc.
Figure 10b depicts inconsistency
IISrc in reuse pair (rtgt , rsrc). We clearly see that (rtgt , rsrc)
is consistent ISrc and ITgt because T(rsrc ) ⊆ T(rtgt ) and
T(rtgt ) ⊆ T(rsrc ). However, inconsistency IISrc for (rtgt , rsrc) is
caused by the dashed T-link from t to r′src . From the perspective
of the reuse pair (rtgt , rsrc), test case t is T-linked with the
requirement r′src , which has no reuse pair partner and thus not
has been reused.
Inconsistency IITgt.
The reuse pair (rtgt , rsrc) in Figure
10b is inconsistent IISrc. It would be inconsistent IITgt if the
dashed T-link pointed from t to a newly added r′tgt instead of
r′src , which has not been reused.
Inconsistency IISrc ∧ IITgt. Figure 10c depicts reuse pair
(rtgt , rsrc), which is inconsistent IISrc and IITgt. Again, the
reuse pair is consistent ISrc and ITgt. Test case t is T-linked
with r′src and r′tgt , which are not a reuse pair. The left dashed
T-link causes inconsistency IISrc, and the right dashed link
causes inconsistency IITgt.
Inconsistency IIISrc. Figure 10d depicts two reuse pairs,
(rtgt , rsrc) and (r′tgt , rsrc), which are both consistent ISrc and
ITgt. The source requirement rsrc has been split into two target
requirements rtgt and r′tgt . Test case t has been T-linked with
both target requirements. Inconsistency IIISrc occurs because
source requirement rsrc is partner of both reuse pairs.
Inconsistency IIITgt.
Figure 10d depicts IIITgt if test
case t was T-linked with all requirements of two reuse pairs,
(rtgt , rsrc) and (rtgt , r′src).
Consistency. Figure 10e depicts two consistently T-linked
reuse pairs, (rtgt , rsrc) and (r′tgt , r′src). Interestingly, inconsis-
tency IISrc∧IITgt from Figure 10c has been removed by adding
the R-link r′src →R r′tgt . However, this is not a general solution,
since both requirements are not necessarily partner of a reuse
pair. However, this situation can still be used as an indicator
to ﬁnd forgotten R-links.
RT-Inconsistencies in the ﬁeld.
After laying the theo-
retical foundation for an analysis of RT-instances and RT-
inconsistencies, we can now present the results of two ﬁeld
studies, thus showing the practical relevance of our RT-linking
technique via real speciﬁcation documents.
Inkonsistenz I_Q
t 
rtgt 
rsrc 
(a) Inconsistency ISrc
Inkonsistenz II_
t 
rtgt 
rsrc 
r´src 
(b) Inconsistency IISrc
Inkonsistenz II_
t 
r´tgt 
rtgt 
rsrc 
r´src 
(c) Inconsistency IISrc ∧ IITgt
Inkonsistenz III
t 
r´tgt 
rtgt 
rsrc 
(d) Inconsistency IIISrc
t 
r´tgt 
rtgt 
rsrc 
r´src 
(e) Consistency I ∧ II ∧ III
Source requirement 
Target requirement 
Test case 
(f) Legend
Figure 10: (In)Consistency examples

479
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
VI.
RT-LINKING: FIELD STUDIES
From an industry perspective, the biggest advantage of the
RT-linking is linking speed. However, the ﬁeld studies will not
focus on showing that automatic linking takes minutes instead
of days (compared with manual linking). Instead, the primary
goal is to show that RT-Linking is accurate.
A. Primary goal and preparation of the ﬁeld study
RT-Linking is effective when it produces the same links
as the current manual linking. Furthermore, the RT-linking is
even more effective than the manual linking when it produces
more T-links with fewer RT-inconsistencies.
Approach.
In the past, RT-problems have been solved
manually. We unsolve these historically solved RT-problems
by removing all T-links that point to the target requirements.
Next, we solve the RT-problems by RT-linking them again.
The manually and automatically solved RT-problems will then
be compared to assess the success of this ﬁeld study.
Preparation. We were able to conduct these ﬁeld studies
in an industrial environment on real speciﬁcation documents
linked in an RT manner in IBM DOORS. These docu-
ments describe a historic linking situation between SRSSrc,Hist,
SRSTgt,Hist and STSHist of a past vehicle series’ requirements
and test reuse:
•
The SRSSrc,Hist contains source requirements.
•
The SRSTgt,Hist reuses SRSSrc,Hist.
•
The STSHist contains test cases which point to
SRSSrc,Hist and SRSTgt,Hist.
The goal of the ﬁeld studies is to show that automatic linking
produces the same or even more T-links than the current
manual linking. To achieve this, the historic documents were
copied, including all links. After, all T-links between the copied
STSRT and the copied SRSTgt,RT were removed. Thus, all
documents only contained unsolved RT-problems:
•
The SRSSrc,RT is an unchanged copy of SRSSrc,Hist.
•
The SRSTgt,RT is a copy of SRSTgt,Hist. The copied
SRS’s have the same reuse pairs as the historical
SRS’s.
•
The STSRT is a copy of STSHist without any T-links
into SRSTgt,RT. The T-links into SRSSrc,RT remain.
Preparation: Special case. Before analysis of the overall
linking situation can begin, we needed to reset all T-links
which cause target inconsistencies. In the historic linking
situation those T-links reﬂected new test cases which were
T-linked with the SRSTgt,Hist but not with the SRSSrc,Hist. We
wanted the historic situation and the situation after the RT-
linking to be comparable in terms of target inconsistencies.
Therefore, we copied the T-links of all test cases which
exclusively veriﬁed SRSTgt,Hist into SRSTgt,RT. Those new
test cases would have also been T-linked after RT-linking the
artefacts from the copied documents.
Execution. In order to compare the historic and automatic
overall linking situations, all unsolved RT-problems were
solved by automatically RT-linking them.
B. System A from vehicle series 1 to vehicle series 2
Figure 11 shows RT-diagrams to visualize the historic and
RT-linking situation for a small-sized interior system.
Examination of the peripheral regions.
RT-linking
solves RT-problems. Because only the centre of the diagram
represents RT-problems, automatic linking does not change
most of the peripheral regions. Both diagrams show 16 source
(
) and 58 target (
) requirements without R- and T-
links. Both diagrams contain 100 reuse pairs without T-links
(
). Because the RT-linking does not change the T-links
into the SRSSrc, both diagrams show 39 source requirements
without R-links but with 77 T-links (
). In the ﬁeld studies
preparations we reset all exclusive T-links into the SRSTgt.
Thus, both diagrams contain one target requirement without
R-links but with 25 T-links (
). Both diagrams show that 75
test cases have no T-links into the SRSSrc (
Src ). Only one
peripheral region distinguishes the historic from the RT-linking
situation: While 49 test cases have no T-links into SRSTgt,Hist,
only 47 test case have no T-links into SRSTgt,RT (
Tgt ). This
is a ﬁrst clue that RT-linking is more efﬁcient than the historic
procedure.
Examination of the diagram centres.
The diagram
centres reveal that, historically, 70 RT-problems have been
solved consistently while the RT-linking led to 74 consistently
solved RT-problems. The following more detailed examination
addresses this observation.
100 
16 
39:77 
58 
1:25 
49 
70:96:96 
65:112 
:107 
2:2:10 
75 
(a) Historic RT-diagram
100 
16 
39:77 
58 
1:25 
47 
74:104:104 
61:104 
:105 
2:2:10 
75 
(b) RT-diagramm after RT-linking
Figure 11: Overall linking situations

480
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Detailed look at the inconsistencies. Table I represents
the (in)consistently solved RT-problems within the diagram
centres. The Hist. situation column represents the historic
centre regions, while the WvT linking column stands for the
centre regions of the RT-linking. The numbers R : TSrc : TTgt
represent the count of reuse pairs (R), the count of T-links to
the source requirements of the counted reuse pairs (TSrc) and
the count of T-links to the target requirements (TTgt). Because
R-links are a new concept they have been set automatically by
matching document internal unique IDs of SRSSrc and SRSTgt.
Thus, inconsistency III can not appear within the scope of the
ﬁeld study.
RT-diagrams and Table I.
To increase the reliability
of the ﬁeld studies, two independent DXL scripts (DXL:
Doors eXtension Language) were implemented. The ﬁrst script
calculates the numbers for the RT-diagram, while the second
script calculates the numbers in Table I. The plausibility of the
results is assured via the following rules: The numbers in the
upper part of the diagram centres are the same as in row 0 of
the table. The lower right region of the RT-diagram centres
corresponds to the sum of the numbers in rows 2, 8 and 10.
The lower left diagram centre’s numbers correspond to the sum
of all other table rows.
Table I: (In)consistencies in the diagram centers
(In)Consistency
Hist. situation
RT-linking
0: consistent
70:96:96
74:104:104
1: ISrc
1:5:4
-
2: ITgt
2:2:10
2:2:10
3: ISrc ∧ ITgt
-
-
4: IISrc
56:92:92
57:94:94
5: ISrc ∧ IISrc
4:5:0
-
6: ITgt ∧ IISrc
1:2:3
1:2:3
7: ISrc ∧ ITgt ∧ IISrc
-
-
8: IITgt
-
-
9: ISrc ∧ IITgt
-
-
10: ITgt ∧ IITgt
-
-
11: ISrc ∧ ITgt ∧ IITgt
-
-
12: IISrc ∧ IITgt
3:8:8
3:8:8
13: ISrc ∧ IISrc ∧ IITgt
-
-
14: ITgt ∧ IISrc ∧ IITgt
-
-
15: ISrc∧ITgt∧IISrc∧IITgt
-
-
RT-linking is effective.
RT-linking is effective if at
least the same test cases are automatically T-linked with
SRSTgt,RT as historically were T-linked with SRSTgt,Hist. First,
the effectiveness is shown by the test cases not T-linked in
the lower peripheral regions of both RT-diagrams. A simple
for loop over all those test cases conﬁrms that each test case
which was not T-linked automatically was also not T-linked
historically. Because fewer test cases have no T-links into
SRSTgt,RT after the RT-linking, the following statement is
true: No test cases exist which have historical T-links into
SRSTgt,Hist but no automatically set T-links into SRSTgt,RT.
Thus, the RT-linking is effective. A second for loop over all
RT-instances in Table I conﬁrms that each solved RT-problem
in the Hist. situation column is also contained in the RT-
linking column with the same or more T-links. Because at least
the same T-links exist, RT-linking is effective. The existence
of more T-links already indicates that RT-linking is even more
effective than the current linking procedure.
RT-linking is even more effective.
RT-linking is more
effective than the current procedure if more test cases are T-
linked and fewer RT-inconsistencies appear. A look at the
diagram centres reveals that after the automatic RT-linking,
47 test cases do not point into the SRSTgt,RT. Thus, two fewer
test cases are not T-linked in comparison to the historic linking
situation. Given that the linking is effective, this leads to the
conclusion that the RT-linking is even more effective than
the current procedure. A further look at Table I conﬁrms that
more consistently solved RT-problems exist after the automatic
linking. Row 0 of Hist. situation counts 70 reuse pairs. The
source and target requirements of those 70 reuse pairs each
count 96 consistent T-links. After the automatic RT-linking, 74
reuse pairs were counted. The source and target requirements
are connected consistently with test cases for every 104 T-
links. In conclusion, RT-linking results in more T-links and
less RT-inconsistencies. Thus, RT-linking is more effective
than the current manual procedure.
Origin of new consistencies. Thus far the ﬁeld study has
revealed that the proposed method solves more RT-problems
consistently. The comparison of the centres of the two RT-
diagrams showed that the upper centre region shows four
additional consistently solved RT-problems, while the lower
left centre region shows four fewer inconsistently solved RT-
problems. Row 0 of Table I validated the plausibility of the
observations. Now a question arises: From where did these
new consistencies originate? We answer this question in the
following sections by analysing the inconsistency transitions
shown in Table II.
Transition rules (TR).
Each reuse pair was analysed
twice: once historically and once after the RT-linking. There-
fore, we know, which inconsistency a reuse pair had in both
cases. This enables us to compare the inconsistency transitions
of each reuse pair. In the following, we will identify which
inconsistency transitions exist and give examples for each tran-
sition that occurred. First, a summary of the four inconsistency
rules: Consistency remains, inconsistency ISrc is eliminated,
inconsistency IISrc remains or is eliminated, inconsistencies
ITgt and IITgt remain. These rules can describe all observed
inconsistency transitions.

481
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
TR1: Consistency remains.
This ﬁrst transition rule
says that each historic RT-pair which is consistent, remains
consistent after RT-linking it automatically with test cases.
This was the case for all 70 consistent RT-pairs.
TR2: Inconsistency ISrc is eliminated. RT-linking elim-
inates inconsistency ISrc by deﬁnition, because it transitively
sets T-links between source and target requirements. Tables
I and II conﬁrm the elimination of ISrc, because they never
contain inconsistencies with an odd number after the RT-
linking (because ISrc denotes 20).
TR3: Inconsistency IISrc remains or is eliminated. IISrc
can become consistent if an inconsistency IISrc occurs, because
an inconsistency ISrc occurred at another point. Otherwise IISrc
remains. In Table II, historic inconsistencies IISrc remained
(4 ⇒ 4, 6 ⇒ 6, 12 ⇒ 12) or were eliminated (4 ⇒ 0, 5 ⇒ 0)
by the RT-linking.
TR4: Inconsistencies ITgt and IITgt remain. To enable a
comparison between SRSTgt,Hist and SRSTgt,RT in preparation
of the ﬁeld study, all exclusive T-links into SRSTgt,Hist were
also set exclusively to SRSTgt,RT. Exclusively means that
the T-link points into SRSTgt but not into SRSSrc. Target
inconsistencies ITgt and IITgt caused by this show that new
test cases have been T-linked with the SRSTgt. Because the
linking of new test cases does not impact RT-linking, all target
inconsistencies remain. Table II conﬁrms this (2 ⇒ 2, 6 ⇒ 6,
12 ⇒ 12).
Table II: Inconsistency transitions from Hist to RT
Hist. ⇒ RT-linking
#Transitions
0 ⇒ 0
(consistent ⇒ consistent)
70
1 ⇒ 0
(ISrc ⇒ consistent)
1
2 ⇒ 2
(ITgt ⇒ ITgt)
2
4 ⇒ 0
(IISrc ⇒ consistent)
1
4 ⇒ 4
(IISrc ⇒ IISrc)
55
5 ⇒ 0
(ISrc ∧ IISrc ⇒ consistent)
2
5 ⇒ 4
(ISrc ∧ IISrc ⇒ IISrc)
2
6 ⇒ 6
(ITgt ∧ IISrc ⇒ ITgt ∧ IISrc)
1
12 ⇒ 12 (IISrc ∧ IITgt ⇒ IISrc ∧ IITgt)
3
Transition examples. To improve the reader’s understand-
ing of inconsistency transitions, an example will be presented
for each row in Table II. The following ﬁgures show real but
anonymised transitions. Therefore, some inconsistency transi-
tions appear isolated in a single example while other examples
contain multiple transitions. The ﬁgure on the left hand side
always represents the historically solved RT-problem(s), while
the right hand ﬁgure always shows the same RT-problem(s),
only automatically RT-linked.
Transition: Consistency remains (0 ⇒ 0).
All source
and target requirements in Figure 12 build a reuse pair: (A, a),
(B, b). The test case t is T-linked with all partners of all reuse
pairs. Thus, TR1 applies and consistency remains.
t 
B 
A 
a 
b 
t 
B 
A 
a 
b 
Figure 12: 0 ⇒ 0
Transition: ISrc is eliminated (1 ⇒ 0). Figure 13 shows
the reuse pair (A, a). On the left hand side the dashed T-link
t →T a causes the historic RT-problem to remain unsolved.
This implies inconsistency ISrc. The deﬁnition of the RT-
linking does not allow such situations. Rule TR2 applies and
the T-link t →T A exists after performing the RT-linking.
t 
A 
a 
t 
A 
a 
Figure 13: 1 ⇒ 0
Transition: ITgt remains (2 ⇒ 2). Figure 14 depicts the
reuse pair (A, a). Because t →T A originates from the new test
case t, t →T a does not exist. This causes inconsistency ITgt,
which remains according to TR4.
t 
A 
a 
t 
A 
a 
Figure 14: 2 ⇒ 2
Transition: IISrc remains (4 ⇒ 4). Figure 15 depicts the
reuse pair (B, b) and source requirement a, which has not been
reused. Inconsistency IISrc is caused by t →T a because t
veriﬁes functionality that does not exist on the target side.
Rule TR3 applies: IISrc cannot be eliminated, because it is not
caused by another inconsistency ISrc.
t 
B 
a 
b 
t 
B 
a 
b 
Figure 15: 4 ⇒ 4

482
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Transition: IISrc is eliminated (4 ⇒ 0).
Figure 16 de-
picts several dependent RT-problems. The reuse pair (C, c) is
consistent ISrc because t is T-linked to both partners. But the
T-links t →T a and t →T b cause (C, c) to be inconsistent IISrc.
Rule TR2 applies. Thus, the inconsistencies ISrc of (A, a) and
(B, b) are eliminated by setting t →T A and t →T B. Rule
TR3 applies: The pair (C, c) is now consistent because ISrc of
(A, a) and (B, b) was the reason for its IISrc.
Transition: ISrc ∧ IISrc becomes consistent (5 ⇒ 0). Fig-
ure 16 shows inconsistency IISrc is eliminated from the per-
spective of (C, c). Because the rules TR2 and TR3 also apply
to the pairs (A, a) and (B, b) their inconsistencies ISrc ∧ IISrc
are eliminated.
t 
C 
B 
a 
b 
c 
A 
t 
C 
B 
a 
b 
c 
A 
Figure 16: 4 ⇒ 0 und 5 ⇒ 0
Transition: ISrc ∧ IISrc becomes IISrc (5 ⇒ 4). Figure 17
depicts the reuse pair (B, b) and source requirement a, which
has not been reused. Rule TR2 applies for (C, c): The missing
T-link t →T B is set via the RT-linking. Inconsistency ISrc for
(B, b) is caused by t →T a. Therefore, ISrc is not eliminated
by RT-linking and TR3 applies: (C, c) remains IISrc.
t 
B 
a 
b 
t 
B 
a 
b 
Figure 17: 5 ⇒ 4
Transition: ITgt ∧ IISrc remains (6 ⇒ 6).
Figure 18
shows reuse pair (B, b) and the source requirement a, which
was not reused. The T-link t →T B causes (B, b) to be
inconsistent ITgt. Rule TR4 forces ITgt to remain. Additionally,
TR3 applies: (C, c) remains IISrc because of t →T a.
Transition: IISrc ∧ IITgt stays (12 ⇒ 12). Figure 18 also
shows the reuse pair (C, c). Again, the T-link t →T a causes
(C, c) to be unresolvably inconsistent IISrc and TR3 applies.
Additionally, TR4 applies and IITgt remains.
t 
C 
B 
a 
b 
c 
t 
C 
B 
a 
b 
c 
Figure 18: 6 ⇒ 6 und 12 ⇒ 12
C. System B from vehicle series 3 to vehicle series 1
The goal of the ﬁrst ﬁeld study was to show that RT-
linking is at least as effective as the current manual procedure.
To support a full and detailed analysis of the results, the ﬁeld
study was performed on a small-sized system A. The second
ﬁeld study serves another purpose: conﬁrmation.
Conﬁrmation. The second ﬁeld study was performed on a
bigger system B, which had ﬁve times more requirements and
test cases than system A. The ﬁeld study was conducted using
the same preparations as the ﬁrst ﬁeld study. All inconsistency
rules were conﬁrmed. No new rules appeared, but more incon-
sistency transitions did. All new transitions can be described
by the four basic inconsistency rules, TR1, TR2, TR3 and TR4.
D. RT-linking: Conclusion
In Section V, we proposed the basic layer of our 3-
layered method to automatically link test cases with reusing
requirements. RT-linking uses the assumption:
IF
a target requirement reuses a source requirement
AND IF
a test case veriﬁes a source requirement
THEN
the test case also veriﬁes the target requirement.
Extension of the SOTA. We gave a short introduction into
research into requirements traceability in Section III. There we
summarized different traceability methods (EBT, RBT, VBT,
...), which automatically create links between requirements and
other artefacts. The proposed RT-linking extends the research
ﬁeld via a new method: Reuse-based Test Traceability (RTT).
Supporting industrial practice. RT-linking did not just
arise from observing industry practice. We also evaluated the
effectiveness of RT-linking under real circumstances with a
DOORS extension plug-in. We conducted a ﬁeld study to
compare the overall linking situation of a set of speciﬁcation
documents after manual linking and automatic RT-linking.
Thanks to its promising results in terms of accuracy, this
plug-in has been transferred to industrial practice. In addition
to its accuracy, the complete linking and link analysis of a
SRSTgt now takes a few minutes instead of days or even
weeks of manual link creation and maintenance. However,
it is clear that some of the T-links have to be reviewed
manually. Those T-links which can be established without
review deﬁne the business case for RT-linking. Several pilot
projects showed that these vary between 20% (systems of new
vehicle series with many new/changed requirements) and 90%
(systems of facelifts with little/no changes). Overall we can say
that speciﬁcation documents of future vehicle series projects
will likely be RT-linked.
Outlook: Extension of the RT-linking. The main part of
this paper focused on the primary contribution of this work:
RT-linking. We will now provide an overview of extensions
to RT-linking, as proposed in [1].

483
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
VII.
OUTLOOK: TEST CONCEPT-DRIVEN FILTERING
RT-linking is the ﬁrst method layer. It solves the RT-
problem. However, real world testing necessitates further con-
siderations. Systematic test planning satisﬁes both ISO 26262
and testing efﬁciency. Therefore, we introduce an augmenta-
tion to the RT-problem’s test case.
Augmentation to the RT-problem.
Test goals (What
purpose?), test levels (When?) and test platforms (Where?)
of the Test Concept [Section II-D] are used to determine
the testing expenses. These test planning dimensions describe
a three dimensional testing expenses cube for each vehicle
function. The conﬁguration of each cube deﬁnes the testing
expenses for a vehicle function and thus also for their reﬁning
requirements. Figure 19 depicts the RT-problem, which is
augmented with classifying test case properties. Each test case
aims to meet speciﬁc test goals, is executed during speciﬁc test
levels and is run on speciﬁc test platforms. These classifying
test case properties are identical to the test planning dimensions
of the testing expenses cube. Figure 19 depicts the concept
behind the Test Concept-driven Filtering. Test case t is linked
with target requirement rtgt if the classifying properties of t
ﬁt the conﬁguration of the cube. In this context, new RT-
inconsistencies arise, for example: (1) If a test case meets
more test goals than demanded by the cube for the vehicle
function then too many test goals are met. Thus, the testing is
not minimally efﬁcient. (2) If the test cube demands more test
goals then all T-linked test cases put together, then too few
test goals will be met. As a result, the testing is not complete.
t 
rtgt 
rsrc 
Figure 19: Test planning dimensions of the RT-problem
Extension of RT-linking.
Test Concept-driven Filtering
extends RT-linking as follows:
IF
a target requirement reuses a source requirement
AND IF
a test case veriﬁes a source requirement
THEN
the test case also veriﬁes the target requirement
according to the Test Concept.
This second method layer has been proposed in [34].
Further, the ﬁltering technique has been implemented in
DOORS DXL. It is currently being evaluated in an industrial
environment.
VIII.
OUTLOOK: CASE-BASED FILTERING
In the second method layer, we only augmented the test
case of the RT-problem in order to connect it with the Test
Concept. The third layer eliminates this unused potential by
fully augmenting the RT-problem. In this way, we facilitate
similarity between RT-problems.
Full augmentation of the RT-problem. Figure 19 depicts
the test case augmentation with classifying test case properties.
Figure 20 depicts the additional augmentation with classifying
requirements properties. These requirements and test properties
can be deﬁned freely, e.g., ASIL ranking, interfaces, require-
ments maturity, OEM or supplier status, test case derivation
method, ownership, etc. By virtue of the R-link between
requirements, property changes can be detected from source
to target in relation to the test properties. As the following
example illustrates, this presents countless possibilities. We
assume that the owner of a source requirement and a T-linked
test case is Thomas. Further, we assume that the owner of
the target requirement has changed to Jonathan. Case-based
Filtering allows us to detect such situations. The detection
mechanism adapts the retrieval techniques of Case-based rea-
soning as follows: An RT-case is structurally identical to an
RT-problem, except for an additional RT-decision and review
note. More precisely, Figure 20 does not depict an RT-problem
but an RT-case. We use a similarity function to assess the
similarity of the classifying properties between an RT-problem
and an RT-case. Thus, we not only detect similar RT-problems
for a given RT-case, but also adapt the RT-decision and review
note to solve the RT-problem.
t 
rtgt 
rsrc 
Figure 20: Classifying properties of the RT-problem
Extension of RT-linking.
Case-based Filtering extends
RT-linking as follows:
IF
a target requirement reuses a source requirement
AND IF
a test case veriﬁes a source requirement
THEN
the test case also veriﬁes the target requirement
according to the RT-Case-basis.
A prototype of the third layer has been implemented in
DOORS DXL. An initial presentation sparked the interest of
requirements and test engineers.

484
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
IX.
CONCLUSIONS AND FUTURE WORK
In this paper, we proposed RT-linking, the main technique
of our 3-layered method, to automatically solve the RT-
problem. RT-problems occur after requirements reuse (R) but
before test reuse (T). The main goal is to reuse test cases on
the basis of requirements reuse.
Comprehensive requirements reuse.
We proposed a
new trace link type: The Reuse- or R-link, which connects
reusing target requirements with reused source requirements.
These R-links facilitate comprehensive reuse traceability as
demanded by ISO 26262 [3, p.20]. By virtue of R-links we
are able to systematically distinguish between new or discarded
requirements and requirements which have been reused with
or without modiﬁcation.
Comprehensive test speciﬁcation.
Test cases are trace
linked with requirements by Test- or T-links to facilitate test
traceability according to ISO 26262 [2, p.25]. These T-links
are inﬂuenced by the requirements reuse; reuse of requirements
implies reuse of test cases. In this paper, we proposed transitive
RT-linking to set T-links automatically from test cases to
reusing target requirements on the basis of previously T-linked
source requirements. Thanks to the promising results from
the ﬁeld studies, RT-linking has been transferred to industrial
practice.
Comprehensive test planning and decisions. Although
this paper focused on the ﬁrst method layer, we gave a short
overview of the second and third method layers. Both layers
provide additional ﬁlter techniques to improve the RT-linking
technique. The second layer arranges RT-linking according to
test planning, while the third layer deﬁnes and uses similarity
between RT-problems to reuse link decisions.
Rotate and tilt the RT-problem. Outside of industrial ap-
plication, an interesting idea has arisen. We used requirements,
test cases and speciﬁc link types to describe the RT-problem.
However, it could be much more general than this if we used
abstract artefacts and abstract link types instead. V-Models are
usually characterized by many different trace linked artefacts.
As well as requirements and test cases, systems, components,
safety cases, architecture, feature models, functional models
and code also exist, among others. Even the SOTA often
relies on holistic traceability models [Section III-A]. Future
work could focus on the interesting question of whether a
general RT-problem is able to support a traceability model by
successively rotating or tilting it through the V-Model, each
followed by a general RT-linking step.
X.
ACKNOWLEDGEMENTS
We thank our DCAITI colleagues Quang Minh Tran, Jonas
Winkler and Martin Beckmann for discussions and proof
reading. Furthermore, we thank our Daimler colleagues for
positively impacting our concepts and implementations with
respect to relevance, feasibility and usability.
REFERENCES
[1]
T. Noack, “Automatic Linking of Test Cases and Requirements,” in
Proceedings of the 5th International Conference in System Testing and
Validation Lifecycle (VALID), Venice, Italy, 2013, pp. 45–48.
[2]
Road Vehicles - Functional Safety, Part 8: Supporting processes (ISO
26262-8:2011), International Organization for Standardization, 2011.
[3]
Road Vehicles - Functional Safety, Part 6: Product Development:
Software Level (ISO 26262-6:2011), International Organization for
Standardization, 2011.
[4]
A. Spillner and T. Linz, Basiswissen Softwaretest, 4th ed.
Heidelberg:
dpunkt.verlag, 2005.
[5]
Software Engineering - Product Quality, Part 1: Quality Model (ISO
9126-1:2001), European Committee for Standardization and Interna-
tional Organization for Standardization, 2005.
[6]
R. Watkins and M. Neal, “Why and How of Requirements Tracing,”
IEEE Software, vol. 11, no. 4, 1994, pp. 104–106.
[7]
J. Cleland-Huang, O. Gotel, and A. Zisman, Software and Systems
Traceability, 1st ed.
Springer, 2012.
[8]
F. A. C. Pinheiro, “Requirements Traceability,” in Perspectives on
Software Requirements, 1st ed., J. C. S. do Prado Leite and J. H. Doorn,
Eds.
Kluwer Academic Publishers, 2004, ch. 5, pp. 91–113.
[9]
K. Pohl and P. Haumer, “HYDRA: A Hypertext Model for Struc-
turing Informal Requirements Representations,” in Proceedings of the
2nd International Workshop on Requirements Engineering (REFSQ),
K. Pohl and P. Peters, Eds. Jyv¨askyl¨a, Finnland: Verlag der Augustinus-
Buchhandlung, 1995, pp. 118–134.
[10]
E. Horowitz and R. C. Williamson, “SODOS : A Software Documen-
tation Support Environment - Its Deﬁnition,” IEEE Transactions on
Software Engineering, vol. 12, no. 8, 1986, pp. 849–859.
[11]
J. Conklin and M. L. Begeman, “glBIS : A Hypertext Tool for Team
Design Deliberation,” in Proceedings of the ACM Conference on
Hypertext.
Chapel Hill, NC, USA: ACM Press, 1987, pp. 247–251.
[12]
B. Ramesh and V. Dhar, “Supporting Systems Development by Cap-
turing Deliberations During Requirements Engineering,” IEEE Trans-
actions on Software Engineering, vol. 18, no. 6, 1992, pp. 498–510.
[13]
H. Kaindl, “The Missing Link in Requirements Engineering,” ACM
SIGSOFT Software Engineering Notes, vol. 18, no. 2, 1993, pp. 30–
39.
[14]
F. A. C. Pinheiro and J. A. Goguen, “An Object-Oriented Tool for Trac-
ing Requirements,” in Proceedings of the 2nd International Conference
on Requirements Engineering.
Colorado Springs, CO, USA: IEEE
Computer Society Press, 1996, pp. 52–64.
[15]
T. Tsumaki and Y. Morisawa, “A Framework of Requirements Tracing
using UML,” in Proceedings of 7th Asia-Paciﬁc Software Engineering
Conference (APSEC).
Singapur, Singapur: IEEE Computer Society
Press, 2000, pp. 206–213.
[16]
P. Letelier, “A Framework for Requirements Traceability in UML-Based
Projects,” in Proceedings of 1st International Workshop on Traceability
in Emerging Forms of Software Engineering, Edinburgh, Schottland,
2002, pp. 30–41.
[17]
M. Narmanli, “A Business Rule Approach to Requirements Traceabil-
ity,” Masterarbeit, Middle East Technical University, 2010.
[18]
B. Turban, M. Kucera, A. Tsakpinis, and C. Wolff, “Bridging the Re-
quirements to Design Traceability Gap,” Intelligent Technical Systems,
Lecture Notes in Electrical Engineering, vol. 38, 2009, pp. 275–288.
[19]
S. Ibrahim, M. Munro, and A. Deraman, “Implementing a Document-
Based Requirements Traceability: A Case Study,” in Proceedings of
International Conference on Software Engineering, P. Kokol, Ed. Inns-
bruck, ¨Osterreich: ACTA Press, 2005, pp. 124–131.
[20]
H. U. Asuncion, F. Francois, and R. N. Taylor, “An End-To-End
Industrial Software Traceability Tool,” in Proceedings of the 6th Joint
Meeting of the European Software Engineering Conference and the
ACM SIGSOFT Symposium on The Foundations of Software Engi-
neering.
Dubrovnik, Kroatien: ACM, 2007, pp. 115–124.
[21]
A. Azmi and S. Ibrahim, “Implementing Test Management Traceability
Model to Support Test Documents,” International Journal of Digital
Information and Wireless Communications (IJDIWC), vol. 1, no. 1,
2011, pp. 109–125.

485
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[22]
J. MacMillan and J. R. Vosburgh, “Software Quality Indicators,” Sci-
entiﬁc System Inc., Cambridge MA., Tech. Rep., 1986.
[23]
DOORS (Dynamic Object Oriented Requirements System) , IBM, 2013.
[24]
S. Rochimah, W. M. N. Wan Kadir, and A. H. Abdullah, “An Eval-
uation of Traceability Approaches to Support Software Evolution,” in
International Conference on Software Engineering Advances (ICSEA
2007).
Cap Esterel, Frankreich: IEEE Computer Society, Aug. 2007,
pp. 19–38.
[25]
R. Torkar, T. Gorschek, R. Feldt, M. Svahnberg, U. A. Raja, and
K. Kamran, “Requirements Traceability: A Systematic Review and
Industry Case Study,” International Journal of Software Engineering
and Knowledge Engineering, vol. 22, no. 3, 2012, pp. 385–433.
[26]
J. Cleland-Huang, C. K. Chang, and M. Christensen, “Event-Based
Traceability for Managing Evolutionary Change,” IEEE Transactions
on Software Engineering, vol. 29, no. 9, 2003, pp. 796–810.
[27]
G. Spanoudakis, A. Zisman, E. P´erez-Minana, and P. Krause, “Rule-
Based Generation of Requirements Traceability Relations,” Journal of
Systems and Software, vol. 72, no. 2, Jul. 2004, pp. 105–127.
[28]
M. Riebisch, “Supporting Evolutionary Development by Feature Models
and Traceability Links,” in 11th IEEE International Conference and
Workshop on the Engineering of Computer-Based Systems (ECBS).
Brno, Tschechien: IEEE Computer Society Press, 2004, pp. 370–377.
[29]
M. Heindl and S. Bifﬂ, “A Case Study on Value-Based Requirements
Tracing,” in Proceedings of the 10th European Software Engineering
Conference held jointly with 13th ACM SIGSOFT International Sym-
posium on Foundations of Software Engineering.
Lissabon, Portugal:
ACM Press, 2005, pp. 60–69.
[30]
A. Egyed and P. Gr¨unbacher, “Supporting Software Understanding
with Automated Requirements Traceability,” International Journal of
Software Engineering and Knowledge Engineering, vol. 15, no. 5, 2005,
pp. 783–810.
[31]
J. Cleland-Huang, R. Settimi, O. BenKhadra, E. Berezhanskaya, and
S. Christina, “Goal-Centric Traceability for Managing Non-Functional
Requirements,” in Proceedings of the 27th International Conference on
Software Engineering (ICSE). St. Louis, MO, USA: ACM Press, 2005,
pp. 362–371.
[32]
R. Oliveto, M. Gethers, D. Poshyvanyk, and A. De Lucia, “On the
Equivalence of Information Retrieval Methods for Automated Traceabil-
ity Link Recovery,” in 18th IEEE International Conference on Program
Comprehension (ICPC).
Minho, Portugal: IEEE Computer Society
Press, Jun. 2010, pp. 68–71.
[33]
A. Cmyrev, R. N¨orenberg, D. Hopp, and R. Reissing, “Consistency
Checking of Feature Mapping between Requirements and Test Arte-
facts,” Concurrent Engineering Approaches for Sustainable Product
Development in a Multi-Disciplinary Environment, vol. 1, no. 1, 2013,
pp. 121–132.
[34]
T. Noack, “Automatische Verlinkung von Testf¨allen und Anforderungen:
Testplangesteuerte Filterung,” Softwaretechnik-Trends, vol. 33, no. 4,
2013, pp. 5–6.
[35]
SimMetrics (Open Source library with numerous algorithms to calculate
textual similarity between two texts), Source Forge, 2014.

