Linear Constraints as a Modeling Language for Discrete Time Hybrid Systems
Federico Mari, Igor Melatti, Ivano Salvo, and Enrico Tronci
Department of Computer Science – Sapienza University of Rome
Via Salaria 113, 00198 Rome, Italy
Email: {mari,melatti,salvo,tronci}@di.uniroma1.it
Abstract—Model Based Design is particularly appealing in
embedded software design where system level speciﬁcations are
much easier to deﬁne than the control software behavior itself.
Formal analysis of Embedded Systems requires modelling both
continuous systems (typically, the plant) as well as discrete
systems (the controller). This is typically done using Hybrid
Systems. Mixed Integer Linear Programming (MILP) based
abstraction techniques have been successfully applied to au-
tomatically synthesize correct-by-construction control software
for Discrete Time Linear Hybrid System, where plant dynamics
is modeled as a linear predicate over state, input, and next
state variables. MILP solvers requires constraints represented
as conjunctive predicates. In this paper we show that, under the
hypothesis that each variable ranges over a bounded interval,
any linear predicate built upon conjunction and disjunction
of linear constraints can be automatically transformed into an
equisatisﬁable conjunctive predicate. Moreover, since variable
bounds play a key role in this transformation, we present an
algorithm that taking as input a linear predicate, computes
implicit variable bounds.
Keywords-Model-based software design; Linear predicates;
Hybrid systems
I. INTRODUCTION
Many Embedded Systems are Software Based Control
Systems (SBCSs). An SBCS consists of two main subsys-
tems: the controller and the plant. Typically, the plant is
a physical system consisting, for example, of mechanical
or electrical devices, while the controller consists of con-
trol software running on a microcontroller. In an endless
loop, each T seconds (sampling time), the controller, after
an Analog-to-Digital (AD) conversion (quantization), reads
sensor outputs from the plant and, possibly after a Digital-to-
Analog (DA) conversion, sends commands to plant actuators.
The controller selects commands in order to guarantee that
the closed loop system (that is, the system consisting of
both plant and controller) meets given safety and liveness
speciﬁcations (System Level Speciﬁcations).
Software generation from models and formal speciﬁca-
tions forms the core of Model Based Design of embedded
software [1]. This approach is particularly interesting for
SBCSs since in such a case system level speciﬁcations are
much easier to deﬁne than the control software behavior
itself. Correct-by-construction software generation as well as
formal veriﬁcation of system level speciﬁcations for SBCSs
requires modelling both the continuous subsystem (the plant)
and discrete systems (the controller). This is typically done
using Hybrid Systems (e.g., see [2][3]).
Discrete Time Linear Hybrid Systems (DTLHSs) [4][5]
provide an expressive model for closed loop systems: a
DTLHS is a discrete time hybrid system whose dynamics
is deﬁned as a linear predicate (i.e., a boolean combination
of linear constraints) on its continuous as well as discrete
(modes) variables. A large class of hybrid systems, including
mixed-mode analog circuits, can be modeled using DTLHSs.
System level safety as well as liveness speciﬁcations are
modeled as set of states deﬁned, in turn, as linear predicates.
In [6], stemming from a constructive sufﬁcient condition
for the existence of a quantized sampling controller for an
SBCS modelled as a DTLHS, we presented an algorithm
that, given a DTLHS model H for the plant, a quantization
schema (i.e., how many bits we use for AD conversion) and
system level speciﬁcations, returns correct-by-construction
quantized feedback control software (if any) meeting the
given system level speciﬁcations. The synthesis algorithm
rests on the fact that, because of the quantization process,
the plant P is seen by the controller as a Nondeterministic
Finite State Automaton (NFSA) ˆP, that is an abstraction
of P. The NFSA ˆP is computed by solving Mixed Integer
Linear Programming (MILP) problems, and thus it requires
the DTLHS dynamics given as a conjunctive predicate, i.e.,
a conjunction of linear constraints.
This paper is motivated by circumventing such a limita-
tion, by showing that, under the hypothesis that each variable
ranges over a bounded interval, any linear predicate can be
represented by an equivalent conjunctive predicate.
Bounds on variables that describe DTLHS behaviour is
a reasonable hypothesis. Usually, control software drives
the plant towards a goal, while keeping it inside a given
bounded admissible region. Bounds on present state vari-
ables essentially model the sensing region, that is the range
of values observable by the sensors, that usually is a bounded
rectangular region (i.e., the Cartesian product of bounded
intervals). Bounds on controllable input variables model the
actuation region, that is the range of values of commands
that the actuators may send to the plant and it is also
typically a bounded rectangular region. Non-state variables
may model both non-observable plant state variables and
uncontrollable inputs (i.e., disturbances). Therefore, bounds
on such variables are usually implied by bounds on state
variables or by reasonable assumptions about disturbances.
1) Our Main Contributions: In this paper we give an
algorithm to transform any linear predicate into an equi-
satisﬁable conjunctive predicate, under the hypothesis that
each variable ranges over a bounded interval. This allows a
MILP based abstraction technique to be applied on a wider
class of DTLHSs (Section III) with respect to [6].
We consider predicates built upon linear constraints (i.e.,
inequalities of the shape Pn
i=1 aixi ≤ b, Section II),
664
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

conjunctions and disjunctions. First, we show that, at the
price of introducing fresh boolean variables, a predicate
can be transformed into an equisatisﬁable guarded predicate
(Section IV), that is a conjunction of guarded constraints,
i.e., constraints of the shape y → (Pn
i=1 aixi ≤ b). Then,
assuming that each variable ranges over a bounded interval,
we show that any guarded constraint can be in turn trans-
formed into a conjunctive predicate, i.e., a conjunction of
linear constraints (Section IV-A). Conjunctive predicates are
the input language of MILP solvers. Finally, in Section V,
we give an algorithm that computes bounds for a variable x
in a given guarded predicate G(X), i.e., either it returns
two values mx, Mx ∈ R such that if G(X) holds, then
mx ≤x≤Mx, or it concludes that such values do not exist.
An evaluation of such algorithm is in Sections VI and VII.
A. Related Work
Mixed Integer Linear Programming (MILP) solving based
abstraction techniques have been designed for the veriﬁ-
cation of Discrete Time Hybrid Automata (DHA) [4] and
implemented within the symbolic model checker HYSDEL
[7]. A MILP based DTLHS abstraction algorithm is the
core of automatic control software synthesis from system
level speciﬁcations in [6], and it requires DTLHS dynamics
modeled as a conjunctive predicate. The same limitation oc-
curs in abstraction techniques based on the Fourier-Motzkin
procedure for existential quantiﬁer elimination [8].
The automatic procedure that we present here to transform
any linear predicate into an equisatisﬁable conjunctive predi-
cate is reminiscent of Mixed Integer Programming modeling
techniques [9] in Operations Research and boolean formula
transformations involved in the conversion of a formula into
a conjunctive or disjunctive normal form [5][10].
Finally, an automatic convertion procedure targeting a
MILP formulation for automatic synthesis of schedules is
presented in [11], where the starting point is a deterministic
ﬁnite automaton rather than a linear predicate.
II. BASIC DEFINITIONS
An initial segment {1, . . . , n} of N is denoted by [n]. We
denote with X = x1, . . . , xn a ﬁnite sequence of distinct
variables, that we may regard, when convenient, as a set.
Each variable x ranges on a known (bounded or unbounded)
interval Dx either of the reals (continuous variables) or of
the integers (discrete variables). The set Q
x∈XDx is denoted
by DX. Boolean variables are discrete variables ranging on
the set B = {0, 1}. If x is a boolean variable we write ¯x
for (1−x). The sequence of continuous (discrete, boolean)
variables in X is denoted by Xr (Xd, Xb).
The set of sequences of n boolean values is denoted by
Bn. The set Bn
k ⊆Bn denotes sequences that contains exactly
k elements equal to 1. Given a, b∈Bn we say that a≤b if
a is point-wise less or equal to b, i.e., if for all i ∈ [n] we
have that ai ≤bi. Given a set B ⊆Bn and a∈Bn we write
a≤B if there exists b∈B such that a≤b and a≥B if there
exists b∈B such that a≥b. We denote with J(b) be the set
of indexes such that bj =1, i.e., J(b)={j ∈[n] | bj =1}.
A. Predicates
A linear expression L(X) = Pn
i=1aixi is a linear
combination of variables in X with rational coefﬁcients.
A constraint is an expression of the form L(X) ≤ b,
where b is a rational constant. We write L(X) ≥ b for
−L(X)≤−b, L(X)=b for (L(X)≤ b) ∧ (−L(X)≤−b),
and a≤L(X)≤b for (L(X)≤b) ∧ (L(X)≥a).
Predicates are inductively deﬁned as follows. A constraint
C(X) is a predicate over X. If A(X) and B(X) are
predicates, then (A(X) ∧ B(X)) and (A(X) ∨ B(X)) are
predicates over X. Parentheses may be omitted, assuming
usual associativity and precedence rules of logical operators.
A conjunctive predicate is a conjunction of constraints.
A valuation over X is a function v that maps each variable
x ∈ X to a value v(x) in Dx. We denote with X∗ ∈ DX
the sequence of values v(x1), . . . , v(xn). Given a predicate
P(Y, X), P(Y, X∗) denotes the predicate obtained by sub-
stituting each occurrence of x with v(x). We call valuation
also the sequence of values X∗. A satisfying assignment to
a predicate P(X) is a valuation X∗ such that P(X∗) holds.
We denote with P also the set of satisfying assignments to
the predicate P. P(X) and Q(X) are equivalent, notation
P ≡Q, if they have the same set of satisfying assignments.
P(X) and Q(Z) are equisatisﬁable, notation P ≃ Q, if P
is satisﬁable if and only if Q is satisﬁable.
B. Mixed Integer Linear Programming
A Mixed Integer Linear Programming (MILP) prob-
lem with decision variables X is a tuple (max, J(X),
A(X)) where X is a list of variables, J(X) (objective
function) is a linear expression over X, and A(X) (con-
straints) is a conjunctive predicate over X. A solution to
(max, J(X), A(X)) is a valuation X∗ such that A(X∗)
and ∀Z (A(Z) → (J(Z) ≤ J(X∗))). J(X∗) is the optimal
value of the MILP problem. A feasibility problem is a MILP
problem of the form (max, 0, A(X)). We write also A(X)
for (max, 0, A(X)). In algorithm outlines, MILP solver
invocations are denoted by function feasible(A(X)) that re-
turns TRUE if A(X) is satisﬁable and FALSE otherwise, and
by function optimalValue(max, J(X), A(X)) that returns
either the optimal value of the MILP problem (max, J(X),
A(X)) or ∞ if such MILP problem is unbounded. We write
(min, J(X), A(X)) for (max, −J(X), A(X)).
III. DISCRETE TIME LINEAR HYBRID SYSTEMS
Discrete Time Linear Hybrid Systems (DTLHSs) provide
a suitable model for many embedded control systems since
they can effectively model linear algebraic constraints in-
volving both continuous as well as discrete variables. In
Ex. 1, we present a DTLHS model of a buck DC-DC con-
verter, i.e., a mixed-mode analog circuit that converts the
DC input voltage to a desired DC output voltage.
Deﬁnition 1: A Discrete Time Linear Hybrid System is a
tuple H = (X, U, Y, N) where:
X = Xr ∪ Xd is a ﬁnite sequence of real and discrete
present state variables. X′ denotes the sequence of next state
variables obtained by decorating with ′ variables in X.
665
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

R
C
rC
D
iD
L
u
+vu
+vD
iC
+vO
Vi
iL
rL
iu
+vC
Figure 1.
Buck DC-DC converter
U = U r ∪ U d is a ﬁnite sequence of input variables.
Y = Y r ∪ Y d is a ﬁnite sequence of auxiliary variables.
Auxiliary variables typically models modes (switching ele-
ments) or uncontrollable inputs (e.g., disturbances).
N(X, U, Y, X′) is a predicate over X∪U∪Y ∪X′ deﬁning
the transition relation (next state) of the system.
Example 1: The buck DC-DC converter is a mixed-mode
analog circuit (Figure 1) converting the DC input voltage (Vi
in Figure 1) to a desired DC output voltage (vO in Figure
1). Buck DC-DC converters are used off-chip to scale down
the typical laptop battery voltage (12-24) to the just few
volts needed by the laptop processor as well as on-chip to
support Dynamic Voltage and Frequency Scaling (DVFS) in
multicore processors. Because of its widespread use, control
schemes for buck DC-DC converters have been widely stud-
ied (e.g., see [12][13][14]). The typical software based ap-
proach is to control the switch u in Figure 1 (typically imple-
mented with a MOSFET) with a microcontroller. The circuit
in Figure 1 can be modeled as a DTLHS H=(X, U, Y, N).
The circuit state variables are iL and vC. However we can
also use the pair iL, vO as state variables in H model since
there is a linear relationship between iL, vC and vO, namely:
vO = rCR
rC+RiL+
R
rC+RvC. Such considerations lead us to the
following DTLHS model H: X =Xr =iL, vO, U =U d =u,
Y =Y r∪Y d where Y r =iu, vu, iD, vD and Y d =q. Note how
H auxiliary variables Y stem from the constitutive equations
of the switching elements (i.e., the switch u and the diode D
in Figure 1). From a simple circuit analysis (e.g., see [15])
we have the following equations:
˙iL
=
a1,1iL + a1,2vO + a1,3vD
(1)
˙vO
=
a2,1iL + a2,2vO + a2,3vD
(2)
where the coefﬁcients ai,j depend on the circuit parameters
R, rL, rC, L and C as follows: a1,1 = − rL
L , a1,2 = − 1
L,
a1,3 =− 1
L, a2,1 =
R
rc+R[− rcrL
L + 1
C ], a2,2 =
−1
rc+R[ rcR
L + 1
C ],
a2,3 =− 1
L
rcR
rc+R. Using a discrete time model with sampling
time T and writing x′ for x(t + 1), we have:
i′
L
=
(1 + Ta1,1)iL + Ta1,2vO + Ta1,3vD
(3)
v′
O
=
Ta2,1iL + (1 + Ta2,2)vO + Ta2,3vD.
(4)
The algebraic constraints stemming from the constitutive
equations of the switching elements are the following:
vD
=
vu − Vi (5)
iD
=
iL − iu
(6)
(u = 1) ∨ (vu = Roﬀiu) (7)
(u = 0) ∨ (vu = 0)
(8)
((iD ≥ 0) ∧ (vD = 0)) ∨ ((iD ≤ 0) ∧ (vD = RoﬀiD))
(9)
The transition relation N of H is given by the conjunction
of the constraints in Eqs. 3–9.
IV. FROM LINEAR TO CONJUNCTIVE PREDICATES
As shown in [6], MILP solvers can be used to build a
suitable discrete abstraction of a DTLHS. As mentioned in
Section II-B, MILP solvers require constraints represented
as conjunctive predicates. In this section, we show how this
limitation can be circumvented. We proceed in two steps.
First, in Section IV, we introduce guarded predicates and
we show that each predicate can be transformed into an
equivalent guarded predicate at the price of introducing new
auxiliary boolean variables. Then, in Section IV-A, we show
that, under the hypothesis that each variable ranges over
a bounded interval, each guarded predicate can be in turn
transformed into an equivalent conjunctive predicate.
1) Guarded Predicates:
Deﬁnition 2: Given a predicate P(X) and a fresh boolean
variable z ̸∈ X, the predicate z → P(X) (resp. ¯z → P(X))
denotes the predicate (z =0)∨P(X) (resp. (z =1)∨P(X)).
We call z the guard variable and both z and ¯z guard literals.
If P(X) is a constraint C(X), a predicate of the form
z → C(X) or ¯z → C(X) is called guarded constraint.
A generalized guarded constraint a predicate of the form
z1 → (z2 → . . . → (zn → C(X)). . .) A guarded predicate
(resp. generalized guarded predicate) is a conjunction of
either constraints or guarded constraints (resp. generalized
guarded constraints).
To simplify proofs and notations, without loss of general-
ity, we always assume guard literals distinct: a conjunction
z → C1(X) ∧ z → C2(X) is equisatisﬁable to the guarded
predicate z1 →C1(X)∧z2 →C2(X)∧z1 =z ∧z2 =z (z1, z2
fresh boolean variables). Moreover, in algorithm outlines,
conjunctive predicates will be regarded as sets of constraints.
By applying standard propositional equivalences, we have
the following facts.
Fact 1: A predicate of the form z → V
i∈[n] Pi(X) is
equivalent to the guarded predicate V
i∈[n](z →Pi(X)).
Fact 2: A generalized guarded constraint z1 → (z2 →
. . . → (zn → C(X)). . .) is equisatisﬁable to the guarded
predicate (z−P
i∈[n] zi ≥1 − n) ∧ (z →C(X)), where z is
a fresh boolean variable.
Proof: Let z be a fresh boolean variable. We have:
z1 →(z2 →. . .→(zn →C(X)). . .)
≡ z1 ∧ z2 ∧ . . . ∧ zn →C(X)
≃ (z1 ∧ z2 ∧ . . . ∧ zn →z) ∧ (z →C(X))
≡ (¯z1 ∨ ¯z2 ∨ . . . ∨ ¯zn ∨ z) ∧ (z →C(X))
≡ (1−z1)+(1−z2)+. . .+(1−zn)+z ≥1 ∧ (z →C(X))
≡ (z−P
i∈[n] zi ≥1−n) ∧ (z →C(X))
Lemma 3: Any predicate P(X) is equisatisﬁable to a pred-
icate Q(X, Z) = G(X, Z) ∧ D(Z), where G and D are
generalized guarded predicates and Z is the set of boolean
variables that occur positively as guards in G.
Proof: By induction on the structure of the predicate
P(X). If P(X) is a constraint or a conjunction, the state-
ment easily follows from inductive hypothesis.
Let P(X) be the disjunction P1(X) ∨ P2(X). By induc-
tive hypothesis, there exist two generalized guarded predi-
cates Q1(X, Z1) = G1(X, Z1) ∧ D1(Z1) and Q2(X, Z2) =
666
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

G2(X, Z2) ∧ D2(Z2) such that P1(X) ≃ Q1(X, Z1) and
P2(X)≃Q2(X, Z2). We can always choose auxiliary boolean
variables in such a way that Z1 ∩ Z2 =∅.
Taken two fresh boolean variables y1 and y2, the predicate
y1 → Q1(X, Z1) ∧ y2 → Q2(X, Z2) ∧ y1 +y2 ≥ 1 is equi-
satisﬁable to P(X). The predicate y1 →Q1(X, Z1) has the
form y1 →(V
i∈[n]Gi
1(X, Z1)∧V
j∈[p]Dj
1(Z1)) and therefore
it is not a generalized guarded constraint. By Fact 1, it
is equivalent to the predicate V
i∈[n](y1 → Gi
1(X, Z1)) ∧
V
j∈[p](y1 → Dj
1(Z2)). By applying Fact 1 also to y2 →
Q2(X, Z2), the statement follows by taking Z =Z1 ∪ Z2 ∪
{y1, y2}, G(X, Z) = V
i∈[n]y1 → Gi
1(X, Z1) ∧ V
i∈[m]y2 →
Gi
2(X, Z2), and D(Z) = V
j∈[p]y1 → Dj
1(Z2) ∧V
j∈[q]y2 →
Dj
2(Z2) ∧ (y1+y2 ≥1)
Proposition 4: Any predicate P(X) is equisatisﬁable to
a predicate Q(X, Z) = G(X, Z′) ∧ D(Z), where G and D
are guarded predicates and Z′ ⊆ Z is the set of boolean
variables that occur positively as guards in G.
Proof: By Lemma 3, any predicate P(X) is equisatisﬁ-
able to a generalized guarded predicate G1(X, Z1)∧D1(Z1).
By Fact 2, D1(Z1) is equisatisﬁable to a guarded predicate
D2(Z1, Z2). Let G1(X, Z1) = V
i∈[n]zi
1 → (zi
2 → . . . →
(zi
ni → Ci(X)) . . .) ∧ G′
1(X, Z3), where G′
1(X, Z3) is a
guarded predicate (Z3 ⊆ Z1). By Fact 2 G1(X, Z1) is eq-
uisatisﬁable to the guarded predicate V
i∈[n]wi → Ci(X) ∧
V
i∈[n](wi − P
j∈[ni] zi
j ≥ 1 − ni) ∧ G′(X, Z3). The state-
ment follows by taking Z′ = Z3 ∪ {w1, . . . , wn}, Z = Z′ ∪
Z1 ∪ Z2, G(X, Z)=V
i∈[n](zi →Ci(X)) ∧ G′′(X, Z′), and
D(X, Z)=V
i∈[n](zi−P
j∈[ni] zi
j ≥1−n) ∧ D′′(Z′, Z′′)
The function PtoG (Alg. 2) summarizes the predicate trans-
formations given in the proof of Prop. 4. It calls function
PtoGG (Alg. 1) that performs predicate transformations given
in the proof of Lemma 3. The function fresh( ) returns at
each invocation a (globally) fresh variable.
Algorithm 1 From predicates to generalized guarded pred.
Input: P predicate over X
Output: ⟨G, D, Z⟩ where G is a general. guarded predicate,
Z is the set of its (fresh) guard variables,
D(Z) is a generalized guarded predicate over Z
function PtoGG(P, X)
1. if P is a constraint C(X) then return ⟨C(X), ∅, ∅⟩
2. let P = P1 ⋄ P2
(⋄ ∈ {∧, ∨})
3. ⟨G1, D1, Z1⟩ ←PtoGG(P1)
4. ⟨G2, D2, Z2⟩ ←PtoGG(P2)
5. if P = P1∧P2 then return ⟨G1∪G2, D1∪D2, Z1∪Z2⟩
6. if P = P1 ∨ P2 then
7.
y1 ←fresh( ), y2 ←fresh( ), Z′ ←Z1 ∪ Z2 ∪ {y1, y2}
8.
D′={y1 →γ|γ ∈D1}∪{y2 →γ|γ ∈D2}∪{y1+y2 ≥1}
9.
G′ = {y1 → γ | γ ∈ G1} ∪ {y2 → γ | γ ∈ G2}
10.
return ⟨G′, D′, Z′⟩
Example 2: Let H be DTLHS in Ex. 1. Given the pred-
icate N that deﬁnes the transition relation of H, function
PtoG computes the following guarded predicate equisatisﬁ-
able to N. Constraints 3–6 remain unchanged, as they are
linear constraints in a top-level conjunction. The disjunction
9 is replaced ﬁrst by the following predicates:
z1 →(iD ≥0 ∧ vD =0) (10)
z2 →(iD ≤0 ∧ vD =RoﬀiD) (11)
and then by constraints 13–16 below, obtained by moving
arrows inside the conjunctions, as shown by Fact 1. Simi-
larly, disjunctions 7 and 8 are eliminated by introducing four
boolean fresh variables. Summing up, disjunctions 7–9 in
Example 1 are replaced by the conjunction of the following
(guarded) constraints:
z4 →(vu =Roﬀiu) (12)
z2 →(vD =RoﬀiD) (13)
z1 →(iD ≥0) (14)
z1 →(vD =0) (15)
z1 →(iD ≤0) (16)
z3 →(u=1) (17)
z5 →(u=0) (18)
z6 →(vu =0) (19)
z1+z2 ≥1 (20)
z3+z4 ≥1 (21)
z5+z6 ≥1 (22)
With respect to the statement of Proposition 4, we have that
Z = {z1, z2, z3, z4, z5, z6}, G(X, Z′) is the conjunction of
guarded constraints 12–19 and original constraints 3–6, and
D(Z) is the conjunction of constraints 20–22.
Algorithm 2 From linear to guarded predicates
Input: P predicate over X
Output: ⟨G, D, Z′, Z⟩ where G is a guarded predicate,
Z′ ⊆ Z set of its guard variables,
D(Z) is a guarded predicate over Z
function PtoG(P, X)
1. ⟨G, D, Z⟩ ←PtoGG(P, X)
2. G′ ← ∅, D′ ← ∅, Z′ = ∅
3. for all γ ∈ G ∪ D do
4.
if γ ≡ z1 →(. . .→(zn →C(W)) . . .) then
5.
w←fresh( ), Z ←Z ∪ {w}
6.
if W ⊆X then G′ ←G′ ∪ {w→C(W)}
7.
else D′ ←D′ ∪ {w→C(W)}
8.
D′ ← D′ ∪ {w − P
i∈[n] zi ≥ 1 − n}
9.
else if vars(γ)⊆X then
10.
G′ ←G′ ∪ {γ} else D′ ←D′ ∪ {γ}
11. return ⟨G′, D′, Z′, Z \ Z′⟩
A. From Guarded to Conjunctive Predicates
Deﬁnition 3: Let P(X) be a predicate. A variable x∈X
is said to be bounded in P if there exist a, b∈Dx such that
P(X) implies a≤x≤b. A predicate P is bounded if all its
variables are bounded. We write sup(P, x) and inf(P, x) for
the minimum and maximum value that the variable x may
assume in a satisfying assignment for P. When P is clear
from the context, we will write simply sup(x) and inf(x).
Given a bounded predicate P(X), a real number a, and
a variable x ∈ X we write sup(ax) for a sup(x) if a ≥ 0
and for a inf(x) if a < 0. We write inf(ax) for a inf(x) if
a ≥ 0 and for a sup(x) if a < 0. Given a linear expression
L(X) = Pn
i=1aixi over a set of bounded variables, we
write sup(L(X)) for Pn
i=1sup(aixi) and inf(L(X)) for
Pn
i=1inf(aixi).
Proposition 5: Each bounded guarded predicate P(X) is
equivalent conjunctive predicate Q(X).
667
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Proof: The conjunctive predicate Q(X) can be obtained
from the guarded predicate P(X) by replacing each guarded
constraint ϕ of the shape z →(L(X)≤b) in P(X) with the
constraint ϕ′ = (sup(L(X))−b)z+L(X) ≤ sup(L(X)). If
z =0 we have ϕ≡ϕ′ since ϕ holds trivially and ϕ′ reduces
to L(X) ≤ sup(L(X)) that holds by construction. If z = 1
both ϕ and ϕ′ reduce to L(X)≤b. Along the same line of
reasoning, if ϕ has the form ¯z →(L(X)≤b) we pick ϕ′ to
be (b−sup(L(X)))z+L(X)≤b.
Together with Prop. 4, Prop. 5 implies that any bounded
predicate can be transformed into an equisatisﬁable conjunc-
tive predicate, at the cost of adding new auxiliary boolean
variables, as stated in the following proposition.
Proposition 6: For each bounded predicate P(X), there
exists an equisatisﬁable conjunctive predicate Q(X, Z).
Example 3: Let H be the DTLHS in Examples 1 and 2.
We set the parameters of H as follows:
rL =0.1Ω
R=5Ω
Vi =15V
L=2 · 10−4H
rC =0.1Ω
Roﬀ =104
T =10−6secs
C =5 · 10−5F
and we assume variables bounds as follows:
−2·104 ≤vu ≤15
−4≤iL ≤4
−1≤vO ≤7 −4≤i′
L ≤96
−2·104 ≤vD ≤0 −1.1≤v′
O ≤17 −4≤iu ≤4 −2≤iD ≤4
By ﬁrst decomposing equations of the shape L(X) = b in
the conjunctive predicate L(X)≤b ∧ −L(X)≤−b and then
by applying the transformation given in the proof of Prop. 5,
guarded constraints 14–19 are replaced by the following
linear constraints:
2z1 − iD ≤ 2 (23)
4 · 104z4 + vu − 104iu ≤ 4 · 104 (24)
6 · 104z4 − vu + 104iu ≤ 6 · 104 (25)
−2.104z1 − vD ≤ 2 · 104 (26)
2.104z2 + vD − 104iD ≤ 2.104 (27)
6.104z2 − vD + 104iD ≤ 6.104 (28)
2 · 104z6 + vu ≤ 15 (29)
2 · 104z4 − vu ≤ 2 · 104 (30)
vD ≤ 0
(31)
4z2 + iD ≤ 4
(32)
z5 + u ≤ 1
(33)
−u ≤ 0
(34)
15z6 + vu ≤ 15
(35)
z3 − u ≤ 1
(36)
u ≤ 1
(37)
V. COMPUTING VARIABLE BOUNDS
In this section, we present an algorithm that checks if a
variable x is bounded and that computes an over- and under-
approximation of sup(x) and inf(x).
Given a guarded predicate G(X, Z), where Z is the set of
guard variables, for any valuation Z∗, G(X, Z∗) is equiva-
lent to a conjunctive predicate (Prop. 7). A naïve algorithm
to ﬁnd bounds for a variable x for any valuation Z∗ solves
the MILP problems optimalValue(x, max, G(X, Z∗)) and
optimalValue(x, min, G(X, Z∗)). If, for all Z∗ ∈ Bn, x is
bounded in G(X, Z∗) or G(X, Z∗) is unfeasible, then x
is bounded in G(X, Z). Vice versa, if for some Z∗ ∈ Bn
G(X, Z∗) is feasible and x is not bounded, then x is not
bounded in G(X, Z). Unfortunately, this exhaustive proce-
dure requires to solve 2|Z| MILP problems.
The function computeBounds in Alg. 3 reﬁnes such idea
in order to save unnecessary MILP invocations. If all guard
literals are positive, if an assignment Z∗
1 makes true more
guards than an assignment Z∗
2, then the conjunctive predicate
G(X, Z∗
1) has more constraints than G(X, Z∗
2) and therefore
if x is bounded in G(X, Z∗
2) then it is also bounded in
G(X, Z∗
1), and if G(X, Z∗
2) is unfeasible, then also G(X, Z∗
1)
is unfeasible (Prop. 7). In the following we establish the
correctness of function computeBounds.
Proposition 7: Let Z = z1, . . . , zn and let G(X, Z) =
V
i∈[n](zi →Ci(X)) be a conjunction of guarded constraints,
where head variables occurs positively. Then:
1) For any Z∗ ∈Bn, G(X, Z∗) is equivalent to the con-
junctive predicate V
j∈J(Z∗)Cj(X).
2) If Z∗
1 ≤ Z∗
2, then G(X, Z∗
2)⇒G(X, Z∗
1).
Proof: Statement 1 easily follows by observing that a
guarded constraint z → C(X) is trivially satisﬁed if z is
assigned to 0 and it is equivalent to C(X) if z is assigned
to 1. Statement 2 follows from the observation that a ≤ b
implies J(a)⊆J(b) and hence G(X, b) has more constraints
than G(X, a).
Deﬁnition 4: We say that a set C ⊆ Bn is a cut if for all
b ∈ Bn we have b ≤ C or b ≥ C. Let D(Z) be a predicate
over a set boolean variables Z =Z1∪Z2 and let |Z2|=n. A
cut C ⊆Bn is (D, Z2)-minimal, if for all c∈C D(Z1, c) is
satisﬁable, and for all b<C D(Z1, b) is not satisﬁable.
To verify that a variable is bounded G(X, Z′) ∧ D(Z),
where G is a guarded predicate with positive guards in the
set Z′ ⊆Z and D(Z) is a conjunctive predicate, it sufﬁces to
check if it is bounded in the conjunctive predicate G(X, c),
for all c that belong to a (D, Z′)-minimal cut.
Algorithm 3 Computing variable bounds in predicate
Input: ⟨G, D, X, Z′, Z, x⟩ where G is a guarded predicate,
Z′ ⊆ Z set of its guard variables, x∈X a variable,
D(Z) is a conjunctive predicate over Z
Output: ⟨b, inf, sup⟩, where b ∈ {B, ¬B, ¬F}.
If b = B, G(X, Z) ⇒ inf ≤ x ≤ sup
function computeBounds(G, D, X, Z′, Z′′, x)
1. C ←∅, r←|Z′|, inf ←+∞, sup←−∞, f ←FALSE
2. r′ ←optimalValue(min, P
i∈[r] zi, D(Z))
3. r′′ ←optimalValue(max, P
i∈[r] zi, D(Z))
4. for k = r′ to r′′ do
5.
end = TRUE
6.
for all b ∈ Br
k do
7.
if C ̸≤b then end ← FALSE else continue
8.
if feasible(D(Z, c)) then C
Proof: Since C is a (D, Z′)-minimal cut, any satisfying
assignment (X∗, Z∗) to Q is such that C ≤ Z′∗. As a
consequence, there exists c∈C such that c≤Z′∗. Prop. 7.2
implies that max{x | G(X, Z∗)} ≤ max{x | G(X, c)} and
min{x | G(X, Z∗)}≥min{x | G(X, c)}. Therefore if x is
bounded in Q(X, c) for any c ∈ C, then it is bounded in
Q(X, Z).
Stemming from Proposition 8, function computeBounds
(Alg. 3) checks if a variable x is bounded in a guarded pred-
icate by ﬁnding a minimal cut. To limit the search space, in
line 2 (resp. line 3) it is computed the minimum (resp. maxi-
mum) number of 1 that a satisfying assignment to the predi-
cate D(Z) must have. The loop in lines 4–16 examines pos-
sible assignments to guard variables in Z, keeping the invari-
ant ∀b<C¬feasibleG(X, b) ∧ ∀b≥C max{x | G(X, Z)}≤
max{x | G(X, b)}∧min{x | G(X, Z∗)}≥min{x | G(X, b)}.
In the loop in lines 6–14, if the assignment c under consid-
eration is greater than an assignment in C, no further inves-
tigation are needed (by Prop. 8 x is bounded in Q(X, c)). If
D(Z\Z′, b) is unfeasible, the assignment c is not relevant,
because c≤C, for any (D, Z′)-minimal cut C. Otherwise, c
is a relevant assignment and it is added to C (line 8). If x is
unbounded in Q(X, c) (lines 11 and 13) we can immediately
conclude that x is unbounded in Q(X, Z). Otherwise, we
update the approximations computed for inf(x) and sup(x)
(line 14). If for all assignments in c ∈ Bn
k we have c ≥ C
(Bn
k is a cut) we are done, C is a (D, Z′)-minimal cut, and
inf and sup computed so far are over-approximation of x
bounds in Q(X, Z) (line 15).
Algorithm 4 From predicates to conjunctive predicates
Input: P predicate over X
Output: ⟨b, C⟩, b ∈ {B, ¬B, ¬F}.
If b = B, then C ≃ P
function PtoC((P, X))
1. ⟨G, D, Z′, Z′′⟩ ←PtoG(P, X)
2. D′ ←GtoC(D, Z′ ∪ Z′′, ⟨0, 1⟩)
3. for all x ∈ X do
4.
⟨µ, mx, Mx⟩ ←computeBounds(G, D′, X, Z′, Z′′, x)
5.
if µ ̸=BOUNDED then return ⟨µ, ∅⟩
6. return ⟨µ,GtoC(G, X ∪ Z′ ∪ Z′′, ⟨m, M⟩)
Example 4: In Ex. 3 we assumed bounds for each vari-
able in the DTLHS H introduced in Example 1. Such bounds
has been obtained by ﬁxing bounds for state variables iL and
vO and for variables vD and iD, and by computing bounds
for variables i′
L, v′
O, iu, and vu using Alg. 3.
The function PtoC in Alg. 4 presents the overall procedure
that transforms a bounded predicate into an equisatisﬁable
conjunctive predicate. It calls functions in Algs. 1–3 and
the function GtoC that performs predicate transformations
given in the proof of Prop. 5. As a ﬁrst step, Alg. 4 translates
a predicate P(X) into an equisatisﬁable guarded predicate
G(X, Z′) ∧ D(Z′, Z′′) by calling the function PtoG. Since
boolean variables are trivially bounded (bounds are vectors
0 = ⟨0, . . . , 0⟩ and 1 = ⟨1, . . . , 1⟩), the guarded predicate
D can be transformed into a conjunctive predicate D′ by
calling the function GtoC on D. To apply function GtoC on
G(X, Z′), we need bounds for each variable in X. These
bounds are computed by calling |X| times the function com-
puteBounds and are stored in the two arrays m, M. If the
function computeBounds ﬁnds that G′ is unfeasible or some
x is not bounded in G′, the empty constraint is returned
together with the failure explanation. Otherwise, the desired
conjunctive predicate is returned.
VI. MODELING ISSUES
The disjunction elimination procedure given in Alg. 4
returns a guarded predicate that may contain a large number
of fresh auxiliary boolean variables and this may heavily
impact on the effectiveness of control software synthesis
or veriﬁcation. On the other hand, guarded predicates are
themselves a natural language to describe DTLHS behavior:
assignments to guard variables play a role similar to modes
in hybrid systems and, by using negative literals as guards,
we can naturally model different kinds of plant behavior
according to different commands sent by actuators.
Example 5: Disjunctions 7–9 in Ex. 1 can be replaced by
the conjunction of the following (guarded) constraints:
q →vD =0 (38)
q →iD ≥0 (39)
u→vu =0 (40)
¯q →vD ≤0 (41)
¯q →vD =RoﬀiD
(42)
¯u→vu =Roﬀiu
(43)
The resulting model for the buck DC-DC converter is
much more succinct than the guarded model in Ex. 2 and it
has two guard variables only, rather than six as in Ex. 2.
Alg. 3 cannot be directly applied to guarded predicates
with both positive and negative guard literals. This obstruc-
tion can be easily bypassed, by observing that a guarded
constraint ¯z → C(X) can is equisatisﬁable to the guarded
predicate (z′ → C(X)) ∧ (z′ +z = 1). This transformation
may double the number of guard variables and hence make
the application of Alg. 3 less effective than an exhaustive
algorithm on the original model with positive and negative
guard literals (see experimental results in Section VII). Sum-
ming up, guarded predicates turn out to be a powerful and
natural modeling language for describing DTLHS transition
relations. We end this section by proposing a syntactic check,
that most of the time may be used to compute variable
bounds avoiding to use the function computeBounds.
Deﬁnition 5: A variable x is explicitly bounded in a pred-
icate P(X), if P(X) = B(x) ∧ P ′(X), where B(x) = x ≤
b ∧ x≥a, for some constants a and b.
Proposition 9: Let H = (X, U, Y, N) be a DTLHS such
that each variable v∈X ∪U ∪Y is explicitly bounded in N,
and for all x′ ∈X′ there are in N at least two constraints of
the form x′ ≥ L1(X, U, Y ) and x′ ≤ L2(X, U, Y ). Then N
is bounded.
Proof: Since all variables in X, U, and Y are explic-
itly bounded in N, they are also bounded in N. Therefore
inf(L1(X, U, Y )) and sup(L2(X, U, Y )) are ﬁnite. Since N
is guarded, it is a conjunction of guarded constraints and for
all x′ ∈ X′ it can be written as x′
1 ≥ L1(X, U, Y ) ∧ x′
1 ≤
L2(X, U, Y ) ∧ N ′(X, U, Y, X′) for a suitable predicate N ′.
669
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

This implies inf(L1(X, U, Y )) ≤ x′ ≤ sup(L2(X, U, Y )),
which in turn implies that x′ is bounded in N.
Example 6: Let H1 be the DTLHS ({x}, {u}, ∅, N1),
where N1(x, u, x′)=(0≤x≤3)∧(0≤u≤1)∧(x′ = x+3u).
By Proposition 9, H1 is bounded with inf(x′) = 0 and
sup(x′)=6. All other variables are explicitly bounded in N.
Explicit bounds on present state and input variables do not
imply that next state variables are bounded. As an example,
let us consider the DTLHS H2 = ({x}, {u}, ∅, N2), where
N2(x, u, x′) = (0 ≤ x ≤ 3) ∧ (0 ≤ u ≤ 1) ∧ (x′ ≥ x+3u).
Since, for any value of x and u, x′ can assume arbitrary
large values, we have that H2 is not bounded.
VII. EXPERIMENTAL RESULTS
In this section, we evaluate the effectiveness of our predi-
cate transformation algorithm PtoC. We implemented Alg. 4
in C programming language, using GLPK to solve MILP
problems. We present the experimental results obtained by
using PTOC on a n-inputs buck DC-DC converter, that we
model with three DTLHSs Hi =(Xi, Ui, Yi, Ni), with i∈[3],
s.t. X1 = X2 = X3, U1 = U2 = U3, Y1 ⊂ Y2 ⊂ Y3, N1 is a
predicate (Section II-A), N2 and N3 are guarded predicates
(Section IV) and guards in N3 are positive only.
We then run PTOC on Hi for increasing values of n
(which entails that the number of guards increases), in order
to show effectiveness of PTOC. Namely, in Section VII-A1
we show experimental results for the whole algorithm in
Alg. 4. Furthermore, in Section VII-A2 we show that exploit-
ing knowledge of the system and modeling it with guarded
predicates we obtain better results than those in Section VII-A1.
To this aim, we suppose that predicates G, D′ and variables
sets X, Z′, Z′′ in Alg. 4 may be directly given as an input
to function PtoC (thus lines 1 and 2 in Alg. 4 are skipped).
Both in Section VII-A1 and VII-A2 we compare the com-
putation time of function PtoC against function PtoCexh,
which may be obtained from Alg. 4 by replacing the call to
function computeBounds (our bottleneck here) in line 4 with
the naïve algorithm which exhaustively checks all possible
assignments to guard variables (see Section V). To this aim,
also PtoCexh has been implemented inside PTOC. As for
PtoC, also for PtoCexh it is possible to directly specify
predicates G, D′ and variables sets X, Z′, Z′′.
A. Multi-Input Buck DC-DC Converter
A Multi-Input Buck DC-DC converter [16] (Figure 2),
consists of n power supplies with voltage values V1 <. . .<
Vn, n switches with voltage values vu
1 , . . . , vu
n and current
values Iu
1 , . . . , Iu
n, and n input diodes D0, . . . , Dn−1 with
voltage values vD
0 , . . . , vD
n−1 and current values iD
0 , . . . , iD
n−1
(in the following, we will also write vD for vD
0 and iD for
iD
0 ). As for the converter in Ex. 1, the state variables are
iL and vO, whereas action variables are u1, . . . , un, thus a
control software for the n-input buck dc-dc converter has
to properly actuate the switches u1, . . . , un. Constant values
are the same given in Ex. 3.
R
+vO
L
iD
Vn
Vn−1
Vi
V1
Iun
Iu
n−1
Iu
i
+vun
un
D0
D1
Di
Dn−1
iL
rL
+vC
C
rC
iC
+vu
i
un−1
ui
+vD
...
...
Iu
1
+vD
1
+vD
i
+vu
n−1
+vD
n−1
+vu
1
u1
Figure 2.
Multi-input Buck DC-DC converter
Table I
PTOC PERFORMANCES (PREDICATES)
n
r
r′
r′′
k
|cut|
CPUr
CPUe
2
12
6
12
11
64
1.48e+00
1.13e+02
3
18
9
18
17
512
8.33e+01
1.35e+04
4
24
12
24
23
4096
8.73e+03
>1.38e+06
1) Multi-Input Buck as a Predicate: We model the n-
input buck DC-DC converter with the DTLHS H1 =(X1, U1,
Y1, N1), where X1 = iL, vO, U1 = u1, . . . , un, and Y1 =
vD, vD
1 , . . . , vD
n−1, iD, Iu
1 , . . . , Iu
n, vu
1 , . . . , vu
n. From a sim-
ple circuit analysis (e.g., see [15]), we have that state vari-
ables constraints are the same as Eqs. (3) and (4) of the
converter in Ex. 1. Analogously, as for the algebraic con-
straints, we have that Eq. (9) in Ex. 1 also holds for the
n-inputs converter. In addition to Eqs. (3), (4) and (9) of
Ex. 1, the Eqs. (45)–(48) below must hold.
^
i∈[n]
(ui =0)∨(vu
i =0) (44)
^
i∈[n]
(ui =1) ∨ (vu
i =RoﬀIu
i )
(45)
^
i∈[n−1]
((Iu
i ≥0) ∧ (vD
i =0)) ∨ ((Iu
i ≤0) ∧ (vD
i =RoﬀIu
i )) (46)
iL =iD+
n
X
i=1
Iu
i
(47)
^
i∈[n−1]
vD =vu
i +vD
i −Vi∧vD =vu
n−Vn (48)
N1 also contains the following explicit bounds: −4≤iL ≤
4 ∧ −1 ≤ vO ≤ 7∧ −103 ≤ iD ≤ 103 ∧ Vn
i=1−103 ≤ Iu
i ≤
103 ∧ Vn
i=1 −107 ≤ vu
i ≤ 107 ∧ Vn−1
i=0 −107 ≤ vD
i ≤ 107.
We call function PtoC with parameters N1, X1 ∪ U1 ∪ Y1
for increasing values of n, and we compare its computation
time with that of function PtoCexh. Table I shows our ex-
perimental results. In Table I, column n shows the number
of buck inputs, column r shows the number of guards (see
line 1 of Alg. 3), columns r′, r′′ have the meaning given in
lines 2 and 3 of Alg. 3, column k gives the value of k at the
end of the for loop of Alg. 3, column |cut| gives the size of
cut at the end of the for loop of Alg. 3, and column CPUr
(resp. CPUe) shows the computation time in seconds of
function function PtoC (resp. PtoCexh). Table I shows that
heuristics implemented in function computeBounds greatly
speeds-up variable bounds computation.
2) Multi-Input Buck as a Guarded Predicate: We mod-
ify the DTLHS H1 of Section VII-A1 by deﬁning H2 =
(X2, U2, Y2, N2), where X2 = X1, U2 = U1, Y2 = Y1 ∪
Y ′
2 = Y1 ∪ {q0, . . . , qn−1} and N2 is obtained from N1 by
replacing Eqs. (9) and (45)–(48) with Eqs. (38)–(43) (where
q = q0, see Section VI), and by adding the following ones
(i∈ [n − 1]):
670
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Table II
PTOC PERFORMANCES (GUARDED PREDICATES)
n
r
r′
r′′
k
|cut|
CPUr
CPUe
4
16
8
8
8
256
1.17e+01
1.24e+01
5
20
10
10
10
1024
1.55e+02
6.93e+01
6
24
12
12
12
4096
2.65e+03
3.78e+02
qi →vD
i =0 (49)
qi →Iu
i ≥0 (50)
ui →vu
i =0 (51)
¯qi →vD
i ≤0 (52)
¯qi →vD
i =RoﬀIu
i
(53)
¯ui →vu
i =RoﬀIu
i
(54)
Finally, we deﬁne H3 = (X3, U3, Y3, N3), where X3 =
X2 = X1, U3 = U2 = U1 and N3 is obtained from N2
by eliminating negative guards as described in Section VI.
This introduces 2n additional auxiliary variables to manage
negations of q0, . . . , qn−1, u1, . . . , un, thus Y3 = Y2 ∪ Y ′
3 =
Y2 ∪ {q′
0, . . . , q′
n−1, u′
1, . . . , u′
n}.
For i = 2, 3, let constraints in Ni be partitioned in Gi and
Di s.t. Gi contains all guarded constraints in Ni. We call
function PtoC with parameters G3, D3, X3 ∪ U3 ∪ Y1, Y ′
2 ∪
Y ′
3, ∅ for increasing values of n, and we compare its com-
putation time with that of function PtoCexh with parame-
ters G2, D2, X2 ∪ U2 ∪ Y1, Y ′
2, ∅ Note that G3 only con-
tains positive-guarded constraints, thus it is possible to call
function PtoC on it. On the other hand, G2 also contains
negative-guarded constraints, thus it cannot be passed to
function PtoC, whilst it can be managed by function Pto-
Cexh.
Table II shows our experimental results. Columns mean-
ing in Table II are the same as of Table I. Predicate transla-
tion on the multi-input buck dc-dc model given as guarded
predicate is much faster due to a smaller number of auxiliary
variables (and constraints). The negative impact of auxiliary
boolean variables is clearly showed by the fact that function
PtoCexh, much slower than function PtoC on a model of the
same size, performs better than PtoC in this case, because
it can work on a model with half of the variables. This
phenomenon would be greatly ampliﬁed in a veriﬁcation or
control software synthesis procedure. These results strongly
support guarded predicates as modeling language.
VIII. CONCLUSIONS
The results presented in this paper contribute to Model
Based Design of embedded software by proposing an ex-
pressive modelling language for discrete time linear hybrid
systems. Indeed, MILP based abstraction of a DTLHS have
been used to synthesize correct-by-construction control soft-
ware that implements a quantized controller. They require
DTLHS dynamics modeled as a conjunctive predicate over
state, input, and next state variables.
In this paper, we circumvented such a limitation, by giving
an automatic procedure that transforms any predicate into
an equisatisﬁable conjunctive predicate, provided that each
variable ranges over a bounded interval. Moreover, we have
presented an algorithm that, taking a linear predicate P and
a variable x, veriﬁes if x is bounded in P, by computing
(an over-approximation of) bounds for x.
Finally, our experimental results show the effectiveness
of our algorithms. Most notably, they show that guarded
predicates may turn out to be a natural language to describe
succinctly DTLHS dynamics.
REFERENCES
[1] T. A. Henzinger and J. Sifakis, “The embedded systems
design challenge,” in FM, ser. LNCS 4085, 2006, pp. 1–15.
[2] R. Alur, C. Courcoubetis, N. Halbwachs, T. A. Henzinger,
P. H. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine,
“The algorithmic analysis of hybrid systems,” Theoretical
Computer Science, vol. 138, no. 1, pp. 3 – 34, 1995.
[3] R. Alur, T. A. Henzinger, and P.-H. Ho, “Automatic symbolic
veriﬁcation of embedded systems,” IEEE Trans. Softw. Eng.,
vol. 22, no. 3, pp. 181–201, 1996.
[4] A. Bemporad and M. Morari, “Veriﬁcation of hybrid systems
via mathematical programming,” in HSCC, 1999
[5] F. Mari and E. Tronci, “CEGAR based bounded model
checking of discrete time hybrid systems,” in HSCC, 2007
[6] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “Synthesis of
quantized feedback control software for discrete time linear
hybrid systems,” in CAV, ser. LNCS 6174, 2010, pp. 180–195.
[7] F. Torrisi and A. Bemporad, “HYSDEL — A tool for gener-
ating computational hybrid models for analysis and synthesis
problems,” IEEE Transactions on Control System Technology,
vol. 12, no. 2, pp. 235–249, 2004.
[8] S. K. Jha, B. H. Krogh, J. E. Weimer, and E. M. Clarke,
“Reachability for linear hybrid automata using iterative re-
laxation abstraction,” in HSCC, ser. LNCS 4416, 2007, pp.
287–300.
[9] F. S. Hillier and G. J. Lieberman, Introduction to operations
research.
McGraw-Hill Inc., 2001.
[10] D. Sheridan, “The optimality of a fast cnf conversion and its
use with sat,” in SAT, 2004.
[11] A. Kobetski and M. Fabian, “Scheduling of discrete event
systems using mixed integer linear programming,” in Discrete
Event Systems, 2006
[12] W. Kim, M. S. Gupta, G.-Y. Wei, and D. M. Brooks, “En-
abling on-chip switching regulators for multi-core processors
using current staggering,” in ASGI, 2007.
[13] W.-C. So, C. Tse, and Y.-S. Lee, “Development of a fuzzy
logic controller for dc/dc converters: design, computer simu-
lation, and experimental evaluation,” IEEE Trans. on Power
Electronics, vol. 11, no. 1, pp. 24–32, 1996.
[14] V. Yousefzadeh, A. Babazadeh, B. Ramachandran, E. Alar-
con, L. Pao, and D. Maksimovic, “Proximate time-optimal
digital control for synchronous buck dc–dc converters,” IEEE
Trans. on Pow. El., 23(4), 2008
[15] P.-Z. Lin, C.-F. Hsu, and T.-T. Lee, “Type-2 fuzzy logic
controller design for buck dc-dc converters,” in FUZZ, 2005,
pp. 365–370.
[16] M. Rodriguez, P. Fernandez-Miaja, A. Rodriguez, and J. Se-
bastian, “A multiple-input digitally controlled buck converter
for envelope tracking applications in radiofrequency power
ampliﬁers,” IEEE Trans on Pow. El., 25(2), 2010
671
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

