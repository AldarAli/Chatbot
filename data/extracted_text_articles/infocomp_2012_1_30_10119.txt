Control Software Visualization
Federico Mari, Igor Melatti, Ivano Salvo and Enrico Tronci
Department of Computer Science
Sapienza University of Rome
Via Salaria 113, 00198 Rome, Italy
Email: {mari,melatti,salvo,tronci}@di.uniroma1.it
Abstract—Many software as well digital hardware automatic
synthesis methods deﬁne the set of implementations meeting
the given system speciﬁcations with a boolean relation K
(controller). Such relation, given a system state s and an action
u, returns 1 iff taking action u in state s leads in the system
goal or at least one step closer to it. In order to determine at
hand if K is a “good” controller, e.g., if it covers a wide enough
portion of the system state space, or to provide an high level
view of the actions enabled by K, it is useful to picture K in
a 2D or 3D diagram. In this paper, starting from a canonical
representation for K, we propose an algorithm to automatically
generate such a picture, relying on available graphing tools.
Keywords-Control Software Visualization; Embedded Systems;
Model Checking
I. INTRODUCTION
Many Embedded Systems are indeed Software Based
Control Systems (SBCSs). An SBCS consists of two main
subsystems: the controller and the plant. Typically, the plant
is a physical system consisting, for example, of mechanical
or electrical devices whereas the controller consists of con-
trol software running on a microcontroller. In an endless
loop, the controller reads sensor outputs from the plant and
sends commands to plant actuators in order to guarantee
that the closed loop system (that is, the system consisting
of both plant and controller) meets given safety and liveness
speciﬁcations (System Level Formal Speciﬁcations).
Software generation from models and formal speciﬁca-
tions forms the core of Model Based Design of embedded
software [1]. This approach is particularly interesting for
SBCSs since in such a case system level (formal) speciﬁ-
cations are much easier to deﬁne than the control software
behavior itself.
The typical control loop skeleton for an SBCS is the
following. Measure x of the system state from plant sensors
goes through an analog-to-digital (AD) conversion, yielding
a quantized value ˆx. A function ctrlRegion checks if ˆx
belongs to the region in which the control software works
correctly. If this is not the case, a Fault Detection, Isolation
and Recovery (FDIR) procedure is triggered; otherwise a
function ctrlLaw computes a command ˆu to be sent to
plant actuators after a digital-to-analog (DA) conversion.
Basically, the control software design problem for SBCSs
consists in designing software implementing functions ctr-
lLaw and ctrlRegion.
Figure 1.
Control Software Synthesis Flow.
Automatic methods and tools aiming at synthesizing both
functions ctrlLaw and ctrlRegion above have been devel-
oped in the last years, e.g., in [2][3][4][5][6][7]. In this
paper, we will refer to the method described in [7], but
the approach we describe may be applied to the other ones
as well. Figure 1 shows the model based control software
synthesis ﬂow in [7]. A speciﬁcation consists of a plant
model, given as a Discrete Time Linear Hybrid System
(DTLHS), System Level Formal Speciﬁcations that describe
functional requirements of the closed loop system, and
Implementation Speciﬁcations that describe non functional
requirements of the control software, such as the number
of bits used in the quantization process, the required worst
case execution time, etc. Given such an input, in step 1 a
suitable ﬁnite discrete abstraction (control abstraction [7])
ˆH of the DTLHS plant model H is computed; ˆH depends
on the quantization schema and it is the plant as it can
be seen from the control software after AD conversion.
Then (step 2), given an abstraction ˆG of the goal states
G, it is computed a controller K that starting from any
initial abstract state, drives ˆH to ˆG regardless of possible
nondeterminism. Control abstraction properties ensure that
K is indeed a (quantized representation of a) controller for
the original plant H. Finally (step 3), the ﬁnite automaton
K is translated into control software (C code).
In the following, we represent the control software with
a boolean relation K (controller) taking as input (the n-bits
15
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-226-4
INFOCOMP 2012 : The Second International Conference on Advanced Communications and Computation

encoding of) a state x of the plant and (the r-bits encoding
of) a proposed action to be performed u, and returns true
(i.e., 1) iff the system speciﬁcations are met when perform-
ing action u in state x. In this approach, K is synthesized so
that a given (initial) plant states region I (which is given as
part of the system level formal speciﬁcations) is guaranteed
to be covered by K. That is, for all states x ∈ I, there must
exist at least an action u s.t. K(x, u) holds. Typically, I is
set to be small in order to increase the likelihood that a K
fulﬁlling the above given property exists. However, the set
of states covered by K, i.e., dom(K) = {x | ∃u : K(x, u)}
may result to be much bigger than I. Therefore, once a
K is built, it is useful to have a tool to graphically depict
dom(K), in order to be able to visualize how big the region
dom(K) is, as well as to have a glimpse of which actions
are turned on by K on given plant states regions.
A. Our Main Contributions
In this paper we present an algorithm that, from an OBDD
(Ordered Binary Decision Diagram [14]) representation of
a controller K for a DTLHS modeling an SBCS, effectively
generates a 2D picture (namely, an input ﬁle for Gnuplot [8])
depicting K. Such picture consists on a cartesian plane
where each point corresponds to a state of the starting
DTLHS, and shows as painted with the same color all
regions of states for which the same actions set is deﬁned
on K. The color for a state (x, y) depends on which actions
set is enabled by K in the DTLHS state (x, y), i.e., it is
uniquely determined by c(x, y) = {u | K((x, y), u)}. As a
special case, if c(x, y) = ∅ for some (x, y), i.e., (x, y) is not
controlled by K, then the color is white. A separated picture
showing the relation between a color and the corresponding
actions set is also automatically generated. In this way,
the state region for which any color is shown depicts the
coverage of K, whilest the regions colors give a glimpse of
which actions are turned on by K.
In our setting, since we seek K for which a software
implementation is possible, a ﬁnite number of bits is used to
encode both the states and the actions of the starting DTLHS.
Suppose now that |u| = r, i.e., if r bits are needed in order
to encode an action of the given DTLHS. Then, there may
be at most 22r different actions sets, i.e., |{c(x, y) | (x, y) is
a state}| = 22r. That is, with r = 5 we need 4×109 colors,
which is more than a typical RGB with 8 bits per color may
achieve. Thus, our method may work only up to r = 4. Note
however that this is not a limitation, since typical DTLHSs
do not need more than 3 bits per action. Moreover, for most
systems |{c(x, y) | (x, y) is a state}| << 22r, thus we may
generate the picture even if r ≥ 5.
We present experimental results showing effectiveness of
the proposed algorithm. As an example, in about 1 hour we
are able to generate the pairs of pictures described above for
a multi-input buck DC/DC converter [9] with r = 4 action
bit variables.
B. Paper outline
This paper is organized as follows. Section III provides
the background needed to understand the results of this
paper. Section IV describes our method to generate a picture
visualizing a controller. Section V provides experimental
results. Finally, Section VI summarizes and concludes the
paper.
II. RELATED WORK
Many papers (e.g., see [7][11][12][13]) tackling the prob-
lem of synthesizing control software (which looks to quan-
tized states) or control laws (which looks at real states) of
hybrid systems show pictures of the type we generate in
this paper (with r = 1, i.e., only one bit for the actions).
However, to the best of our knowledge there are no papers
directly focusing on the method to generate such pictures,
thus no automatic approach to controllers visualization is
described.
Therefore, to the best of our knowledge this is the ﬁrst
time that an algorithm generating a picture of the coverage
of a controller for a DTLHS is presented.
III. BASIC DEFINITIONS
To make this paper self-contained, in this section we
brieﬂy summarize previous work on automatic generation
of control software for Discrete Time Linear Hybrid System
(DTLHS) from System Level Formal Speciﬁcations focusing
on basic deﬁnitions and mathematical tools that will be
useful in the sequel.
Figure 1 shows the control software synthesis ﬂow that
we consider here [7]. We model the controlled system (i.e.,
the plant) as a DTLHS (Section III-D), that is a discrete
time hybrid system whose dynamics is modeled as a linear
predicate (Section III-A) over a set of continuous as well as
discrete variables. The semantics of a DTLHS is given in
terms of a Labeled Transition Systems (LTS, Section III-C).
Given a plant H modeled as a DTLHS, a set of goal
states G (liveness speciﬁcations) and an initial region I,
both represented as linear predicates, we are interested in
ﬁnding a restriction K of the behaviour of H such that in
the closed loop system all paths starting in a state in I lead
to G after a ﬁnite number of steps. Finding K is the DTLHS
control problem (Section III-D) that is in turn deﬁned as a
suitable LTS control problem (Section III-C).
Finally, we are interested in controllers that take their
decisions by looking at quantized states, i.e., the values that
the control software reads after an AD conversion. This is
the quantized control problem.
A. Predicates
We denote with X = [x1, . . . , xn] a ﬁnite sequence of
variables. Each variable x ranges on a known (bounded or
unbounded) interval Dx either of the reals or of the integers
(discrete variables). We denote with DX the set Q
x∈X Dx.
Boolean variables are discrete variables ranging on the set B
16
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-226-4
INFOCOMP 2012 : The Second International Conference on Advanced Communications and Computation

= {0, 1}. Unless otherwise stated, we suppose real variables
to range on R and integer variables to range on Z.
A linear expression over a list of variables X is a linear
combination of variables in X with rational coefﬁcients.
A linear constraint over X (or simply a constraint) is an
expression of the form L(X) ≤ b, where L(X) is a linear
expression over X and b is a rational constant. Finally, a
conjunctive predicate is conjunction of constraints.
B. OBDD Representation for Boolean Functions
We will denote boolean functions f : Bn → B with
boolean expressions on boolean variables involving + (log-
ical OR), · (logical AND, usually omitted thus xy = x · y),
¯ (logical complementation) and ⊕ (logical XOR). We will
also denote vectors of boolean variables in boldface, e.g.,
x = ⟨x1, . . . , xn⟩. Moreover, we also denote with f|xi=g(x)
the boolean function f(x1, . . . , xi−1, g(x), xi+1, . . . , xn)
and with ∃xi
f(x) the boolean function f|xi=0(x) +
f|xi=1(x). A truth assignment µ is a partial map from
a set of boolean variables V to B. A minterm of µ is
a total extension of µ, i.e., a total truth assignment ν
s.t. µ(x)
̸=⊥→
ν(x)
=
µ(x) for all x
∈
V. The
value of a minterm (or of a total truth assignment) ν is
Pn
i=1 2i−1ν(xi), being V = {x1, . . . , xn}.
An
OBDD
with
complemented
edges
(COBDD
[14][15][16])
is
a
rooted
directed
acyclic
graph (DAG) with the following properties. Each node v is
labeled either with a boolean variable var(v) (an internal
node) or with 1 ∈ B (the unique terminal node 1). Each
internal node v has exactly two children, labeled with
high(v) (representing the case in which var(v) is true)
and low(v) (var(v) is false). Moreover, low(v) may be
complemented, depending on a label ﬂip(v) being true.
Finally, on each path from the root to a terminal node, the
variables labeling each internal node must follow the same
ordering. The semantics of a COBDD internal node v w.r.t.
a ﬂipping bit b, with var(v) = x, is the boolean function
Jv, bK := xJhigh(v), bK + ¯xJlow(v), b ⊕ ﬂip(v)K
C. Most General Optimal Controllers
A Labeled Transition System (LTS) is a tuple S
=
(S, A, T) where S is a ﬁnite set of states, A is a ﬁnite set of
actions, and T is the (possibly non-deterministic) transition
relation of S. A controller for an LTS S is a function
K : S ×A → B enabling actions in a given state. We denote
with Dom(K) the set of states for which a control action
is enabled. An LTS control problem is a triple P = (S,
I, G), where S is an LTS and I, G ⊆ S. A controller K
for S is a strong solution to P iff it drives each initial state
s ∈ I in a goal state t ∈ G, notwithstanding nondeterminism
of S. A strong solution K∗ to P is optimal iff it minimizes
path lengths. An optimal strong solution K∗ to P is the most
general optimal controller (we call such solution an mgo) iff
in each state it enables all actions enabled by other optimal
controllers. For more formal deﬁnitions of such concepts,
see [7]. For efﬁcient algorithms to compute mgos starting
from suitable (nondeterministic) LTSs, i.e., see [17].
D. Discrete Time Linear Hybrid Systems
In this section we introduce the class of discrete time Hy-
brid Systems that we use as plant models, namely Discrete
Time Linear Hybrid Systems (DTLHSs for short). For a more
complete introduction, see [10].
Deﬁnition 1. A Discrete Time Linear Hybrid System is a
tuple H = (X, U, Y, N) where: X is a ﬁnite sequence of
present state variables (we denote with X′ the sequence
of next state variables obtained by decorating with ′ all
variables in X); U is a ﬁnite sequence of input variables; Y
is a ﬁnite sequence of auxiliary variables; N(X, U, Y, X′)
is a conjunctive predicate over X ∪ U ∪ Y ∪ X′ deﬁning
the transition relation (next state) of the system. Note
that X, U, Y may contain discrete as well as continuous
variables.
DTLHSs may be used to represent many interesting real-
world plants, such as e.g., the buck DC/DC converter with
multi inputs used in Section V [9].
Given a DTLHS H = (X, U, Y , N), we deﬁne LTS(H)
= (DX, DU, ˜N) where: ˜N : DX × DU × DX → B is
a function s.t. ˜N(x, u, x′) ≡ ∃ y ∈ DY N(x, u, y, x′). A
state x for H is a state x for LTS(H). A DTLHS control
problem P = (H, I, G) is deﬁned as the LTS control
problem (LTS(H), I, G). To accommodate quantization
errors, always present in software based controllers, it is
useful to relax the notion of control solution by tolerating
an (arbitrarily small) error ε on the continuous variables.
Accordingly, we look for controllers that drive the plant to
the goal G with an error at most ε (we call such a controller
a ε-solution to P). Such an error is deﬁned by the given
quantization for the DTLHS.
In classical control theory the concept of quantization has
been introduced (e.g., see [18]) in order to manage real val-
ued variables. Quantization is the process of approximating
a continuous interval by a set of integer values. Formally, a
quantization function γ for a real interval I = [a, b] is a non-
decreasing function γ : I 7→ Z s.t. γ(I) is a bounded integer
interval. Finally, a quantization Q = (A, Γ) for a DTLHS
encloses quantization functions Γ for all state variables as
well as the bounded (safe) admissible region A on which the
desired controller is supposed to work. Namely, A bounds
both state variables (subregion AX) on which the controller
has to keep the system and action variables (subregion AU)
on which the controller works.
A control problem admits a quantized solution if control
decisions can be made by just looking at quantized values.
This enables a software implementation for a controller.
Deﬁnition 2. Given a quantization Q, a Q Quantized Feed-
back Control (QFC) solution to a DTLHS control problem
P is a ∥Γ∥ solution K(x, u) to P such that K(x, u) =
17
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-226-4
INFOCOMP 2012 : The Second International Conference on Advanced Communications and Computation

ˆK(Γ(x), Γ(u)), where ˆK : Γ(AX) × Γ(AU) → B and ∥Γ∥
is the size of the largest interval of values that are mapped
to the same quantized value.
For efﬁcient (non-complete) algorithms to compute QFC
solutions to a DTLHS control problem, e.g., see [7].
IV. AUTOMATIC VISUALIZATION OF CONTROL
SOFTWARE
In this section, we describe (Algorithms 1 and 2) our
method to automatically generate a 2D picture describing
a Q QFC solution K to a DTLHS control problem P =
(H, I, G) with a given quantization Q = (A, Γ).
The picture we generate lies on a 2D cartesian plane,
where each axis is labeled with a state variable of H and
has a range bounded by A. Then, a point (x, y) in the picture
is colored depending on which actions set is enabled by K
in the DTLHS state (x, y), i.e., on
c(x, y) = {u | K((x, y), u) = 1}
If H has ℓ+2 state variables, then the actions set we consider
is c(x, y) = {u | ∃d1, . . . , dℓK((x, y, d1, . . . , dℓ), u) = 1}.
Note that such a picture is practically useful if H has
at least two real variables, which is indeed the case in
most real-world SBCSs. Finally, a second picture showing
the correspondence between actions sets and colors is also
generated.
A. Input and Output
The above is performed by our main function Visualize
(described in Algorithm 1), which takes as input:
• a DTLHS plant model H = (X, U, Y, N);
• a quantization Q = (A, Γ) for H;
• a subset Ξ ⊆ X of plant state variables s.t. |Ξ| = 2;
variables in Ξ are those to be shown in the axes of the
ﬁnal 2D picture;
• a Q QFC solution K to a control problem involving
H. By Deﬁnition 2, K is based on a controller ˆK
that only looks at integer (quantized) values. Thus, by
considering the boolean encoding of such values (as it
is usual in Model Checking Applications), ˆK, and by
abuse of notation K, can be represented as a COBDD
ρ, a node v of ρ and a ﬂipping bit b s.t. Jv, bK = K.
The output of Visualize is a Gnuplot [8] source ﬁles
pair (P, C) describing the picture P to be generated and
the color legend C. Note however that Visualize may
be easily adjusted to work with any other graphing tool,
provided that it generates pictures from textual descriptions.
In Algorithm 1, we represent P as a list of rectangles in
the plant state space (restricted to variables in Ξ). To each
rectangle, we associate the RGB code of the corresponding
color to be displayed. Analogously, C is a list of colored
rectangles with height equal to the height of the picture:
on the x axis the actions set corresponding to each colored
rectangle is shown.
B. Algorithm Details
Function Visualize works as follows. First of all, in line 2,
state bit variables encoding plant state variables not in Ξ
(i.e., those not to be displayed in the ﬁnal picture) are
existentialized out from K, thus obtaining COBDD node v′
and ﬂipping bit b′ such that Jv′, b′K = ∃v1, . . . , vℓJv, bK =
∃v1, . . . , vℓK = ˜K. As a result, the ﬁnal picture will show
all values for plant state variables in Ξ s.t. there exists at
least a value for all plant state variables in X \ Ξ that is
controlled by K.
The workﬂow of the remaining lines is as follows. In
order to obtain a better compression, controllers are typically
represented with COBDDs where action bit variables come
ﬁrst in the variables ordering; this is also the case for [7].
In order to generate the desired picture, we reverse such
order by placing state bit variables before action bit variables
(line 4), thus obtaining a new COBDD ρ′. Since there always
exists a COBDD representing a given boolean formula, in
the new COBDD ρ′ there will be a node v′′ s.t. Jv′′, b′K = ˜K.
This allows us to perform a depth-ﬁrst visit (DFS) of the
COBDD representing ˜K, by calling (line 5) function Cre-
ateGnuplotBody described in Algorithm 2. Namely, function
CreateGnuplotBody returns a list M of (µ, v, b) triples s.t.
µ is a total truth assignment to state bit variables with value
ˆx, and for all plant states x in the quantized state ˆx (i.e.,
such that x ∈ Γ−1(ˆx)) K enables the set of actions u s.t.
the boolean encoding of u satisﬁes Jv, bK.
In order to achieve this goal, function CreateGnuplotBody
of Algorithm 2 starts a depth-ﬁrst visit (DFS) of ρ′ from
node v′′ with ﬂipping bit b′. On each path from v′′ to 1,
the DFS stops as soon as an action bit variable is found
at node z (i.e., var(z) is part of plant action variables U
encoding) with ﬂipping bit c. While exploring such a path,
the corresponding truth assignment µ is maintained, i.e.,
if the then edge of a node w has been traversed, then
µ(var(w)) = 1 (lines 5–6); if the else edge has been
traversed, then µ(var(w)) = 0 (lines 7–9). Moreover, if
a complemented edge is traversed, the ﬂipping bit b is
ﬂipped (line 8). Once, in line 1, a node z is found s.t.
var(z) is an action bit variable, or directly 1 is encountered
(meaning that all actions are enabled by K for the quantized
states corresponding to values of minterms of µ), the to-be-
returned list M is updated (lines 2–3) by adding all minterms
of the current µ together with the pair (z, b).
Once function CreateGnuplotBody has ﬁnished, the re-
turned list M may be directly translated in a Gnuplot ﬁle P
as follows. For each triple (µ, v, b) in M, the value ˆx of µ is
translated in a rectangle having as bounds those of Γ−1(ˆx),
i.e., of the cartesian product of the intervals that are mapped
to ˆx (line 10). The RGB color of such a rectangle may be
determined starting from the address (a C language pointer)
of (v, b). However, this has the following drawbacks: i) the
Gnuplot ﬁle for the picture may be too big; ii) different runs
18
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-226-4
INFOCOMP 2012 : The Second International Conference on Advanced Communications and Computation

of function Visualize (e.g., with different quantizations, and
thus different boolean encoding, for plant state variables)
may result in different colors for equal actions sets, which
may make difﬁcult an effective comparison between differ-
ent experiments. In order to counteract i), M is compacted,
by collapsing contiguous quantized states with the same
action sets (function CompactRectangularRegions in line 7
of Algorithm 1). To avoid ii), we ﬁrst generate all possible
22r colors (line 8, using an approach similar to [19]) and
we use a lexicographical ordering on action sets to pick one
of such colors. Finally, the Gnuplot ﬁle C maintaining the
correspondence between colors and action sets is generated
in lines 11–12, where SatAll returns all satisfying minterms
of the given COBDD (boolean function).
Algorithm 1 Visualizing a controller.
Require: DTLHS H, quantization Q, state variables set Ξ
s.t. |Ξ| = 2, COBDD ρ, node v, boolean b
Ensure: Visualize(H, Ξ, ρ, v, b):
1: let v1, . . . , vℓ be the state bit variables encoding plant
variables in Ξ
2: let v′, b′ be s.t. Jv′, b′K = ∃v1, . . . , vℓJv, bK
3: let w1, . . . , wr, wr+1, . . . , wn+r be the current bit vari-
ables ordering in ρ, being r (resp. n) the number of
action (state) bits variables
4: modify the ordering in wr+1, . . . , wn+r, w1, . . . , wr;
call ρ′ the resulting COBDD and v′′ the node of ρ′ s.t.
Jv′′, b′Kρ′ = Jv′, b′Kρ
5: M ←CreateGnuplotBody(ρ′, v′′, b′, w1, ⊥, ∅)
6: for all i ∈ [|α|] do
7:
M ←CompactRectangularRegions(M, i)
8: χ ←DifferentColorsRGB(22r)
9: for all triples (µ, v, b) ∈ M do
10:
using Q, append to P the rectangle corresponding to
µ with color χlexOrder(v,b)
11: for all (v, b) s.t. ∃(µ, v, b) ∈ M do
12:
append to C a rectangle of color χlexOrder(v,b) with
label SatAll(ρ′, v, b)
13: return ⟨P, C⟩
V. EXPERIMENTAL RESULTS
We implemented our picture generation algorithm in
C programming language, using the CUDD package for
OBDD based computations and BLIF ﬁles to represent input
OBDDs. We name the resulting tool KPS (Kontroller Picture
Synthesizer). KPS is part of a more general tool named
QKS (Quantized feedback Kontrol Synthesizer [7]). In this
section we present our experiments that aim at evaluating
effectiveness of KPS.
1) Experimental Settings: We present experimental re-
sults obtained by using KPS on given COBDDs ρ1, . . . , ρ4
and DTLHSs H1, . . . , H4 s.t. for all i ∈ [4] ρi represents
the mgo Ki(x, u) for a buck DC/DC converter with i
inputs (see [9] for a description of this system) modeled
Algorithm 2 Visualizing a controller: Gnuplot body.
Require: COBDD ρ, node v, boolean b, ﬁrst action bit
variable a, truth assignment µ, (assignment, COBDD
node, ﬂipping bit) triples set M
Ensure: CreateGnuplotBody(ρ, v, b, a, µ, M):
1: if (v = 1 ∧ ¬b) ∨ (v ̸= 1 ∧ var(v) > a) then
2:
for all minterms ν of µ do
3:
M ← M ∪ (ν, v, b)
4: else if v ̸= 1 then
5:
µ(var(v)) ← 1
6:
M ←CreateGnuplotBody(ρ, high(v), b, a, µ, M)
7:
µ(var(v)) ← 0
8:
if ﬂip(v) then b ← ¬b
9:
M ←CreateGnuplotBody(ρ, low(v), b, a, µ, M)
10: return M
Table I
KPS PERFORMANCE (CPU TIMES ARE IN SECONDS).
r
CPU(P)
CPU(G)
|P|
|J|
|E|
1
9.15e+00
3.25e+02
6.17e+03
2.46e+01
5.19e+03
2
1.00e+01
1.47e+03
1.29e+04
2.91e+01
1.09e+04
3
1.06e+01
2.43e+03
1.67e+04
2.91e+01
1.39e+04
4
1.10e+01
3.58e+03
2.02e+04
3.16e+01
1.68e+04
by Hi, where quantization Q is s.t. n = |x| = 20 and
ri = |u| = i. Ki is an intermediate output of the QKS
tool described in [7]. For each ρi, we run KPS so as to
compute Visualize(Hi, Q, X, ρi, vi, bi) (see Algorithm 1).
All our experiments have been carried out on a 3.0 GHz Intel
hyperthreaded Quad Core Linux PC with 8 GB of RAM.
2) KPS Performance: In this section we will show the
performance (in terms of computation time and output size)
of the algorithms discussed in Section IV. Table I show our
experimental results. The i-th row in Table I corresponds to
experiments running KPS so as to compute Synthesize(Hi,
Q, X, ρi, vi, bi). Columns in Table I have the following
meaning. Column r shows the number of action variables
|u| (note that |x| = 20 on all our experiments). Col-
umn CPU(P) shows the computation time of KPS, i.e., of
function Visualize of Algorithm 1 (in seconds). Columns
|P|, |J| and |E| show the size in KB of, respectively, the
source Gnuplot ﬁle for the 2D picture (i.e., the output P of
function Visualize of Algorithm 1), the JPEG ﬁle generated
by Gnuplot from P (i.e., with compression), and the EPS ﬁle
generated by Gnuplot from P (i.e., without compression).
Finally, Column CPU(G) shows the computation time of
Gnuplot (in seconds) to generate the JPEG and the EPS
ﬁles (computation time and size for ﬁle C are negligible).
From Table I we can see that, in slightly more than 10
seconds we are able to generate the Gnuplot ﬁle for the
multi-input buck with r = 4 action variables. Then, Gnuplot
needs about one hour to synthesize the actual picture (either
in JPEG or in EPS).
19
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-226-4
INFOCOMP 2012 : The Second International Conference on Advanced Communications and Computation

-1
 0
 1
 2
 3
 4
 5
 6
 7
-4
-3
-2
-1
 0
 1
 2
 3
 4
vO
iL
Figure 2.
KPS+Gnuplot generated picture (P) for K2.
 0
 0.2
 0.4
 0.6
 0.8
 1
(-,-)
(-,1)
(0,-),(1,1)
(1,0)
(-,0)
(0,0)
(0,1),(1,-)
u1, u2
Figure 3.
KPS+Gnuplot generated picture (C) for K2.
3) KPS Evaluation: In Figures 2 and 3 we show the
pictures generated by the KPS–Gnuplot chain for K2. First
of all, from Figure 3 we note that only 7 actions sets out of
222 = 16 are indeed enabled in K. Moreover, from Figure 2
we may immediately see that K indeed covers nearly all the
admissible region of the buck converter. Finally, combining
the two ﬁgures, we may see that the actions set {(−, 1)}
(i.e., u2 = 1 and u1 may be either 1 or 0) is the most used
one.
VI. CONCLUSIONS
In this paper, we addressed the problem of visualizing a
controller K for a DTLHS modeling an embedded system
(plant). To this aim, we presented an algorithm and a tool
KPS implementing it, which, from an OBDD representation
of K, effectively generates a 2D picture depicting K. Such
picture consists on a cartesian plane where each point
corresponds to a state of the starting DTLHS, and colors
with the same color all regions of states for which the same
actions set is deﬁned on K. A separated picture showing the
relation between a color and the corresponding actions set
is also automatically generated. In this way, the state region
for which any color is shown depicts the coverage of K,
whilest the regions colors give a glimpse of which actions
are turned on by K on given plant states regions. We have
shown feasibility of our proposed approach by presenting
experimental results on using it to visualize the controller
for a multi-input buck DC-DC converter.
The proposed approach currently generates a 2D picture,
which forces to focus on just two plant state variables. Thus,
a natural possible future research direction is to investigate
how to generate a 3D picture. Finally, a 3D bar picture may
also be used if there are more than 2 state variables in the
input DTLHS plant, in order to show for each quantized
value of the variables to be shown (i.e., those in Ξ) the
percentage of coverage w.r.t. variables not to be shown (i.e.,
not in Ξ).
Acknowledgments: We are grateful to our anonymous
referees for their helpful comments. Our work has been
partially supported by: MIUR project DM24283 (TRAMP)
and by the EC FP7 project GA218815 (ULISSE).
REFERENCES
[1] T. A. Henzinger and J. Sifakis, “The embedded systems
design challenge,” in FM’06, LNCS 4085.
[2] T. Henzinger, P.-H. Ho, and H. Wong-Toi, “Hytech: A model
checker for hybrid systems,” STTT, 1(1), pp. 110–122, 1997.
[3] G. Frehse, “Phaver: algorithmic veriﬁcation of hybrid systems
past hytech,” STTT, 10(3), pp. 263–279, 2008.
[4] H. Wong-Toi, “The synthesis of controllers for linear hybrid
automata,” in CDC’97, pp. 4607–4612.
[5] C. Tomlin, J. Lygeros, and S. Sastry, “Computing controllers
for nonlinear hybrid systems,” in HSCC’99, LNCS 1569.
[6] M. Mazo, A. Davitian, and P. Tabuada, “Pessoa: A tool for
embedded controller synthesis,” in CAV’10, LNCS 6174.
[7] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “Synthesis of
quantized feedback control software for discrete time linear
hybrid systems,” in CAV’10, LNCS 6174.
[8] “Gnuplot: http://www.gnuplot.info/,” accessed: Jul 31, 2012.
[9] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “On model based
synthesis of embedded control software,” in EMSOFT’12.
[10] F. Mari, I. Melatti, I. Salvo, E. Tronci. Quantized feedback
control software synthesis from system level formal speciﬁ-
cations. CoRR, abs/1107.5638v1, 2011.
[11] A. Girard, “Synthesis using approximately bisimilar abstrac-
tions: time-optimal control problems,” in CDC’10.
[12] M. J. Mazo and P. Tabuada, “Symbolic approximate time-
optimal control,” Systems & Control Letters, 60(4), pp. 256–
263, 2011.
[13] A. Girard, G. Pola, and P. Tabuada, “Approximately bisimilar
symbolic models for incrementally stable switched systems,”
IEEE Trans. on Aut. Contr., 55(1), pp. 116–126, 2010.
[14] K. S. Brace, R. L. Rudell, and R. E. Bryant, “Efﬁcient
implementation of a bdd package,” in DAC’90.
[15] S. Minato, N. Ishiura, and S. Yajima, “Shared binary decision
diagram with attributed edges for efﬁcient boolean function
manipulation,” in DAC’90, pp. 52–57.
[16] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “From boolean
relations to control software,” in ICSEA’11.
[17] A. Cimatti, M. Roveri, and P. Traverso, “Strong planning in
non-deterministic domains via model checking,” in AIPS’98.
[18] M. Fu and L. Xie, “The sector bound approach to quantized
feedback control,” IEEE Trans. on Automatic Control, 50(11),
pp. 1698–1711, 2005.
[19] “How
to
generate
random
colors
programmatically:
http://martin.ankerl.com/2009/12/09/how-to-create-random-
colors-programmatically/,” accessed: Jul 31, 2012.
[20] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “Synthesis of
quantized feedback control software for discrete time linear
hybrid systems,” in CAV’10, LNCS 6174.
20
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-226-4
INFOCOMP 2012 : The Second International Conference on Advanced Communications and Computation

