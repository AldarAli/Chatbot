165
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Exact Logic Minimization and Multiplicative
Complexity of Concrete Algebraic and
Cryptographic Circuits
Nicolas T. Courtois
University College London,
Gower Street, London, UK
n.courtois@cs.ucl.ac.uk
Theodosis Mourouzis
University College London,
Gower Street, London, UK
theodosis.mourouzis.09@ucl.ac.uk
Daniel Hulme
University College London,
Gower Street, London, UK
d.hulme@cs.ucl.ac.uk
Abstract—Two very important NP-hard problems in the area
of computational complexity are the problems of Matrix Mul-
tiplication (MM) and Circuit Optimization. Solving particular
cases of such problems yield to improvements in many other
problems as they are core sub-routines implemented in many
other algorithms. However, obtaining optimal solutions is an
intractable problem since the space to explore for each problem
is exponentially large. All suggested methodologies rely on well-
chosen heuristics, selected according to the topology of the
speciﬁc problem. Such heuristics may yield to efﬁcient and
acceptable solutions but they do not guarantee that no better
can be done. In this paper, we suggest a general framework for
obtaining solutions to such problems. We have developed a 2-step
methodology, where in the ﬁrst place we describe algebraically
the problem and then we convert it to a SAT-CNF problem, which
we solve using SAT-solvers. By running the same procedure for
different values of k we can obtain optimal solutions and prove
that no better can be done. We decrease the k until ”UNSAT”
is obtained. Using the suitable encoding step for each problem
we have been able to obtain exact and optimal solutions for
different problems which are sufﬁciently small, allowing us to
solve them on an average PC. We have been able to prove
the exact number of multiplications needed for multiplying two
non-square matrices of sufﬁciently small dimensions, as well as
obtaining optimal representations with respect to meaningful
metrics for several S-boxes used in prominent ultra-lightweight
ciphers such as GOST, PRESENT and CTC2.
Index Terms—Linear Algebra, Fast Matrix Multiplication, Com-
plex Numbers, quaternions, Strassen’s algorithm, Multiplicative
Complexity, Asynchronous Circuits, Logic Minimization, Auto-
mated Theorem Provers, Block Ciphers, CTC2, PRESENT, GOST,
SAT solvers
I. INTRODUCTION
Optimization of arbitrary algebraic computations over rings
in the general non-commutative setting is considered as one
of the most interesting topics in theoretical computer science
and mathematics. In general such optimization problems are
expected to be computationally very hard [1], [2].
In this paper, we study two fundamental problems. We study
the problem of minimizing the Multiplicative Complexity
(MC) of algebraic computations, such as the Matrix Multipli-
cation (MM) [1]. MC is the minimum number of AND gates
that are needed, if we allow an unlimited number of NOT
and XOR gates. Informally, we are interested in reducing the
number of multiplications involved in an arbitrary algebraic
computation to the lowest possible bound, allowing unlimited
number of additions. Initially, we study the optimization
problem over small ﬁelds such as GF(2). However, in some
cases solutions found do not yet yield a general solution for
a larger ring, and there can be additional lifting steps [1].
The second problem we study is the combinatorial logic
optimization of general Boolean circuits, with respect to a
given set of elementary operations. Logic optimization is also
a well-known hard problem which interests the chip maker
industry and researchers in complexity. Good optimizations are
particularly important in industrial hardware implementations
of standard cryptographic algorithms [3], [4]. This is because
cryptography is computationally very costly and the improved
designs can be used in hundreds of millions of integrated cir-
cuits and produce important savings. These ciphers have very
small S-boxes, yet, nobody knows how to implement them in
an optimal way, and new cryptographic implementations with
less gates are obtained almost each year [5], [6].
In practice, there are no known analytic techniques nor di-
rect prescriptive algorithms, which can construct such optimal
circuits. Developing an optimal circuit representation for a
small-size Boolean function of the form GF(2)8 → GF(2)
with respect to AND gates remains still an open problem. Is
it possible to determine once for all, what is the minimum
possible number of gates? Exact bounds are very hard to be
obtained in these areas, as the problem is mainly solved by
heuristic techniques and is known to be computationally very
hard.
In this paper, we view these problems as constraint satis-
faction problems which we attempt to solve them by methods
of formal coding [7] and later solve with software such as
SAT solvers [8]. The striking feature of this type of methods
is that, if we use a ”complete” SAT solver (and we have
enough CPUs), as opposed to a ”stochastic” one, and if it
is fast enough to complete, and it outputs UNSAT, we obtain
a proven lower bound, a very rare thing in complexity.
Our method consists of three basic steps. In the ﬁrst step, we
formally encode the problem by writing a system of equations
which describes our problem as a system of polynomial

166
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
equations over the ﬁnite ﬁeld of two elements GF(2). In the
case of the MM problem and some other of our algebraic
optimizations [1], we use the Brent Equations [9] in the
encoding step. Circuit minimization problems are encoded
formally as a form of straight-line representation problem,
which we encode them as a quantiﬁed set of multivariate
relations that need to be satisﬁed. Then, we proceed by
converting our deﬁned modulo 2 problem to a SAT problem
using the Courtois-Bard-Jefferson method [7] and then (only
if required) we may add additional steps such as lifting the
solution to larger ﬁelds or rings [1] or re-optimize for circuit
depth, or many other [5], [6].
This type of methodology was recently applied with success
to optimize linear circuits [10] and bi-linear circuits [11]. We
have developed a method to do this also for non-linear circuits.
We have been greatly inﬂuenced by the work of Boyar and
Peralta on the AES cipher S-box and its MC, however, we can
also produce many optimizations from scratch with arbitrary
gates and without the Boyar-Peralta heuristic. Though this type
of exact optimizations is computationally very intensive and
therefore currently only possible for fairly small circuits, the
preliminary results obtained are very encouraging and allow
for direct applications in cryptographic hardware synthesis,
systematic synthesis of implementations resistant to side-
channel attacks, and also in cryptanalysis [12], [3], [13]. In
this paper, we also report our results on PRESENT and GOST,
two block ciphers known for their exceptionally low hardware
cost.
A. Structure of the Paper
The organization of this paper is as follows:
Section II: We refer to several reasons highlighting the
importance of solving such problems. We outline several
improvements which yield in many other applications, as
a consequence of improving the state-of-art algorithms for
solving MM and combinatorial circuit optimization problems.
Obtaining even solutions to small problems may yield signif-
icant improvements to general problems as these solutions to
smaller instances can be recursively used to handle the general
problem.
Section III: We describe all technical details of our 2-
step methodology. Initially, we describe the encoding step
which we employ for each problem. For example in case
of MM as a tool of encoding we use the Brent Equations,
while for optimizing circuits we invented a general framework
of encoding. Then we brieﬂy analyze how to obtain the
corresponding CNF-SAT problem of a given problem, which
is algebraically encoded. Additionally, we describe provably
aspects of our methodology and we highlight how powerful are
the SAT solvers for solving exactly such NP-hard problems.
Section IV: We apply our methodology for obtaining new
formulaes for multiplying two non-necessarily square matri-
ces. We have been able to solve exactly with respect to the
number of multiplications needed to multiply such matrices,
for sufﬁciently small matrices. Several small instances are
solved and presented.
Section V: We optimize arbitrary non-linear digital circuits
for silicon implementation and cryptanalysis. We apply our
methodology for obtaining optimal circuit representations for
the S-boxes used in many prominent ultra-lightweight block
ciphers such as PRESENT and GOST. For experimentation we
have been able to optimize the 3-bit to 3-bit S-box of CTC
cipher with respect to different meaningful metrics.
II. MOTIVATION FOR LOW MC AND LOW GATE COUNT
OPTIMIZATIONS
We brieﬂy outline what will be the beneﬁts in both academic
and industrial world if some better optimizations are found for
the problems of MM and gate-efﬁcient implementation.
A. Matrix Multiplication Problem
Obtaining the minimum number of 2-input multiplications
needed for computing the product of two matrices A, B, is
considered among the most difﬁcult optimization problems
in the area of computer science and mathematics. Given two
matrices A, B the MM is deﬁned as follows (Def. 1).
Deﬁnition 1: (Matrix Multiplication [MM])
Let A and B two n × n matrices, n ∈ N, with entries in a
ring R (not necessarily commutative), such that
Am,n =





a1,1
a1,2
· · ·
a1,n
a2,1
a2,2
· · ·
a2,n
...
...
...
...
an,1
an,2
· · ·
an,n




 and
Bm,n =





b1,1
b1,2
· · ·
b1,n
b2,1
b2,2
· · ·
b2,n
...
...
...
...
bn,1
bn,2
· · ·
bn,n




.
Then, the entries of the product matrix C = AB are given
by
Cp,q = [AB]p,q =
n
∑
i=1
ap,ibi,q.
(1)
The multiplication is deﬁned as in the ring R.
We are interested in obtaining new formulaes for computing
the product matrix C involving as few number of 2-input
multiplications as possible. Fast linear algebra for large matri-
ces leads to signiﬁcant improvements in many other areas as
follows [14]:
• Commercial software such as MATLAB, MATHEMAT-
ICA and GAUSS
• Economic Modeling
• Weather prediction
• Signal processing
• Gauss Elimination algorithm for solving a system of
linear polynomial equations
• Algorithms for solving non-linear polynomial equations
• Recognizing if a word of length n belongs to a context-
free language
• Transitive closure of a graph or a relation on a ﬁnite set
• Statistical analysis of large data sets

167
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
• Integer factorization
• Cryptanalysis
B. Circuit Complexity
There are many reasons why circuits of low MC are
very important especially for industrial applications and for
cryptography. More analytic explanations can be found in [3].
• Develop certain so called Bitslice parallel-SIMD software
implementations of block ciphers such as in [15]
• Lower the hardware implementation cost of encryption
algorithms in silicon chips
• Prevent Side Channel Attacks (SCA) on smart cards such
as Differential Power Analysis (DPA) [16]
C. Cryptanalysis Applications:
In addition, more or less all optimizations in this paper
have direct applications in software cryptanalysis, cf. [12], [3],
[4], [13]. One reason for that is the fact that dense linear
algebra is very frequently the last step in many algebraic
attacks. Another family of applications are algebraic attacks
on symmetric cryptography. A more compact representation
of a cipher is known to improve the running time of many
such attacks [12], [13].
III. A SAT-SOLVER BASED METHODOLOGY
A. General Methodological Framework
In this paper, we formally encode optimization problems as
systems of multivariate equations over GF(2), then we convert
them to SAT problems, and then we solve them.
This sort of encoding is subject to continuous improvement,
and it can be viewed itself as a hard but solvable optimization
problem. Therefore, our current timings (current methods are
quite slow) and results are very likely to be improved in the
future in very substantial ways.
We describe all the main steps in our approach. Our main
scientiﬁc contributions are the methodology and concrete
results that are mathematical theorems about lower complex-
ity bounds and concrete optimizations, which are reusable
building blocks for algorithms, scientiﬁc computing and the
industry. For those results which we show to be optimal they
can no longer be improved, however, the timing of obtaining
these results (computations that need to be done only once)
can still certainly be improved.
In what follows, we present two major encoding method-
ologies. The Coding Methodology 1 is designed to address the
efﬁcient MM problem and other algebraic optimizations, We
use the Brent Equations [9] in the encoding step.
The Coding Methodology 2 is designed to address more
general problems of MC and other optimizations of arbitrary
circuits which are no longer initially described by multi-
variate polynomial expressions, but by a truth table. Circuit
minimization problems are encoded formally as a form or
straight-line representation problem, then we describe it as a
quantiﬁed set of multivariate relations [3], and then it has to
hold simultaneously for different input values in the truth table.
B. Coding Methodology 1
Our algorithm for solving for MM problems is as follows:
1) Form the Brent Equations (or write a quantiﬁed set of
multivariate relations that describes the problem)
2) Consider only solutions in 0,1=integers modulo 2
3) Convert to SAT with Courtois-Bard-Jefferson method [7]
4) Lift the solution from GF(2) to the general bigger ﬁelds
by another constraint satisfaction algorithm
C. Brent Equations
Brent Equations are used for encoding problems in a more
formal algebraic language. After the encoding we convert this
problem to a SAT problem and then we try to obtain a solution
using several SAT solvers.
Brent’s Method: Suppose we want to multiply a M × N
matrix A by a N×P matrix B using T 2-input multiplications.
We solve the above problem by solving the following system
of (MNP)2 equations in T(MN + NP + MP) unknowns,
cf. [9]:
{∀i∀j∀k∀L∀m∀n, ∑T
p=1 αijpβkLpγmnp = δniδjkδLm}
A solution to this set of equations implies that the coefﬁcient
entries cij of the product matrix C = AB can be written as
cnm = ΣT
p=1γmnpqp,
where the products q1, q2, ..., qT are given by the expression
qp = (Σαijpaij)(ΣβKLpbKL).
This form of encoding can be generalized for describing
other problems such as complex number multiplication and
quaternion multiplication.
D. Coding Methodology 2
This methodology is very different, and in fact it is possible
to see that for many circuits both methodologies could be ap-
plied. The motivation for this second method is that not every
circuit is very algebraic and it can be described efﬁciently
by sparse multivariate polynomial expressions. Especially, in
industrial cryptographic primitives we expect that the resulting
circuits will have a very low gate count since the efﬁcient
hardware implementation is one of the main priorities of
designers. Thus, it is very realistic that a system of equation
describing such a cryptographic primitive will be very sparse.
Therefore, the Brent-like approach could lead to a very large
problem to solve. However, we can also describe the initial
problem as a substitution box with a truth table. We proceed
as follows.
First, we write a certain system of equations C1 in which
variables will be divided in several disjoint categories:
1) We will have the ”x” variables which will be inputs of
the truth table.
2) The ”y” variables which will be outputs of the truth
table.
3) The ”t” variables which will be inputs of gates.
4) The ”q” variables which are outputs of gates.
5) The ”b” variables will deﬁne the function of each gate.
(For example, one gate could be AND, OR, XOR and

168
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
the model is b(uv) + b′(u + v), and when b = 1, b′ = 0
this will be AND gate.)
6) The ”a” variables which will be the unknown connec-
tions between different gates.
A crucial problem is how these connections are described
in C1. The purpose of the ”a” variables is to make each new
”t” variable depended on some combinations of past variables
of type ”x”, ”t”, ”q”. These ”a” variables will encode ALL
the unknown connections between different gates, their inputs,
their outputs, our inputs ”x” and our outputs ”y”.
For example, in MC optimizations we can say that each vari-
able is an afﬁne or linear combination of previous variables.
In other optimizations we can furthermore add constraints of
type aiaj = 0 which say that in a certain set of ai only at
most one of these variables is at 1. We provide a toy example
of our algebraic description C1 below:
t1 = a1 * x1 + a2 * x2
a1 * a2 = 0
t2 = a3 * x1 + a4 * x2
a3 * a4 = 0
q1 = t1 * t2
y1 = a5 * q1 + a6 * x1 + a7 * x2
y1 = x1 * x2
Another problem is how to describe the relation between the
inputs ”x” and the outputs ”y” efﬁciently. In the toy example
above this is done in the last line. Several methods for coding
small size I/O relations are described in [12]. It is the open
problem to see what is the best method and the best method
will depend a lot on the type of the circuit. One very good
method is to use a previous circuit with more gates (!).
Now our circuit minimization problem is encoded formally
as a straight-line computation problem. Then we expand this
system of equations C1 into another system of equations C2
as follows:
1) Our problem C1 is a quantiﬁed system of constraints.
We need to determine the variables of types ”a” and
”b”.
2) Our circuit C1 (see toy example above) must be true for
every ”x”. We can privilege values of small Hamming
weight (for some circuits we do NOT need to put all
possible values of ”x”.
3) We make several copies of the circuits and we rename
the ”x” and ”y” and ”q” and ”t” variables, however, the
”a” and ”b” variables remain common in all circuits.
4) We write all these circuits as systems of multivariate
relations [3] and concatenate them. We call C2 the
resulting system of equations.
5) We convert C2 to SAT and solve for the ”a” and ”b”
variables.
6) We take the values of the ”a” and ”b” variables, we
ignore all the other assignments, and substitute in the
original (single) circuit model C1.
7) We check if our solution is correct, and potentially opti-
mize for XORs, to decrease the number of intermediate
variables, etc.
E. SAT Solver Step
Satisﬁability (SAT) is the problem of determining if the
variables of a given Boolean formula can be assigned in a
way as to make the formula evaluate to TRUE [17]. SAT
was the ﬁrst known example of an NP-complete problem. A
wide range of other decision and optimization problems can
be transformed into instances of SAT and a class of algorithms
called SAT solvers can efﬁciently solve a large enough subset
of SAT instances such as MiniSAT solver [8]. Our aim is to
transform problems like MM into SAT problems.
SAT solvers had both theoretical and practical improve-
ments and have made a lot of progress in recent years. The
basis of most SAT solvers is the Davis-Putnam backtrack
search, which searches for a solution by recursively choosing a
variable and trying to assign to it one value and then the other.
At each stage of search a propagation step is performed which
attempts to imply the assignments to as many unassigned
variables as possible based on previous assignments. As a
result of this it may uncover a clause which cannot be satisﬁed,
so search backtracks.
In the major SAT competition every year, almost all the
previous years winners are beaten by new competitors who
design more efﬁcient solvers. Thus SAT solvers are carefully
designed to run on a large range of problems with no tuning
required by users.
Problems arising either from academia or from industry
can be solved by SAT solvers if are converted to Conjunctive
Normal Form (CNF). In Boolean logic, a formula is in CNF if
it is a conjunction of clauses, where a clause is a disjunction
of literals.
At a ﬁrst glance, this seems to be inefﬁcient as conversion
to CNF can skip extra structural information of the original
problem. However, the performance of SAT solvers is often
able to offset this structural information loss.
F. On the Complexity of SAT-solvers
Unfortunately, the time complexity of a SAT solver is not
easy to determine. A very large system in CNF can be easily
solved by a SAT solver on an average PC, but beyond some
point the probability of solving such a system from 1 becomes
0.
In cryptanalysis, that implies we can derive the key of
a reduced version. As the number of rounds grows, the
time complexity of such an algebraic attack becomes inﬁnite.
Unfortunately, there is no clear indication when the problem
becomes infeasible.
G. Conversion to SAT
In order to solve a problem using a SAT solver we need to
convert this problem to its CNF (cf. Def. 2).
Deﬁnition 2: (Conjunctive Normal Form)
A Boolean function f is said to be in conjunctive normal
form, if it is a conjunctive of clauses, where each clause is a
disjunction of literals, i.e., f can be expressed in the form

169
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
∧I⊆M(∨i∈Ixi), M = {1, .., n}
We have been using three major methods to convert a system
of multivariate polynomial equations over GF(2) to a SAT
problem. This idea has been pioneered by Bard and Courtois
see [12] and has become a very important tool in modern
cryptanalysis and automated problem solving.
As these methods are quite slow, it is too early to say which
one is better for the purpose of our optimizations.
1) We can use the Courtois-Bard-Jefferson tool [7] which
is available for download.
2) Another method is local approximation, it has been
frequently used in cryptanalysis, see [12], [13].
3) Yet another method is to use a SAT solver which accepts
native XORs, such as CryptoMiniSat by Soos [18],
and therefore new conversion methods can be proposed,
see [13] for some applications of these very promising
new encodings which seem to be really excellent in
cryptanalysis applications however, they have not yet
been tested in the setting of this paper.
A very basic approach to map a given problem to SAT-
CNF is ﬁrstly to derive a 2-degree system of equations from
the algebraic description of the problem using the fact that [7]:
{m = wxyz} ⇔ {a = wx, b = yz, m = ab}
In general, CNF expressions describe instances of SAT
problems, thus we need to obtain the CNF of this multivariate
system of quadratic equations. This conversion proceeds by
three major steps as follows [7]:
STEP 0: The CNF form must not contain any constants.
Since all clauses must be true in a solution, we introduce
constants by adding clauses of the form T ∨T ∨...∨T, which
implies that variable T is true in any satisfying solution. T
encodes constant 1, while T encodes 0.
STEP 1: (Polynomial System to Linear System)
Every polynomial is a sum of linear and higher degree
terms. Given a monomial a = wxyz over F2, then this is
tautological equivalent to
a ⇔ (w ∧ x ∧ y ∧ z)
(w ∨ ¯a)(x ∨ ¯a)(y ∨ ¯a)(z ∨ ¯a)(a ∨ ¯w ∨ ¯x ∨ ¯y ∨ ¯z).
Thus, for each monomial of degree d we have d+1 clauses,
while the total length of clauses is 3d + 1.
STEP 2: (Linear System to CNF expression)
After expressing each monomial involved the next step is
to express the logical XORs. The sum a ⊕ b ⊕ c ⊕ d⊕ = 0 is
equivalent to:
(¯a ∨ b ∨ c ∨ d)(a ∨ ¯b ∨ c ∨ d)(a ∨ b ∨ ¯c ∨ d)(a ∨ b ∨ c ∨ ¯d)
(¯a ∨ ¯b ∨ ¯c ∨ d)(¯a ∨ ¯b ∨ c ∨ ¯d)(¯a ∨ b ∨ ¯c ∨ ¯d)(a ∨ ¯b ∨ ¯c ∨ ¯d)
However, handling long XORs is a hard problems for SAT
solvers. For example, given a sum of length h we split it
into different sub-sums and encode each sum separately. More
details can be found in [7] since the scope of this paper to
contribute towards the encoding step and both conversion and
solving techniques can be considered as black-box procedures.
Note that the conversion procedure in this section is polyno-
mial in time and more details are found in [7].
H. Provably Optimal Aspects of Our Methods:
All the optimizations which are claimed EXACT in this
paper are optimal: they have been proven impossible to further
improve. This is achieved with an automated software proof
with UNSAT and would be PROVABLY OPTIMAL if we had
a proof of correctness of the SAT solver software and of course
if there is no bug in the SAT solver software.
For example, a SAT solver could claim UNSAT for a
certain problem or even output an incorrect proof of UNSAT.
However, we can overcome this problem as we have a portfolio
of around 500 different SAT solvers software and we can re-
check our results with other SAT solvers. Even if we assume
the presence of bugs in this software, one can consider that
our proofs are probabilistic proofs.
Possibly the probability of error could be very small and
under some additional assumptions we could have better
conﬁdence that our automated proof is indeed correct. We also
claim that what we do could be extended to produce fully veri-
ﬁable mathematical proofs written in a formal language, which
prove these optimality results. Some SAT solvers already have
the ability to output such proofs.
In order to obtain optimal solutions with respect to a count
k for a problem X we proceed as follows in Algorithm 1:
Algorithm 1: Given a decision problem X and a count k
for the metric of our interest proceed as follows:
1) Convert this to SAT-CNF
2) Obtain ”SAT” and a solution
3) Set k := k − 1
4) Repeat Until ”UNSAT”
5) Output: kmin such that is ”SAT”
IV. ON SOLVING THE MM PROBLEM
A very common approach for tackling the MM problem
is to work by solving ﬁxed-size problems and then apply
the solution recursively to higher dimensions. The general
framework for gluing together solutions for smaller instances
and obtain solutions to the general problem is provided by the
divide-and-conquer paradigm [19].
The complexity of solving the general problem depends
on the complexity of solving the underlying smaller sub-
problems. Thus, even a slight improvement in such a sub-
problem may lead to a huge improvement in the general prob-
lem. This general concept can be seen as a pure combinatorial
optimization problem with ﬁxed size, which have been studied
by many authors since Strassen [2], [20].
In this section, we provide a short description regarding
the complexity of existing techniques for solving the MM up-
to-date. Additionally, we apply our SAT-based methodology
for solving smaller instances of the MM problem. We present
new formulaes for multiplying sufﬁciently small matrices and
in some cases we are able to prove that these formulaes are
optimal with respect to the number of 2-input multiplications
required.

170
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
A. On the Complexity of MM
The complexity of the naive algorithm for computing the
product of two n × n matrices is O(n3) and similarly the
complexity for multiplying a m × p matrix by a p × n matrix
is O(mpn). Clearly, as the computation of the product matrix
of two n×n matrices contains n2 entries, that implies at least
n2 operations are needed and that a proven lower bound for
the complexity is O(n2).
Thus, the exponent of MM problem over a general non-
commutative ring R deﬁned as
ω(R) := inf τ ∈ R|MR = O(nτ)
Improving the exponent τ of the complexity O(nτ) of
MM problem is one of the main interests of the academic
community. The ﬁrst attempt was in 1969 by Volker Strassen
who has been able to decrease the complexity of square MM
to O(n2.807), by applying recursively the optimal solution he
obtained for multiplying two 2 × 2 matrices with 7 multipli-
cations [20] (cf. Theorem 1).
Theorem 1: (Strassen’s Algorithm using 7 Multiplications)
Given two 2 × 2 matrices A, B over a ring R, with entries
ai,j, bi,j ∈ R 1 ≤ i, j ≤ 2, then the entries ci,j of the product
matrix C = AB can be computed by the following formulaes,
P1 = (a1,1 + a2,2)(b1,1 + b2,2)
P2 = (a2,1 + a2,2)b1,1
P3 = a1,1(b1,2 + b2,2)
P4 = a2,2(−b1,1 + b2,1)
P5 = (a1,1 + a1,2)b2,2
P6 = (−a1,1 + a2,1)(b1,1 + b1,2)
P7 = (a1,2 − a2,2)(b2,1 + b2,2),
c1,1 = P1 + P4 − P5 + P7
c1,2 = P2 + P4
c2,1 = P3 + P5
c2,2 = P1 + P3 − P2 + P6
Afterwards, Coppersmith and Winograd developed an al-
gorithm to perform MM of square matrices of complexity
O(n2.376) [21]. They achieved such a complexity reduction
by proving new formulas for computing the inner product of
two n-dimensional vectors using fewer 2-input multiplications.
Later in 1975, Laderman published a solution for multi-
plying 3 × 3 matrices with 23 multiplications [22]. Since
then, this topic generated very considerable interest and yet
to this day it is not clear if Laderman’s solution in case of
3×3 multiplication can be further improved. For example, we
cannot prove if 23 is optimal and no formulas exist using 22
multiplications or even less.
In 2005, a team of scientists from Microsoft Research and
two US universities established a new method for ﬁnding such
algorithms based on group theory, and their best method so
far gives an exponents of 2.41 [23], close to Coppersmith-
Winograd result and subject to further improvement. However,
exponent τ is quite low and it is conjectured that one should
be able to do MM in so called soft quadratic time, with
possibly some poly-logarithmic overheads, which could even
be sub-exponential in the logarithm. This in fact would be
nearly linear in the size of the input. Amazingly enough,
many scientists conjecture that it could be nearly quadratic
like O(n2(log2(n))a), for some a.
Our Contribution: In this paper, we proceed by solving the
corresponding Brent equations for a given MM problem[9],
by converting it into a SAT-CNF problem. This approach
has been tried many times before, cf. [9], [17]. Note that
this methodology is more generic and it is also applied to
multiplication of non-square matrices.
B. New Formulaes for MM Problem
Using our SAT-based methodology as described in previous
chapters, we have been able to obtain the following results as
presented in Table I.
TABLE I
THE OUTPUT OF APPLYING OUR METHODOLOGY FOR SOLVING THE MM
PROBLEM USING A FIXED NUMBER OF MULTIPLICATIONS
Inputs
No.Mults.
SAT
Av.Time(s)
2,2,2
7
YES
0.55
2,2,2
6
NO
1062.7
2,2,3
11
YES
474.5
2,2,3
10
NO
4032.2
2,2,4
16
YES
0.63
2,2,4
15
YES
3152.8
As we see from the same table we can prove that multi-
plying two 2 × 2 matrices can not be done using less than 7
multiplications and thus Strassen’s formulaes are optimal.
Using stochastic SAT solvers, we can solve exactly the
decision problem: ”Can we multiply two matrices A, B using
exactly k 2-input multiplications?”. We have tried to solve all
these underlying decision problems for small problems and we
have been able to prove that no better can be done. A new
exact result is as formulated below in Theorem 2.
Theorem 2: Given two matrices matrices A ∈ M2×2(R)
and A ∈ M2×3(R) where R an arbitrary non-commutative
ring , then we can compute the product matrix C = AB using
at most 11 multiplications
Proof: An upper bound for solving this problem is by
naive MM and it is 12 multiplications in total over a general
non-commutative ring R.
First, we consider the Brent Equations corresponding to
11 multiplications. Thus, we obtain 144 equations in 176
unknowns (12098 right clauses).
Then, we convert it to a SAT problem, which we solve
using CryptoMiniSat in approximately 474.54s=0.132h. We
have obtained the following set of equations for solving the
MM problem using 11 multiplications.
P01 := (−a11 − a12 + a21 + a22) ∗ (b23);
P02 := (−a11 − a12 + a21) ∗ (b12 − b23);
P03 := (a11 − a21) ∗ (−b13 + b23);
P04 := (a11) ∗ (b11);
P05 := (a22) ∗ (−b21 + b23);

171
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
P06 := (−a11 − a12) ∗ (b12);
P07 := (a21) ∗ (b12 − b13);
P08 := (a22) ∗ (b21 − b22);
P09 := (a12) ∗ (−b12 + b22);
P10 := (a21) ∗ (−b11 + b12);
P11 := (a12) ∗ (b21);
c11 = (P04 + P11);
c12 = (−P06 + P09);
c13 = (P02 − P03 − P06 − P07);
c21 = (P01 + P02 − P05 − P06 − P10);
c22 = (P01 + P02 − P05 − P06 − P08);
c23 = (P01 + P02 − P06 − P07);
Initially, only 117 out of 144 equations were also true over
Z/4Z. After we applied our heuristic lifting technique we
lifted all solutions over this ring and the solution was true
over an arbitrary ring.
Then, we have obtained the corresponding Brent Equations
for 10 multiplications, 144 equations in 160 unknowns and
proceeded similarly. The output of our algorithm is UNSAT,
implying that there is no solution for this problem. We have
veriﬁed the UNSAT result using several other SAT-solvers for
minimizing the errors due to bugs in software.
Hence, 11 multiplications is the minimal number of required
multiplications for solving this problem.
In addition, we have applied our methodology for solving
the Laderman’s problem for multiplying 2 3×3 matrices using
23 multiplications. Amazingly, we have obtained a new non-
isomorphic solution to the same problem and we present it
below in Theorem 3.
Theorem 3: Given two square matrices matrices A, B ∈
M(R, 3) where R an arbitrary non-commutative ring , then
we can compute the product matrix C = A.B using at most
23 multiplications
Proof: An upper bound for solving this problem is by
naive MM and it is 27 multiplications in total over a general
non-commutative ring R.
Firstly, we write down the Brent Equations corresponding
to 23 multiplications. Thus, we obtain 729 equations in 621
unknowns. Then we convert them to a SAT-CNF problem,
which we solve using CryptoMiniSat. The following set of
equations is obtained.
P01 := (a23) ∗ (−b12 + b13 − b32 + b33);
P02 := (−a11 + a13 + a31 + a32) ∗ (b21 + b22);
P03 := (a13 + a23 − a33) ∗ (b31 + b32 − b33);
P04 := (−a11 + a13) ∗ (−b21 − b22 + b31);
P05 := (a11 − a13 + a33) ∗ (b31);
P06 := (−a21 + a23 + a31) ∗ (b12 − b13);
P07 := (−a31 − a32) ∗ (b22);
P08 := (a31) ∗ (b11 − b21);
P09 := (−a21 − a22 + a23) ∗ (b33);
P10 := (a11 + a21 − a31) ∗ (b11 + b12 + b33);
P11 := (−a12 − a22 + a32) ∗ (−b22 + b23);
P12 := (a33) ∗ (b32);
P13 := (a22) ∗ (b13 − b23);
P14 := (a21 + a22) ∗ (b13 + b33);
P15 := (a11) ∗ (−b11 + b21 − b31);
P16 := (a31) ∗ (b12 − b22);
P17 := (a12) ∗ (−b22 + b23 − b33);
P18 := (−a11 + a12 + a13 + a22 + a31) ∗ (b21 + b22 + b33);
P19 := (−a11 + a22 + a31) ∗ (b13 + b21 + b33);
P20 := (−a12 + a21 + a22 − a23 − a33) ∗ (−b33);
P21 := (−a22 − a31) ∗ (b13 − b22);
P22 := (−a11 − a12 + a31 + a32) ∗ (b21);
P23 := (a11 + a23) ∗ (b12 − b13 − b31);
c11 = P02 + P04 + P07 − P15 − P22;
c12 = P01 − P02 + P03 + P05 − P07 + P09 + P12
+P18 − P19 − P20 − P21 + P22 + P23;
c13 = −P02 − P07 + P17 + P18 − P19 − P21 + P22;
c21 = P06 + P08 + P10 − P14 + P15 + P19 − P23;
c22 = −P01 − P06 + P09 + P14 + P16 + P21;
c23 = P09 − P13 + P14;
c31 = P02 + P04 + P05 + P07 + P08;
c32 = −P07 + P12 + P16;
c33 = −P07 − P09 + P11 − P13 + P17 + P20 − P21;
This new set of equations for multiplying two 3×3 matrices
is non-isomorphic to the system of equations obtained by
Ladermann. A full explanation and proof of this is found in [1].
This embraces the conjecture that maybe it can be done with
fewer multiplications. We will try to investigate even more
this in the future by either seeking for further improvements
in our encoding step or running our algorithms on more CPUs
working in parallel.
V. EXACT COMBINATORIAL CIRCUIT OPTIMIZATION
In this section, we apply our methodology for obtaining
optimal circuit representations for sufﬁciently small digital
circuits with respect to various meaningful metrics. We study
circuit representations with respect to the following metrics:
1.Multiplicative Complexity (MC):is the minimum number
of AND gates (inﬁnite number of XORs in allowed).
2.Bitslice Gate Complexity (BGC): is the minimum number
of 2-input gates of types XOR,OR,AND,NOT needed. This
model is relevant in so called bitslice parallel-SIMD imple-
mentations of block ciphers, e.g. in [15].
3.Gate Complexity (GC): is the minimum number of 2-input
gates of types XOR,AND,OR,NAND,NOR,NXOR.
4.NAND Complexity (NC): is deﬁned by the minimum
number of 2-input NAND gates.
In order to compute such circuits, we apply the heuristic
methodology suggested by Boyar and Peralta [24] based on
the notion of MC as follows:
Step 1: First compute the MC.
Step 2: Optimize the number of XORs separately, cf. [25],
[10].
Step 3: (Optional Step) At the end do additional optimiza-
tions to decrease the circuit depth, and possibly additional
software optimizations, cf. [5], [24], [6].
We apply Coding Methodology 2 and we encode the
problem formally as a straight-line representation problem,

172
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
described by a quantiﬁed set of multivariate relations and we
convert it to SAT with the Courtois-Bard-Jefferson tool [7]
or other methods. Earlier work on computing the MC can be
found in [3].
In the next section we apply our methodology for obtaining
optimal representations with respect to all these circuit notions
for the CTC S-box.
A. Optimal Representations of CTC S-box
More generally, Coding Methodology 2 allows to optimize
for arbitrary gates, not only for MC. As a proof of concept
we consider the following S-box with 3 inputs and 3 outputs,
which have been generated at random for the CTC2 cipher [3]
and is deﬁned as,
{7, 6, 0, 4, 2, 5, 1}.
We have tried to optimize this S-box with the well known
software Logic Friday (based on Espresso min-term optimiza-
tion developed at Berkeley) and we obtained 13 gates, which
obviously can be further improved. With our software and in
a few seconds we obtained several interesting results, each
coming with a proof that it is an optimal result. All our
theorems are presented in the Lemmas below.
Lemma 4: The MC of CTC S-box is exactly 3 (we allow
3 AND gates and an unlimited number of XOR gates) (cf.
Figure 1)
Proof: We have obtained the following straight-line pro-
gram for this problem:
t00 = x01 + x02 + 1
y0 = q00 + q01 + x02
t01 = x00 + x02 + 1
y1 = q00 + q01 + q02
q00 = t00 × t01
y2 = q00 + x00
t02 = x02
t03 = x00 + x01 + x02
q01 = t02 × t03
t04 = x01 + x02 + 1
t05 = q00 + x01 + 1
q02 = t04 × t05
Fig. 1.
Our provably optimal implementation of CTC2 S-box [3] with MC
3.
Lemma 5: The Bitslice Gate Complexity (BGC) of CTC S-
box is exactly 8 (allowed are XOR,OR,AND,NOT) (we allow
3 AND gates and an unlimited number of XOR gates) (cf.
Figure 2)
Proof: Straight-Line Program for CTC2 S-box w.r.t Bit-
slice Complexity
t00 = x01
q03 = t06+t07
t15 = x00
t01 = x00
t08 = q01
q07 = t14+t15
q00 = t00×t01+t00+t01
t09 = x02
y0 = q04
t02 = q00
q04 = t08+t09
y1 = q05
t03 = 1
t10 = q00
y2 = q07
q01 = t02 + t03
t11 = q03
t04 = x00
q05 = t10 + t11
t05 = x02
t12 = q04
q02 = t04 × t05
t13 = q05
t06 = x01
q06 = t12 × t13
t07 = q02
t14 = q06
Fig. 2.
Our provably optimal implementation of CTC2 S-box with Gate
Complexity 6.
Lemma 6: The Gate Complexity (GC) of CTC S-box is
exactly 6 (allowing XOR,OR,AND,NOT,NAND,NOR,NXOR)
(cf. Figure 3)
Proof: Straight-Line Program for CTC2 S-box w.r.t Gate
Complexity
t00 = x01
q03 = t06 + t07
t01 = x00
t08 = q03
q00 = t00 × t01 + t00 + t01 + 1 t09 = q01
t02 = x02
q04 = t08 × t09
t03 = q00
t10 = q00 + q04
q01 = t02 + t03
t11 = x00
t04 = q01
q05 = t10 + t11
t05 = x00
y0 = q01
q02 = t04 × t05 + 1
y1 = q03
t06 = q02
y2 = q05
t07 = x01
Fig. 3.
Our provably optimal implementation of CTC2 S-box with Bitslice
Gate Complexity 8.

173
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Lemma 7: The NAND Complexity (NC) of CTC S-box is
exactly 12 (only NAND gates and constants) (cf. Figure 4)
Proof: Straight-Line Program for CTC2 S-box w.r.t Bit-
slice Complexity
m00 = x00
m10 = q05
m01 = x01
t12 = x02
m02 = x02
t13 = m10
m03 = x00
q06 = t12 × t13 + 1
m04 = x01
m11 = q06
t00 = m03
t14 = x00
t01 = m02
t15 = m09
q00 = t00 × t01 + 1
q07 = t14 × t15 + 1
m05 = q00
m12 = q07
t02 = m05
t16 = m08
t03 = m01
t17 = m12
q01 = t02 × t03 + 1
q08 = t16 × t17 + 1
m06 = q01
m13 = q08
t04 = m06
t18 = m10
t05 = x02
t19 = m09
q02 = t04 × t05 + 1
q09 = t18 × t19 + 1
m07 = q02
m14 = q09
t06 = m06
t20 = m12
t07 = m07
t21 = m13
q03 = t06 × t07 + 1
q10 = t20 × t21 + 1
m08 = q03
m15 = q10
t08 = m06
t22 = m15
t09 = m04
t23 = m11
q04 = t08 × t09 + 1
q11 = t22 × t23 + 1
m09 = q04
m16 = q11
t10 = m05
y0 = m16
t11 = m06
y1 = m14
q05 = t10 × t11 + 1
y2 = m13
Fig. 4.
Our provably optimal implementation of CTC2 S-box with NAND
Complexity 12.
Proof: (Complimentary Optimality Proof)
Unlike the great majority of circuit optimizations, needed
each time a given cipher is implemented in hardware, our
results are exact. They are obtained by solving the problem
at a given gate count k, the SAT solver outputs SAT and a
solution, and if for k-1 gates the SAT solver is good enough
and fast enough, it will output UNSAT and we obtain a proven
lower bound, a rare thing in complexity.
B. Optimizing the PRESENT S-box
In this section we apply our methodology for optimal circuit
representations with respect to bitslice implementation metric
for the PRESENT S-box deﬁned as,
{12, 5, 6, 11, 9, 0, 10, 13, 3, 14, 15, 8, 4, 7, 1, 2} [26].
In Figure 5, we present a circuit implementation of it with
MC 4 (i.e., using only 4 AND gates) and we prove that this
circuit implementation is optimal with respect to the AND
gates.
Lemma 8: The MC of the PRESENT S-box is exactly 4.
Proof: Initially, we encoded the problem using 3 AND
gates and our thoroughly designed and tested system outputs
UNSAT. This could be converted to a formal proof that the
MC is at least 3. For 4 AND gates, our system outputs SAT
and a solution. This can be seen as a software proof.
Further optimization of the linear part, which is also optimal
as we also obtained UNSAT for lower numbers, allowed us to
minimize the number of XORs to the strict minimum possible
(prove by additional UNSAT results).
As a result, for we have obtained an implementation of
the PRESENT S-box with 25 gates in total: 4 AND, 20
XOR, 1 NOT, which is optimal w.r.t our Boyar-Peralta 2-step
methodology, which is as follows: In overall gate complexity
since 25 gates are still not satisfactory.
Straight-Line Program for PRESENT S-box w.t.r Bit-slice
Complexity
u00 = x3 + x1
t00 = x4
y1 = p02 + u02
u01 = u00 + 1
t01 = u05
y2 = v01 + u06
u02 = x1 + x4
p00 = t00 × t01
y3 = v03 + u07
u03 = u01 + x4
t02 = p00 + u3
y4 = v00 + x2
u04 = x3 + x2
t03 = p00 + x2
u05 = u04 + x4
p01 = t02 × t03
u06 = u03 + x2
t04 = u04
u07 = u06 + u00
t05 = x3
u08 = x1 + u03
p02 = t04 × t05
t06 = u02 + u08
t07 = p02 + u01
p03 = t06 × t07
v00 = p03 + p00
v01 = p03 + p02
v02 = p00 + p02
v03 = v02 + p01
A better result in terms of gate complexity can be achieved
by the following method: we observe that AND gates and
OR gates are afﬁne equivalents, and it is likely that if we
implement certain AND gates with OR gates, we might be
able to further reduce the overall complexity of the linear
parts. We may try all possible 24 cases where some AND
gates are implemented with OR gates. Even better results can
be obtained if we consider also NOR and NAND gates. By
this method, starting with the right optimization with MC=4,
as several such optimizations may exist, we can obtain the
following new implementation of the PRESENT S-box which
requires only 14 gates total.

174
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Fig. 5.
Our provably optimal Bitslice-type implementation of PRESENT
S-box with 14 gates.
Applications. This implementation is used in our recent
bit-slice implementation of PRESENT, see [15]. In addition,
we postulate that this implementation of the PRESENT S-
box is in certain sense optimal for DPA-protected hardware
implementations with linear masking, as it minimizes the
number of non-linear gates (there are only 4 such gates).
Discussion. Our best optimisation of the PRESENT S-box
seems to conﬁrm the Boyar-Peralta heuristic to the effect that
some of the best possible gate-efﬁcient implementations are
very closely related to the notion of MC. However, the most
recent implementations of the AES S-box, in the second paper
by Boyar and Peralta, show that further improvements, and
also circuit depth improvements, can be achieved also by
relaxing the number of ANDs used as in the latest optimization
of the 4-bit inverse in GF(24) for AES given on Figure 1 in
[6].
C. Optimal Representations of GOST S-boxes
In this section, we apply our automated methodology
encode-and-then-solve for obtaining optimal circuit represen-
tations of the 8 S-boxes S1 − S8 of GOST block cipher with
respect to the number of AND gates.
GOST block cipher has a simple 32-round Feistel structure,
which encrypts a 64-bit block using a 256-bit key deﬁned
in the standard GOST 28147-89 [27]. We consider the main
standard and most widely known version of the GOST block
cipher, known as ”GostR3411 94 TestParamSet”, also known
as the one used by the Central Bank of the Russian Federation,
and 7 additional versions which are found in the OpenSSL
source code.
We have obtained for all these versions optimal represen-
tations with respect to the number of AND gates and these
results are summarized in Table II.
Lemma 9: The MC of the eight S-boxes of GOST cipher
S1-S8 and for 8 principal known version of GOST as speciﬁed
in OpenSSL are EXACTLY equal to the values given on Table
II.
Further work. With suitable encoding for other compo-
nents, and in particular for the addition modulo 232 in GOST
cipher, we are potentially able to provably minimize the
number of non-linear gates in a whole cipher to a (proven)
lower bound. We can obtain very compact algebraic encodings
of GOST which can used for algebraic cryptanalysis, see [4],
[13].
TABLE II
MC FOR ALL KNOWN GOST S-BOXES
S-box Set Name
S1
S2
S3
S4
S5
S6
S7
S8
GostR3411 94 TestParamSet
4
5
5
5
5
5
4
5
GostR3411 94 CryptoProParamSet
4
5
5
4
5
5
4
5
Gost28147 TestParamSet
4
4
4
4
4
5
5
5
Gost28147 CryptoProParamSetA
5
4
5
4
4
4
5
5
Gost28147 CryptoProParamSetB
5
5
5
5
5
5
5
5
Gost28147 CryptoProParamSetC
5
5
5
5
5
5
5
5
Gost28147 CryptoProParamSetD
5
5
5
5
5
5
5
5
GostR3411 94 SberbankHashParamset
4
4
4
5
5
4
4
4
The better the optimizations obtained, the more compact
the representation we get for a given cipher, and heuristically
this leads to better algebraic attacks. This provides additional
motivation for our work. Such compact representations can be
combined with several complexity reduction and differential
attacks to obtain attacks again full rounds of GOST.
D. Optimization of the Majority Function
The Majority function is a function of the form Fn
2 → F2,
which is False when n
2 of its inputs are false and vice versa
for True. It is a highly non-trivial task to obtain circuit
representations with optimal MC in the case when n is odd.
Using our 2-step automated procedure we have been able
to ﬁnd optimal circuit representation for the Majority function
in cases when n = 3, 5, 7.
Lemma 10: The MC for the Majority Function when n = 3
is 1 (cf. Figure 6)
Proof: Using our methodology we have obtained the
following circuit representation.
t0 = x0 ⊕ x2, t1 = x0 ⊕ x1
q0 = t0 ∧ t1, q1 = q0 ⊕ x1
Lemma 11: The MC for the Majority Function when n = 5
is 3 (cf. Figure 7)
Proof: Using our methodology we have obtained the
following circuit representation.
k0 = x0 ⊕ x1, k1 = x3 ⊕ x4, t0 = k0 ⊕ k1,
t1 = x1 ⊕ x2, q0 = t0 ∧ t1, t2 = x0 ⊕ x3,
q1 = k1 ∧ t2, k2 = k1 ⊕ t2, t3 = q1 ⊕ k2,
k3 = x2 ⊕ x4, t4 = q0 ⊕ k3, q2 = t3 ∧ t4,
o0 = q2 ⊕ x4

175
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Fig. 6.
Circuit Representation of Majority function on 3 inputs with optimal
MC=1
Fig. 7.
Circuit Representation of Majority function on 5 inputs with optimal
MC=3
Lemma 12: The MC for the Majority Function when n = 7
is 4 (cf. Figure 8)
Proof: Using our methodology we have obtained the
following circuit representation. We have obtained a circuit
with 23 gates in total: 4 AND gates, 1 NOT gate and 18 XOR
gates.
t0 = x0 ⊕ x1, t1 = x0 ⊕ x2, q0 = t0 ∧ t1,
t2 = x4 ⊕ x5, t3 = x3 ⊕ x4, q1 = t2 ∧ t3,
p0 = q0 ⊕ q1, k0 = x1 ⊕ x2, k1 = x4 ⊕ x6,
k2 = x3 ⊕ x5, l0 = k0 ⊕ k1, l1 = p0 ⊕ l0,
t4 = l1 ⊕ 1, t5 = k1 ⊕ k2, q2 = t4 ∧ t5,
k3 = x0 ⊕ x4, t6 = p0 ⊕ k3, p1 = q0 ⊕ q2,
k4 = x0 ⊕ x6, t7 = p1 ⊕ k4, q3 = t6 ∧ t7,
p2 = q0 ⊕ q3, o0 = p2 ⊕ x0
Fig. 8.
Circuit Representation of Majority function on 7 inputs with optimal
MC=4
VI. CONCLUSION
The construction of efﬁcient computational circuits and
the optimization of arbitrary algebraic computations over
ﬁelds and rings in the general non-commutative setting is
considered as one of most important problems in computer
science, applied mathematics and the industry. It has numerous
applications in improving various linear/polynomial/graph/lan-
guage/cryptographic algorithms and an important footprint in
many current applications. For example, in improving basic
all-purpose linear algebra routines or in efﬁcient implementa-
tion of important cryptographic algorithms, which are used in
countless software (and hardware) systems.
In this paper, we studied two fundamental problems in the
area of computational complexity. The notion of MC which
minimizes the number of elementary non-linear operations
(AND gates), and more general problems of gate complexity
under almost any circuit complexity ”metric”, for example
MC, gate count w.r.t. a speciﬁc set of gates, circuit depth,
circuit width, etc. Following the heuristic of Boyar-Peralta,
we used MC as an essential tool for optimizing potentially
arbitrary algebraic computations over ﬁelds and rings and in
particular for binary circuits. Additionally, we focused on the
combinatorial logic optimization of general digital circuits
with particular attention to small substitution boxes (S-boxes),
which are massively used in the industrial cryptographic
schemes and which are small enough for some very advanced
methods to be invented. Thus, in many cases we managed to
obtain optimal results which can no longer be improved, and
we have a formal mathematical proof of these claims by an
automated software proof technique with a SAT solver.
We have developed a fully automated procedure for obtain-
ing new formulas for Matrix Multiplication (MM) problems,
complex multiplication problems, multiplication of quater-
nions and for construction of optimal circuit representations
with any given Boolean functions, with respect to any given
set of basic gates. Our methodology consists of three main
steps. In the ﬁrst step, we formally encode these problems as
polynomial equations, then convert them into a SAT problem
using the Courtois-Bard-Jefferson [7] or other methods and
then we solve these problems using SAT solver software. Thus,
we have been able to ﬁnd new formulas for multiplying two
3 × 3 matrices using 23 2-input multiplications [11] and also
multiplying a 2 × 2 matrix by a 2 × 3 matrix using only
11 multiplications, naive multiplication needs 12. We have
been able to construct several optimal circuit representations
for the S-box of CTC2 cipher [3] with respect to its MC,
Bitslice Gate Complexity, Gate Complexity and NAND Gate
Complexity. Additionally, we constructed an optimal circuit
representation with 14 gates for the PRESENT S-box, which
is the best currently known [15] and we computed the exact
MC of the 8 S-boxes S1-S8 used in the GOST cipher. The
amazing thing is that our methodology can ﬁnd EXACT circuit
representations (which is very hard to obtain in the area of
computational complexity). This is if our SAT solvers used
in the ﬁnal solving stage are complete (in a sense that they
are fast enough and output UNSAT if the problem has no
solution). In future works, we need to address the questions
of what form or language such automated proofs could be
output, shared and published.
Cryptography is always very costly, and a lot of effort
is always done in order to improve the implementation of
any given cipher [5], [6]. To the best of our knowledge

176
International Journal on Advances in Intelligent Systems, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
provably optimal circuits have never been found before for
any cryptographic algorithm, and optimal digital circuits have
never been yet used in industrial applications. Interestingly,
if a cryptographic algorithm such as AES which tends to
be present nowadays in more or less every major CPU [5]
could be implemented in a provably optimal way (or at
least it would be optimal for smaller components like in the
present paper), people in the industry would no longer need
to make their designs proprietary. The best digital designs
could be developed at universities and licensed or offered to
the worldwide industry or jointly developed by cooperative
industrial consortia to beneﬁt every company small and large.
Thus, the (large) computational cost and research effort needed
to develop such top-end (excessively good) implementations
and optimizations could be amortized and justiﬁed.
ACKNOWLEDGMENT
This research was supported by the UK Technology Strategy
Board in the United Kingdom under project 9626-58525.
REFERENCES
[1] N.T. Courtois, D. Hulme, and T. Mourouzis, ”Multiplicative Complexity
And Solving Generalized Brent Equations With SAT Solvers,” in COM-
PUTATION TOOLS 2012, in the Third International Conference on Com-
putational Logics, Algebras, Programming, Tools, and Benchmarking, pp.
22-27, 2012.
[2] J. Patarin, N. Courtois, and L. Goubin, ”Improved Algorithms for Iso-
morphism of Polynomials,” in Advances in CryptologyEUROCRYPT’98,
pp. 184-200, Springer Berlin Heidelberg, 1998.
[3] N.T. Courtois, D. Hulme, and T. Mourouzis, ”Solving Circuit Optimisa-
tion Problems in Cryptography and Cryptanalysis,” in Proceedings of 2nd
IMA Conference Mathematics in Defence, UK, Swindon, 2011.
[4] N.T. Courtois, D. Hulme, and T. Mourouzis, ”Solving Circuit Optimisa-
tion Problems in Cryptography and Cryptanalysis.” in IACR Cryptology
ePrint Archive 2011, Report 475,2012.
[5] J. Boyar, P. Matthews, and R. Peralta, ”Logic Minimization Techniques
with Applications to Cryptology,” Journal of Cryptology, vol. 26, p. 280-
312, 2013.
[6] J. Boyar, and R.Peralt, ”A depth-16 circuit for the AES S-box,” in IACR
Cryptology ePrint Archive, Report 33,2011.
[7] G.V. Bard, N.T. Courtois, and C. Jefferson, ”Efﬁcient Methods for
Conversion and Solution of Sparse Systems of Low-Degree Multivariate
Polynomials over GF(2) via SAT-Solvers, ”ECRYPT workshop Tools for
Cryptanalysis, 2007.
[8] N. Sorensson, and N. Een, ”Minisat v1. 13-a sat solver with conﬂict-
clause minimization,” SAT journal pp. 53-59, 2005.
[9] R. Brent, ”Algorithms for matrix multiplication,” Tech. Report Report
TR-CS-70-157 , Department of Computer Science, Stanford, 1970.
[10] C. Fuhs, and P. Schneider-Kamp, ”Synthesizing Shortest Linear Straight-
Line Programs over GF(2) Using SAT,” in SAT 2010, Theory and
Applications of Satisﬁability Testing, Springer LNCS 6175, pp. 71-84,
2010.
[11] N.T. Courtois, G.V. Bard, and D. Hulme, ”A New General-Purpose
Method to Multiply 3x3 Matrices Using Only 23 Multiplications,” in
arXiv preprint arXiv:1108.2830, 2011.
[12] N. T. Courtois, and G. Bard, ”Algebraic Cryptanalysis of the Data En-
cryption Standard,” in Cryptography and Coding, 11-th IMA Conference,
pp. 152-169, LNCS 4887, Springer, 2007.
[13] N.T. Courtois, ”Algebraic Complexity Reduction and Cryptanalysis of
GOST,” in IACR Cryptology ePrint Archive, Report 626, 2011.
[14] A. Edelman, ”Large Dense Numerical Linear Algebra in 1994 (survey),”
Journal of Supercomputer Applications. Vol. 7, p. 113128, 1993.
[15] M. Albrecht, N.T. Courtois, D. Hulme,
and G. Song, ”Bit-Slice
Implementation of PRESENT in pure standard C,” Available online at
www.nicolascourtois.com, 2011.
[16] E. Prouff, C. Giraud, and S. Aumonier, ”Provably Secure S-Box Imple-
mentation Based on Fourier Transform,” in CHES 2006, Springer LNCS
4249, pp. 216-230, 2006.
[17] G. Bard, ”Algorithms for Solving Linear and Polynomial Systems
of Equations over Finite Fields with Applications to Cryptanalysis,”
Submitted in Partial Fulﬁllment for the degree of Doctor of Philosophy
of Applied Mathematics and Scientiﬁc Computation, 2007.
[18] M. Soos, ”CryptoMiniSat 2.5.0,”in SAT Race competitive event booklet,
2010.
[19] S. Dasgupta, C. Papadimitriou, and U. Vazirani, ”Algorithms,” 2nd
Edition, 2006.
[20] V. Strassen, ”Gaussian elimination is not optimal,” in Numerische
Mathematik Vol 13 pp. 354-356, 1969.
[21] D. Coppersmith, and S.Winograd, ”On the asymptotic complexity of
matrix multiplication,” SIAM Journal Comp., Vol 11, pp 472-492 , 1980.
[22] J.D. Laderman, ”A Non-Commutative Algorithm for Multiplying 3x3
Matrices Using 23 Multiplications,” in Amer. Math. Soc. Vol. 82, Number
1, 1976.
[23] H. Cohn, R. Kleinberg, B. Szegedyz, and C. Umans, ”Grouptheoretic
Algorithms for Matrix Multiplication,” in FOCS05, 46th Annual IEEE
Symposium on Foundations of Computer Science, pp. 379-390, 2005.
[24] J. Boyar, and R. Peralta, ”A New Combinational Logic Minimization
Technique with Applications to Cryptology,” in SEA 2010, pp. 178-189,
2009.
[25] J. Boyar, P. Matthews, and R. Penalta, ”On the Shortest Linear Straight-
Line Program for Computing Linear Forms,” in Mathematical Founda-
tions of Computer Science 2008, pp. 168-179, Springer Berlin Heidelberg,
2008.
[26] A. Bogdanov, L.R. Knudsen, G. Leander, C. Paar, A. Poschmann, and
M.J.B. Robshaw,”PRESENT: An Ultra-Lightweight Block Cipher,” in
CHES 2007, LNCS 4727, pp. 450-466, Springer, 2007.
[27] A. Poschmann, S. Ling, and H. Wang, ”256 Bit Standardized Crypto
for 650 GE GOST Revisited,” in CHES 2010, LNCS 6225, pp. 219-233,
2010.

