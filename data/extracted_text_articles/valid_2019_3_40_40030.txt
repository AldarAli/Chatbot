Reﬁnement Maps for Insulin Pump Control Software Safety Veriﬁcation
Eman M. Al-qtiemat∗, Sudarshan K. Srinivasan∗, Zeyad A. Al-Odat∗, Sana Shuja†
∗Electrical and Computer Engineering, North Dakota State University,
Fargo, ND, USA
†Department of Electrical Engineering, COMSATS University,
Islamabad, Pakistan
Emails: ∗eman.alqtiemat@ndsu.edu, ∗sudarshan.srinivasan@ndsu.edu, ∗zeyad.alodat@ndsu.edu,
†SanaShuja@comsats.edu.pk
Abstract—Reﬁnement-based veriﬁcation is a formal veriﬁcation
technique that has shown promise to be applicable for veriﬁcation
of low-level real-time embedded object code. In reﬁnement-
based veriﬁcation, both the implementation (the artifact to be
veriﬁed) and the speciﬁcation are modeled as transition systems,
which essentially capture the states of the system and transitions
between the states. A key step in the veriﬁcation process is the
construction of a reﬁnement map, which is a function that maps
implementation states onto speciﬁcation states. Construction of
reﬁnement maps is most often done manually and requires
key insights about how the implementation and speciﬁcation
behave. In this paper, we develop reﬁnement maps for various
safety properties concerning the software control operation of
insulin pumps. We then identify possible generic templates for
construction of reﬁnement maps as a ﬁrst step towards developing
a process to construct reﬁnement maps in an automated fashion.
Keywords–Formal veriﬁcation; safety-critical devices; Reﬁne-
ment maps; Reﬁnement-based veriﬁcation.
I.
INTRODUCTION
One of the key issues in designing safety-critical embed-
ded systems such as medical devices is software safety [1].
For example, infusion pumps (a medical device that delivers
medication such as pain medication, insulin, cancer drugs etc.,
in controlled doses to patients intravenously) has 54 class 1
recalls related to software issued by the US Food and Drug
Administration (FDA) [2]. Class 1 means that the use of the
medical device can cause serious adverse health consequences
or death.
Despite the fact that testing is the dominant veriﬁcation
technique currently used in commercial design cycles [3],
testing can only show the presence of faults, but it never proves
their absence [4]. Alternate veriﬁcation processes should be
applied to the software design in conjunction with testing to as-
sure system correctness and reliability. Formal veriﬁcation can
address testing limitations by providing proofs of correctness
for software safety. Intel [5], Microsoft [6] and [7], and Airbus
[8] have successfully applied formal veriﬁcation processes.
Reﬁnement-based veriﬁcation [9] is a formal veriﬁcation
technique that has been demonstrated to be effective for veri-
ﬁcation of software correctness at the object code level [10].
To apply reﬁnement-based veriﬁcation, software requirements
should be expressed as a formal model. Previously, we have
proposed a novel approach to synthesize formal speciﬁcations
from natural language requirements [11], and in a later work,
we have also addressed timing requirements and speciﬁca-
tions [12].
Our veriﬁcation approach is based on the theory of Well-
Founded Equivalence Bisimulation (WEB) reﬁnement [9]. In
the context of WEB reﬁnement, both the implementation and
speciﬁcation are treated as Transition Systems (TSs). If every
behavior of the implementation is matched by a behavior of the
speciﬁcation and vice versa, then the implementation behaves
correctly as prescribed by the speciﬁcation. However, this is
not easy to check in practice as the implementation TS and
speciﬁcation TS can look very different. The speciﬁcation
states obtained from the software requirements are marked
with atomic propositions (predicates that are true or false in
a given state). The implementation states are states of the
microcontroller that the object code program modiﬁes. As
such, the microcontroller states includes registers, ﬂags, and
memory. The various possible values that these components
can have during the execution of the object code program gives
rise to the many millions of states of the implementation. To
overcome this difference, WEB reﬁnement uses the concept
of a reﬁnement map, which is a function that provided an
implementation state, gives the corresponding speciﬁcation
state. Historically, one of the reasons that reﬁnement-based
veriﬁcation is much less explored than other formal veriﬁcation
paradigms such as model checking is that the construction
of reﬁnement maps often requires deep understanding and
intuitions about the speciﬁcation and implementation [13].
However, once a reﬁnement map is constructed, the beneﬁt is
that reﬁnement-based veriﬁcation is a very scalable approach
for dealing with low-level artifacts such as real-time object
code veriﬁcation. This paper studies reﬁnement maps corre-
sponding to formal speciﬁcations related to infusion pump
safety and proposes possible generic reﬁnement map templates,
which is the ﬁrst step toward automating the construction of
reﬁnement maps.
The remainder of this paper is organized as follows.
Section II summarizes background information. Section III
details related work. Section IV describes the reﬁnement maps
and reﬁnement map templates. Conclusions and direction for
future work are noted in Section V.
II.
BACKGROUND
This section explores the deﬁnition of transition systems,
the deﬁnition of reﬁnement-based veriﬁcation, and the synthe-
sis of formal speciﬁcations as key terms related to our work.
A. Transition Systems
As stated earlier, transition systems (TSs) are used to
model both speciﬁcation and implementation in reﬁnement-
based veriﬁcation. TSs are deﬁned below.
56
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

Deﬁnition 1: A TS M = ⟨S, R, L⟩ is a three tuple in
which S denotes the set of states, R ⊆ SXS is the transition
relation that provides the transition between states, and L is a
labeling function that describes what is visible at each state.
States are marked with Atomic Propositions (APs), which
are predicates that are true or false in each state. The labeling
function maps states to the APs that are true in every state.
An example TS is shown in Figure 1. Here S = {S1, S2, S3,
S4}, R = {(S1, S2), (S2, S4), (S4, S3), (S3, S4), (S3, S2),
(S1, S3)} and, L(S2) represents the atomic propositions that
are true for the S2 state.
S1
S3
S2
S4
Figure 1. An example of a transition system (TS).
B. Reﬁnement-Based Veriﬁcation
Our veriﬁcation process is based on the theory of Well-
Founded Equivalence Bisimulation reﬁnement. A detailed de-
scription of this theory can be found in [9]. Here, we give a
very high-level overview of the key concepts. As stated earlier,
WEB reﬁnement provides a notion of correctness that can be
used to check an implementation TS against a speciﬁcation
TS. One of the key features is that WEB reﬁnement accounts
for stuttering, which is the phenomenon where multiple but
ﬁnite transitions of the implementation can match a single
transition of the speciﬁcation. This is a very key feature
because the control code implements many functions and
only some of these functions maybe relevant to the safety
property being veriﬁed. Therefore, the code maybe doing a
number of things that do not relate to the property and will
therefore be stuttering a lot w.r.t. the speciﬁcation. Another key
feature of WEB reﬁnement is reﬁnement maps, which is the
focus of this work. Reﬁnement maps are functions that map
implementation states to speciﬁcation states. There is a lot of
ﬂexibility in how reﬁnement maps can be deﬁned. This allows
for low-level implementations to be veriﬁed against high-level
speciﬁcations.
Deﬁnition 2: (WEB Reﬁnement): Let M
= ⟨S, R, L⟩,
M ′ = ⟨S′, R′, L′⟩, and r: S → S’. M is a WEB reﬁnement of
M ′ with respect to reﬁnement map r, written M ≈ r M ′, if
there exists a relation, B, such that ⟨ ∀ s ∈ S :: sB(r.s)⟩ and
B is a WEB on the TS ⟨ S ⊎ S’, R ⊎ R’, L ⟩, where L.s =
L’(s) for s and S’ state and L.s = L’(r.s) otherwise.
C. Synthesis of Formal Speciﬁcations
Our approach for development and study of reﬁnement
maps is based on the formal TS speciﬁcations. We have devel-
oped a previous approach to transform functional requirements
into formal speciﬁcations [11]. Since this work is closely tied
to the prior work, we brieﬂy review it here. The transformation
procedure is as follows: The ﬁrst step of computing the
TSs is to extract the APs from the requirements. We have
developed three Atomic Proposition Extraction Rules (APERs)
that work on the parse tree of the requirement obtained from
an English language parser called Enju. A high-level procedure
for speciﬁcation transition system synthesis has been proposed
to compute the states and transitions using the resulting list of
APs under expert user supervision. Figure 2 summarizes the
main steps of the synthesizing procedure.
Natural 
Language 
Requirement/s
Parse Tree
Formal 
specification 
(TS)
APs List
   
Enju Parser
APERs
Formal Model 
Synthesis Procedure
Figure 2. Formal Model synthesis procedure for Functional Requirements.
III.
RELATED WORK
This section summarizes a few works on applying re-
ﬁnement processes to get more concrete speciﬁcations and
reﬁnement-based veriﬁcation. None of these works are applied
to insulin pump formal speciﬁcations as our work. To the best
of our knowledge, these are the most related state of art in this
area of study.
Klein et al. [14] introduced a new technique called State
Transition Diagrams (STD). It is a graphical speciﬁcation
technique that provides reﬁnement rules, each rule deﬁnes an
implementation relation on STD speciﬁcation. The proposed
approach was applied to the feature interaction problem. The
reﬁnement relation was utilized to add a feature or to deﬁne
the notion of conﬂicting features.
Rabiah et al. [15] developed a reliable autonomous robot
system by addressing A* path planning algorithm reliability
issue. A reﬁnement process was used to capture more concrete
speciﬁcations by transforming High-Level speciﬁcation into
equivalent executable program. Traditional mathematical con-
cepts were used to capture formal descriptions.Then, Z spec-
iﬁcation language was employed to transform mathematical
description to Z schemas to get formal speciﬁcations. Z formal
reﬁnement theory was used to obtain the implementation
speciﬁcation.
Spichkova [16] proposed a reﬁnement-based veriﬁcation
scheme for interactive real time systems. The proposed work
solves the mistakes that rise from the speciﬁcation problems
by integrating the formal speciﬁcations with the veriﬁcation
system. The proposed scheme translates the speciﬁcations to a
higher-order logic, and then uses the theorem prover (Isabelle)
to prove the speciﬁcations. Using the reﬁnement-based veriﬁ-
cation, this scheme validates the reﬁnement relations between
two different systems. The proposed design was tested and
veriﬁed using a case study of electronic data transmission
gateway.
57
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

A new approach that focuses on the reﬁnement veriﬁcation
using state ﬂow charts has been presented by Miyazawa et al.
[17]. They proposed a reﬁnement strategy that supports the
sequential C implementations of the state ﬂow charts. The
proposed design beneﬁted from the architectural features of
model to allow a higher level of automation by retrieving the
data relation in a calculation style and rendering the data into
an automated system. The proposed design was tested and
veriﬁed using Matlab Simulink SDK. Through the provided
case study, the scheme was able to be scaled to different state
charts problems.
Cimatti et al. proposed a contract-reﬁnement scheme for
embedded systems [18]. The contract-reﬁnement provides
interactive composition reasoning, step-wise reﬁnement, and
principled reuse reﬁnements for components for the already
designed or independently designed components. The proposed
design addresses the problem of architectural decomposition of
embedded systems based on the principles of temporal logic to
generate a set of proof obligations. The testing and veriﬁcation
of the Wheel Braking System (WBS) case study show that the
proposed design can detect the problems in the architectural
design of the WBS.
Bibighaus [19] employed the Doubly Labeled Transition
Systems (DLTS) to reason about possibilities security prop-
erties and reﬁnement. This work was compared with three
different security frameworks when applied to large class
systems. The reﬁnement framework in this work preserves and
guarantees the liveness of the model by verifying the timing
parameter of the model. The analysis results show that the
proposed design preserves the security properties to a series
of availability requirements.
IV.
REFINEMENT MAPS AND REFINEMENT MAP
TEMPLATES
Figures 3-9 show the formal TS speciﬁcation for 8 insulin
pump safety requirements and the reﬁnement map we have
developed corresponding to each speciﬁcation TS. The formal
TS speciﬁcations were developed as part of our previous work
in this area [11] [12]. As can be seen from the ﬁgures, each
TS consists of a set of states and the transitions between the
states. Also, each state is marked with the atomic propositions
that are true in the state.
Our strategy for constructing the reﬁnement maps is as
follows. A speciﬁcation state can be constructed from an
implementation state by determining the APs that are true in
the implementation state. If a speciﬁcation has n APs, then we
construct one predicate function for each AP. The predicate
functions take the implementation state as input and output a
predicate value that indicates if the AP is true in that state
or not. Thus, the collection of such predicate functions is the
reﬁnement map.
We next discuss the reﬁnement map for the speciﬁcation in
Figure 3. The safety speciﬁcation from [20] is as follows: ”The
pump shall suspend all active basal delivery and stop any active
bolus during a pump prime or reﬁll. It shall prohibit any insulin
administration during the priming process and resume the
suspended basal delivery, either a basal proﬁle or a temporary
basal, after the prime or reﬁll is successfully completed.” The
APs corresponding to this safety requirement are (1) BO: active
bolus delivery; (2) BA: active basal delivery; (3) P: priming
process; and (4) R: reﬁll process. The reﬁnement map however
has to account for what is happening in the implementation
code and relate that to the atomic propositions.
The predicate function for BO uses several variables from
the code including NB: Normal Bolus and EB: Extended Bolus
as there are more than one type of Bolus dose supported by the
system. So the AP BO should be true if there is a NB or an EB.
NB is only a ﬂag that indicates that a normal bolus should be in
progress. The actual bolus itself will continue to occur as long
as a counter that keeps track of the bolus has not reached its
maximum value. Therefore, for example for a normal bolus,
we use a conjunction of NB and the condition that the NB
counter (NBc) is less than its possible maximum value (NBm).
We use a similar strategy for the extended bolus as well. This
reﬁnement map template works for all processes similar to a
Bolus dosage delivery, such as basal dosage delivery, priming
process, and reﬁll process. Therefore, we term this reﬁnement
map template as ”process template.” For the basal dosage (BA
AP) a number of basal proﬁles (BPs) are possible that accounts
for BP1 thru BPn. TB stands for temporary basal. As can be
noted from Figures 4-9, the process template accounts for a
large number of predicate functions corresponding to APs.
The second reﬁnement map template is a simple one called
the ”projection template,” which is used when the AP in the
speciﬁcation TS corresponds directly to a variable in the code.
An example of the projection template can be found in Figure
4, where the User Reminder (UR) AP is mapped directly
from a ﬂag variable in the code that corresponds to the user
reminder. A variation of this template is a boolean expression
of Boolean variables in the code. An example of such an AP
is the UIP AP in Figure 8.
The third reﬁnement map template is called the ”value
change template,” which is used when the AP is true only
when a value has changed. An example use of this template
can be found in Figure 4 for the CDTC AP. CDTC corresponds
to the change in drug type and concentration and is true when
the drug type or concentration is changed. For the drug type
change, DT is the variable that corresponds to the drug type.
The question here is how to track that a value has changed. The
idea is to use history variables. HDT is a history variable that
corresponds to the history of the drug type, i.e., the value of
the drug type in the previous cycle. If HDT is not equal to DT
in a code state, then we know the drug type has changed. The
inequality of HDT and DT is used to construct the predicate
function. For all the safety requirements analyzed, these three
reﬁnement map templates cover all the APs. Table 1 gives the
expansions for all the abbreviations used in Figures 3-9, so
that the corresponding reﬁnement maps can be comprehended
by the reader.
V.
CONCLUSION AND FUTURE WORK
In this paper, we have developed reﬁnement maps corre-
sponding to the speciﬁcation TSs of several infusion pump
safety requirements. This is a ﬁrst step in automating the
construction of reﬁnement maps. Our eventual goal is to
develop a process for the construction of reﬁnement maps.
The reﬁnement maps from this paper will be used as bench-
marks to study and develop generic reﬁnement map templates.
Heuristics will be developed based on the output of the Enju
parser to select a reﬁnement map template for each atomic
proposition. The development and testing of this process is
part of future work.
58
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

P
BO
BA
R
• BO = [NB ∧ (NBc < NBm)] ∨ [EB ∧ (EBc < EBm)]
• P = P ∧ (Pc < Pm)
• R = R ∧ (Rc < Rm)
• BA = [BP1 ∧ (BP1c < BP1m)] ∨ [BP2 ∧ (BP2c < BP2m)] ∨ ...∨
[BPn ∧ (BPnc < BPnm)] ∨ [TB ∧ (TBc < TBm)]
Figure 3. A formal presentation of requirement 1.1.1 from [20] and the suggested reﬁnement maps.
AI
RTV R
UR
CDTC
• AI = [BP1 ∧ (BP1c < BP1m)] ∨ [BP2 ∧ (BP2c < BP2m)] ∨ ...∨
[BPn ∧ (BPnc < BPnm)] ∨ [TB ∧ (TBc < TBm)] ∨ [NB ∧ (NBc
< NBm)] ∨ [EB ∧ (EBc < EBm)]
• CDTC = (DT ̸= HDT) ∧ (CDTCc < CDTCm)
• UR = FLAG
• RTVR = (CRV ̸= HRV) ∧ (RTV Rc < RTV Rm)
Figure 4. A formal presentation of requirement 1.1.3 from [20] and the suggested reﬁnement maps.
IBO
INDV
SPM
SY NC
• IBO = [NB ∧ (NBc < NBm)] ∨ [EB ∧ (EBc < EBm)]
• INDV = [BP1 ∧ (BP1c < BP1m)] ∨ [BP2 ∧ (BP2c < BP2m)] ∨ ...∨
[BPn ∧ (BPnc < BPnm)] ∨ [TB ∧ (TBc < TBm)] ∨ [NB ∧ (NBc
< NBm)] ∨ [EB ∧ (EBc < EBm)]
• SMP = [P ∧ (Pc < Pm)] ∨ [R ∧ (Rc < Rm)]
• SYNC = INCAL ∧ (INCALc < INCALm)
Figure 5. A formal presentation of requirement 1.8.2 and 1.8.5 from [20] and the suggested reﬁnement maps.
NB
REQ
ALRT
DNY
• NB = NB ∧ (NBc < NBm)
• REQ = REQ-FLAG
• ALRT = ALRT-FLAG
• DNY = CALL-FUNCT
Figure 6. A formal presentation of requirement 1.3.5 from [20] and the suggested reﬁnement maps.
SET
UCNF
CONC
• SET = CLRS ∨ [CHNS ∧ (CHNSc < CHNSm)] ∨ RESS
• UCNF = FLAG
• CONC = [SETT ∧ (SETTc < SETTm)] ∨ [CHNC ∧ (CHNCc <
CHNCm)]
Figure 7. A formal presentation of requirement 2.2.2 and 2.2.3 from [20] and the suggested reﬁnement maps.
59
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

UIP
WAR
ACT
• UIP = BG ∨ TBG ∨ INCR ∨ CORF
• WAR = FLAG
• ACT = CNFI ∨ [CHNI ∧ (CHNIc < CHNIm)]
Figure 8. A formal presentation of requirement 3.2.5 from [20] followed by the suggested reﬁnement maps.
ELR
ELRF
FWAR
• ELR = [EL ∧ (ELc < ELm)] ∨ [LR ∧ (LRc < LRm)]
• ELRF = ELF ∨ LRF
• FWAR = FLAG
Figure 9. A formal presentation of requirement 3.2.7 from [20] followed by the suggested reﬁnement maps.
TABLE I. LIST OF ABBREVIATIONS
Abbreviation
Meaning
AI
Active Infusion
CDTC
Change Drug Type and Concentration
DT
Data Type
HDT
Historical Data Type
UR
User Reminder
RTVR
Reservoir Time and Volume Recomputed
CRV
Current Reservoir Volume
HRV
Historical Reservoir Volume
REQ-FLAG
Request Flag
CALL-FUNCT
Call-Function for Calculation
INCAL
Insulin Calculations
CLRS
Clear Settings
CHNS
Change Settings
RESS
Reset Settings
BG
Blood Glucose
TBG
Targeted Blood Glucose
INCR
Insulin to Carbohydrate ratio
CORF
Correction Factor
CNFI
Conﬁrm Input
CHNI
Change Input
EL
Event Logging
LR
Log Retrieving
ELRF
Event Logging or Logging Retrieving Failure
ELF
Event Logging Failure
LRF
Logging Retrieving Failure
ACKNOWLEDGMENT
This publication was funded by a grant from the United
States Government and the generous support of the American
people through the United States Department of State and the
United States Agency for International Development (USAID)
under the Pakistan - U.S. Science & Technology Cooperation
Program. The contents do not necessarily reﬂect the views of
the United States Government.
REFERENCES
[1]
B. Fei, W. S. Ng, S. Chauhan, and C. K. Kwoh, “The safety issues
of medical robotics,” Reliability Engineering & System Safety, vol. 73,
no. 2, 2001, pp. 183–192.
[2]
FDA, “List of Device Recalls, U.S. Food and Drug Administration
(FDA),”
2018,
last
accessed:
2019-10-11.
[Online].
Available:
https://www.accessdata.fda.gov/scripts/cdrh/cfdocs/cfRES/res.cfm
[3]
S. Quadri and S. U. Farooq, “Software testing-goals, principles, and
limitations,” International Journal of Computer Applications, vol. 6,
no. 9, 2010, pp. 7–10.
[4]
E. Miller and W. E. Howden, Tutorial, software testing & validation
techniques.
IEEE Computer Society Press, 1981.
[5]
R. Kaivola et al., “Replacing testing with formal veriﬁcation in intel
coretm i7 processor execution engine validation,” in Computer Aided
Veriﬁcation, 21st International Conference, CAV, Grenoble, France,
June 26 - July 2, 2009. Proceedings, pp. 414–429. [Online]. Available:
https://doi.org/10.1007/978-3-642-02658-4\ 32
[6]
T. Ball, B. Cook, V. Levin, and S. K. Rajamani, “SLAM and
static driver veriﬁer: Technology transfer of formal methods inside
microsoft,” in Integrated Formal Methods, 4th International Conference,
IFM, Canterbury, UK, April 4-7, 2004, Proceedings, pp. 1–20. [Online].
Available: https://doi.org/10.1007/978-3-540-24756-2\ 1
[7]
K. Bhargavan et al., “Formal veriﬁcation of smart contracts: Short
paper,” in Proceedings of the 2016 ACM Workshop on Programming
Languages and Analysis for Security.
ACM, 2016, pp. 91–96.
[8]
D. Delmas, E. Goubault, S. Putot, J. Souyris, K. Tekkal, and F. V´edrine,
“Towards an industrial use of ﬂuctuat on safety-critical avionics soft-
ware,” in International Workshop on Formal Methods for Industrial
Critical Systems.
Springer, 2009, pp. 53–69.
[9]
P. Manolios, “Mechanical veriﬁcation of reactive systems,” PhD
thesis, University of Texas at Austin, August 2001, last accessed:
2019-10-04. [Online]. Available: http://www.ccs.neu.edu/home/pete/
research/phd-dissertation.html
[10]
M. A. L. Dubasi, S. K. Srinivasan, and V. Wijayasekara, “Timed reﬁne-
ment for veriﬁcation of real-time object code programs,” in Working
Conference on Veriﬁed Software: Theories, Tools, and Experiments.
Springer, 2014, pp. 252–269.
[11]
E. M. Al-qtiemat, S. K. Srinivasan, M. A. L. Dubasi, and S. Shuja,
“A methodology for synthesizing formal speciﬁcation models from
requirements for reﬁnement-based object code veriﬁcation,” in The
Third International Conference on Cyber-Technologies and Cyber-
Systems.
IARIA, 2018, pp. 94–101.
[12]
E. M. Al-Qtiemat, S. K. Srinivasan, Z. A. Al-Odat, and S. Shuja, “Syn-
thesis of Formal Speciﬁcations From Requirements for Reﬁnement-
based Real Time Object Code Veriﬁcation,” International Journal on
Advances in Internet Technology, vol. 12, Aug 2019, pp. 95–107.
[13]
M. Abadi and L. Lamport, “The existence of reﬁnement mappings,”
Theoretical Computer Science, vol. 82, no. 2, 1991, pp. 253–284.
[14]
C. Klein, C. Prehofer, and B. Rumpe, “Feature speciﬁcation and reﬁne-
ment with state transition diagrams,” arXiv preprint arXiv:1409.7232,
2014.
[15]
E. Rabiah and B. Belkhouche, “Formal speciﬁcation, reﬁnement, and
implementation of path planning,” in 12th International Conference on
Innovations in Information Technology (IIT).
IEEE, 2016, pp. 1–6.
[16]
M. Spichkova, “Reﬁnement-based veriﬁcation of interactive real-time
systems,” Electronic Notes in Theoretical Computer Science, vol. 214,
2008, pp. 131–157.
60
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

[17]
A. Miyazawa and A. Cavalcanti, “Reﬁnement-based veriﬁcation
of sequential implementations of stateﬂow charts,” arXiv preprint
arXiv:1106.4094, 2011.
[18]
A. Cimatti and S. Tonetta, “Contracts-reﬁnement proof system for
component-based embedded systems,” Science of computer program-
ming, vol. 97, 2015, pp. 333–348.
[19]
D. L. Bibighaus, “Applying doubly labeled transition systems to the
reﬁnement paradox,” Naval Postgraduate School Monterey CA, Tech.
Rep., 2005.
[20]
Y. Zhang, R. Jetley, P. L. Jones, and A. Ray, “Generic safety require-
ments for developing safe insulin pump software,” Journal of diabetes
science and technology, vol. 5, no. 6, 2011, pp. 1403–1419.
61
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

