Quantization Errors in Overlapped Block Digital Filtering Methods
Mustafa Daloglu
Dept. of Electrical and Electronics Eng.
Bilkent University
Bilkent, Ankara, Turkey
email: mudaloglu@gmail.com
Erchin Serpedin
Dept. of Electrical and Computer Eng.
Texas A&M University
College Station, Texas, USA
email: serpedin@ece.tamu.edu
Abstract—In digital signal processing applications involving
ﬁltering long sequences, block ﬁltering methods like overlap-
save and overlap-add are widely used. Like all ﬁnite-precision
applications, overlap-save and overlap-add methods are also
affected by quantization errors. The goal of this paper is
to calculate and make a quantitative comparison of the
overall quantization noise resulting from the two methods in
terms of power (variance) of the quantization noise. Multiple
quantization noise sources are taken into consideration in the
computation of the variances. The calculations reveal that the
overlap-add approach is more prone to quantization noise
compared to the overlap-save approach due to the addition
of overlapping sections between overlap-add output blocks.
Keywords-block
ﬁlter;
quantization
noise;
overlap-add;
overlap-save;
I. INTRODUCTION
Overlap-save and overlap-add block ﬁltering algorithms
are frequently used to implement block ﬁnite impulse re-
sponse (FIR) ﬁlters [1], particularly when the input se-
quences are long. In these widely used approaches, segments
from the long input signal are processed using the discrete
Fourier transform (DFT), which is generally implemented
via the fast Fourier transform (FFT) [2]. In all the computa-
tional stages of the block ﬁltering approaches, quantization
errors occur due to the necessity of expressing numerical
quantities with ﬁnite precision in digital signal processors.
The goal of this study is to estimate the overall quantization
noise in the output blocks resulting from the overlap-save
(OLS) and overlap-add (OLA) methods, and compare these
errors in terms of quantization noise power. In order to
compute the overall quantization noise in the output blocks,
multiple error sources related to the different stages of the
computation must be considered, as for example, it is the
case with the errors resulting from the analog-to-digital
(A/D) conversion and the DFT computation stage.
Individual quantization error sources have been amply
investigated in previous studies. These include the quanti-
zation errors from the A/D conversion process [3,4], errors
generated from a standard DFT computation [3,4] and quan-
tization errors from an FFT process [3,4,5]. However, there
is no previous attempt to investigate the overall quantization
error present in the output blocks of the OLA approach and
OLS scheme, to the best of our knowledge. In the following
sections, we will try to estimate and compare the power of
the overall quantization error in the output blocks of the
OLA and OLS processes computed via the standard DFT.
The rest of this paper is organized as follows. In Section
II, the probabilistic properties of the quantization noise
generated in the different stages of the computational process
are described. In Section III, the variance of the quantization
error present in the output of the OLS blocks is calculated. In
Section IV, the same calculation is conducted for the output
blocks of the OLA. A brief numerical study is conducted to
illustrate the difference in terms of quantization noise power
between OLA and OLS methods. In Section V, the error
variances from the two different OLA and OLS block ﬁlters
are compared and several concluding remarks are presented.
Throughout the paper, the DFT and the inverse DFT
(IDFT) of any signal block are computed via multiplication
with the DFT and IDFT matrix, respectively. The N × N
DFT matrix for an N-point DFT computation is deﬁned as
[6]:
WN =


1
1
. . .
1
1
e−j 2π
N
. . .
e−j 2π(N−1)
N
...
...
...
1
e−j 2π(N−1)
N
. . .
e−j 2π(N−1)2
N


.
(1)
The N ×N IDFT matrix for an N-point IDFT computation
is given by [6]:
W −1
N
= 1
N W H
N ,
(2)
where H stands for the complex conjugate transpose (Hermi-
tian). In addition, x denotes the time-domain input sequence
and bx represents the DFT of x, and it is considered to belong
to the frequency domain. This relationship can be expressed
compactly as:
bx = WNx.
(3)
Similarly, h denotes the time-domain impulse response of
the ﬁlter and bh represents the DFT of h.
II. PROBABILISTIC PROPERTIES OF THE QUANTIZATION
NOISE
In this section, we describe from a statistical perspective
the quantization noises generated in the different stages of
117
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

the OLA and OLS methods. The quantization noise in all
of these stages is modeled as an additive noise (or error)
signal [4, p.119]. A statistical model is used for this additive
noise with the assumptions that: “the error sequence e is
a sample sequence of a stationary random process, e is
uncorrelated with the original signal, the random variables
(RV) of the error process are uncorrelated and the probability
distribution functions (PDF) of the error process are uniform
over the range of the quantization error [4, p.120].” For
quantizers using rounding in quantization, the amplitude of
e is in the range:
−∆
2
< e < ∆
2 .
(4)
With the assumptions above, the mean value of e is zero
and its variance (power) is [4, p.120]:
σ2
e = ∆2
12 .
(5)
A. Quantization Noise in the A/D Conversion
Quantization noise occurs at the A/D conversion stage,
where the analog-to-digital converter (ADC) is the quantizer.
Referring to the noise model above, the step size ∆adc of
a B + 1-bit two’s complement ADC is in general given by
[4, p.118]:
∆adc = 2Xm
2B+1 = Xm
2B ,
(6)
where Xm is called the full-scale level of the ADC [4,
p.118]. Consequently, the variance of the ADC quantization
noise σ2
adc is expressed as:
σ2
adc = ∆2
adc
12
= X2
m
3 2−(2B+2).
(7)
B. Quantization of the Filter Coefﬁcients
The ﬁlter coefﬁcients, or the impulse response h, are
stored in a ﬁnite-precision digital environment in digital
ﬁltering applications which also require quantization. If the
impulse response coefﬁcients are rounded to B + 1 bits,
then the step size of this quantization ∆h will be [4,p.347],
[3,p.580]:
∆h = 2−B.
(8)
Then, the variance of this noise σ2
h will be:
σ2
h = ∆2
h
12 = 2−(2B+2)
3
.
(9)
C. Quantization Noise in an N-Point DFT
The DFT operation is also implemented in a ﬁnite-
precision digital environment, for this reason quantization
noise is also present in the computation of a DFT. The
main source of the error is represented by the round-off
errors due to the multiplications performed in the DFT with
ﬁxed point arithmetic; therefore, we assume that the DFT
coefﬁcients themselves and the addition operations are not
quantized. Assuming that the input signal is also complex
valued, there are N complex-valued multiplications (thus
4N real-valued multiplications) in the direct computation of
the DFT. We also assume that these 4N quantization errors
are mutually uncorrelated and also uncorrelated with the
input sequence [3, p.487]. If the numbers are represented
with B + 1 bits, the variance of the error resulting form
a single real multiplication would be 2−2B/12 [4, p.630].
Since we have 4N mutually uncorrelated errors, the variance
of the overall error would be expressed as [4, p.631], [3,
p.487]:
σ2
dft = N
3 2−2B.
(10)
D. Quantization Noise in the Multiplication bx ⊙ bh
After computing the DFTs of the input signal and the
impulse response, the next step is to multiply the two N-
point frequency domain sequences term by term using the
Hadamard product “⊙”. This operation corresponds to a
circular convolution in the time-domain and it is actually
representing the ﬁltering process. For each term, there will
be a single complex-valued multiplication or 4 real-valued
multiplications. Using the same approach as above, we can
directly state that the error corresponding to this operation
(supposing that the representation assumes B + 1 bits) will
have a variance of:
σ2
mult = 4
122−2B = 1
32−2B.
(11)
E. Quantization Noise in an N-Point IDFT
The IDFT operation is symmetric to the DFT operation.
Therefore, the previous analysis conducted for the DFT is
directly extendable to the IDFT operation. The variance of
the error generated by the IDFT operation will be given by:
σ2
idft = N
3 2−2B.
(12)
III. QUANTIZATION NOISE IN THE OLS METHOD
One of the most widely used approaches for block digital
ﬁltering is the overlap and save method [7]. Considering an
N-point input segment x and a P-point impulse response
h, the OLS method corresponds to implementing an N-
point circular convolution and identifying the part of this
convolution that corresponds to a linear convolution. Then,
patching these segments together to form the output block.
This can be obtained by dividing x into sections of length N
such that each input section overlaps the preceding section
by P − 1 points, and by discarding the ﬁrst P − 1 samples
of the output block that result from the N-point circular
convolution. The remaining N −(P −1) samples correspond
to the linear convolution and can be patched block by block
to form the output [4, p.558].
In order to implement the N-point circular convolution,
we will ﬁrst pad the impulse response with N − P zeros
so that it will have the same length as the input block
(assuming that N > P). Then both of the time-domain
118
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

sequences will be transformed with the DFT operation and
multiplied in the frequency-domain. The resulting sequence
will be converted back to the time-domain via the IDFT
operation. The quantization errors will be introduced step
by step during the process and will be carried to the output.
Any quantization error is denoted as an additive random
vector with the same length as that of the original signal, i.e.,
it is modeled as a vector of uncorrelated complex random
variables with a length N.
A. Computation of the Error Term
The ﬁrst source of quantization error is the quantization
of the input signal by the ADC and the quantization of the
ﬁlter coefﬁcients:
x = x0 + ∆x
h = h0 + ∆h,
(13)
where x0, h0 are the original vectors and ∆x, ∆h are
the random vectors, all of length N. The next step is to
transform both of these vectors to the frequency-domain via
the multiplication with the N-point DFT matrix W , which
will also generate quantization errors:
bx = W x0 + W ∆x + c
δx
= c
x0 + d
∆x + c
δx,
(14)
where c
δx is the quantization noise generated from the DFT
operation. In a similar fashion:
bh = W h0 + W ∆h + c
δh
= c
h0 + d
∆h + c
δh.
(15)
At this stage we multiply both vectors using the Hadamard
product “⊙” in the frequency-domain to form the output:
by = bh ⊙ bx + c
µy,
(16)
where c
µy is the quantization error vector generated from the
ﬁnite-precision multiplications at this stage. After taking the
Hadamard product of bh and bx and discarding the terms that
result from the multiplication of two error terms, it follows
that
by = c
h0 ⊙ c
x0 + c
h0 ⊙ d
∆x + c
h0 ⊙ c
δx
+ d
∆h ⊙ c
x0 + c
δh ⊙ c
x0 + c
µy.
(17)
The last quantization error source will be the one induced
by the IDFT operation. We will model the noise induced
by the IDFT in a similar way to that generated by the DFT
process:
y = 1
N W Hby + δy,
(18)
where δy stands for the quantization error vector generated
by the IDFT operation.
In order to compute the power of the overall error, we
express y in terms of the original signal and an error term:
y = y0 + ∆y → y0 = 1
N W H(c
h0 ⊙ c
x0).
(19)
Then we can express the ﬁnal error in open form as:
∆y = 1
N W H(c
h0 ⊙ d
∆x) + 1
N W H(d
∆h ⊙ c
x0)
+ 1
N W H(c
h0 ⊙ c
δx) + 1
N W H(c
δh ⊙ c
x0)
+ 1
N W H( c
µy) + δy.
(20)
As expressed above, the overall error is composed of 6 terms,
which will be denoted respectively as zi, where 1 ≤ i ≤ 6,
for easy reference in the further stages:
∆y =
6
∑
i=1
zi.
(21)
The error vector zi is an N × 1 vector of complex random
variables generated from the ith quantization error source.
B. Variance of the Error Terms
The calculation of the output signal y, showed that there
are multiple quantization noise sources in the process, which
are assumed to generate mutually uncorrelated and zero-
mean noise vectors. For the computation of the variance,
it is important to note that the noise vectors are mutually
uncorrelated and their entries are also uncorrelated one with
respect to the other. In other words, the noise terms in
an individual vector are all uncorrelated with each other.
With these assumptions, we will determine our strategy to
calculate the variance of the overall noise term using zN×1
as a generic vector with a variance of σ2
z. Note that z is a
zero-mean noise vector:
E(z) =


E(z1)
...
E(zN)

 =


0
...
0

 = 0.
(22)
Using this property and the fact that the noise terms are
uncorrelated with each other, it follows that:
E(zzH) =


E(|z1|2)
. . .
0
...
0
. . .
E(|zN|2)

 = σ2
zI.
(23)
Note that σ2
z is the variance of a single term in the vector
z. In order to calculate the variance of the vector, we need
to add up all the variances corresponding to all the entries
in the vector. Mathematically, this operation amounts to
σ2
z−vector = E(zHz) = Nσ2
z.
(24)
Once the variances of the individual noise sources are
calculated, it is possible to ﬁnd the overall variance just
by adding the individual ones due to the uncorrelated nature
119
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

of the noise sources [8, p.220]. We will denote the variance
of an individual noise vector zi as σ2
i , where 1 ≤ i ≤ 6
denotes the respective order.
1) σ2
1 and σ2
2: Let’s start with z1 and proceed using the
strategy developed for the generic vector.
z1 = 1
N W H(c
h0 ⊙ d
∆x) → E(zH
1 z1) =
E( 1
N 2 (c
h0 ⊙ d
∆x)HW W H(c
h0 ⊙ d
∆x))
= E( 1
N (c
h0 ⊙ d
∆x)H(c
h0 ⊙ d
∆x)),
(25)
since W W H = NI. Writing in open form:
E(zH
1 z1) = E
( 1
N
N
∑
i=1
|c
h0[i]|2| c
∆x[i]|2)
= 1
N
N
∑
i=1
|c
h0[i]|2E(| c
∆x[i]|2),
(26)
where c
∆x’s are the probabilistic terms. Note that d
∆x =
W ∆x, and ∆x is the zero-mean noise vector generated at
the ADC composed of terms with a variance σ2
adc as deﬁned
previously. Therefore, the following relations hold:
d
∆x = W ∆x , E(d
∆x) = 0
E(d
∆xd
∆x
H) = E(W ∆x(W ∆x)H)
= W E(∆x∆xH)W H
= W σ2
adcIW H = σ2
adcNI.
(27)
This means that each term in the vector d
∆x has a variance
equal to σ2
adcN. Thus, we can replace any E(| c
∆x[i]|2) term
with σ2
adcN. Therefore, it follows further that
E(zH
1 z1) = 1
N
N
∑
i=1
|c
h0[i]|2σ2
adcN
= σ2
adc
N
∑
i=1
|c
h0[i]|2.
(28)
Note also that c
h0 = W h0. Thus:
N
∑
i=1
|c
h0[i]|2 = c
h0
H c
h0 = (W h0)H(W h0)
= h0
HW HW h0 = Nh0
Hh0
= N
N
∑
i=1
h2
0[i].
(29)
To sum up, the variance (σ2
1) of the quantization noise from
the ﬁrst source (z1) is found to be:
σ2
1 = Nσ2
adc
N
∑
i=1
h2
0[i].
(30)
This also means that any term in the vector z1 has a variance
equal to σ2
adc
∑N
i=1 h2
0[i].
We notice that the variance (σ2
2) calculation of the quanti-
zation noise from the second source (z2) is similar with the
ﬁrst calculation. For this reason, we can directly state that:
σ2
2 = Nσ2
h
N
∑
i=1
x2
0[i],
(31)
where σ2
h is the noise caused by the quantization of the
impulse response.
2) σ2
3 and σ2
4: The strategy for the calculation of these
variances is the same as the one used for the ﬁrst variance.
The vector variance σ2
3 of the noise generated from the third
source z3 could be directly expressed as:
σ2
3 = 1
N
N
∑
i=1
(|c
h0[i]|2E(|c
δx[i]|2).
(32)
As stated previously, c
δx is the zero-mean noise vector gener-
ated by the N-point DFT process with a variance σ2
dft. Then,
we can replace any E(|c
δx[i]|2) term with σ2
dft. We have
previously found out that ∑N
i=1 |c
h0[i]|2 = N ∑N
i=1 h2
0[i].
Thus:
σ2
3 = σ2
dft
N
∑
i=1
h2
0[i].
(33)
As it was the case for the ﬁrst set of variances, calculation
of σ2
3 and σ2
4 is quite similar. Therefore, one can directly
express σ2
4 as follows:
σ2
4 = σ2
dft
N
∑
i=1
x2
0[i].
(34)
3) σ2
5 and σ2
6: The computation of these variances is less
complex with respect to the previous variance calculations
because z5 and z6 are generated at the ﬁnal stages of the
OLS process. For this reason, these noise vectors are carried
through fewer computational stages in the OLS process with
respect to the previous noise vectors. Calculation of z5 relies
on the following relation:
σ2
5 = E([ 1
N W H c
µy]H[ 1
N W H c
µy])
= 1
N E( c
µyH c
µy) = 1
N
N
∑
i=1
E(|c
µy[i]|2).
(35)
From our previous deﬁnitions, c
µy was the zero-mean noise
vector generated by the Hadamard product of two complex
N-point vectors in a ﬁnite precision environment with a vari-
ance σ2
mult. Replacing E(|c
µy[i]|2) with σ2
mult, we obtain:
σ2
5 = σ2
mult.
(36)
120
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

The last quantization noise source is the IDFT process,
generating a noise vector z6 = δy with terms having a
variance σ2
idft:
σ2
6 = E(zH
6 z6) =
N
∑
i=1
E(|δy[i]|2).
(37)
The resulting value is:
σ2
6 = Nσ2
idft.
(38)
Exploiting the assumption that all these 6 noise sources are
mutually uncorrelated, we express the overall vector variance
in an N-point output block computed via the OLS method
as:
σ2
OLS = (Nσ2
adc + σ2
dft)
N
∑
i=1
h2
0[i]
+ (Nσ2
h + σ2
dft)
N
∑
i=1
x2
0[i]
+ σ2
mult + Nσ2
idft.
(39)
All these variances were numerically determined in the
second section. Considering a (B + 1)-bit digital system
that assumes a (B + 1)-bit ADC with a full-scale level of
Xm, we ﬁnd the variance in an N-point OLS output block
to be:
σ2
OLS = N
3 2−2B(
(X2
m + 4
4
)
N
∑
i=1
h2
0[i]
+ (5
4)
N
∑
i=1
x2
0[i] + N 2 + 1
N
)
.
(40)
IV. QUANTIZATION NOISE IN THE OLA METHOD
The other widely used block digital ﬁltering method is
the overlap and add method [1]. Considering an L-point
input signal block x and a P-point ﬁlter impulse response
h, the OLA method convolves x and h using a linear
convolution operation. Thus, it results in an output block
of length N = L+P −1. In order to perform this operation
in the frequency-domain via DFT-IDFT, we must pad both
x and h with zeros such that both of them become vectors
of the same length N, which corresponds to performing an
N-point circular convolution. When patching the N-point
output blocks together, the ﬁrst P − 1 terms of each block
are overlapped and added with the last P − 1 terms of the
previous block [4, p.558].
In terms of variance calculation, an important difference
between the OLS scheme and OLA method is that the
OLA method requires the addition of the ﬁrst P − 1 terms
of the current output block with the overlapping P − 1
terms of the previous output block. This means that in
these overlapping sections, the quantization errors present
in the two individual blocks are also added. Other than this
difference, the computation stages for both the OLS scheme
and the OLA method are the same. Thus, we can use our
previous variance calculations for the OLS and modify them
appropriately to include the additional noise coming from
overlapping P − 1 terms.
Assume that the OLA method results in an output block
of length N, and consider an N-point slice from the output
sequence of the OLS. Just before overlapping and adding the
the ﬁrst P − 1 terms of the current OLA block with the last
P −1 terms of the previous block, both blocks from the OLA
and the OLS process present the same variance. Assuming
that the overlapping blocks of the OLA are uncorrelated,
the P − 1 noise terms being added to each other are also
uncorrelated. It would be correct to state that the variance of
the terms in the overlapping section of the OLA block will
be doubled. With this reasoning, we can express the variance
of the quantization noise in an N-point OLA output block
(σ2
OLA) in terms of the variance of the quantization noise in
an N-point OLS output block (σ2
OLS) as follows:
σ2
OLA = N + P − 1
N
σ2
OLS.
(41)
Adopting a (B+1)-bit digital system that assumes a (B+1)-
bit ADC with a full-scale level of Xm, we can express the
numerical value of σ2
OLA as:
σ2
OLA = N + P − 1
3
2−2B
(
(X2
m + 4
4
)
N
∑
i=1
h2
0[i] + (5
4)
N
∑
i=1
x2
0[i] + N 2 + 1
N
)
.
(42)
In practice, the difference in terms of quantization noise
variance between OLS and OLA is relatively small. For
example, when N = 256 and P = 32, according to (41), the
difference is 10 log10((N +P −1)/N) = 0.49dB, while for
N = 256 and P = 128, the difference amounts to 1.7dB.
V. CONCLUSION
The quantization noise is a side effect that is inher-
ently present in any digital system due to the necessity of
representing the signal samples in ﬁnite-precision. Having
an important role in digital signal processing applications
that involve the ﬁltering of long sequences, OLA and OLS
methods are also prone to quantization noise once that they
get implemented in a digital system. Both methods were
implemented in multiple stages like the ADC, DFT or the
IDFT stage and multiple quantization noise sources from
these stages were taken into consideration. It was observed
that the power of the quantization noise in an OLA output
block tended to be higher than the quantization noise in
an OLS output block, mainly because of the addition of
the overlapping sections in the OLA process. However, it
was also observed that the difference in the quantization
noise power was highly dependent on the length of the input
sequences.
121
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

The computation of the variances would have been more
realistic if an FFT algorithm was used instead of a direct
DFT computation because most digital signal processing
applications take advantage of FFT algorithms. This study
can be expanded to include an FFT algorithm instead of a
direct DFT implementation. However, it is expected that the
quantitative comparison of the quantization noises in OLA
and OLS will not change.
ACKNOWLEDGMENT
This work was made possible by the support offered by
QNRF-NPRP grants 09-341-2128 and 4-1293-2-513.
REFERENCES
[1] M. J. Narasimha, “Linear convolution using skew–cyclic con-
volutions,” IEEE Signal Processing Letters, vol. 14, 2007, pp.
173–176.
[2] A. Daher, E. H. Baghious, G. Burel, and E. Radoi, “Overlap–
save and overlap–add ﬁlters: optimal design and comparison,”
IEEE Transactions on Signal Processing, vol. 58, 2010, pp.
3066–3075.
[3] J. G. Proakis and D. G. Manolakis, Digital Signal Processing:
Principles, Algorithms and Applications. Upper Saddle River:
Prentice Hall, 1996.
[4] A. V. Oppenheim and R. W. Schafer, Discrete Time Signal
Processing.
Englewood Cliffs: Prentice Hall, 1989.
[5] A. V. Oppenheim and C. J. Weinstein, “Effects of ﬁnite register
length in digital ﬁltering and the fast Fourier transform,”
Proceedings of IEEE, vol. 60, 1972, pp. 957–976.
[6] A. E. Cetin, Lecture Notes on Discrete-Time Signal Process-
ing: EE424 Course at Bilkent University, Ankara, Turkey,
2012.
[7] G. Burel, “Optimal design of transform-based block digital
ﬁlters using a quadratic criterion,” IEEE Transactions on Signal
Processing, vol. 52, 2004, pp. 1964–1974.
[8] D. P. Bertsekas and J. N. Tsitsiklis, Introduction to Probability.
Belmont: Athena Scientiﬁc, 2008.
122
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

