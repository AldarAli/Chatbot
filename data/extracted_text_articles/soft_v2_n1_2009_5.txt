47
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
Complex software systems : Formalization and Applications ∗
Marc Aiguier, Pascale Le Gall and Mbarka Mabrouki
École Centrale Paris
Laboratoire de Mathématiques Appliqués aux Systèmes (MAS)
Grande Voie des Vignes - F-92295 Châtenay-Malabry
Programme d’Épigénomique
523, Place des Terrasses de l’Agora - F-91025 Evry
{marc.aiguier,pascale.legall}@ecp.fr, mabrouki@epigenomique.genopole.fr
Abstract
A mathematical denotation is proposed for the notion
of complex software systems whose behavior is speciﬁed
by rigorous formalisms.
Complex systems are described
in a recursive way as an interconnection of subsystems by
means of architectural connectors.
In order to consider
the largest family of speciﬁcation formalisms and architec-
tural connectors, this denotation is essentially formalism,
speciﬁcation and connector independent. For this, we build
our denotation on Goguen’s institution theory. In this ab-
stract framework, we characterize complexity by the notion
of property emergence.
This work is a revised and extended version of Aigu-
ier, Le Gall and Mabrouki (3rd International Conference on
Software Engineering Advanced (ICSEA), IEEE Computer
Society Press, 2008).
Keywords-abstract speciﬁcation language; abstract ar-
chitectural connector; emergent property; institution; cate-
gory theory; transition systems; modal ﬁrst-order logic.
1
Introduction
A powerful approach to develop large software systems
is to describe them in a recursive way as an interconnec-
tion of sub-systems. This has then made emerge the no-
tion of architectural connector as a powerful tool to de-
scribe systems in terms of components and their interac-
tions [6, 7, 16, 25]. Academic and industrial groups have
deﬁned and developed computer languages dedicated to the
description of software architectures provided with archi-
tectural connectors, called Architectural Description Lan-
guage (ADL), such as ACME/ADML [17], Wright [5] or
∗This work is performed within the European project GENNETEC
(GENetic NeTworks: Emergence and Complexity) STREP 34952.
Community [15, 16]. The interest of describing software
systems as interconnected subsystems is that this promotes
the reuse of components either directly taken in a library
or adapted by slight modiﬁcations made on existing ones.
The well-known difﬁculty with such systems is to infer the
global behavior of the system from the ones of subsystems.
Indeed, modern software systems are often open on the out-
side, that is they interact with the environment, composed
of interacting subsystems (e.g. active objects which inter-
act together concurrently [3, 27]) or deﬁned by questioning
requirements of subsystems (e.g. feature-oriented systems
where each feature can modify the expected properties of
pre-existing features [18, 4, 26]). Thus, such global systems
may exhibit behaviors, that cannot be anticipated just from
a complete knowledge of subsystems. Hence, what makes
such software systems complex is they cannot be reduced to
simple rules of property inference from subsystems towards
to the global system.
Following some works issued from other scientiﬁc dis-
ciplinaries such as biology, physics, economy or sociol-
ogy [10, 13], let us make more precise what we mean by
complex systems. A complex system is characterized by a
holistic behavior, i.e. global: we do not consider that its be-
havior results from the combination of isolated behaviors of
some of its components, but instead has to be considered as
a whole. This is expressed by the appearance (emergence)
of global properties which is very difﬁcult, see impossible,
to anticipate just from a complete knowledge of component
behaviors. This notion of emergence seems to be the sim-
plest way to deﬁne complexity. Succinctly, this could be
expressed as follows: suppose a system XY composed of
two subsystems X and Y. Let us also suppose we have a
mathematical function F which gives all potential pieces of
information on XY, X and Y, and an operation ’+’ to com-
bine potential pieces of information of subsystems. If we
have that F(XY ) = F(X) + F(Y ) then this means that

48
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
the system XY integrates in a consistent manner the sub-
systems X and Y without either removing or adding pieces
of information. Therefore, we can say that the system XY
is not complex (i.e. the system XY is said to be modular).
On the contrary, if there exists some a ∈ F(X) + F(Y )
such that a ̸∈ F(XY ) or there exists some a ∈ F(XY )
such that a ̸∈ F(X) + F(Y ), then there is reconsideration
of some potential pieces of information of X or Y in the
ﬁrst case, and appearance of true emergence in the second
case. The system XY is then said complex.
In this paper, we will study the notion of complex soft-
ware systems by using formal speciﬁcations, that is we will
suppose that every part of systems have been speciﬁed in a
given formalism from which we can infer properties. The
system XY will be built from subsystems X and Y by
means of an architectural connector c expliciting how the
two subsystems are linked together to form the global sys-
tem c(X, Y ) = XY , the connector c being implicit in the
notation XY . Finally, the function F will give for a spec-
iﬁcation its whole set of satisﬁed properties, the so-called
semantic consequences of speciﬁcations usually noted X•,
and F(X) + F(Y ) = (X• ∪ Y •)•. Roughly speaking, this
last notation consists in saturating the property derivation
mechanism, and then represents the fact that F(X)+F(Y )
denote the set of all properties which can be derived from
the set of properties X•, resp. Y •, associated to X, resp. Y .
The notion of complexity being based on the emergence of
properties, a general framework dedicated to complex soft-
ware systems can be deﬁned independently of formalisms,
speciﬁcations and architectural connectors. Hence, we in-
vestigate an abstract form of complexity, by following the
paradigm “logical-system independency”. The interest here
is simple. We can observe, whatever the formalism used
to specify softwares, that the same set of notions underlies
complexity. These notions are : architectural connector and
emergent property. To formalize abstractly these elements,
our approach will be based on previous works:
• we will use the general framework of institutions [20]
which is recognized as well-adapted to generalize for-
malisms. The theory of institutions abstracts the se-
mantical part of logical systems according to the needs
of software speciﬁcations in which changes of signa-
tures are taken into account. The abstraction of the
different parts of logical systems is obtained by us-
ing some notions of the category theory such as the
category of signatures and the two functors to denote
respectively the set of sentences and the category of
models over a signature (see Section 2 for the complete
deﬁnition of institutions and some related notions);
• speciﬁcations will be deﬁned following the generic
approach of speciﬁcation logics [14].
The inter-
est of speciﬁcation logics is they unify in the same
framework heterogeneous forms of speciﬁcations by
considering them as simple objects of a category
SPEC, while handled speciﬁcations over institutions
are mostly axiomatic (i.e. of the form (Σ, Ax) where
Σ is a signature and Ax is a (ﬁnite) set of formulas (ax-
ioms) over Σ). However, because we are interested by
emergent properties, we will adapt/modify speciﬁca-
tion logics by deﬁning them over institutions in order
to focus on speciﬁcation properties;
• abstract connectors will be deﬁned by using notions of
the category theory. The use of category theory has
already been applied strikingly to model the architec-
ture of software systems by Goguen [19] and Fiadeiro
& al. [15]. It has also been applied to model com-
plex natural systems such as biological, physical and
social systems (e.g. Ehresman and Vanbremeersch’s
works [13]).
Fiadeiro & al. [16] have proposed an abstract formal
denotation of a class of architectural connectors in the
style of Allen and Garlan [6], that is deﬁned by a set of
roles and a glue speciﬁcation. Here, we will go beyond
by not supposing any structure in the architectural con-
nectors.
Over our abstract notions of speciﬁcation and architec-
tural connector, we will deﬁne the notion of emergent prop-
erties according to the two following classes:
1. the ones we will call true emergent properties that are
properties which cannot be inferred from subsystem
properties,
2. and the ones we will call non conformity properties
that are subsystem properties which are not satisﬁed
by the global system anymore.
In practice, properties of the ﬁrst form, i.e. true emer-
gent properties, combine knowledge inherited from subsys-
tems. Thus, they are deﬁned in a richer language than the
ones associated to each subsystem, and the presence of such
emergent properties is quite natural. Conversely, properties
of the second form, i.e. non conformity properties, are often
the consequences of bad interactions between subsystems.
They characterize properties that are satisﬁed (resp. not sat-
isﬁed) by a subsystem considered in isolation, but are not
satisﬁed (resp. satisﬁed) by the global system incorporating
the subsystem in question.
A software system will be then said complex when emer-
gent properties can be inferred from it. The complexity of
systems just means that we do not beneﬁt from the complete
knowledge of subsystems we have, to analyze the behavior
of the large system. Hence, the recursive approach used to
describe the system cannot be used to analyze its behavior.
Complex systems can then be opposed to modular systems

49
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
which by deﬁnition strictly preserve local properties at the
global level (see [24] for a state-of-the-art on the modular
approach).
The formalizations of system complexity and emergent
properties are interesting if they are done in such way to
support the characterization of general properties to guar-
antee when a system is or is not complex. To answer this
point, we will give some conditions under which a system
is modular. We will then establish two results: in the ﬁrst
one we will give a sufﬁcient and necessary condition to en-
sure the absence of true emergent properties. In the sec-
ond result, we will give sufﬁcient conditions based on the
categorical notion of adjunctness to ensure the absence of
non-conformity properties.
As a result of our generalization deﬁned in this paper, all
the notions, results, and techniques established and deﬁned
in our abstract framework are de facto adaptable to any in-
stitution.
The paper is structured as follows: Section 2 reviews
some concepts, notations and terminology about institu-
tions. Section 3 deﬁnes an abstract notion of speciﬁcations
over institutions. In Section 4, abstract architectural con-
nectors are deﬁned and classiﬁed as complex and modular.
The notations of the category theory used in this paper are
the standard ones and can be found in [15]. Although all the
notions and results given in this manuscript are exempliﬁed
by many examples all along the paper, Section 5 illustrates
more particularly the abstract framework developed in this
paper to reactive component-based systems described by
transition systems and combined together through the syn-
chronous product operation.
Note : This manuscript extends the paper published in
the proceedings of [1] with expanded deﬁnitions, new re-
sults and additional examples. Moreover, as an application
of our approach, we will study reactive systems described
by means of transition systems as components and of the
usual synchronous product as architectural connector, and
whose behavior is expressed by logical properties over a
modal ﬁrst-order logic. In this framework, we propose to
study complexity of reactive systems through this notion of
emergent properties. We will also give some conditions to
guarantee when a system is lacking of non-conformity prop-
erties which have been recognized as being the cause of bad
interaction between components. This last work has been
published in the proceedings of [2]. Here, this manuscript
also extends the paper published in [2] with complete proofs
of the main results.
2
Institutions
The theory of institutions [20] is a categorical abstract
model theory which formalizes the intuitive notion of logi-
cal system, including syntax, semantics, and the satisfaction
between them. This emerged in computing science studies
of software speciﬁcation and semantics, in the context of
the increasing number of considered logics, with the ambi-
tion of doing as much as possible at the level of abstraction
independent of commitment to any particular logic. Now
institutions have become a common tool in the area of for-
mal speciﬁcation, in fact its most fundamental mathematical
structure.
2.1
Basic deﬁnitions
Deﬁnition. 1 (Institution) An
institution
I
=
(Sig, Sen, Mod, |=) consists of
• a category Sig, objects of which are called signatures,
• a functor Sen : Sig → Set giving for each signature
a set, elements of which are called sentences,
• a contravariant functor Mod : Sigop → Cat giving
for each signature a category, objects and arrows of
which are called Σ-models and Σ-morphisms respec-
tively, and
• a |Sig|-indexed family of relations
|=Σ⊆ |Mod(Σ)| × Sen(Σ)
called satisfaction relation,
such that the following property holds:
∀σ : Σ → Σ′, ∀M′ ∈ |Mod(Σ′)|, ∀ϕ ∈ Sen(Σ),
M′ |=Σ′ Sen(σ)(ϕ) ⇔ Mod(σ)(M′) |=Σ ϕ
Here, we deﬁne some notions over institutions which
will be useful thereafter.
Deﬁnition. 2 (Elementary equivalence) Let
I
=
(Sig, Sen, Mod, |=) be an institution. Let Σ be a signa-
ture. Two Σ-models M1 and M2 are elementary equivalent,
noted M1 ≡Σ M2 if, and only if the following condition
holds: ∀ϕ ∈ Sen(Σ), M1 |=Σ ϕ ⇐⇒ M2 |=Σ ϕ.
This means that M1 and M2 are undistinguishable with
respect to the formula satisfaction.
Deﬁnition. 3 (Closed under isomorphism) An institution
is closed under isomorphism if, and only if every two iso-
morphic models are elementary equivalent.
All reasonable logics (anyway all the logics classically used
in mathematics and computer science) are closed under iso-
morphism.

50
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
Deﬁnition. 4 (Logical theory) Let
I
=
(Sig, Sen, Mod, |=) be an institution.
Let Σ be a
signature of |Sig|.
Let T be a set of Σ-sentences (i.e.
T ⊆ Sen(Σ)). Let us denote Mod(T) the full sub-category
of Mod(Σ) whose objects are all Σ-models M such that
for any ϕ ∈ T, M |=Σ ϕ, and T • the subset of Sen(Σ),
so-called semantic consequences of T, deﬁned as follows:
T • = {ϕ | ∀M ∈ |Mod(T)|, M |=Σ ϕ}
T is a logical theory if, and only if T = T •.
ϕ ∈ T • is also denoted by T |=Σ ϕ.
2.2
Examples of institutions
2.2.1
Propositional Logic (PL)
Signatures and signature morphisms are sets of proposi-
tional variables and functions between them respectively.
Given a signature Σ, the set of Σ-sentences is the least set
of sentences ﬁnitely built over propositional variables in Σ
and Boolean connectives in {¬, ∨, ∧, ⇒}. Given a signa-
ture morphism σ : Σ → Σ′ associating to each proposi-
tional variable of Σ a propositional variable of Σ′, Sen(σ)
translates Σ-formulas to Σ′-formulas by renaming proposi-
tional variables according to σ.
Given a signature Σ, the category of Σ-models is the cate-
gory of mappings1 ν : Σ → {0, 1} with identities as mor-
phisms. Given a signature morphism σ : Σ → Σ′, the for-
getful functor Mod(σ) maps a Σ′-model ν′ to the Σ-model
ν = ν′ ◦ σ.
Finally, satisfaction is the usual propositional satisfaction.
2.2.2
Many-sorted First Order Logic with equality
(FOL)
Signatures are triples (S, F, P) where S is a set of sorts,
and F and P are sets of function and predicate names re-
spectively, both with arities in S∗ ×S and S+ respectively.2
Signature morphisms σ : (S, F, P) → (S′, F ′, P ′) consist
of three functions between sets of sorts, sets of functions
and sets of predicates respectively, the last two preserving
arities.
Given a signature Σ = (S, F, P), the Σ-atoms are of two
possible forms: t1 = t2 where 3 t1, t2 ∈ TF (X)s (s ∈ S),
and p(t1, . . . , tn) where p : s1 × . . . × sn ∈ P and
ti ∈ TF (X)si (1 ≤ i ≤ n, si ∈ S). The set of Σ-sentences
is the least set of formulas built over the set of Σ-atoms by
ﬁnitely applying Boolean connectives in {¬, ∨, ∧, ⇒} and
1{0, 1} are the usual truth-values.
2S+ is the set of all non-empty sequences of elements in S and S∗ =
S+ ∪ {ϵ} where ϵ denotes the empty sequence.
3TF (X)s is the term algebra of sort s built over F with sorted variables
in a given set X.
quantiﬁers ∀ and ∃.
Given a signature Σ = (S, F, P), a Σ-model M is a fam-
ily M = (Ms)s∈S of sets (one for every s ∈ S), each one
equipped with a function f M : Ms1 ×. . .×Msn → Ms for
every f : s1 × . . . × sn → s ∈ F and with a n-ary relation
pM ⊆ Ms1 × . . . × Msn for every p : s1 × . . . × sn ∈ P.
Given a signature morphism σ : Σ = (S, F, P) → Σ′ =
(S′, F ′, P ′) and a Σ′-model M′, Mod(σ)(M′) is the Σ-
model M deﬁned for every s ∈ S by Ms = M ′
σ(s), and for
every function name f ∈ F and predicate name p ∈ P, by
f M = σ(f)M′ and pM = σ(p)M′. Finally, satisfaction is
the usual ﬁrst-order satisfaction.
Many other important logics can be obtained as FOL re-
strictions such as:
• Horn Clause Logic (HCL). An universal Horn sen-
tence for a signature Σ in FOL is a Σ-sentence of
the form Γ ⇒ α where Γ is a ﬁnite conjunction of
Σ-atoms and α is a Σ-atom. The institution of Horn
clause logic is the sub-institution of FOL whose sig-
natures and models are those of FOL and sentences
are restricted to the universal Horn sentences.
• Equational Logic (EQL). An algebraic signature
(S, F) simply is a FOL signature without predicate
symbols. The institution of equational logic is the sub-
institution of FOL whose signatures and models are
algebraic signatures and algebras respectively.
• Conditional equational logic (CEL). The institution
of conditional equational logic is the sub-institution of
EQL whose sentences are universal Horn clauses for
algebraic signatures.
• Rewriting Logic (RWL) Given an algebraic signature
Σ = (S, F), Σ-sentences are formulas of the form
ϕ : t1 → t′
1 ∧ . . . ∧ tn → t′
n ⇒ t → t′ where ti, t′
i ∈
TF (X)si (1 ≤ i ≤ n, si ∈ S) and t, t′ ∈ TF (X)s
(s ∈ S). Models of rewriting logic are preorder mod-
els, i.e. given a signature Σ = (S, F), Mod(Σ) is the
category of Σ-algebras A such that for every s ∈ S,
As is equipped with a preorder ≥. Hence, A |= ϕ if,
and only if for every variable assignment ν : X → A,
if each ν(ti)A ≥ ν(t′
i)A then ν(t)A ≥ ν(t′)A where
_A : TF (A) → A is the mapping inductively deﬁned
by: f(t1, . . . , tn)A = f A(tA
1 , . . . , tA
n ).
2.2.3
Modal FOL (MFOL)
Signatures are couples (Σ, A) where Σ is a FOL-signature
and A is a set of actions, and morphisms are couples of
FOL-signature morphisms and total functions on sets of ac-
tions. In the sequel, we will note by the same name both
MFOL-signature and each of its components.

51
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
Given a MFOL signature (Σ, A) with Σ = (S, F, P),
(Σ, A)-atoms are either predicates p(t1, . . . , tn) or the sym-
bol T (for True), and the set of (Σ, A)-formulas is the least
set of formulas built over the set of (Σ, A)-atoms by ﬁnitely
applying Boolean connectives in {¬, ∨, ∧, ⇒}, quantiﬁers
∀ and ∃, and modalities in {2a|a ∈ A}. For every a ∈ A,
the intuitive meaning of 2a is “always after the action a”.
Given a signature (Σ, A), a (Σ, A)-model (W, R), called
Kripke frame, consists of a family W = (W i)i∈I of Σ-
models in FOL (the possible worlds) such that 4 W i
s = W j
s
for every i, j ∈ I and s ∈ S, and a A-indexed family of
“accessibility” relations Ra ⊆ I × I. Given a signature
morphism σ : (Σ, A) → (Σ′, A′) and a (Σ′, A′)-model
((W ′i)i∈I, R′), Mod(σ)(((W ′i)i∈I, R′)) is the (Σ, A)-
model (Mod(σ)(W ′i)i∈I, R) deﬁned for every a ∈ A by
Ra = R′
σ(a). A (Σ, A)-sentence ϕ is said to be satisﬁed by
a (Σ, A)-model (W, R), noted (W, R) |=(Σ,A) ϕ, if for ev-
ery i ∈ I we have (W, R) |=i
Σ ϕ, where |=i
Σ is inductively
deﬁned on the structure of ϕ as follows:
• for
every
FOL-formula
ϕ
built
over
Σ-atoms,
(W, R) |=i
Σ ϕ iff W i |=Σ ϕ
• (W, R) |=i
Σ 2aϕ when (W, R) |=j
Σ ϕ for every j ∈ I
such that i Ra j.
2.2.4
More exotic institutions
The institution theory also enables to represent formalisms
which are not logics strictly speaking.
Formal languages (FL) The institution of formal lan-
guages is deﬁned by the category of signatures Set. Given
a set A, the set of sentences is A∗ and Mod(A) is the cate-
gory whose objects are all subsets of A∗. Given a signature
morphism σ : A → A′, Mod(σ) is the functor which at
L′ ⊆ A′∗ associates the set L = {α|σ(α) ∈ L′}. Finally,
given a signature Σ ∈ Sig, |=Σ is just the membership rela-
tion ∋. It is obvious to show that the satisfaction condition
holds.
Programming languages (PLG) The institution of a
programming language [28] is built over an algebra of built-
in data types and operations of a programming language.
Signatures are FOL signatures and sentences are programs
of the programming language over signatures; and models
are algebraic structures in which functions are interpreted
as recursive mappings (i.e for each function symbol is as-
signed a computation (either diverging, or yielding a result)
to any sequence of actual parameters). A model satisﬁes a
sentence if, and only if it assigns to each sequence of param-
eters the computation of the function body as given by the
sentence. Hence, sentences determine particular functions
4In the literature, Kripke frames satisfying such a property are said with
constant domains.
in the model uniquely. Finally, signature morphisms, model
reductions and sentence translations are deﬁned similarly to
those in FOL.
3
Speciﬁcations in institutions
Over institutions, speciﬁcations are usually deﬁned ei-
ther by logical theories or couples (Σ, Ax) where Σ is a
signature and Ax a set (usually ﬁnite) of formulae (often
called axioms) over Σ. However, there is a large family of
speciﬁcation formalisms mainly used to specify concurrent,
reactive and dynamic systems for which speciﬁcations are
not expressed in this way. We can cite for instance pro-
cess algebras, transition systems or Petri nets. Now, all of
these kinds of speciﬁcations can be studied through the set
of their semantic consequences expressed in an adequate
formalism. This leads us up to deﬁne the notion of speciﬁ-
cations over institutions.
3.1
Deﬁnitions
Let us now consider a ﬁxed but arbitrary institution I =
(Sig, Sen, Mod, |=).
Deﬁnition. 5 (Speciﬁcations) A speciﬁcation language SL
over I is a pair (Spec, Real) where:
• Spec : Sigop → Set is a functor. Given a signature
Σ, elements in Spec(Σ) are called speciﬁcations over
Σ.
• Real = (RealΣ)Σ∈|Sig| is a Sig-indexed family of
mappings RealΣ
: Spec(Σ) → |Cat| such that
for every Σ ∈ |Sig|, and every Sp ∈ Spec(Σ),
RealΣ(Sp) is a full subcategory of Mod(Σ). Objects
of RealΣ(Sp) are called realizations of Sp.
Deﬁnition. 6 (Semantic consequences) Let
SL
=
(Spec, Real) be a speciﬁcation language over I. Let us
deﬁne _• = (_•
Σ)Σ∈Sig the Sig-indexed family of mappings
_•
Σ : Spec(Σ) → P(Sen(Σ)) that to every Sp ∈ Spec(Σ),
yields the set Sp•
Σ = {ϕ|∀M ∈ RealΣ(Sp), M |=Σ ϕ}.
Sp•
Σ is called the set of semantic consequences of Sp or
the theory of Sp.
Deﬁnition 6 calls for some comments:
• We could expect that Mod(Sp•) = Real(Sp) what
would make unmeaning the existence of the mappings
in Real in Deﬁnition 5. However, we can often be led
up to make some restrictions on speciﬁcation models.
For instance, when dealing with axiom speciﬁcations
expressed in equational logic, we can be interested by
reachable or initial models to allow inductive proofs or
for computability reasons.

52
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
• Sometimes, _• is a natural transformation from Spec
to5 P ◦ Senop. However, most of times, it is not the
case (see the examples in Section 3.2).
Deﬁnition. 7 (Category of speciﬁcations) Let SL be a
speciﬁcation language over an institution I.
Denote
SPEC the category of speciﬁcations over SL whose the
objects are the elements in
[
Σ∈|Sig|
Spec(Σ), and morphisms
are actually given by signature morphisms (i.e. for every
Sp ∈ Spec(Σ) and every Sp′ ∈ Spec(Σ′), σ : Sp →
Sp′ ∈ SPEC iff σ : Σ → Σ′ ∈ Sig). If a morphism
σ : Sp → Sp′ in SPEC further satisﬁes: Sen(σ)(Sp•
Σ) ⊆
Sp′•
Σ′, then σ is called speciﬁcation morphism.
Sig : SPEC → Sig is the functor which maps any speciﬁ-
cation Sp ∈ Spec(Σ) to the signature Σ and any morphism
σ to the signature morphism Sig(σ).
Hence, speciﬁcation morphisms are arrows in SPEC
that further preserve semantic consequences.
Com-
monly, the category of speciﬁcations over institutions have
[
Σ∈|Sig|
Spec(Σ) as objects and speciﬁcation morphisms as
arrows [20, 29]. Here, the fact to consider just signature
morphisms between speciﬁcations will be useful to deﬁne
both architectural connectors and their combination.
3.2
Examples of speciﬁcations
We give three examples of speciﬁcation languages that
correspond to the usual forms of speciﬁcations over arbi-
trary institutions.
3.2.1
Logical theories
Here, speciﬁcations are logical theories. To meet the re-
quirements given in Deﬁnition 5, this gives rise to the func-
tor Spec : Sigop → Set which to every Σ ∈ Sig, as-
sociates the set of all Σ-theories T, and to every signa-
ture morphism σ : Σ → Σ′, matches every Σ′-theory T ′
with the Σ-theory T = {ϕ|Sen(σ)(ϕ) ∈ T ′}.
Hence,
Spec(Σ) ⊆ P(Sen(Σ)). We naturally deﬁne RealΣ(T) =
Mod(T). Moreover, speciﬁcations being saturated theories,
this naturally leads to the identity function _•
Σ : Spec(Σ) →
5Given a functor F : C → D, Fop : Cop → Dop is the dual of F
deﬁned as follows:
– ∀o ∈ C, F op(o) = F(o)
– f∗ being the reverse arrow of f in C, ∀o, o′
∈
C, ∀f
∈
HomC(o, o′), F op(f∗) = F(f)∗
The powerset functor P : Setop → Set takes a set S to its powerset
P(S), and a set function f : S → S′ (i.e., an arrow from S′ to S in
Setop) to the inverse image function f−1 : P(S′) → P(S) which asso-
ciates to a subset A ⊆ S′ the subset {s ∈ S|f(s) ∈ A} of S.
P(Sen(Σ)). It is easy to check that given a signature mor-
phism σ : Σ → Σ′, the following diagram commutes and
then _• is a natural transformation:
Spec(Σ)
P(Sen(Σ))
Spec(Σ′)
P(Sen(Σ′))
_•
Σ
_•
Σ′
Spec(σ)
P(Senop(σ∗))
(See Footnote 5 for the deﬁnition of σ∗)
3.2.2
Axiomatic speciﬁcations
In this case, speciﬁcations are deﬁned by pairs (Σ, Ax)
where Σ is a signature and Ax
⊆
Sen(Σ),
and
given a signature morphism σ
:
Σ
→
Σ′, Spec(σ)
matches every Σ′-speciﬁcation Sp′ = (Σ′, Ax′) to Sp =
(Σ, {ϕ|Sen(σ)(ϕ) ∈ Ax′}). By the satisfaction condition,
we have that Sen(σ)(Ax•) ⊆ Ax′•. The functor Spec then
associates to every signature Σ the set of pairs (Σ, Ax), and
(Σ, Ax)•
Σ = Ax•. Observe that _• is not a natural transfor-
mation. Indeed, let us set in FOL, and consider the inclu-
sion morphism σ : Σ → Σ′ where Σ′ = ({s}, ∅, {R1, R2 :
s × s}) and Σ = ({s}, ∅, {R1 : s × s}). Let Ax′ be the set
of axioms:
x R2 y =⇒ y R2 x
x R1 y ⇐⇒ x R2 y
Obviously, we prove from Ax′ that R1 is a symmetric
relation.
However,
Spec(σ)((Σ′, Ax′))
=
∅,
and
then
Spec(σ)((Σ′, Ax′))• is restricted to tautologies while
P(Senop(σ∗))(Ax′) contains at least x R1 y ⇒ y R1 x.
3.2.3
Inference rules
In the framework of formal language, languages L over an
alphabet A can be speciﬁed by inference rules, that is n-
ary relations r on A∗ and a tuple (α1, . . . , αn) ∈ r means
that if α1, . . . , αn−1 are words of the language, then so
is αn. Hence, a speciﬁcation over an alphabet A is a set
R of n-ary relations on A∗. Given a signature morphism
σ : A → A′ and a speciﬁcation R′ over A′, the speciﬁcation
Spec(σ)(R′) over A is the set R of n-ary relation r such
that there exists r′ ∈ R′ and r = {(a1, . . . , an)|(∀i, 1 ≤
i ≤ n, ai ∈ A) ∧ (a1, . . . , an) ∈ r′}. Given a set of infer-
ence rules R over an alphabet A, R•
A is the language L in-
ductively generated from inference rules of R. Given a sig-
nature morphism σ : A → A′ and a set of inference rules R′
over A′. It is easy to show that Spec(σ)(R′)•
A = R′•
A′ ∩ A∗
what proves that _• is a natural transformation from Spec
to P ◦ Senop.

53
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
3.3
Properties of speciﬁcations
Proposition. 1 Let σ : Sp → Sp′ be a speciﬁcation mor-
phism. Then, the functor Mod(σ) : Mod(Sig(Sp′)) →
Mod(Sig(Sp)) can be restricted to speciﬁcation semantic
consequences (i.e. Mod(σ) : Mod(Sp′•
Σ′) → Mod(Sp•
Σ)
is a functor).
Proof. Let ϕ ∈ Sp•
Sig(Sp) and M ∈ Mod(Sp′).
As
σ is a speciﬁcation morphism, M |=Sig(Sp′) Sen(σ)(ϕ).
Therefore, by the satisfaction condition, we also have that
Mod(σ)(M) |=Sig(Sp) ϕ.
We cannot state a similar result for the family of map-
pings Real, i.e. we cannot deﬁne in a general way a func-
tor of the form Real(σ) : Real(Sp′) → Real(Sp). The
following notion of compatibility captures the existence of
such a functor.
Deﬁnition. 8 (Compatible) Let SL = (Spec, Real) be a
speciﬁcation language over I. Let σ : Sp → Sp′ be a
speciﬁcation morphism. Real is said compatible with σ if,
and only if we can deﬁne a functor Real(σ) : Real(Sp′) →
Real(Sp).
Here, we deﬁne two other notions that we will use after-
wards.
Deﬁnition. 9 (Deﬁnable by speciﬁcation) Given an insti-
tution I and a speciﬁcation language over I, a Σ-theory
T is said deﬁnable by speciﬁcation or deﬁnable for being
shorter if, and only if there exists Sp ∈ Spec(Σ) such that
T = Sp•
Σ.
In the following deﬁnition, we now adapt the standard
notion of liberal speciﬁcation morphism [12] which will be
useful in Section 4.3.
Deﬁnition. 10 (Liberality) In any speciﬁcation language
SL over I, a speciﬁcation morphism σ : Sp → Sp′
is liberal if, and only if Real is compatible with σ and
Real(σ) : Real(Sp′) → Real(Sp) has a left-adjunct
F(σ) : Real(Sp) → Real(Sp′).
Speciﬁcations deﬁned by logical theories and axiomatic
speciﬁcations over the institution CEL is liberal for every
speciﬁcation morphism σ. Indeed, let σ : Σ = (S, F) →
Σ′ = (S′, F ′) be a signature morphism, and let Γ and Γ′
be two sets of conditional equations over, respectively, Σ
and Σ′ such that Sen(σ)(Γ) ⊆ Γ′. We can build a functor
TΓ′/Γ : A 7→ TΓ′/Γ(A), from the category of Γ-algebras to
the category of Γ′-algebras.
Let A be a Γ-algebras.
TΓ′/Γ(A) is the quotient of
TF ′(A) by the congruence generated by the kernel of the Σ-
morphism TF (A) in A extending the identity on X. 6 This
algebra satisﬁes the following universal property: for every
Γ′-algebra B and every Σ-morphism µ : A → Mod(σ)B,
there exists a unique Σ′-morphism ηB : TΓ′/Γ(A) → B
such that for every a ∈ A, ηB(a) = µ(a). This universal
property directly shows that the functor TΓ′/Γ is left-adjunct
to Mod(σ), i.e., for every Γ-algebra A there exists a univer-
sal morphism µA : A → Mod(σ)(TΓ′/Γ(A)). µA is called
the adjunct morphism for A.
4
Architectural connector
4.1
Deﬁnitions
Succinctly, architectural connectors enable one to com-
bine components (speciﬁcations) together to make bigger
ones. However, depending on the used speciﬁcation lan-
guage, the way of combining components can be differ-
ent. For instance, when speciﬁcations are logical theories
then their combination is often based on the set theoretical
union on signatures whereas the combination of speciﬁca-
tions made of transition systems is based on some kinds of
product. However, one can observe that most of existing
connectors c have the following common features:
• a connector c gets as arguments a ﬁxed number n of
existing speciﬁcations Sp1, Sp2, . . . Spn deﬁned re-
spectively over the signatures Σ1, Σ2, . . . Σn, to build
a new one, denoted Sp = c(Sp1, Sp2, . . . , Spn). We
can then see the connector c as a mapping of arity n
from |SPEC|n to |SPEC|. We will see in the ex-
amples that actually c may be a partial function, but
often deﬁned in a way sufﬁciently general to accept as
arguments tuples (Sp1, Sp2, . . . , Spn) with a large as-
sociated family of signature tuples (Σ1, Σ2, . . . , Σn).
• as speciﬁcations will be recursively deﬁned by means
of connectors, the arguments Sp1, Sp2, . . . Spn of
the connector c can be linked together by some con-
straints on elements present in speciﬁcation signatures,
expressed by signature morphisms. These constraints
will be taken into account by the deﬁnition of the con-
nector c. Hence, the arguments of a connector c will
not be a tuple of n speciﬁcations, but n speciﬁcations
equipped with signature morphisms. This will be de-
ﬁned by a graph whose nodes are speciﬁcations and
edges are signature morphisms. In our category theory
based setting, such a graph is called a diagram of the
speciﬁcation category SPEC. In practice, for a given
connector c, all the diagrams accepted as arguments by
6TF ′(A) (resp. TF (A)) is the term algebra built over F ′ (resp. F)
with sorted variables in the carrier A of the Γ-algebra A.

54
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
c have the same graph shape (i.e. the same organiza-
tion between nodes and edges). Hence, our connectors
will be built on the diagram category with the same
shape over the category SPEC.
• the signature Σ of Sp is the least one over the sig-
natures Σ1, Σ2, . . . , Σn. This expresses the fact that
generally, a connector c does not explicitly introduce
new elements to be speciﬁed, but on the contrary only
combines the elements already present in one of the
signatures Σ1, Σ2 . . . Σn. In the following deﬁnition
of connectors, this will be expressed by the co-limit of
the diagram, projected on signatures.
This then leads us up to formally deﬁne architectural
connectors as follows:
Notation. 1 (Diagram category) Let I and C be two cat-
egories. Note ∆(I,C) the category of diagrams in C with
shape I, i.e. the category whose objects are all functors
δ : I → C, and morphisms are natural transformations be-
tween functors δ, δ′ : I → C.
Let I′ be a subcategory of a category I. Let δ be a dia-
gram of ∆(I,C). Let us denote δ|I′ the diagram of ∆(I′,C)
obtained by restricting δ to I′.
Deﬁnition. 11 (Co-cone) Given a diagram δ : I → C. A
co-cone of δ consists of an object c ∈ |C| and a I-indexed
family of morphisms αi : δ(i) → c such that for each edge
e : i → i′ in I, we have that αi′ ◦ δ(e) = αi.
A co-limiting co-cone (co-limit) (c, {αi}i∈I) can be un-
derstood as a minimal co-cone, that is:
Deﬁnition. 12 (Co-limit) A co-cone (c, {αi}i∈I) of a dia-
gram δ is a co-limit if, and only if it has the property that
for any other co-cone (d, {βi}i∈I) of δ, there exists a unique
morphism γ : c → d such that for every i ∈ I, γ ◦ αi = βi.
When I is the category • ← • → • with three objects and
two non-identity arrows, the co-limit is called a pushout.
Deﬁnition. 13 (Co-complete) A
category
C
is
co-
complete if for every shape category I, every diagram
δ : I → C has a co-limit.
In the sequel, we will then consider institutions whose
the signature category is co-complete.
Deﬁnition. 14 (Architectural connector) Let SL be a
speciﬁcation language over an institution I for which the
category Sig is co-complete.
An architectural connector
c : |∆(I,SP EC)| → |SPEC| is a partial mapping such that
every δ ∈ ∆(I,SP EC) for which c(δ) is deﬁned, is equipped
with a co-cone p : Sig ◦ δ → Sig(c(δ)) co-limit of Sig ◦ δ.
Example. 1 (Enrichment and union) Enrichment
and
union of speciﬁcations have surely been the ﬁrst primitives
architectural
connectors
(so-called
structuring
primi-
tives) to be formally deﬁned and studied especially when
dealing with speciﬁcations deﬁned as axiomatic speci-
ﬁcations.
They even received an abstract formalization
in institutions [8].
In our framework, both structuring
primitives are deﬁned as follows: we consider an institu-
tion I = (Sig, Sen, Mod, |=). Moreover, in Example 1,
SPEC is the category whose objects are speciﬁcations of
the form (Σ, Ax) over a given institution I and morphisms
are any σ : (Σ, Ax) → (Σ′, Ax′) s.t. σ : Σ → Σ′ is a
signature morphism.
Enrichment Let I be the graph composed of two nodes
i and j and one arrow a : i → j. The connector En-
rich for axiomatic speciﬁcations is deﬁned for every di-
agram δ : I → SPEC where δ(i) = (Σ, Ax) and
δ(j) = (Σ′, Ax′) such that Sen(Sig(δ(a)))(Ax) ⊆ Ax′,
and yields Enrich(δ) = (Σ′, Ax′) together with the co-
cone Sig(δ(a)) and IdSig(δ(j)) which is the obvious co-
limit of Sig ◦ δ. Observe that δ(a) and Idδ(j) are further
speciﬁcation morphisms.
Union Let I be the graph composed of three nodes i, j,
and k and two arrows a1 : i → j and a2 : i → k. The con-
nector Union is deﬁned for every diagram δ : I → SPEC
where δ(i) = (Σ0, Ax0), δ(j) = (Σ1, Ax1) and δ(k) =
(Σ2, Ax2),
and such that Sen(Sig(δ(a1)))(Ax0)
⊆
Ax1 and Sen(Sig(δ(a2)))(Ax0)
⊆
Ax2, and yields
Union(δ) = (Σ, Ax) with the co-cone p : Sig ◦ δ → Σ
which is the pushout of Sig(δ(a1)) and Sig(δ(a2)) and
such that Ax = Sen(pj)(Ax1) ∪ Sen(pk)(Ax2). Observe
that we can derive the co-cone pSP EC : δ → (Σ, Ax) such
that Sig ◦ pSP EC = p, and pSP ECj and pSP ECk are spec-
iﬁcation morphisms.
In [8], both above connectors have been brought down
to two basic connectors: union with constant signatures S,
and translate _ by σ for every signature morphism σ. They
are deﬁned by:
1. Let I be the graph composed of two nodes i and j
and without arrows between i and j.
The connec-
tor S is deﬁned for every diagram δ : I → SPEC
where δ(i) = (Σ, Ax1) and δ(j) = (Σ, Ax2), and
yields S(δ) = (Σ, Ax) with the obvious co-limit p :
Sig ◦δ → Σ where pi and pj are the identity signature
morphism for Σ, and such that Ax = Ax1 ∪ Ax2.
2. Let I be the graph composed two nodes k and l. The
connector translate _ by σ where σ : Σ → Σ′
is a signature morphism, is deﬁned for every dia-
gram δ : I → SPEC where δ(k) = (Σ, Ax) and
δ(l) = (Σ′, Sen(σ)(Ax)), and yields translate _ by
σ(δ) = (Σ′, Sen(σ)(Ax)).

55
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
In [8], S(δ) and translate _ by σ(δ) are respectively noted
δ(i) S δ(j) and translate δ(k) by σ.
Architectural connectors can be combined to deal with
speciﬁcations in the large.
Deﬁnition. 15 (Connector combination) Let
c
:
|∆I,SP EC| → |SPEC| and c′ : |∆(I′,SP EC)| → |SPEC|
be two architectural connectors. Let i′ ∈ |I′| be an object.
Let I′ ◦i′ I be the category deﬁned by:
• |I′ ◦i′ I| = |I| ` |I′|
• the sets HomI′◦i′I(k, l) for every k, l ∈ |I′ ◦i′ I| are
inductively deﬁned as follows:
– k, l ∈ |I′| ⇒ HomI′(k, l) ⊆ HomI′◦i′I(k, l)
– k, l ∈ |I| ⇒ HomI(k, l) ⊆ HomI′◦i′I(k, l)
– for every i ∈ |I|, we introduce the arrow qi in
HomI′◦i′I(i, i′).
– HomI′◦i′I is closed under composition.
Let us denote c′ ◦i′ c : |∆I′◦i′I,SP EC| → |SPEC| the
architectural connector deﬁned by : 7
δ 7→















c′(δ|I′ )
if c(δ|I) is deﬁned
δ(i′) = c(δ|I)
and δ(qi) is the morphism ri in SPEC
whose the image by Sig is the component
pi of the co-limit p associated to c(δ|I)
undefined
otherwise
Example. 2 Enrichment can be removed and replaced by
the following combination of translate and ∪ as follows:
let δ be a diagram of ∆(I,SP EC) where I is the index
category of the connector Enrich, δ(i) = (Σ, Ax) and
δ(j) = (Σ′, Ax′)
Enrich(δ) =
[
◦itranslate_byδ′(pi)(δ′)
where δ′ is the diagram of ∆(I′′◦iI′,SP EC) for I′′ (resp.
I′) the index category of the connector ∪ (resp. translate),
deﬁned by: δ′(k) = δ(i), δ′(i) = translateδ′(k)byδ′(pi) =
(Σ′, Sen(Sig(pi))(Ax)) and δ′(j) = (Σ′, Ax′ \ Ax).
The reader accommodated to the terminology and to the
concepts of software architecture can be disappointed by the
way connectors are interpreted here, i.e. by functions that
take components and produce systems. Indeed, connectors
are typically viewed as forms of communicating compo-
nents. Such connectors can also be formalized in our frame-
work. For instance, in Community [15, 16], in the style of
Allen and Garlan [6], a connector consists of n roles Ri and
7qi is the arrow introduced in HomI′◦i′ I(i, i′).
one glue G stating the interaction between roles (i.e. the
way roles communicate together). Roles and glue are pro-
grams deﬁned over signatures (see [16] for a complete def-
inition of programs). In our framework, programs denote
speciﬁcations from which we can observe temporal proper-
ties. Each role and the glue are interconnected by a channel
to denote via signature morphisms shared attributes and ac-
tions. This gives rise to a diagram deﬁned as the intercon-
nection on the glue G of basic diagrams of the form:
channel
Ri
G
In Community, the mathematical meaning of a connector is
then deﬁned by the colimit of such diagrams. This can be
easily deﬁned in our framework by considering a connec-
tor c deﬁned for every diagram of the previous form over
the category PROG (deﬁned in [16]) taken as the category
SPEC.
4.2
Complex structuring
As already explained in the introduction of the paper,
an architectural connector will be considered as complex
when:
1. The global system does not preserve the complete be-
havior of some subsystems. We will then talk about
non-conformity properties.
2. Some global properties cannot be deduced from a com-
plete knowledge of these components. We will then
talk about true emergent properties.
This is expressed by comparing the set of semantic con-
sequences of subsystems with the ones of the global system
up to signature morphisms.
Deﬁnition. 16 (Complex connector) Let
c
:
|∆(I,SP EC)|
→
|SPEC| be an architectural connec-
tor. Let δ be a diagram of ∆(I,SP EC) such that c(δ) is
deﬁned. c is said complex for δ if, and only if one of the
two following properties fails:
1. Conformity.
∀i ∈ I, ∀ϕ ∈ Sen(Sig(δ(i))), ϕ ∈ δ(i)•
Sig(δ(i)) ⇐⇒
Sen(pi)(ϕ) ∈ c(δ)•
Sig(c(δ))

56
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
2. Non true emergence.
∀ϕ ∈ c(δ)•
Sig(c(δ)),
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))) |=Sig(c(δ))
ϕ
A formula ϕ that makes fail the equivalence of both Point 1.
and Point 2. is called emergent property.
If c is not complex for a diagram δ, then it is said modular.
Example. 3 Here, we give a very simple example of spec-
iﬁcations in which modularity fails. Let Nat be the speciﬁ-
cation in EQL deﬁned as follows:
Speciﬁcation of Nat Sorts: SNat = { nat }
Functions :
FNat
=
{0 :→ nat ,
succ : nat → nat ,
_ + _ : nat × nat → nat }
Axioms: AxNat
=
{x + 0 = x
x + succ(y) = succ(x + y)}
Let us us enrich this speciﬁcation by adding operations
and axioms to specify stacks of natural numbers. This leads
to the following enrichment:
Sorts: SStack = { nat, stack }
Functions :
FStack
=
FNat
∪
{empty :→ stack ,
push : nat × stack → stack ,
pop : stack → stack ,
top : stack → nat ,
high : stack → nat}
Axioms: AxStack
=
AxNat
∪
{pop(empty) = empty
pop(push(e, P)) = P
top(push(e, P)) = e
high(push(e, P)) = succ(high(P))}
If we suppose that realizations are either the initial
model or reachable models 8 of both speciﬁcations, then an
example of emergent property is:
∀x, (x = 0) ∨ (∃y, x = succ(y))
This is because high(empty) has not been speciﬁed to
be equal to 0. On the contrary, if we add this equation in
AxStack, there is not emergent property anymore.
8A model is reachable when any of its values is the result of the evalu-
ation of a ground term.
4.3
Conditions for modularity
As we have explained it in the introduction of this
manuscript, complex software systems prevent to check
their correctness with respect to their speciﬁcation step by
step by taking the beneﬁt of their recursive structure. This
leads to the important consequence that adding any compo-
nent gives rise to a new systems whose the correctness has
to be completely (re)checked. It is then important to study
general properties that guarantee when a system is not com-
plex (i.e. modular). This is what we propose to do with the
two following results.
Theorem 1 states that showing the non-presence of true
emergent properties for a connector c and a diagram δ
comes to show that (
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))• is deﬁn-
able by c(δ).
Theorem. 1 Let c be an architectural connector and δ be a
diagram such that c(δ) is deﬁned. Then, we have:
(
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))• is deﬁnable by c(δ) if, and
only if the set of true emergent properties is empty and each
pi is a speciﬁcation morphism.
Proof. The
only
if
part.
This
obviously
results
from
the
fact
that
(
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))•
is
deﬁnable
by
c(δ).
Indeed,
we
have
c(δ)•
Sig(c(δ)
=
(
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))•,
that
is
for
every
ϕ
∈
c(δ)•
Sig(c(δ)),
we
have
that
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))) |=Sig(c(δ)) ϕ.
The if part. As each pi of p is a speciﬁcation morphism,
we have that (
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))• ⊆ c(δ)•
Sig(c(δ).
Moreover, as the set of true emerging properties is empty,
we have that c(δ)•
Sig(c(δ) ⊆ (
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))•.
Hence, c(δ)•
Sig(c(δ) = (
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))•, and
then
(
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))• is deﬁnable by c(δ).
By Theorem 1, the architectural connectors Enrich,
Union, S and translate _ by σ have no true emergence
properties for any deﬁned diagram.
As we could expect, modularity is a property which
holds for some, but certainly not for all architectural con-
nectors.
More surprising, even under the condition that

57
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
(
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))• is deﬁnable by c(δ) for a con-
nector c and a diagram δ such that c(δ) is deﬁned, mod-
ularity can fail because of non-conformity properties (see
Example 3).
In the next theorem, we give a supplementary condition
based on the liberality of each pi of the co-limit p, that leads
to an empty set of non-conformity properties. For Theo-
rem 2, we suppose the following conditions :
1. the institution under consideration is closed under iso-
morphism,
2. Real is compatible for every speciﬁcation morphism
pi of the associated co-cone p, and
3. each pi of the co-limit p associated to the con-
nector c in ∆(I,SP EC) satisﬁes the supplemen-
tary condition,
so-called Right Satisfaction Con-
dition (RSC) : ∀ϕ
∈
Sen(Sig(δi)), ∀M
∈
Real(c(δ)), Real(pi)(M)
|=Sig(δi)
ϕ
=⇒
M |=Sig(δ(c)) Sen(pi)(ϕ).
The interest of RSC is, realizations being a subset of mod-
els, some pruning on realizations in Real(δ(c)) have been
allowed to be done, and then this direction of the satisfac-
tion condition has been able to be brought into failure. For
instance, this property does not hold when speciﬁcations are
logical theories and realizations are restricted to reachable
models (see Example 3). For the next theorem, we suppose
that these three conditions hold.
Theorem. 2 Let c be an architectural connector and δ
be a diagram such that c(δ) is deﬁned.
Suppose that
(
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))• is deﬁnable by c(δ), Real is
compatible with each pi and each pi is liberal. Then, for
every i ∈ I and every M ∈ Real(δ(i)), If each adjunct
morphism µM : M → Real(pi)(F(pi)(M)) is an isomor-
phism, then the set of non-conformity properties is empty.
Proof. Let ϕ ∈ δ(i)•
Sig(δ(i)), and let M ∈ Real(c(δ)).
As (
[
i∈I
Sen(pi)(δ(i)•
Sig(δ(i))))•
is deﬁnable by c(δ),
Real(pi)(M) |=Sig(δ(i)) ϕ.
Therefore, by the hypothe-
sis that the truth of property is preserved for the functor
Real through each signature morphism pi, we have that
M |=Sig(c(δ)) Sen(pi)(ϕ).
let ϕ ∈ Sen(δ(i)) such that Sen(pi)(ϕ) ∈ c(δ)•, and let
M ∈ Real(δ(i)). As F(pi) is left-adjunct to Real(pi), we
have F(pi)(M) |=Sig(c(δ)) Sen(pi)(ϕ). As Real is com-
patible with each pi, Real(σ)(F(pi)(M)) |=Sig(δ(i)) ϕ.
As the adjunct morphism is an isomorphism and I is sta-
ble under isomorphism, M and Real(σ)(F(pi)(M)) are
elementary equivalent, and then M |=Sig(δ(i)) ϕ.
Theorem 2 generalizes to any architectural connectors
the standard condition of modularity based on the two no-
tions of hierarchical consistency and sufﬁcient complete-
ness [22], which has been stated for the enrichment connec-
tor in the algebraic speciﬁcation framework (when speciﬁ-
cations are conditional positive).
5
Application to reactive systems
In this section, we propose to exemplify our abstract
framework to reactive system modeling. We will then give a
rigorous and formal deﬁnition of emergent properties in the
framework of reactive system modeling. We restrict our-
selves to reactive systems described by means of the usual
synchronous product of transition systems, and whose be-
havior is expressed by logical properties over MFOL. The
reason is this is sufﬁcient for the purpose of the study, and
the results given in this paper could easily be adapted to
temporal logics more classically used to reason on reactive
systems and other composition connector whose the great-
est number are based-on transition system product. In our
setting, we will study some conditions under which non-
conformity properties do not occur. The interest is this pro-
vides guidance in the design process. Indeed, the appear-
ance of non-conformity properties leads to make a posteri-
ori veriﬁcation of the global system without beneﬁting from
the decomposition of the system into components.
In Section 5.1, we introduce transition systems and their
semantics, and deﬁne the synchronous product as means to
compose them. Finally, Section 5.2 presents results ensur-
ing the non-existence of non-conformity properties along
synchronous product.
5.1
Transition systems
5.1.1
Syntax
As usual when considering automata, transition systems
describe possible evolutions of system states. Elementary
evolutions are represented by a transition relation between
states. Each transition between two states is labeled by three
elements: actions of the system, guards expressed here by
formulas of FOL presented in Section 2, and side-effects
on states deﬁned by pairs of ground terms or of the form
(p(t1, . . . , tn), b) where p(t1, . . . , tn) is a ground atom and
b is equal to true or false. As usual, we start by deﬁn-
ing the language, so-called signature, on which transition
systems are built:
Deﬁnition. 17 (Signature) A signature is a triple L
=
(Σ, V, A) where: Σ is a FOL-signature, V is a set of vari-
ables over Σ and A is a set whose elements are called ac-
tions.

58
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
Deﬁnition. 18 (Side-effect) Given a signature L
=
(Σ, V, A) where Σ = (S, F, P), a side-effect over L is a
pair of ground terms over Σ (t, t′) of the same sort (i.e.
∃s ∈ S, t, t′ ∈ TF ) or a couple (p(t1, . . . , tn), b) where
p(t1, . . . , tn) is a ground Σ-atom (i.e. each ti is a ground
term) and b is equal to true or false. In the sequel, a side-
effect (t, t′) will be noted t 7→ t′.
We note SE(L) the set of side-effects over L.
A transition system is then deﬁned as follows:
Deﬁnition. 19 (Transition system) Given
a
signature
L
= (Σ, V, A), a transition system is a couple (Q, T)
where:
• Q is a set of states, and
• T ⊆ Q × A × Sen(Σ) × 2SE(L) × Q.
A small speciﬁcation example is given in [2]. Transi-
tion systems are speciﬁcations of reactive systems. Given
a signature morphism σ : (Σ, A) → (Σ′, A′) and a spec-
iﬁcation S′ = (Q′, T′) over (Σ′, A′), Spec(σ)(S′) is the
speciﬁcation S = (Q, T) over (Σ, A) such that Q = Q′ and
T = {(q, a, ϕ, δ, q′)|(q, σ(a), Sen(σ)(ϕ), σ(δ), q′) ∈ T′}.
5.1.2
Semantics
Semantics of transition systems are deﬁned by Kripke
frames themselves deﬁned as follows:
Deﬁnition. 20 (Kripke frame) Given a signature L
=
(Σ, V, A), an Kripke frame over L or L -model, is a cou-
ple (W, R) where:
• W is a I-indexed set (Wi)i∈I of Σ-models such that
W i
s = W j
s for every i, j ∈ I and s ∈ S, and
• R is a A-indexed set of “accessibility” relations Ra ⊆
I × I.
Here, states are deﬁned by Σ-models. Therefore, side-
effects will consist on moving from a Σ-model to another
one by changing the semantics of functions according the
assignments given in the set δ of transitions. Formally, this
is deﬁned as follow: if A is a Σ-model, then _A : TF → A
is the Σ-morphism inductively deﬁned by f(t1, . . . , tn) 7→
f A(tA
1 , . . . , tA
n )
Deﬁnition. 21 (Side-effect semantics) Let L = (Σ, V, A)
be a signature. Let A and B be two Σ-models. We note
A ;δ B to mean that the state A is transformed into the
state B along δ, if and only if B is deﬁned as A except that
for every t 7→ t′ ∈ δ (resp. p(t1, . . . , tn) 7→ b), tB = t′A
(resp. (tA
1 , . . . , tA
n ) ∈ pB iff b = true).
Deﬁnition. 22 (Semantics of transition systems) Given a
transition system S = (Q, T) over a signature L , the se-
mantics for S, noted Real(S), is the set of all the Kripke
frames (W, R) over L such that the set of indexes I = Q,
and satisfying both implications:
1. (q, a, ϕ, δ, q′) ∈ T ∧ Wq |= ϕ ∧ Wq ;δ Wq′
⇒ q Ra q′
2. q Ra q′
⇒ ∃(q, a, ϕ, δ, q′) ∈ T, Wq |= ϕ ∧ Wq ;δ Wq′
Hence, the way whose dynamic is dealt with in this paper
follows the state-as-algebra style [21, 3] where states are
Σ-models and state transformations are transitions from a
state-model to another state-model.
5.1.3
Synchronous product
Synchronous product combines two transition systems into
a single one by synchronizing transitions. Understandably,
executions of synchronous product modelize system behav-
ior as a synchronizing concurrent system. Hence, when an
action a is “executed” in the product, then every compo-
nent with a in its alphabet must execute a transition labeled
with a. Formally, the synchronous product of two transition
systems is deﬁned as follows:
Deﬁnition. 23 (Synchronous product) Let Si = (Qi, Ti)
be a transition system over a signature Li = (Σi, Vi, Ai)
with i = 1, 2 such that:
• for every transition (q1, a, ϕ1, δ1, q′
1) ∈ T1 and ev-
ery f(t1, . . . , tn) 7→ t′
1 ∈ δ1 (resp. p(t1, . . . , tn) 7→
b
∈
δ1),
there
does
not
exist
a
transition
(q2, a, ϕ2, δ2, q′
2)
∈
T2 and a side-effect t2
7→
t′
2
∈
δ2 with t2 of the form f(t′
1, . . . , t′
n) (resp.
p(t′
1, . . . , t′
n) 7→ b′ ∈ δ2),
• and conversely, that is this condition on side-effects
has also to be satisﬁed by replacing T1 by T2, δ1 by
δ2 and δ2 by δ1.
The synchronous product of S1 and S2, noted S1⊗S2, is the
transition system (Q, T) over L = (Σ1 ∪Σ2, V1 ∪V2, A1 ∪
A2) deﬁned as follows:
• Q = Q1 × Q2
• if a
∈
A1 ∩ A2, (q1, a, ϕ1, δ1, q′
1)
∈
T1 and
(q2, a, ϕ2, δ2, q′
2) ∈ T2 then
((q1, q2), a, ϕ1 ∧ ϕ2, δ1 ∪ δ2, (q′
1, q′
2)) ∈ T
• if a ∈ A1 \ A2 and (q1, a, ϕ1, δ1, q′
1) ∈ T1 then for
every q2 ∈ Q2, ((q1, q2), a, ϕ1, δ1, (q′
1, q2)) ∈ T

59
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
• if a ∈ A2 \ A1 and (q2, a, ϕ2, δ2, q′
2) ∈ T2 then for
every q1 ∈ Q1, ((q1, q2), a, ϕ2, δ2, (q1, q′
2)) ∈ T
Both conditions on side-effects allow us to remove the case
where for an identical function name f (resp. a predicate p)
applied to an identical tuple of arguments yields different
values, and then causes the functionality of f (resp. makes
inconsistent the set of side-effects resting on p) to fail.
By following the notions of our abstract framework, the
synchronous product gives rise to the connector Sync. To
deﬁne this connector, we consider the shape I composed
of three nodes i, j and k and two arrows a1 : i → j and
a2 : i → k. The connector Sync is then deﬁned for ev-
ery diagram δ where δ(i) is the empty transition system
over the signature (Σ∅, Ai) where Σ∅ is the empty FOL-
signature, δ(j) = (Qj, Tj) over the signature (Σj, Aj) and
δ(k) = (Qk, Tk) over the signature (Σk, Ak), and yields
Sync(δ) = δ(j) ⊗ δ(k) over the signature (Σ, A) with the
co-cone p : Sig ◦ δ → (Σ, A) which is the pushout of
Sig(δ(a1)) and Sig(δ(a2)) in Sig.
5.2
Results
The synchronous product of two transition systems S1 ⊗
S2 have generally true emergent properties.
The reason
is the set Mod(Th(S•
1 ∪ S•
2)) of Kripke frames may be
greater than Real(S1 ⊗ S2).
Indeed, Kripke frames in
Real(S1 ⊗ S2) have to preserve the shape of the transition
system S1⊗S2 unlike Kripke frames in Mod(Th(S•
1∪S•
2)).
Hence, properties in (S1⊗S2)• may be more numerous than
in Th(S•
1 ∪ S•
2). However, we can show under some con-
ditions that non-conformity properties cannot occur along
synchronous product. More precisely, we are going to show
that the “only if” part of the conformity property is satisﬁed
but the “if” part only holds when formulas that label tran-
sitions are conditional equations (i.e. expressed in the logic
CEL).
Let us start by showing that the semantic consequences
of S1 and S2 are preserved by S1 ⊗ S2. Let us suppose
a S1 ⊗ S2-model (W, R), and let us deﬁne a Li-model
(Wi, Ri) for i = 1, 2 as follow:
• for every q ∈ Qi, Wq
i = Mod(Σi ,→ Σ)(W(q,q′)) for
any q′ ∈ Qj with j ̸= i ∈ {1, 2}
• ∀a ∈ Ai, Ria = {(q, q′)|∃ϕ ∈ Sen(Σi), ∃δ ∈
SE(L), (q, a, ϕ, δ, q′) ∈ Ti}
Let us note Γi for i = 1, 2, the set of all these Li-models.
Theorem. 3 Each (Wi, Ri) ∈ Γi is a Si-model.
Proof. The ﬁrst condition of Deﬁnition 22 is obvious. To
prove the second condition, let us suppose a transition
(q, a, ϕ, q′) ∈ Ti. By construction, there exists a transi-
tion ((q, qj), a, ϕ′, δ′, (q′, q′
j)) ∈ T such that either ϕ′ = ϕ
and δ′ = δ, or ϕ′ = ϕ ∧ ϕ′′ and δ′ = δ ∪ δ′′. In both cases,
by hypothesis, we have that (W(q,qj) |= ϕ′. Therefore, by
the satisfaction condition for FOL Wq
i |= ϕ. Moreover, by
the condition on side-effects in Deﬁnition 23, we have that
Wq
i ;δ Wq′
i
Proposition. 2 ∀ι : V → W,
(∀(Wi, Ri) ∈ Γi, ∀q ∈ Qi, (Wi, Ri) |=q
ι ϕ)
=⇒ (∀qj ∈ Qj, (W, R) |=(q,qj)
ι
ϕ)
Proof. By induction on the structure of ϕ.
Basic case. ϕ is of the form p(t1, . . . , tn). Let qj ∈
Qj. By deﬁnition, there exists (Wi, Ri) ∈ Γi such that
Wq
i = Mod(Σi ,→ Σ)(W(q,qj)). By hypothesis, we have
Wq
i |=ι p(t1, . . . , tn), and then W(q,qj) |=ι p(t1, . . . , tn).
General case. Let us handle the case where ϕ is 2aϕ′.
Let us suppose that (W, R) |=(q,qj)
ι
ϕ. Then, let us consider
(q′, qj) such that (q, qj) Ra (q′, q′
j). By the hypothesis, we
have for every (Wi, Ri) ∈ Γi that (Wi, Ri) |=q
ι ϕ. By con-
struction, we also have q Ria q′ for every (Wi, Ri) ∈ Γi.
Therefore, for every (Wi, Ri) ∈ Γi, (Wi, Ri) |=q
ι ϕ′, and
then by the induction hypothesis, we have (W, R) |=
(q′,q′
j)
ι
ϕ′, whence we can conclude (W, R) |=
(q′,q′
j)
ι
ϕ.
The cases of Boolean connectives and quantiﬁer are sim-
pler and left to the interested reader.
Theorem. 4 S•
i ⊆ (S1 ⊗ S2)•
Proof. Let ϕ ∈ S•
i , and let (W, R) ∈ Real(S1 ⊗ S2). Let
ι : V → W be an interpretation. By Theorem 3, for every
model (Wi, Ri) ∈ Γi, we have (Wi, Ri) |= ϕ, and then
for every q ∈ Qi we also have (Wi, Ri) |=q
ι ϕ. There-
fore, by Proposition 2, we have for every qj ∈ Qj that
(W, R) |=(q,qj)
ι
ϕ, and then (W, R) |= ϕ.
To show the “if” part of the conformity property, we need
to make some restrictions on formulas that label transitions.
Hence, we suppose that transition systems are built over the
logic CEL, and then given a model (W, R) of transition
system S, for each q ∈ Q, Wq is now an algebra. There-
fore, the logic for transition systems is the modal ﬁrst-order
logic deﬁned as in Section 2 except that now Σ-atoms are
restricted to Σ-equations.
Given two transition systems S1 and S2 over the signa-
tures L1 and L2, respectively, and satisfying the above re-
striction, for i ̸= j ∈ {1, 2}, and for every (Wj, Rj) ∈
Mod(Sj) we deﬁne the mapping F(Wj,Rj) : Mod(Si) →
Mod(L) where L is the signature over which the transition
system S1 ⊗S2 is built as follow: if we note for a Σ-algebra
A, th(A) = {ϕ|ϕ : CEL-formula, A |= ϕ}, then to every

60
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
(Wi, Ri), F(Wj,Rj)((Wi, Ri)) = (W, R) such that (W, R)
is the L-model deﬁned by 9
• ∀q ∈ Qi, ∀q′ ∈ Qj, W (q,q′) = TΓi/Γ(Wq
i ) ×
TΓj/Γ(Wq
i )
• Ra
=
{((q1, q′
1), (q2, q′
2))|∃ϕ
∈
Sen(Σ), ∃δ
∈
SE(L), ((q1, q′
1), a, ϕ, (q2, q′
2)) ∈ T}
where Γi = th(Wq
i ), Γj = th(Wq′
j ), and Γ = th(Wq
i ) ∪
th(Wq′
j ).
Theorem. 5 For every (Wj, Rj) ∈ Mod(Sj) and every
(Wi, Ri) ∈ Mod(Si), F(Wj,Rj)((Wi, Ri)) is a S1 ⊗ S2-
model.
Proof. The ﬁrst condition of Deﬁnition 20 is obvious. To
prove the second condition, let us suppose a transition
((q1, q′
1), a, ϕ, δ, (q2, q′
2)) ∈ T. By construction, ϕ and δ
are:
1. either of the form ϕ′ ∧ ϕ′′ with ϕ′ ∈ Sen(Σi) and
ϕ′′ ∈ Sen(Σj) and δ′ ∪ δ′′ with δ′ ∈ SE(Li) and
δ′′ ∈ SE(Lj),
2. or ϕ ∈ Sen(Σi)∪Sen(Σj) and δ ∈ SE(Li)∪SE(Lj).
This then leads to the two following cases:
1. Suppose that ϕ is of the form ϕ′ ∧ ϕ′′ and then
δ
= δ′ ∪ δ′′.
This means by construction, that
(q1, a, ϕ′, δ′, q′
1) ∈ Ti and (q2, a, ϕ′′, δ′′, q′
2) ∈ Tj.
By hypothesis, we have Wq1
i
|= ϕ′ and Wq′
j 1
|=
ϕ′′.
Therefore, we have that TΓi/Γ(Wq1
i ) |= ϕ′ ∧
ϕ′′ and TΓj/Γ(Wq2
j ) |= ϕ′ ∧ ϕ′′, and then so is
9Cartesian product and preservation results Let Σ be a signature, I
be a set and (Ai)i∈I be a I-indexed family of Σ-algebras. Let us note
Y
i∈I
Ai the Σ-algebra deﬁned as follow:
• for every s ∈ S, its carrier of sort s is
Y
i∈I
(Ai)s,
• for every f : s1 × . . . × sn → s ∈ F, f
Y
i∈I
Ai
is the mapping that
to every (a1, . . . , an) ∈
Y
i∈I
(Ai)s1 ×. . .×
Y
i∈I
(Ai)sn, associates
(fAi(ai
1, . . . , ai
n)|i ∈ I) where given a ∈
Y
i∈I
(Ai)s, ai is the ith
coordinate of a.
By construction, we can notice that:
Y
i∈I
Ai |=ι ϕ ⇐⇒ ∀i ∈ I, Ai |=ιi ϕ
where for every interpretation ι, ιi is the interpretation deﬁned by x 7→ ai
if ι(x) = a. It is well-known that conditional equations are preserved by
Cartesian product of algebras, that is, if for every i ∈ I, Ai |= Γ ⇒ α,
then
Y
i∈I
Ai |= Γ ⇒ α.
TΓi/Γ(Wq1
i ) × TΓj/Γ(Wq2
j ) (recall that conditional
equations are preserved along the cartesian product of
algebras). Moreover, by hypothesis, we also have that
Wq1
i
;δ′ Wq2
i
and Wq2
j
;δ′′ Wq′
2
j . By deﬁnition,
Γi (resp. Γj) contains the ground equational theory of
Wq1
i
(resp. Wq2
j ). If we note Γ′
i = th(Wq′
1
i ), Γ′
j =
th(Wq′
2
j ) and Γ′ = th(Wq′
1
i ) ∪ th(Wq′
2
j ), then we have
TΓi/Γ(Wq1
i ) ;δ TΓ′
i/Γ′(Wq2
i ) and TΓj/Γ(Wq2
j ) ;δ
TΓ′
j/Γ′(Wq′
2
j ).
2. The case where ϕ ∈ Sen(Σi) ∪ Sen(Σj) and δ′ ∈
SE(Li) and δ′′ ∈ SE(Lj) is noticeably similar to the
previous one.
MFOL is closed under isomorphism. Moreover, by The-
orem 3, Real is compatible with each morphisms pi of the
co-cone p associated to the connector Sync. Finally, by
Proposition 2 and Theorem 4, RSC is satisﬁed. Therefore,
Theorem 6 is a specialization of Theorem 2.
Theorem. 6 If for every (Wi, Ri)
∈
Mod(Si), every
(Wj, Rj) ∈ Mod(Sj), and every q ∈ Qi and every
q′ ∈ Qj, the adjunct morphism µWq
i : Wq
i → Mod(Σi ,→
Σ)(TΓi\Γ(Wq
i )) is an isomorphism, then (S1 ⊗ S2)• ∩
Sen(Li) ⊆ S•
i .
Proof. Let ϕ ∈ (S1 ⊗ S2)• ∩ Sen(Si) and let (Wi, Ri) ∈
Mod(Si). By Theorem 5, for every (Wj, Rj) ∈ Mod(Sj),
we have that F(Wj,Rj)((Wi, Ri)) |= ϕ. As the adjunct mor-
phism µWq
i is an isomorphism, for every ι : V → Wi there
exists ι′ : V → TΓi/Γ(Wi)×TΓj/Γ(Wj) such that ι = pi◦ι′
where pi is the i-th projection map pi : TΓi/Γ(Wq
i ) →
TΓi/Γ(Wq
i ) ⊗ TΓj/Γ(Wq′
j ) for q ∈ Qi and q′ ∈ Qj.
By hypothesis, for every q ∈ Qi and every q′ ∈ Qj,
F(Wj,Rj)((Wi, Ri)) |=(q,q′)
ι′
ϕ. It is then easy to show by
induction on the structure of ϕ that (Wi, Ri) |=q
ι ϕ.
Example. 4 When dealing with formulas expressed in the
logic CEL to label transitions, we often make restrictions
on algebras denoting states.
Indeed, to allow inductive
proofs or for computability reasons, state-algebras are then
restricted to reachable 10 or some quotients of the ground
term algebra. Let us the suppose for the below counter-
example of the conditions given in Theorem 6, that we re-
strict our approach to state-algebras deﬁned by reachable
algebras. Let us consider the two following transition sys-
tems S1 and S2 deﬁned respectively over the two following
signatures L1 and L2:
10A Σ-algebra is reachable if, and only if the unique Σ-morphism
µ : TF → A is surjective, that is all the values in A are denoted by
the evaluation of a ground term.

61
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
Σ1 =











S = {nat},
F =



0 :→ nat;
s : nat → nat,
+ : nat × nat → nat


 ,
P = ∅
Σ2 =



S = {nat},
F = {0 :→ nat; s, p : nat → nat},
P = ∅
A1 = A2 = {a}
Let us deﬁne S1 and S2 as follows:
• S1 = ({q1, q2}, {q1
a,ϕ1,δ1
−→
q2}) where ϕ1 = (s(x) =
s(y) ⇒ x = y)∧x+0 = x∧x+s(y) = s(x+y) and
δ1 = ∅. S2 = ({q′
1, q′
2}, {q′
1
a,ϕ2,δ2
−→
q′
2}) where ϕ2 =
(s(x) = s(y) ⇒ x = y) ∧ s(p(x)) = x ∧ p(s(x)) = x
and δ2 = ∅.
By deﬁnition of S1 (resp. S2), the unique S1-model (resp.
S2-model) is (W, R) where Wq1
1
= Wq2
1
= N (resp.
Wq′
21
= Wq′
22
= Z).
On the contrary, by construction,
in S1 ⊗ S2, we have the transition (q1, q′
1)
a,ϕ′,δ′
−→ (q2, q′
2)
where ϕ′ = ϕ1 ∧ ϕ2 and δ′ = ∅, and then all the S1 ⊗ S2-
model satisfy W(q1,q′
1) = W(q2,q′
2) = Z. Consequently, the
modal formula ϕ′ ⇒ 2a(∀x.∃y.x + y = 0) belongs to
(S1 ⊗ S2)• but not in S•
1. The reason is F(W2,R2)(Wq1
1 ) =
Z. Therefore, the adjunct functor µWq1
1
is injective but not
surjective, and then is not an isomorphism.
6
Conclusion
In this paper, our main contribution is twofold. First,
we have formally deﬁned the notion of emergent properties
independently of formalism, and of the form of both spec-
iﬁcations and architectural connectors. Secondly, we have
studied in this abstract framework, some general conditions
that enable us to obtain two general properties that guar-
antee when a system is not complex. These conditions are
based on the category theory of morphism conservativeness
and adjunction. Finally, to illustrate our abstract framework,
we have instantiated our abstract framework with reactive
component-based systems described by transition systems
and combined together through synchronous product, and
we have applied our general results to obtain global sys-
tems lacking of non-conformity properties which have been
recognized as being the cause of bad interactions between
components.
An ongoing research that we are currently pursuing is to
extend abstract connectors to heterogeneous abstract con-
nectors, that is connectors deﬁned on component speciﬁca-
tions described in heterogeneous formalisms. For this pur-
pose, we will take beneﬁt from [11, 23] and from works that
we made on hierarchical heterogeneous speciﬁcations [9].
References
[1] M. Aiguier, P. Le Gall, and M. Mabrouki. A formal deﬁ-
nition of complex software. In ICSEA 2008: Proceedings
of the 2008 The Third International Conference on Software
Engineering Advances, pages 415–420. IEEE Computer So-
ciety, 2008.
[2] M. Aiguier, P. Le Gall, and M. Mabrouki. Emergent prop-
erties in reactive systems.
In APSEC 2008: Proceedings
of the 2008 15th Asia-Paciﬁc Software Engineering Confer-
ence, pages 273–280. IEEE Computer Society, 2008.
[3] M. Aiguier. Étoile-speciﬁcations: An object-oriented alge-
braic formalism with reﬁnement. Journal of Logic and Com-
putation, 14(2):145–178, 2004.
[4] M. Aiguier, C. Gaston, and P. Le Gall. Feature logics and
reﬁnement. In APSEC 2002: Proceedings of the 9th Asian
Paciﬁc Software Engeenering Conference, pages 385–395.
IEEE Computer Society Press, 2002.
[5] R. Allen.
A Formal Approach to Software Architecture.
PhD thesis, Carnegie Mellon, School of Computer Science,
Junuary 1997. Issued as CMU Technical Report CMU-CS-
97-144.
[6] R. Allen and D. Garlan. A formal basis for architectural
connectors. ACM TOSEM, 6(3):213–249, 1997.
[7] L. Blass, P. Clements, and R. Kasman. Software Architecture
in Practice. Addison Wesley, 1998.
[8] T. Borzyszkowski. Logical systems for structured speciﬁca-
tions. Theoretical Computer Science, 286:197–245, 2002.
[9] S. Coudert and P. Le Gall. A reuse-oriented framework for
hierarchical speciﬁcations. In AMAST 2000: Proceedings
of the 8th International Conference on Algebraic Methodol-
ogy and Software Technology, pages 438–453, London, UK,
2000. Springer-Verlag.
[10] R.-I. Damper. Emergence and levels of abstraction. Inter-
national Journal of Systems Science, 31(7):811–818, 2000.
Editorial for the Special Issue on ’Emergent Properties of
Complex Systems’.
[11] R. Diaconescu. Grothendieck institutions. Applied Categor-
ical Structures, 10(4):383–402, 2002.
[12] R. Diaconescu. Jewels of institution-independent model the-
ory. In K. Futatsugi, J.-P. Jouannaud, and J. Meseguer, ed-
itors, Algebra, Meaning, and Computation, Essays Dedi-
cated to J.-A. Goguen on the Occasion of His 65th Birth-
day, volume 4060 of Lecture Notes in Computer Science.
Springer-Verlag, 2006.
[13] A.-C. Ehresmann and J.-P. Vanbremeersch. Memory Evo-
lutive Systems: Hierarchy, Emergence, Cognition. Elsevier
Science, 2007.
[14] H. Ehrig, M. Balmadus, and F. Orejas. New concepts for
amalgation and extension in the framework of speciﬁca-
tion logics. In AMAST 1991: Algebraic Methodology and
Software Technology, Lecture Notes in Computer Science.
Springer, 1991.
[15] J.-L. Fiadeiro.
Categories for Software Engineering.
Springer-Verlag, 2004.
[16] J.-L. Fiadeiro, A. Lopes, and M. Wermelinger.
A math-
ematical semantics for architectural connectors.
In R.-C.
Backhouse and J. Gibbons, editors, Generic Programming,
volume 2793 of Lecture Notes in Computer Science, pages
178–221. Springer-Verlag, 2003.

62
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
[17] D. Garlan, R.-T. Monroe, and D. Wile. Acme: An architec-
ture description interchange language. In CASCON 1997:
Proceedings of the 1997 conference of the Centre for Ad-
vanced Studies on Collaborative research, pages 169–183.
IBM Press, 1997.
[18] C. Gaston, M. Aiguier, and P. Le Gall.
Language Con-
structs for Decsribing Features, chapter Algebraic treat-
ment of feature-oriented systems, pages 105–125. Springer-
Verlag, 2000.
[19] J. Goguen. Advances in Cybernetics and Systems Research,
chapter Categorical Foundations for General Systems The-
ory, pages 121–130. Transcripta Books, 1973.
[20] J. Goguen and R.-M. Burstall. Institutions: Abstract model
theory for speciﬁcation and programming. Journal of the
ACM, 39(1):95–146, 1992.
[21] Y. Gurevich. Evolving algebras 1993: Lipari guide. In Spec-
iﬁcation and Validation Methods, pages 9–36. Oxford Uni-
versity Press, 1995.
[22] J.-V. Guttag and J.-J. Horning. The algebraic speciﬁcation
of abstract data types. Acta Informatica, pages 27–52, 1978.
[23] T. Mossakowski. Institutional 2-cells and grothendieck insti-
tutions. In Essays Dedicated to Joseph A. Goguen, volume
4060 of Lecture Notes in Computer Science, pages 124–149.
Springer, 2006.
[24] F. Orejas. Algebraic Foundations of Systems Speciﬁcation,
chapter Structuring and Modularity, pages 159–201. IFIP
State-of-the-Art Reports. Springer, 1999.
[25] D. Perry and A. Wolf. Foundations for the study of software
architectures. ACM SIGSOFT Software Engineering Notes,
17(4):40–52, 1992.
[26] M. Plath and M. Ryan. Feature integration using a feature
construct. Science of Computer Programming, 41(1):53–84,
2001.
[27] A. Sernadas, C. Sernadas, and C. Caleiro.
Denota-
tional semantics of object speciﬁcation. Acta Informatica,
35(9):729–773, 1998.
[28] A. Tarlecki. Moving between logical systems. In M. Hav-
eraaen, O. Owe, and O.-J. Dahl, editors, Recent Trends in
Data Type Speciﬁcations. 11th Workshop on Speciﬁcation of
Abstract Data Types, volume 1130 of Lecture Notes in Com-
puter Science, pages 478–502. Springer Verlag, 1996.
[29] A. Tarlecki. Algebraic Foundations of Systems Speciﬁca-
tion, chapter Institutions: An abstract Framework for For-
mal Speciﬁcations, pages 105–131.
IFIP State-of-the-Art
Reports. Springer, 1999.

