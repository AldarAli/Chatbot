Towards an Operational Semantics for Solidity
Marco Crosara
Dept. of Computer Science
University of Verona, Italy
Email: marco.crosara@studenti.univr.it
Gabriele Centurino
Dept. of Computer Science
University of Verona, Italy
Email: gabriele.centurino@studenti.univr.it
Vincenzo Arceri
Dept. of Computer Science
University of Verona, Italy
Email: vincenzo.arceri@univr.it
Abstract—Solidity is a multi-paradigm programming language
used for writing smart contracts on the Ethereum blockchain
and offers a wide range of features, such as Ethereum transfers
between contracts or wallets of normal users. Its speciﬁcation is
not formally deﬁned, the behaviours of Solidity constructs are
informally provided by its documentation, leading to misunder-
standings and buggy code. Without a formal semantics, reasoning
about programs becomes extremely hard, if not impossible. In
this paper, we provide a ﬁrst-step towards a formal operational
semantics for Solidity, deﬁning a memory model for the language,
able to capture its main features.
Keywords–Programming Languages; Solidity; Semantics.
I.
INTRODUCTION
We intend to deﬁne a complete semantics of a core of
Solidity [1], but this is not a simple task. In order to reach this
goal, we have to deal with an unusual actor: the blockchain
[2]. Due to its presence, providing a formal semantics for
Solidity [3] could result challenging for two reasons. The
ﬁrst one is relative to the frequently updating language, since
Solidity continuously changes the constructs and mechanics of
operations [4]. For this reason, in this work, we have chosen
a speciﬁc version of the compiler: 0.5.10. The second one
is that we have to deal with the Storage of the blockchain,
that is separated from the memory of the Ethereum Virtual
Machine (EVM). In this paper, we provide a ﬁrst step toward
a formal semantics of Solidity, modelling the memory and
the interaction that happens between a smart contract and
the blockchain. In the next section, we describe the Solidity
language, the domains and the memory model used. In Section
III we present its concrete semantics for some basic constructs
and in Section IV we extend the semantics to contracts and
functions. Finally, we provide some ideas for future related
works.
II.
SOLIDITY
Solidity is the most popular language to write smart con-
tracts on the Ethereum blockchain. Intuitively, a smart contract
is a computer program designed to execute some actions when
some condition is veriﬁed [2]. Solidity has been designed to
offer a simple way to develop a smart contract and for this
reason, it is strongly inspired by JavaScript. Unlike JavaScript,
it is object-oriented and statically typed. When we deploy
a contract on the blockchain, the Solidity code has to be
executed by the EVM. Inside this environment, we have a set
of instructions called opcodes that are encoded in byte code
in order to have a more efﬁcient store. Each opcode has a
cost of execution, this is needed to prevent the execution of
inﬁnite loops or similar and to reward the miners who validate
the transactions. This cost is expressed in unit of Gas and the
price per unit is expressed in GWei, a fraction of an Ethereum
token. 1 Ethereum (ETH) corresponds to 1 × 1018 Wei, that
are 1 × 109 GWei. For the sake of simplicity, we assume that
any operation inside the blockchain has been equipped with
enough gas to correctly end its execution. In our work, we
chose not to handle transactions in memory, studying only the
interaction that they have with the blockchain.
A. Memory and Storage
Solidity provides three types of memory, namely Stack,
used to hold local variables of primitive type (uint256, bool,
etc.), Storage is a persistent memory and is a key-value
store where keys and values are both 32 bytes, storing, for
instance, state variables. Finally, Memory is a byte-array that
contains data until the execution of the function, used to save,
for example, function arguments. In this paper, we do not
distinguish between Stack and Memory. According to the real
model described, the evaluation of expressions and statements
in our work is made considering the tuple σ = ⟨Nρ, ρ, C, A⟩.
We can split this tuple in two halves, namely Memory and
Storage. The ﬁrst one refers to the EVM Memory and the
second one to the blockchain. Nρ e ρ are respectively the
Namespace and the link between address and values. Instead
A stands for Accounts and contains the balances of contract
address and normal user address. C stands for Contracts and
contains, for any contract, the corresponding Storage and all
the functions with the corresponding signature. Formally, we
deﬁne the State σ, as follows.
–
Nρ ∈ Memory is a function s.t. Nρ : ID → MLOC
contract Bank {
uint money = 0;
constructor () public payable {
money = msg.value;
}
function sendEther () public payable {
money += msg.value;
if(money > 300000000000000000){//0.3 ETH
msg.sender.transfer(money);
money = 0;
}
}
function () external payable {}
}
Figure 1. Example of a simple contract written in Solidity.
1
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

Solidity ::= (Contract)*
Contract ::= contract id { (St)* }
St
::= Method | StateDef
StateDef ::= Type id ;
|
Type id = Exp ;
Type ::= uint | bool | address | address payable
Method ::= function id((Type id,)*) (Qualiﬁer)*
{(Stmt)*}
|
function()external payable { (Stmt)* }
|
constructor((Type id,)*) public |
internal { (Stmt)* }
Qualiﬁer ::= public | internal | external
|
private | returns( Type id )
BinOp ::= + | - | * | / | % | && | || | == | !=
|
> | < | >= | <=
UnOp ::= - | !
Stmt ::= ϵ
|
Type id (= Exp)? ;
|
if( Exp )Stmt (else Stmt)?
|
while( Exp ) Stmt
|
{ (Stmt)* }
|
return (Exp)? ;
|
Exp ;
Exp ::= Literal
|
id( (Exp ,)* )
|
id.transfer(Exp)
|
Exp BinOp Exp
|
UnOp Exp
|
id = Exp
|
id
Literal ::= n ∈ UINT
|
b ∈ BOOL
|
a ∈ ADDR
|
ea ∈
ADDRP
Figure 2. Syntax of Solidity core.
–
ρ ∈ Memory is a function s.t. ρ : MLOC → V with
V = UINT ∪ BOOL ∪ ADDR ∪ ADDRP
–
A ∈ Storage is a function s.t. A : ADDR → UINT
–
C ∈ Storage is a function s.t. C : ADDR → ⟨λ, Nµ, µ⟩
Where λ = ⟨P, I, E, R⟩, Nµ : ID → SLOC and µ :
SLOC → V
λ contains contracts functions that are divided by access
level: Public, Internal, External, PRivate ⟨P, I, E, R⟩, each
element in λ is also a function ⟨ID, ForParams⟩ → BODY and
ForParams is a list of ⟨Type, ID⟩ but for simplicity, sometimes
we will refer to it with a string of the type (Type id,)∗. BODY
is a string with a sequence of statements: (Stmt)∗. The qualiﬁer
of a function can be [4]:
–
public: Public functions are part of the contract
interface and can be either called internally or via
messages.
–
internal: Those functions and state variables can
only be accessed internally (i.e., from within the
current contract or contracts deriving from it), without
using this.
–
external: External functions are part of the contract
interface, which means they can be called from other
contracts and via transactions. An external function f
cannot be called internally.
–
private: Private functions and state variables are
only visible for the contract they are deﬁned in and
not in derived contracts.
In this paper, we suppose that in each moment we have
another namespace Nσ, which determines the last declaration
of a variable, between Memory and Storage. Formally, it is
always Nσ = (σ.C(˙c).Nµ)[Nρ] where ˙c is the current contract
address.
B. Domains
The followings are the Solidity domains considered for this
paper:
–
n ∈ UINT = { 0, 1, 2, ..., 2256 − 1}: the domain of
Unsigned Integers, corresponding to the uint256 type
in the Solidity language. We deﬁne two numbers, ˜N =
2256 and ˆN = 2256 − 1, where ˆN is the max value
that can be assigned.
–
a ∈ ADDR is the domain of Addresses. The addresses
are used as unique identiﬁer inside the blockchain:
every contract, every user and every transaction
has one. In Solidity the address type holds a 20
byte value (size of an Ethereum address), e.g.,
‘0xbb9bc244d798123fde783fcc1c72d3bb8c189413’.
The same address could be also declared as Address
Payable, this is necessary to allow transfers of ETH
on it, as we will explain later. The domain of payable
address is ADDRP and with ea we denote an element
of it.
–
b ∈ BOOL = {true, false}: the domain of Booleans.
–
x ∈ ID is the domain of Identiﬁers. In Solidity, an
identiﬁer is a string with the pattern [a-zA-Z_$][a-zA-
Z_$0-9]*. An ID element could be a variable name, a
contract name or a function name.
–
LOC: the domain of Locations. We can have two types
of locations, namely Memory Locations (MLOC) and
Storage Locations (SLOC). Hence we have LOC =
MLOC ∪ SLOC s.t. MLOC ∩ SLOC = ∅.
In our work, we denote by type(σ, x) ∈ {uint, bool,
address,
address payable}
the
type
x
in
σ,
e.g.,
type(⟨{x → l}, {l → 5}, C, A⟩, x) = uint. We abuse notation
denoting type(σ, l), l ∈ LOC, the type of a location.
Address and Address Payable: In our core, there are two
ways to declare addresses and the difference is the keyword
payable. A payable address can be the receiver of some ETH
sent using a transfer or a send function in a smart contract.
Trying transfer money to a non-payable address would result
in a compiler error. Therefore, for example the transfer
function could not be invoked on a non-payable address. In
sight of this, we can state that the keyword payable is only
used in order to force the developer to wisely choose which
address should be able to receive ether or not. In our semantics,
the meta-variables of address can be interchangeable with the
one of address payable.
2
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

L n Mσ
def= n, n ∈ UINT
L b Mσ
def= b, b ∈ BOOL
L a Mσ
def= a, a ∈ ADDR
L ea Mσ
def= ea, ea ∈ ADDRP
L e1 + e2 Mσ
def= (n1 +Num n2)% ˜N
L e1 − e2 Mσ
def= (n1 −Num n2)% ˜N
L e1 ∗ e2 Mσ
def= (n1 ·Num n2)% ˜N
L e1 / e2 Mσ
def= (n1 /Num n2)% ˜N with n2 ̸= 0
L e1 % e2 Mσ
def= (n1 % n2)% ˜N
L −e1 Mσ
def= L 0 − e1 Mσ
L e1 Mσ
def= n1, L e2 Mσ
def= n2
function checkPlusMin() public
,→ returns (uint n5, uint n6, uint
,→
n7) {
uint n1 = 2**256 - 1;
uint n2 = 1;
uint n3 = 2**255 + 333333;
uint n4 = 2**255 + 4444444;
return (n1 + n2, n3 + n4, 0 - n2);
}
> checkPlusMin()≫(0,4777777,2**256-1)
Figure 3. (a) Identity (b) Arithmetic expressions (c) Example of overﬂow.
C. Environment access and Memory updating
In our semantics, when we need to access a tuple, for
the sake of readability, we use the dots notation. For ex-
ample, if σ = ⟨Nρ, ρ, C, A⟩ we write σ.C to access C
of σ. Note that, in some cases we will refer directly to
Nρ, ρ, C, A, λ, Nµ, µ respectively instead of each ones with
σ preﬁxed: σ.Nρ, σ.ρ, σ.C...
Updating of a single value in Memory:
ρ ∈ Memory, l ∈ MLOC,
k ∈ V = UINT ∪ BOOL ∪ ADDR ∪ ADDRP
ρ[l ← k] = ρ′ ∈ Memory
⇐⇒
ρ′(l) = k and ∀l′ ∈ MLOC . l′ ̸= l . ρ′(l′) = ρ(l′)
Updating of a Memory with another Memory:
ρ, ρ′ ∈ Memory, l ∈ MLOC, k ∈ V
Loc(ρ) = {l | (l 7→ k) ∈ ρ}
ρ[ρ′] = ρ′′ ∈ Memory
⇐⇒
∀l ∈ Loc(ρ) ∪ Loc(ρ′) . ρ′′(l) =
ρ′(l)
l ∈ Loc(ρ′)
ρ(l)
otherwise
Similarly, we can deﬁne Memory namespace update with
single value (Nρ[x ← l]) and update between Memory names-
paces (Nρ[N ′
ρ]). The same is also true for Nµ, µ, C, A update.
III.
CONCRETE SEMANTICS OF SOLIDITY
In this section, we deﬁne our core (Figure 2) and we
provide a formal semantics for it [5]. We focus the attention on
the standard constructs of programming languages, the more
blockchain related constructs will be treated in Section IV.
There will be also some examples that we will use to motivate
the results. The semantics is captured by the function L · M that
we will deﬁne in the next sections.
A. Expressions Semantics
We denote the domain of expressions by e ∈ Exp. In
this section, we deﬁne the main semantics expressions of our
Solidity core. The semantics of expressions is captured by
the function L · M : Exp × State → V × State, that evaluates
an expression in a State and returns a ﬁnal value, with the
previous State modiﬁed by the evaluation. For convenience
when the State σ does not change the evaluation, it returns
only V. As we have already mentioned before, in our core we
consider four primitive types: bool, address (payable and not),
and uint. Each type has been deﬁned as a domain of its values:
UINT, BOOL, ADDR and ADDRP. According to this, we have
four identity rules (Figure 3a). We also have other rules that
refer to unary and binary operators. In Solidity, like in every
other programming languages, we have many of them but we
selected only the ones that have been deﬁned in the syntax.
Any numeric operator (Figure 3b) has a correspondent in the
concrete. The rules consider the numeric overﬂow, indeed in
UINT we can represent, like previously stated, the max value
ˆN and we will have an overﬂow using the next integer ( ˜N),
this one is used by the rules through the modulo operator. A
Solidity UINT overﬂow example is shown in Figure 3c.
The rules regarding And, Or and Negation for the binary
operators (Figure 4a) are trivial. It is interesting to talk about
Equality and Inequality operators among the different types.
In these rules, we have the operator □ ∈ {==,!=} and the
operator  that is the numeric counterpart of the ﬁrst one.
For example, if == is the syntactic notation, =Num is the
corresponding numeric operator. Each rule checks that the
type of e1 is the same of e2 and returns a boolean value.
An exception is the type ADDRP that is equal to ADDR for
the reason previously speciﬁed. The next rule is similar to
L e1 && e2 Mσ
def=
(
false
L e1 Mσ
def= false
L e2 Mσ
L e1 Mσ
def= true
L e1 || e2 Mσ
def=
(
true
L e1 Mσ
def= true
L e2 Mσ
L e1 Mσ
def= false
L !e Mσ
def=
(
true
L e Mσ
def= false
false
L e Mσ
def= true
L e1 □ e2 Mσ
def=













n1 Num n2
L e1 Mσ
def= n1 ∧ L e2 Mσ
def= n2
b1 Bool b2
L e1 Mσ
def= b1 ∧ L e2 Mσ
def= b2
a1 Adr a2
L e1 Mσ
def= a1 ∧ L e2 Mσ
def= a2
ea1 Adr ea2
L e1 Mσ
def= ea1 ∧ L e2 Mσ
def= ea2
a1 Adr ea2
L e1 Mσ
def= a1 ∧ L e2 Mσ
def= ea2
L e1 ♦ e2 Mσ
def= (n1 ♦· Num n2) ∈ {true, false}
Figure 4. (a) Boolean expression semantics (b) Relational expression semantics.
3
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

the previous, but the operator ♦ ∈ {>, <, >=, <=} with
the counterpart ♦· is only deﬁned for numerical expressions.
Afterwards, we will deﬁne other two rules regarding the
semantics expressions.
1) Assignment: In this rule and the following ones, we
suppose that ˙c is the current contract address and that σ =
⟨Nρ, ρ, C, A⟩.
L x = e Mσ
def=
(
⟨g, σ′⟩ with g
def= L e Mσ
Nσ(x) ∈ MLOC
⟨g, σ′′⟩ with g
def= L e Mσ
Nσ(x) ∈ SLOC
σ′ = ⟨Nρ, ρ[Nρ(x) ← g], C, A⟩
σ′′ = ⟨Nρ, ρ, C[˙c ← ⟨λ, Nµ, µ′′⟩], A⟩
with µ′′ = µ[Nµ(x) ← g]
if Nσ(x) ̸= ⊥
The assignment in Solidity depends on the variable x which
we are referring to. If Nσ(x) ∈ MLOC it means that the
variable has been deﬁned into the EVM Memory (potentially
could exist an x inside the Store). In this case, priority is
given to the local variable and we only modiﬁed ρ based on
the address contained in Nρ. Otherwise, if Nσ(x) ∈ SLOC it
means that it does not exist a local variable with that identiﬁer.
However, for the precondition rule Nσ(x) ̸= ⊥, there is
always a global variable x, thus we modify µ associating the
evaluation result of e to the Storage address of x.
2) Lookup:
L x Mσ
def=
ρ(Nρ(x))
Nσ(x) ∈ MLOC
C(˙c).µ(C(˙c).Nµ(x))
Nσ(x) ∈ SLOC
if Nσ(x) ̸= ⊥
Like the previous rule, when in the code a variable x is
used, the returned value is determined with reference to the
location where the last declaration happened. According to
this, the value of x in the Memory ρ or in the Storage µ
is returned.
B. Statements Semantics
In this section, we deﬁne the formal semantics of State-
ments. Let denote by s ∈ Stmt the sets of statements. With
a slight abuse of notation, we denote the statement semantics
evaluation with L · M : Stmt × State → State, that evaluates a
statement in a State σ and returns the State modiﬁed by the
evaluation.
1) Skip:
L ϵ Mσ
def= σ where ϵ is the empty statement
2) Lacal Variable Declaration:
L uint x = e1; Mσ
def= ⟨Nρ[x ← l], ρ[l ← L e1 Mσ], C, A⟩
with L e1 Mσ ∈ UINT
l ∈ MLOC fresh and Nρ(x) = ⊥
The ﬁrst semantics rule in this section is the empty state-
ment, the following are regarding the variables declaration.
The declaration of local and state variables is syntactically
the same, so the correct rule is chosen accordingly to the
position of statement. We distinguish if the declaration is
inside the body of a function or directly inside the contract.
The declaration of a local variable, differently from the only
assignment, also modiﬁes Nρ. Therefore, a new location is
added and the evaluated expression will be saved on it.
3) State Variable Declaration:
L uint x = e1; Mσ
def= σ′ = ⟨Nρ, ρ, C′, A⟩
with C′ = (C[˙c.Nµ(x) ← l])[˙c.µ(l) ← L e1 Mσ]
with L e1 Mσ ∈ UINT, l ∈ SLOC fresh
if Nµ(x) = ⊥
The declaration of state variable is similar but in this case
Nµ and µ are modiﬁed. In each case, there is a precondition:
a variable with the same name must not be already declared.
The rules for the other primitives types, which differ from uint
are easily deducible for similarity.
4) Declaration without initialisation:
L uint x; Mσ
def= L uint x = 0; Mσ
L bool y; Mσ
def= L bool y = false; Mσ
L address z; Mσ
def= L address z = 0x040; Mσ
Rules used for the declaration without initialisation can
be deﬁned as rewriting of the same rules with assignment.
The value assigned to the variable is the default value of each
primitive types. Other semantics rules related to constructs in
our core in Figure 5a, are the one for if (rewrite of if else)
and for while, where the single iteration is based on the
rewrite of if else. Then, we have the semantics of block:
after evaluating the statement inside the braces, the Memory
of such evaluation is returned, preserving however the initial
namespace Nρ. This happens because the declaration made
inside a block must not be considered as valid outside of it.
Examples are presented in Figure 5b and Figure 5c. Finally,
for the sequence of statements let’s proceed evaluating the ﬁrst
statement. On the state returned we evaluate the next statement.
IV.
CONCRETE SEMANTICS OF CONTRACTS
In this section, we provide the operational semantics for
contracts and functions. A Solidity ﬁle has sol extension, it
could contain some contracts, which are denoted by c. A ﬁle
can be considered as a sequence of contracts C. We denote by
st a structure type and by St a sequence of structure type. A
st could be a state variable or a function. In addition ω is used
to denote the constructor of the contract.
1) First:
L c1C Mσ
def= L C Mσ′′ with σ′′ = ⟨Nρ, ρ, C′, A′⟩
and σ′ = L c1 Mσ
def= ⟨N ′
ρ, ρ′, C′, A′⟩
with Nρ, ρ empty
To evaluate a Solidity ﬁle we have to execute the se-
quence of contracts which it contains. We evaluate every
contract on the state returned from the execution of the
previous one, replacing however N ′
ρ and ρ′ with a new
empty Memory Nρ, ρ. Indeed the Memory of the EVM is
not preserved from the execution of a contract to an another.
Let’s make a consideration now: C(˙c).λ.P and C(˙c).λ.E
are visible to all other contracts, but to call a method of
another contract it is necessary to create an instance of it, e.g.,
MyContract mc = new MyContract(); and that does not
4
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

L if(e) s else s′ Mσ
def=
(
L s Mσ
L e Mσ
def= true
L s′ Mσ
L e Mσ
def= false
L if(e) s Mσ
def= L if(e) s else ϵ Mσ
L while(e) s Mσ
def= L if(e){s while(e) s} else ϵ Mσ
L {s} Mσ
def= ⟨Nρ, ρ′, C′, A′⟩ with L s Mσ
def= ⟨N ′
ρ, ρ′, C′, A′⟩
L s s′ Mσ
def= L s′ M(L s Mσ)
function checkBlock()
,→ public returns (
,→ uint vx, uint vy) {
uint x = 0;
uint y = 0;
{ uint z = 0;
x = x + 1;
{ uint w = 0;
y = y + 1;
}
}
return (x, y);
}
> checkBlock()≫(1, 1)
function checkBlock2()
,→ public {
uint x = 0;
uint y = 0;
{ uint z = 0;
{ uint w = 0; }
w = w + 1; // <<
}
}
> Compile error: Undeclared id.
Figure 5. (a) IfElse, If, While, Block and Sequence of Stmt (b) Example of block: scoping of variables (c) Example of block: undeclared identiﬁer.
exist in our core. Furthermore C(˙c).λ.I is directly visible to
the contracts that derive from it, but to allow inheritance in
Solidity we need the is construct that is not inside our core.
2) Contract:
L contract cname {St} Mσ
def=
σ′′
ω ∈ St
L c′ Mσ
ω /∈ St
c′ = contract cname {constructor() public{} St}
σ′′ def=
L C′.λ.P(constructor, ∗) Mσ′
C′.λ.P(con..., ∗) ̸= ⊥
L C′.λ.I(constructor, ∗) Mσ′
C′.λ.I(con..., ∗) ̸= ⊥
with σ′ = L St Mσ
def= ⟨Nρ, ρ, C′, A′⟩
The evaluation of a contract if there is not any constructor,
add, ﬁrstly, the default constructor. Afterwards, all the structure
types contained are evaluated. After that, C(˙c) is populated
with functions and state variables of the contract. The ﬁnal step
is to execute the constructor code and return the evaluation of
it.
3) Function Declaration: For simplicity, we suppose that
functions with a return statement at the end of body, have the
respective returns(Exp) qualiﬁer in the function deﬁnition.
L function fname (FP) public {BODY} Mσ
def= σ′
L function fname (FP) public returns (rp) {BODY} Mσ
def= σ′
σ′ = ⟨Nρ, ρ, C′, A⟩ with C′ = C[˙c.λ.P.⟨fname, FP⟩ ← BODY]
if
C(˙c).λ.P(⟨fname, FP⟩) = ⊥, C(˙c).λ.I(⟨fname, FP⟩) = ⊥,
C(˙c).λ.E(⟨fname, FP⟩) = ⊥, C(˙c).λ.R(⟨fname, FP⟩) = ⊥
The evaluation of a function declaration is the addition of
the same to C(˙c).λ. For internal and private qualiﬁers the rule
is equivalent, with the modiﬁcation of I, E and R respectively
instead of P.
4) Constructor Declaration:
A constructor is optional.
Only one constructor for each contract can be deﬁned, which
means that overloading is not supported. In the code, no
function with name ‘constructor’ can be deﬁned. Constructor
functions can be either public or internal. If there is no con-
structor, the contract will assume the default empty constructor.
L constructor (FP) public {BODY} Mσ
def=
L function constructor (FP) public {BODY} Mσ
with σ.C(˙c).λ.P(constructor, ∗) = ⊥
and σ.C(˙c).λ.I(constructor, ∗) = ⊥
The constructor evaluation can be treated as a rewrite
of a normal function declaration, with identiﬁer the word
‘constructor’. We use this trick because the Solidity syntax
does not allow naming a function ‘constructor’. The rule is
the same for internal qualiﬁer.
5) Fallback Function Declaration: A fallback function is
a particular function that can be inside a contract. It has two
mandatory characteristics: it has to be anonymous and does
not have any arguments. It is executed whenever a function
identiﬁer does not match the available functions or if the
contract receives plain Ether without any other data associated
with the transaction. For this reason, it is good practice to
make it payable, so that it can receive ETH sent erroneously.
Consequently, in our core, we choose that the fallback function
is always payable. The fallback function has only 2300 units
of gas, leaving not much capacity to perform operations except
basic logging.
L function () external payable {BODY} Mσ
def=
L function ϵ (∅) external {BODY} Mσ
with σ.C(˙c).λ.E(ϵ, ∅) = ⊥
The idea of the fallback function semantics is the same as
the constructor one. The rule is given as rewrite of function
declaration with ϵ, namely the empty string, as name.
6) Return:
L return; Mσ
def= σ′ = ⟨Nρ[return ← l], ρ[l ← ϵ], C, A⟩
L return e; Mσ
def= σ′ = ⟨Nρ[return ← l], ρ[l ← L e Mσ], C, A⟩
The return statement is the last Stmt of function. It returns
directly a value or an expression that must be evaluated. To
transfer the return value to the caller, we save it in the Memory
with the identiﬁer ‘return’. The function call knows that, once
the evaluation of the function is completed, the return value is
stored in N ′
ρ(ρ′(return)).
5
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

7) Function Call:
L fname(e1...en) Mσ
def= L BODY Mσ′ = ⟨N ′
ρ(ρ′(return)), σ′′⟩
where σ′ = ⟨N ′
ρ, ρ′, C, A⟩ s.t. N ′
ρ = {(fpi ← li) | ∀i ∈ [1, n]},
ρ′ = {(li ← L ei Mσi−1) | ∀i ∈ [1, n], σ0 = σ}
li ∈ MLOC fresh and σ′′ = ⟨Nρ, ρ, C′, A′⟩
BODY =







Pbody = C(˙c).λ.P(fname, ∀i | ti)
Pbody ̸= ⊥
Ibody = C(˙c).λ.I(fname, ∀i | ti)
Ibody ̸= ⊥
Ebody = C(˙c).λ.E(fname, ∀i | ti)
Ebody ̸= ⊥
Rbody = C(˙c).λ.R(fname, ∀i | ti)
Rbody ̸= ⊥
where ti = type(L ei Mσi−1)
The semantics of a function call corresponds to the exe-
cution result of the function body. In particular, the function
body must be executed in a state taking into account of
the parameters passed to the function call, memory σ′. Then
C, A are unattached from σ while N ′
ρ and ρ′ contains all
the associations between actual and formal parameters. The
return instruction saves, as previously said, the ﬁnal value in
N ′
ρ(ρ′(return)). This one is returned to the caller with the
Storage modiﬁed by the last evaluation and the Memory that
the caller had before the call.
8) Transfer: We have chosen to implement the transfer
function. This is not the only way that exists to transfer
ETH between addresses, but is the most secure. In fact, there
are also the call function, that is now deprecated, and the
send function that can be still used but, contrary to the
transfer function, when it fails, it simply returns false and
does not propagate the exception. This behaviour can lead to
unwanted errors and vulnerabilities [6]. Regarding the way we
implemented the transfer function, we choose not to handle
the exceptions. We studied three possible results of transfers:
–
A transfer is done between two contracts with a correct
amount of ETH and no fallback function is invoked.
–
A transfer is done between two contracts with a correct
amount of ETH and a fallback function is invoked.
–
A transfer is done between two contracts with an
incorrect amount of ETH and this lead to an error.
L ea.transfer(n) Mσ
def= σ′
σ′ =





















⟨Nρ, ρ, C, (A[˙c ← A(˙c) − n])[ea ← A(ea) + n]⟩
1st case
⟨Nρ, ρ, C′, A′⟩
def= L C(ea).λ.E(ϵ, ∅) Mσ′′
| σ′′ = ⟨Nρ, ρ, C, A′⟩
2nd case
| A′ = (A[˙c ← A(˙c) − n])[ea ← A(ea) + n]
exception
3rd case
1st case : A(˙c) ≥ n ∧ (C(ea) = ⊥∨
(C(ea) ̸= ⊥ ∧ C(ea).λ.E(ϵ, ∅) = ⊥))
2nd case : A(˙c) ≥ n ∧ C(ea) ̸= ⊥ ∧ C(ea).λ.E(ϵ, ∅) ̸= ⊥
3rd case : A(˙c) < n
The three cases are described before. In the ﬁrst and second
case, we transfer the amount of ETH from ˙c to ea, but in
the second case the recipient is also a contract, therefore
the returned Memory depends on the execution of ea fallback
function. In Figure 1 we propose a simple example of a
contract that receives Ether and returns the full amount through
the invocation of function sendEther when the contract
balance is at least 0.3 ETH. The contract mentions the msg
ﬁeld that we have not covered in this core. It contains useful
information of the transaction, e.g., the sender and, for ETH
transfers, the amount sent.
V.
CONCLUSION AND FUTURE WORKS
In this paper, we have introduced a Solidity core and a
formal semantics for it. This required us to introduce a ﬁrst
concept of an abstract memory model, that is able to run
the code on the EVM. This model is also able to represent
blockchain and its complex structure and behaviour. In order
to extend our work, the next step is to create a more complete
and meaningful core by adding the missing constructs. In this
way, we will be able to provide a better representation of the
contracts on the blockchain. At this stage, our core is enough
to give a ﬁrst idea and can provide the semantics of only basic
contracts. As a future work, we plan to build a static analyzer,
based on abstract interpretation [7], for the smart contracts
written in Solidity.
REFERENCES
[1] K. Bhargavan et al., “Formal veriﬁcation of smart con-
tracts: Short paper,” in Proceedings of the 2016 ACM
Workshop on Programming Languages and Analysis for
Security, PLAS@CCS 2016, Vienna, Austria, October
24, 2016, T. C. Murray and D. Stefan, Eds.
ACM,
2016, pp. 91–96, URL: https://doi.org/10.1145/2993600.
2993611 [accessed: 2019-10-22].
[2] B. K. Mohanta, S. S. Panda, and D. Jena, “An overview
of smart contract and use cases in blockchain technology,”
in 2018 9th International Conference on Computing, Com-
munication and Networking Technologies (ICCCNT), July
2018, pp. 1–4.
[3] J. Zakrzewski, “Towards veriﬁcation of ethereum smart
contracts: A formalization of core of solidity,” in Veriﬁed
Software. Theories, Tools, and Experiments - 10th Inter-
national Conference, VSTTE 2018, Oxford, UK, July 18-
19, 2018, Revised Selected Papers, ser. Lecture Notes in
Computer Science, R. Piskac and P. Rümmer, Eds., vol.
11294.
Springer, 2018, pp. 229–247.
[4] “Ethereum - Solidity documentation,” 2019, URL: https://
solidity.readthedocs.io/en/v0.5.10 [accessed: 2019-10-22].
[5] J. Jiao et al., “Executable operational semantics of solid-
ity,” CoRR, vol. abs/1804.01295, 2018, URL: http://arxiv.
org/abs/1804.01295 [accessed: 2019-10-22].
[6] “King of the Ether Throne - Post-Mortem Investigation,”
2016, URL: https://www.kingoftheether.com/postmortem.
html [accessed: 2019-10-22].
[7] P. Cousot and R. Cousot, “Automatic synthesis of optimal
invariant assertions: Mathematical foundations,” SIGART
Newsletter, vol. 64, 1977, pp. 1–12.
[8] S. Sahoo, A. M. Fajge, R. Halder, and A. Cortesi, “A
hierarchical and abstraction-based blockchain model,” Ap-
plied Sciences, vol. 9, no. 11, Jun. 2019, p. 2343, URL:
http://dx.doi.org/10.3390/app9112343 [accessed: 2019-10-
22].
6
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

