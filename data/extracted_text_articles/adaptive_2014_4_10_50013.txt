Performance Evaluation of Reconﬁguration Algorithms for the Reconﬁgurable Network
on Chip Architecture RecMIN
Alexander Logvinenko, Dietmar Tutsch
University of Wuppertal
Emails: alexanderlogv@gmail.com, tutsch@uni-wuppertal.de
Abstract—The Reconﬁgurable Multi-Interconnection Network
(RecMIN) is a new network architecture that reduces inefﬁciency
and increases the throughput of the network on chip. The
RecMIN topology adapts itself to trafﬁc ﬂow by reconﬁguration.
Three reconﬁguration algorithms are employed, in order to take
advantage of the capabilities of the RecMIN architecture. The
η-algorithm, the minimal queues algorithm and the pattern
identiﬁcation algorithm allow the network to adapt itself to differ-
ent trafﬁc distributions. Furthermore, an observation technique
that notes changes in trafﬁc pattern is presented, in order to
avoid inﬁnite reconﬁguration processes. The performance of the
algorithms is presented.
Keywords-Network on Chip; Reconﬁguration Algorithms; Re-
conﬁguration Architecture.
I.
INTRODUCTION
Modern Systems on Chip (SoC) are built so that they
consist of many independent individually designed units (Intel-
lectual Property cores or IP- cores), e.g., cache memory, I/O
controllers, audio/video interfaces, etc. Buses were used up
to now in order to enable communication among these units.
Today, however, designers prefer Networks on Chip (NoC) for
efﬁcient interaction among IP-cores. Therefore, the speed and
efﬁciency of modern SoC depend not just on the speed of
single units of IP but also on the properties of the NoC used
[1]. The main properties of the NoC are source output, target
throughput and packet delay. The latter ones depend not just on
topology of the network, routing algorithm, buffering strategy,
packet switching but also on how efﬁciently network operates
in case of bottlenecks during the packet trafﬁc ﬂow.
The popular solution to solve the problem of a partially
overloaded network (bottlenecks) due to inefﬁciency, is to
implement a complex algorithm that reroutes data ﬂow in NoC.
The complexity of such algorithms usually grows exponen-
tially with the size of network. So, as an alternative to the re-
routing algorithms, some works from the academic community
have been focusing on the possibility of adopting NoC by
reconﬁguration.
For instance, Tutsch and L¨udtke [2][3][4] and Al Faruque
[5][6] suggest that the directions of data ﬂow should be
changed in order to optimize the NoC for special trafﬁc
proﬁles. Unlike them, this paper continues the previously
[7][8][9] introduced topic of the RecMIN architecture. In this
article, however, we present three different algorithms for the
optimization of a network that uses the RecMIN architecture.
The paper is structured as following: Section 2 introduces
the reconﬁguration architecture RecMIN. Section 3 deals with
the η-function, which enables to evaluate of the network-
on-chip performance. In most important Section 4, three al-
gorithms are presented and compared: η algorithm, minimal
ques algorithm, pattern identiﬁcation algorithm. Section 5
concludes.
II.
RECONFIGURATION ARCHITECTURE RECMIN
The main problem of NoC as compared to the full con-
nection of all inputs/outputs is the chance of bottlenecks to
arise given certain trafﬁc structures. In this work, Multistage
Interconnection Metwork (MIN) architecture is used, which
is built out of 2 × 2 routers [10]. An example of this kind
of network is shown in Fig. 1. The technical realisation of
MIN topology is given, e.g., in [11] and [12]. One of the
characteristics of MIN is that all the trafﬁc loads have to pass
through all the stages of the MIN. Especially for asymmetrical
trafﬁc, the connection wires between the stages can lead to
tailbacks.
Figure 1.
MIN architecture with 8x8 inputs/outputs built out of 2x2 routers
Reconﬁguration architecture RecMIN solves the problem
of bottlenecks in two out of three possible cases. The proposal
is to create the MIN not from the 2x2 routers, as usual, but
from speciﬁc reconﬁguration half cells - Reconﬁguration Half
Cell (RecHC). The architecture of this cell is given in Fig. 2.
RecHC has 8 inputs and 8 outputs. In front of each input,
one buffer element is located. Each half-cell can be used in
one of these two possible modes: In the ﬁrst mode (Mode A),
the RecHC consists of four independent 2x2 routers. In the
85
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-341-4
ADAPTIVE 2014 : The Sixth International Conference on Adaptive and Self-Adaptive Systems and Applications

RecHC0
Figure 2.
The architecture of reconﬁguration half cell - RecHC
second mode (Mode B), there is however just one 4x4 router
in the upper part of the cell, and four simple wire connections
without any logic in its bottom part. If a RecHC changes the
mode from A to B (Fig. 3), then packets which arrive in the
upper part of the Half Cell are distributed correctly without
problems. Though, in the bottom part of the RecHC problems
may arise, since in the mode B no redirection takes place,
and the packets are transferred straight forward (Fig. 3). For
example, after switching from mode A to mode B some packets
in buffer of input i4 that are addressed to output o5 have no
possibility to arrive at their targets (e.g., IP-cores). Therefore,
usage of two half cells simultaneously is to be preferred.
R
R
R
a                       b
R
R
i0
i1
i2
i3
i4
i5
i6
i7
i0
i1
i2
i3
i4
i5
i6
i7
o0
o1
o2
o3
o4
o5
o6
o7
o0
o1
o2
o3
o4
o5
o6
o7
Figure 3.
RecHC in two modes. a: mode A, b: mode B
The two RecHCs are put together (the second one upside
down), to form one reconﬁguration cell - RecCell (Fig. 4).
If both of RecHCs that build RecCell are put into the Mode
A, then the construction leads to two independent MINs (Fig.
4a), with 4x4 inputs-outputs and 2x2 routers each. If the two
RecHCs are put in mode B, then two independent 4x4 routers
emerge (Fig. 4b). The other two combinations (AB and BA)
are meaningless and therefore are not used. So, a full cell has
two possible reconﬁgurations: folded (BB) and unfolded (AA).
With RecCells, it is possible to build a MIN. The resulting
structure is called RecMIN. If the number of 2x2 switches
R
R
R
R
R
R
R
R
R
R
RecHC0
RecHC1
RecHC0
RecHC1
a
b
Figure 4.
RecCell in two modes. a: unfolded mode, b: folded mode
in MIN is divisible by 16, the entire network can be built
from reconﬁguration cells. Otherwise, it is necessary to use
two non-reconﬁgurable 2x2 switches in order to connect the
reconﬁguration cells. Therefore, RecMIN with an arbitary
number of 2x2 routers can be implemented.
C0 
C1
C2 
C3 
Figure 5.
RecMIN with 16 inputs/outputs
In this paper, the RecMIN with 16 inputs outputs is used
as an example for RecMIN architecture (Fig. 5). This RecMIN
can be build out of four RecCells: C0, C1, C2 and C3.
If we compare our architecture (Fig. 6) with the one of
the non-reconﬁgurable MIN with 2x2 routers, we will see that
the dotted line marked router connection (between the ﬁrst
and the second stage of the 2x2 routers) can be reconﬁgured.
So, if the trafﬁc in the network generates bottlenecks in these
places, the NoC can reconﬁgure its topology according to the
adaptation of the architecture to the trafﬁc load, and so increase
the throughput of the network and decrease the packet delay.
It can be said that if the trafﬁc unfortunately generates
a bottleneck in one of the non-reconﬁgurable wires, the re-
conﬁguration will not help. But, usually, the designer of the
NoC knows the application for which the network is to be
designed, and so can pre-arrange the most expected bottleneck-
wires inside the reconﬁguration cells.
The other way around, the 4x4 router would have less
throughput than a 2x2 router [13]. So, for the symmetrical high
load (more than 0.63 ﬂits per clock cycle), the 4x4 routers will
automatically become NoC bottlenecks. In this case, a back
86
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-341-4
ADAPTIVE 2014 : The Sixth International Conference on Adaptive and Self-Adaptive Systems and Applications

Figure 6.
RecMIN with 16 inputs/outputs
reconﬁguration of the RecCells to unfolded mode is necessary
(see [13]).
The other disadvantage of the architecture is that two
independent routers of the NoC are now bonded together. If
one of the 4x4 routers of RecCell ”decides” to change mode
(from unfolded to folded or other way around), it has to check
if the other router of the same RecCell will ”agree” to change
the mode as well.
III.
EVALUATION OF NETWORK PERFORMANCE
The network performance of asymmetrical NoC for asym-
metrical load is measured by three main parameters: through-
put of network sources (ςi, where i is a number of the source in
NoC), throughput of network targets (τi, where i is a number
of the target in NoC), and packet delay for each target (δi,
where i is a number of the target in NoC). To evaluate network
efﬁciency dependent on the packet load, we use η-function:
η =
N−1
X
i=0
(ςi ∗ Cςi + τi ∗ Cτi + δi ∗ Cδi)
(1)
where N is the number of sources/targets in NoC and
constants Cςi, Cτi, Cδi are priority weights for throughput
and delay deﬁned by SoC designer. By setting the priorities
the designer speciﬁes how important the corresponding NoC
parameter is.
For example, for speciﬁc NoC the throughput for sources
and targets may be not as important as a minimal delay.
Furthermore, packet delay is especially important for the
targets T4 and T5. In this case, the constants Cςi, Cτi, Cδi
can be adjusted as follows:
Cςi = Cτi = 0
[clock cycles/ﬂit]
for i ∈ {0, .., N − 1}
Cδi = −1
[clock cycles]−1
for i ∈ {0, .., N − 1}n{4, 5}
Cδ4 = Cδ5 = −2
[clock cycles]−1
.
(2)
The parameter ςi, τi, δi depend on the topology of the
network, and are calculated using simulation. By simulating
the different network reconﬁgurations, designer is able to
compare the performance of different network topologies for
speciﬁed trafﬁc. Table 1 gives an example for a network with
16 inputs and 16 outputs consisting of four RecCells (Fig. 6).
Constants of priorities are chosen according to (2).
In Table 1, Gi is the notation for each source (generator)
i; Ptr (Gi) is the probability that the source i sends a packet
per clock time unit; Prec (Tx) is the probability that the target
node x receives a packet from the generator i (Gi) per clock
time unit.
-500
-400
-300
-200
-100
0
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Network Evaluation
Topology No.
etaη
Figure 7.
η-function for 16x16 RecMIN loaded with trafﬁc from Table 1
The simulation results are presented in Fig. 7 (Simula-
tion parameters for all simulations presented in this paper
are: buffer size 16 phits for each buffer, conﬂict resolution
algorithm for each router is ”random choice”, each packet
consists of one ﬂit, a ﬂit equals the size of a phit). It shows
the evaluation of different RecMIN reconﬁgurations, resulting
from all possible RecCell modes. The used NoC consists
of 4 RecCells each of them can be used in two possible
modes, so, for this kind of network there exist 24 = 16
possible topologies. As is shown in Fig. 7, η-function has the
highest rates for topologies with an odd number (1,3,5 etc.),
and the lowest rate for topology 10. Thus, for the optimal
communication of NoC components by trafﬁc deﬁned in Table
1, RecMIN must be reconﬁgured to topologies 1,3,5,7,9,11,13,
or 15.
IV.
RECONFIGURATION ALGORITHMS
It is not sufﬁcient only to offer a reconﬁgurable architecture
when considering the reconﬁguration of NoC as an opportunity
to improve its efﬁciency and performance. A second step is
required in order to take advantage of the capabilities of the
architecture: employing algorithms that allow the network to
87
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-341-4
ADAPTIVE 2014 : The Sixth International Conference on Adaptive and Self-Adaptive Systems and Applications

TABLE I.
LOAD IN RECMIN
Generator
Ptr(Gi)
Prec(T10)
Prec(T11)
Prec(T12)
Prec(Trst)
G0, G1
0.4875
0.2/16
0.3
0.2/16
0.2/16
G2, G3
0,3875
0.2/16
0.2/16
0.2
0.2/16
G4 - G7
0,55
0.1
0.2/16
0.2/16
0.2/16
G8 - G15
0.2
0.2/16
0.2/16
0.2/16
0.2/16
adapt itself to different trafﬁc distributions. In this paper, we
propose several algorithms that were developed for RecMIN
architecture: the η-algorithm, the minimal queues algorithm
and the pattern identiﬁcation algorithm.
A. General requirements for algorithms
The tasks of the algorithm responsible for the reconﬁgura-
tion of the network can be divided into the following steps:
•
Monitoring the trigger: tracking events or sequences of
events, after which the algorithm has to decide about
the reconﬁguration of the network topology.
•
Looking for bottlenecks: ﬁnding parts of the network
that need to be changed due to reconﬁguration
•
Looking for alternative structure: ﬁnding a topology
to substitute the previous one
•
Processing the reconﬁguration
Each of these steps should avoid high time consumption
and should require simple calculation wherever possible. (Im-
plementation of complex calculations in hardware, requires
expensive chip area). Another key issue is the question of
stability. It is necessary to avoid a situation where the al-
gorithm constantly tries to optimize the network. Doing so
the algorithm continually conducts endless reconﬁguration
processes, hence preventing the network from operating in
normal mode. For example, such a problem can occur if
reconﬁguration algorithm is unable to ﬁnd an unambiguously
best network topology. Thus, after checking different network
reconﬁgurations the found topology is still not optimal. This
state directs to the retriggering of the algorithm thereby starting
a new reconﬁguration process. Therefore, no reconﬁguration
process should be started, if the algorithm is unable to ﬁnd
a better NoC topology for the trafﬁc ﬂow unless the network
trafﬁc changes. Consequently, it is essential not only to have
a trigger to reconﬁgure the network, but also to implement an
observation technique that notes changes in trafﬁc pattern.
-1000
-500
0
500
1000
0
1
2
3
4
5
Network Evaluation
Traﬃc No
worst eta for the traﬃc
best eta for the traﬃc
η
η
Figure 8.
η-functions for different trafﬁcs in 16x16 RecMIN
This paper proposes to monitor the trafﬁc ﬂow by changes
of queue lengths in the NoC buffers, in order to solve the
problem of instability. Assume, each trafﬁc corresponds to a
vector ⃗θ. Thus, change in the trafﬁc ﬂow is observed by ⃗
∆θ,
the difference between two previous calculated ⃗θ-vectors:
⃗
∆θ = ⃗θ2 − ⃗θ1 =




θ0,2
θ1,2
...
θN−1,2



 −




θ0,1
θ1,1
...
θN−1,1




(3)
where θi,j is the length of the queue in the buffer j caused
by trafﬁc number i. In the more general case the system records
the combination of topologies and corresponding trafﬁc vectors
in memory registers. Then, the reconﬁguration algorithm can
immediately change the NoC to the optimal topology, if the
network trafﬁc pattern repeats after some time.
B. The η-Algorithm
The η-algorithm uses the η-function for the evaluation
and improvement of the network effectiveness. The algorithm
receives the mean values for the network settings (throughput
and delay) every 1000 cycles (number of cycles can be changed
by the network designer). It calculates the value of η based on
these means. If η-value falls below the speciﬁed threshold, the
algorithm starts the reconﬁguration.
Looking for an alternative structure is a typical global
optimization problem of locating a good approximation to
the global optimum of a given function. We used an ex-
haustive search of all possible topology reconﬁgurations, to
ﬁnd the optimal one. It is a reasonable alternative for small
networks. (We used 16 × 16 RecMIN, where only 24 − 1=15
reconﬁgurations are possible (the original conﬁguration is not
a reconﬁguration). For networks with the higher number of
RecCells, we recommend the usage of simulated annealing,
genetic algorithms or other heuristic algorithms). Once all pos-
sible topologies for RecMIN have been iterated, the algorithm
chooses the one with the maximum η-value.
The η-algorithm written in pseudo-code is shown below:
INPUT:
RecMIN, traffic;
OUTPUT: RecMIN_topology;
best_calculated_η:= calculate η;
BEGIN
IF η<η_threshold THEN
IF no reconfiguration is running THEN
FOR i:=0
TO i<all_possible_reconfigurations - 1
DO
simulate topologyi;
calculate η;
IF calculated η>best_calculated_η
THEN
best_calculated_η:=calculated_η;
88
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-341-4
ADAPTIVE 2014 : The Sixth International Conference on Adaptive and Self-Adaptive Systems and Applications

best_topology:=sim_topology;
END IF;
END FOR;
END IF;
END IF;
RETURN best_topology;
END;
Advantages and Disadvantages of the η-Algorithm: The
main advantage of the η-algorithm is the possibility of ﬁnding
the optimal network topology for any trafﬁc. Fig. 8 shows
the analysis of six NoC trafﬁcs (in 16×16 RecMIN consisting
of four RecCells) using the η-algorithm. The chosen priority
weights are Cςi = Cτi = 50 [clock cycles/ﬂit] and Cδi = −1
[clock cycles]−1 for all i ∈ {0, .., N −1}. For each trafﬁc, Fig.
8 shows two values: the minimum and maximum value of η,
which can be achieved by reconﬁguring the network with the
η-algorithm.
Fig. 8 shows the result of six chosen trafﬁcs given by
the η-algorithm. It can be seen that for some trafﬁc ﬂows
(e.g., trafﬁc nos. 1 and 5) it is possible to achieve a good
improvement of network performance by reconﬁguration. On
the other hand, some trafﬁcs exist (e.g., trafﬁc nos. 2 and 3), for
which reconﬁguration does not lead to distinct enhancements.
Therefor, the usage of the η-algorithm with exhaustive search
is not reasonable for this kinds of trafﬁcs.
50
100
150
200
250
300
350
400
450
0
1
2
3
4
5
Network Evaluation
Traﬃc Nr
eta for topology found by MQA
best eta
η
η
o
Figure 9.
Comparison between the MQA and the η-algorithm for different
trafﬁcs in 16x16 RecMIN
The additional disadvantages of the η-algorithm are:
1)
The algorithm requires constant conduct of statistics
of throughput and delay for the sources and targets in
NoC. More sophisticated IP-cores (responsible for the
collection of statistical data) have to be integrated in
the network interfaces, to accomplish this task. This
increases the chip area occupied by the network. Ac-
cordingly, the entire SoC production cost increases.
2)
The algorithm deals with a large search space, when
dealing with big NoCs consisting of many RecCells.
This problem can be solved by using, e.g., simulated
annealing. However, there is no guaranty of ﬁnding
the optimal solution by the η-algorithm.
The η-algorithm is not very suitable for implementation
in SoC, due to the disadvantage 1. However, it can be used
in simulations. The designer can evaluate the effectiveness of
other reconﬁguration algorithms, comparing their results with
the η-algorithm outcome.
C. The Minimal Queues Algorithm
Analysis of the various NoCs shows that the more effec-
tively the network works, the shorter are the queues in the
network buffers. Bottlenecks cause the queues in buffers on the
respective network sections to rise. Subsequently, this effect
generally leads to an increase of the length of the buffer queues
in the entire network.
The idea of Minimal Queues Algorithm (MQA) is to
react on increases of the lengths of the buffer queues in the
network, and thereafter minimize these using reconﬁgurations.
Observing the length of the buffer queues in a real SoC is
much easier than keeping statistics of throughput and delay
for sources and targets. Thus, the MQA is more suitable for
implementation in SoC than the η-algorithm.
The trigger condition for the MQA is that the total number
of packets in the network buffers exceeds some threshold
speciﬁed by the developer. After that the MQA performs
k reconﬁguration steps. In each step, the MQA looks for
switching the mode of one single RecCell that clearly shortens
the lengths of the buffer queues in the entire NoC. Thereby,
the MQA begins at the RecCell with the longest buffer queues.
(The number k is speciﬁed by the developer. We set k equal
to half of the amount of RecCells used in a network, i. e., if a
network consists of four RecCells k = 2). The reconﬁguration
process requires neither to stop the operation of the NoC nor to
release it entirely from packets, according to technique shown
in [9].
The MQA written in pseudo-code is given below:
INPUT:
RecMIN, traffic;
OUTPUT: RecMIN_topology;
best_calculated_buffer_sum:= calculate(buffer_sum)
BEGIN
IF buffer_sum>buffer_sum_threshold THEN
IF no reconfiguration is running THEN
FOR i:=0 TO i<k - 1 DO
list_of_tried_cells:={};
FOR each RecCell DO
switching_cell:= search for
RecCell with
the highest
buffer_sum_in_cell;
IF switching_cell
/∈ list_of_tried_cells THEN
switch RecCell mode (swisching_cell);
simulate topology;
calculate(buffer_sum);
#if the buffer queues does not decrease
IF NOT (calculated buffer_sum <<
best_calculated_buffer_sum)
THEN
step back to previous topology;
add
switching_cell
to
list_of_tried_cells;
END IF;
END FOR;
END FOR;
END IF;
END IF;
RETURN actual_topology;
END;
89
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-341-4
ADAPTIVE 2014 : The Sixth International Conference on Adaptive and Self-Adaptive Systems and Applications

Advantages and Disadvantages of MQA: As mentioned,
the MQA is more suitable for real SoC than the η-algorithm,
because it uses information of buffer occupation, instead of
throughput and packet delay values. Furthermore, the MQA
does not use an exhaustive search of all possible reconﬁgu-
rations. In worst case k ∗ N reconﬁguration steps have to be
performed.
The main disadvantage of the MQA is that it does not
provide the optimal solution. (The MQA is an empirical
algorithm). Fig. 9 presents the comparison of the network
performance between the η-algorithm and the MQA. Only in
one of six cases, the MQA did not ﬁnd the global, but the
local optimum (trafﬁc 5).
D. The Pattern Identiﬁcation Algorithm
Generally, the occurrence of a bottleneck in RecCell can
be identiﬁed by the occupation of its buffers. So, if such a
situation arises in a particular RecCell, the overloaded channel
can be diagnosed by a pattern of the buffer queues in the
RecCell. Accordingly, if one of those patterns is recognised
during an operation of the NoC, the RecCell has to be
reconﬁgured.
A Pattern Identiﬁcation Algorithm (PIA) can be imple-
mented. It monitors bottleneck occurrence by recognition of
buffer occupation patterns in each RecCell and performs the
required reconﬁguration. If more than one pattern is identiﬁed,
the PIA gives priority to RecCells according to the distance of
their position to the targets.
50
100
150
200
250
300
350
400
450
0
1
2
3
4
5
Network Evaluation
Traﬃc No
eta for topology found by PIA
best eta
η
η
Figure 10.
Comparison between PIA and η-algorithm for different trafﬁcs
in 16x16 RecMIN
The PIA written in pseudo-code is given below:
INPUT:
RecMIN, traffic;
OUTPUT: RecMIN_topology;
BEGIN
FOR i:=stage_number -1 DOWNTO 0 DO
FOR each stage in RecMIN
beginning from stage[i]
DO
FOR each RecCell in this stage DO
IF no reconfiguration is running THEN
IF
is one of the patterns found
THEN
reconﬁgure the cell according to the found pattern
END IF;
END IF;
END FOR;
END FOR;
END FOR;
RETURN actual_topology;
END;
Advantages and Disadvantages of PIA: An important ad-
vantage of the algorithm is that it does not search for a
new topology by traversation of possible solutions. The PIA
performs a reconﬁguration only if it clearly improves the
network efﬁciency. In worst case the PIA would do 2n ∗ k
(where n is the index of stages in RecMIN, and k is the
number of RecCells in each RecCell). But, in normal cases,
the PIA is more efﬁcient than the MQA comparing the number
of reconﬁguration steps.
Furthermore, a pattern search algorithm like the PIA uses
buffer states as trigger information. This makes the imple-
mentation of the PIA in SoC simple. Also, the PIA performs
reconﬁguration steps for RecCells of the same RecMIN stage
simultaneously so increasing the speed of the reconﬁguration
process.
The disadvantage of the PIA is that it requires implemen-
tation of additional memory registers in order to store the pat-
terns in the NoC. Also, in case of miscarrying implementation
of patterns, the RecMIN can become instable. Thus, the PIA
will constantly detect one of the implemented patterns and
fulﬁl inﬁnite reconﬁguration processes.
The PIA is the best of three algorithms proposed in this
paper, for hardware realisation in SoC (in case that the patterns
for the PIA are well implemented). So, for all of the six
trafﬁc ﬂows that were used to test the performance of the three
proposed algorithms, the PIA found an optimal NoC topology
(Fig. 10).
V.
CONCLUSION
In this paper, three reconﬁguration algorithms were em-
ployed and evaluated, in order to beneﬁt from the special
capabilities of the Reconﬁgurable Multi-Interconnection Net-
work (RecMIN) architecture. The η-algorithm, the minimal
queues algorithm (MQA) and the pattern identiﬁcation al-
gorithm (PIA) allow the network to adapt itself to different
trafﬁc distributions. We evaluated the performance of the
proposed reconﬁguration algorithms with six chosen trafﬁc
ﬂows and discussed the advantages and disadvantages of each
algorithm. Finally, the η-algorithm is the best one for simula-
tion. Therefore, the designer can evaluate the effectiveness of
other reconﬁguration algorithms, comparing their results with
the η-algorithm outcome. However, the pattern identiﬁcation
algorithm is the most suitable reconﬁguration algorithm for
hardware realization in SoC.
REFERENCES
[1]
J. Owens, W. Dally, R. Ho, D. Jayasimha, S. Keckler, and L.-S. Peh,
“Research challenges for on-chip interconnection networks,” Micro,
IEEE, vol. 27, no. 5, Sept.-Oct. 2007, pp. 96 –108.
[2]
D. L¨udtke, D. Tutsch, A. Walter, and G. Hommel, “Improved perfor-
mance of bidirectional multistage interconnection networks by recon-
ﬁguration,” in Proceedings of 2005 Design, Analysis, and Simulation
of Distributed Systems (DASD 2005); San Diego.
SCS, Apr. 2005,
pp. 21–27.
90
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-341-4
ADAPTIVE 2014 : The Sixth International Conference on Adaptive and Self-Adaptive Systems and Applications

[3]
D. L¨udtke and D. Tutsch, “Lossless static vs. dynamic reconﬁguration of
interconnection networks in parallel and distributed computer systems,”
in Proceedings of the 2007 Summer Computer Simulation Conference
(SCSC’07); San Diego.
SCS, Jun. 2007, pp. 717–724.
[4]
——, “The modeling power of CINSim: Performance evaluation of
interconnection networks,” Computer Networks, vol. 53, no. 8, 2009,
pp. 1274–1288.
[5]
M. Al Faruque, T. Ebi, and J. Henkel, “ROAdNoC: Runtime observabil-
ity for an adaptive network on chip architecture,” in Computer-Aided
Design, 2008. ICCAD 2008. IEEE/ACM International Conference on,
Nov. 2008, pp. 543–548.
[6]
——, “Conﬁgurable links for runtime adaptive on-chip communica-
tion,” in Design, Automation Test in Europe Conference Exhibition,
2009. DATE ’09., april 2009, pp. 256 –261.
[7]
A. Logvinenko and D. Tutsch, “A reconﬁguration technique for area-
efﬁcient network-on-chip topologies,” in Performance Evaluation of
Computer Telecommunication Systems (SPECTS), 2011 International
Symposium on, June 2011, pp. 259 –264.
[8]
——, “Recsim - a simulator for reconﬁgurable network on chip topolo-
gies,” in Proceedings of the 26th European Simulation and Modelling
Conference (ESM 2012). Essen, Germany, October 2012, pp. 144–151.
[9]
A. Logvinenko, C. Gremzow, and D. Tutsch, “RecMIN: A recon-
ﬁguration architecture for network on chip,” in Reconﬁgurable and
Communication-Centric Systems-on-Chip (ReCoSoC), 2013 8th Inter-
national Workshop on, 2013, pp. 1–6.
[10]
D. Tutsch, Performance Analysis of Network Architectures, 1st ed.
Berlin: Springer Verlag, 2006.
[11]
P. C. Wong and M. S. Yeung, “Design and analysis of a novel fast
packet switch–pipeline banyan,” IEEE/ACM Transactions on Network-
ing, vol. 3, no. 1, Feb. 1995, pp. 63–69.
[12]
T.-Y. Huang and J.-L. C. Wu, “Alternate resolution strategy in multistage
interconnection networks,” Parallel Computing, vol. 20, 1994, pp. 887–
896.
[13]
N. Boot, “Throughput and delay analysis for a single router in networks
on chip,” Master’s thesis, Technische Universiteit Eindhoven, Nether-
lands, 2005.
91
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-341-4
ADAPTIVE 2014 : The Sixth International Conference on Adaptive and Self-Adaptive Systems and Applications

