Possibilities of the Reverse Run of Software Systems
Modeled by Petri Nets
Radek Koˇc´ı and Vladim´ır Janouˇsek
Brno University of Technology, Faculty of Information Technology,
IT4Innovations Centre of Excellence
Bozetechova 2, 612 66 Brno, Czech Republic
{koci,janousek}@ﬁt.vutbr.cz
Abstract—Application run tracing and step-by-step execution
are an integral part of the debugging process. In many cases,
debugging would be more comfortable and faster if it was
possible to go back in the execution and examine the system
state before getting into the wrong or disabled state. Currently,
such a technique is not widespread, but there are experimental
implementations that burden the application run with logging
information needed to restore previous states. Moreover, many
of them increase overhead in a signiﬁcant way. This paper focuses
on the possibility of reversing the run of systems whose behavior
is described by Petri nets. The work follows the methodology of
designing and validating system requirements using functional
models that combine formal notation with objects of the produc-
tion environment and can be used as a full-ﬂedged application.
Due to the nature of Petri Nets formalisms, it is possible to deﬁne
reverse operations to reduce the overhead of application run.
Keywords–Object Oriented Petri Nets; debugging; tracing; re-
verse debugging; requirements validation.
I.
INTRODUCTION
This work builds on the concepts of formal approach to
design and develop system requirements and evolves principles
discussed in the paper [1]. The presented approach uses the
formalism of Petri Nets to specify the system under devel-
opment [2]. It is part of the Simulation Driven Development
(SDD) approach [3] combining basic models of the most used
modeling language Uniﬁed Modeling Language (UML) [4][5]
and the formalism of Object-Oriented Petri Nets (OOPN) [6].
This approach is based on ideas of model-driven develop-
ment dealing with gaps between different development stages
and focuses on the usage of conceptual models during the
development process of simulation models. These techniques
are called model continuity [7]. The model continuity concept
works with simulation models during design stages, while the
approach based on Petri Nets focuses on live models that can
be used in the deployed system.
When testing models or implementations, developers often
use the interactive debugging technique, which allows them
to go through the system run and investigate its state step
by step. The logging technique and subsequent analysis of
the running system are less often used. These techniques are
linked to the limits of their use, notably the inability to make
reverse steps. In this case, it is difﬁcult to determine the system
states before stopping (e.g., at breakpoints). However, the
introduction of reverse interactive debugging leads to increased
overhead, especially for running an application where it is
necessary to collect the information needed to reconstruct
the previous states. There are several approaches; however,
they differ in their possibilities and overhead. A signiﬁcant
factor is, in addition to higher demands on the runtime of the
application, that there is a higher demand for memory that
keeps the collected information. Another issue is the overhead
of reverse debugging, which is not as important as the run
overhead.
There are three basic approaches to solving this problem.
The ﬁrst one records the system run and then performs all the
steps from the beginning to the desired point (record-replay
approach). The second approach records all the information
needed to return to the previous step (trace-based approach).
The third approach records only selected checkpoints, so
they are reliably replicated (reconstruction-based approach).
Reverse debugging is done by reconstructing the appropriate
checkpoint state and then making forward steps. The approach
presented in this paper is based on the trace-based reverse
debugging. Due to the nature of used OOPN formalism, which
has a formal base working with uniquely deﬁned events, there
is no problem in deﬁning and performing reverse operations
associated with each event.
The paper is organized as follows. Section II introduces
related work. Section III summarizes basic deﬁnitions of
OOPN formalism needed to deﬁne tracing concepts. Section
IV discusses the possibilities of OOPN models simulation trac-
ing and introduces the simple demonstrating model. Section V
focuses on recording states and event during the simulation
and Section VI describes reverse events and operations when
reverse debugging performed. The question of saving the
whole state is discussed in Section VII. The summary and
future work are described in Section VIII.
II.
RELATED WORK
The solution based on recording simulation run and re-
playing it from the beginning to the breakpoint may be time-
consuming and, for a long run of the application, unsuitable
due to time lags when debugging. As examples, we can
mention Instant Replay debugger [8] or Microsoft Visual
Studio 2010 IntelliTrace [9].
The trace-based solution logs all steps, so it is possible to
determine the current state and the sequence of steps that led
to this state. In many cases, the simulators record everything
and, therefore, it is possible to go back to one of the previous
191
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

steps. The scope of that solution is limited by what and
how can be traced, especially using multi-processors is very
difﬁcult to work. As examples, we can mention Green Hills
Time Machine [10], Omniscient Debugger [11] fo Java Virtual
Machine, or gnu reverse debugger gdb 7.0 [12]. The last
mentioned, gdb debugger, is very slow but is the only open-
source solution. There are tools based on Petri nets that allow
reverse debugging, e.g., the TIme petri Net Analyzer TINA
[13]. Nevertheless, these tools focus on a speciﬁc variant of
Petri nets that are not usable for the application environment.
Besides, there are also tools suitable for these purposes, e.g.,
Renew [14], which are similar to the SDD approach but do
not allow reverse debugging.
Some solutions allow us to go back within the operation
stack, change the current state, and proceed from this step.
An example may be the Smalltalk language [15]. Even in this
case, however, we do not have a stack of states associated with
the appropriate steps. We only get the current state, which is
reﬂected in all previously executed steps.
III.
BASIC DEFINITION OF OOPN FORMALISM
In this section, we introduce the basic deﬁnition of Object-
oriented Petri Nets (OOPN) formalism necessary for the pre-
sented purpose.
A. System of Classes and Objects
For this work, we deﬁne the Object Oriented Petri Nets
(OOPN) as a system of classes and objects that consists of the
individual elements [16].
Deﬁnition 1: System OOPN is Π = (Σ, Γ, c0, o0), where
Σ is a system of classes, Γ is a system of objects, c0 is an initial
class and o0 is an identiﬁer of the initial object instantiated
from the class c0.
Deﬁnition 2: System
of
classes
Σ
consists
of
sets
of
elements
constituting
classes
and
is
deﬁned
as
Σ
=
(CΣ, MSG, NO, NM, SP, NP, P, T, CONST, VAR),
where CΣ is a set of classes, MSG is a set of messages, NO
is a set of object nets, NM is a set of method nets, SP is a
set of synchronous ports, NP is a set of negative predicates,
P is a set of places, T is a set of transitions, CONST is a set
of constants and VAR is a set of variables. Messages MSG
correspond to method nets, synchronous ports, and negative
predicates.
Deﬁnition 3: The class is a structure
C = (MSGC, nC
O, NC
M, SPC, NPC),
where MSGC ⊆ MSG, nC
O ∈ NO, NC
NPC ⊆ NP. Each net of the set {nCM ⊆ NM, SPC ⊆ SP and
O}∪NC
M consists of places
and transitions (subsets of P and T).
Deﬁnition 4: System of objects Γ is a structure containing
sets of elements constituting the model runs (the model run
corresponds to the simulation, so that we will use the notation
of simulation). Γ = (OΓ, NΓ, MN, MT), where OΓ is a set
of object identiﬁers, NΓ is a set of method nets identiﬁers,
MN ⊂ (OΓ ∪ NΓ) × P × UM is place markings and MT ⊂
(OΓ ∪ NΓ) × T × P(BIND) is transition markings.
Deﬁnition 5: The OOPN system universe U is deﬁned
U = {(cnst, cls, oid) | cnst ∈ CONST ∧ cls ∈ CΣ ∧ oid ∈
OΓ}. The system universe represents a set of all possible values
that may be part of markings or variables. UM is then a multi-
set over the set U.
We can use the following notation to simplify writing. For
constants, we write down their values directly, e.g., 10, ′a′. For
classes, we write down their names directly without quotes or
apostrophes. To identify an object, we write its identiﬁer with
a @ character.
Deﬁnition 6: The set of all variable bindings BIND used
in OOPN is deﬁned BIND = {b | b : VAR −→ U}.
Deﬁnition 7: We deﬁne operators for instantiating classes
∐C and method nets ∐N that create the appropriate instances
and assign them identiﬁers from sets OΓ, resp. NΓ. When
creating a new instance of the class c ∈ CΣ, we will write
∐C(c) = o or ∐C(c, o), where o ∈ OΓ. Similarly, for the
method net instance m ∈ NM, we will write ∐N(o, m) = n
or ∐N(o, m, n), where o ∈ OΓ is an object where the method
net instance n ∈ NΓ is created.
Individual class elements are identiﬁed by their fully qual-
iﬁed names consisting of sub-element names separated by a
dot. The class is identiﬁed by its name, e.g., C. The method is
identiﬁed by class and method names, e.g., C.M, the method
place C.M.P, and so on. In the case of object net, the elements
will be written directly without method identiﬁcation, e.g.,
C.P. Similarly, we introduce the identiﬁcation of Γ object
system elements. Objects and nets instances are uniquely
identiﬁed by their identiﬁers, net elements (transitions and
places) by their names. For instance, the transition t ∈ T of the
method net mi ∈ NΓ can be identiﬁed by following notations:
mi.t or (mi, t). The object net describes the autonomous
activities of the object; its instance is always created with the
instantiation of the class, and is just one. For this reason, the
notation o ∈ OΓ can identify the class instance as well as its
object net. Method nets describe the object’s response to the
sent message. In case the message is received, the instance
n ∈ NΓ of the respective net NM is created, and its simulation
starts.
B. OOPN Model Example
An example illustrating the basic elements of OOPN for-
malism is shown in Figure 1. There are deﬁned two classes
C0 and C1, where the class C0 is marked as the initial one.
When you run the simulation, an instance of the initial class is
created, that is, the class C0. The class C0 has only an object
net that contains places p1, p2, p3, p4 and transitions t1, t2, t3.
These transitions gradually create instances of the class C1
in their actions and send doFor:20 and doFor:10 messages to
these objects. The object net C1 contains the place p11 with an
initial marking 10 and the method net doFor:. The method net
has a place x corresponding to the x argument of the method,
an output place return, where the resulting method token is
placed, and two transitions t1 and t2.
Transitions are protected by guards. The transition t1 is
ﬁreable (can be executed, i.e., ﬁred) if the value of the passed
argument x is less than or equal to the value stored in the
place p11 of the object net (x <= s). The transition t2 is
192
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

C1 is_a PN
return
x
t1
t2
x > s
ns := s + x
s
10
x <= s
x
x
s
s
ns
p11
ns
doFor: x
C0 is_a PN
p1
o := C1 new.
p2
p3
o doFor: 10.
p4
o doFor: 20.
t1
t2
t3
o
o
o
o
o
Figure 1.
An example of the OOPN model with basic elements.
ﬁreable if the value of the passed argument x is greater than
the value stored in the place p11 of the object net (x > s).
Firing the transition t1 does not change the state of the object,
and a copy of the value from the place p11 is put to the output
place return. It indicates that the method has reached a result,
and its net terminates when the calling transition obtains this
result. By ﬁring the transition t2, the value of the variable x
is added to the value stored in place p11.
C. Nets of the OOPN Formalism
The OOPN class consists of two categories of nets, object
net and method net. These nets are instantiated, i.e., their copy
is created over which a simulation is performed. When the new
object is being created, its object net is instantiated immedi-
ately. When the method is invoked, its net is instantiated. Now
let us take a look at the example in Figure 1 and explain the
model dynamics, i.e., the use of individual nets.
p1
o := C1 new.
p2
t1
o
o doFor: 20.
t2
o
p3
o
10
p11
p11
t2start
t2end
10
x
20
return
p11
30
x
return
30
=>
30
p11
Figure 2.
A usage of the method net doFor: of the object net C0.
As soon as the simulation starts, an instance of the initial
class (i.e., the class C0) is created. Part of the object net of
the initial object o0 is shown in Figure 2. First, the transition
t1 is performed, which instantiates the class C1 class and puts
a newly created object to the place p2. In place p2, there is
now an object o1 with an object net containing only one place
p11 having the initial marking 10. Next, the transition t2 is
ﬁred, which sends a message doFor: with the argument value
20 taken from the place p2. We can imagine this situation
as replacing the transition t2 with two auxiliary transitions
t2start, respectively t2end. These transitions are associated
with input, respectively output, places of the method net its
instance was created. The object o1 now contains an object net
(constituted by the place p11) and an instance of the method
net doFor:. When the method net completes the execution, the
resulting token is placed to the place return. The auxiliary
transition t2end fetches this token from the place return and
ends the method net’s run. An object o1 is inserted to the place
p3, which now contains only the object net with the place p11
containing the value of 30.
D. Place
The place is represented by a named multi-set. The multi-
set AM is a generalization of the set A such that it can contain
multiple occurrences of elements. Thus, the multi-set can be
deﬁned as a function AM : A
→ N, which assigns to each
element a ∈ A the number of occurrences in the multi-set. The
number of occurrences will be denoted by the term frequency.
We denote |A| the cardinality of the set A, i.e., the number
of elements in the set A. We denote |AM| the cardinality of
multi-set AM, i.e., the sum of frequencies of all elements in
the set A. For an individual element x of the place p ∈ P, we
write x ∈ p a for its frequency m‘x.
Deﬁnition 8: The place marking corresponds to its content
and is deﬁned as a multi-set MP = {(m, o) | m ∈ N+ ∧ o ∈
U}, where m is frequency of the member o in the multi-set.
Members of multi-set will be written in the form m‘o, marking
of the place p ∈ P will be written in the form MP(p) =
{m1‘o1, m2‘o2, . . . }.
As an example we can mention the initial marking
of the place o0.p1 from the model shown in Figure 1—
MP(o0.p1) = {1‘•}. The place cardinality is |o0.m1.p2| = 1
a |o0.m1.p2M| = 1.
E. Transition
The transition is a net element whose execution determines
the model’s dynamics. OOPN dynamics are based on High-
level Petri nets, but the semantics of transitions is modiﬁed.
Each transition includes edges that connect the transition to
places; the edge deﬁnes one condition for the ﬁreability of
the transition. The condition is deﬁned by the inscription
language. We distinguish input conditions (precondition), test
conditions (condition) and output conditions (postcondition).
The transition is ﬁreable for certain binding of variables that
are deﬁned in the input and test conditions and the transition
guard, if there are a sufﬁcient number of objects in input places
and the guard is evaluated truthfully for the obtained binding.
Individual types of transitions are deﬁned as follows
•
Input condition (precondition) associates a transition
with a place whose state is a condition for ﬁring
(performing) the transition. When transition ﬁres, the
associated objects are removed from the associated
input place. An example is the edge from place C0.p1
to the transition C0.t1.
•
Test condition (condition) is similar to the input con-
dition, except it does not change the state of the
associated input place when the transition ﬁres. The
demonstration example does not include a test edge.
•
Output condition (postcondition) speciﬁes what ob-
jects are inserted in the associated output place after
the transition ﬁres. An example is the edge from the
transition C0.t1 to the place C0.p2.
F. Inscription Language and Arc Expressions
An important part of OOPN formalism is its language
of instruction, so-called inscription language. The language
includes edge evaluation and operations deﬁned in guards
193
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

and actions of transitions. The form of the script language
is inspired by the Smalltalk language.
Arc expression matches the usual approach used in Petri
nets. Each arc expression has a form of m‘o, where m ∈
N+ ∪ VAR and o
∈ U ∪ VAR. The expression element
m represents the frequency of o in the multi-set and can be
denoted by a numeric value or a variable. If the variable is
used at the position m, the frequency of the member o in
multi-set is assigned to that variable. The element o represents
the object stored in multi-set and can be deﬁned by the element
of the universe U or the variable. If a variable is used at
the position o, an object from multi-set, whose frequency
corresponds to speciﬁed m, is bound to that variable. If both
parts of an expression are deﬁned by variables, any object and
its frequency are bound to these variables. If the content of the
multi-set does not match the given expression, the bounding
process fails.
G. Synchronization Mechanisms
Synchronization elements and dynamics of the OOPN
model are presented in the modiﬁed model, which is shown in
Figure 3. Two classes C0 and C1 are deﬁned here. Object
net of the class C0 contains C0.p1 and C0.p2 and one
transition C0.t1. The object net C1 is empty. The class C0
contains the method C1.init:, the synchronous port C0.get:
and the negative predicate C0.empty. The class C1 contains
the method C1.doFor:.
We show an example of calling synchronous port C0.get:
with a free parameter. The synchronous port has one parameter
named o. This port is called from the transition C1.t2 with
free variable n. The parameter o is free, too, and is bound
to one object from the place C0.p2. The bound object is
available in the calling transition via the variable n. If the
called synchronous port does not exist, the transition is not
ﬁreable.
An example of a negative predicate is C0.empty. The
predicate is called from the transition C1.t3, which means
that the transition C1.t3 is ﬁreable if the place C0.p2 is
empty. Negative predicate C0.empty is complementary to the
synchronous port C0.get: called with a free parameter. Either
one or the other is ﬁreable, never both or none at the same
time. In this way, it is possible to model a decision based on
the existence of tokens in places.
o
o := Rand next
t1
p2
p1
#e
C0 is_a PN
init: x
x
x
t1
x
return
x‘#e
o
get: o
o
C1 is_a PN
doFor: x
return
x
c := C0 new.
c init: x.
x
t1
t2
c
c get: n
s := s + n
c empty
t3
c
s
c
s
s
s
p1
p2
0
empty
Figure 3.
OOPN model with synchronization mechanisms.
Now let us look at the dynamics of the model that is
created by instantiating the class C1, ∐C(C1) = o0, and
calling the method doFor: 3 on the object o0. When the
method net is being instantiated, ∐N(o0, C1.doFor:) = m1,
and a constant object 3 is inserted into the parameter place
o0.m1.x the transition o0.m1.t1 ﬁres. Executing this creates
an instance of the class C0, ∐C(C0) = o1, a reference to
object o1 is stored in the variable c and object o1 is initialized
by calling the method o1.init, ∐N(o1, C0.init) = m2. It inserts
three symbols #e to the place o1.p1. The transition o1.t1
generates three random numbers and puts them in the place
o1.p2. Transitions o0.m1.t2 and o0.m1.t3 are complementary.
The transition o0.m1.t2 is ﬁreable if there is at least one
object (number) in the place o1.p2. Test of ﬁreability and
obtaining objects at the same time, if the test is successful,
are provided by the synchronous port o1.get: with the free
variable n. When the transition is performed, one object from
the place o1.p1 is bound to the variable n. At the same time,
the bound port get: is executed on the object o1 and the bound
object is removed from the place o1.p2. Transition o0.m1.t2
then adds the acquired value to the amount stored in the place
o0.m1.p2. Figure 4 shows the principle of dynamic fusion of
transition and synchronous port. Figure 4a) is the state after
execution the transition o0.m1.t1. The place o0.m1.p1 contains
a reference to the object o1 and the place o1.p2 contains three
randomly generated values. Dynamic fusion of the transition
o0.m1.t2 with synchronous port is shown in Figure 4b). After
the transition o0.m1.t2 ﬁres for the binding xn = 10, the model
moves to the state shown in Figure 4c).
p1
t2
c get: n
s := s + n
c
s
s
p2
0
10, 12,
18
p2
p1
t2
s := s + n
c
s
s
p2
0
10, 12,
18
p2
n
≈
p1
t2
c get: n
s := s + n
c
s
s
p2
10
12, 18
p2
⇒
a)
b)
c)
Figure 4.
Dynamic fusion of the transition C1.doFor:.t2 and synchronous
port C0.get:.
The transition o0.m1.t3 is ﬁreable if the place o1.p2 is
empty. The ﬁreability test is provided by calling the negative
predicate o1.empty. If the transition o0.m1.t3 ﬁres, the value is
transferred from the place o0.m1.p2 to the place o0.m1.return
and the method execution is terminated. Calling and executing
the method o1.doFor: x generates x random numbers and
returns the sum of them.
H. Set of Classes
The formalism of OOPN works, in addition to the OOPN
objects (OΓ and the corresponding set of classes CΣ), with
objects that are not a direct part of the formalism. The principle
of their usage is based on Smalltalk, which is also used as the
inscription language of the formalism of OOPN. These objects
are especially basic constant objects (sometimes also called
primitive objects) such as numbers, symbols, characters, and
strings. The corresponding classes will be denoted Number,
Symbol, Character and String and their set, in sum, CC.
Objects of these classes are part of the set of constants
CONST. In addition to these basic objects, OOPN formalism
194
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

can work with other objects and classes. In particular, it cov-
ers collections, graphical user interface objects, user-deﬁned
classes, etc. We will call the set of these classes as domain
classes and denote with the symbol CD, CC ⊂ CD. A set of
object identiﬁers created from classes CD is denoted OD.
Deﬁnition 9: Let CΠ = CΣ∪CD be a set of all classes that
can be used by the formalism of OOPN. Let OΠ = OΓ∪OD be
a set of all object identiﬁers that can be instantiated (created)
from classes CΠ.
Deﬁnition 10: Extended Universe UΠ of OOPN is deﬁned
UΠ = {(cnst, cls, oid) | cnst ∈ CONST ∧ cls ∈ CΠ ∧ oid ∈
OΠ}.
Deﬁnition 11: The set of selectors MSG can be deﬁned as
the union of the following sets: MSG = MSGM ∪ MSGS ∪
MSGP ∪ MSGD, where MSGM corresponds to method nets,
MSGS corresponds to synchronous ports, MSGP corresponds
to predicates and MSGD corresponds to domain class opera-
tions.
IV.
SIMULATION TRACING
In this section, we brieﬂy outline the sample model and
discuss the possibilities of tracing the run of the software
system described by the formalism of OOPN. We call that
run simulation.
A. Sample Model
The basic concept will be outlined using a simple example.
Figure 5 shows classes of that example. Figure 5a) depicts the
initial class A1 with its object net and Figure 5b) depicts the
class A2 having the only method calc: with one parameter x.
a := x + 10.
b := a * 2.
calc: x
return
t2
x
x
b
o := A2 new.
r := o calc: x.
p2
t1
x
r
p1
1) 1‘10
a)
b)
2) 1‘10, 1‘20
Figure 5.
The sample model consisting of two classes A1 and A2; a) class
A1 has only object net and b) class A2 has only method net calc:.
At the simulation start, an instance o0 from the initial
class A1 is created, ∐C(A1, o0). The object net o0 creates an
instance of the class A2, ∐C(A2, o1), and calls its method net
calc: from the transition o0.t1, ∐N(o1, calc:, n1). The method
net n1 executes the transition n1.t2. This example works
with two variants of initial marking of the object net A1; 1)
MP(p1) = {1‘10} and 2) MP(p1) = {1‘10, 1‘20}.
B. Tracing Tree
The simulation progress can be recorded as a tree, where
nodes represent the relevant unit of simulation run, and edges
represent a sequence of units execution, including the bindings.
The relevant unit is understood as the least set of events that
the tracer records. Tree root represents the input point of the
calculation. If a parallel calculation occurs during the execution
of the relevant unit, this unit has more successors in its tree
view. The current state of the calculation is then represented
by all tree leaves. In Figure 6, we can see such a tree for
the model from Figure 5 for the variant of initial marking
MP(p1) = {1‘10, 1‘20}. In this example, the relevant unit
is one executed command. Edges are recorded with a full-line
arrow. Nodes capture on which net and transition the command
has been performed.
o0
t1 {r := o calc: x.}
o0
t1 {o := A2 new.}
o0
t2 {a := x + 10.}
o1.m1
t2 {b := a * 2.}
o1.m1
t1 {r := o calc: x.}
o0
t1 {o := A2 new.}
o0
t2 {a := x + 10.}
o2.m1
t2 {b := a * 2.}
o2.m1
(x=10)
(x=20)
(x=10,o=@o1)
(x=20,o=@o2)
(x=10)
(x=10, a=20)
(x=20)
(x=20, a=30)
Figure 6.
Scenario model of one simulation run.
The tree constructed by that way represents threads that
may appear while running the simulation. It does not, however,
capture the succession of steps that are important for making
backward steps. The sequence of steps (events, see Section
IV-C) can be different and depends on the speciﬁc conditions
of the simulation run. One such variant is captured in Figure
6 with the dashed line arrows.
If all previous node states are stored during a trace, it
is possible to return to any of the previous nodes at any
time, make any changes to the state, and continue from that
node. All nodes that are between the leaf and the selected
node are removed from the tree. In this way, you can work
independently on different tree branches. If there is a branch
or link on the path, it must also be canceled. If another branch
has been executed concurrently, it either stays (there is a
connection on the way) or its execution must also be removed
(there is a branch on the way).
C. Event
The simulation run is driven by events. Each executed
(ﬁred) event changes the system state, and, therefore, repre-
sents one step of model simulation. The set of states S of the
system has a character of the net instances marking, which
includes marking of places and transitions. One step from the
state s ∈ S to the state s′ ∈ S is written in the form s [ev⟩ s′,
where ev is an executed event.
Deﬁnition 12: Event is ev = (e, id, t, b), where e is a type
of event, id ∈ NΓ∪OΓ is the identiﬁer of net instance the event
executes in, t ∈ T is the transition to be executed (ﬁred), and
b ∈ P(BIND) is variables binding the event is to be executed
for.
195
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Event types can be as follows: A represents an atomic
event, the entire transition is done in one step; F represents
sending a message, i.e., creating an instance of a new method
net and waiting for its completion; J represents completion of
the method net called at F event.
(1) {m1.p2{1‘0}, m1.x{1‘0}}
⇒ [(F, m1, C1.doFor:.t1, {(x, 3)})⟩
(2) {m1.p2{1‘0}, }
⇒ [(C, m1, C1.doFor:.t1, {(x, 3), (c, o1)})⟩
(3) {m1.p2{1‘0}, m2.x{1‘3}}
⇒ [(A, m2, C0.init.t1, {(x, 3)})⟩
(4) {m1.p2{1‘0}, m2.return{1‘3}, o1.p1{3‘#e}}
⇒ [(J, m1, C1.doFor:.t1, {(x, 3), (c, o1)})⟩
(5) {m1.p2{1‘0}, o1.p1{3‘#e}, m1.p1{1‘o1}}
⇒ [(A, m2, C0.t1, {(ε, #e)})⟩
(6) {m1.p2{1‘0}, o1.p1{2‘#e}, o1.p2{1‘n1}, m1.p1{1‘o1}}
⇒ [(A, m1, C1.doFor:.t2, {(c, o1), (s, 0), (n, n1)})⟩
(7) {m1.p2{1‘n1}, o1.p1{2‘#e}, m1.p1{1‘o1}}
⇒ . . .
Figure 7.
An example of the transition sequence record.
Here are a few steps of the example that is modeled in
Figure 3, and its dynamics are described in Section III-G. We
start from a state where ∐N(o0, C1.doFor:) = m1 is invoked
with the parameter 3. Places that are empty in that state are
not listed.
D. Event ﬂow subgraph
From the object point of view, we distinguish an event
whose execution does not require an external stimulus (internal
event), and an event that comes from the outside (external
event). A feasible transition always represents the internal
event. An external event can be ﬁred by sending a message
or by calling a synchronous port. The message creates a net
instance consisting of an internal event sequence. Synchronous
port can affect object state by modiﬁcation of places content,
but also invoke the sequence of internal events in the object
net.
The object net can describe multiple scenarios, either
interconnected or totally disjoint. The structure of each net
is deﬁned by a graph of the Petri net, so we can deﬁne the
scenarios as subgraphs of such nets.
Deﬁnition 13: Let S(OΓ ∪ NΓ) be a set of all valid
subgraphs of object nets OΓ and method nets NΓ. Individual
scenarios will be denoted δc(n) = (ev0, ev1, . . . ), where
n ∈ OΓ ∧ c ∈ N.
Now, we return to the step (i.e., event) sequence entry
shown in Figure 6 and write the presented scenario in the
form of net subgraph,
δ = ([A, o0, t1, (x = 10)⟩, [F, o0, t1, (x = 10, o = @o1)⟩,
[A, o0, t1, (x = 20)⟩, [F, o0, t1, (x = 20, o = @o2)⟩,
[A, o1.m1, t2, (x = 10)⟩, [A, o1.m1, t2, (x = 10, a = 20)⟩,
[A, o2.m1, t2, (x = 20)⟩, [A, o2.m1, t2, (x = 20, a = 30)⟩)
Now, let us go back to our example and the event
[(A, m1, C1.doFor:.t2, {(c, o1), (s, 0), (n, n1)})⟩. When this
internal event is executed, the synchronized port (o1, C0.get:)
is executed simultaneously, so the net o1 will trigger an
external event C0.get:, which removes one object from the
place (o1, C0.p2). Execution of the net m1 corresponds to a
sequence of internal events (in abbreviated notation)
δ1(m1) = ([(F, t1)⟩, [(C, t1)⟩, [(J, t1)⟩, [(A, t2)⟩,
[(A, t2)⟩, [(A, t2)⟩, [(A, t3)⟩)
and execution of the net o1 corresponds to the sequence of
events (in abbreviated notation, external event is highlighted
by superscript e)
δ1(o1) = ([(A, t1)⟩, [(A, t1)⟩, [(A, t1)⟩,
[(A, get:)⟩e, [(A, get:)⟩e, [(A, get:)⟩e.
For the sake of readability, it is possible not to include in the
notation those components which are not important for the
described situation. In our case, we only show the type of
event and the transition, in other situations a simple sequence
of transitions is sufﬁcient.
E. Composite Command
If the transition contains a sequence of messages, either
step-by-step or composite ones, this transition can be under-
stood, from the OOPN theory point of view, as a sequence
of simple transitions, each of which contains just one simple
command. An example of such equivalence is shown in Figure
8.
p1
p2
≈
a)
b := o doit: (n+2).
(@o1, 10), 
(@o2, 20)
(o, n)
t1
p1
p2
b)
tmp1 := (n+2).
b := o doit: tmp1.
(o, n)
t1
b
b
p1
t1_tmp1
c)
tmp1 := (n+2).
(o, n)
t1[1]
(o, n, tmp1)
p2
b := o doit: tmp1.
t1[2]
b
(o, n, tmp1)
≈
(@o1, 10), 
(@o2, 20)
(@o1, 10), 
(@o2, 20)
Figure 8.
Composite command of the transition.
This model has four variants of execution. In the following
example, only one is listed, the others are a combination of
different interleaving of two concurrently running transitions
196
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

t1. The notation of a transition using index, e.g., t1[1], refers
to the corresponding command of the composite transition.
δ1(o0)
=
([A, o0, t1[1], {o = @o1, n = 10}⟩,
[F, o0, t1[2], {o = @o1, n = 10, tmp1 = 12}⟩,
[J, o0, t1[2], {(o = @o1, n = 10, tmp1 = 12}⟩,
[A, o0, t1[1], {(o = @o2, n = 20}⟩,
[F, o0, t1[2], {o = @o2, n = 20, tmp1 = 22}⟩,
[J, o0, t1[2], {o = @o2, n = 20, tmp1 = 22}⟩)
Due to that reason we slightly modify the transition mark-
ing deﬁnition, MT ⊂ (OΓ ∪ NΓ) × T × N × P(BIND), where
N represents an index of the composite transition command.
V.
RECORDING THE SIMULATION
This section focuses on recording states during simulation.
We describe each of the monitored events and how the state
changes are recorded. To record the entire state would be very
time consuming and memory intensive, and from the means
offered by OOPN formalism point of view also unnecessary.
For stepping, it is sufﬁcient to save partial state changes that
avoid storing the whole simulation image after every step.
A. State Changes Processing
A partial state change may involve inserting or selecting
an element from a place, assigning the result to a variable,
creating or destroying an object, creating or completing a
method net instance (associated with calling and terminating
this method), and creating or completing a transition instance.
1) Changing Place State: Changing the place state is the
easiest operation corresponding to removing elements when
transition ﬁres or adding elements when the transition is
complete. Within one step, more elements can be inserted or
removed into or out of more places. The change is recorded in
the following notation. We deﬁne the operation add(p, m, o)
for adding element to the place and operation del(p, m, o) for
removing element from the place. In both operations, p ∈ P
is the place, and m ∈ N+ is the frequency of element o ∈ U.
2) Firing and Completing Composite Transition: Although
the composite command in the transition is always interpreted
as a sequence of individual commands, it is necessary to
maintain a relationship with the original entire transition. Ad-
ditionally, the transition can be run multiple times for different
bindings, so it is necessary to identify the speciﬁc transition
instance uniquely. Therefore, we introduce a particular event
type B, which represents the transition ﬁring for a given
binding, and at the same time, assigns a unique identiﬁer to
the ﬁred transition. Similarly, we introduce a particular C event
type to completing the ﬁred transition.
Deﬁnition 14: For writing state changes, we extend the
deﬁnition of the system of objects Γ to the set of transition
instance identiﬁers TΓ, i.e., transitions ﬁred with a speciﬁc
binding, Γ = (OΓ, NΓ, TΓ, MN, MT).
3) Changing Variable State: Changing the state of the
variable when executing the transition is denoted by operation
swap(ti, v, onew, oold), where ti ∈ TΓ is a transition, v ∈ VAR
is the transition variable, onew ∈ U is a universe object
assigned to the variable v and oold ∈ U is the original object
assigned to the variable v before this event occurs.
4) Creating Object: Creating an object (a class instance)
corresponds to the creation of an object net and its initial-
ization. In terms of state recording, it is essential to keep
information about the identiﬁcation of newly created object
∐C and changes of the object net’s places, i.e., adding objects
into places during the net initialization process.
5) Creating Method Net Instances: Creating a method
net instance corresponds to a method invoking by sending a
message. As with the object, it is necessary to keep information
about the identiﬁcation of newly created instance ∐N and
inserting objects (values) into the net’s parameter places.
6) Completing Method Net Instances: After the method net
instance is completed,
two possible options can be applied
to record changes. First, the current state of the entire net is
recorded, i.e., marking of all places and all ﬁred transitions
(instances). Second, no state is recorded. The ﬁrst option is
more demanding for time and memory space during simula-
tion. On the other side, it is not necessary to reconstruct the
net’s state so that it matches the state before its completion.
The second option is more efﬁcient during simulation, but it is
more demanding to reconstruct the net’s state during backward
stepping. At this point, we focus on the option without state
recording. We introduce a special operation ∆N(mi), which
indicates the completion and cancellation of the net instance
mi.
B. Example of Tracing Simulation
We demonstrate the concept of simulation tracking on the
model shown in Figure 5 for variant 1, i.e., with the initial
marking MP(p1) = {1‘10}. For the reasons given in Section
V-A2, we will modify the event deﬁnition as follows:
Deﬁnition 15: Event is ev = (e, id, t, ti, b), where e is
a kind of event, id ∈ NΓ ∪ OΓ is the identiﬁer of the net
instance the event executes in, t ∈ T is the transition to be
executed (ﬁred), and b ∈ P(BIND) is variables binding for
which this event is executed, and ti ∈ TΓ is the identiﬁer of
ﬁred transition.
There is only one variant of execution. The sequence of
events is captured in Figure 9. For this text, we simplify writing
so that we do not specify the binding b, and where it is evident
from the context, we will not even specify the net identiﬁer
id.
δ(o1) = ([B, t1, t11⟩, [A, t1[1], t11⟩, [F, t1[2], t11⟩, δ(m1),
[J, t1[2], t11⟩, [C, t1, t11⟩)
δ(m1) = ([B, t2, t21⟩, [A, t2[1], t21⟩, [A, t2[2], t21⟩,
[J, t1, t11⟩)
Figure 9.
Scenario (event ﬂow) of the sample example.
The sequence of ﬁred transitions does not necessarily
correspond to the tracing tree, which also takes into account
the simulation branching. The sequence of ﬁred transitions
captures a speciﬁc sequence of events, which is always un-
ambiguously given. Figure 10 captures the sequence of events
(scenario) completed with state change operations. It represents
197
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Event
State
∐C(A1, o1)
add(o1.p1, 1, (10, ε, ε))
[B, o1, t1, t11⟩
del(o1.p1, 1, (10, ε, ε))
swap(t11, x, (10, ε, ε), ε)
[A, o1, t1[1], t11⟩
∐C(A2, o2)
swap(t11, o, (ε, ε, o2), ε)
[F, o1, t1[2], t11⟩
∐N(o2, A2.calc:, m1)
add(o2.m1.x, 1, (10, ε, ε))
[B, o2.m1, t2, t21⟩
del(o2.m1.x, 1, (10, ε, ε))
swap(t21, x, (10, ε, ε), ε)
[A, o2.m1, t2[1], t21⟩
swap(t21, a, (20, ε, ε), ε)
[A, o2.m1, t2[2], t21⟩
swap(t21, b, (40, ε, ε), ε)
[C, o2.m1, t2, t21⟩
add(o2.m1.return, 1, (40, ε, ε))
[J, o1, t1[2], t11⟩
∆N(m1)
swap(t11, r, (40, ε, ε), ε)
[C, o1, t11⟩
add(o1.p2, 1, (40, ε, ε))
Figure 10.
Scenario record.
a tracing simulation with storing relevant information for
backward stepping. We can see state changes in the State
column. For this text, we simplify writing events so that we
do not specify the binding b.
VI.
REVERSE DEBUGGING
In this section, we describe steps that are performed when
stepping backwards.
A. State Changes Reverse Processing
There is a sequence of reverse operations for each state
change that allows to return to the previous step. We explain
the operations associated with each recorded event. Some of
the operations are demonstrated on the discussed example, the
ﬁrst steps of reverse debugging are shown in Figure 11.
1) C-Event Type: The event C represents completing the
transition instance ti. In a step back, our goal is to reconstruct
this instance. It is necessary to perform the reverse operations
that are associated with this event. Since these operations refer
to the insertion of elements into the output places, the reverse
operations remove these elements. The next step is to recon-
struct the state of transition instance ti. We ﬁnd the ﬁrst entry
regarding the instance ti, i.e., [B, t, ti⟩, create this instance and
perform all the swap operations. In our example, this would be
a sequence of events [B, t1, t11⟩, [A, t1[1], t11⟩, [F, t1[2], t11⟩
and [J, t1[2], t11⟩. Event B ensures creation of the appropri-
ate instance with the t11 identiﬁer. The associated sequence
of swap operators is as follows: swap(t11, x, (10, ε, ε), ε),
swap(t11, o, (ε, ε, o2), ε) and swap(t11, r, (40, ε, ε), ε). This
way we ﬁlled all the variables with appropriate values, and we
are in a state where the transition instance t11 was completed.
If the object, resp. its identiﬁer, that has been destroyed (e.g.,
because it was removed by a garbage collector) is assigned to
the variable, it is not essential at this point. The object will
be reconstructed at the ﬁrst access to it (state handling, work
with method net, etc.).
2) J-Event Type: The event J represents completing the
call of method. The reverse swap operation is executed, i.e., the
value is removed from the variable and replaced with the origi-
nal (previous) value. The next step is to perform a reverse oper-
ation ¯
∆N(mi) to destroying the method net ∆N(mi), i.e., creat-
ing net instance mi and reconstructing its last state. Using oper-
ation ¯
∆N(mi), we get a sequence of operations over the net mi
starting with ∐N(oi, class.method name, mi) operation. From
this sequence, we will perform add and del operations on the
net instance mi. In our example, it would be a sequence of op-
erations add(o2.m1.x, 1, (10, ε, ε)), del(o2.m1.x, 1, (10, ε, ε))
and add(o2.m1, return, 1, (40, ε, ε)). As a result, we made
method net in the state, where the place return contains the
object representing number 40.
Step
State
[C, o1, t11⟩
del(o1.p2, 1, (40, ε, ε))
[J, o1, t1[2], t11⟩
swap(t11, r, ε, (40, ε, ε))
¯
∆N(m1) ⇒
∐N(o2, A2.calc:, m1)
add(o2.m1.x, 1, (10, ε, ε))
del(o2.m1.x, 1, (10, ε, ε))
add(o2.m1.return, 1, (40, ε, ε))
[C, o2.m1, t2, t21⟩
del(o2.m1.return, 1, (40, ε, ε))
swap(t21, x, (10, ε, ε), ε)
swap(t21, a, (20, ε, ε), ε)
swap(t21, b, (40, ε, ε), ε)
[A, o2.m1, t2[2], t21⟩
swap(t21, b, ε, (40, ε, ε))
Figure 11.
Reverse scenario.
There may be still instances of transitions that are not
terminated at the method net completion. It may happen,
although it very probably indicates a mistake in the design, that
there are still instances of transitions that are not terminated
at the method net completion. These instances must also be
reconstructed. From the sequence of operations
¯
∆N(mi), we
ﬁnd such sequences that correspond to unﬁnished transitions
starting with [B, t, ti⟩ event, but having no event [C, ti⟩.
For each such sequence we perform actions similarly to the
backward step of [C, ti⟩ event.
3) F-Event Type: The event F represents the method invok-
ing on the object. In the reverse step, the appropriate instance
of method net speciﬁed in ∐N operator is destroyed.
4) A-Event Type: The event A represents the atomic execu-
tion of the operation. The reverse swap operation is executed,
i.e., the value is removed from the variable and replaced with
the original (previous) value. If the atomic operation is a
creation of a class instance ∐C, this instance is destroyed.
5) B-Event Type: The event B represents the start of
transition execution (creation of a transition instance). In the
reverse step, the transition instance ti is destroyed, and the
add reverse operation is performed. There is no need to swap
variables, as the entire ﬁred transition is canceled.
198
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

B. Object Reconstruction
At the time of access to the object, e.g., due to the
reconstruction of the method net, it may happen that the object
no longer exists. The reason may be the loss of all references
to this object and its removal by the garbage collector. At
this point, it is necessary to create the object and reconstruct
its last state. Because the object was destroyed, it means
that there were no existing method nets. It is necessary to
reconstruct the state of the object net, which is done in the
same way as the method net reconstruction. The sequence of
corresponding operations on the object net oi is obtained by
using ¯
∆O(oi) operation, which is similar to ¯
∆N(oi) operation,
but the obtained sequence starts with ∐C(class, oi) operation
and the class instance is created instead of method net instance.
VII.
SAVING THE SIMULATION STATE
As already mentioned, one way of ensuring the consistency
of the state in reverse debugging is by continuously saving the
state. In this section, we outline the way of the object’s state
saving and the associated problems.
A. Simulation State
The problem associated with continually saving changes
may be the time consuming to reconstruct a state that is
far from the current location, i.e., the simulation state. The
distance µ can be deﬁned as the number of steps taken from
the start of the simulation, or the last saved state, to the
stop point of the simulation. From this perspective, it seems
appropriate to provide continuous saving the entire state at
speciﬁc distances (after a certain number of steps) and saving
changes from that storage point. In this way, the process of
reconstructing states according to debugging requirements can
be accelerated. On the other hand, it increases the demands of
both spatial (the need to store more data) and time during the
simulation. The question arises as to the appropriate choice of
distance µ, after which it is useful to save the whole state of
the simulation.
Deﬁnition 16: Simulation state S corresponds to the sys-
tem of objects Γ consisting of sets of nets identiﬁers, net
markings, and transition markings, S
=
(Γ, RT), where
RT ⊆ NΓ × (T, N) is a relation mapping ﬁred method nets to
ﬁred transitions from which the nets have been called.
B. Domain objects
The second, more serious problem is related to objects that
are not directly managed by the simulation engine. These are
primarily objects of the production environment OD, which
are instances of the domain classes CD. In this case, it is not
possible to reconstruct the state as presented in the previous
sections (except for the constant objects OC).
We can divide domain objects into several categories and
work with them accordingly when trying to save a simulation
state:
•
General objects. Their concrete form cannot be spec-
iﬁed in any way and, thus, it is impossible to deﬁne
some limitations on these objects. They cannot be
easily managed.
•
Collection. Collections can be understood as speciﬁc
objects, and the simulator can be prepared for it; their
storage and recovery can be ensured in a relatively
simple manner. However, objects stored in collections
fall into the general object category.
•
Interface to other systems. These objects serve as
wrappers for other objects and as such can be un-
derstood as constant objects. Therefore, these objects
do not need to be stored. Again, the objects that the
interface encapsulates are general objects.
•
Objects that are linked to the model (that is, the model
may not have references to them). These objects are
mostly outside the simulation management and use
model objects mainly to determine the state by which
they set their own state. Typically, these are user
interface objects. This group can be understood as a
speciﬁc subset of general objects.
•
Simulated general objects. These objects are mostly
used instead of ordinary general objects to simulate
their behavior and reactions. They are used when it
is impossible to connect created models to the real
environment, or it is not necessary.
C. General Domain Objects
General domain objects are a signiﬁcant problem in pro-
viding state during the simulation. One solution is to use the
resources of the production environment, i.e., the environment
in which the domain objects are implemented, and to serialize
and deserialize those objects. In many cases, however, this
solution requires to modify domain class deﬁnitions, e.g.,
to use annotations associated with a suitable Java toolkit.
But, such an approach is so demanding that it is unusable
in practice. Another problem is the large object structures
where an object referenced from the OOPN model contains
references to other nested objects. Ensuring their consistency
is a signiﬁcant problem in the reconstruction of complex object
structures.
The speciﬁc solution to this problem then depends on the
environment in which the entire system for modeling and
verifying requirements is implemented. The implementation in
Smalltalk can use a relatively clear and straightforward means
of storing the state of objects without having to interfere in
any way with the existing domain object code [15]. In this
case, the combination of continually saving state changes and
saving the entire state after µ steps is applied. Generic domain
objects can be stored with the entire structure, or the plunging
depth can be limited.
It is necessary to take into account that when debugging
with backward steps, it is not possible to ensure a complete
reconstruction of all domain objects, but only the basic ones,
as mentioned above. Additionally, some of the general domain
objects are still in the last achieved state. Nevertheless, we
have to realize that the system, for which the discussed
backward stepping principle is intended, serves mainly for the
analysis and veriﬁcation of requirements, as presented in [17].
General domain objects are mainly used to link the created
model to existing components for system validation under real
conditions. Under these circumstances, it can be accepted if
199
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

some actions on the domain objects are not performed. It is still
possible to trace back the location where the error occurred, or
the wrong data was sent to the domain objects. If a simulated
domain object is used for validation purposes, the situation at
the state reconstruction is much simpler.
VIII.
CONCLUSION
The paper dealt with the concept of tracing and reversing
a run of software system modeled by Petri Nets, especially
the formalism of Object Oriented Petri nets. While the model
is running, the sequence of events and changes in states
of individual elements are logged. The presented concept,
combined with saving the execution state, is fully functional
but has not yet taken into account all the possibilities of
use. We have abstracted the possibility of having objects that
have running method nets, even though the garbage collector
collected them. The reason is the existence of cyclic depen-
dencies but unavailable from the initial object. We also were
only concerned with pure Petri Nets objects and passed the
domain objects, e.g., collections, objects of user classes, etc.
The way of storing the state of generic domain objects remains
an open question. One possibility is to save these states only
at predeﬁned points and then reconstruct them on the ﬂy - this
would involve the actual steps taken during the reconstruction.
In any case, each solution requires collaboration of the host
environment or subordination of domain object management
to the OOPN simulator.
At present, we have an experimental partial implementation
of the tool supporting reverse debugging. We will complete
the implementation in the future and focus on the limitation
mentioned above. For more effective stepping, it may be neces-
sary to introduce a reconstruction of the whole state at speciﬁc
points (e.g., at breakpoints). To provide greater ﬂexibility in
interactive debugging, we will consider the possibility to deﬁne
the granularity of the unit to be traced (complete transition,
command, method) at runtime.
ACKNOWLEDGMENT
This work has been supported by The Ministry of Educa-
tion, Youth and Sports of the Czech Republic from the National
Programme of Sustainability (NPU II); project IT4Innovations
excellence in science - LQ1602.
REFERENCES
[1]
R. Koˇc´ı and V. Janouˇsek, “Tracing and Reversing the Run of Software
Systems Implemented by Petri Nets,” in ThinkMind ICSEA 2018, The
Tvelfth International Conference on Software Engineering Advances.
Xpert Publishing Services, 2018.
[2]
R. Koˇc´ı and V. Janouˇsek, “Speciﬁcation of Requirements Using Uniﬁed
Modeling Language and Petri Nets,” International Journal on Advances
in Software, vol. 10, no. 12, 2017, pp. 121–131.
[3]
R. Koˇc´ı and V. Janouˇsek, “Modeling and Simulation-Based Design
Using Object-Oriented Petri Nets: A Case Study,” in Proceeding of the
International Workshop on Petri Nets and Software Engineering 2012,
vol. 851.
CEUR, 2012, pp. 253–266.
[4]
J. Rumbaugh, I. Jacobson, and G. Booch, The Uniﬁed Modeling
Language Reference Manual.
Addison-Wesley, 1999.
[5]
C. Raistrick, P. Francis, J. Wright, C. Carter, and I. Wilkie, Model
Driven Architecture with Executable UML.
Cambridge University
Press, 2004.
[6]
M. ˇCeˇska, V. Janouˇsek, and T. Vojnar, “Modelling, Prototyping, and Ver-
ifying Concurrent and Distributed Applications Using Object-Oriented
Petri Nets,” Kybernetes: The International Journal of Systems and
Cybernetics, vol. 2002, no. 9, 2002.
[7]
D. Cetinkaya, A. V. Dai, and M. D. Seck, “Model continuity in
discrete event simulation: A framework for model-driven development
of simulation models,” ACM Transactions on Modeling and Computer
Simulation, vol. 25, no. 3, 2015.
[8]
T. LeBlanc and J. Mellor-Crummey, “Debugging Parallel Programs with
Instant Replay,” IEEE Transactions on Computers, vol. 36, no. 4, 1987,
pp. 471–482.
[9]
I. Huff, “IntelliTrace in Visual Studion 2010 Ultimate,” MSDN
Blogs,
http://blogs.msdn.com/b/ianhu/archive/2009/05/13/historical-
debugging-in-visual-studio-team-system-2010.aspx, 2009.
[10]
M. Lindahl, “The Device Software Engineer’s Best Friend,” in IEEE
Computer, 2006.
[11]
B. Lewis and M. Ducasse, “Using Events to Debug Java Programs
Backwards in Time,” in Proc. of the ACM SIGPLAN 2003 Conference
on Object-oriented programming, systems, languages, and applications
(OOPSLA), 2003, pp. 96–97.
[12]
The GNU Project Debugger, “GDB and Reverse Debugging,” GNU
pages, https://www.gnu.org/software/gdb/news/reversible.html, 2009.
[13]
F. V. B. Berthomieu, F. Peres, “Model-checking Bounded Prioriterized
Time Petri Nets,” in Proceedings of ATVA, 2007.
[14]
O. Kummer, F. Wienberg, and et al., “Renew – User Guide,”
http://www.informatik.uni-hamburg.de/TGI/renew/renew.pdf,
January
2016.
[15]
A. GoldBerk and D. Robson, Smalltalk 80: The Language.
Addison-
Wesley, 1989.
[16]
R. Koˇc´ı and V. Janouˇsek, “The Object Oriented Petri Net Component
Model,” in The Tenth International Conference on Software Engineering
Advances.
Xpert Publishing Services, 2015, pp. 309–315.
[17]
R. Koˇc´ı and V. Janouˇsek, “Modeling System Requirements Using Use
Cases and Petri Nets,” in ThinkMind ICSEA 2016, The Eleventh
International Conference on Software Engineering Advances.
Xpert
Publishing Services, 2016, pp. 160–165.
200
International Journal on Advances in Software, vol 12 no 3 & 4, year 2019, http://www.iariajournals.org/software/
2019, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

