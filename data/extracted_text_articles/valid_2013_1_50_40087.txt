Formal Composition Based on Roles within a Model Driven Engineering Approach
C´edrick Lelionnais
J´erˆome Delatour
and Matthias Brun
ESEO-TRAME
Angers, FRANCE
{cedrick.lelionnais,jerome.delatour,matthias.brun}@eseo.fr
Olivier H. Roux
and Charlotte Seidner
IRCCyN - Universit´e de Nantes
´Ecole Centrale de Nantes
Nantes, FRANCE
{olivier-h.roux,charlotte.seidner}@irccyn.ec-nantes.fr
Abstract—Faced with the increasing complexity of Real-
Time Embedded Systems, Model Driven Engineering offers the
possibility of developping frameworks in which transformations
are used to generate either executable code or formal models.
However, these transformations themselves are generally not
formalized. Correctness of transformations could therefore be
called into question. This paper proposes a formalization of a
transformation step, namely: the composition of formal fragments
describing the behavior of a real-time system. These fragments
are described using an extension of the classical Time Petri Nets,
where the notion of roles was added to perform the composition
of the fragments. This formalization increases conﬁdence in
transformations.
Keywords—Model Driven Engineering, Real-time operating sys-
tems, Behavioral modeling, Transformation, Veriﬁcation, Time Petri
Nets, Application deployment
I.
INTRODUCTION
Real-Time Embedded Systems (RTESs) increasingly sur-
round us in various domains (aircrafts, automotive sector, cell
phones, robotics, etc.). RTES engineers are confronted with the
challenge of developing more complex, higher quality systems,
with shorter development cycles at lower costs. Model Driven
Engineering (MDE) [7] helps engineers to develop frameworks
for partially automating the development of RTESs. Thanks to
transformations, those frameworks produce either executable
code or formal models from high-level descriptions of RTESs.
However, many frameworks do not consider the description
of Real-Time Operating Systems (RTOSs) [4]. RTOSs have
indeed an impact on the behavior of RTESs. In addition,
in spite of the fact that the behavior of RTOSs starts to
be considered, transformations have often been implemented
within frameworks without formalization. Correctness of the
transformation could therefore be called into question. Conﬁ-
dence in those frameworks could also be reduced.
The general approach presented in this paper aims to create
a formal model of the whole system deployed on a RTOS.
This approach was thought regardless of the intended RTOS.
To do this, a transformation process is currently in progress to
compose several behavioral fragments, each one describing a
part of this system. Those fragments come from a model of
the targeted RTOS, which is considered through the process
execution. However, composition rules must be chained in a
right sequence in order to avoid any ambiguity. As a basis of
the construction, the use of roles formally identify connection
points, which will be used as a glue of the system parts.
This paper is divided into the following sections. Section 2
refers brieﬂy to the frameworks chosen for this contribution.
The latter is presented in Section 3, highlighting both the
deployment process and the use of roles. Section 4 deals
with Time Petri Nets (TPNs) as translation formalism. A
new syntax is then deﬁned formalizing the composition of
TPNs based on roles. Relying on this deﬁnition, Section 5
formalizes the construction of an application deployment in
TPN. Consequently, the beneﬁts and limits of this approach
are discussed in Section 6. Finally, we conclude in Section 7.
II.
RELATED WORKS
A ﬁrst presentation of related works in conjunction with
the consideration of RTOSs has already been presented in a
previous contribution [4]. For this reason, frameworks in line
with the consideration of RTOSs will only be presented here.
We have opted for frameworks in which the intervention
of each stakeholder has been made more ﬂexible. Indeed, the
domain skills (RTOSs structure, transformations, deployments
choice, etc.) are correctly separated with these frameworks.
This has been made possible thanks to an explicit approach,
which consists in considering each RTOS description without
modifying the transformation rules. This strategy offers the
possibility to capitalize most descriptions in a generic way.
Furthermore, other works [3] [4] are based on the behavioral
consideration of RTOSs. These contributions search for reﬁn-
ing models of applications deployed on RTOS with the aim of
verifying properties.
We can note the MARTE UML proﬁle [8] in which
the Software Resource Modeling (SRM) approach [12] has
been integrated. With SRM, RTOSs can be modeled using
stereotyped concepts from the real-time software domain. For
another example, Software Execution Platform Inside Tools
(SExPIsTools) is involved in the tooling of development pro-
cesses. Real-Time Embedded Platform Modeling Language
(RTEPML) [2] was developped in this sense, with the aim
of deﬁning concepts dedicated to the real-time domain for
modeling RTOSs.
However, as introduced previously, the processes imple-
mented in those frameworks have not yet been formalized. We
have therefore decided to carry on developping SExPIsTools
by experimenting the formalization.
III.
CONTEXTUALIZATION IN A MDE APPROACH
This section is divided into two parts. The ﬁrst part presents
the SExPIsTools framework and the language RTEPML [2].
This presentation details the notion of role, which is used for
the composition of behavioral descriptions. The second part
speciﬁes the language adopted for formalizing.
27
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

A. SExPIsTools Framework
SExPIsTools (Figure 1) allows to generate code from high-
level descriptions [2] to several RTOSs. The RTOS description
(i.e., the Platform Description Model) is a parameter of the
generic transformation made possible thanks to the notion
of role. A role explicitly establishes a relationship between
abstract concepts of RTOSs (i.e., the notion of task), their
properties (priority of task) and their services (creation or
destruction of task). The transformation rules rely on both
concepts and roles. For each Platform Description Model,
translation of roles is given in the Application Programming
Interface (API) of the targeted RTOS. The descriptions are
realized by the modeling language RTEPML.
Fig. 1: SExPIsTools Process within MDE Context
RTEPML has been extended [4] to describe RTOSs be-
havior in a formal way. The purpose of formalizing was to
allow model-checking. For each concept and service of the
RTOS, a formal description (called fragment) is given. The
transformation process leads to the composition of fragments.
To facilitate this composition, some roles were added.
B. Choice of formal language
We have chosen TPNs [6] [1] to translate behavioral
fragments because we need a formalism which expresses
models with synchronism and parallelism for multitasking.
Lastly, RTOSs imply time constraints. The chosen formalism
needs to have clocks to represent time evolution.
IV.
TPN COMPOSITION BASED ON ROLES
In order to compose fragments in TPN, we have projected
roles on those fragments. To perform the composition, we have
decided to assign roles to places. The interest of such a method
is to merge places [11] [10], which are the connection points
of the system that must be modeled in TPN.
In this section, TPNs with roles are ﬁrstly deﬁned. The
deﬁnition of the instanciation of TPN with roles is then given.
Finally, the composition of TPNs is highlighted through a
synchronization formalism based on roles.
A. TPNs
TPNs are a timed extension of classical Petri nets. Infor-
mally, to each transition of the net is associated an implicit
clock and an explicit time interval. The clock measures the
time since the transition has been enabled and the time interval
is interpreted as a ﬁring condition: the transition may ﬁre if
the value of its clock belongs to the time interval.
Deﬁnition 1 (TPN): A
TPN
is
a
tuple
T
=
⟨P, T, Pre, Post, m0, Is⟩ where:
•
P is a ﬁnite non-empty set of places;
•
T is a ﬁnite non-empty set of transitions;
•
Pre : P × T → N is the backward incidence function;
•
Post : P × T → N is the forward incidence function;
•
m0 : P → N is the initial marking of the net;
•
Is : T → N × (N ∪ {+∞}) assigns a static time
interval to each transition.
A marking of T is an application from P to N. Let m be
a marking of T . Then, for any place p ∈ P, we say that p
contains m(p) tokens. A transition t ∈ T is said to be enabled
by the marking m if ∀p ∈ P, m(p) ≥ Pre(p, t). This is denoted
by t ∈ enabled (m). For any interval Is, we denote by Is
↓ the
smallest left-closed interval with lower bound 0 that contains
Is. For each transition t there is an associated clock xt. We
consider valuations on the set of clocks {xt|t ∈ T } and we will
slightly abuse the notations by writing v(t) instead of v(xt).
Let m be a marking of the net and t a transition in
enabled (m). Let m′ be the marking obtained from m by
ﬁring t. Let m′′ be the intermediate marking deﬁned by
∀p, m′′(p) = m(p)−Pre(p, t). A transition t′ is newly enabled
by the ﬁring of t from m, and we note t ∈ ↑enabled(m, t) if
t′ ∈ enabled (m′) \ enabled (m′′) ∪ {t}
The
operational
semantics
of
the
TPN
T
=
⟨P, T, Pre, Post, m0, Is⟩ is deﬁned by the time transition
system ST = (Q, q0, →) such that:
•
Q = NP × RT
≥0
•
q0 = (m0, 0)
•
→∈ Q×(T ∪R≥0)×Q is the transition relation includ-
ing a discrete transition and a continuous transition.
◦
The discrete transition is deﬁned ∀t ∈ T by
(m, v)
t∈T
−−→ (m′, v′) iff:
t ∈ enabled (m);
∀p ∈ P, m′(p) = m(p) − Pre(p, t) +
Post(p, t);
v(t) ∈ Is(t);
∀k
∈
[1, |T |],
v′
k(tk)
=
0 if tk ∈ ↑enabled(m, t)
vk(tk) otherwise
◦
The
continuous
transition
is
deﬁned
by
(m, v)
d∈R≥0
−−−−→
(m, v + d)
iff
∀t′
∈
enabled (m) , ∀0 < d′ ≤ d, (v + d′)(t′) ∈
I↓
s (t′).
Deﬁnition 2 (TPN with roles): A TPN with roles is a tuple
N = ⟨T , R, λ⟩ where:
•
T is a TPN,
•
R is a ﬁnite set of roles,
•
λ : P → R ∪ {⊥} is the function assigning a role to
a place and ⊥ denoting that no role is assigned to a
28
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

place. Hereafter, some notations and properties of this
function are enumerated :
1)
Pλ = {p ∈ P | λ(p) ̸= ⊥} is the set of places
with role.
2)
λ\Pλ : Pλ → R is an injective function;
3)
λ−1 : R ∪ {⊥} → P ∪ {∅} such that



∀r ∈ R, λ−1(r) =
p if λ(p) = r
∅ otherwise
λ−1(⊥) = ∅
The operational semantics of the TPN with roles N =
⟨T , R, λ⟩ is the same as that of TPN. Indeed, the use of roles
within the deﬁnition of TPN does not impact its semantics.
B. Instanciation of TPN with roles
As seen previously, some fragments of TPN are instan-
ciated before being composed. In order to distinguish the
fragments to compose, all roles in a same fragment must be
renamed according to the name of the instance.
Let N be the TPN to instanciate and x the label given to
the instance. The renaming function ⇁ is a function from R
to Ri where assigned roles are involved in parameters.
Deﬁnition 3 (Instanciation of TPN with roles): The
instanciation of N with m renamings is denoted by
Ni = Ins(N, x) = N
r1 ⇁ r1 x
. . .
rm ⇁ rm x
with m = |R| , ∀j ∈ [1, m] , rj ∈ R, rj x ∈ Ri and ∀k ∈
[1, m], k ̸= j → rk ̸= rj
C. TPNs Synchronization based on roles
In order to synchronize some TPNs, we must precise the
deﬁnition of the composition of TPNs, which will be based
on roles assigned to places. Let N1, . . . , Nn be n TPNs with
Ni = ⟨Pi, Ti, Prei, Posti, m0i, Isi, Ri, λi⟩ such that ∀k ̸= k′ ∈
[1, n] =⇒
Tk ∩ Tk′ = ∅ and Pk ∩ Pk′ = ∅. The composition
N = ⟨P, T, Pre, Post, m0, Is, R, λ⟩ of the previous TPNs with
roles will be denoted by N = N1||N2|| . . . ||Nn. Linked to
this composition, we deﬁne a function leading to the merging
of places whose assigned roles will be taken into account in
parameters.
The merging function ֒→ is a partial function from (R1 ∪
{•}) × (R2 ∪ {•}) × · · · × (Rn ∪ {•}) → P × R where • is a
special symbol used when a TPN is not involved in a particular
merge of the global system. We then extend the deﬁnition of
the assigning inverse function with λ−1(•) = ∅
The composition of n TPN with m merging is denoted by

N1|| . . . ||Nn

(r1
1, . . . , r1
n) ֒→ (p1, r1)
. . .
(rm
1 , . . . , rm
n ) ֒→ (pm, rm)
with ∀i ∈ [1, n], ∀j ∈ [1, m] , rj
i ∈ Ri, rj ∈ R and pj ∈ P,
and ∀k ∈ [1, m], k ̸= j ⇒ rk
i ̸= rj
i
We will subsequently use the following notations:
•
Let P merged
i
⊆ Pi be the set of places of the net
Ni merged by the composition. Formally P merged
i
=
S
∀j∈[1,m]
{λ−1
i (rj
i )}
•
Let P ֒→ ⊆ P be the set of places of the net N ob-
tained by the merging. Formally P ֒→ =
S
∀j∈[1,m]
{pj}
Deﬁnition 4 (Composition of TPNs with roles): The com-
position of the n TPN Ni with the merging ֒→ denoted by:
N =

N1|| . . . ||Nn

(r1
1, . . . , r1
n) ֒→ (p1, r1)
. . .
(rm
1 , . . . , rm
n ) ֒→ (pm, rm)
is deﬁned by:
•
R =

S
∀i∈[1,n]

=
 
N1||

N2||N3

(r2,r3)֒→(p23,r23)
!
(r1,r23)֒→(p,r)
Property 2 (Commutativity): The composition of TPNs
with roles is commutative:
 
N1||N2
!
(r1
1, r1
2) ֒→ (p1, r1)
. . .
(rk
1 , rk
2 ) ֒→ (pk, rk)
=
 
N2||N1
!
(r1
2, r1
1) ֒→ (p1, r1)
. . .
(rk
2 , rk
1 ) ֒→ (pk, rk)
V.
CONSTRUCTION AND ILLUSTRATION
The deﬁnitions presented above will help the formal con-
struction of behavioral models in TPN. This construction
will serve as a basis of the transformation process within
SExPIsTools framework (Figure 1). To better understand the
concepts involved in this construction, we must specify the
major categories of concepts in RTEPML [2]. At the moment,
three of them were selected from a behavioral point of view:
concurrent resources (i.e., tasks, interruptions, alarms, etc.),
interaction resources (i.e., semaphores, message queues, shared
data, events, etc.) and routines (i.e., application code). For the
sake of clarity, the construction has deliberately been splitted
into four composition operations. The overall construction is
a sequence of four operations.
A construction example in TPN is provided to illustrate
the method. Figure 2 presents some TPN fragments instanti-
ated with roles (in boxes), prepared for construction. Every
operation details the fragments involved in the composition.
The mergeable places are represented in double circle and
those ready to be merged are connected by a hook-dotted arc
with the number of the construction. The roles are assigned
to the right above of places. The whole model is describing
a monoprocessor application Proc with two periodic tasks
T ask1 and T ask2 sharing the same semaphore Sem1.
a) Construction for each routine: The routines serve
as executive body of concurrent resources. They consist of
an ordered sequence of call services. The list of services
considered in RTEPML is not exhaustive at the moment. The
instructions described in TPN are: activation and termination
of task, acquisition and release of semaphore and waiting,
notiﬁcation and inhibition of event.
Let n be the number of call services described follow-
ing: {NS1, NS2, . . . , NSn} such that ∀i ∈ [1, n], NSi
=
Ins(NS, Si) with NS the TPN describing a service. The
routine construction then implies n − 1 compositions, each
one having mj mergings of places with j ∈ [1, n − 1]. The
construction of a routine instance NR is given by (1).
Illustration 1 (See Figure 2): In
accordance
with
NR,
∀l
∈
[1, 2],
NT asklBody
is
built
from
TPNs
{NGetl(Sem1), NReleasel(Sem1), NT erminatel(T askl)}.
This
sequence describes in the order, an acquisition of Sem1, a
release of Sem1 and a termination of T askl.
b) Construction for each entry point of a concurrent
resource: Each resource points to a routine described by NR
previously formed. Only one operation composes NR with
NCλ = Ins(NC, Cλ). NC is the TPN describing a concurrent
resource. The construction of a concurrent resource instance
with its executive body NCR is given by (2) for m mergings.
Illustration 2 (See Figure 2): In accordance with NCR,
∀l ∈ [1, 2], NT askl withBody is built composing NT askl with
its entry point NT asklBody.
c) Construction for concurrent resources: At this stage,
concurrent resources must be attached together with the aim
of being scheduled by the same processor.
Let qC be the number of concurrent resources with their
composed executive bodies such that ∀iC ∈ [1, qC], each
resource is described by NCRiC in accordance with NCR
previously formed. The construction then implies qC −1 com-
positions, each one having mjC mergings with jC ∈ [1, qC−1].
The construction of NW is given by (3).
Illustration 3 (See Figure 2): In accordance with NW ,
NwithoutP roc is ﬁrstly composed of NT ask1 withBody and
NT ask2 withBody.
d) Global construction with processor and interaction
resources: Note that the processor is also a shared resource.
It will therefore be considered as an interaction resource.
Let qI be the number of interaction resources consid-
ered such that ∀iI
∈ [1, qI], each resource is described
by NIiI
= Ins(NI, IiI) with NI the TPN describing an
interaction resource. Each interaction resource is composed
with NW previously formed. The global construction then
implies qI compositions, each one having mjI mergings with
jI ∈ [1, qI]. The global composition NG is given by (4).
Illustration 4 (See Figure 2): In
accordance
with
NG,
NDeployedApplication is ﬁnalized by composing NwithoutP roc,
NSem1 and NP roc.
VI.
BENEFITS AND LIMITS
The use of TPNs with roles and the composition based on
roles has allowed to detect several errors within the SExPIs-
Tools transformation process. Those errors were bad transfor-
mation rules between concepts and roles, bad descriptions of
the behavioral fragments.
That has also clariﬁed the chaining of the transformation
rules. As a result, a part of the transformation prototype has
been rewritten. This approach has increased the conﬁdence in
SExPIsTools framework and its generated formal models.
Although SExPIsTools can consider several RTOSs, we
have only deﬁned fragments for OSEK/VDX [9] in TPN.
Moreover, some complex real-time mechanisms, such as pri-
ority ceiling protocol or special queues of message box show
the limits of the expressiveness of TPNs. For this reason, we
could not model those mechanisms.
VII.
CONCLUSION
An approach has been presented to build a formal model of
RTESs taking into account a RTOS description. A new deﬁni-
tion has extended the modeling in TPN to compose fragments
with roles. The formalized composition will be used as a basis
of the transformation process. The process implementation
in SExPIsTools is in progress. The framework integrates a
modeling language called RTEPML designed to describe the
behavior of RTOSs. During the process running, only the
description of the target execution platform is considered.
The main idea of this process is to maintain a genericity of
implementation. Composition rules introduced in this paper are
independant of any RTOSs thanks to role notion. This notion
is an essential point of our strategy and brings an advantage
in relation to other existing approaches. Future prospects are
scheduled in order to take into account other RTOS descrip-
tions. Another important point is the consideration of more
30
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

NR
=
 
NS1||NS2

(end S1, start S2) ֒→ (SS1→S2 , ⊥)
(r2
S1 , r2
S2 ) ֒→ (p2
S2 , r2
S2 )
. . .
(rm1
S1
, rm1
S2
) ֒→ (pm1
S2
, rm1
S2
)
||NS3

(end S2, start S3) ֒→ (SS1S2→S3 , ⊥)
(r2
S1S2 , r2
S3 ) ֒→ (p2
S3 , r2
S3 )
. . .
(rm2
S1S2
, rm2
S3
) ֒→ (pm2
S3
, rm2
S3
)
. . . ||NSn
!
(end Sn−1, start Sn) ֒→ (SS1S2...Sn−1→Sn , ⊥)
(r2
S1S2...Sn−1 , r2
Sn ) ֒→ (p2
Sn , r2
Sn )
. . .
(r
mn−1
S1S2...Sn−1
, r
mn−1
Sn
) ֒→ (p
mn−1
Sn
, r
mn−1
Sn
)
(1)
with ∀k ∈ [1, mj] and n ≥ 2 if k ≥ 2 then rk
S1...Sj = rk
Sj+1
NCR
=

NCλ||NR

(start Cλ, start S1) ֒→ (S, ⊥)
(end Cλ, end Sn) ֒→ (E, ⊥)
(r3
Cλ
, r3
R) ֒→ (p3
R, r3
R)
. . .
(rm
Cλ
, rm
R ) ֒→ (pm
R , rm
R )
(2)
with ∀k ∈ [1, m] if k ≥ 3 then rk
Cλ = rk
R
NW
=

NCR1||NCR2

(processor CR1, processor CR2) ֒→ (PCR1→CR2 , processor P roc)
(r2
CR1 , r2
CR2 ) ֒→ (p2
CR2 , r2
CR2 )
. . .
(rm1
CR1
, rm1
CR2
) ֒→ (pm1
CR2
, rm1
CR2
)
. . . ||NCRqC

(processor CRqC −1, processor CRqC ) ֒→ (PCR1...CRqC −1→CRqC
, processor P ROC)
(r2
CR1...CRqC −1 , r2
CRqC
) ֒→ (p2
CRqC
, r2
CRqC
)
. . .
(r
mqC −1
CR1...CRqC −1
, r
mqC −1
CRqC
) ֒→ (p
mqC −1
CRqC
, r
mqC −1
CRqC
)
(3)
with ∀kC ∈ [1, mjC] and qC ≥ 2 if kC ≥ 2 then rkC
CR1...CRjC = rkC
CRjC +1
NG
=

NW ||NI1

(r1
P , r1
I1 ) ֒→ (p1
I1 , r1
I1 )
. . .
(rm1
P
, rm1
I1
) ֒→ (pm1
I1
, rm1
I1
)
. . . ||NIqI

(r1
P I1...IqI −1 , r1
IqI
) ֒→ (p1
IqI
, r1
IqI
)
. . .
(r
mqI
P I1...IqI −1
, r
mqI
IqI
) ֒→ (p
mqI
IqI
, r
mqI
IqI
)
(4)
with ∀kI ∈ [1, mjI] and qI ≥ 1, rkI
P IjI −1 = rkI
IjI
complex RTOSs mechanisms. The use of high-level Petri Nets
such as Scheduling TPNs [5] is also planned.
Finally, a more long-term goal is planned to check the cor-
rectness of the transformation. A formal comparison between
an application model projected on a more abstract platform
and a deployed application model generated by SExPIsTools
could allow this veriﬁcation.
REFERENCES
[1]
M. Boyer and O.H. Roux, “On the compared expressiveness of arc, place
and transition time Petri nets,” Fundamenta Informaticae, August. 2008,
pp. 88(3):225-249.
[2]
M. Brun and J. Delatour, “Contribution on the software execution
platform integration during an application deployment process,” First
Topcased Day, Toulouse, February. 2011.
[3]
W. El Hajj Chehade, A. Radermacher, S. G´erard, and F. Terrier, “De-
tailed Real-Time Software Platform Modeling,” Software Engineering
Conference (APSEC), 17th Asia Paciﬁc, November. 2010, pp. 108-117.
[4]
C. Lelionnais, M. Brun, J. Delatour, O.H. Roux, and C.Seidner, “Formal
Behavioral Modeling of Real-Time Operating Systems,” ICEIS(2) -
Proceedings of the 14th International Conference on Enterprise Infor-
mation Systems (Special Session on Model Driven Development for
Information Systems: Techniques, Tools, and Methodologies - MDDIS
2012), Wroclaw, Poland: June. 2012, pp. 407-414.
[5]
D. Lime and O.H. Roux, “Formal veriﬁcation of real-time systems
with preemptive scheduling,” Journal of Real-Time Systems, Springer,
February. 2009, pp. 41(2):118-151.
[6]
M. Merlin, “A study of the recoverability of computing systems,”
PhD dissertation, Univ. of California, Department of Information ans
Computer Science, Irvine, 1974.
[7]
J. Miller and J. Mukerji, “Model Driven Architecture (MDA) Guide,
version 1.0.1.,” Technical report, Object Management Group, June. 2003.
[8]
Object Management Group (OMG), “UML Proﬁle for Modeling and
Analysis of Real Time and Embbeded systems (MARTE), version 1.1.,”
Technical report, June. 2011.
[9]
OSEK/VDX Group, “OSEK/VDX Operating System Speciﬁcation, ver-
sion 2.2.3.,” Technical report, February. 2005.
[10]
F. Peres, B. Berthomieu, and F. Vernadat, “On the composition of
Time Petri Nets,” Discrete Event Dynamic Systems, September. 2011,
pp. 21(3):395-424.
[11]
F. Ta¨ıani, M. Paludetto, and J. Delatour, “Composing real-time objects:
a case for Petri nets and Girard’s linear logic,” Object-Oriented Real-
Time Distributed Computing, ISORC-2001. Proceedings. Fourth IEEE
International Symposium on, May. 2001, pp. 298-305.
[12]
F. Thomas, S. G´erard, J. Delatour, and F. Terrier, “Software Real-Time
Resource Modeling,” Embedded Systems Speciﬁcation and Design Lan-
guages, Lecture Notes in Electrical Engineering, Springer Netherlands,
2008, pp. 10:169-182.
31
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

ENABLE
enabling T ask1
CLOCK
ACT IV AT ION
activation T ask1
SUSP ENDED
terminatedState T ask1
[inc; inc]
increment
T RIGGER
[period; period]
cycle
T RIGGER
[0; 0]
resuming
T RIGGER
READY
activatedState T ask1
[0; 0]
activation
T RIGGER
P ROCESSOR
processor T ask1
resumedState T ask1
RUNNING
start T ask1
ST ART
[0; 0]
T RIGGER
end T ask1
END
NTask1
NTask1 withBody
ENABLE
enabling T ask2
CLOCK
ACT IV AT ION
activation T ask2
SUSP ENDED
terminatedState T ask2
[inc; inc]
increment
T RIGGER
[period; period]
cycle
T RIGGER
[0; 0]
resuming
T RIGGER
READY
activatedState T ask2
[0; 0]
activation
T RIGGER
P ROCESSOR
processor T ask2
resumedState T ask2
RUNNING
start T ask2
ST ART
[0; 0]
T RIGGER
end T ask2
END
NTask2
NTask2 withBody
end Sem1
END
count Sem1
F REE
discount Sem1
BUSY
start Sem1
ST ART
[0; 0]
T RIGGER
[0; 0]
bypass
T RIGGER
NGet1(Sem1)
end Sem1
END
count Sem1
F REE
discount Sem1
BUSY
start Sem1
ST ART
[0; 0]
T RIGGER
[0; 0]
bypass
T RIGGER
NGet2(Sem1)
end Sem1
END
count Sem1
F REE
discount Sem1
BUSY
start Sem1
ST ART
[0; 0]
T RIGGER
[0; 0]
bypass
T RIGGER
NRelease1(Sem1)
end Sem1
END
count Sem1
F REE
discount Sem1
BUSY
start Sem1
ST ART
[0; 0]
T RIGGER
[0; 0]
bypass
T RIGGER
NRelease2(Sem1)
P ROCESSOR
processor T ask1
end T ask1
END
resumedState T ask1
RUNNING
terminatedState T ask1
SUSP ENDED
start T ask1
ST ART
[0; 0]
T RIGGER
NTerminate1(Task1)
P ROCESSOR
processor T ask2
end T ask2
END
resumedState T ask2
RUNNING
terminatedState T ask2
SUSP ENDED
start T ask2
ST ART
[0; 0]
T RIGGER
NTerminate2(Task2)
NTask1Body
NTask2Body
P ROCESSOR
processor P roc
NP roc
count Sem1
F REE
discount Sem1
BUSY
NSem1
NDeployedApplication
(a)
(a)
(a)
(a)
(a)
(a)
(a)
(a)
(b)
(b)
(b)
(b)
(b)
(b)
(b)
(b)
(b)(b)
(c)
(c)
(c)
(d)
(d)
(d)
Fig. 2: Deployed application of semaphore sharing composed in TPN
32
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

