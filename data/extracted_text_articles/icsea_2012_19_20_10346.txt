A Constraint-based Method to Compute Semantics of Channel-based Coordination
Models
Behnaz Changizi, Natallia Kokash
Leiden Institute of Advanced Computer Science (LIACS)
Leiden, The Netherlands
b.changizi@umail.leidenuniv.nl, nkokash@liacs.nl
Farhad Arbab
Centrum Wiskunde & Informatica (CWI)
Amsterdam, The Netherlands
farhad.arbab@cwi.nl
Abstract—Reo is an exogenous channel-based coordination
language that acts as glue code to tie together software
components and services. The building blocks of Reo models
are connectors that impose constraints on the data-ﬂow in
component or service-based architectures in terms of data syn-
chronization, buffering, mutual exclusion, etc. Several semantic
models have been introduced to formalize the behavior of Reo.
These models differ in terms of expressiveness, computation
complexity and purposes that they serve. In this paper, we
present a method and a tool for building formal automata-
based semantics of Reo that uniﬁes various aspects of existing
semantics. We express the behavior of a Reo network as a
mixed system of Boolean and numerical constraints constructed
compositionally by conjuncting the assertions for its constituent
parts. The solutions of this system are found with the help
of off-the-shelf constraint solvers and are used to construct
the constraint automaton with state memory that gives the
sound and complete semantics of Reo with respect to existing
models. Our approach is more efﬁcient compared to the existing
methods for generating formal semantics of Reo connectors.
Keywords-formal semantics; Reo; constraint automata; col-
oring semantics; constraint solving.
I. INTRODUCTION
Service-oriented architecture [1] (SOA) is an indispens-
able solution for many of todays’ problems. The SOA
implementation depends on a mesh of functionality units,
called services. Services are loosely coupled and do not
invoke or communicate with each other directly. Instead,
they employ a pre-deﬁned protocol, which speciﬁes the
way they can exchange messages amongst themselves. As a
result, the correctness of a SOA implementation relies not
only on the correctness of its involved services but also on
the properness of its communication protocol.
Coordination languages and models provide dedicated
frameworks to study the communication protocols as sepa-
rate concerns. They deﬁne the “glue code” that ties together
the services to enable the message passing among the
involved services. Some recent coordination models include:
i) a Calculus for Orchestration of Web Services (COWS)
[2], which speciﬁes the combination of service-oriented ap-
plications and models their dynamic behavior; ii) Orc [3], a
process calculus for distributed and concurrent programming
which provides uniform access to computational services,
including distributed communication and data manipulation;
and iii) Reo [4], an exogenous coordination language that
realizes the coordination patterns in terms of its complex
connectors, also called networks, that are built out of simple
primitives called channels. In the sequel, we focus on Reo.
Each channel in Reo deﬁnes a form of coordination in
terms of synchronizing, buffering, retaining data, etc., along
with constraining its input and output data items. Reo allows
hierarchical modeling where arbitrarily complex connectors
can be formed out of simpler networks. In our previous work
[5] [6], we have presented the suitability of Reo to model
behavioral patterns describable by business process models.
We have also developed tools for automatic transformation
of these models into Reo [6]. This enables the use of Reo
analysis methods and tools on the coordination protocols
that originally were not expressed in Reo.
To perform formal analysis on Reo networks, formal
semantics of these models are necessary. Several operational
semantics have been proposed for Reo [7] with various styles
of I/O streams [4], automata, coloring [8] and constraints [9].
The most basic automata-based semantics of Reo is Con-
straint Automata (CA) [10]. An advantage of CA and its
extensions is their support for data-constraints that are part
of the coordination primitives in Reo. This is in contrast with
the coloring semantics that abstracts data-ﬂow and expresses
the behavior of a connector only in terms of existence or lack
of data-ﬂow.
Constraint Automata with State Memory (CASM) [11] is
an extension of CA that due to its state abstraction and data-
awareness, is suitable as a more compact semantic model
for Reo in model checking. In this paper, we present a
constraint-based technique and a tool to generate CASMs
from Reo networks in a compositional manner.
A shortcoming of earlier work stems from its lack of
support for data-dependent behavior. We overcome this
shortcoming in the work we present in this paper. Our tool
is a necessary step for providing fully automated model
checking for data-aware and context-dependent composition
of services coordinated by Reo.
The rest of this paper is organized as follows. In Section
2, we explain the basics of Reo. In Section 3, we introduce
530
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Table I: Graphical Representation of the Most Frequently
Used Reo Channels
A Sync channel accepts data from its source end iff it
can dispense it simultaneously through its sink end.
A LossySync reads a data item from its source end and
writes it simultaneously to its sink end. If the sink end
is not ready to accept the data item, the channel loses it.
A SyncDrain reads data to discard through its two source
ends iff both ends are ready to interact simultaneously.
An AsyncDrain accepts and discards a data item from
either of its source ends that offers one. If both ends offer
data items simultaneously, then the channel chooses one
non-deterministically.
P
A Filter accepts a data item that does not match its
predeﬁned ﬁlter pattern P from its source and loses it.
For a data item that matches its ﬁlter pattern P, a ﬁlter
channel behaves as a Sync channel; it accepts the data
item iff it can dispense it simultaneously through its sink
end.
f
A Transformer acquires data at its source end, applies a
predeﬁned transform function f on it and simultaneously
writes the result to its sink end, iff the data item is in the
domain of the function f. Otherwise, the channel loses
the data item.
If a FIFO1 is empty, it accepts incoming data from its
source end and buffers it. Being full, the channel is ready
to dispense data through its sink end and become empty.
Because this channel has a buffer capacity of one data
item, it is either full or empty at any given time, and thus
the ends of this channel cannot interact simultaneously.
constraint automata with state memory. In Section 4, we
formalize the mentioned semantic model of Reo in systems
of constraints along with techniques to solve them. In
Section 5, we show how we abstract from the internal ports
in a Reo network in a minimized representation. In Section
6, we brieﬂy discuss some properties of our presented
constraint encoding of Reo networks. Finally, in Section 7,
we conclude the paper and outline our future work.
II. REO
Reo [4] is an exogenous channel-based coordination
language, which can act as “glue code” to tie together
software components and services. The building blocks of
Reo models, connectors, impose constraints on the data-ﬂow
in terms of synchronization, buffering, mutual exclusion, etc.
Every connector contains some primitives. The set of Reo
primitives is open-ended, meaning that a user can deﬁne new
primitives and extend the expressiveness of Reo.
The simplest Reo connector is a channel that has two
ends, also called ports. Channel ends are either of type
source that reads data into the channel or sink that writes
the channel’s data out. Table I shows the most commonly
used channels in Reo.
Reo nodes connect channels to each other to form Reo
connectors, also called circuits or networks. Depending on
whether all channel ends that coincide on a node are source
ends, sink ends or a combination of both, nodes become
source, sink or mixed nodes. A source node behaves as a
synchronous Replicator that replicates the incoming data
Table II: Graphical Representation of Reo Nodes and Two
Frequently Used Components
A Replicator replicates the incoming data of its source
to its sink ends simultaneously.
A Merger non-deterministically chooses one of its source
ends that is ready to communicate, take its incoming data
item and writes it to its sink end.
A Router accepts data from its source end and simul-
taneously writes it on one of its non-deterministically
chosen sink ends that is ready to accept the data.
A Cross-product reads one incoming data item from each
of its incoming source ends, forms a tuple in which the
data elements are set in the counter-clock-wise order
with respect to its sink node, and simultaneously writes
the resulting tuple on its sink end.
of its source to its sink ends simultaneously, while a sink
node acts as a non-deterministic Merger that combines the
ﬂows of its source ends to its sink end. A mixed node is an
atomic combination of a replicator and a non-deterministic
merger. Each read and write action needs all of its involved
source and sink ends to be able to interact synchronously;
otherwise, the action cannot take place. Reo also allows
hierarchical modeling and abstraction from inner structures
by means of components. A component can be written in
any programming language. Moreover, a connector can be
converted into a component, exhibiting (part of) its inner
logic as an observable behavioral interface. Table II shows
the graphical representation of the Reo nodes and two
frequently used components, Router and Cross-product.
A. Formal Semantics of Reo
Coordination patterns that a Reo network imposes on data-
ﬂow deﬁne the network’s behavior. Formal analysis of a
Reo network requires formal modeling of its behavior. The
behavior of a Reo network consists of various dimensions
that involve:
• State: The states of elements forming a Reo network at
any point in time deﬁne the state, also called conﬁgu-
ration, of the network. The network state affects and is
affected by the data-ﬂow at each step.
• Synchronization/Exclusion: The term synchronization
refers to atomic concurrent data-ﬂow through ports
and nodes. Depending on its constituents and their
arrangement inside the network, in each conﬁguration,
a Reo network allows, requires, or forbids a group of
ports to synchronize. We consider mutual exclusion as
a special case of synchronization.
• Data-dependent ﬂow: The value of data items that the
ports of a Reo network exchange can affect the network
behavior, particularly if the network contains elements,
such as ﬁlter or transformer channels, that allow or
forbid exchange of special data values.
• Context dependency: The choices some Reo elements
can take change non-monotonically as the context
changes [12]. A context-dependent semantics of Reo
531
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

deﬁnes context in terms of presence or absence of
pending I/O requests on boundary primitive ends. As
an example of such behavior consider the original
description of a LossySync channel, which writes on
its sink end the data item it reads from its source end.
The channel can lose a data item only if its sink end
is not write-enabled [4].
• Timing: The behavior of a Reo network can be subject
to time constraints. For example, we can formalize a
deadline for availability of some data using a FIFO1
channel, which associates an expiration time with the
data that it buffers. If the channel’s sink end does not
dispense a buffered data item before its expiration, the
channel loses it [13].
• Priority: Presence of a prioritized element in a Reo
network can inﬂuence some non-deterministic synchro-
nization choices in the network by favoring data-ﬂow
through ports related to that prioritized element.
B. Related work and motivation
Several formal semantic models have been proposed to
specify the behavior of Reo. An extensive overview and
comparison of these models is presented in [7].
Connector coloring (CC) [8] is a formal semantics for
Reo that describes the behavior of a connector by assigning
different colors to its ports to designate presence or absence
of data-ﬂow. CC accounts for synchronization and context
dependency. This model captures context dependency by
propagating negative information about the absence of data-
ﬂow inside the network.
The majority of Reo semantic models are based on
automata. These semantic models allow the semantics of a
large network to be constructed from the given automata
for its constituents using the product of automata. The
earliest automata-based Reo semantics is Constraint Au-
tomata (CA) [10] that accommodate synchronization, states,
and data-dependent ﬂow. Transitions in CA contain the set
of synchronized ports and constraints over data that the
ports exchange. An extension of CA, Constraint Automata
with State Memory (CASM) [11] elaborates on states by
introducing state memory cells and extends data constraints
to accommodate them.
Extending CA with clock assignments and timing con-
straints, Timed Constraint Automata (TCA) [13] express the
time-aware aspect of Reo networks. A SAT-based approach
for bounded model checking of TCA is presented in [14].
Another extension of CA, Constraint Automata with Priority
(CAP) [15] supports the propagation of prioritized requests.
The most recent semantics of Reo [9] that is based on
constraint solving, deals with synchronization, data-, and
context-dependency. It uses different constraints for each of
these notions, which are added conjunctively to capture their
composition. This approach is the basis of the DREAMS [9]
execution engine for Reo. Although in theory, this semantics
accounts for data-dependency, the proposed implementation
ignores data. This leads to incorrect results when dealing
with data-sensitive elements such as Filter channel.
A translation of CA and CC to a process algebraic
speciﬁcation language called mCRL2 [16] has been done
[17]. The mCRL2 toolset compiles the speciﬁcations into
Labeled Transition Systems (LTS)s, which can be veriﬁed
using the mCRL2 toolset. This approach represents certain
aspects of existing semantic models for Reo in an automata-
based form. For instance, it models the context dependency
in the behavior of Reo networks using LTSs with labels
corresponding to colors in CC.
Despite the abundance of the semantics that capture dif-
ferent aspects of Reo, there are expressiveness gaps among
them. For instance, a network with priority dependent and
time sensitive behavior cannot be readily expressed by any
of the mentioned formal semantics. In this paper, we present
a uniﬁed symbolic constraint-based framework, where these
different semantics coexist. This framework encodes the
behavior of Reo networks in terms of constraints whose
solutions form an existing automata-based semantic model
of Reo. Unlike [17], our framework treats data symbolically,
so that the state space does not blow up. Our framework ex-
tends DREAMS with time and priority. It also provides tool
support using existing constraint solving tools to incorporate
data and time constraints.
For a given conﬁguration of a Reo network, DREAMS
uses constraint solving to compute only a single solution
for synchronous data-ﬂow in this conﬁguration, which leads
to the next conﬁguration. In contrast, our approach considers
all solutions and conﬁgurations, which in turn enable us to
map the solutions to an automata-based semantics that is
well suited for model checking.
Generating the CA corresponding to a Reo network from
the CA of its constituents using the CA product operator
[10], is computationally expensive and memory inefﬁcient.
The complexity of composing m CA each having n transi-
tions is O(nm). However, we can convert this problem to
the NP-complete problem of SAT-solving for which many
efﬁcient solvers exist.
Contribution: Instead of generating the CA corresponding
to a Reo network directly by composing the CAs of its
constituents, we encode each constituent CA into constraints
whose conjunction forms the system of constraints that
captures the full behavior of the network. The solutions
of this system of constraints describe the behavior of the
network in terms of variables representing different aspects
of the behavior of Reo, such as synchronization, data-
dependent ﬂow, etc. From these solutions, we generate
the CA corresponding to the network. We show that our
solution is more efﬁcient compared to the previous attempts
in generating the formal semantics of a Reo network.
We have developed a tool to automate our approach that
is integrated in the Extensible Coordination Tools (ECT)
532
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

[18]. ECT is a framework to design, develop, model check,
test, and execute component-based software modeled by the
Reo coordination language. The tools in this framework
are integrated as Eclipse plug-ins and operate based on
the operational semantics of Reo, most notably, connector
coloring and constraint automata. Our tool is the only tool
that supports propagation of priorities in Reo networks.
Furthermore, it uniﬁes various behavioral aspects of Reo
networks in a single encoding, which enables analysis of net-
works whose behavior spans over several existing semantic
models.
III. CONSTRAINT AUTOMATA WITH STATE MEMORY
Constraint Automata with State Memory (CASM) [11]
extends CA with variables that represent local memory cells
of the states of the automata. Due to its elaboration on state
information, we choose CASM as the main semantic model
of Reo that our framework generates.
Deﬁnition 3.1 (Constraint Automaton with State Memory):
A constraint automaton with state memory (CASM) is a
tuple A = (Q, N, →, q0, M) where
• Q is a ﬁnite set of states.
• N is a ﬁnite set of names.
• → is a ﬁnite subset of Q × 2N × DC(N, M, D) × Q
is the transition relation of A, where DC(N, M, D) is
the set of data constraints, deﬁned below.
• q0 ∈ Q is an initial state.
• M is a set of memory cell names, where N ∩ M = ∅.
Every n ∈ N represents a node in a Reo connector.
The set N is partitioned into three mutually disjoint sets
of source nodes N src, mixed nodes N mix, and sink nodes
N snk. Because we make the replication and merge inherent
in Reo nodes explicit as replicator and merger primitives
(in Table II), at most two primitive ends coincide on every
node n ∈ N. Thus, it follows that a source or a sink node
contains only a single (source or sink) primitive end, and
a mixed node contains exactly one source and one sink
primitive ends.
We write q
N,g
−−→ p instead of (q, N, g, p) ∈→. For every
transition q
N,g
−−→ p, we require that g ∈ DC(N, M, D),
where D is the global set of numerical data values and
DC(N, M, D) is the language deﬁned by the following
grammar:
g
::=
true | ¬ g | g ∧ g | u = u | u < u,
u
::=
d(n) | m′ | m | v.
In this grammar, = is the symmetric equality relation, < is
a total order relation, n ∈ N ⊆ N denotes a node name,
d(n) represents the data item exchanged through the node
n, m ∈ M correspond to a memory cell in the current state,
which is the source state of the transition, m′ stands for the
memory cell m ∈ M in the next state, which is the target
state of the transition, and v ∈ D. As usual, false stands for
¬true, x > y stands for y < x, and other logical operators,
such as ∨ and ⇒ (the implication symbol) can be built from
the given operators.
Transitions with data constraints that can be reduced to
false using the Boolean laws are impossible and we omit
them. A data constraint g that is always true can be left
out. We use Mg to represent the set of all m ∈ M that
syntactically appear as m in a data constraint g; and M′g
to refer to the set of all m ∈ M that syntactically appear as
m′ in g. The valuation function Vq : M → 2D designates
the set of values Vq(m) of a memory cell m ∈ M in a state
q ∈ Q, where Vq0(m) = ∅ for all m ∈ M.
A transition q
N,g
−−→ p in a given constraint automaton with
state memory is possible only if there exists a substitution
for every syntactic element d(n), m, and m′ that appears in
g to satisfy g. A substitution simultaneously replaces in g:
- every occurrence of d(n) with the data value exchanged
through the node n ∈ N;
- every occurrence of m′ of every m ∈ M with a value
v ∈ D;
- every occurrence m ∈ M with:
– the special symbol ′◦′ if Vq(m) = ∅
– a value v ∈ Vq(m), otherwise.
The guard g is satisﬁed if proper replacement values can be
found to make g true. Making this transition, the automaton
deﬁnes the valuation function Vp for the target state p, as
follows: for every m ∈ M′
g, Vp(m) is the set of all v ∈ D
whose replacements for m′ satisfy g. For every other m ∈
M, Vp(m) = ∅.
A relational operator evaluates to true only if the values of
its operands are in its respective relation. Thus, any operator
with one or more ◦ as an operand always evaluates to false.
We call a CASM, normalized iff a) it does not have two
states with the same set of state memory variables, and b)
every two transitions differ at least in their start states, their
target states, or their sets of synchronizing ports. For any
arbitrary CASM that is not normalized, we can normalize it
by a) introducing auxiliary variables, to make the set of state
memory variables unique for each state, and b) by merging
the transitions that have the same start and target states and
synchronize the same ports. In the sequel, we consider only
normalized CASMs.
Following are the deﬁnitions for product and hiding
operations on CASM. Both deﬁnitions are adapted from
[10].
Deﬁnition 3.2 (Product-automaton): For the CASMs
A1 = (Q1, N1, →1, q0,1, M1) and A2 = (Q2, N2, →2,
q0,2, M2), their product is deﬁned as:
A1 ▷◁ A2 = (Q1 × Q2, N1 ∪ N2, →, q0,1 × q0,2, M1 ∪ M2)
where the following rules deﬁne the transition relation →:
q1
N1,g1
−−−−→1p1, q2
N2,g2
−−−−→2p2, N1 ∩ N2 = N2 ∩ N1
⟨q1, q2⟩
N1∪N2,g1∧g2
−−−−−−−−−→ ⟨p1, p2⟩
533
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

q1
N1,g1
−−−−→1p1, N1 ∩ N2 = ∅
⟨q1, q2⟩
N,g
−−→ ⟨p1, q2⟩
q2
N2,g2
−−−−→2p2, N1 ∩ N2 = ∅
⟨q1, q2⟩
N,g
−−→ ⟨q1, p2⟩
We can abstract from the data-ﬂow on certain Reo nodes
using the hiding operator deﬁned as follows:
Deﬁnition 3.3 (Hiding): Let A = (Q, N, →, q0, M)
be a constraint automaton and C ∈ N. The constraint
automaton that results from hiding the node C in automaton
A is ∃C [A] = (Q, N\{C}, →C, q0, M) and the transition
relation −→C is deﬁned as follows:
p
N,g
−−→ q, N ′ = N\{C}, g′ = ∃C [g]
p
N ′,g′
−−−→C q
, where
∃C [g] =
_
d∈D
g [d (C) /d] .
IV. CONNECTOR COLORING
The connector coloring semantics [8] denotes the exis-
tence or absence of data-ﬂow through the primitive ends by
marking them with different colors. Let Colors be the set
of colors. A set of two colors, Colors = {—, - -}, where —
denotes an occurrence and - - represents an absence of data-
ﬂow is adequate to express the formal semantics of many
Reo networks. However, this two-color set cannot express
the semantics of some Reo networks.
A traditional example of such a network is when the
sink end of a LossySync channel connects to an empty
FIFO1 channel; in this case, the semantics of this network
according to the two-color set includes the case where the
LossySync loses its incoming data item, while the FIFO1
channel is empty. This is an unacceptable behavior for a so-
called context sensitive LossySync channel: it must lose its
incoming data only if its sink end cannot dispense it. In the
sequel, when we refer to a LossySync we mean its context
sensitive version.
The three coloring semantics, Colors = {–, ◁, ▷}, ad-
dresses this problem by propagating negative information
regarding the absence of data-ﬂow: it replaces - - with ◁
and ▷ meaning that the associated primitive end, respectively,
provides or requires a reason for no-ﬂow. Considering that
no-ﬂow can occur only when at least one of the involved
primitive ends provides a reason for it, and that an empty
FIFO1 cannot provide a reason for no-ﬂow on its source
end, the invalid behavior described above does not arise in
the three coloring semantics.
Deﬁnition 4.1 (Coloring): A coloring l : P → Colors is
a total function from the primitive ends to a set of colors.
We refer to the global set of colorings as L.
Deﬁnition 4.2 (Coloring Composition): The composition
of colorings l1 and l2, denoted l1 • l2, is deﬁned as:
l1 • l2 = {c1 ∪ c2|c1 ∈ l1, c2 ∈ l2, p1 ∈ dom(c1),
p2 ∈ dom(c2), p1 and p2 are the source and sink
ends of a node n, ¬(c1(p1) = ◁ ∧ c2(P2) = ▷)}
Deﬁnition 4.3 (Next function): The next function η
:
L → 2L maps a coloring to a set of colorings, which can
succeed it.
Deﬁnition 4.4 (Coloring Semantics): A coloring seman-
tics of a Reo network is a tuple CC = ⟨P, 2L, l0, η⟩, where:
• P is the set of primitive ends,
• l0 ∈ L is the initial set of possible colorings,
• 2L is a set of colorings,
• η is a next function that maps a coloring to a set of
colorings.
V. REO CONSTRAINT SATISFACTION PROBLEM
In Section II-A, we presented an overview of the various
behavioral dimensions of a Reo network. We extend the
constraint-based framework in [9] to incorporate all behav-
ioral dimensions addressed by various semantic models for
Reo. In our framework, we denote each of these elements
by variables over their proper domains. We relate these
variables to each other and restrict possible values they can
assume using constraints whose solutions give the under-
lying formal semantics of the network. In the sequel, we
deal only with networks whose semantics can be expressed
in CASM or CC. However, we are currently extending our
framework to also support timing and priority.
Let N = N src ∪ N mix ∪ N snk be the global set of
nodes, M the global set of state memory variables, and D
the global set of numerical data values. The set of primitive
ends P consists of all primitive ends p derived from N by
marking its elements with superscripts c and k, according
to the following grammar:
p ::= rc | sk
where r ∈ N src ∪ N mix and s ∈ N snk ∪ N mix. Observe
that the primitive ends nc and nk connect on the common
node n.
Let p ∈ P, n ∈ N and m ∈ M be a primitive end, a node,
and a state memory variable, respectively. A free variable v
that occurs in the constraints encoding the behavior of a Reo
network has one of the following forms:
• ˜n ranges over {⊤, ⊥} to show presence or absence of
ﬂow on the node n.
• ˆn ranges over D to represent the data value passing
through the node n.
• ˚
m, ˚
m′ range over {⊤, ⊥} to denote whether or not the
state memory variable m is deﬁned in, respectively, the
source and the target states of the transition to which
the encoded guard belongs.
• ˆm, ˆm′ range over D to represent the values of the state
memory variable m in, respectively, the source and
the target states of the transition to which the encoded
guard belongs.
• −→p ranges over {⊤, ⊥} to state that the reason for
lack of data-ﬂow through the primitive end p originates
534
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

from, respectively, the primitive to which p belongs or
the context (of this primitive).
Note that not all of the introduced variables are required
for encoding the behavior of every Reo network. In presence
of context dependent primitives like LossySync or in priority-
sensitive networks, constraints include variables of the form
−→p . For the stateful elements such as FIFO1, variables like
˚
m, ˚
m′, ˆm, and ˆm′ appear in the constraints.
Observe that the interpretation of some of the mentioned
variables depends on the values of other variables. Referring
to the variable −→p makes sense only if ˜n = ⊥, where p = nc
or p = nk (i.e., the primitive end p belongs to the node n);
and ˆn, ˆm and ˆm′ make sense only if ˜n = ⊤, ˚
m = ⊤ and
˚
m′ = ⊤, respectively.
The
grammar
for
a
constraint
Ψ
encoding
the
behavior
of
a
Reo
network
is
as
follows:
t
::=
ˆn | ˆm | ˆm′ | d | t ⊛ d
(terms)
a
::=
˜n | −→p | ˚
m | ˚
m′ | t = t | t < t
(atoms)
Ψ
::=
a | ¬Ψ | Ψ ∧ Ψ
(formulae)
where d ∈ D is a constant, ⊛ ∈ {+, −, ∗, /, %, ˆ}, and p is
either of the form nc or nk.
Deﬁnition 5.1 (Reo Constraint Satisfaction Problem):
A Reo Constraint Satisfaction Problem (RCSP) is a tuple
⟨P, M, M0, V, C⟩, where:
• P is a ﬁnite set of primitive ends.
• M is a ﬁnite set of state memory variables.
• M0 ⊆ M is a set of state memory variables that deﬁne
the initial conﬁguration of a Reo network.
• V is a set of variables v deﬁned by the grammar
v ::= ˜n | −→p | ˚
m | ˚
m′ | ˆn | ˆm | ˆm′
for n ∈ N, p ∈ P, and m ∈ M. The values that the
variables of the forms ˆn, ˆm, and ˆm′ can assume are
subsets of D, and the other variables are Boolean, with
values in {⊤, ⊥}.
• C = {C1, C2, ..., Cm} is a ﬁnite set of constraints,
where each Ci is a constraint given by the grammar
Ψ involving a subset of variables Vi ⊆ V.
Example 5.1: The
RCSP
of
a
Sync
channel
with
the
source
end
a
and
the
sink
end
b
is
⟨{a, b}, ∅, ∅, {˜a,˜b, ˆa,ˆb}, ˜a ⇔ ˜b ∧ ˜a ⇒ (ˆa = ˆb)⟩. The
solutions for this constraint problem give the behavior of
the Sync channel as the channel allows data-ﬂow on its
source end iff its sink end can dispense it simultaneously
(which agrees with the semantics of this channel as deﬁned
in other formal models of Reo). In case of data-ﬂow, the
values of the data items passing through the ends of this
channel are equal.
We obtain the constraints corresponding to a Reo network
by composing the RCSPs of its constituents as deﬁned
below.
Deﬁnition 5.2 (Composition): The composition of two
RCSPs
ρ1
=
⟨P1, M1, M0,1, V1, C1⟩
and
ρ2
=
⟨P2, M2, M0,2, V2, C2⟩ is deﬁned as follows:
ρ1⊙ρ2 = ⟨P1∪P2, M1∪M2, M0,1∪M0,2, V1∪V2, C1∧C1⟩
However, connecting two Reo networks must not in-
troduce incorrect data-ﬂow possibilities. This is done by
enforcing a restriction on the possible solutions through the
following axiom:
Axiom 1 (Mixed node axiom): When two Reo networks
connect on the common node x, where xc is a source end in
one network and xk is a sink end in the other, the following
constraint must hold:
¬˜x ⇔ (−→
xc ∨
−→
xk)
The mixed node axiom, which applies to all mixed nodes in
a network, states that a node x cannot produce the reason
for no-ﬂow all by itself.
A. Encoding Reo Elements in RCSPs
Table III summarizes the constraint encodings associated
with commonly used Reo elements. If a Reo network does
not contain any context dependent channel, the variables
encoding the context dependency can be ignored in its RCSP.
Table IV shows the encoding of Reo elements from Table
III where the context variables are removed. Note that in
these tables, a and b denote the source and the sink ends of
a primitive, respectively, and that dom refers to the domain
of the given function or predicate. In the case of elements
with more than one source or sink ends, we use indices.
The intuition behind these constraints is that their solu-
tions reﬂect the semantic model of each element as given
by CASM and CC.
Example 5.2: Figure 1 shows a Reo network that consists
of a transformer channel with the function 3 ∗ ˆa, whose
domain is the set of numbers Number and a ﬁlter channel
with the condition ˆb%2 = 0 and domain Number.
a
3 ∗ ˆa
b
c
ˆb%2 = 0
Figure 1: A Data-Aware Reo Network
Since none of the Reo primitives in Figure 1 is context
dependent, we use the constraints corresponding to the
primitives in this network as deﬁned in Table IV.
Equation 1 states that ﬂow occurs on the source end of the
transformer channel iff it occurs on its sink end. In addition,
ﬂow can exist only if the data item that enters the source
end of the channel is a number. In this case, the data item
written on the sink end is three times the value of the source
data item.
Equation 2 expresses that ﬂow on the source end of the
ﬁlter channel leads to ﬂow on its sink end, iff the data
item belongs to the channel’s accepting pattern (which is
535
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Table III: Context Dependent Encoding of Reo Primitives
(Extending [9])
Channel
Constraints
ψSync(a, b) : ˜a ⇔ ˜b ∧ ˜a ⇒ (ˆa = ˆb) ∧ ¬(−
→
ac ∧
−
→
bk)
ψSyncDrain(a1, a2) : ˜a1 ⇔ ˜a2 ∧ ¬(−
→
ac
1 ∧ −
→
ac
2)
ψAsyncDrain(a1, a2) : ˜a1 ⇒ (¬˜a2 ∧ −
→
ac
2) ∧ ˜a2 ⇒
(¬˜a1 ∧ −
→
ac
1)
ψLossySync(a, b) : ˜b ⇒ ˜a ∧ ˜b ⇒ (ˆa = ˆb) ∧ ¬−
→
ac ∧
¬˜a ⇒
−
→
bk
ψMerger(a0..i, b) : ˜ai ⇔ ˜b ∧ ˜ai ⇒ ( ˆai = ˆb) ∧ ¬˜b ⇒
((¬
−
→
bk V
i
−
→
ac
i ) ∨ (
−
→
bk ∧ ¬−
→
ac
i
V
j,j!=i
−→
ak
j ))
ψReplicator(a, b0..i) : ˜a ⇔ V
i ˜bi ∧ (˜a ⇒ V
i(ˆbi =
ˆa)) ∧ ¬˜a ⇒ ((¬−
→
ac V
i
−
→
bk
i ) ∨ (¬
−
→
bk
i
V
j,j̸=i
−
→
bk
j ∧ −
→
ac))
ψRouter(a, b0..i) : ˜a ⇔ (W
i ˜bi) V
j,j̸=i ¬(˜bi ∧ ˜bj) ∧
˜bi ⇒ ( ˆbi = ˆa) ∧ ˜a ⇔ (¬−
→
ac ∨ ¬(W
i
−
→
bk
i ))
ψF IF O1(a, b, m) : ˜a ⇒ (¬˚
m∧˚
m′∧( ˆm′ = ˆa))∧˜b ⇒
(˚
m∧¬˚
m′∧( ˆm = ˆb))∧(¬˜a∧¬˜b) ⇒ (˚
m ⇔ ˚
m′∧˚
m ⇒
( ˆm = ˆm′)) ∧ ¬˚
m ⇒
−
→
bk ∧ ˚
m ⇒ −
→
ac
P
ψF ilter(a, b, P) = ˜b ⇒ (˜a ∧ ˆa ∈ dom(P) ∧ P(ˆa)) ∧
˜b ⇒ (ˆa = ˆb) ∧ (¬˜a ⇒ (¬−
→
ac ⇔
−
→
bk)) ∧ (˜a ∧ ¬˜b ⇒
−
→
bk)
f
ψT ransformer(a, b, f) = ˜b ⇒ (˜a ∧ ˆa ∈ dom(f)) ∧
˜b ⇒ (ˆb = f(ˆa)) ∧ ¬(−
→
ac ∧
−
→
bk)
Table IV: Encoding Reo Primitives (Extending [9])
Channel
Constraints
ψSync(a, b) : ˜a ⇔ ˜b ∧ ˜a ⇒ (ˆa = ˆb)
ψSyncDrain(a1, a2) : ˜a1 ⇔ ˜a2
ψAsyncDrain(a1, a2) : ¬(˜a1 ∧ ˜a2)
ψLossySync : ˜b ⇒ ˜a ∧ ˜b ⇒ (ˆa = ˆb)
ψMerger(a0..i, b) : ˜b ⇔ (W
i ˜ai) V
j,j̸=i ¬(˜ai ∧ ˜aj) ∧
˜ai ⇒ (ˆai = ˆb)
ψReplicator(a, b0..i) : ˜a ⇔ (V
i ˜bi) ∧ ˜a ⇒ (V
i(ˆbi =
ˆa))
ψRouter(a, b0..i) : ˜a ⇔ (W
i ˜bi) V
j,j̸=i ¬(˜bi ∧ ˜bj) ∧
˜bi ⇒ (ˆbi = ˆa)
ψF IF O1(a, b, m) : ˜a ⇒ (¬˚
m∧˚
m′∧( ˆm′ = ˜a))∧˜b ⇒
(˚
m∧¬˚
m′∧( ˆm = ˜b))∧(¬˜a∧¬˜b) ⇒ (˚
m ⇔ ˚
m′∧˚
m ⇒
( ˆm = ˆm))
P
ψF ilter(a, b, P) = ˜b ⇒ (˜a ∧ ˆb ∈ dom(P) ∧ P(ˆa) ∧
(ˆa = ˆb))
f
ψT ransformer(a, b, f) = ˜b ⇒ (˜a ∧ ˆb ∈ dom(f)) ∧
˜b ⇒ (ˆb = f(ˆa))
ψT ransformer(a, b, 3∗ˆa) = ˜a ⇔ ˜b∧˜a ⇒ (ˆa ∈ Number∧ˆb = 3∗ˆa)) (1)
ψF ilter(b, c,ˆb%2 = 0) = ˜c ⇒ (˜b ∧ ˆb ∈ Number ∧ (ˆb%2 = 0))
(2)
ˆb%2 = 0). In this case, the value of data items passing
through the ends are equal. No ﬂow through the sink end
c is either due to no ﬂow on b or that the incoming data
item does not satisfy the accepting pattern. As mentioned,
the conjunction of these constraints (subject to Axiom 1,
which trivially holds in this case) encodes the behavior of
the given Reo network.
B. Solving RCSPs
In this section, we formalize the solutions of RCSPs and
show how to obtain them.
Deﬁnition 5.3 (Solution): A solution S for a constraint C
is a function S : V → 2D ∪ {⊤, ⊥} such that for all distinct
vi ∈ V, 1 ≤ i ≤ n = |V|, we have zi ∈ S(vi) implies
C [v1, v2, . . . , vn \ z1, z2, . . . , zn] is true.
Since Reo Constraint Satisfaction Problems (RCSPs) have
predicates with free variables of types Boolean ({⊤, ⊥}) and
data (D), a SAT-solver or a numeric constraint solver cannot
solve them alone. Satisﬁability Modulo Theories (SMT) [19]
solvers ﬁnd solutions for propositional satisﬁability prob-
lems where propositions are either Boolean or constraints in
a speciﬁc theory. However, SMT-solvers are not applicable
in our case either, because unlike SAT-solvers they ﬁnd only
an instance of a solution as opposed to the complete set of
answers. Another drawback of most SAT- and SMT-solvers
is that they work only on quantiﬁer-free formulae, while we
use existential quantiﬁes to implement the hiding operator
of Constraint Automata (see Section VI).
To generate the CASM corresponding to a given Reo
network, we need all solutions and thus resort to a hybrid
approach that uses both SAT-solvers and Computer Algebra
Systems (CASs), namely, REDUCE [20], which is a system
for general algebraic computations. First, we form a pure
Boolean constraint system by substituting data dependent
constraints with new Boolean variables. We ﬁnd all solu-
tions for the new constraints using a SAT-solver. Then, by
substituting each such solution into the original constraints,
we obtain a data dependent constraint satisfaction problem
that a CAS can solve symbolically. From these solutions, we
extract a CASM corresponding to the Reo network encoded
by the original set of constraints. Our approach avoids state
explosion by treating data constraints symbolically. In the
following, we elaborate on our approach.
In an RCSP ⟨P, M, M0, V, C⟩, let VB and VD be the sets
of free Boolean and free data variables of C, respectively,
where V = VB ∪ VD, and let AD be the set of atomic
predicates of C containing data variables. The following is
our procedure for solving C.
1) We obtain CB from C by replacing every occurrence
of x ∈ AD with a unique new Boolean variable
y /∈ V. For example, for C = (˜c ⇒ ˜b) ∧ (˜c ⇒ (ˆb ∈
Number ⇒ ˆb%2 = 0)) in Example 5.2, we obtain
CB as (˜c ⇒ ˜b) ∧ (˜c ⇒ (y1 ⇒ y2)) where y1 and y2
replace ˆb ∈ Number and ˆb%2 = 0, respectively.
2) An off-the-shelf SAT-solver can ﬁnd the set of solu-
tions SB for CB. We deﬁne the ﬁnite set of constraints
C [SB] = {C [v1, v2, . . . , vn \ z1, z2, . . . zn] | for all
distinct vi ∈ VB, 1 ≤ i ≤ n = |VB|, zi ∈ S (vi) , S ∈
SB}.
3) Every CD ∈ C [SB] is a numerical constraint satis-
faction problem, which we (symbolically) solve using
536
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

a Computer Algebra System. Every solution to each
CD along with the SAT solution S ∈ SB that produced
CD ∈ C [SB] in the previous step, constitute a solution
to the RCSP.
Using the presented technique, we obtain the solutions for
the RCSP corresponding to Examples 5.2 as follows:
1)
⟨{˜a = ⊥, ˜b = ⊥, ˜c = ⊥}, ⊤⟩,
2)
⟨{˜a = ⊤, ˜b = ⊥, ˜c = ⊥}, ˆa ̸∈ Number⟩,
3)
⟨{˜a = ⊤, ˜b = ⊤, ˜c = ⊥}, ˆa ∈ Number ∧ ˆb = 3 ∗ ˆa ∧ ˆb%2 ̸= 0⟩,
4)
⟨{˜a = ⊤, ˜b = ⊤, ˜c = ⊤}, ˆa ∈ Number ∧ ˆb = 3 ∗ ˆa ∧ ˆb%2 =
0 ∧ ˆb = ˆc⟩.
Example 5.3: Figure 2 depicts a Reo network that con-
sists of a LossySync channel and a FIFO1 channel connect-
ing on the node b.
a
b
c
Figure 2: A Context Sensitive Reo Network
Since the Reo network in Figure 2 contains a LossySync that
is a context dependent channel, we use the context-aware
RCSP encoding from Table III:
ψLossySync(a, b) = ˜b ⇒ (˜a ∧ (ˆa = ˆb)) ∧ ¬
−
→
ac ∧ ¬˜a ⇒
−
→
bk.
(3)
ψF IF O1(b, c, m) = ˜b ⇒ (¬˚
m ∧ ˚
m′ ∧ ( ˆm′ = ˆb)) ∧ ˜c ⇒
(˚
m ∧ ¬˚
m′ ∧ ( ˆm = ˆc)) ∧ (¬˜b ∧ ¬˜c) ⇒ ((˚
m ⇔ ˚
m′) ∧ ˚
m ⇒
( ˆm = ˆm′)) ∧ ¬˚
m ⇒ −
→
cc ∧ ˚
m ⇒
−
→
bk.
(4)
Equation 3 states that ﬂow on the sink end of the LossySync
is due to ﬂow on its source end. If there is ﬂow on the
sink end of the LossySync, the data items exchanged at
the source and the sink ends are the same. However, it is
possible that the source end has ﬂow, but the sink end does
not. In this case, the reason for no ﬂow comes from the
environment with which the sink end communicates. The
third possible behavior of the channel is that there is no
ﬂow on the source end due to the environment, in which
case the channel provides a reason for no ﬂow on its sink
end.
Equation 4 expresses the behavior of the FIFO1 channel
as follows: The ﬂow on the source end of the channel states
that the value of the variable representing the state memory
(of the current state) is undeﬁned. The ﬂow on the source
end deﬁnes the state memory variable for the next state to
contain the value of the incoming data item. On the other
hand, ﬂow on the sink end means that the value of the state
memory variable is deﬁned. The data item leaving the sink
end is equivalent to the buffer’s data item. In addition, the
value of the state memory variable becomes undeﬁned in
the next state. If there is no ﬂow on the ends, the variables
related to the states stay the same. Being empty, the FIFO1
channel provides a reason for no ﬂow on its sink end, while
being full does so on the source end of the channel.
The solutions for the RCSP of Example 5.3, (where for
brevity, we omit the values of the variables representing the
context, such as −→
bc) are as follows:
{}, true
{a, b, c},
ˆa
∈
Number∧
ˆb = 3 ∗ ˆa ∧
ˆb = ˆc ∧
ˆb%2 = 0
{a, b},
ˆa
∈
Number∧
ˆb = 3 ∗ ˆa ∧
ˆb%2 ̸= 2
{a}, ˆa ̸∈
Number
(a)
m
start
{}, true
{a, b, c}, ˆa = ˆb ∧ ˆb = ˆc ∧ ˆm′ = ˆc
{a}, true
{}, true
{a, d}, ˆm = ˆd
{d}, ˆm = ˆd
(b)
Figure 3: CASMs Generated for Examples 5.2 (a) and 5.3
(b)
1)
⟨{˜a = ⊥, ˜b = ⊥, ˜c = ⊥, ˚
m = ⊥, ˚
m′ = ⊥}, ⊤⟩,
2)
⟨{˜a = ⊤, ˜b = ⊤, ˜c = ⊥, ˚
m = ⊥, ˚
m′ = ⊤}, ˆa = ˆb ∧ ˆm′ = ˆb⟩,
3)
⟨{˜a = ⊤, ˜b = ⊥, ˜c = ⊥, ˚
m = ⊤, ˚
m′ = ⊤}, ˆm = ˆm′⟩,
4)
⟨{˜a = ⊥, ˜b = ⊥, ˜c = ⊥, ˚
m = ⊤, ˚
m′ = ⊤}, ˆm = ˆm′⟩,
5)
⟨{˜a = ⊤, ˜b = ⊥, ˜c = ⊥, ˚
m = ⊤, ˚
m′ = ⊥}, ˆm = ˆc⟩,
6)
⟨{˜a = ⊥, ˜b = ⊥, ˜c = ⊤, ˚
m = ⊤, ˚
m′ = ⊥}, ˆm = ˆc⟩.
C. CASM Construction
In order to construct the CASM from the set of solutions
S for an RCSP ⟨P, M, M0, V, C⟩, we ﬁrst deﬁne
• N = {n | nc ∈ P ∨ nk ∈ P}
and then map each solution ⟨s, sd⟩ ∈ S into a transition
t : q
N,g
−−→ p as follows:
• q = ⟨{m | m ∈ M, s (˚
m) = ⊤}⟩,
• p = ⟨{m | m ∈ M, s (˚
m′) = ⊤}⟩,
• N = {n | n ∈ N, s (˜n) = ⊤},
• The data constraint g is (a syntactic variant of) sd.
We obtain the CASM A = (Q, N, →, q0, M) from the set
−→ of all transitions generated above, where:
• Q = {q | q
N,g
−−→ p ∨ p
N,g
−−→ q},
• q0 = ⟨{m | m ∈ M0, s(˚
m) = ⊤}⟩,
• M is the same M as in the RCSP.
Applying the above procedure to the solutions of RCSPs
constraints generates their corresponding CASMs. For in-
stance, the ﬁrst solution for the constraints in Example 5.2
generates the transition q
∅,true
−−−−→ q, where q is the only state
of the CASM, which has no state memory variable. This is
so because the set of variables of the form ˚
m is empty. Also,
the transition has no synchronizing port, because the value
of every one of variables ˜a,˜b and ˜c is ⊥. Figures 3a and 3b
show the CASMs derived from the RCSPs in Examples 5.2
and 5.3.
Our approach deals with data in a symbolic fashion, where
we partition the global set of data values to equivalence
classes toward which a Reo network behaves differently.
537
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

This is in contrast with the traditional way of dealing with
data in the formal semantics of Reo (and other models),
where they consider a different state for each possible value
that can be stored in buffers and a distinct transition for each
data value passing through the ports. Our symbolic approach
allows working with an inﬁnite data domain. In addition,
rather than implementing the highly time- and memory-
demanding custom-made algorithms to generate Reo formal
semantics, we use the efﬁcient SAT-solvers and computer
algebra systems to solve constraints whose solutions are
equivalent to these models. An experimental study on the
efﬁciency of using SAT-solvers to generate Reo formal
semantics is reported in [9].
VI. HIDING
We use hiding to abstract from internal transitions. The
author in [9] proposes applying the existential quantiﬁer to
the constraints encoding of the behavior of a network to
abstract from internal ports and their corresponding data
variables. Similarly, we use existential quantiﬁers such as
∃˜e, ˆe, −→e : C, where C is the RCSP of a Reo network and
e is an internal node to hide.
Although several algorithms exist for the problem of
quantiﬁer elimination in Boolean algebra and ﬁrst order
logic [21], [22] and [23], we are not aware of any working
tool that does quantiﬁer elimination on Boolean algebraic
formulae. Therefore, our tool implements the hiding operator
as deﬁned for CASM.
Hiding the internal nodes on some transitions can make
the set of their synchronized nodes empty. Here, we refer to
such a transition as an empty transition, if the free variables
of its guard are merely state memory variables. Under some
circumstances, we can merge the source and the target states
of empty transitions. Let q and p be two states in a CASM
such that q
∅,g
−−→ p. The following are the conditions under
which the state p can merge into the sate q:
1) The states q and p have the same number of state
memory variables.
2) The guard g consists of the conjunction of the predi-
cates of the form of x = y′, for x, y ∈ M. This way,
g deﬁnes a correspondence relation between the state
memory variables of the state q and those of the state
p.
3) For each transition q
N,g′
−−−→ r where r /∈ {p, q}, there
is a transition p
N,g′′
−−−→ r such that g′ ⇔ g′′
g , where
g′′
g is obtained from g by replacing all occurrences of
the next state memory variable y′ with the next state
memory variable x′, if g contains x = y′ for state
memory variables x, y ∈ M.
4) For each transition r
N,g′
−−−→ p where r /∈ {p, q}, there
is a transition r
N,g′′
−−−→ q such that g′′ ⇔ g′
g, where g′
g
is derived from g by substituting all occurrences of the
a
b
c
Figure 4: Two FIFO1s Forming FIFO2
start
m
n
m,
n
{}, true
{}, true
{}, true
{}, true
{a},
m′ = ˆa
{b},
ˆb = m ∧
n′ = ˆb
{a},
m′ = ˆa∧
n′ = n
{c},
m′ = m
∧ ˆc = n
{c},
ˆc = n
{a, c},
m′ = ˆa
∧ ˆc = n
(a) CASM of Example 6.1
start
m
n
m,
n
{}, true
{}, true
{}, true
{}, true
{a},
m′ = ˆa
{},
n′ = m
{a},
m′ = ˆa∧
n′ = n
{c},
m′ = m
∧ ˆc = n
{c},
ˆc = n
{a, c},
m′ = ˆa ∧
ˆc = n
(b) Hiding Internal Ports
start
m
m,
n
{},
true
{},
true
{},
true
{a},
m′ = ˆa
{a},
m′ = ˆa ∧
n′ = m
{c},
m′ = m∧
ˆc = n
{c},
ˆc = m
{a, c},
m′ = ˆa ∧
ˆc = m
(c) Merging the States
Figure 5: Hiding the Empty Transition and Merging Its
Source and Target States for the CASM of FIFO2 in Figure
4
state memory variable x in g with the state memory
variable x, if g contains x = y′ for state memory
variables x, y ∈ M.
Provided that the above conditions hold, the state p merges
into the state q as follows:
1) We eliminate the transition q
∅,g
−−→ p.
2) We remove the state p after substituting y, y′, and p
with x, x′, and q in all transitions. Observe that such
substitutions convert the non-eliminated transitions
between the states q and p into loops over the state q.
Example 6.1: Figure 4 shows a FIFO2 derived from
composing two FIFO1s. The CASM corresponding to the
FIFO2 is in Figure 5a. Figure 5b depicts the CASM resulting
from hiding the mixed node b. Figure 5c presents the result
of eliminating the empty transitions.
VII. CONCLUSIONS AND FUTURE WORK
In this paper, we have presented a constraint-based frame-
work that encodes the semantics of Reo networks as con-
straint satisfaction problems whose predicates are either
Boolean propositions or numerical constraints. We presented
a hybrid approach to ﬁnd the solutions for these problems.
An advantage of our approach is that it treats data constraints
symbolically to mitigate the state explosion problem. From
this solution, we construct the semantic model corresponding
538
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

to a Reo network in the form of constraint automata with
state memory. Our framework supports product and hiding
operations on constraint automata. We have implemented
and integrated our approach as a tool in the ECT. As part of
our ongoing work, we are using this framework to encode
other aspects of the semantics of Reo, namely, priorities
and timed behavior. In this way, our work will be the most
expressive framework that exists to analyze Reo networks.
Furthermore, we will prove soundness and completeness
of the RCSP encoding of Reo networks along with its
compositionality.
REFERENCES
[1] M.
Bell,
“Introduction
to
Service-Oriented
Modeling,”
Service-Oriented Modeling: Service Analysis, Design, and
Architecture, p. 3, 2008.
[2] R. Pugliese and F. Tiezzi, “A Calculus for Orchestration of
Web Services,” J. Applied Logic, vol. 10, no. 1, pp. 2–31,
2012.
[3] D. Kitchin, W. R. Cook, and J. Misra, “A Language for
Task Orchestration and Its Semantic Properties,” in CONCUR,
vol. 4137 of Lecture Notes in Computer Science, pp. 477–491,
Springer, 2006.
[4] F. Arbab, “Reo: a Channel-Based Coordination Model for
Component Composition,” Mathematical Structures in Com-
puter Science, vol. 14, pp. 329–366, 2004.
[5] F. Arbab, N. Kokash, and S. Meng, “Towards Using Reo for
Compliance-Aware Business Process Modeling,” in ISoLA,
pp. 108–123, 2008.
[6] B. Changizi, N. Kokash, and F. Arbab, “A Uniﬁed Toolset for
Business Process Model Formalization,” in 7th International
Workshop on Formal Engineering approaches to Software
Components and Architectures (FESCA 2010), pp. 147–156,
ENTCS, 2010.
[7] S.-S. T. Jongmans and F. Arbab, “Overview of Thirty Se-
mantic Formalisms for Reo,” Scientiﬁc Annals of Computer
Science, vol. 22, pp. 201–251, 2012.
[8] D. Clarke, D. Costa, and F. Arbab, “Connector Colouring
I: Synchronisation and Context Dependency,” Science of
Computer Programming, vol. 66, no. 3, pp. 205–225, 2007.
[9] J. Proenc¸a, Synchronous Coordination of Distributed Com-
ponents. PhD thesis, Institue for Prgramming research and
Algorithms, 2011.
[10] C. Baier, M. Sirjani, F. Arbab, and J. J. M. M. Rutten,
“Modeling Component Connectors in Reo by Constraint
Automata,” Science of Computer Programming, vol. 61, no. 2,
pp. 75–113, 2006.
[11] B. Pourvatan, M. Sirjani, H. Hojjat, and F. Arbab, “Symbolic
Execution of Reo Circuits using Constraint Automata,” Sci.
Comput. Program., vol. 77, no. 7-8, pp. 848–869, 2012.
[12] M. M. Bonsangue, D. Clarke, and A. Silva, “Automata
for Context-Dependent Connectors,” in COORDINATION
(J. Field and V. T. Vasconcelos, eds.), vol. 5521 of Lecture
Notes in Computer Science, pp. 184–203, Springer, 2009.
[13] F. Arbab, C. Baier, F. D. Boer, and J. Rutten, “Models
and Temporal Logics for Timed Component Connectors,” in
2nd International Conference on Software Engineering and
Formal Methods (SEFM 2004), pp. 198–207, IEEE Computer
Society, 2004.
[14] S. Kemper, “SAT-based Veriﬁcation for Timed Component
Connectors,” Electr. Notes Theor. Comput. Sci., vol. 255,
pp. 103–118, 2009.
[15] F. Arbab and C. Baier, “Priority in Reo and Constraint Au-
tomata,” tech. rep., Centrum voor Wiskunde en Informatica.
In preparation.
[16] J. F. Groote, A. Mathijssen, M. Reniers, Y. Usenko, and M. V.
Weerdenburg, “The Formal Speciﬁcation Language mCRL2,”
in Methods for Modelling Software Systems (MMOSS 2006),
vol. 06351 of Dagstuhl Seminar Proceedings, IBFI, 2006.
[17] N. Kokash, C. Krause, and E. de Vink, “Reo + mCRL2: A
Framework for Model-checking Dataﬂow in Service Compo-
sitions,” Formal Aspects of Computing, 2011.
[18] F. Arbab, C. Koehler, Z. Maraikar, Y.-J. Moon, and J. Proenca,
“Modeling, Testing and Executing Reo Connectors with the
Eclipse Coordination Tools,” in 5th International Workshop
on Formal Aspects of Component Software (FACS 2008),
vol. 8, ENTCS, 2008.
[19] C. W. Barrett, R. Sebastiani, S. A. Seshia, and C. Tinelli,
“Satisﬁability Modulo Theories,” Handbook of Satisﬁability,
vol. 4, 2009.
[20] G. Rayna, REDUCE: Software for Algebraic Computation.
New York, NY, USA: Springer-Verlag New York, Inc., 1987.
[21] L. Bordeaux and L. Zhang, “A Solver for Quantiﬁed Boolean
and Linear Constraints,” in Proceedings of the 2007 ACM
symposium on Applied computing, SAC ’07, (New York, NY,
USA), pp. 321–325, ACM, 2007.
[22] A. Ayari and D. Basin, “QUBOS: Deciding Quantiﬁed
Boolean Logic using Propositional Satisﬁability Solvers,” in
Formal Methods in Computer-Aided Design, pp. 187–201,
Springer, 2002.
[23] J. H. Davenport, “Computer Algebra Applied to Itself,” J.
Symb. Comput., vol. 6, pp. 127–132, August 1988.
539
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

