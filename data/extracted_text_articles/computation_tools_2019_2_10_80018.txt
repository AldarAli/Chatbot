A Sequent Based On-the-ﬂy Procedure to Get
Hilbert Proofs in Classical Propositional Logic
Mauro Ferrari
DiSTA, Univ. degli Studi dell’Insubria,
Via Mazzini, 5, 21100, Varese, Italy
mauro.ferrari@uninsubria.it
Camillo Fiorentini
DI, Univ. degli Studi di Milano,
Via Celoria 18, 20133 Milano, Italy
fiorentini@di.unimi.it
Guido Fiorino
DISCO, Univ. degli Studi di Milano-Bicocca,
Viale Sarca 336, 20126 Milano, Italy
guido.fiorino@unimib.it
Abstract—In this paper, we present a preliminary result on the
generation of Hilbert proofs for classical propositional logic. This
is part of our ongoing research on the comparison of proof-search
in different proof-systems. Exploiting the notion of evaluation
function, we deﬁne a fully deterministic terminating decision
procedure that returns either a derivation in the Hilbert calculus
of the given goal or a counter model witnessing its unprovability.
Keywords–Automated Theorem Proving; Hilbert calculi.
I.
INTRODUCTION
It is well-known [1] that the standard formalizations of
classical and intuitionistic logic based on Hilbert calculi,
sequent calculi and natural deduction are equivalent. In spite
of this, proof-search has been mainly developed around the
notion of sequent calculi, almost neglecting the cases of natural
deduction and Hilbert calculi. This is primarily motivated by
the fact that the latters lack the structural properties of sequent
calculi, like cut-elimination and subformula property, that can
be immediately exploited to deﬁne a goal-oriented proof-
search procedure (see, e.g., [2]-[3] for an accurate discussion).
In [4][5] it is shown that in the case of natural deduction it is
possible to design proof-search procedures with structural and
complexity properties comparable with those based on sequent
calculi. This is obtained by imposing a strict discipline on
the backward application of the rules and by exploiting some
internal features of the goal via evaluation functions. In this
paper, we begin an investigation concerning Hilbert calculi
with the aim to apply in this context the ideas developed in
the above cited papers. We take Classical Propositional Logic
(CPL) as the entry point of our investigation. We consider
the Hilbert system Hc for CPL as deﬁned in [6] and we
introduce a proof-search strategy for it. The procedure builds
Hilbert proofs during the proof-search phase. Since the proof-
search phase is based on a strategy for a sequent calculus, the
procedure can be seen as building Hilbert proofs in one-pass,
that is, by translating on-the-ﬂy sequent proofs. The procedure
relies on a sequent calculus with at most one formula on the
right, thus to get termination and completeness we need to
introduce the machinery of evaluations.
As regards related works, as far as we know, the only two
papers addressing this issue are [7][8], and both are scarcely
related with our approach. The former deals with backward
application of modus ponens, introducing metavariables to rep-
resents cut-formulas. In [8], an implementation of a prover for
CPL is presented, that relies on a semantic method exploiting
Kalmar completeness theorem.
The system Hc consists of some axioms and only one
rule, modus ponens (from A → B and A infer B). The main
problem in deﬁning a proof-search procedure for Hc is to
control the application of modus ponens. If we backward apply
modus ponens to prove a goal formula B, we have to guess a
cut-formula A, so that next goals are A and A → B. To avoid
considering useless cut-formulas, we adapt to the classical
case the notion of evaluation function introduced in [9] for
intuitionistic propositional logic. Essentially, an evaluation
function is a lightweight computational mechanism that drives
the backward application of the rules, only analyzing the
current goal of the proof search. The evaluation function for
Hc is introduced in Section III. The proof-search procedure
described in Section IV takes as input a goal G and a set
of assumptions Γ and returns either a deduction of G in Hc
from assumptions Γ or a classical model of Γ falsifying G. As
proved in Section IV the proof-search procedure is terminating
and it does not require backtracking.
II.
THE HILBERT CALCULUS Hc
We consider the propositional language L of CPL based
on a denumerable set of propositional variables Pv and the
connectives ∧, ∨, → and ¬. We write A ↔ B as a shorthand
for (A → B) ∧ (B → A). A literal is a formula of the form p
or ¬p with p ∈ Pv; the set of literals is denoted by Lit. The
size of a formula A, denoted by |A|, is the number of logical
symbols occurring in A. A model M is a subset of Pv; we
write M ⊨ A to denote that the formula A is valid in M,
according to the usual deﬁnition. Let Γ be a set of formulas;
M ⊨ Γ iff, for every A ∈ Γ, M ⊨ A. By Γ ⊨ A we mean that
A is a classical consequence of Γ, namely: for every model
M, M ⊨ Γ implies M ⊨ A.
We call Hc the Hilbert calculus for CPL introduced in [6].
Logical axioms of Hc are:
(Ax1)
A → (B → A)
(Ax2)
(A → B) → ((A → (B → C)) → (A → C))
(Ax3)
A → (B → (A ∧ B))
(Ax4a) (A ∧ B) → A
(Ax4b) (A ∧ B) → B
(Ax5a) A → (A ∨ B)
(Ax5b) B → (A ∨ B)
(Ax6)
(A → C) → ((B → C) → ((A ∨ B) → C))
(Ax7)
(A → B) → ((A → ¬B) → ¬A)
(Ax8)
¬¬A → A
The only rule of Hc is MP (Modus Ponens): from A → B
and A infer B.
10
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-709-2
COMPUTATION TOOLS 2019 : The Tenth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

Let Γ be a set of formulas and A a formula. A deduction
of A from assumptions Γ is a ﬁnite sequence of formulas
D = ⟨A1, . . . , An⟩ (possibly with repetitions) such that An =
A and, for every Ai in the sequence, one of the following
conditions holds:
(a) Ai ∈ Γ (namely, Ai is an assumption);
(b) Ai is an instance of a logical axiom;
(c) Ai is obtained by applying MP to Aj and Ak, with j < i
and k < i.
We denote with Fm(D) = {A1, . . . , An} the set of
formulas occurring in D. By D : Γ ⊢ A we mean that
D is a deduction of A from assumptions in Γ. Given two
sets of formulas A1, . . . , An and B1, . . . , Bm, we write D :
A1, . . . , An, B1, . . . , Bm ⊢ A instead of D : {A1, . . . , An} ∪
{B1, . . . , Bm} ⊢ A.
Given two deductions D1 : Γ1 ⊢ A1 and D2 : Γ2 ⊢ A2, we
denote by D1 ◦ D2 the deduction obtained by concatenating
the sequences D1 and D2. One can easily check that D1 ◦D2 :
Γ ⊢ A2, where Γ ⊆ Γ1 ∪ Γ2. Note that Γ can be a proper
subset of Γ1 ∪ Γ2, since some of assumptions in Γ2 could be
obtained by applying MP in D1 ◦ D2 (see the next example).
Example 1: Let us consider the derivations
D1 = ⟨p1, p1 → p2⟩
D2 = ⟨p2, p2 → (p2 ∨ q), p2 ∨ q⟩
We have D1 : p1, p1 → p2 ⊢ p1 → p2. In D2, the formula
p2 → (p2 ∨ q) is an instance of axiom (Ax5a) and p2 ∨ q
is obtained by applying MP to p2 → (p2 ∨ q) and p2, hence
D2 : p2 ⊢ p2 ∨ q. In the concatenation D1 ◦ D2 the formula
p2 can be obtained by applying MP to p1 → p2 and p1, hence
D1 ◦ D2 : p1, p1 → p2 ⊢ p2 ∨ q.
In the following proposition, we introduce some deduction
schemas we use later on.
Lemma 1: For all formulas A, B and C, the following
deductions can be constructed:
(i) DMP(A → B, A) : A → B, A ⊢ B;
(ii) D¬¬E(A) : ¬¬A ⊢ A;
(iii) DEF(A, B) : A, ¬A ⊢ B;
(iv) DEF→(A, B) : ¬A → B, ¬A → ¬B ⊢ A;
(v) DEF→¬(A, B) : A → B, A → ¬B ⊢ ¬A;
(vi) D∨E(A, B, C) : A → C, B → C, A ∨ B ⊢ C.
Proof: The following sequence of formulas proves
Point (vi):
(1)
A → C
Assumption
(2)
B → C
Assumption
(3)
A ∨ B
Assumption
(4)
(A → C) →
((B → C) → ((A ∨ B) → C))
(Ax6)
(5)
(B → C) → ((A ∨ B) → C)
MP (4) (1)
(6)
(A ∨ B) → C
MP (5) (2)
(7)
C
MP (6) (3)
A distinguishing feature of Hilbert calculi is that there are
no rules to close assumptions. Thus, to prove the Deduction
Lemma for Hc we have to rearrange a deduction D of
A, Γ ⊢ B to get a deduction of Γ ⊢ A → B. An analogous
issue holds for negation elimination and negation introduction.
The following lemma provides the schemas of derivation
transformations treating such cases:
Lemma 2 (Closing assumption lemma):
(i) Let D : A, Γ ⊢ B. Then, there exists a deduction
EDL(D, A) : Γ ⊢ A → B such that, for every C ∈
Fm(D), A → C ∈ Fm(EDL(D)).
(ii) Let D : ¬A, Γ ⊢ K such that ¬K ∈ Fm(D). Then, there
exists a deduction E¬E(D, ¬A) : Γ ⊢ A.
(iii) Let D : A, Γ ⊢ K such that ¬K ∈ Fm(D). Then, there
exists a deduction E¬I(D, A) : Γ ⊢ ¬A.
Proof: For Point (i) see the proof of the Deduction
Lemma in [6]. As for Point (ii), by Point (i) there exists a
deduction EDL(D, ¬A) : Γ ⊢ ¬A → K such that ¬A →
¬K
∈ Fm(EDL(D, ¬A)). Let us consider the derivation
DEF→(A, K) : ¬A → K, ¬A → ¬K ⊢ A deﬁned in
Lemma 1.(iv). We set E¬E(D, ¬A) : Γ ⊢ A as the deduction
EDL(D, ¬A) ◦ DEF→(A, K). The deduction E¬I(D, A) of
Point (iii) is built in a similarly using DEF→¬(A, K) instead
of DEF→(A, K).
III.
THE EVALUATION MECHANISM
Evaluation functions have been introduced in [9] to get
a terminating proof-search procedure for Gentzen sequent
calculus LJ for propositional intuitionistic logic. Here, we
adapt this mechanism to the case of classical propositional
logic.
Let Lt,f be the language obtained by adding to L the
constants t (true) and f (false), with the usual interpretation;
let H be a formula of Lt,f and let Γ be a set of formulas of
L. The evaluation of H in Γ, denoted by eval(H, Γ), is the
formula of Lt,f obtained by replacing every subformula K of
H such that K is an axiom or K ∈ Γ with t and then by
performing some truth preserving boolean simpliﬁcations (for
instance, any subformula of the kind t ∨ K is replaced by t,
while f ∨ K is replaced by K). The function eval and the
auxiliary function simpl are deﬁned by mutual induction in
Figure 1. We point out that eval(H, Γ) is either t or f or a
formula of L (not containing the constants t, f). Moreover,
|eval(H, Γ)| ≤ |H|.
One can easily prove that, assuming Γ, the formulas H,
eval(H, Γ) and simpl(H, Γ) are classically equivalent, as
stated in the next lemma
Lemma 3: Let Γ be a set of formulas of L and H a formula
of Lt,f. Then:
1) Γ ⊨ H ↔ eval(H, Γ);
2) Γ ⊨ H ↔ simpl(H, Γ).
By Lemma 3 we immediately get:
Theorem 1: Let Γ be a set of formulas of L, let A be a
formula of L and M a model such that M ⊨ Γ.
1) eval(A, Γ) = t implies M ⊨ A.
11
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-709-2
COMPUTATION TOOLS 2019 : The Tenth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

eval(H, Γ) =







t
if H is an axiom or H ∈ Γ
f
if ¬H ∈ Γ
H
if H ∈ (Pv \ Γ) ∪ {t, f}
simpl(H, Γ)
otherwise
in the following K1 = eval(H1, Γ) and K2 = eval(H2, Γ)
simpl(¬H1, Γ) =



t
if K1 = f
f
if K1 = t
¬K1
otherwise
simpl(H1 ∧ H2, Γ) =



t
if K1 = t and K2 = t
f
if K1 = f or K2 = f
K1 ∧ K2
otherwise
simpl(H1 ∨ H2, Γ) =



t
if K1 = t or K2 = t
f
if K1 = f and K2 = f
K1 ∨ K2
otherwise
simpl(H1 → H2, Γ) =



t
if K1 = f or K2 = t
f
if K1 = t and K2 = f
K1 → K2
otherwise
Figure 1.
Deﬁnition of eval
2) eval(A, Γ) = f implies M ⊨ ¬A.
By L¬ we denote the set of formulas H such that H is a
literal or H = ¬(A ∨ B). A set of formulas Γ is reduced iff
the following properties hold:
• Γ ⊆ L¬;
• for every p ∈ Pv, p ∈ Γ implies ¬p ̸∈ Γ;
• for every H = ¬(A ∨ B) ∈ Γ, eval(H, Γ \ {H}) = t.
By Theorem 1, we get:
Theorem 2: Let Γ be a reduced set of formulas. Then, Γ∩
Pv is a model of Γ.
Proof: Let Θ be the subset of Γ containing all the
formulas of the kind ¬(A ∨ B) of Γ. We prove the theorem
by induction on the cardinality of Θ. If Θ is empty, then Γ
only contains propositional variables or formulas ¬p such that
p ∈ Pv \ Γ; this implies that Γ ∩ Pv is a model of Γ. Let
¬(A ∨ B) ∈ Θ, let Γ1 = Γ \ {¬(A ∨ B)} and let M be the
model Γ ∩ Pv. By induction hypothesis, M is a model of Γ1.
Since Γ is reduced, we have eval(¬(A ∨ B), Γ1) = t; by
Theorem 1 we get M ⊨ ¬(A ∨ B), hence M is a model of
Γ.
A set of formulas Γ is contradictory iff there exists a
formula X such that {X, ¬X} ⊆ Γ. In the proof of termination
of the proof-search procedure Hp, we need the following
properties of eval.
Lemma 4: Let Γ be a non-contradictory set of formulas,
let H be a formula and let us assume that eval(H, Γ) = τ,
where τ ∈ {t, f}. Let K ∈ Γ and ∆ = Γ \ {K}. Then:
1) If K = ¬¬A and ∆ ∪ {A} is not contradictory, then
eval(H, ∆ ∪ {A}) = τ.
2) If K = A ∧ B and ∆ ∪ {A, B} is not contradictory, then
eval(H, ∆ ∪ {A, B}) = τ.
3) If A0 ∨ A1 ∈ Γ and , ∆ ∪ {Ak} is not contradictory, then
eval(H, ∆ ∪ {Ak}) = τ.
4) If K = A → B and ∆ ∪ {¬A} is not contradictory, then
eval(H, ∆ ∪ {¬A}) = τ.
5) If K = A → B and , ∆ ∪ {B} is not contradictory, then
eval(H, ∆ ∪ {B}) = τ.
6) If K = ¬(A0 ∧ A1) and k ∈ {0, 1} and ∆ ∪ {¬Ak} is
not contradictory, then eval(H, ∆ ∪ {¬Ak}) = τ.
7) If K = ¬(A0 ∨ A1) and eval(K, ∆) = t and k ∈ {0, 1}
and ∆ ∪ {¬Ak} is not contradictory, then eval(H, ∆ ∪
{¬Ak}) = τ.
8) If K = ¬(A0 ∨ A1) and eval(A0, ∆) = eval(A1, ∆) =
f, then eval(H, ∆) = τ.
9) If ¬(A → B) ∈ Γ and ∆∪{A, ¬B} is not contradictory,
then eval(H, ∆ ∪ {A, ¬B}) = τ.
IV.
PROCEDURE Hp
We present the procedure Hp to search for a deduction in
Hc. Let Γ be a set of formulas and let G be the goal formula or
the special symbol □ representing the empty goal. We deﬁne
the procedure Hp satisfying the following properties:
(H1) If G ∈ L, Hp(Γ, G) returns either a deduction D : Γ ⊢ G
or a model of Γ ∪ {¬G}.
(H2) Hp(Γ, □) returns either a deduction D : Γ ⊢ K such that
¬K ∈ Fm(D) or a model of Γ.
Procedure Hp (Γ, G)
(1) if G is an axiom or G ∈ Γ
return ⟨G⟩
(2) if there is {¬A, A} ⊆ Γ
if G ̸= □, then return the proof DEF(A, G)
else return ⟨¬A, A⟩
(3) if there is ¬¬A ∈ Γ
let D = Hp( (Γ \ {¬¬A}) ∪ {A}, G ).
if D is a model, then return D
else return ⟨¬¬A, ¬¬A → A⟩ ◦ D
(4) if there is A ∧ B ∈ Γ
12
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-709-2
COMPUTATION TOOLS 2019 : The Tenth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

let D = Hp( (Γ \ {A ∧ B}) ∪ {A, B}, G )
if D is a model, then return D
else return ⟨A ∧ B, (A ∧ B) → A, (A ∧ B) → B⟩ ◦ D
(5) if there is A0 ∨ A1 ∈ Γ and G = □
for i = 0, 1, let Di = Hp( (Γ \ {A0 ∨ A1}) ∪ {Ai}, □ )
if there exists i ∈ {0, 1} such that Di is a model, then
return Di
else for i = 0, 1, let Ki the last formula of Di
let D′
1 = D1 ◦ DEF(K1, ¬K0) ◦ DEF(K1, K0)
let E0 = EDL(D0, A0)
let E1 = EDL(D′
1, A1)
return E0 ◦ E1 ◦ D∨E(A0, A1, ¬K0) ◦ D∨E(A0, A1, K0)
(6) if there is A0 ∨ A1 ∈ Γ and G ̸= □
for i = 0, 1, let Di = Hp((Γ \ {A0 ∨ A1}) ∪ {Ai}, G)
if there exists i ∈ {0, 1}, such that Di is a model, then
return Di
else for i = 0, 1, let D′
i = EDL(Di, Ai)
return D′
0 ◦ D′
1 ◦ D∨E(A0, A1, G)
(7) if (G = A0 ∨ A1 or G ∈ Pv) and eval(G, Γ) ̸= f
let D = Hp( Γ ∪ {¬G}, □ )
if D is a model, then return D
else return E¬E(D, ¬G)
(8) if G = A0 ∧ A1
for i = 0, 1, let Di = Hp(Γ, Ai)
if there exists i ∈ {0, 1}, such that Di is a model, then
return Di
else let
D2
= ⟨
A0 → (A1 → (A0 ∧ A1)),
A1 → (A0 ∧ A1), A0 ∧ A1⟩
return D0 ◦ D1 ◦ D2
(9) if G = A → B
let D = Hp(Γ ∪ {A}, B)
if D is a model, then return D, else return EDL(D, A)
(10) if G = ¬A
let D = Hp(Γ ∪ {A}, □)
if D is a model, then return D, else return E¬I(D, A)
(11) if G = A0 ∨ A1
// here eval(A0 ∨ A1, Γ) = f
if eval(A0, Γ) ̸= f
let D = Hp(Γ, A0)
if D is a model, then return D
else return D ◦ ⟨A0 → (A0 ∨ A1), A0 ∨ A1⟩
if eval(A1, Γ) ̸= f
let D = Hp(Γ, A1)
if D is a model, then return D
else return D ◦ ⟨A1 → (A0 ∨ A1), A0 ∨ A1⟩
// here eval(A0, Γ) = eval(A1, Γ) = f
let D = Hp(Γ, □)
if D is a model, then return D
else let K be the last formula of D
return D ◦ DEF(K, G)
(12) if G ∈ Pv and ¬G ∈ Γ
let D = Hp(Γ, □)
if D is a model, then return D
else let K be the last formula of D
return D ◦ DEF(K, G)
// here G = □
(13) if there is ¬A ∈ Γ such that A = B0 ∨ B1
and eval(¬A, Γ \ {¬A}) ̸= t
let D = Hp(Γ, A)
if D is a model, then return D
else return ⟨¬A⟩ ◦ D
(14) if there is ¬A ∈ Γ such that A ̸∈ Pv and A ̸= B0 ∨ B1
let D = Hp( Γ \ {¬A}, A )
if D is a model, then return D
else return ⟨¬A⟩ ◦ D
(15) if there is A → B ∈ Γ
let D0 = Hp( Γ \ {A → B}, A )
let D1 = Hp( (Γ \ {A → B}) ∪ {B}, G )
if, for some i ∈ {0, 1}, Di is a model, then return Di
else return D0 ◦ ⟨A → B⟩ ◦ D1
// here Γ is reduced
(16) return the model Γ ∩ Pv
Before discussing the properties of Hp, we give a high-
level overview of the proof-search procedure. Steps (1), (2)
and (16) are the base cases of Hp and immediately return a
value. In particular, Step (1) returns a derivation of G when
it is either an axiom or an assumption and Step (2) returns
the derivation of G when Γ is contradictory. As for Step (16),
it is executed when steps (1)-(15) cannot be applied; thus, Γ
is reduced and G is the empty goal □. As we discuss later
(see Theorem 4), the returned value Γ ∩ Pv is a model of Γ.
Steps (3)-(6) act on an assumption K ∈ Γ; according with the
form of K, these steps reduce the problem to prove Γ ⊢ G to
the problem to prove Γ′ ⊢ G, where Γ′ is obtained by replacing
K with its relevant subformulas. These steps exploit axioms
(Ax8), (Ax4a), (Ax4b), (Ax6) to decompose the assumption.
Steps (7)-(12) act on the goal formula G. Step (7) essentially
corresponds to an application of reductio ad absurdum. Note
that this case only applies when G is an atomic or a disjunctive
formula; how we discuss later (see Point (P6) below), the side
condition eval(G, Γ) ̸= f has an essential role to guarantee
termination. Steps (8)-(12) exploit axioms (Ax3), (Ax5a) and
the closing assumption schemas of Lemma 2 to decompose the
goal formula. Steps (13) and (14) handle the case of negated
assumptions. We note that in Step (13) the treated assumption
¬(B0 ∨ B1) is retained in the recursive call; also in this case
the ﬁring condition involving the evaluation function plays an
essential role to guarantee termination (see Point (P8) below).
Finally, Step (15) handles the case of implicative assumptions.
Termination and completeness
To search for a derivation of a goal G0 from assumptions
Γ0, we have to compute Hp(Γ0, G0). We show that the call
Hp(Γ0, G0) terminates. The stack of recursive calls involved
in the computation of Hp(Γ0, G0) can be represented by a
chain of the form Γ0 ⊢ G0 7→ Γ1 ⊢ G1 7→ · · · 7→ Γn ⊢ Gn
where, for every k ≥ 0, Γk is a set of formulas and the
goal Gk is a formula or □. Each sequent σk = Γk ⊢ Gk
in the chain represents a call Hp(Γk, Gk) performed along
the computation of Hp(Γ0, G0). By Gk we denote the set
Γk ∪ {¬Gk} if Gk ̸= □ and the set Γk if Gk = □.
We have to prove that, for every set of formulas Γ0 and
goal G0, every chain starting from σ0 = Γ0 ⊢ G0 is ﬁnite
(namely, the chain contains ﬁnitely many sequents). Let us
assume, by absurd, that there exists an inﬁnite chain C(σ0) =
σ0 7→ σ1 7→ σ2 . . . ; we show that we get a contradiction. To
this aim, we state some properties of C(σ0) (the related proofs
are only sketched).
(P1) For every k ≥ 0, Gk is not an axiom.
(P2) For every k ≥ 0, the set Gk is not contradictory.
13
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-709-2
COMPUTATION TOOLS 2019 : The Tenth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

Let us assume, by contradiction, that there exists k ≥ 0
such that Gk is an axiom. Then the call Hp(Γk, Gk) imme-
diately ends at step (1), hence σk would be the last sequent
of C(σ0), against the assumption that C(σ0) is inﬁnite. This
proves (P1).
To prove (P2), let us assume that there exists k ≥ 0 such
that Gk is contradictory. Then, there is a formula X such that
{X, ¬X} ⊆ Gk. If {X, ¬X} ⊆ Γk or Gk = □, then the
call Hp(Γk, Gk) immediately ends at step (2), a contradiction.
Thus, let us assume Gk ̸= □ and either Gk ∈ Γk or ¬¬Gk ∈
Γk. In the ﬁrst case, the call Hp(Γk, Gk) immediately ends
at step (1). If ¬¬Gk ∈ Γk, by inspecting Hp one can check
that there exists j > k such that Gk ∈ Γj and Gj = Gk
(see step (3)), hence σj would be the last sequent of C(σ0), a
contradiction. This concludes the proof of (P2).
By (P2) and the properties of eval, we can prove that the
evaluation of a formula is preserved along the chain, as stated
in the next property:
(P3) Let eval(A, Gk) = τ, with τ ∈ {t, f}. Then, for every
j ≥ k, eval(A, Gj) = τ.
To prove (P3), we can exploit Lemma 4, since, by
Point (P2), all the sets Gk are non-contradictory.
By Sf¬(σ0) we denote the set of the formulas H and ¬H
such that H is a subformula of a formula in σ0. By inspecting
the deﬁnition of Hp, one can easily check that:
(P4) For every k ≥ 0, Gk ⊆ Sf¬(σ0).
(P5) For every i ≤ j, Gi ∩ L¬ ⊆ Gj ∩ L¬.
We now state some crucial properties of disjunctive goals:
(P6) Let Gk = A∨B and eval(Γk, A) ̸= f. Then, there exists
j > k such that eval(Γj, A) = f.
(P7) Let Gk = A∨B and eval(Γk, A) = f and eval(Γk, B) ̸=
f. Then, there exists j > k such that eval(Γj, A) =
eval(Γj, B) = f.
(P8) Let H = ¬(A ∨ B) such that H ∈ Γk and eval(H, Γk \
{H}) ̸= t. Then, there exists j > k such that H ∈ Γj
and eval(H, Γj \ {H}) = t.
Let us consider Point (P6). If Gk
=
A ∨ B and
eval(Γk, A) ̸= f, then there exists l ≥ k such that chain
starting from the sequent σl has the form
Γl ⊢ A ∨ B 7→ Γl+1 ⊢ A 7→ · · · ; 7→ Γl+m ⊢ H
where the formula H satisﬁes one of the following properties:
(a) H = H0 ∨ H1 and eval(H0 ∨ H1, Γl+m) ̸= f;
(b) H is a literal.
Indeed, after a (possibly empty) initial phase where some
formulas in Γk are handled, the goal formula A∨B is eagerly
decomposed until a disjunctive formula H satisfying (a) or a
literal H is obtained. In this phase, whenever we get a goal
Gj = B → C, the formula B is added to the left-hand side
and the next sequent of the chain is Γj, B ⊢ C (see step (9));
this might introduce a sequence of steps to decompose the
formula B and its subformulas. By exploiting (P3), one can
prove that:
(c) eval(H, Γl+m+1) = f implies eval(A, Γl+m+1) = f.
If H satisﬁes (a), the next sequent of the chain is σl+m+1 =
Γl+m, ¬H ⊢ □ (see step (7)). Since eval(H, Γl+m+1) = f,
by (c) we get eval(A, Γl+m+1) = f, hence Point (P6)
holds. Similarly, if H is a propositional variable, then H ̸∈
Γl+m, otherwise the set Gl+m would be contradictory, against
Point (P2). Thus, the next sequent of the chain is σl+m+1 =
Γl+m, ¬H ⊢ □ (see step (7)), and this proves Point (P6). The
case H = ¬p, with p ∈ Pv, is similar (see step (10)). The
proofs of points (P7) and (P8) are similar.
By the above points, it follows that we eventually get a
sequent σm such that Γm is reduced and Gm = □. Indeed,
by (P4), the formulas occurring in C(σ0) are subformulas of
Sf¬(σ0). Along the chain, formulas H occurring in Γk such
that H ̸∈ L¬ are eventually decomposed, formulas H ∈ L¬
are preserved (see (P5)). Formulas of the kind ¬p, with p ∈ Pv,
do not threaten termination. Let us take a formula H = ¬(A∨
B) occurring in some Γk. By (P8), there exists l > k such
that σl = Γl ⊢ Gl and eval(H, Γl \ {H}) = t. By (P3), for
every j ≥ l it holds that eval(H, Γj \ {H}) = t. Since the
formulas of the kind ¬(A ∨ B) that can occur in the sets Γk
are ﬁnitely many, it follows that we eventually get a sequent
σm such that Γm is reduced and Gm = □. Since the only step
applicable to the call Hp(Γm, Gm) is (16), σm should be the
last sequent of C(σ0), a contradiction. This proves that C(σ0)
is ﬁnite, thus:
Theorem 3 (Termination): Let Γ be a ﬁnite set of formulas
of L and G a formula of L or □. Then, Hp(Γ, G) terminates.
Now, we prove that Hp is correct, namely:
Theorem 4 (Correctness): Let Γ be a ﬁnite set of formulas
of L and G a formula of L or □. Then, Hp(Γ, G) satisﬁes
properties (H1) and (H2).
Proof: By induction on the length l of C(Γ ⊢ G). If
l = 0, then the computation of Hp(Γ, G) does not require any
recursive call. Accordingly, one of the steps (1), (2) or (16)
is executed. In the ﬁrst two cases, a derivation satisfying
properties (H1) and (H2) is returned. In the latter case, the
model M = Γ ∩ Pv is returned. Since none of the conditions
in the if-statements of cases (1)–(15) holds, the set Γ is reduced
and G = □; by Theorem 2, we conclude M ⊨ Γ. Let l > 1
and let C(Γ ⊢ G)
=
Γ ⊢ G 7→ Γ1 ⊢ G1
7→
· · · . Since
the length of C(Γ1 ⊢ G1) is l − 1, by induction hypothesis the
call Hp(Γ1, G1) satisﬁes properties (H1) and (H2). By a case
analysis, one can easily check that Hp(Γ, G) satisﬁes (H1)
and (H2) as well. For instance, let us assume that G = A0∨A1
and that step (11) is executed. If eval(A0, Γ) = f, the
recursive call Hp(Γ, A0) is executed. If a deduction D is
returned, by induction hypothesis D is a deduction of Γ ⊢ A0.
This implies that the deduction D◦⟨A0 → (A0∨A1), A0∨A1⟩
returned by Hp(Γ, A0 ∨ A1) is a deduction of Γ ⊢ A0 ∨ A1
(note that A0 → (A0 ∨ A1) is an instance of the axiom
(Ax5a)). Let us assume that Hp(Γ, A0) returns a model
M. By induction hypothesis, we have M ⊨ Γ ∪ {¬A0}.
Moreover, since the if-condition in step (7) is false, it holds
that eval(A0 ∨ A1, Γ) = f. By Theorem 1, we get M ⊨
¬(A0 ∨ A1), hence M ⊨ Γ ∪ {¬(A0 ∨ A1}. The proof of the
remaining subcases is similar.
To conclude this section we provide two examples, the ﬁrst
one showing an example of an execution of the proof-search
14
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-709-2
COMPUTATION TOOLS 2019 : The Tenth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

procedure returning a counter model, the second one returning
an Hc-derivation.
Example 2: Let us consider the case where the goal for-
mula is p ∨ q and the set of the assumptions is empty. We
describe the chain of recursive calls applied to compute the
goal, referring to the steps in the deﬁnition of Hp.
(c1) Hp(∅, p ∨ q)
Since eval(p ∨ q, ∅) = p ∨ q, case (7) is applied and the
recursive call Hp({¬(p ∨ q)}, □) is executed.
(c2) Hp({¬(p ∨ q)}, □)
Since eval(¬(p ∨ q), ∅) = ¬(p ∨ q), case (13) is selected
and Hp({¬(p ∨ q)}, p ∨ q) is executed.
(c3) Hp({¬(p ∨ q)}, p ∨ q)
Since eval(p ∨ q, {¬(p ∨ q)}) = f, case (11) is se-
lected. Moreover, since eval(p, {¬(p ∨ q)}) = p, the call
Hp({¬(p ∨ q)}, p) is executed.
(c4) Hp({¬(p ∨ q)}, p)
Since eval(p, {¬(p ∨ q)}) = p, case (7) is selected and
Hp({¬(p ∨ q), ¬p}, □) is executed.
(c5) Hp({¬(p ∨ q), ¬p}, □)
Since eval(¬(p ∨ q), {¬p}) = ¬q, case (13) is selected
and Hp({¬(p ∨ q), ¬p}, p ∨ q) is executed.
(c6) Hp({¬(p ∨ q), ¬p}, p ∨ q)
Since eval(p ∨ q, {¬(p ∨ q), ¬p}) = f, case (11) is
selected. Moreover, since eval(p, {¬(p ∨ q), ¬p}) = f
and eval(q, {¬(p ∨ q), ¬p}) = q, Hp({¬(p ∨ q), ¬p}, q)
is executed.
(c7) Hp({¬(p ∨ q), ¬p}, q)
Since eval(q, {¬(p ∨ q), ¬p}) = q, case (7) is selected
and Hp({¬(p ∨ q), ¬p, ¬q}, □) is executed.
(c8) Hp({¬(p ∨ q), ¬p, ¬q}, □)
Since eval(¬(p ∨ q), {¬p, ¬q}) = t and ¬p and ¬q are
literals, case (16) is executed and the model ∅ is returned.
Since the recursive call in (c8) returns the model ∅, any of
the recursive calls in points (c7)-(c1) returns the same model,
which indeed is a model of {¬(p ∨ q)}.
Example 3: Let us consider the case where the goal for-
mula is p ∨ ¬p and the set of assumptions is empty.
(c1) Hp(∅, p ∨ ¬p)
Since eval(p ∨ ¬p, ∅) = p ∨ ¬p, case (7) is selected and
the recursive call Hp({¬(p ∨ ¬p)}, □) is executed.
(c2) Hp({¬(p ∨ ¬p)}, □)
Since eval(¬(p ∨ ¬p), ∅) = ¬(p ∨ ¬p), case (13) is
selected and Hp({¬(p ∨ ¬p)}, p ∨ ¬p) is executed.
(c3) Hp({¬(p ∨ ¬p)}, p ∨ ¬p)
Since eval(p∨¬p, {¬(p∨¬p)}) = f, case (11) is selected
and since eval(p, {¬(p∨¬p)}) = p, the call Hp({¬(p∨
¬p)}, p) is executed.
(c4) Hp({¬(p ∨ ¬p)}, p)
Since eval(p, {¬(p ∨ ¬p)}) = p case (7) is selected and
Hp({¬(p ∨ ¬p), ¬p}, □) is executed.
(c5) Hp({¬(p ∨ ¬p), ¬p}, □)
Since eval(¬(p ∨ ¬p), {¬p}) = f, case (13) is selected
and Hp({¬(p ∨ ¬p), ¬p}, p ∨ ¬p) is executed.
(c6) Hp({¬(p ∨ ¬p), ¬p}, p ∨ ¬p)
Since eval(p ∨ ¬p, {¬(p ∨ ¬p), ¬p}) = t, case (11) is
selected. Moreover, we have eval(p, {¬(p ∨ ¬p), ¬p}) =
f and eval(¬p, {¬(p∨¬p), ¬p}) = t; as a consequence
Hp({¬(p ∨ ¬p), ¬p}, ¬p) is executed.
(c7) Hp({¬(p ∨ ¬p), ¬p}, ¬p)
Since ¬p ∈ {¬(p ∨ ¬p), ¬p} case (1) is selected and the
Hc-derivation ⟨¬p⟩ is returned.
Since the recursive call in (c7) returns a derivation, any of the
calls in points (c6)-(c1) returns the derivation built according
with the receipt described in the corresponding case.
V.
CONCLUSIONS
In this paper, we have presented a deterministic and ter-
minating proof-search procedure Hp for a Hilbert calculus
for classical propositional logic (a Prolog implementation is
available[10]). Hp is a procedure that builds Hilbert proofs, if
any, in one-pass, that is during the proof-search phase. Such
proofs can be seen as derivations based on a sequent calculus
having at most one formula on the right. The machinery of
evaluations is used to get completeness and termination.
As regards future works, we plan to provide terminating
procedures returning Hilbert proofs for intermediate logics by
applying the results in [9][11]. We also aim to extend the proof-
search procedure for Hc to treat some modal logics, as, e.g.,
S4 and S5 [12] and conditional logics [13].
REFERENCES
[1]
A. Troelstra and H. Schwichtenberg, Basic Proof Theory, ser. Cam-
bridge Tracts in Theoretical Computer Science.
Cambridge University
Press, 2000, vol. 43.
[2]
M. D’Agostino, “Classical natural deduction,” in We Will Show Them!,
S. A. et al., Ed.
College Publications, 2005, pp. 429–468.
[3]
W. Sieg and J. Byrnes, “Normal natural deduction proofs (in classical
logic),” Studia Logica, vol. 60, no. 1, 1998, pp. 67–106.
[4]
M. Ferrari and C. Fiorentini, “Proof-search in natural deduction calculus
for classical propositional logic,” in TABLEAUX 2015, ser. LNCS,
H. D. Nivelle, Ed., vol. 9323.
Springer, 2015, pp. 237–252.
[5]
——, “Goal-oriented proof-search in natural deduction for intuitionistic
propositional logic,” Journal of Automated Reasoning, vol. 62, no. 1,
Jan 2019, pp. 127–167. [Online]. Available: https://doi.org/10.1007/
s10817-017-9427-3
[6]
S. Kleene, Introduction to Metamathematics.
Van Nostrand, 1952.
[7]
E. Eder, “Automated Deduction in Frege-Hilbert Calculi,” in 8th WEAS
International Conference on Applied Computer and Applied Compu-
tational Science, Chen, SY and Li, Q, Ed.
World Scientiﬁc and
Engineering Acad and Soc, 2009, pp. 21–25.
[8]
J. Toriz, I. Ruiz, and J. R. Arrazola-Ram´ırez, “On automatic theorem
proving with ML,” in 13th Mexican International Conference on
Artiﬁcial Intelligence, MICAI 2014, 2014, pp. 231–236.
[9]
M. Ferrari, C. Fiorentini, and G. Fiorino, “An evaluation-driven deci-
sion procedure for G3i,” ACM Transactions on Computational Logic
(TOCL), vol. 6, no. 1, 2015, pp. 8:1–8:37.
[10]
“Implementation of Hp “, 2019, URL: https://drive.google.com/open?
id=1nGvqKx Rj0y2IscL4jldH2jPMWzDB-0X.
[11]
A. Avellone, P. Miglioli, U. Moscato, and M. Ornaghi, “Generalized
tableau systems for intermediate propositional logics,” in TABLEAUX
1997, ser. LNAI, D. Galmiche, Ed., vol. 1227.
Springer-Verlag, 1997,
pp. 43–61.
[12]
A. Chagrov and M. Zakharyaschev, Modal Logic.
Oxford University
Press, 1997.
[13]
D. Lewis, Counterfactuals.
John Wiley & Sons, 2013.
15
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-709-2
COMPUTATION TOOLS 2019 : The Tenth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

