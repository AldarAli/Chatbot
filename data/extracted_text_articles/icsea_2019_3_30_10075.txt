Towards Component-Based Development of Textual Domain-Speciﬁc Languages
Andreas Wortmann
Software Engineering
RWTH Aachen University
Aachen, Germany
http://www.se-rwth.de/
Abstract—Software-intensive systems are developed with the
help of experts of different domains. This requires reifying their
domain expertise in software, which raises the need for Domain-
Speciﬁc Languages (DSLs) to bridge the gap between the problem
space of the experts’ experience and software development. Devel-
oping suitable DSLs still is prohibitively complex due to the lack
of pervasive concepts for DSL reuse. Existing concepts either give
rise to a conceptual gap between their abstractions and language
deﬁnition constituents or are tied to speciﬁc technological spaces.
To mitigates this, we present a novel conceptual model for the
systematic reuse of textual DSLs. This technology-independent
model promotes modularity and reusability based on language
families that exhibit speciﬁc reuse interfaces. To realize these
concepts, we conceived an extensible modelling infrastructure
that supports the engineering of reusable textual DSLs using the
MontiCore language workbench. This enables systematic reuse
of textual DSLs for compatible technological spaces from which
DSL engineers in many domains can greatly beneﬁt.
Index Terms—Software Language Engineering, Textual Lan-
guages, Language Components
I. INTRODUCTION
Society increasingly depends on systems developed by ex-
perts from various domains using their own Domain-Speciﬁc
Languages (DSLs) [1]. DSLs have become innovation drivers
in many disciplines, including automotive, avionics, civil en-
gineering, Industry 4.0, robotics, and software engineering
itself. This, e.g., led to the engineering of over 120 DSLs
for software architectures [2] used in different domains and
various technological spaces [3]. All of these need to be
developed, maintained, and evolved on their own, which is
costly, error-prone, and hinders progress in the multi-domain
engineering of modern software-intensive systems.
Research in Software Language Engineering (SLE) [4] in-
vestigates the efﬁcient and reliable engineering, maintenance,
deployment, use, and evolution of DSLs to support software
engineers and domain experts in efﬁciently developing future
systems. Despite attempts to a systematic SLE, many DSLs
are engineered ad-hoc, for very speciﬁc challenges, and very
limited purposes only [5]. Hence, research has produced a mul-
titude of solutions to facilitate creating DSLs. These include on
metamodels [6], grammars [7], or abstract data types [8], inter-
preters [9] or code generators [10], and well-formedness rules
deﬁned in metalanguages [8] or programming languages [11].
For these, the SLE community has proposed various reuse
techniques, based on experiences from general software reuse
(e.g., polymorphic [12] and parametric [13] reuse, composi-
tion [7] or variability [14]). Although these techniques address
a wide range of scenarios, most support speciﬁc parts of DSL
deﬁnitions (e.g., abstract syntax or code generators) only and
are limited to speciﬁc technological spaces. This complicates
the engineering and customization of real-world DSLs for
different usage scenarios, which ultimately hinders systems
engineering by domain experts.
To mitigate this, we present the COLD4TXT conceptual
model for component-based language development of tex-
tual DSLs that implement behavior with code generators
(txtDSLs). In this model, language components with explicit
interfaces of required and provided grammar rules, well-
formedness rules, and code generators are the principal el-
ements of reuse. Feature models arrange these components,
according to their required and provided extension points, in
language families. Thus selecting features governs how the
language components are composed. Based on this model,
we present a systematic method to describe and resolve the
component’s variability, as well as their customization.
As the technical realizations of composing grammars, well-
formedness rules, and code generators have been presented
already [10], [15], this contribution illustrates their conceptual
framework consisting of:
1) The COLD4TXT conceptual model for reusable txtDSL
components featuring explicit interfaces of required and
provided elements.
2) A systematic method for engineering languages based on
reusable txtDSL components.
3) A realization of both with the MontiCore language engi-
neering workbench.
With these, reusing language components in different language
families can greatly facilitate engineering DSLs.
In the following, Section II motivates our method by
example. Afterwards, Section III presents txtDSL language
components and Section IV our method to reuse theses for
efﬁcient txtDSL engineering. Ultimately, Section V debates
observations, Section VI discusses related work, and Sec-
tion VII concludes.
II. EXAMPLE
Consider
using
Architecture
Description
Languages
(ADLs)
[2]
–
DSLs
for
the
speciﬁcation
of
software
68
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

BaseADL
Components
Connectors
Reconfiguration
Static
Modes
Asm/Gar
Contracts
Generic
Port Types
Shared
Memory
ROS
based
Automata
Grammar
Contract Automata
Well-formedness
Rules
Contract Automata
Transformations
Component
Modes Grammar
Component Modes
Well-formedness
Rules
Component Modes
Transformations
Invariants
realizes
realizes
Expression
Grammar
Expression Well-
formedness Rules
Expression
Transformations
realizes
family CorpADL
cmp ContractAutomata
cmp ComponentModes
cmp Expressions
Fig. 1. A language family comprising features of language components that
can fulﬁll the requirements of all three departments.
architectures – for the different departments of a large
corporation. In each of these departments, some developers
occasionally, maybe once a week, (re-)model parts of a
speciﬁc software architecture (e.g., of a train, a factory, or
a mobile service robot). Instead of learning overly generic
ADLs and operating with complex modeling guidelines that
describe how to properly model with these, modelers of each
department should be able to use their speciﬁc terminology
and learn only the modeling elements required for their
speciﬁc application.
Hence, while in general, these ADLs require some notion
of components, ports, and connectors, each department has
domain-speciﬁc requirements for the ADLs to be used:
• Department A (trains) requires components that support
dynamic reconﬁguration via components modes [16] to
enable switching components related to country-speciﬁc
technology when the train crosses a border.
• Department B (smart factories) demands components
with assumption/guarantee contracts [17] that facilitate
correct integration of new components when the factory
reconﬁgures.
• Department C (robotics) demands novel connectors that
support bridging architecture models with the robot op-
erating system (ROS) [18].
Developing a general ADL that captures all of these concepts
is not feasible as it complicates modeling in departments
where only some of these modeling elements are required.
Alternatively developing three speciﬁc ADLs – each with
their speciﬁc infrastructure (e.g., parsers, model checkers, code
generators) – independently is costly and inefﬁcient.
Instead, building suitable language components and com-
bining these as required can signiﬁcantly reduce the effort
of fulﬁlling the departments’ requirements. For our example,
consider the language family of Figure 1: this family contains
the language features required by the different departments
and each feature is implemented by a language component
comprising a combination of grammar, well-formedness rules,
and code generators. By developing independent language
components that implement the different features and by lever-
aging variability modeling techniques, the conﬁguration of the
base ADL for the different departments only requires selecting
the appropriate language components and (semi-)automatically
integrating these. If no appropriate features are available,
developing and integrating novel language components and
integrating these into existing language families reduces the
effort of building a suitable ADL.
Our method to engineer and reuse language components
considers both, planned variability and opportunistic reuse, and
supports semi-automated composition of language component
constituents in the technological space of the MontiCore [11]
language workbench.
III. COLD4TXT LANGUAGE COMPONENTS
The conceptual model of COLD is a vision of language
reuse that requires concretization. For txtDSLs, we have de-
veloped the COLD4TXT variant of COLD which realizes vari-
ability, explains how resolving variability affects the language
components, how variability and customizability interact, how
variability, customizability, the language facets’ artifacts relate,
and provides modeling techniques to realize this. At its core,
COLD4TXT resolves variability and customizability through
the additive composition of language components according
to their explicitly provided and required extension points.
To enable this, COLD4TXT differs from COLD: In
COLD4TXT, language families and language components
replace language concerns and language facets of COLD,
respectively: The language concerns of COLD provide both
variability and customizability. This entails that they pro-
vide the complete customizability of their intrinsic language
product line and express this towards the user despite only
a small subset of customization options being available in
the language product derived from the product line (namely
these provided by the features selected for the product). In
contrast, customizability should express means for tailoring
languages that are not resolved by variability. Therefore, the
language component comprising the derived language product
provides customizability options instead. Moreover, to enable
the proper composition of language components based on a
feature selection, the COLD4TXT language components yield
interfaces themselves. These interfaces guide and restrict their
use in the variation interface’s feature model and enable com-
posing two language components (semi-)automatically, with
only the implementation of adapters for generator composition
requiring manual interaction [10]. To explain the effects of
resolving variability and customizability in COLD4TXT, a
language component consists of a
• one language component interface,
• one customization interface,
69
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

• up to one grammar artifact,
• arbitrary many well-formedness rule artifacts, and
• arbitrary many code generator artifacts.
The language component interfaces explicitly provide or
require language grammar productions, well-formedness rules,
or code generators. Also, they may yield constraints between
these (e.g., representing whether an extension point is optional
or mandatory, or to express that selecting a provided code
generator entails selecting a grammar production as well).
The provided extension points for grammar rules identify
productions of the contained CFG that are meant for reuse
(e.g., expressions of an imperative modeling language, method
signatures of a class diagram language, etc.). The required
extension points for grammar productions explicate produc-
tions that demand (optional or mandatory) extension for the
contained syntax to be completed.
Specifying required well-formedness rules within the inter-
face either demands complete speciﬁcations of the required
well-formedness rules behavior (i.e., their implementation) or
demands conditions under which an independently provided
well-formedness rule is suitable for the required rule (i.e.,
some form of acceptance tests). The former entails having
a speciﬁcation that is precise enough to become a imple-
mentation automatically and the latter testing rarely would
be complete. Hence, we decided to consider the set of well-
formedness rules of a language component as its extension
point. Thus, a language component can provide arbitrary
many well-formedness rules that may or may not be used by
other components, but it cannot (yet) describe that it requires
additional well-formedness rules. Specifying the semantics of
required well-formedness rules is subject to ongoing work. For
code generators, language components leverage the notions of
producer interface and product interface as introduced in [10].
Hence, language components may provide and require exten-
sion points that declare exactly one producer interface and one
product interface. The customization interfaces of language
interfaces comprise parameters of well-formedness rules and
generators that are not meant to be resolved through the closed
variation of language families but enable open customization
instead. Such customization could be the numbers of initial
states supported in models of a language component for
an automaton DSL or the path a generator should produce
artifacts in.
The language interfaces ground their required and provided
extension points in the artifacts of their language components
as illustrated in Figure 2. Here, the red concepts (solid lines)
represent the language components and the yellow concepts
(dashed lines) highlight their customization interface parts.
The language components are part of language families. Aside
from at least one language component, a language family
contains a variation interface comprising a single feature
model and a mapping that relates features to language compo-
nent interfaces. By transitivity of language interface extension
points, this also identiﬁes one language component per feature.
The feature model of the variation interface is developed by a
Language
Family
Language
Component
Interface
Customization
Parameter
Feature
Model
FeatureTo
Component
Mapping
Variation
Interface
Feature
Constraint
Customization
Interface
Feature
Feature 
Group
Language
Component
has-
many
has-
many
has-
many
has-
many
has-
many
has-
many
Fig. 2. Conceptual model for txtDSL reuse focusing on language families
and their variation interfaces.
language family CorpADL {
components
MontiArc, ContractAutomata, ComplexPortTypes, Expressions;
variation interface root BaseADL {
mandatory Components {
optional AsmGarContracts { optional Invariants; }
optional GenericPortTypes;
}
// additional features relations
}
root feature BaseADL uses MontiArc;
abstract feature Components;
feature AsmGarContracts uses ContractAutomata {
binds production Automaton to Components.ArcElement;
binds generator Automaton2Java to Components.BehaviorGenerator;
binds wfrs NonHierarchical; 
}
feature Invariants uses Expressions {
binds production Expression to AsmGarContracts.Expr.
binds Expression.All;
binds generator Expressions2POJO to AsmGarContracts.Guard2Java;
}
// additional features definitions
}
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
variation
interface
available language components
feature definition
feature to component mappings
Fig. 3. Textual model of the CorpADL language family of Figure 1.
language family designer that intends to derive similar DSLs
of joint buildings blocks. As such, the designer models the
selection of a speciﬁc child feature implementing the extension
points of its parent feature and speciﬁes constraints between
features in the Feature2ComponentMappting.
The language components are composed based on the ar-
rangement of language components in the variation interfaces’
feature model. From this, a new language component compris-
ing their (possibly composed) artifacts together with a derived
interface are synthesized. If there are required extension points
not fulﬁlled by the selected features, these become part of the
new component’s interface.
COLD4TXT is realized as a language engineering frame-
work using the MontiCore language workbench. To this end,
we have developed modeling languages for language families,
language components, feature conﬁgurations, and customiza-
tion conﬁgurations as well as a toolchain that supports resolv-
ing variability and customizability.
The language family CorpADL of our example (cf. Fig-
ure 1) can be represented as illustrated in Figure 3. This
family describes which language components it comprises
(ll. 2-3), its variation interface in terms of a feature model
(ll. 4-10), and deﬁnes its features (ll. 11-24). A feature either
is a root feature (at most one), an abstract feature solely for
grouping other features (such as the feature Component),
70
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

language component ContractAutomata {
grammar mc.automata.ca.ContractAutomata;
provides production ConractAutomatonMain;
provides AsmAutomaton for production AssumptionAutomaton;
provides GarAutomaton for production GuaranteeAutomaton;
requires mandatory Expr for production IGuardExpression;
provides generator Automaton2Java for ContractAutomatonMain {
producer IAutomatonGen; 
product IAutomatonPairRealization;
}
requires generator Guard2Java for IGuardExpression {
producer IGuardExpressionGenerator;
product IGuardExpression
}
provides wfrs Hierarchical { 
mc.automata.ca.coco.base.*;
mc.automata.ca.coco.hierarchical.*; 
}
provides wfrs NonHierarchical { 
mc.automata.ca.coco.base.*;
mc.automata.ca.coco.NoHierarchy; 
}
parameters { 
int max for mc.automata.cocos.NumHierarchyLevels.initialize;
String prefix for IAutomatonGen.generate;
} 
}
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
provided
grammar
productions
required grammar production
provided generator
required generator
provided sets of
well-formedness
rules
customization parameters
Fig. 4. Model of the ContractAutomata component of Figure 1.
language component Expressions {
grammar mc.basic.expressions.Expressions;
provides production Expression; 
provides wfrs All { mc.basic.expressions.*; }
provides transformation Expressions2POJO for Expression {
producer IExpressionJavaGenerator; 
product IExpression;
}
}
01
02
03
04
05
06
07
08
09
10
Fig. 5. Model of the Expression component of Figure 1.
or is realized by a language component. Each feature of the
latter kind deﬁnes how the provided extension points of its
language component are mapped to the required extension
points of its parent feature. For instance, selecting the feature
Invariants entails that (1) its production Expression
will be embedded [15] into the extension point Expr of
the language component AsmGarContracts (l. 21); (2) its
well-formedness rules provided via the extension point All
will be reused (l. 22); and (3) its code generator provided via
the extension point Expressions2POJO will be embedded
into the code generator Guard2Java of language component
AsmGarContracts (l. 23). The well-formedness rules of
the language family ensure that these mappings are valid w.r.t.
the language components illustrated in Figure 4 and Figure 5.
IV. DERIVING LANGUAGES
Modeling language families with COLD4TXT ﬁrst demands
its instantiation for a speciﬁc technological space by providing
modules for (1) analysing the compatibility of COLD4TXT
models with the referenced technology space artifacts and
(2) composing these artifacts according to COLD4TXT spec-
iﬁcations as depicted in Figure 6. The former modules, for
instance, check whether a well-formedness rule provided by
a language component exists or whether a grammar produc-
tion declared as an extension point indeed is an interface
production. The latter modules take composition instructions
(the binding mappings) and related artifacts, and compose
these accordingly. For MontiCore, these modules are provided.
Language engineers than can use this instance of COLD4TXT
to engineer language components. Language family developers
can reuse these in different contexts through arranging these
in the variation interfaces. Language family users select the
desired language features matching their requirements and use
the COLD4TXT instance to synthesize a suitable language
component. If this language component is incomplete w.r.t. its
mandatory required extension points or parameters, it cannot
be used as a DSL yet. In this case, the language family user
has to specify the missing customization conﬁguration, before
a fully conﬁgured language component and the artifacts for a
DSL in the corresponding technological space are derived.
For MontiCore, these artifacts are a synthesized CFG, the
union of the selected well-formedness rules, and a code
generator composed along its producer and product interfaces.
These artifacts can be processed by MontiCore to produce a
DSL that is completely independent of language families and
language components. Moreover, the (possibly incomplete)
language components derived from resolving variability and
customizability can be used as parts of other language families
again, which facilitates their reuse.
Based on a feature conﬁguration, the COLD4TXT frame-
work composes the language components associated with
the selected features pairwise and top-down. The result-
ing component yields the provided extension points of the
parent and child components. For each mandatorily re-
quired extension point (e.g., Expr of language component
ContractAutomata), if an implementation is deﬁned by
the binding mappings in the variation interface’s feature
model, then this extension point becomes optional and is
copied to the interface of the new component as well. The
sets of well-formedness rules from the parent component and
the ones from the selected provided extension point of the
child component are merged and provided as a new extension
point in the new component. For the CFGs, COLD4TXT
expects the responsible modules of the speciﬁc technology
space to produce combined CFGs and adapters between the
participating code generators accordingly.
For instance, selecting the features “Asm/Gar Contracts”
and “Invariants” depicted in Figure 1 with the variation
interface speciﬁed in Figure 3 entails combining the lan-
guage components ContractAutomata (Figure 4) and
Expressions (Figure 5) accordingly. The resulting lan-
guage component is given in Figure 7. This component uses a
synthesized CFG featuring contract automata and expressions
(l. 2), the union of selected well-formedness rules, and the
composed code generators. Its interface reduces the cardinality
of the required grammar extension point Expr to optional
(l. 7), adds the provided extension point Expression (l. 8),
as well as the code generator for expressions (ll. 14-17)
71
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

COLD4TXT
Infrastructure
MontiCore
Analyses
CorpADL
:Language
Family
AsmGar
Contracts
:Component
GenericPort
Types
:Component
ROS
Connectors
:Component
Invariants
:Component
conforms
Language
Family
:MCDSL
COLD4TXT 
conceptual framework
COLD4TXT realization as 
MontiCore languages
COLD4TXT instance, using 
MontiCore analyses and syntheses
CorpADL language family in 
MontiCore’s technological space
Configuration of the CorpADL language 
family through its interfaces
Department
B
:Component
DepartmentB
:CustomizationCo
nfiguration
configures
composition operator
COLD4TXT 
well-formedness rules
realize
MontiCore
Syntheses
⊕
COLD4TXT conceptual model
DepartmentB
:Feature
Configuration
technology 
space expert
language
component
developers
language
family
user
language
family
engineer
⊕
Language
Component
:MCDSL
DepartmentB
:MCDSL
Fig. 6. After tailoring CORE4TXT for a speciﬁc technological space, developers can engineer language components to be used by language family
developers to facilitate creating DSLs.
language component ContractAutomataWithExpresssions {
grammar mc.automata.ca.ContractAutomataWithExpressions;
provides production ConractAutomatonMain;
provides AsmAutomaton of production AssumptionAutomaton;
provides GarAutomaton of production GuaranteeAutomaton;
requires optional Expr for production IGuardExpression;
provides production Expression;
provides transformation Automaton2Java for ContractAutomatonMain {
producer IAutomatonGen; 
product IAutomatonPairRealization;
}
provides transformation Expressions2POJO for Expression {
producer IExpressionJavaGenerator; 
product IExpression;
}
provides wfrs All { 
mc.automata.ca.coco.base.*;
mc.automata.ca.coco.NoHierarchy;
mc.basic.expressions.*;
}
parameters { 
int max for mc.automata.cocos.NumHierarchyLevels.initialize;
String prefix for IAutomatonGen.generate;
} 
}
01
02
03
04
05
06
07
08
09
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
became optional
added
synthesized
grammar
added
synthesized set of well-
formedness rules
Fig. 7. Language component synthesized as result from selecting the
features “Asm/Gar Contracts” and “Invariants” of Figure 3.
from the Expressions language component of Figure 5,
and provides a new set of well-formedness rules (ll. 19-
23). As this component does not require further extension,
specifying values for its parameters enables MontiCore to
derive a complete DSL from it.
V. DISCUSSION
In contrast to the purely conceptual models of DSL
reuse [19], [20], COLD4TXT supports capturing all DSL deﬁ-
nition constituents at a sufﬁcient level of abstraction to support
the precise explanation of the effects of composing these,
binding their variability, and resolving their customizability
on its own.
The conceptual model of COLD4TXT aims to be inde-
pendent of technological spaces as long as these enable to
(1) identify grammar extension points; (2) compose grammars,
sets of well-formedness rules, and code generators without
eliminating the extension points in the process; (3) describe
code generators and the generated products in terms of their
interfaces; (4) identify parameters of well-formedness rules
and code generators in an object-oriented fashion. While
these are strong assumptions, we currently investigate applying
COLD4TXT and its realization within the technological spaces
of Neverlang [7] and Xtext [21]. Moreover, it currently only
supports embedding in the sense of [10], whereas there are
various other composition operators for txtDSLs. Whether and
how supporting these is possible, also is ongoing research.
In the future, we aim to extend the notion of language
components to feature additional constituents (e.g., model-
to-model transformations or editor fragments), support other
forms of composition (e.g., coordination or aggregation), and
make the constraints of required well-formedness rule exten-
sions more explicit.
VI. RELATED WORK
Research on Language product lines (LPLs) [15], [22],
[23] is scattered across different kinds of DSL deﬁnition con-
stituents and technological spaces. And while we developed a
notion of LPLs for the technological space of MontiCore [15]
in particular, there currently is no actionable understanding
of the variability of complete txtDSLs (i.e., encompassing all
four kinds of constituents). Moreover, (closed) variation rarely
is connected with (open) customization to systematically reuse
72
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

DSLs in general. There are only a few solutions that consider
either txtDSL variation or customization across different kinds
of DSL deﬁnition constituents. These include a few language
workbenches [24], such as Argyle [23], Neverlang [7], or the
combination of SDF and FeatureHouse [22].
In Argyle [23], DSLs are constructed from language assets
that resemble concerns and comprise syntax, data types, and
code generation templates. A feature model arranges assets
according to their dependencies, which demands their white-
box apriori composition that hinders the reuse of facets.
In contrast, COLD4TXT will be based on our exploratory
work [15] that makes extension points of concerns explicit and
supports the black box composition of their artifacts through
the generation of suitable adapters between these.
SDF and FeatureHouse realize variability based on compo-
sitional language modules containing grammar rules, typing
rules, and evaluation rules [22]. It also focuses on the white-
box composition of artifacts and interpretation. Similar partial
solutions towards variation or customization of selected kinds
of DSL deﬁnition constituents are available from a variety
of language workbenches. For instance, ableC [25] is an
extensible C language that leverages attribute grammars to
reuse syntax and semantics, MPS [21] enables reuse of projec-
tional languages with views and model transformations, and
Spoofax [8] supports reuse of textual, interpreted languages.
All of these concepts for (partial) DSL reuse focus on speciﬁc
technological spaces. and lack support for integrated reuse
across variation and customization.
VII. CONCLUSION
We have presented the novel COLD4TXT conceptual frame-
work to facilitate reusing textual DSLs through systematic
variability and customizability. In COLD4TXT, language fam-
ilies capture txtDSL variability as feature models and realize
it via composition of language components according to
their interfaces. Composing language components yields new
language components that may demand further extension or
customization before these can be translated into complete
DSLs for speciﬁc contexts. Making the interfaces of language
components explicit enables reusing these in different lan-
guage families. This facilitates engineering textual DSLs for
different contexts and fosters the application of DSLs.
REFERENCES
[1] M. Voelter, B. Kolb, K. Birken, F. Tomassetti, P. Alff, L. Wiart,
A. Wortmann, and A. Nordmann, “Using language workbenches and
domain-speciﬁc languages for safety-critical software development,”
Software & Systems Modeling, pp. 1–24, 2018.
[2] I. Malavolta, P. Lago, H. Muccini, P. Pelliccione, and A. Tang, “What
Industry Needs from Architectural Languages: A Survey,” IEEE Trans-
actions on Software Engineering, vol. 39, no. 6, pp. 869–891, 2013.
[3] I. Kurtev, J. B´ezivin, and M. Aksit, “Technological spaces: An initial
appraisal,” CoopIS, DOA, vol. 2002, 2002.
[4] K. H¨olldobler, B. Rumpe, and A. Wortmann, “Software Language En-
gineering in the Large: Towards Composing and Deriving Languages,”
Computer Languages, Systems & Structures, vol. 54, pp. 386–405, 2018.
[5] J. Whittle, J. Hutchinson, and M. Rounceﬁeld, “The State of Practice in
Model-Driven Engineering,” Software, IEEE, vol. 31, no. 3, pp. 79–85,
2014.
[6] T. K¨uhne, “Matters of (meta-) modeling,” Software & Systems Modeling,
vol. 5, no. 4, pp. 369–385, 2006.
[7] E. Vacchi and W. Cazzola, “Neverlang: A framework for feature-oriented
language development,” Computer Languages, Systems & Structures,
vol. 43, pp. 1–40, 2015.
[8] G. H. Wachsmuth, G. D. P. Konat, and E. Visser, “Language Design
with the Spoofax Language Workbench,” IEEE Software, vol. 31, no. 5,
pp. 35–43, 2014.
[9] E. Bousse, J. Corley, B. Combemale, J. Gray, and B. Baudry, “Sup-
porting efﬁcient and advanced omniscient debugging for xDSMLs,” in
Proceedings of the 2015 ACM SIGPLAN International Conference on
Software Language Engineering.
ACM, 2015, pp. 137–148.
[10] A. Butting, R. Eikermann, O. Kautz, B. Rumpe, and A. Wortmann,
“Modeling Language Variability with Reusable Language Components,”
in International Conference on Systems and Software Product Line
(SPLC’18).
ACM, 9 2018.
[11] K.
H¨olldobler
and
B.
Rumpe,
MontiCore
5
Language
Workbench
Edition
2017,
ser.
Aachener
Informatik-Berichte,
Software
Engineering,
Band
32.
Shaker
Verlag,
Decem-
ber
2017.
[Online].
Available:
http://www.se-rwth.de/phdtheses/
MontiCore-5-Language-Workbench-Edition-2017.pdf
[12] T. Degueule, B. Combemale, A. Blouin, O. Barais, and J.-M. J´ez´equel,
“Safe model polymorphism for ﬂexible modeling,” Computer Lan-
guages, Systems & Structures, vol. 49, pp. 176–195, 2017.
[13] J. de Lara and E. Guerra, “Generic Meta-modelling with Concepts,
Templates and Mixin Layers,” in Model Driven Engineering Languages
and Systems, D. C. Petriu, N. Rouquette, and Ø. Haugen, Eds.
Berlin,
Heidelberg: Springer Berlin Heidelberg, 2010, pp. 16–30.
[14] T. K¨uhn, W. Cazzola, and D. M. Olivares, “Choosy and picky: conﬁgura-
tion of language product lines,” in Proceedings of the 19th International
Conference on Software Product Line.
ACM, 2015, pp. 71–80.
[15] A. Butting, R. Eikermann, O. Kautz, B. Rumpe, and A. Wortmann,
“Systematic composition of independent language features,” Journal of
Systems and Software, vol. 152, pp. 50–69, 2019.
[16] P. H. Feiler and D. P. Gluch, Model-Based Engineering with AADL:
An Introduction to the SAE Architecture Analysis & Design Language.
Addison-Wesley, 2012.
[17] M. Broy and K. Stølen, Speciﬁcation and development of interactive
systems: focus on streams, interfaces, and reﬁnement. Springer Science
& Business Media, 2012.
[18] K. Adam, K. H¨olldobler, B. Rumpe, and A. Wortmann, “Modeling
Robotics Software Architectures with Modular Model Transformations,”
Journal of Software Engineering for Robotics (JOSER), vol. 8, no. 1,
pp. 3–16, 2017.
[19] T. Clark, M. v. d. Brand, B. Combemale, and B. Rumpe, “Conceptual
Model of the Globalization for Domain-Speciﬁc Languages,” in Glob-
alizing Domain-Speciﬁc Languages, ser. LNCS 9400.
Springer, 2015,
pp. 7–20.
[20] B. Combemale, J. Kienzle, G. Mussbacher, O. Barais, E. Bousse,
W. Cazzola, P. Collet, T. Degueule, R. Heinrich, J.-M. J´ez´equel,
M. Leduc, T. Mayerhofer, S. Mosser, M. Sch¨ottle, M. Strittmatter,
and A. Wortmann, “Concern-oriented language development (COLD):
Fostering reuse in language engineering,” Computer Languages, Systems
& Structures, vol. 54, pp. 139–155, 2018.
[21] M. V¨olter, S. Benz, C. Dietrich, B. Engelmann, M. Helander, L. C. L.
Kats, E. Visser, and G. Wachsmuth, {DSL} Engineering - Designing,
Implementing and Using Domain-Speciﬁc Languages.
dslbook.org,
2013. [Online]. Available: http://www.dslbook.org
[22] J. Liebig, R. Daniel, and S. Apel, “Feature-oriented language families:
a case study,” in VaMoS, 2013.
[23] C. Huang, A. Osaka, Y. Kamei, and N. Ubayashi, “Automated DSL
construction based on software product lines,” in 2015 3rd International
Conference on Model-Driven Engineering and Software Development
(MODELSWARD).
IEEE, 2015, pp. 1–8.
[24] S. Erdweg, T. Van Der Storm, M. V¨olter, L. Tratt, R. Bosman,
W. R. Cook, A. Gerritsen, A. Hulshout, S. Kelly, A. Loh, and Others,
“Evaluating and comparing language workbenches: Existing results and
benchmarks for the future,” Computer Languages, Systems & Structures,
vol. 44, pp. 24–47, 2015.
[25] T. Kaminski, L. Kramer, T. Carlson, and E. Van Wyk, “Reliable and
automatic composition of language extensions to C: the ableC exten-
sible language framework,” Proceedings of the ACM on Programming
Languages, vol. 1, no. OOPSLA, p. 98, 2017.
73
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

