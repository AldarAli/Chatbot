Model-Based MCDC Testing of Complex Decisions for the Java Card Applet Firewall
Roderick Bloem1, Karin Greimel2, Robert Koenighofer1, Franz Roeck1,2
1Institute for Applied Information Processing and Communications
Graz University of Technology, A-8010 Graz, Austria
{roderick.bloem, robert.koenighofer, franz.roeck}@iaik.tugraz.at
2NXP Semiconductors Austria GmbH, Gratkorn, A-8101 Gratkorn, Austria
{karin.greimel, franz.roeck}@nxp.com
Abstract—Certiﬁcation processes require the generation of
models of a design. Using Model-Based Testing, these models
can double as guides for test case generation. In this paper, we
consider Boolean formulas that model a decision to be taken by
a part of the software. We show how to use an SMT-solver to
generate test cases that fulﬁll the MCDC coverage criteria on
these models, in the presence of strong coupling. We show that
the approach can improve test coverage, and ﬁnds a bug in an
implementation of the Java Card Applet Firewall.
Keywords—automatic test case generation; common criteria;
java card applet ﬁrewall.
I.
INTRODUCTION
Certiﬁcation of security critical embedded systems at a
certain level requires that formal models of the design are
created and veriﬁed against the security requirements. The
main motivation for the work presented in this paper is to com-
plement this certiﬁcation effort with systematic testing. Re-
using existing models for test case generation, we can increase
the conﬁdence in the quality of the actual implementation at
little extra cost.
Common Criteria [5] is a typical, widely used certiﬁcation
scheme. It assures that Security Functional Requirements are
met by the Target of Evaluation. It offers several Evaluation
Assurance Levels (EAL). Starting with EAL6, a formal model
is required to prove that the Security Functional Requirements
are satisﬁed. For complexity reasons, this proof is (typically)
carried out on the model and not on the actual implementation.
We propose to complement the certiﬁcation with test cases
derived automatically from the model in order to close the
link from the security functional requirements down to the
actual implementation, as illustrated in Fig. 1. The arrow from
the model to the implementation is dashed to emphasize that
the implementation is often not derived from the model but
developed independently. Thus, it is important to perform a
conformance check, and test cases are a scalable and ﬂexible
option.
Models of security-critical systems often contain complex
decisions, i.e., expressions evaluating to true or false. They
may express, for instance, under which circumstances a user
login should be successful or access to some resource should
be allowed. Complex decisions may directly serve as models
for stateless parts of the system (e.g., a method that checks if
some access is allowed). They may also appear as guards in
This work was supported in part by the Austrian Research Promotion
Agency (FWF) through project NewP@ss (835917).
Fig. 1: Test case generation complements certiﬁcation.
transition systems modeling stateful parts of the design. Such
complex decisions are often difﬁcult to test manually. First,
there may be complex dependencies between the different parts
of the decisions. Second, exhaustive testing is often infeasible,
but we still want to cover the “interesting” cases. Test criteria
help by deﬁning which cases are interesting and have to be
tested and we can use them to automatically generate test
cases. The beneﬁt of this Model-Based Testing approach is
that the models are much simpler than the implementation,
but precisely describe the various cases of interest. Also, the
model acts as a test oracle. In our setting, the model is derived
as a side-effect of the certiﬁcation procedure, at no extra cost.
One widely used test criterion to measure code coverage
is the Modiﬁed Condition Decision Coverage (MCDC) [9].
It is required by the US Federal Aviation Administration for
safety critical software in aircrafts [13], and also used in many
other domains. While MCDC is mostly used to measure the
coverage of test cases with respect to the decisions in the
implementation, we will apply the criterion to generate test
cases from the decisions in the model.
In this paper, we show how to derive a test suite that
achieves MCDC on a model that consists of logical decisions.
Using a Satisﬁability Modulo Theories (SMT) solver, we
obtain values for the variables used in the decision. That is,
our method not only computes the desired truth values of
the different conditions (i.e., atoms) in a decision, but it also
computes values for the (potentially non-Boolean) variables,
which can then be used as test cases. It can handle complex
interdependencies (“couplings”) between the conditions by
passing them on to the solver.
We apply our implementation in a case study of a Java Card
applet ﬁrewall. This ﬁrewall is modeled as a decision under
which access to an object is granted. Although a large set of
manually constructed tests exists, the automatically constructed
tests increase the code coverage. Using the model as a test
oracle, our test suite also detects an inconsistency between the
implementation and the speciﬁcation due to an update of the
reference manual which was not implemented.
1
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

Our test case generation method can be applied directly
to testing Boolean effects in stateless systems. Our approach
can also be combined with that of [19] to obtain test cases
for systems that are modeled as transition systems, obtaining
a test suite that exercises the guards of the state transitions.
Several papers on formal modeling for high assurance
Common Criteria evaluations exist [4], [18], [7]. Both in [18]
and in [7], the Java Card ﬁrewall is modeled and a theorem
prover is used to prove that the model satisﬁes the access
control policy. For a Common Criteria certiﬁcation it is not
necessary to formally link the model to the implementation. In
[7], the gap to the implementation is closed by manual code-
to-spec review. In contrast, we propose to close this gap by
generating test cases from the formal model and run them on
the implementation. In [16], the functional correctness of an
OS kernel is directly proven for the implementation. This gives
higher assurance of the correctness but increases the effort
tremendously. Our approach of integrating formal veriﬁcation
at a high abstraction level and model-based testing at the
implementation level gives a good trade-off between assurance
and cost.
The idea of generating test cases based on formal speciﬁca-
tions was already presented in [3]. Since then, a lot of research
has been done in this ﬁeld [21], [19], [14], [22]. In [14] a
survey on testing with model checkers is given. Using model
checkers, test cases are generated by deﬁning trap properties
in CTL formulas such that a counterexample represents a
test case. The disadvantage of this approach, however, is that
model checking can be quite resource intensive. Feeding the
guards of the transitions into an SMT-solver, as we do, is
potentially cheaper. The closest related work we are aware
of regarding test case generation is presented in [19]. The
authors compute test cases achieving MCDC on a speciﬁcation
by walking through the parse trees of the decisions. Depending
on the logical operator they decide what the expression of the
subtree should evaluate to. In contrast, our method (a) does
not stop at the Boolean level but also produces values for
non-Boolean variables appearing in the decisions, and (b) can
handle complex dependencies between the different parts of
the decision.
The rest of this paper is structured as follows. Section II
introduces background and notation, and gives an example.
Section III presents our quality assurance ﬂow based on
certiﬁcation and test case generation. Section IV discusses our
case study with the Java Card applet ﬁrewall, and Section V
draws conclusions and gives ideas for future work.
II.
PRELIMINARIES
A. Decisions and Speciﬁcations
Let V be a set of variables ranging over a domain D, and let
F be a set of function symbols. A term over V and F is deﬁned
inductively as follows: (a) any variable v ∈ V is a term, and
(b) if f ∈ F is a function symbol with arity n and a1,a2,...an
are terms, then f(a1,a2,...an) is a term. For simplicity of
the presentation, we assume that all variables have the same
domain D. E.g., D could be the domain of integers or bit-
vectors of length 32. Also, all functions f ∈ F are mappings
f : D × ... × D → D. A condition is a function mapping a
vector of terms to either true (⊤) or false (⊥). A decision
ϕ is deﬁned inductively as follows: (a) every condition is a
decision, and (b) if ϕ1 and ϕ2 are decisions, then ¬ϕ1 and
ϕ1 ∨ ϕ2 are decisions as well. The Boolean operators ¬ and
∨ have their usual semantics. Other Boolean operators can be
seen as shortcuts. A speciﬁcation is a set S = {ϕ1,ϕ2,...} of
decisions.
We write CoN(ϕ) = {c1,c2,...} for the set of all condition
nodes in the parse tree of decision ϕ, and ϕ[c|⊤] (ϕ[c|⊥]) for
the decision ϕ with condition node c ∈ CoN(ϕ) replaced by
⊤ (⊥).
B. Test Cases and Speciﬁcation Coverage
A test case for a speciﬁcation S = {ϕ1,ϕ2,...} is an
assignment t : V → D of values to all variables in V. We write
ϕ(t) or c(t) to denote the truth value (⊤ or ⊥) of decision
ϕ or condition node c ∈ CoN(ϕ) under assignment t. A test
suite is a set T = {t1,t2,...} of test cases.
Let ϕ be a decision, c ∈ CoN(ϕ) be a condition node, and
t : V → D be a test case. We say that c determines ϕ under t,
written det(c,ϕ,t), iff ϕ(t) ̸= ϕ[c|¬c(t)](t). That is, negating
the truth value of c changes the truth value of ϕ.
Test suite T achieves Masking Modiﬁed Condition Decision
Coverage [8] on speciﬁcation S iff for all ϕ ∈ S:
∃t,t′ ∈ T : ϕ(t)∧¬ϕ(t′)
(1)
and
∀c ∈ CoN(ϕ) : ∃t,t′ ∈ T :
c(t)∧¬c(t′)∧det(c,ϕ,t)∧det(c,ϕ,t′).
(2)
That is, every decision ϕ ∈ S must evaluate to true and to
false on some test. Also, every condition node c must evaluate
to true and to false while determining the truth value of ϕ.
Masking MCDC is also referred to as Correlated Active Clause
Coverage in the literature [1].
Unique cause MCDC [8] is a stricter variant. Whereas
masking MCDC allows other occurring conditions to evaluate
to different truth values for t and t′ as long as the determination
of c is preserved, unique cause MCDC requires the conditions
to be same for both t and t′. Expressed more formally, we say
that test suite T achieves unique cause MCDC on speciﬁcation
S iff for all ϕ ∈ S:
∃t,t′ ∈ T : ϕ(t)∧¬ϕ(t′)
(3)
and
∀c ∈ CoN(ϕ) : ∃t,t′ ∈ T :
c(t)∧¬c(t′)∧det(c,ϕ,t)∧det(c,ϕ,t′)∧
∀c′ ∈ {CoN(ϕ)\c} : c′(t) = c′(t′).
(4)
MCDC (either kind) can be calculated straightforward as
long as all conditions are independent. However, variables
may occur in more than one condition, and ﬁxing the truth
value of some conditions may determine others. If the truth
value of one condition always ﬂips when ﬂipping the truth
value of another condition, then these conditions are called
strongly coupled [9]. If it ﬂips in some but not in all cases,
they are called weakly coupled. E.g., (A > 5) and (A < 9) are
weakly coupled, whereas (A > 5) and (A ≤ 5) are strongly
2
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

Fig. 2: Example: Parse tree of a decision with test cases.
coupled. Due to coupled conditions, some test cases required
for achieving MCDC may be infeasible.
Another metric, closer to exhaustive testing, is Multiple
Condition Coverage (MCC). MCC requires that for every
decision, all possible combinations of the truth values of
its conditions are tested. This results in 2n test cases for n
conditions in a single decision.
C. Example
Fig. 2 depicts the parse tree of the decision ϕ = (x > 7∧x+
y ≤ 12)∨(x < 7∧y > 5). Even though the decision is small, it is
certainly not easy to test due to couplings between conditions.
The parse tree contains four condition nodes, but from the 24 =
16 possible truth value combinations, only 8 are satisﬁable.
They are listed as potential test cases t1 to t8 at the right side
of the ﬁgure.
The four test cases t2,t4,t7,t8 achieve masking MCDC as
follows. Condition node A is tested by t4 and t8: ϕ(t4) = ⊥ ̸=
ϕ(t4)[A|⊤] = ⊤, so A determines ϕ under t4. Analogously for
t8. In the same way, B is tested by t7 and t8, C by t2 and t7, and
D by t2 and t4. However, these four test cases do not achieve
unique cause MCDC because the pairs of test cases do not
only ﬂip the truth value of the tested condition node, but also
others.
Unique cause MCDC can be achieved by the seven test
cases t1,t2,t3,t4,t5,t6,t8. Condition node A is now tested by t3
and t8. We have that B(t3) = B(t8) = ⊤, C(t3) =C(t8) = ⊥, and
D(t3) = D(t8) = ⊥, so the truth value for the other condition
nodes remains the same when testing A. In a similar way,
condition node B is tested by t6 and t8, C by t1 and t2, and D
by t4 and t5.
III.
CERTIFICATION WITH TEST CASE GENERATION
This section presents our proposed quality assurance ﬂow,
which is based on certiﬁcation and automatic test case gener-
ation. It consists of the following four steps (see also Fig. 1):
1)
Construct a model of the system.
2)
Prove that the model of the system satisﬁes the
requirements.
3)
From the provenly correct model, automatically gen-
erate test cases.
4)
Run the tests on the implementation.
Obviously, this ﬂow does not give a formal proof of correctness
for the implementation. It only proves that the model is correct
with respect to the requirements. The test cases then verify that
the model has been implemented correctly.
A. Certiﬁcation
For certiﬁcation under high assurance levels, like Common
Criteria EAL6 or EAL7, formal models of the speciﬁcation and
of the design are required at different levels of detail, depend-
ing on the level of the certiﬁcation. These models describe how
the product implements certain parts of the speciﬁcation. For
Common Criteria, the requirements for formal security policy
models are given in [6]. The ‘Bundesamt f¨ur Sicherheit in der
Informationstechnik’, one of the certiﬁcation bodies, published
a guideline for the evaluation of security policy models [17].
The guideline suggests to use formal tools such as theorem
provers or model checkers. We use model checking because
these tools work fully automatically. A model checker takes a
formal speciﬁcation and a model as input. It returns true if the
model satisﬁes the speciﬁcation, giving a mathematical proof
of correctness. Otherwise, if the model does not satisfy the
speciﬁcation, the model checker returns a counterexample [11].
We use the model checker NuSMV [10] for certiﬁcation,
as described in [4] for a smart card system. NuSMV has a
proprietary modeling language, deﬁning a ﬁnite state machine.
A model consists of state and input variables, and of transitions
deﬁning how an input leads from one state to the next states.
The rules on the transitions can be complex logical decisions.
In the next section we will explain how to automatically
generate test cases from complex logical decisions with high
coverage.
B. Test Case Generation
We created a tool to compute a test suite T that achieves
MCDC on a speciﬁcation S. It uses the SMT-solver Z3 [12] to
compute test cases as satisfying assignments of the constraints
that have to be fulﬁlled by the tests. The decisions of the
speciﬁcation must be given in SMT-LIB2 format [2]. Our tool
builds a parse tree of the decisions so that condition nodes
can be found and replaced by ⊤ or ⊥ easily. Next, it passes
the constraints of Eq. 2 to the solver, one after the other, for
all ϕ ∈ S and c ∈ CoN(ϕ). For each satisﬁable query, we
can extract a pair of test cases t,t′ as a satisfying assignment
and add it to the test suite T. Variables which are irrelevant
for the satisfying assignment will get a value which is either
random or deﬁned by the user. Unsatisﬁable cases are reported
to the user, because they usually indicate inconsistencies or
redundancies in the decision. Before adding a new pair of test
cases, we check if T already contains test cases that satisfy
the constraints. This reduces the overall number of test cases.
Finally, the test suite T is written into a simple text ﬁle, which
can be parsed by a test adapter. Our tool supports masking
MCDC, unique cause MCDC, and MCC.
IV.
CASE STUDY: JAVA CARD FIREWALL
We applied our test case generation tool to the guard
expressing the access rules in the formal model of the Java
Card applet ﬁrewall, as speciﬁed in Section 6.2.8 of the JCRE
speciﬁcation, version 3 [20]. As a result, we obtain a set of
test cases satisfying the MCDC criterion with respect to the
guard in the model. Using MCDC ensures that each sub-item
of the speciﬁcation independently affects the access decision.
After running the test suite it can then be assured, provided
that none of the SMT-solver calls were unsatisﬁable, that every
3
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

Fig. 3: The Java Card Runtime Environment.
explicit requirement from the speciﬁcation is implemented and
evaluates, for the state which is used for testing, to the expected
outcome. The generation of the test suite for the guard,
consisting of 223 conditions, takes less than a minute and
results in 205 test cases before removing duplicates and 127
test cases after the elimination. As some variables like the one
to identify the current bytecode, the current context, the object
owner and so on, occur in more than one condition, some SMT-
solver calls were unsatisﬁable due to coupled conditions.
A. Java Card Applet Firewall Model
Whereas in standard Java every applet runs on its own
instance of a virtual machine, the Java Card virtual machine
must be able to deal with several (independent) applets. The
Java Card applet ﬁrewall ensures that applets cannot randomly
access data belonging to other applets, but only in restricted
cases. The applet ﬁrewall is part of the Java Card virtual
machine (JCVM) (see Fig. 3) and checks every single access
according to the JCRE speciﬁcation [20].
Our model of the Java Card ﬁrewall (see Fig. 4) consists
of only two states: idle and locked. As long as the
ﬁrewall is in the idle state, it performs the required checks
for the Java Card virtual machine. If an access is denied, a
SecurityException is thrown. The JCVM then has to handle
this exception, e.g. reset a started transaction, while the applet
ﬁrewall doesn’t do anything. This situation we have modeled
by introducing the second state called locked. Conceptually,
this behavior is very simple. The difﬁculty for testing the
ﬁrewall stems from the very complicated decision when to
allow access.
Fig. 4: Abstract model of the Java Card applet ﬁrewall.
The access rules are modeled by two transitions. The ﬁrst
transition, representing access allowed, is a self loop of the idle
state. The second transition is a deny all transition, going from
idle to locked with a lower priority. This realization ensures
that every access, which is not explicitly allowed, is denied.
The guard of the self loop is a formalization of Section 6.2.8 of
the JCRE speciﬁcation [20] such that a satisfying assignment
for the formula corresponds to an access which is allowed.
Example 1: Section 6.2.8.7 of the JCRE speciﬁcation [20]
speciﬁes access rules for the bytecode athrow by saying:
•
“If the object is owned by an applet in the currently
active context, access is allowed.
•
Otherwise, if the object is designated a Java Card RE
Entry Point Object, access is allowed.
•
Otherwise, if the Java Card RE is the currently active
context, access is allowed.
•
Otherwise, access is denied.”
This can be translated into a formula
(bytecode = 7)∧
((Owner = FLAG CurrentlyActiveContext)∨
(FLAG entryPointJCREObject)∨
(FLAG CurrentlyActiveContext = 0)),
(5)
where (bytecode = 7) checks if the bytecode equals athrow,
and the remaining three lines correspond to the ﬁrst three
bullets copied from the JCRE speciﬁcation, with the constant
0 encoding the JCRE context. This example illustrates that
formulating the speciﬁcation of the ﬁrewall is (for the most
part) rather straightforward.
B. Evaluation Setting
We compare the quality of the test cases created automati-
cally using our tool to that of the JCTCK, a hand-crafted test
suite. The hand-crafted tests are given as Java Card applets.
They test the whole implementation of the Java Card runtime
environment and not only parts of it. The test harness for
these tests simply runs the applets. In contrast to that, our
test adapter runs the test cases as module tests implemented
in C, which is the language the Java Card operating system is
programmed in. It sets up the memory as required from the
test case and calls the relevant bytecode implementation which
performs the necessary ﬁrewall checks. If access is denied, a
security exception is thrown, otherwise access was allowed.
To evaluate the code coverage for both test suites, the
functions belonging to the Java Card applet ﬁrewall were
instrumented using a code coverage tool. The code was in-
strumented in a way such that covering all instrumentations
corresponds to condition coverage plus basic block coverage.
After running the test suites, analysis can be performed on the
collected data and the code coverage can be compared.
Of course, the test cases do not only have the purpose of
covering as much code as possible, but also to check if the
applet ﬁrewall’s behavior conforms to the JCRE speciﬁcation.
The provided JCTCK installs and runs the applets and the
applets themselves check if the result corresponds to the
expected outcome. The test adapter for our automatically
constructed test cases calculates the expected result, namely
either access allowed or denied, by evaluating the decision
in the model on the test case input data. If the access is
denied, a security exception is thrown by the implementation
4
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

TABLE I: Instrumentations and achieved coverage
test suite
covered / total
percentage
JCTCK
64/71
90%
our test suite
63/71
89%
together
68/71
96%
(a) JCTCK coverage
(b) Additional coverage on the
previously uncovered code
Fig. 5: Additional coverage on previously from the JCTCK
uncovered code achieved by our test suite.
and caught by the test adapter. The test adapter ﬁnally checks
for discrepancies between occurred and expected exceptions.
Our test approach is quite different from that of the JCTCK,
so we are going to evaluate only results which are targeted
from both test adapters. Moreover, we will explicitly mention
if certain test goals can not be reached due to limitations
stemming from the type of test. One such limitation is, for
example, that a Java Card applet is restricted in its object
creation.
C. Code Coverage Results
As we consider Section 6.2.8 of the JCRE speciﬁcation
as base for our test suite, we only evaluate the coverage in
the functions of the applet ﬁrewall dealing with this Chapter.
In some of the functions, the end can not be reached due to
thrown exceptions. The total number of 78 instrumentations
for the coverage is reduced by those, such that a coverage
of all remaining 71 instrumentations corresponds to 100%
coverage. After running the test suites and storing the results
for each test suite, the code coverage investigations reveal that
neither of the test suites did achieve a full condition plus basic
block coverage of 100% (see Table I). However, when using
both test suites it is possible to increase the coverage of the
JCTCK by six percent, from 90% to 96%. This means that
the automatically generated test suite covers 60% of the cases
that are missed by the JCTCK (see Fig. 5).
As there are only a few uncovered parts of the source code
(see Table II), we will now explicitly discuss every one of
them. The ﬁrst condition that was not fully covered by our
automatically generated test suite was a null pointer check.
Some of the ﬁrewall functions perform a null pointer check
TABLE II: Conditions which were not fully covered
condition
JCTCK
our test suite
is object a null pointer
-
not to true
is object a global array
not to true
-
is object a shareable object
not to false
not to false
access of shareable object
not to false
not to false
before using the pointer. This condition is impossible for our
test suite to cover, because our test suite is generated based
on Section 6.2.8 of the JCRE speciﬁcation and null pointers
are not mentioned there. Therefore, no test case is generated
targeting null pointers.
A check if the accessed object is a global array is covered
by our automatically generated test suite but not by the
JCTCK: The JCTCK was not able to make the condition in the
source code evaluate to true. The reason is that the condition is
disjuncted with a check if the object is a temporary entry point
object in the source code. As there is only one global array
in the Java Card implementation, namely the APDU buffer,
and this one is also a temporary entry point object, the short
circuit evaluation in the C semantics renders it impossible to
let the global-array-check evaluate to true. In contrast to that,
our test adapter sets up the memory as required without the
restrictions for a Java Card applet and was therefore able to
generate an object which is no temporary entry point object
but a global array.
Neither of the two test suites was able to make the checks
regarding shareable objects evaluate to false. This is due to
implementation speciﬁcs, which perform a check if the class
or interface is shareable already in the implementation of
the bytecode itself before calling the actual ﬁrewall function.
Therefore, the ﬁrewall function is only entered if the condition
evaluates to true. Note that in the implementation the ﬁrewall
is not a monolithic function isolated from the rest of the code,
but rather an optimized implementation taking advantages of
available code.
So, in summary, the only parts of the ﬁrewall which are
not covered by both test suites taken together are conditions
that can only evaluate to ﬁxed truth values due to checks that
are made elsewhere in the code. Beside these conditions, full
condition and basic block coverage is achieved on the code
relevant for Section 6.2.8 of the JCRE speciﬁcation.
D. Error Detection Results
All tests from the JCTCK relevant for the Java Card applet
ﬁrewall passed with success. From our automatically generated
test suite, however, the result of three test cases did not match
the outcome of the oracle. Two of those were false positives:
The ﬁrewall didn’t deny access to objects with some attribute
combinations because other parts of the implementation ensure
that these attribute combinations can never occur. The third
failing test case detected an actual inconsistency. It tested an
access rule from Section 6.2.8.9, namely “Otherwise, if the
object is designated a Java Card RE Entry Point Object,
access is allowed”. The result was a Security Exception,
whereas the oracle expected that the access would be allowed
because of this rule. An inspection of previous versions of
the speciﬁcations conﬁrmed that this access rule was added to
the speciﬁcation in version 2.2 [15], however, a review of the
source code showed, that this modiﬁcation of the speciﬁcation
was not implemented. Due to the limitations for object creation
via Java Card applets it was also not possible to create a test
case for the JCTCK which tests this behavior on the system
level, so this inconsistency remained undiscovered until now.
5
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

V.
CONCLUSION AND FUTURE WORK
In this paper, we have presented an automatic test case
generation technique to achieve Modiﬁed Condition Decision
Coverage on complex logical decisions. We implemented this
approach in a test case generation tool using an SMT-solver
to compute tests as satisfying assignments for the constraints
that have to be satisﬁed to meet the coverage criterion. Our
approach can handle complex couplings between different
parts of the decision by delegating them to the SMT-solver.
Our test case generation method can complement certiﬁcation
in the software development process by taking the existing
models and closing the link from the requirements down to
the implementation.
We evaluated our approach on an implementation of the
Java Card operating system with focus on the applet ﬁrewall.
Our tool produced only a small amount of test cases, but was
able to improve the code coverage (condition + basic block
coverage) of the existing test suite so that now all reachable
locations and cases are covered. The additional tests produced
by our tool also revealed that an update of the speciﬁcation was
not implemented. This conﬁrms that different levels of testing
are useful. System tests have to be complemented by unit
and module tests because certain scenarios cannot (easily) be
produced in the integrated system. The MCDC criterion proved
to be effective in our setting because it tests the different parts
of the decisions in isolation without producing too many test
cases.
In the future, we plan to extend our test case generation
approach and tool to deal with stateful models directly. This
will relieve the user from writing a test adapter that brings the
system into the desired state before the tests can be applied.
REFERENCES
[1]
P. Ammann, A. J. Offutt, and H. Huang, “Coverage criteria for log-
ical expressions,” in International Symposium on Software Reliability
Engineering (ISSRE’03).
IEEE, 2003, pp. 99–107.
[2]
C. Barrett, A. Stump, and C. Tinelli, “The Satisﬁability Modulo
Theories Library (SMT-LIB),” www.SMT-LIB.org, 2010.
[3]
G. Bernot, M. C. Gaudel, and B. Marre, “Software testing based
on formal speciﬁcations: a theory and a tool,” Software Engineering
Journal, vol. 6, no. 6, 1991, pp. 387–405.
[4]
G. Beuster and K. Greimel, “Formal security policy models for smart
card evaluations,” in Annual ACM Symposium on Applied Computing
(SAC’12).
ACM, 2012, pp. 1640–1642.
[5]
Common Criteria for Information Technology Security Evaluation Ver-
sion 3.1 Revision 3 – Part 1: Introduction and general model, July
2009.
[6]
Common Criteria for Information Technology Security Evaluation Ver-
sion 3.1 Revision 3 – Part 3: Security assurance components, July 2009.
[7]
B. Chetali and Q. H. Nguyen, “Industrial use of formal methods for a
high-level security evaluation,” in International Symposium on Formal
Methods (FM’08), ser. LNCS, vol. 2404. Springer, 2008, pp. 198–213.
[8]
J. J. Chilenski, “An investigation of three forms of the modiﬁed
condition decision coverage (MCDC) criterion,” DTIC Document, Tech.
Rep., 2001.
[9]
J. J. Chilenski and S. P. Miller, “Applicability of modiﬁed con-
dition/decision coverage to software testing,” Software Engineering
Journal, vol. 9, no. 5, 1994, pp. 193–200.
[10]
A. Cimatti et al., “NuSMV version 2: An opensource tool for symbolic
model checking,” in Computer-Aided Veriﬁcation (CAV’02), ser. LNCS,
vol. 2404.
Springer, 2002, pp. 359–364.
[11]
E. M. Clarke, O. Grumberg, and D. Peled, Model checking. MIT Press,
1999.
[12]
L. M. de Moura and N. Bjørner, “Z3: An efﬁcient SMT solver,” in
Tools and Algorithms for the Construction and Analysis of Systems
(TACAS’08), ser. LNCS, vol. 4963.
Springer, 2008, pp. 337–340.
[13]
R. T. C. for Aeronautics (RTCA), “RTCA-DO-178B: Software consid-
erations in airbone systems and equipment certiﬁcation,” Dec. 1992.
[14]
G. Fraser, F. Wotawa, and P. E. Ammann, “Testing with model
checkers: a survey,” Software Testing, Veriﬁcation and Reliability,
vol.
19,
no.
3,
Sep.
2009,
pp.
215–261.
[Online].
Available:
http://dx.doi.org/10.1002/stvr.v19:3
[15]
S. M. Inc., “Java Card TM 2.2 Runtime Environment (JCRE) Speciﬁ-
cation,” 2006.
[16]
G. Klein et al., “seL4: formal veriﬁcation of an operating-system
kernel,” Communications of the ACM, vol. 53, no. 6, 2010, pp. 107–115.
[17]
H. Mantel, W. Stephan, M. Ullmann, and R. Vogt, Guideline for the
Development and Evaluation of formal security policy models in the
scope of ITSEC and Common Criteria Version 2.0, December 2007.
[18]
S. Motre and C. Teri, “Using B method to formalize the java card
runtime security policy for a common criteria evaluation,” in National
Information Systems Security Conference (NISSC’00), 2000.
[19]
J. Offutt, S. Liu, A. Abdurazik, and P. Ammann, “Generating test
data from state-based speciﬁcations,” Software Testing, Veriﬁcation and
Reliability, vol. 13, 2003, pp. 25–53.
[20]
Oracle, “Java Card 3 Platform Runtime Environment Speciﬁcation,
Classic Edition Version 3.0.4,” 2011.
[21]
T. J. Ostrand and M. J. Balcer, “The category-partition method for
specifying and generating fuctional tests,” Communications of the ACM,
vol. 31, no. 6, 1988, pp. 676–686.
[22]
E. Weyuker, T. Goradia, and A. Singh, “Automatically generating test
data from a boolean speciﬁcation,” IEEE Transactions on Software
Engineering, vol. 20, no. 5, 1994, pp. 353–363.
6
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-307-0
VALID 2013 : The Fifth International Conference on Advances in System Testing and Validation Lifecycle

