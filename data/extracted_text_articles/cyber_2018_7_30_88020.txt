A Methodology for Synthesizing Formal Speciﬁcation Models From Requirements for
Reﬁnement-based Object Code Veriﬁcation
Eman M. Al-qtiemat∗, Sudarshan K. Srinivasan∗, Mohana Asha Latha Dubasi∗, Sana Shuja†
∗Electrical and Computer Engineering, North Dakota State University,
Fargo, ND, USA
†Department of Electrical Engineering, COMSATS University,
Islamabad, Pakistan
Emails: ∗eman.alqtiemat@ndsu.edu, ∗sudarshan.srinivasan@ndsu.edu, ∗MohanaAshaLatha.Duba@ndsu.edu,
†SanaShuja@comsats.edu.pk
Abstract—Formal veriﬁcation has become the bedrock for ensur-
ing software correctness when dealing with safety-critical systems.
One of the biggest obstacles in applying formal techniques to
commercial systems is the lack of formal speciﬁcations. Software
requirements are expressed only in natural language. We present
a structured approach for synthesizing formal models from
natural language requirements. Synthesizing formal speciﬁcation
models from natural language requirements is a hard problem.
Our approach is structured in that, while our procedures do most
of the work in the synthesis process, it allows for structured input
from the domain expert. The uniqueness of this paper is the novel
approach that can synthesize natural language requirements
to formal speciﬁcations that are useful for reﬁnement-based
veriﬁcation, a formal veriﬁcation technique that is very effective
for the safety-critical Internet of Things (IoT) embedded systems.
A number of safety requirements for insulin pumps have been
used to demonstrate the effectiveness of the approach.
Keywords–requirements analysis; safety-critical IoT embedded
devices; formal model; formal veriﬁcation.
I.
INTRODUCTION
Ensuring the correctness of control software used in safety-
critical embedded devices is still an ongoing challenge. For
example, from 2001 to 2017, the Food and Drug Administra-
tion (FDA) has issued 54 Class-1 recalls on infusion pumps
(medical devices used to deliver controlled doses of ﬂuid
medications to patients intravenously) due to software issues
[1]. Class-1 recalls are applied to medical device models whose
use can cause serious adverse health consequences or death.
With the advent of IoT, such safety-critical embedded devices
incorporate a whole slew of additional functionality to interface
with the network and other components, in addition to their
core control functions. These additional functions signiﬁcantly
exacerbate the challenge of ensuring that the core functionality
of the control software is correct and intact.
The use of formal veriﬁcation has become an industry stan-
dard when addressing software correctness of safety-critical
devices. There are many success stories and commercial adop-
tion of formal veriﬁcation processes. Examples include Intel
[2], Microsoft [3] and [4], and Airbus [5].
Reﬁnement-based veriﬁcation [6] is a formal veriﬁcation
technology that has been demonstrated to be applicable to
the veriﬁcation of embedded control software at the object-
code level [7]. In formal veriﬁcation and reﬁnement-based
veriﬁcation, typically the design artifact to be veriﬁed is called
the implementation and the speciﬁcation is a formal model
that captures the correct functionality of the implementation.
The goal of reﬁnement-based veriﬁcation is to mathematically
prove that the implementation behaves correctly as deﬁned
by the speciﬁcation. In reﬁnement-based veriﬁcation, both the
implementation and speciﬁcation are modeled as transition
systems.
One of the key features of reﬁnement-based is the use of
reﬁnement maps, which are functions that map implementation
states to speciﬁcation states. In practice, these reﬁnement maps
have a very favorable property in that they abstract out behav-
iors of the implementation not relevant to the speciﬁcation, but
only after determining that these additional behaviors do not
actually impact the behaviors of the implementation relevant to
the speciﬁcation. This property of reﬁnement maps makes the
reﬁnement-based veriﬁcation very suitable for the veriﬁcation
of control software used in IoT devices as reﬁnement maps
can be used to abstract out the additional functionality of
software in IoT devices; again, only after determining that
these additional functionality are not impacting the behavior
of the core functionality of the implementation as deﬁned by
the speciﬁcation.
One of the crucial challenges in applying reﬁnement-based
veriﬁcation to commercial devices is the availability of formal
speciﬁcations. For commercial devices, typically, the speciﬁ-
cation of a device is given as natural language requirements.
There are many approaches towards transforming natural lan-
guage requirements to formal speciﬁcations, however none
targeted towards reﬁnement-based veriﬁcation. In this paper,
we present a methodology for transforming natural language
requirements into formal speciﬁcations that can be used in the
context of reﬁnement-based veriﬁcation.
The rest of the paper is organized as follows. An overview
of the background is presented in Section II. Section III details
the related work. A formal model describing the synthesis
procedure is presented in Section IV. Section V details the
case study. Section VI gives the veriﬁcation results for the
proposed formal model. Conclusions and direction for future
work are noted in Section VII.
II.
BACKGROUND
This section explores the parsing tree and the deﬁnition of
transition systems as main topics related to our work.
94
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

A. Parsing tree
A parse tree is an ordered tree that pictorially represents
how words in a sentence are connected to each other. The
connection between each word in the sentence gives the syntac-
tic categories for the sentence. The parsing process represents
the syntactic analysis of a sentence in natural language. For
example, when the parsing process is applied on a simple
sentence like ”Adam eats banana”, the parse tree categorizes
the two parts of speech: N for nouns (Adam, banana) and V
for the verb (eats). Here N, V are the syntactic categories.
The parsing process is considered to be a preprocessing
step for some applications, where natural language should be
converted into other forms. Usually, the system requirements
are written in natural language, which needs to be converted
into a structural form that can then be used to create the
transition system(s) (explained in Section II-B). Enju [8] is an
English consistency-based parser, which can process very long
complex sentences like system requirements using an accurate
analysis (the accuracy relation is around 90 percent of news
articles and bio-medical papers). Besides, Enju is a high-speed
parser with less than 500 msec per sentence. The output is the
resulting tree in an XML format which is considered to be
one of the commonly used formats by various applications.
As will be described later, the case study used to describe
the proposed methodology is from the bio-medical area, Enju
was the perfect tool as the natural language processing (NLP)
parser.
S
VP
NP
N
ball
D
the
V
hit
N
John
Figure 1. A simple example of a parsing tree using Enju parser [9].
Figure 1 shows a simple tree example using Enju. Here,
Enju distinguishes between terminal nodes (John is a terminal
node) and non-terminal nodes (VP is a verb phrase). The
abbreviations of the syntactic categories of Figure 1 are: S
stands for sentence (the head of the tree), N stands for noun,
VP stands for verb phrase (which is a subtree), NP stands
for noun phrase, V stands for verb, and ﬁnally D stands for
determiner (comes with noun phrases). Using these syntactic
categories, we have developed an extraction technique that
would help in translating the natural language to a formal
model of the requirements.
B. Transition systems
The implementation and speciﬁcation in reﬁnement-based
veriﬁcation are represented using Transition Systems (TSs) [6],
[7]. The deﬁnition of a TS is given below:
Deﬁnition 1: A TS M = ⟨S, R, L⟩ is a three tuple in
which S denotes the set of states, R ⊆ SXS is the transition
relation that provides the transition between states, and L is a
labeling function that describes what is visible at each state.
Figure 2. An example of a transition system (TS).
An Atomic Proposition (AP) is a statement that can be
evaluated to be either true or false. The labeling function maps
state to the APs that are true in every state. An example of
a TS is shown in Figure 2. Here S = {IBO, SPM, SYNC,
INDV}, R = {(IBO, SPM), (SPM, SYNC), (SYNC, INDV),
(INDV, SYNC), (INDV, SPM), (IBO, INDV)} and, L(SPM)
represents the atomic propositions that are true for the SPM
state. Similarly, labeling function can be applied to all the
states in this TS.
III.
RELATED WORK
In the last few years, there has been a tremendous growth
in ﬁnding the optimal technique of requirement transformation
into a formal model. While most of them proposed system-
driven models, our approach is user-driven to ensure a safe
product.
Automatic Requirements Speciﬁcation Extraction from
Natural Language (ARSENAL) [10] is a system based frame-
work that applies some semantic parsers in multi-level to
get the grammatical relations between words in the require-
ment. ARSENAL transforms natural language requirements
into formal and logical forms expressed in Symbolic Analysis
Laboratory (SAL) (a formal language to describe concurrent
systems), and Linear Temporal Logic (LTL) (a mathematical
language that describes linear time properties) respectively.
The LTL formulas are then used to build the SAL model.
Multiple validation checks are applied on Natural Language
Processing (NLP) stage and LTL formulas to check for their
correctness. However, ARSENAL records some inaccuracies
in NLP stage that need a user intervention.
Aceituna et al. [11] have proposed a front end frame-
work that builds a model to exhibit the system behavior
(for synchronous systems only) and help in creating temporal
logic properties automatically. This framework can be used
before applying the model checking technique, it exposes
accidental scenarios in the requirements. The framework is
designed in a manner that helps in understanding the errors in
a non-technical manner for users who do not have a formal
background. In contrast, our work does not need the temporal
logic in deﬁning the speciﬁcations for a model.
A semantic parser has been developed by Harris [12] to
extract a formal behavioral description from natural language
speciﬁcations. The proposed semantic parser was employed
to extract key information describing bus transactions. The
natural language descriptions are then converted to verilog (a
hardware description language) tasks.
Kress-Gazit et al. [13] have proposed a human-robot inter-
face to translate natural language speciﬁcation into motions.
95
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

This interface allows a user to instruct the robot using a
controller. LTL formulas are employed to formalize the desired
behavior requested by the user.
An approach supporting property elucidation (called PRO-
PEL) has been introduced by Smith et al. [14], it provides
templates that capture properties for creating property pattern.
Natural language and ﬁnite state automation are used to
represent the templates.
Two approaches have been proposed by Shimizu [15] to
solve the ambiguity of natural language speciﬁcations using
formal speciﬁcation. The ﬁrst approach simpliﬁes the formal
speciﬁcation development for the popular PCI bus protocol
and the Intel Itanium bus protocol. The second approach
explains how formal speciﬁcations can help in automating
many processes that are now done manually.
A natural language parsing technique has been used with
the default reasoning, which is a requirement formalism to
support requirement development, this work helps stakeholders
to easily deal with requirements in a formal manner, in addi-
tion, a method has been proposed for discovering any existed
requirements inconsistencies. A prototype tool called CARL
was used for implementation and veriﬁcation by Zowghi et
al. [16].
Gervasi et al. [17] have also worked on solving the
requirement’s inconsistencies issues by using a well-known
formalism called monotonic logic, it has been used especially
for requirement’s transformation. Multiple natural language
processing tools [18]–[21] in additional to grammatical anal-
ysis methodologies for requirement’s development have been
done to get requirements in a formal manner.
However, the main advantages of our work over prior
algorithms in requirements engineering is its ability to generate
a full formal model directly from natural language require-
ments by an expert supervision to emphasis on the safety
transformation. Also, our work does not require that the expert
user know any temporal logic languages.
IV.
FORMAL MODEL SYNTHESIS PROCEDURE
The ﬁrst step to computing the TSs is to extract the
APs from the requirements. We have developed three Atomic
Proposition Extraction Rules (APERs) that work on the parse
tree of the requirement obtained from Enju. The resulting APs
are then used to compute the states and transitions. The APERs
are described next.
A. Atomic Proposition Extraction Rule 1 (APER 1)
APER 1 is based on the hypothesis that noun phrases in a
requirement correspond to APs. Each subtree of the parse tree
with an NX root (called an NX head) corresponds to a noun
phrase and hence an AP. Therefore, APER 1 computes the
subtrees corresponding to NX heads. If NX heads are nested,
then the highest-level NX head is used to compute the AP. The
terminal nodes of the subtree are conjoined together to form
the noun phrase. APER 1 returns AP-list, which is the set of
APs corresponding to a parse tree.
We now describe the procedure corresponding to APER 1
in detail. Firstly, AP-List is initialized to the empty set (line 1).
The procedure then iterates through each terminal node n (line
2). The head of a node is its parent. If a terminal node is part of
an NX subtree, its level two head will be marked as NX, which
Procedure 1 APER1
Require: Parse-tree
1: AP-list ← ∅ ;
2: for each n ∈ TerminalNodes(Parse-tree) do
3:
Start-cat = head(head(n));
4:
if Start-cat = NX then
5:
X = Sub-tree(Start-cat);
6:
while (head(X) = NX ) ∨ (head(X) = COOD)
∨ (head(X) =NX-COOD ) do
7:
X = Sub-tree(head(X));
8:
AP-list ← AP-list ∪ TerminalNodes(X) ;
is checked in line 3. The level-two NX node of the terminal
node is stored in variable State-cat. If the Start-cat is of NX
category (line 4), a function called Sub-tree is used to get the
resulting subtree (line 5), which is stored in variable X. A while
loop is used to traverse the tree of X upwards checking if the
head syntactic category is NX or COOD or NX-COOD (line
6). Only when one of the conditions is satisﬁed the subtree
is stored in X (line 7). The terminal nodes of the resulting
sub tree ’X’ will be added to AP-List as a new suggested AP
(line 8). Figure 3 gives a sub tree example for APER 1. Note
that APER 1 may result in the same AP being duplicated.
Duplicates are checked and removed from the AP list in the
overall approach.
Figure 3. An Enju parsing tree portion shows some resulting APs by
applying APER 1.
As shown in Figure 3, the terminal nodes ’the’ and ’prim-
ing’ does not have head(head(n)) = NX. The ﬁrst terminal node
that has the NX category is ’process’. Traversing upwards,
the NX related categories gives us the subtree which contains
’priming process’. This now constitutes the ﬁrst AP for this
part of requirement. Applying the APER 1 rule on the visible
part of the sentence in Figure 3 gives us the following APs:
’priming process’, ’suspended basal proﬁle’, ’basal proﬁle’,
and ’temporary basal’.
96
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

B. Atomic Proposition Extraction Rule 2 (APER 2)
APER 2 and APER 3 correspond to the two other parse tree
patterns that also lead to noun phrases. APER 2 examines the
parse tree for noun categories along with its upper verb head.
APs will be the conjoined terminal nodes of the resulting sub
tree. APER 2 states that APs are the terminal nodes under the
head VP passing through NX (or its related phrases such as
NX-COOD, COOD), NP (or its related phrases NP-COOD,
COOD), and VX phrase. APER 2 is built on top of APER 1
Procedure 2 APER 2
Require: Parse-tree
1: AP-list ← ∅ ;
2: for each n ∈ TerminalNodes(Parse-tree) do
3:
Start-cat = head(head(n));
4:
X1 ← ∅;
5:
if Start-cat = NX then
6:
X = Sub-tree(Start-cat);
7:
while (head(X) = NX ) ∨ (head(X) = COOD)
∨ (head(X) =NX-COOD ) do
8:
X= Sub-tree(head(X));
9:
while (head(X) = NP) ∨ (head(X) = COOD)
∨ (head(X) = NP-COOD) do
10:
X1 = Sub-tree(head(X));
11:
if (head(X1) = VX) ∧ (head(head(X1)) = VP) then
12:
X = Sub-tree(head(head(X1));
13:
else
14:
if (head(X1) = VP) then
15:
X = Sub-tree(head(X1);
16:
AP-list ← AP-list ∪ TerminalNodes(X);
to get atomic propositions for requirements that APER 1 is
not able to collect. While APER 1 looks only for APs that are
noun phrases, APER 2 looks for noun phrases that are further
characterized by verb phrases. For example, if APER 1 ﬁnds
the AP ”suspended basal delivery,” APER 2 will ﬁnd ”resume
the suspended basal delivery.”
APER 1 and APER 2 have the same algorithmic ﬂow until
ﬁnding the sub tree of X that is the top NX head (line 8).
However, APER 2 does not consider the resulting X to be
an AP like APER 1 does. Instead, X is the input of the next
step. A while loop is used to search if the head category of
X is in NP category or one of its related phrases (line 9).
Only when the while loop condition is true, the new sub-tree
is stored temporarily in the variable X1 (line 10), where X1 is
a temporary variable initialized to null (line 4). This ensures
that X does not change in this step for future use. The search
for VX and VP categories is to be performed only when X1
is not null.
On the successful completion of NP category search,
the search for VX category followed by VP categories is
performed (line 11). When the if condition is satisﬁed, X is
updated with the new sub-tree (line 12). In the case of failure
of the if condition in line 11, a new search for VP category
is performed on the head of NP category sub-tree (line 14).
On success, X is updated with the new sub-tree (line 15). If
either of the if conditions (line 11 and line 14) fail, then X will
remain as the sub-tree of NX category. The terminal nodes of
the resulting subtree in X is appended to the AP-list (line 16).
Figure 4 shows a resulting sub tree example by applying APER
2. Figure 4 shows that the procedure starts from left to right
Figure 4. An Enju parsing tree portion shows some resulting APs by
applying APER 2.
looking for level two NX nodes and traversing upward until
higher NX nodes are accounted for. NP phrases are selected
to expand the tree. Then choosing the upper level which is VP
in this particular case (sometimes its VX → VP). The output
of APER 2 for this tree portion is ’override the current basal
delivery with a temporary basal’, and ’changing existing basal
proﬁles’.
C. Atomic Proposition Extraction Rule 3 (APER 3)
APER 3 is built on top of APER 2, it explores the verb head
levels in the parse tree like APER 2, but APER 3 eliminates
some verb phrases that is not part of APs. This elimination
is done based on the head of the VP category as illustrated
in Procedure 3 below. APER 3 and APER 2 have the same
stream up to line 10. The algorithm starts with initializing
temporary variables X1 and Y to null (line 4). The search for
syntactic categories start with the top NX phrase (line 7) and
the resultant sub tree is stored in X (line 8). Then, the search
begins for the top NP phrase (line 9) and the resultant sub tree
is stored in X1 (line 10) since the sub tree in X is needed
for future use. As in APER2, the search for either VX phrase
followed by VP phrase or just VP phrase is performed on X1
and the resultant sub tree is stored in Y (lines 11-15). If and
only if Y is not empty then the check on the head syntactic
category is performed to ensure that it does not contain CP or
COOD categories. In this case, X gets only the right child (line
16-18) i.e. the left child of Y is pruned. On the other hand,
if Y has a CP or COOD head, X value will be updated to be
equal to Y (line 20). Finally, terminal nodes of the resulting
sub tree X will be saved in the AP-list as a new AP. The
pruning process (line 18) is done to remove some action verbs
which are not part of an AP.
Like APER2, APER3 also works on verb head categories.
However, APER3 has some pruning techniques to remove parts
of the sentence that should not be part of an AP. Consider the
snippet in Figure 5, the sub tree ”issue an alert” is subjected to
left branch pruning to remove the verb ’issue’ since such verbs
do not add value in the AP. According to the algorithm, since
the head node of VP is COOD, only the terminal nodes of the
97
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

Procedure 3 APER 3
Require: Parse-tree
1: AP-list ← ∅ ;
2: for each n ∈ TerminalNodes(Parse-tree) do
3:
Start-cat = head(head(n));
4:
X1 ← ∅ , Y ← ∅;
5:
if Start-cat = NX then
6:
X = Sub-tree(Start-cat);
7:
while (head(X) = NX) ∨ (head(X) = COOD)
∨ (head(X) =NX-COOD ) do
8:
X = Sub-tree(head(X));
9:
while (head(X) = NP) ∨ (head(X) = COOD)
∨ (head(X) = NP-COOD) do
10:
X1 = Sub-tree(head(X));
11:
if (head(X1) = VX) ∧ (head(head(X1)) = VP) then
12:
Y = Sub-tree(head(head(X1));
13:
else
14:
if (head(X1) = VP) then
15:
Y = Sub-tree(head(X1);
16:
if (Y ̸= ∅) then
17:
if head(Y ) ̸= CP) ∧ (head(Y ) ̸= COOD) then
18:
X = Sub-tree(RightChild(Y ));
19:
else
20:
X = Y ;
21:
AP-list ← AP-list ∪ TerminalNodes(X);
right child are considered as an AP. Applying APER 3 on the
visible part of the requirement in Figure 5 gives the following
APs: ’pump’, ’an alert’, and ’deny the request’. The proposed
Figure 5. An Enju parsing tree portion shows some resulting APs using
APER 3.
APERs may be used individually or in combination depending
on the system requirement and model functionally. However,
no one rule is considered to be the best for all models because
of the natural language structure.
Procedure 4 Procedure for synthesizing TSs from system
requirements
Require: set of requirements (System-requirements)
1: TS-set ← ∅ ;
2: for each Req ∈ System-requirements do
3:
Parse-tree ← Get(Req tree.xml);
4:
AP-list ← APER(Parse-tree);
5:
AP-list ← Eliminate Dup(AP-list);
6:
AP-list ← USR IN(AP-List);
7:
AP-truth-table ← Relation(AP-list);
8:
AP-truth-table ← USR IN(AP-truth-table);
9:
S-list ← ∅;
10:
for each A ∈ AP-truth-table do
11:
S-list[i] = Ai ;
12:
S-list ← USR IN(S-list);
13:
T ← CreateT(S-list);
14:
T ← USR IN(T);
15:
TS ← CreateTS(T, S-list);
16:
TS-set ← TS-set U TS;
17:
return TS-set;
D. High-Level Procedure for Speciﬁcation Transition System
Synthesis
Procedure 4 shows the overall ﬂow for computing the
TSs. A set of system requirements in natural language are
fed as input to the procedure. TS-set is the output of the
procedure and will contain the set of transition systems that
capture the input requirements as a formal model. TS-set is
initialized to null (line 1). Each requirement is input to the
Enju parser. The parser gives an xml ﬁle as output. A function
called Get is used to obtain the xml ﬁle into the variable
Parse-tree (line 3). The xml output in Parse-tree is subjected
to the proposed APERs, which give the atomic propositions
(APs) as output. APs are stored in the AP-list (line 4). Each
requirement is subject to all APERs and the AP-list obtained is
the union of the APs produced by each of the rules. The output
obtained by using the APERs may contain duplicates, which
are eliminated by using the function Eliminate Dup (line 5).
AP-list is then subjected to an expert user check, where the
AP(s) might be appended, eliminated or revised based on the
expert user’s domain knowledge (line 6). Some of the APs
maybe expressible as a boolean function of other APs.
Therefore, next, a truth table (AP-truth-table) is created, where
each row corresponds to an AP from AP-list and each column
also corresponds to an AP from AP-list (line 7). Each entry
in the table is a Bolean value (true or false). Completing the
truth table determines the relationship of each AP with the
other APs in the AP-list. The truth table is completed by the
expert user (line 8). The list of states for the input requirements
are stored in the variable S-list. S-list is initialized to null (line
9). Each truth table entry (A) is deﬁned to be a single state in
the transition system (line 10). This heuristic has worked well
in practice. S-list is subjected to expert user input (line 12).
The transitions of the TS are computed next. The list of
transitions (T) is initialized to a transition between every two
states using function ’CreateT’ (line 13). The transition list is
subjected to expert user input (line 14). A transition system
(TS) is constructed using the CreateTS function, which takes
the transitions (T) and the list of states (S-list) as input (line
98
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

15). This transition system (TS) is then added to the transition
system set (TS-set) (line 16). The procedure ﬁnally returns
a set of transition systems for all the requirements in an
application (line 17).
V.
CASE STUDY: GENERIC INSULIN INFUSION PUMP
(GIIP)
Insulin pump is a medical device that delivers doses of
insulin 24 hours a day to patients with diabetes. It is typically
used to keep the blood glucose level in an acceptable range.
Overdose of insulin can lead to low blood sugar that can lead
to coma/death. Therefore, the insulin pump is a safety-critical
device.
Requirement 1.8.2: When the pump is in suspension mode,
insulin deliveries shall be prohibited. Any incomplete bolus
delivery shall be stopped and shall not be resumed after the
suspension.
The Generic Insulin Infusion Pump (GIIP) has been pro-
posed [22], which lists a set of safety requirements for insulin
pumps. We use these safety requirements for our approach.
As an example, consider requirement 1.8.2 (from [22])
which is needed to address a hazard that may happen in
the suspension mode of the pump. Suspension mode can
occur when the pump may be in reﬁll or priming or insulin
delivery processes. The insulin pump has two type of insulin
deliveries: bolus and basal. Bolus is a high insulin rate that is
recommended in case of low blood glucose level. From safety
requirement 1.8.2, it is clear that the pump should not resume a
suspended bolus automatically after returning from suspension
since they would be an unexpected amount of insulin.
Requirement 1.8.5: When the pump resumes from suspension,
calculations shall be performed to synchronize insulin used
and remaining reservoir volume.
Requirement 1.8.5 is an extension of how the pump should
function after returning from the suspension mode. Here two
requirements are needed to address one safety hazard. When
algorithm 4 is applied on these two requirements, the ﬁrst step
is collecting the APs by using the extraction rules. Applying
APER 2 on 1.8.2 gives: ”pump”, ”suspension mode”, ”insulin
deliveries”, ”incomplete bolus delivery”, and ”suspension”.
Applying APER 2 on 1.8.5 gives: ”pump”, ”suspension”,
”calculations”, and ”synchronize insulin used and remaining
reservoir volume”. Next, duplicate APs are to be removed.
This eliminates ’pump’ and ’suspension’ from the AP-list.
Now, the expert user intervenes for manipulating the AP-list,
where APs can be deleted, modiﬁed or even inserted based on
the expert user’s domain knowledge. This yields the ﬁnal AP-
list as ”suspension mode” (SPM), ”insulin deliveries” (INDV),
”incomplete bolus delivery” (IBO) and ”synchronize insulin
used and remaining reservoir volume” (SYNC). Next, the AP-
truth-table to deﬁne relations between APs is constructed as
shown in Table I.
Here, each row represents a state. For example, SPM
represents a state where suspension mode is true, IBO is false,
INDV is false, and SYNC is also false; which emphasizes
that insulin bolus should not be active during suspension.
Finally, Procedure 4 applies transitions between every two
states as shown in Figure 6a. The expert user will approve
or remove some unacceptable transitions. Figure 6b shows the
ﬁnal transition system.
TABLE I. AP-TRUTH-TABLE FOR REQUIREMENT 1.8.2 AND 1.8.5
FROM AP-LIST
APs →
SPM
INDV
IBO
SYNC
↓
SPM
T
F
F
F
INDV
F
T
F
F
IBO
F
T
T
F
SYNC
F
F
F
T
(a) TS with all suggested
transitions.
(b) TS after removing some
transitions.
Figure 6. Finite state machine for pump suspension requirements (1.8.2,
1.8.5).
VI.
RESULTS ANALYSIS
Evaluation of the presented approach is performed using
the NuSMV model checker. A model checker is a tool that
can check if a TS satisﬁes a set of properties. The properties
have to be expressed in a temporal logic. Here, we have
used CTL to express the properties. The CTL properties
were written manually for each of the requirements that were
subjected to our approach. NuSMV was used to check if the
TSs synthesized by the presented approach satisﬁed the CTL
properties corresponding to that requirement.
Table II shows the results of applying Procedure 4 on
a number of GIIP requirements. The requirement numbers
in the table are from [22]. All the ﬁnal TSs satisﬁed their
corresponding CTL properties. Each requirement or set of
requirements (listed in column 1) have been subjected to the
extraction rules (column 2), where column 3 shows the total
number of APs resulting from each extraction rule. Column 4
gives the number of APs after removing the duplicate APs. In
addition, a record of the suggested expert user intervention for
adding, removing or modifying the APs is shown in column
5. The ﬁnal number of APs, states, and transitions are shown
in column 6.
As shown in the table, when a requirement is subjected
to the APERs, the resultant output from each APER may
be different even though the number of APs is the same.
For requirements 1.8.2 and 1.8.5, although applying APER1,
APER2, and APER3 give the same number of APs, APER1
gives different list of APs from APER2 and APER3.
VII.
CONCLUSION AND FUTURE WORK
The key ideas of our approach for transforming require-
ments into transition systems are the following. The extraction
rules work on the parse tree to get an initial list of APs. The
AP truth table is used to establish relationships between the
initial list of APs. For example, an AP may be expressible as
a conjunction of two other APs. The initial expert user pruned
99
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

TABLE II. RESULTING TRANSITION SYSTEMS BY APPLYING THE GENERAL ALGORITHM AND APERS ON A SET OF SYSTEM
REQUIREMENTS
Req. NO.
APER
Total No.
of APs
No. of APs
Without DP
User input
Final
AP added
AP removed
AP modiﬁed
APs
states
transitions
1
10
10
0
6
0
1.1.1
2
10
10
0
5
0
5
4
5
3
10
10
0
6
0
1
7
7
0
3
2
1.1.3
2
7
7
0
3
2
4
4
4
3
7
7
0
3
1
1
24
12
3
5
1
1.2.4 , 1.2.6, 1.2.7
2
24
18
0
8
0
10
10
14
3
24
16
2
8
0
1
11
6
1
3
0
1.3.5
2
11
8
0
4
1
4
4
4
3
11
8
1
5
0
1
9
7
1
3
1
1.8.2, 1.8.5
2
9
7
0
3
0
4
4
5
3
9
7
0
3
0
1
6
6
0
3
1
2.2.2, 2.2.3
2
7
6
0
3
1
3
3
4
3
7
6
0
3
2
1
15
14
0
9
0
3.1.1
2
14
12
0
7
0
5
3
3
3
14
13
0
8
0
1
10
9
0
7
2
3.2.5
2
7
7
0
4
1
3
3
3
3
7
7
0
4
1
1
4
4
0
1
0
3.2.7
2
4
4
0
1
1
3
3
3
3
4
4
0
1
0
list of APs gives insight into the states of the transition system.
We have found empirically that having one state for this initial
pruned AP list is a good heuristic to compute the states of the
transition system. Transitions are applied between every two
states and then pruned by the expert user.
Transforming natural language requirements into formal
models is quite a hard problem and hard to get right without
input from domain expert. Our approach sets up a very struc-
tured process, where the tool does lot of the work in analyzing
and synthesizing TSs, but also allows for input from domain
expert. The proposed methodology has worked very well in
practice for the GIIP requirements. All the TSs computed for
the requirements satisﬁed their corresponding CTL properties.
For future work, we plan to address requirements with real-
time constraints. The corresponding formal model will be
timed transition systems.
ACKNOWLEDGMENT
This publication was funded by a grant from the United
States Government and the generous support of the American
people through the United States Department of State and the
United States Agency for International Development (USAID)
under the Pakistan - U.S. Science & Technology Cooperation
Program. The contents do not necessarily reﬂect the views
of the United States Government. The authors would like to
acknowledge Dr. Vinay Gonela for helping with proofreading
the paper.
100
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

REFERENCES
[1]
FDA, “List of Device Recalls, U.S. Food and Drug Administration
(FDA),”
2018,
last
accessed:
2018-09-10.
[Online].
Available:
https://www.accessdata.fda.gov/scripts/cdrh/cfdocs/cfRES/res.cfm
[2]
R.
Kaivola,
et
al.,
“Replacing
testing
with
formal
veriﬁcation
in
intel
coretm
i7
processor
execution
engine
validation,”
in
Computer Aided Veriﬁcation, 21st International Conference, CAV
2009, Grenoble, France, June 26 - July 2, 2009. Proceedings, ser.
Lecture Notes in Computer Science, A. Bouajjani and O. Maler,
Eds., vol. 5643.
Springer, 2009, pp. 414–429. [Online]. Available:
https://doi.org/10.1007/978-3-642-02658-4\ 32
[3]
T. Ball, B. Cook, V. Levin, and S. K. Rajamani, “SLAM and
static driver veriﬁer: Technology transfer of formal methods inside
microsoft,” in Integrated Formal Methods, 4th International Conference,
IFM 2004, Canterbury, UK, April 4-7, 2004, Proceedings, ser. Lecture
Notes in Computer Science, E. A. Boiten, J. Derrick, and G. Smith,
Eds., vol. 2999.
Springer, 2004, pp. 1–20. [Online]. Available:
https://doi.org/10.1007/978-3-540-24756-2\ 1
[4]
K.
Bhargavan,
et
al.,
“Formal
veriﬁcation
of
smart
contracts:
Short paper,” in Proceedings of the 2016 ACM Workshop on
Programming Languages and Analysis for Security, PLAS@CCS
2016,
Vienna,
Austria,
October
24,
2016,
T.
C.
Murray
and
D.
Stefan,
Eds.
ACM,
2016,
pp.
91–96.
[Online].
Available:
http://doi.acm.org/10.1145/2993600.2993611
[5]
D. Delmas, et al., “Towards an industrial use of ﬂuctuat on safety-critical
avionics software,” in International Workshop on Formal Methods for
Industrial Critical Systems.
Springer, 2009, pp. 53–69.
[6]
P. Manolios, “Mechanical veriﬁcation of reactive systems,” PhD
thesis, University of Texas at Austin, August 2001, last accessed:
2018-10-10. [Online]. Available: http://www.ccs.neu.edu/home/pete/
research/phd-dissertation.html
[7]
M. A. L. Dubasi, S. K. Srinivasan, and V. Wijayasekara, “Timed reﬁne-
ment for veriﬁcation of real-time object code programs,” in Working
Conference on Veriﬁed Software: Theories, Tools, and Experiments.
Springer, 2014, pp. 252–269.
[8]
Tsujii laboratory, Department of Computer Science at The University
of Tokyo, “Enju - a fast, accurate, and deep parser for English,” 2011,
available from http://www.nactem.ac.uk/enju, [accessed: 2018-07-10].
[9]
V. ´Agel, Dependency and valency: an international handbook of con-
temporary research.
Walter de Gruyter, 2003, vol. 1.
[10]
S Ghosh, et al., “Automatic requirements speciﬁcation extraction from
natural language (ARSENAL),” SRI International, Menlo Park, CA,
Tech. Rep., 2014.
[11]
D. Aceituna, H. Do, and S. Srinivasan, “A systematic approach to
transforming system requirements into model checking speciﬁcations,”
in Companion Proceedings of the 36th International Conference on
Software Engineering.
ACM, 2014, pp. 165–174.
[12]
I. G. Harris, “Extracting design information from natural language
speciﬁcations,” in Proceedings of the 49th Annual Design Automation
Conference.
ACM, 2012, pp. 1256–1257.
[13]
H. Kress-Gazit, G. E. Fainekos, and G. J. Pappas, “Translating struc-
tured English to robot controllers,” Advanced Robotics, vol. 22, no. 12,
2008, pp. 1343–1359.
[14]
R. L. Smith, G. S. Avrunin, L. A. Clarke, and L. J. Osterweil, “Propel:
an approach supporting property elucidation,” in Proceedings of the
24th International Conference on Software Engineering.
ACM, 2002,
pp. 11–21.
[15]
K. Shimizu, “Writing, verifying, and exploiting formal speciﬁcations for
hardware designs,” Ph.D. dissertation, PhD thesis, Stanford University,
2002.
[16]
D. Zowghi, V. Gervasi, and A. McRae, “Using default reasoning to
discover inconsistencies in natural language requirements,” in Software
Engineering Conference, 2001. APSEC 2001. Eighth Asia-Paciﬁc.
IEEE, 2001, pp. 133–140.
[17]
V. Gervasi and D. Zowghi, “Reasoning about inconsistencies in natural
language requirements,” ACM Transactions on Software Engineering
and Methodology (TOSEM), vol. 14, no. 3, 2005, pp. 277–330.
[18]
W. Scott, S. Cook, and J. Kasser, “Development and application of
a context-free grammar for requirements,” in SETE 2004: Focussing
on Project Success; Conference Proceedings; 8-10 November 2004.
Systems Engineering Society of Australia, 2004, p. 333.
[19]
X. Xiao, A. Paradkar, S. Thummalapenta, and T. Xie, “Automated ex-
traction of security policies from natural-language software documents,”
in Proceedings of the ACM SIGSOFT 20th International Symposium
on the Foundations of Software Engineering.
ACM, 2012, p. 12.
[20]
Z. Ding, M. Jiang, and J. Palsberg, “From textual use cases to service
component models,” in Proceedings of the 3rd International Workshop
on Principles of Engineering Service-Oriented Systems.
ACM, 2011,
pp. 8–14.
[21]
C. Rolland and C. Proix, “A natural language approach for requirements
engineering,” in International Conference on Advanced Information
Systems Engineering.
Springer, 1992, pp. 257–277.
[22]
Y. Zhang, R. Jetley, P. L. Jones, and A. Ray, “Generic safety require-
ments for developing safe insulin pump software,” Journal of diabetes
science and technology, vol. 5, no. 6, 2011, pp. 1403–1419.
101
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

