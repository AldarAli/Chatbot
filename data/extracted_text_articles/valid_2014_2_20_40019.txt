Algebraic Analysis of Branching Processes
David Delﬁeu
Universit´e de Nantes
IRCCyN
Nantes, France
david.delﬁeu@univ-nantes.fr
Maurice Comlan, M´ed´esu Sogbohossou
Universit´e d’Abomey-Calavi
LETIA
Abomey-Calavi, B´enin
comlan@hotmail.fr, sogbohossou medesu@yahoo.fr
Abstract—Combinatory explosion is a limit which can be en-
countered when a state space exploration is driven on large
speciﬁcation modeled with Petri nets. Technics like unfolding have
been proposed to cope with this problem. This paper presents an
axiomatic model to reduce unfoldings to canonic forms which
preserves conﬂicts.
Keywords–Petri Nets; Unfolding; Branching process; Algebra.
I.
INTRODUCTION
Petri nets are a widely used tool used to model critical
real-time systems. The formal veriﬁcation of properties is
then based on the computation of state space [1]. But, this
computation faces generally, for highly concurrent and large
systems, to combinatory explosion. A major cause is the
semantics of interleaving. Partial order semantics [2] have been
introduced to shunt those interleavings. This work, initiated in
[3], go further with the introduction of the conﬂict equivalence.
An operator which is an abstraction of sequence and true
parallelism simpliﬁes the representation of processes, only
conﬂicts are preserved. This approach can be used to speed up
the identiﬁcation of the branching processes of an unfolding.
The notion of equivalence can be used to make a new type of
reduction of unfoldings.
Finite preﬁxes of net unfoldings constitute a ﬁrst trans-
formation of the initial Petri Net (PN), where cycles have
been ﬂattened. This computation produces a process set where
conﬂicts act as a discriminating factor. A conﬂict partitions
a process in branching processes. An unfolding can be trans-
formed into a set of ﬁnite branching processes. Theses pro-
cesses constitute a set of acyclic graphs - several graphs
can be produced when the PN contains parallelism - built
with events and conditions, and structured with two operators:
causality and true parallelism. An interesting particularity of
an unfolding is that in spite of the loss of the concept of
global marking, these processes contain enough information to
reconstitute the reachable markings of the original Petri nets. In
most of the cases, unfoldings are larger than the original Petri
net. This is provoked essentially when values of precondition
places exceed the precondition of non simple conﬂicts. This
produces a lot of alternative conditions. In spite of that, a
step has been taken forward: cycles have been broken and
the conﬂicts have structured the nets in branching processes.
A lot of works have been proposed to improve unfolding
algorithms [2][4][5][6]. Is there another way to draw on recent
works about unfolding? In spite of the eventual increase of
the size of the net unfoldings, the suppression of conﬂicts
and loops has decreased its structural complexity, allowing to
compute the state space and to the extract of semantics.
From a developer’s point of view an unfolding can be
efﬁciently coded by a boolean table of events. This table
describes every pair to pair relation between events. This table
has been the starting point of our reﬂection: it stresses the
point that a new connector can be deﬁned to express that a set
of events belong to the same process. This connector allows to
aggregate all the events of a branching process. For example,
a theorem is proposed to compute all the branching processes,
in canonic form, for chains of conﬂicts of the kind illustrated
in Figure 1.
e1
e2
ep-1
ep
b0
b1
bp-1
bp
e3
Fig 1. Chain of conﬂicts.
The work presented in this paper takes place in the context
of combining process algebra [7][8] and Petri nets [9]. The
axiomatic model of Milner’s process with Calculus of Com-
municating Systems (CCS) is compared with the branching
processes and related to other works in Section II. Then, after
a brief presentation of Petri nets and unfoldings in Section
III, Section IV presents our contribution with the deﬁnition
of an axiomatic framework and the description of properties.
The last section presents examples, in particular, illustrating a
conﬂict equivalence.
II.
RELATED WORKS
Process algebra appeared with Milner [8] on the Calculus
of Communicating Systems (CCS) and the Communicating
Sequential Processes (CSP) of Hoare [7] in not equivalent
but similar approaches. The algebra of branching process we
propose in this paper is inspired by the process algebra of
Milner. CCS is based on two central ideas: The notion of
observability and the concept of synchronized communication;
CCS is as an abstract code that corresponds to a real program
whose primitives are reduced to simple send and receive on
channels. The terms (or agents) are called processes with
interaction capabilities that match requests communication
channels. The elements of the alphabet are observable events
and concurrent systems (processes) can be speciﬁed with the
use of three operators: sequence, choice, and parallelism. A
main axiom of CCS is the rejection of distributivity of the
sequence upon the choice. Let p and q be two processes, the
complete process of syntax is:
21
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-370-4
VALID 2014 : The Sixth International Conference on Advances in System Testing and Validation Lifecycle

Capacity
α
:=
¯x | x | τ
Proces
p
::=
α.p | p||q | p+q | D(˜x) | p\x | 0
a
b
c
a
b
c
a
Fig 2. Milner: rejection of distributivity of sequence on choice.
Consider an observer. In the ﬁrst automaton of the Figure
2, after the occurrence of the action a, he can observe either b
or c. In the second automaton, the observation of a does not
imply that b and c stay observable. The behavior of the two
automata are not equivalent.
In CCS, Milner deﬁnes the observational equivalence. Two
automata are observational equivalent if there are bisimular.
On a algebraic point of view, the distributivity of the sequence
on the choice is rejected in the equation (1):
a.(b+c) ̸≡behaviorally a.b+a.c
(1)
The key point of our approach is based on the fact that this
distributivity is not rejected in occurrence nets. The timing
of the choices in a process is essential [10]. The nodes of
occurrence nets are events. An event is a ﬁred transition of the
underlying Petri net. In CCS, an observer observes possible
futures. In occurrence nets, the observer observes arborescent
past. This controversy in the theory of concurrency is an
important topic of linear time versus branching time. In our
model the equation (2) holds:
a ≺ (b ⊥ c) ≡ (a ≺ b) ⊥ (a ≺ c)
(2)
The equation (2) is a basic axiom of our algebraic model.
The equivalence relation differs then from bisimulation equiv-
alence. This relation will be deﬁned in the following with the
deﬁnition of the canonic form of an unfolding.
Branching process does not ﬁt with process algebra on
numerous other aspects. For example, a difference can be
noticed about parallelism. While unfolding keeps true paral-
lelism, process algebra considers a parallelism of interleaving.
Another difference is relative to events and conditions which
are nodes of different nature in an unfolding. Conditions and
events differ in term of ancestor. Every condition is produced
by at most one event ancestor (none for the condition standing
for m0, the initial marking), whereas every event may have
1 or n condition ancestor(s). In CCS, there is no distinction
between conditions and events. Moreover, conditions will be
consumed deﬁning processes as set of events.
However, a lot of works [6][10][11] have shown the interest
of an algebraic formalization: it allows the study of con-
nectives, the compositionally and facilitates reasoning (tools
like [12]). Let have two Petri nets; it is questionable whether
they are equivalent. In principle, they are equivalent if they
are executed strictly in the same manner. This is obviously
a too restrictive view they may have the same capabilities
of interaction without having the same internal implementa-
tions. These work resulted to ﬁnd matches (rather ﬂexible
and not strict) between nets. Mention may be made among
other the occurrence net equivalence [13], the bisimulation
equivalence [14], the partial order equivalence [15], or the
ST-bisimulation equivalence [16]. These different equivalences
are based either on the isomorphism between the unfolding
of nets or on observable actions or traces of the execution
of Petri nets or other criteria. This approach in this paper is
weaker than a trace equivalence; it does not preserves traces
but preserves conﬂicts. The originality of this approach is
to encapsulate causality and concurrency in a new operator
which “aggregates” and “abstract” events in a process. This
new operator reduces the representation and accelerates the
reduction process. This paper intends ﬁrst, to give an algebraic
model to an unfolding, and second, to establish a canonic form
leading to the deﬁnition of an equivalence conﬂict.
III.
UNFOLDING A PETRI NET
A. Petri Net
A Petri net [9] N =< P,T,W > is a triple with: P, a ﬁnite
set of places, T, the ﬁnite set of transitions, P ∪ T are nodes
of the net; (P∩T = /0), and W : (P×T) ∪ (T ×P) −→ N ,
the ﬂow relation deﬁning arcs (and their valuations) between
nodes of N .
The pre-set (resp. post-set) of a node x is denoted •x = {y ∈
P∪T | W (y,x) > 0} (resp. x• = {y ∈ P∪T | W (x,y) > 0}). A
marking of a Petri net N is a mapping m : P −→ N . A tran-
sition t ∈ T is said enabled by m iff: ∀p ∈ •t, m(p) ≥ W (p,t).
This is denoted: m
t→ Firing of t leads to the new marking
m′ (m t→ m′): ∀p ∈ P, m′(p) = m(p)−W (p,t)+W (t, p). The
initial marking is denoted m0.
A Petri net is k-bounded iff ∀m, reachable from m0,m(p) ≤
k (with p ∈ P). It is said safe when 1-bounded. Two transitions
are in a structural conﬂict when they share at least one pre-set
place; a conﬂict is effective when these transitions are both
enabled by a same marking. The considered Petri nets in this
paper are k-bounded.
B. Unfolding
In [4], the notion of branching process is deﬁned as an
initial part of a run of a Petri net respecting its partial order
semantics and possibly including non deterministic choices
(conﬂicts). This net is acyclic and the largest branching process
of an initially marked Petri net is called the unfolding of this
net. Resulting net from an unfolding is a labeled occurrence
net, a Petri net whose places are called conditions (labeled
with their corresponding place name in the original net) and
transitions are called events (labeled with their corresponding
transition name in the original net).
An occurrence net [17] O =< B,E ,F > is a 1-valued arcs
Petri net, with B the set of conditions, E the set of events,
and F the ﬂow relation (1-valued arcs), such that: |•b| ≤ 1 (
∀b ∈ B), •e ̸= /0 (∀e ∈ E ), and F + (the transitive closure of F)
is a strict order relation. This net O is a set of acyclic graphs.
Min(O) = {b | b ∈ B,|•b| = 0} is the minimal conditions set:
the set of conditions with no ancestor can be mapped with the
initial marking of the underlying Petri net. Also, Max(O) =
{x | x ∈ B ∪E ,|x•| = 0} are maximal nodes.
Three kinds of relations could be deﬁned between the nodes
of O:
•
The strict causality relation noted ≺: ∀x,y ∈ B ∪
22
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-370-4
VALID 2014 : The Sixth International Conference on Advances in System Testing and Validation Lifecycle

E , x ≺ y if (x,y) ∈ F +
•
The conﬂict relation noted #: ∀b ∈ B, if e1,e2 ∈ b•
(e1 ̸= e2), then e1 and e2 are in conﬂict relation,
denoted e1 # e2 (in Figure 3.b e4#e5 ).
•
The concurrency relation noted ≀: ∀x,y ∈ B ∪E (x ̸=
y), x ≀ y ssi ¬((x ≺ y) ∨ (y ≺ x) ∨ (x ♯ y)). (in Figure
3.b e2 ≀e3).
Remark 3.1: The transitive aspect of F + implies a tran-
sitive deﬁnition of strict causality.
A set B ⊆ B of conditions such as ∀b,b′ ∈ B,b ̸= b′ ⇒ b≀b′ is
a cut. Let B be a cut with ∀b ∈ B,∄b′ ∈ B\B, b≀b′, B is the
maximal cut.
Deﬁnition 3.2: The unfolding UnfF
def=< OF,λF > of a
marked net < N ,m0 >, with OF
def=< BF,EF,FF > an occur-
rence net and λF : BF ∪EF → P ∪T (such as λ(BF) ⊆ P
and λ(EF) ⊆ T ) a labeling function, is given by:
1)
∀p ∈ P, if m0(p) ̸= /0, then Bp
def= {b ∈ BF | λF(b) =
p∧ •b = /0} and m0(p) = |Bp|;
2)
∀Bt ⊆ BF such as Bt is a cut, if ∃t ∈ T ,λF(Bt) =
•t ∧|Bt| = |•t|, then:
a)
∃!e ∈ EF such as •e = Bt ∧λF(e) = t;
b)
if t• ̸= /0, then B′
t
def= {b ∈ BF | •b = {e}} is
as λF(B′
t) = t• ∧|B′
t| = |t•|;
c)
if t• = /0, then B′
t
def= {b ∈ BF | •b = {e}} is
as λF(B′
t) = /0∧|B′
t| = 1;
3)
∀Bt ⊆ BF, if Bt is not a cut , then ∄e ∈ EF such as
•e = Bt.
The deﬁnition 3.2 represents an exhaustive unfolding algo-
rithm of < N ,m0 >. In 1., the algorithm for the building of the
unfolding starts with the creation of conditions corresponding
to the initial marking of < N ,m0 > and in 2., news events
are added one at a time together with their output conditions
(taking into account sink transitions). In 3., the algorithm
requires that any event is a possible action: there are no adding
nodes to those created in item 1 and 2. The algorithm does
not necessary terminate; it terminates if and only if the net
< N ,m0 > does not have any inﬁnite sequence. The sink
transitions (ie t ∈ T ,t• = /0) are taken into account in 2.(c).
Let be E ⊂ EF. The occurrence net O
def=< B,E ,F >
associated with E such as B
def= {b ∈ BF | ∃e ∈ E ,b ∈ •e∪e•}
and F
def= {(x,y) ∈ FF | x ∈ E ∨ y ∈ E } is a preﬁx of OF if
Min(O) = Min(OF). By extension, Unf
def=< O,λ > (with λ,
the restriction of λF to B ∪E ) is a preﬁx of unfolding UnfF.
It should be noted that, according to the implementation,
the names (the elements in the sets E and B) given to
nodes in the same unfolding can be different. A name can be
independently chosen in an implementation using a tree formed
by its causal predecessors and the name of the corresponding
nodes in N [4].
Deﬁnition 3.3: A causal net C is an occurrence net C
def=<
B,E ,F > such as:
1)
∀e ∈ E : e• ̸= /0 ∧ •e ̸= /0;
2)
∀b ∈ B : |b•| ≤ 1 ∧ |•b| ≤ 1.
Deﬁnition 3.4: Pi = (Ci,λF) is a process of < N ,m0 >
iff: Ci
def=< Bi,Ei,Fi > is a causal net and λ : Bi ∪Ei → P∪T
p 3
p 4
t3
t4
t1
t2
p 1
p 2
p 5
(p3)
(p4)
(t3)
(t4)
(t1)
(t2)
(p1)
(p2)
(p4)
(t2)
(p2)
(p3)
(t1)
(p1)
(p5)
(p5)
(t4)
b1
b2
b3
b4
b5
b6
b9
b8
b7
b10
e1
e2
e3
e6
e5
e4
e7
a)
b)
Fig 3. a) Petri net, b) Unfolding.
is a labeling fonction such as:
1)
Bi ⊆ BF and Ei ⊆ EF
2)
λF(Bi) ⊆ P and λF(Ei) ⊆ T;
3)
λF(•e) =• λF(e) and λF(e•) = λF(e)•
4)
∀ei ∈ Ei,
∀p ∈ P :
W (p,λF(e)) = |λ −1(p) ∩•
e| ∧ W (λF(e), p) = |λ −1(p)∩e•|
5)
If p ∈ Min(P) ⇒ ∃b ∈ Bi : •b = /0 ∧ λF(b) = p
Max(Ci) is the state of N . Min(Ci) and Max(Ci) are
maximum cuts. Generally, any maximal cut B ⊆ Bi corre-
sponds to a reachable marking m of < N ,m0 > such as
∀p ∈ P,m(p) = |Bp| avec Bp = {b ∈ B | λ(b) = p}.
The local conﬁguration of an event e is deﬁned by: [e]
def=
{e′ | e′ ≺ e}∪{e} and is a process. For example of unfolding
in Figure 3.b: [e4]
def= {e1,e3,e4}.
The conﬂits in a unfolding derive from the fact that there
is an reachable marking (a cut in an unfolding) such as two or
many transitions of a labelled net < N ,m0 > are enabled
and the ﬁring of one transition disable other. Whence the
proposition:
Proposition 3.5: Let be e1,e2 ∈ EF. If e1 ⊥ e2, then there
∃(e′
1,e′
2) ∈ [e1]×[e2] such as •e′
1 ∩ •e′
2 ̸= /0 et •e′
1 ∪ •e′
2 is a cut.
IV.
BRANCHING PROCESS ALGEBRA
The previous section showed how unfolding exhibits causal
nets and conﬂicts. Otherwise, every couple of events which
are not bounded by a causal relation or the same conﬂict set
are in concurrency. Then, an unfolding allows to build a 2D-
table making explicit every binary relations between events.
Practically, this table establishes the relations of causality and
exclusion. If a binary relation is not explicit in the table, it
means that the couple of events are in a concurrency relation.
Let E B = E ∪B a ﬁnite alphabet, composed of the events
and the conditions generated by the unfolding. The event table
(produced by the unfolding) deﬁnes for every couple in E B
either a causality relation C , either a concurrency relation I
or an exclusive relation X . These sets of binary relations dot
23
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-370-4
VALID 2014 : The Sixth International Conference on Advances in System Testing and Validation Lifecycle

not intersect and the following expressions can be deduced:
Unf/X = C ∪I
(3)
Unf/C = X ∪I
(4)
Unf/I = C ∪X
(5)
To illustrate these relation sets, the negation operator noted
¬ can be introduced. Then, the equations (3),(4),(5) leads to
(6),(7),(8):
¬((e1,e2) ∈ I ) ⇔
(e1,e2) ∈ C ∪X
(6)
¬((e1,e2) ∈ C ) ⇔
(e1,e2) ∈ I ∪X
(7)
¬((e1,e2) ∈ X ) ⇔
(e1,e2) ∈ C ∪I
(8)
The equation (8) expresses that if two events are not in conﬂict
they are in the same branching process. Let us now deﬁne the
union of binary relations C and I : P
= C
∪ I For
every couple (e1,e2) ∈ P, either (e1,e2) are in causality or in
concurrency: P is the union of every branching process of an
unfolding.
a) Example: Let us consider an unfolding (left part)
on the Figure 4 and the table T (right part) which is its
representation:
In Figure 4, the table T contains 7 causal
e0
e2
e3
e4
e5
e6
e1
Table : 
T(e0, e2)=#t
T(e1, e3)=#t
T(e1, e4)=#t
T(e3, e5)=#t
T(e4, e6)=#t
T(e1, e5)=#t
T(e1, e6)=#t 
T(e3, e4)=#f
T(e3, e6)=#f
T(e4, e5)=#f
T(e5, e6)=#f
Causalities
Conﬂicts
Fig 4. Unfolding.
relations and 4 conﬂict relations. (e0,e4) is not (negation) in
the table, expresses that e0 and e4 are concurrent. Moreover,
if two events are not in conﬂict (consider e0 and e6): (e0,e6)
is not a key of the table, (e0,e6) are in concurrency and thus,
those events belongs to the same branching process.
A. Deﬁnition of the Algebra
The starting point of this work is based on the fact that
the logical negation operator articulates the relation between
two sets: the process set P, and the exclusion set X . As
mentioned in Section IV, C , I and , P does not intersect,
then semantically, if a couple of events is not in a relation of
exclusion (noted ⊥), the events are in P. P contains binary
relations between events that are in branching process.
To express that events are in the same branching process,
a new operator noted ⊕ is introduced. An algebra describing
branching process can be deﬁned as follow:
{U ,≺ , ≀ , ⊥ ,⊕, ¬}
Let us note; ∗ = ⊕,≺, or ⊥, #t the void process, and # f
the false process. Here is the formal signature of the language:
•
∀e ∈ E B,e ∈ U ,#t ∈ U ,# f ∈ U
•
∀e ∈ U ,¬e ∈ U
•
∀(e1,e2) ∈ U 2,e1 ∗e2 ∈ U
Properties, neutral/absorbing elements, distributivities and
semi-distributivities have been deﬁned in [3]. However, let us
now just recall the deﬁnitions (equations (9),(10),(11),(12)):
1) Causality: C is the set of all the causalities between
every elements of E B. e1 ≺ e2 if e1 is in the local conﬁguration
of e2:
e1 ≺ e2 if e1 ∈ [e2]
(9)
2) Exclusion: X is the set of all the exclusion relations
between every elements of E B. Two events are in exclusion
iff they are either in direct conﬂict, either it exists a conﬂict
at any level with an ancestor:
e1 ⊥ e2 ≡ ((•e1 ∩•e2 ̸= /0) or (∃ei,ei ≺ e2 and e1 ⊥ ei)) (10)
3) Concurrency: I is the set of every couple of element
of E B in concurrency. e1 and e2 are in concurrency if the
occurrence of one is independent of the occurrence of the
other. So, e1 ≀ e2 iff e1 and e2 are neither in causality neither
in exclusion.
e1 ≀e2 ≡ ¬((e1 ⊥ e2) or (e1 ≺ e2) or (e2 ≺ e1))
(11)
4) Process: ⊕ aggregates events in one process. Two events
e1 and e2 are in the same process if e1 causes e2 or if e1 is
concurrent with e2:
e1 ⊕e2 ≡ (e1 ≺ e2) or (e2 ≺ e1) or (e1 ≀e2)
(12)
This operator constitutes an abstraction which hides in a black
box causalities and concurrency. The meaning of this operator
is similar to the linear connector ⊕ of MILL [18]. It allows to
aggregates resources. But, in the context of unfolding, events
or conditions are unique and then they cannot be counted.
Thus, this operator is here idempotent.
The expression e1 ⊕ e2 deﬁnes that e1 and e2 are in the
same process.
Note that (⊕ e1 e2 ... en−1 en) will abbreviate (e1 ⊕ e2 ⊕
e3 ⊕...en−1 ⊕ en)
B. Axioms
The following axioms stem directly from previous assump-
tions and deﬁnitions made upon the algebraic model:
Axiom 4.1 (Distributivity of ≺):
e ≺ (e1 ⊥ e2) ≡def (e ≺ e1) ⊥ (e ≺ e2)
The ﬁrst axiom constitutes the basis of our approach. As
discussed in the Section II, on the contrary of CCS, e is
distributed onto two expressions, giving alternative process.
Axiom 4.2 (Deﬁnition of ⊕):
e1 ⊕e2 ≡def (e1 ≺ e2) ⊥ (e2 ≺ e1) ⊥ (e1 ≀e2)
⊕ aggregates two elements in a process. Two elements are in
a process if they are concurrent or in a causality relation.
Axiom 4.3 (≺):
e1 ≺ e2 ≡def ¬e1 ⊥ (e1 ⊕e2)
A causality can be expressed by two processes in exclusion:
either ¬e1: e1 has not occurred either e1 ⊕e2: e1 and e2 within
the same process.
Axiom 4.4 (Duality between ⊕ and ⊥):
e1 ⊕e2 ≡def e1¬⊥e2
e1¬⊕e2 ≡def e1 ⊥ e2
24
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-370-4
VALID 2014 : The Sixth International Conference on Advances in System Testing and Validation Lifecycle

This axiom comes from the introduction of the operator ¬
discussed in the beginning of the Section IV. It expresses that
P and X are complementary sets.
Axiom 4.5 (Exclusion):
e1 ⊥ e2 ≡de f (¬e1 ⊕e2) ⊥ (e1 ⊕¬e2)
The ﬁfth axiom expresses that a conﬂict can be considered as
two processes in conﬂict
Axiom 4.6 (Distributivities):
•
≺,⊥,⊕ are distributive over ≀.
•
≺,⊕,≀ are distributive over ⊥ (axiom 4.3).
•
⊥,≀ are distributive over ⊥ and ⊕.
The distributivities over ⊥ are used in the transformation of
an expression in the canonic form. The other distributivities
will be used in the reduction process.
C. Canonic Form
1) Deﬁnition: The deﬁnition of the canonic form allows to
deﬁne an equivalence called a “conﬂict equivalence”.
Deﬁnition 4.1: A canonic process is a formula expressed
on elements of E B and with the operators ⊕, ⊥ ordered by
an alphanumeric sort on the name of its symbol.
Theorem 4.2 (Canonical form): Let us consider an unfold-
ing U, this form can be reduced in the following form:
U = (⊥ P1 P2 ... Pn)
where
Pi = (⊕ ei1... ein)
This form is canonic and exhibits every processes Pi of the
unfolding.
Proof: In an unfolding every causality (≺) and every
partial order (≀) can be reduced in ⊕ by deduction rules Modus
Ponens (MP,MP1,MP2), Simpliﬁcation rule (S) and Par (see
Section IV-C2). Moreover, ⊕ and ⊥ are mutually distributive,
so ⊥ can be factorized in every sub-formula to reach the higher
level of the formula. In ﬁne, an alphanumeric sort on symbols
of the processes can be applied to assure the unicity of the
form.
This canonic form preserves conﬂicts, let us now deﬁne a
conﬂict equivalence:
Deﬁnition 4.3 (Conﬂict Equivalence): Let us U1,U2 un-
foldings of Petri nets:
U1 ≈conf U2
iff they have the same canonic form.
Remark 4.4: A process is an aggregate set of events where
≺ and ≀ are hidden. This equivalence is lower than a trace
equivalence: each process Pi is an abstraction of a set of traces.
2) Derivation Rules: This section gives a set of rules
which transform branching processes toward a canonical form.
Theses transformations preserve conﬂicts whereas ≺ and ≀ are
transformed in ⊕.
Let us note b a condition, e an event and E a well formed
formula on the algebra. Theses rules allow to reduct process:
1)
Modus Ponens:
⊢ ⊕ b...
⊢ ⊕ b... ≺ e
⊢ e
MP1
⊢ e
⊢ e ≺ ⊕ b...
⊢ ⊕ e b...
MP2
Where
⊕b...
stands
for
the
general
form
for
⊕b1b2... bn. MP1 expresses that b... are consumed
by the causality, whereas, in MP2 e stays in the
conclusion.
2)
Dual form:
⊢ ¬e1
⊢ e1 ≺ e2
⊢ ¬e1 ⊕¬e2
MP′
3)
Simpliﬁcation:
⊢ ¬e1 ⊕E
⊢ E
S1
⊢ ⊕b... E
⊢ E
S2
Those rules are applied, in ﬁne, to clear not pertinent
informations in the process. S1 rule is applied, to
clear the negations whereas S2 is applied to clear the
conditions which have not been consumed.
4)
Reduction of ≀:
⊢ e1 ≀e2
⊢ e1 ⊕e2 Par
This rule corresponds to the deﬁnition of ⊕
These rules have been deﬁned to lead to a canonic
form.
D. Theorems
The properties of operators (deﬁnition, axioms and distribu-
tivites) allow to deﬁne theorems which are congruences w.r.t
the operators of Section IV-A (proofs have been already stated
in [3]).
Theorem 4.5 (Conﬂict):
e1 ≺ (e2 ⊥ e3) ≡ (e1 ≺ (e2 ⊕¬e3)) ⊥ (e1 ≺ (¬e2 ⊕e3))
This theorem expresses how to develop a conﬂict and the
following theorem allows to reduce processes:
Theorem 4.6 (Absorption): Let E,F some processes: E ⊥
(E ⊕F) ≡ E ⊕F
1) Chain of conﬂicts: This section presents a theorem
which computes the branching process in canonic form of a
chain of conﬂict illustrated in Figure 5.
e1
e2
ep-1
ep
b0
b1
bp-1
bp
e3
Fig 5. Chain of conﬂicts.
The axiomatic representation of the unfolding is:
U = ((⊕ b0 b1 ... (b0 ≺ (e1 ⊥ e2))(b1 ≺ (e2 ⊥ e3))...)
After some steps of reduction (MP+S):
U = (e1 ⊥ e2 ⊥ ... ⊥ ep)
Let us now consider the following conventions: Let us note:
•
l1 = (e1,e2,...en), l2 = (e2,...en)
•
li the ith element of a list l.
•
If ei is an element of the list l, let us note indice(ei)
the position of ei in l.
25
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-370-4
VALID 2014 : The Sixth International Conference on Advances in System Testing and Validation Lifecycle

Remark 4.7: In the list of event constituting a chain of
conﬂict (l = (e1,e2,...en)), for every event ei, the next (resp.
previous) event in the same branching process is ei+2 or ei+3
(resp. ei−2 or ei−3)
The next deﬁnition deﬁnes two processes Un and Vn which are
aggregation of events where the possible successor of an event
ei is either l(indice(ei)+2) either l(indice(ei)+3).
Deﬁnition 4.8: Let us consider that n <= p (p: index of
the last event implied in the chain of conﬂict):







U0 = e1
U1
n = l1
n+2 ⊕U2
n+2
U2
n = l1
n+3 ⊕U2
n+3
Un = U1
n
⊕U2
n
Un: processes beginning by e1







V0 = e2
V 1
n = l2
n+2 ⊕V 2
n+2
V 2
n = l2
n+3 ⊕V 2
n+3
Vn = V 1
n
⊕V 2
n
Vn: processes beginning by e2
Theorem 4.9: The canonic form of a chain of conﬂict C is
Un ⊕Vn:
(e1 ⊥ e2 ⊥ ... ⊥ ep) ≡ Un ⊕Vn
V.
EXAMPLES
A. Example 1
The Figure 6 gives a Petri net which represents a chain
of conﬂicts and its unfolding. The unfolding gives a table of
e1
e2
e3
e4
e5
b2
b3
b4
t1
P1
t2
P2
t3
P3
t4
P4
t5
b1
Fig 6. PN and unfolding of a chain of conﬂicts.
binary relations on events (see Section IV) which is represented
by the following algebraic expression U2:
U1 = (⊕ b1 b2 b3 b4 b5 (b1 ≺ (e1 ⊥ e2)) (b2 ≺ (e2 ⊥ e3)) ...)
After some steps of reduction (MP+S), U1 becomes:
(e1 ⊥ e2 ⊥ e3 ⊥ e4 ⊥ e5)
(13)
The theorem (T 4.9) allows to compute from (13) its following
canonic form:
(⊥ (⊕ e1 e3 e5)(⊕ e1 e4 )(⊕ e2 e4)(⊕ e2 e5))
B. Example 2
Let us consider the following Unfolding of the Figure 7.
The table computed which leads to the following algebraic
e1(t1)
e2(t2)
e3(t3)
b12
b0
e4(t4)
e5(t5)
b2
b1
b3
e3(t3)
e4(t4)
e5(t5)
b4
e4(t4)
e5(t5)
b3
b4
e1(t1)
e5(t5)
b7
e1(t1)
e2(t2)
b8
b10
b9
b11
e3(t3)
e2(t2)
e1(t1)
Fig 7. U2.
expression U2:
U2
= (⊕ b12
(b12 ≺ (e1 ⊥ e2 ⊥ e3 ⊥ e4 ⊥ e5))
(e1 ≺ (⊕ b0 b1 b2 b3))(e2 ≺ b4)(e3 ≺ (⊕b5 b6))(e4 ≺ b7)
(e5 ≺ (⊕b8 b9 b10 b11))((⊕ b0 b1) ≺ e3) ((⊕ b1 b2) ≺ e4)
((⊕ b2 b3) ≺ e5) (b4 ≺ (⊥ e4 e5))(b5 ≺ e1) (b6 ≺ e5)
(b7 ≺ (⊥ e1 e2)) ((⊕ b8 b9) ≺ e3) ((⊕ b9 b10) ≺ e2)
((⊕ b10 b11) ≺ e1))
(14)
Let us note P the aggregation of the ﬁve ﬁrst lines of the
equation. (14) becomes:
U2
= (⊕ b12
(b12 ≺ (⊥ e1 e2 e3 e4 e5)) P
(15)
Rules MP1, MP2 and theorem 1, reduce (15) in:
U2
= (⊥ (⊕ e1 P) (⊕ e2 P) (⊕ e3 P) (⊕ e4 P) (⊕ e5 P) )
Distributivity of perp:
U2
= (⊕
(⊥ (⊕ e1 b0 b1 b2 b3)(⊕ e2 b4)(⊕ e3 b5 b6) (⊕ e4 b7)
(⊕ e5 b8 b9 b10 b11)) ((⊕ b0 b1) ≺ e3) ((⊕ b1 b2) ≺ e4)
((⊕ b2 b3) ≺ e5) (b4 ≺ (⊥ e4 e5))(b5 ≺ e1) (b6 ≺ e5)
(b7 ≺ (⊥ e1 e2))((⊕ b8 b9) ≺ e3) ((⊕ b9 b10) ≺ e2)
((⊕ b10 b11) ≺ e1))
Distributivity of ⊥ and MP1:
U2
= (⊥
(⊕ e1 e3 e5 b1 b2)(⊕ e1 e4 b0 b3)(⊕ e2 e4)(⊕ e2 e5)
(⊕ e3 e1)(⊕ e3 e5)(⊕ e4 e1)(⊕ e4 e2)(⊕ e5 e1 e3 b9 b10)
(⊕ e5 e2 b8 b11))
Theorem 2 (absorption of (⊕ e3 e1) and (⊕ e3 e5) in
(⊕ e1 e3 e5 b1 b2), idempotency of ⊥:
U2
= (⊥
(⊕ e1 e3 e5 b1 b2)(⊕ e1 e4 b0 b3)(⊕ e2 e4)(⊕ e2 e5)
(⊕ e4 e1)(⊕ e5 e1 e3 b9 b10)(⊕ e5 e2 b8 b11))
Rules of simpliﬁcation S1 and S2 and theorem 2:
U2 = (⊥ (⊕ e1 e3 e5)(⊕ e1 e4)(⊕ e2 e4)(⊕ e2 e5))
The two unfoldings of example 1 and 2 have the same
canonic form, they are conﬂict-equivalent: U1 ≈conf U2
1) Reasoning about processes: Let us consider all the
process p of U2 : (⊕ e1 e3 e5),(⊕ e1 e4),...
•
∀p ∈ U2 whenever e3 is present, e1 is present.
•
∀p ∈ U2,¬e3 ⊥ (e1 ⊕ e3 ⊕e5)
This is the algebraic deﬁnition of ≺. Finally from
this chain of conﬂicts, the following causality can be
deduced:
e3 ≺ (e1 ⊕e5)
(16)
•
A similar reasoning can be made:
∀p ∈ U2,¬(e1 ⊕e5) ⊥ (e1 ⊕ e3 ⊕e5)
This is the algebraic deﬁnition of:
(e1 ⊕e5) ≺ e3
(17)
(16) and (17) expresses that there is a strong link
between e3 and the process (e1 ⊕ e5) but ≺ is no
well suited to encompass this relation. Theses two
processes are like “intricated”.
26
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-370-4
VALID 2014 : The Sixth International Conference on Advances in System Testing and Validation Lifecycle

•
In the same manner:
¬e2 ⊥ (e2 ⊕e4) ⊥ (e2 ⊕e5)
≡dist
¬e2 ⊥ (e2 ⊕(e4 ⊥ e5))
≡def
e2 ≺ (e4 ⊥ e5)
(18)
e2 leads to a conﬂict
¬e1 ⊥ ((⊕e1e3e5) ⊥ (e1 ⊕e4)
≡dist
¬e1 ⊥ (e1 ⊕((e3 ⊕e5) ⊥ e4))
≡def
e1 ≺ ((e3 ⊕ e5) ⊥ e4)
(19)
Equations (18) and (19) show that e1 and e2 transform the
chain of conﬂict in a unique conﬂict. New relations between
events or processes can be introduced:
•
Alliance relation: e1,e3 and e5 are in “an alliance
relation”. Every event of this set is enforced by the
occurrence of the other events: e1 ⊕ e3 enforces e5,
e1 ⊕e5 enforces e3 and e3 ⊕e5 enforces e1.
•
Intrication: the occurrence of e3 forces e1 ⊕ e5 and
reciprocally e1 ⊕e5 forces e3.
•
Resolving conﬂicts (liberation):
◦
e1 resolves 3 conﬂicts on 4 (as e2, e4 and e5)
◦
e3 resolves every conﬂicts.
Semantically, e3 can be identiﬁed as an important event in
the chain. Moreover (⊕e1 e3 e5) is a process aggregated with
“associated events”. This chain of conﬂict can be seen as two
causalities in conﬂicts: (e1 ≺ (e4 ⊥ (e3 ⊕e5))) ⊥ (e2 ≺ (e4 ⊥ e5))
1
WaitCustomerAction
AnalyzeCode
WaitEnterCode
ReadyToGetCash
WaitConsult
WaitGetCash
ReadyToConsult
Consult
GetConsult
GetCash
EnterCode
Getcash
OKcode
BadCode
Fig 8. Cash dispenser.
2) Example 3 (Cash dispenser): Let us consider the cash
dispenser of the Figure 8, its unfolding in canonical form is:
U3 = (⊥ (⊕ Consult EnterCode OKcode GetConsult)
(⊕ Consult EnterCode OKcode Getcash)
(⊕ Consult EnterCode BadCode)
(⊕ GetCash EnterCode OKcode Getcash)
(⊕ GetCash EnterCode OKcode GetConsult)
(⊕ GetCash EnterCode BadCode))
This expression enlightens that GetCash and BadCode are
neither in the same process.
VI.
CONCLUSION AND FUTURE WORK
This work is a ﬁrst attempt to present an axiomatic frame-
work to the analyze of the processes issued of an unfolding.
From a set of axioms, distributivities and derivation rules,
theorems have been established and a reduction process can
lead to a canonic form The unfolding process, deﬁnitions,
theorems and reduction rules have been coded in LISP[19]
with a package named PLT/Redex[3][12]. This canonic form
assets an equivalence conﬂicts (≡conf ) between unfoldings and
then Petri nets.
Several perspectives are into progress. First, news theorems
have to be established allowing to speed up the procedure
of canonic reduction and to extend extraction of knowledge
on relationship between events. Different kinds of relationship
between events have to be deﬁned and formalized: Alliance
relation, Intrication, etc. Moreover, as already outlined in the
last part of the example section, algebraic reasoning can raise
semantic informations about events from the canonic form.
Another perspective is to extend this approach to Petri nets
with inhibitor and drain arcs.
REFERENCES
[1]
B. Berthomieu and F. Vernadat, “State class constructions for branching
analysis of time petri nets,” in TACAS, volume 2619 of LNCS.
Springer Verlag, 2003, pp. 442–457.
[2]
J. Esparza and K. Heljanko, “Unfoldings - a partial-order approach
to model checking,” EATCS Monographs in Theoretical Computer
Science, 2008.
[3]
D. Delﬁeu and M. Sogbohossou, “An algebra for branching processes,”
in Control, Decision and Information Technologies (CoDIT), 2013
International Conference on, May 2013, pp. 625–634.
[4]
J. Engelfriet, “Branching processes of petri nets,” Acta Informatica,
vol. 28, no. 6, 1991, pp. 575–591.
[5]
J. Esparza, S. R¨omer, and W. Vogler, An Improvement of McMillan’s
Unfolding Algorithm.
Mit Press, 1996.
[6]
McMillan and Kenneth, “Using unfoldings to avoid the state explosion
problem in the veriﬁcation of asynchronous circuits,” in Computer
Aided Veriﬁcation.
Springer, 1993, pp. 164–177.
[7]
C. A. R. Hoare, Communicating sequential processes.
Prentice-hall
Englewood Cliffs, 1985, vol. 178.
[8]
R. Milner, Communication and concurrency.
Prentice-hall Englewood
Cliffs, 1989.
[9]
C. A. Petri, “Communication with automata,” PhD thesis, Institut fuer
Instrumentelle Mathematik, 1962.
[10]
R. Glabbeek and F. Vaandrager, “Petri net models for algebraic theo-
ries of concurrency,” in PARLE Parallel Architectures and Languages
Europe, ser. Lecture Notes in Computer Science, J. Bakker, A. Nijman,
and P. Treleaven, Eds.
Springer Berlin Heidelberg, 1987, vol. 259, pp.
224–242.
[11]
E. Best, R. Devillers, and M. Koutny, “The box algebra=petri
nets+process expressions,” Information and Computation, vol. 178,
no. 1, 2002, pp. 44 – 100.
[12]
M. Felleisen, R. Findler, and M. Flatt, Semantics Engineering With PLT
Redex.
Mit Press, 2009.
[13]
M. Nielsen, G. Plotkin, and G. Winskel, “Petri nets, event structures
and domains,” in T. Theor. Comp. Sci., vol. 13(1), 1981, pp. 89–118.
[14]
J. Baeten, J. Bergstra, and J. Klop, “An operational semantics for
process algebra,” in CWI Report CSR8522, 1985.
[15]
G. Boudol and I. Castellani, “On the semantics of concurrency: partial
orders and transitions systems,” in Rapports de Recherche No 550,
INRIA, Centre Sophia Antipolis, 1986.
[16]
V. Glaabeek and F. Vaandrager, “Petri nets for algebraic theories of
concurrency,” in CWI Report SC-R87, 1987.
[17]
T. Chatain and C. Jard, “Complete ﬁnite preﬁxes of symbolic
unfoldings of safe time petri nets,” in Petri Nets and Other Models
of Concurrency - ICATPN 2006, ser. Lecture Notes in Computer
Science, S. Donatelli and P. Thiagarajan, Eds.
Springer Berlin
Heidelberg, 2006, vol. 4024, pp. 125–145. [Online]. Available:
http://dx.doi.org/10.1007/11767589
[18]
J.-Y. Girard, “Linear logic,” Theoretical computer science, vol. 50, no. 1,
1987, pp. 1–101.
[19]
G. L. Steele, Common LISP: the language.
Digital press, 1990.
27
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-370-4
VALID 2014 : The Sixth International Conference on Advances in System Testing and Validation Lifecycle

