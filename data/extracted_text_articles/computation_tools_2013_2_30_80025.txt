Reducing Higher Order π-Calculus to Spatial Logics
Zining Cao1,2
1Department of Computer Science and Technology
Nanjing University of Aeronautics & Astronautics
Nanjing 210016, China
2State Key Laboratory for Civil Aircraft Flight Simulation
Shanghai Aircraft Design and Research Institute
Shanghai 201210, China
Abstract—In this paper, we show that the theory of processes
can be reduced to the theory of spatial logic. Firstly, we propose a
spatial logic SL for higher order π-calculus, and give an inference
system of SL. The soundness and incompleteness of SL are
proved. Furthermore, we show that the structure congruence
relation and one-step transition relation can be described as the
logical relation of SL formulas. At last we extend all deﬁnitions
and results of SL to a weak semantics version of SL, called WL.
Keywords—higher order π-calculus; spatial logic; inference
system
I.
INTRODUCTION
Higher order π-calculus was proposed and studied inten-
sively in Sangiorgi’s dissertation [29]. In higher order π-
calculus, processes and abstractions over processes of arbi-
trarily high order, can be communicated. Some interesting
equivalences for higher order π-calculus, such as barbed equiv-
alence, context bisimulation and normal bisimulation, were
presented in [29]. Barbed equivalence can be regarded as a
uniform deﬁnition of bisimulation for a variety of concurrent
calculi. Context bisimulation is a very intuitive deﬁnition of
bisimulation for higher order π-calculus, but it is heavy to
handle, due to the appearance of universal quantiﬁcations in
its deﬁnition. In the deﬁnition of normal bisimulation, all
universal quantiﬁcations disappeared, therefore normal bisim-
ulation is a very economic characterization of bisimulation
for higher order π-calculus. The coincidence among the three
weak equivalences was proven [29], [28], [20]. Moreover, this
proposition was generalized to the strong bisimulation case
[10].
Spatial logic was presented in [12]. Spatial logic extends
classical logic with connectives to reason about the structure of
the processes. The additional connectives belong to two fam-
ilies. Intensional operators allow one to inspect the structure
of the process. A formula A1|A2 is satisﬁed whenever we can
split the process into two parts satisfying the corresponding
subformula Ai, i = 1, 2. In the presence of restriction in
the underlying model, a process P satisﬁes formula n®A
if we can write P as (νn)P ′ with P ′ satisfying A. Finally,
formula 0 is only satisﬁed by the inaction process. Connectives
| and ® come with adjunct operators, called guarantee (◃) and
hiding (⊘) respectively, which allow one to extend the process
being observed. In this sense, these can be called contextual
operators. P satisﬁes A1◃A2 whenever the spatial composition
(using |) of P with any process satisfying A1 satisﬁes A2, and
P satisﬁes A ⊘ n if (νn)P satisﬁes A. Some spatial logics
have an operator for fresh name quantiﬁcation [11].
There are lots of works of spatial logics for π-calculus and
Mobile Ambients. In some papers, spatial logic was studied on
its relations with structural congruence, bisimulation, model
checking and type system of process calculi [5], [6], [9], [16],
[27].
The main idea of this paper is that the theory of processes
can be reduced to the theory of spatial logic.
In this paper, we present a spatial logic for higher order
π-calculus, called SL, which comprises some action temporal
operators such as ⟨τ⟩ and ⟨a⟨A⟩⟩, some spatial operators such
as preﬁx and composition, some adjunct operators of spatial
operators such as ◃ and ⊘, and some operators on the property
of free names and bound names such as ⊖n and e⊖. We
give an inference system of SL, and prove the soundness
of the inference system for SL. Furthermore, we show that
there is no ﬁnite complete inference system for SL. Then we
study the relation between processes and SL formulas. We
show that an SL formula can be viewed as a speciﬁcation of
processes, and conversely, a process can be viewed as a special
kind of SL formulas. Therefore, SL is a generalization of
processes, which extend process with speciﬁcation statements.
We show that the structural congruence relation and one-step
transition relation can be described as the logical relation of
SL formulas. We also show that bisimulations for higher order
processes coincide with logical equivalence with respect to
some fragment of a sublogic of SL.
Furthermore, we give a weak semantics version of SL,
called WL, where the internal action is unobservable. The
results of SL are extended to WL, such as an inference system
for WL, the soundness of this inference system, and the non-
existence of a ﬁnite complete inference system for WL.
Finally, we add µ-operator to SL. The new logic is named
µSL. We show that WL is a sublogic of µSL and replication
operator can be expressed in µSL. Thus µSL is a powerful
logic which can express both strong semantics and weak
semantics for higher order processes.
This paper is organized as follows: In Section 2, we brieﬂy
review higher order π-calculus. In Section 3, we present a
spatial logic SL, including its syntax, semantics and inference
system. The soundness and incompleteness of the inference
44
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

system of SL are proved. Furthermore, we discuss that SL
can be regarded as a speciﬁcation language of processes and
processes can be regarded as a kind of special formulas of SL.
Bisimulation in higher order π-calculus coincides with logical
equivalence with respect to some fragment of a sublogic of
SL. In Section 4, we give a weak semantics version of SL,
called WL. We generalize concepts and results of SL to WL.
The paper is concluded in Section 5.
II.
HIGHER ORDER π-CALCULUS
A. Syntax and Labelled Transition System
In this section we brieﬂy recall the syntax and labelled
transition system of the higher order π-calculus. Similar to
[28], we only focus on a second-order fragment of the higher
order π-calculus, i.e., there is no abstraction in this fragment.
We assume a set N of names, ranged over by a, b, c, ... and
a set V ar of process variables, ranged over by X, Y, Z, U, ....
We use E, F, P, Q, ... to stand for processes. Pr denotes the
set of all processes.
We ﬁrst give the syntax for the higher order π-calculus
processes as follows:
P ::= 0 | U | π.P | P1|P2 | (νa)P
π is called a preﬁx and can have one of the following
forms:
π ::= a(U) | a⟨P⟩, here a(U) is a higher order input preﬁx
and a⟨P⟩ is a higher order output preﬁx.
In each process of the form (νa)P the occurrence of a is
bound within the scope of P. An occurrence of a in a process
is said to be free iff it does not lie within the scope of a
bound occurrence of a. The set of names occurring free in
P is denoted fn(P). An occurrence of a name in a process
is said to be bound if it is not free, and we write the set of
bound names as bn(P). n(P) denotes the set of names of P,
i.e., n(P) = fn(P) ∪ bn(P).
Higher order input preﬁx a(U).P binds all free occurrences
of U in P. The set of variables occurring free in P is denoted
fv(P). We write the set of bound variables as bv(P). A
process is closed if it has no free variable; it is open if it
may have free variables. Prc is the set of all closed processes.
Processes P and Q are α-convertible, P ≡α Q, if Q can
be obtained from P by a ﬁnite number of changes of bound
names and variables. For example, (νb)(a⟨b(U).U⟩.0) ≡α
(νc)(a⟨c(U).U⟩.0).
Structural congruence is the smallest congruence relation
that validates the following axioms: P|Q ≡ Q|P; (P|Q)|R ≡
P|(Q|R); P|0 ≡ P; (νa)0 ≡ 0; (νm)(νn)P ≡ (νn)(νm)P;
(νa)(P|Q) ≡ P|(νa)Q if a /∈ fn(P).
In [26], Parrow has shown that in higher order π-calculus,
the replication can be deﬁned by other operators such as
higher order preﬁx, parallel and restriction. For example,
!P can be simulated by RP = (νa)(D|a⟨P|D⟩.0), where
D = a(X).(X|a⟨X⟩.0).
The operational semantics of higher order processes is
given in Table 1. We have omitted the symmetric cases of
the parallelism and communication rules.
ALP : P
α
−→ P ′
Q
α
−→ Q′ P ≡ Q, P ′ ≡ Q′
OUT : a⟨E⟩.P
a⟨E⟩
−→ P
IN : a(U).P
a⟨E⟩
−→ P{E/U} bn(E) = ∅
PAR :
P
α
−→ P ′
P|Q
α
−→ P ′|Q
bn(α) ∩ fn(Q) = ∅
COM : P
(νeb)a⟨E⟩
−→
P ′
Q
a⟨E⟩
−→ Q′
P|Q
τ
−→ (νeb)(P ′|Q′)
eb ∩ fn(Q) = ∅
RES :
P
α
−→ P ′
(νa)P
α
−→ (νa)P ′ a /∈ n(α)
OPEN :
P
(νec)a⟨E⟩
−→
P ′
(νb)P
(νb,ec)a⟨E⟩
−→
P ′
a ̸= b, b ∈ fn(E) − ec
REP : P|!P
α
−→ P ′
!P
α
−→ P ′
Table 1. The operational semantics of higher order π-calculus
B. Bisimulations in Higher Order π-Calculus
Context bisimulation and contextual barbed bisimulation
were presented in [29] to describe the behavioral equivalences
for higher order π-calculus. Let us review the deﬁnition of
these bisimulations. In the following, we abbreviate P{E/U}
as P⟨E⟩.
Context bisimulation is an intuitive deﬁnition of bisimula-
tion for higher order π-calculus.
Deﬁnition 1 A symmetric relation R ⊆ Prc × Prc is a
strong context bisimulation if P R Q implies:
(1) whenever P
τ
−→ P ′, there exists Q′ such that Q
τ
−→ Q′
and P ′ R Q′;
(2) whenever P
a⟨E⟩
−→ P ′, there exists Q′ such that Q
a⟨E⟩
−→
Q′ and P ′ R Q′;
(3) whenever P
(νeb)a⟨E⟩
−→
P ′, there exist Q′, F, ec such that
Q
(νec)a⟨F ⟩
−→
Q′ and for all C(U) with fn(C(U)) ∩ {eb, ec} =
∅, (νeb)(P ′|C⟨E⟩) R (νec)(Q′|C⟨F⟩). Here C(U) represents a
process containing a unique free variable U.
We write P ∼Ct Q if P and Q are strongly context
bisimilar.
Contextual barbed equivalence can be regarded as a uni-
form deﬁnition of bisimulation for a variety of process calculi.
Deﬁnition 2 A symmetric relation R ⊆ Prc × Prc is a
strong contextual barbed bisimulation if P R Q implies:
(1) P|C R Q|C for any C;
(2) whenever P
τ
−→ P ′ then there exists Q′ such that
Q
τ
−→ Q′ and P ′ R Q′;
(3) P ↓µ implies Q ↓µ, where P ↓a if ∃P ′, P
a⟨E⟩
−→ P ′,
and P ↓a if ∃P ′, P
(νeb)a⟨E⟩
−→
P ′.
45
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

We write P ∼Ba Q if P and Q are strongly contextual
barbed bisimilar.
Intuitively, a tau action represents the internal action of
processes. If we just consider external actions, then we should
adopt weak bisimulations to characterize the equivalence of
processes.
Deﬁnition 3 A symmetric relation R ⊆ Prc × Prc is a
weak context bisimulation if P R Q implies:
(1) whenever P
ε
=⇒ P ′, there exists Q′ such that Q
ε
=⇒ Q′
and P ′ R Q′;
(2) whenever P
a⟨E⟩
=⇒ P ′, there exists Q′ such that Q
a⟨E⟩
=⇒
Q′ and P ′ R Q′;
(3) whenever P
(νeb)a⟨E⟩
=⇒
P ′, there exist Q′, F, ec such that
Q
(νec)a⟨F ⟩
=⇒
Q′ and for all C(U) with fn(C(U)) ∩ {eb, ec} =
∅, (νeb)(P ′|C⟨E⟩) R (νec)(Q′|C⟨F⟩). Here C(U) represents a
process containing a unique free variable U.
We write P
≈Ct Q if P and Q are weakly context
bisimilar.
Deﬁnition 4 A symmetric relation R ⊆ Prc × Prc is a
weak contextual barbed bisimulation if P R Q implies:
(1) P|C R Q|C for any C;
(2) whenever P
ε
=⇒ P ′ then there exists Q′ such that
Q
ε
=⇒ Q′ and P ′ R Q′;
(3) P ⇓µ implies Q ⇓µ, where P ⇓µ if ∃P ′, P
ε
=⇒ P ′
and P ′ ↓µ .
We write P ≈Ba Q if P and Q are weakly contextual
barbed bisimilar.
III.
LOGICS FOR STRONG SEMANTICS
In this section, we present a logic to reason about higher
order π-calculus called SL. This logic extends propositional
logic with three kinds of connectives: action temporal opera-
tors, spatial operators, operators about names and variables. We
give the syntax and semantics of SL. The inference system of
SL is also given. We prove the soundness and incompleteness
of this inference system. As far as we know, this is the ﬁrst
result on the completeness problem of the inference system of
spatial logic. Furthermore, we show that structural congruence,
one-step transition relation and bisimulation can all be char-
acterized by this spatial logic. It is well known that structural
congruence, one-step transition relation and bisimulation are
the central concepts in the theory of processes, and almost
all the studies of process calculi are about these concepts.
Therefore, our study gives an approach of reducing theory of
processes to theory of spatial logic. Moreover, since processes
can be regarded as a special kind of spatial logic formulas,
spatial logic can be viewed as an extension of process calculus.
Based on spatial logic, it is possible to propose a reﬁnement
calculus [23] of concurrent processes.
A. Syntax and Semantics of Logic SL
Now we introduce a logic called SL, which is a spatial
logic for higher order π-calculus.
Deﬁnition 5 Syntax of logic SL
A ::= ⊤| ⊥| ¬A | A1∧A2 | ⟨τ⟩A | ⟨a⟨A1⟩⟩A2 | ⟨a[A1]⟩A2
| ⟨a⟨A1⟩⟩A2 | 0 | X | a⊙X.A | A\a⊙X | a⟨A1⟩.A2 | A\a
| A1|A2 | A1 ◃A2 | a®A | A⊘a | (Nx)A | (NX)A | (⊖a)A
| (˜⊖)A | a ̸= b | X | µX.A(X) where X occurs positively
in A(X), i.e., all free occurrences of X fall under an even
number of negations.
In (Nx)A, (NX)A, the variables x (and X) are bound
within the scope of the formula A. We assume that the standard
relation ≡α of α-conversion (safe renaming of bound vari-
ables) was deﬁned on formulas, but we never implicitly take
formulas “up to α-conversion”: our manipulation of variables
via α-conversion steps is always quite explicit. The set fn(A)
of free names in A, and the set fpv(A) of free propositional
variables in A, are deﬁned in the usual way. A formula is
closed if it has no free variable such as X, and it is open
if it may have free variables. SLc is the set of all closed
formulas. In the following, we use A{b/a} to denote the
formula obtained by replacing all occurrences of a in A by
b. Similarly, we use A{Y/X} to denote the formula obtained
by replacing all occurrences of X in A by Y. It is easy to
see that a process can also be regarded as a spatial formula.
For example, process a⟨E⟩.P is also a spatial formula. In this
paper, we say that such a formula is in the form of process
formula.
Semantics of SL is given as following:
We write such set of processes in which A is true as
[[A]]e
P r, where e: V ar → 2P r is an environment. We denote
by e[X ← W] a new environment that is the same as e except
that e[X ← W](X) = W. The set [[A]]e
S is the set of processes
that satisfy A with respect to e.
Deﬁnition 6 Semantics of logic SL
[[⊤]]e
P r = Pr;
[[⊥]]e
P r = ∅;
[[¬A]]e
P r = Pr − [[A]]e
P r;
[[A1 ∧ A2]]e
P r = [[A1]]e
P r ∩ [[A2]]e
P r;
[[⟨τ⟩A]]e
P r = {P | ∃Q. P
τ
−→ Q and Q ∈ [[A]]e
P r};
[[⟨a⟨A1⟩⟩A2]]e
P r = {P | ∃P1, P2. P
a⟨P1⟩
−→
P2, P1 ∈
[[A1]]e
P r and P2 ∈ [[A2]]e
P r};
[[⟨a[A1]⟩A2]]e
P r = {P | ∀R, R ∈ [[A1]]e
P r, ∃Q. P
a⟨R⟩
−→ Q
and Q ∈ [[A2]]e
P r};
[[⟨a⟨A1⟩⟩A2]]e
P r = {P | ∃P1, P2. P
(νeb)a⟨P1⟩
−→
P2, (νeb)P1 ∈
[[A1]]e
P r and P2 ∈ [[A2]]e
P r};
[[0]]e
P r = {P | P ≡ 0};
[[X]]e
P r = {P | P ≡ X};
[[a⊙X.A]]e
P r = {P | ∃Q. P ≡ a(X).Q and Q ∈ [[A]]e
P r};
[[A \ a ⊙ X]]e
P r = {P | a(X).P ∈ [[A]]e
P r};
[[a⟨A1⟩.A2]]e
P r = {P | ∃P1, P2. P ≡ a⟨P1⟩.P2, P1 ∈
[[A1]]e
P r and P2 ∈ [[A2]]e
P r};
[[A \ a]]e
P r = {P | a⟨P⟩.0 ∈ [[A]]e
P r};
46
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

[[A1|A2]]e
P r = {P | ∃Q1, Q2. P ≡ Q1|Q2, Q1 ∈ [[A1]]e
P r
and Q2 ∈ [[A2]]e
P r};
[[A1 ◃ A2]]e
P r = {P | ∀Q. Q ∈ [[A1]]e
P r implies P|Q ∈
[[A2]]e
P r};
[[a®A]]e
P r = {P | ∃Q. P ≡ (νa)Q and Q ∈ [[A]]e
P r};
[[A ⊘ a]]e
P r = {P | (νa)P ∈ [[A]]e
P r};
[[(Nx)A]]e
P r = ∪n/∈fn((Nx)A)([[A{n/x}]]e
P r\{P | n ∈
fn(P)});
[[(NX)A]]e
P r
=
∪V /∈fpv((NX)A)([[A{V/X}]]e
P r\{P
|
V ∈ fpv(P)});
[[(⊖a)A]]e
P r = {P | a /∈ fn(P) and P ∈ [[A]]e
P r};
[[(˜⊖)A]]e
P r = {P | ∃Q. P ≡ Q and bn(Q) = ∅ and
Q ∈ [[A]]e
P r};
[[a ̸= b]]e
P r = Pr if a ̸= b;
[[a ̸= b]]e
P r = ∅ if a = b.
[[X]]e
P r = e(X)
[[µX.A(X)]]e
P r = ∩{W ⊆ Pr | [[A(X)]]e[X←W ]
P r
⊆ W}.
In SL, formula ⟨a⟨A1⟩⟩A2 is satisﬁed by the processes
that can receive a process satisfying A1 and then become a
process satisfying A2. A process satsﬁes formula ⟨a[A1]⟩A2 if
it receive any process satisfying A1 then it becomes a process
satisfying A2. A \ a ⊙ X is an adjunct operator of a ⊙ X.A,
and A \ a is an adjunct operator of a⟨A⟩.0. (⊖a)A is satisﬁed
by processes that satisfy A and a is not its free name. (˜⊖)A is
satisﬁed by processes that satisfy A and have no bound names.
Other operators in SL are well known in spatial logic or can
be interpreted similarly as above operators.
Deﬁnition 7 P |=SL A if P ∈ [[A]]e
P r.
Deﬁnition 8 For a set of formulas Γ and a formula A, we
write Γ |=SL A, if A is valid in all processes that satisfy all
formulas of Γ.
For example, the following equations hold in SL:
{P | ∀P1. P1 ∈ [[A1]]e
P r implies a⟨P1⟩.P ∈ [[A2]]e
P r} =
[[(b ⊙ Y.a⟨A1⟩.Y ◃ ⟨τ⟩A2) \ b]]e
P r.
{P | ∀P1. P1 ∈ [[A1]]e
P r implies a⟨P⟩.P1 ∈ [[A2]]e
P r} =
[[(b ⊙ Y.a⟨Y ⟩.A1 ◃ ⟨τ⟩A2) \ b]]e
P r.
{P | a ∈ fn(P) and P ∈ [[A]]e
P r} = [[¬(⊖a)⊤ ∧ A]]e
P r.
{P | X ∈ fv(P) and P ∈ [[A]]e
P r} = [[¬(⊖X)⊤∧A]]e
P r.
{(νn)P | P ∈ [[A{n/x}]]e
P r} = [[(Nx)x®A]]e
P r.
{a(U).P | P ∈ [[A{U/X}]]e
P r} = [[(NX)a ⊙ X.A]]e
P r.
[[A|!A]]e
P r = [[!A]]e
P r, where !A
def
= ¬µX.¬(A|¬X).
B. Inference System of SL
Now we list a number of valid properties of spatial logic.
The combination of the complete inference system of ﬁrst
order logic and the following axioms and rules form the
inference system S of SL.
(1) ⟨α⟩⊥ → ⊥;
(2) a ⊙ X.⊥ → ⊥;
(3) a⟨⊤⟩.⊥ → ⊥;
(4) a⟨⊥⟩.⊤ → ⊥;
(5) ⊥ \ a ⊙ X → ⊥;
(6) ⊥ \ a → ⊥;
(7) A|⊥ → ⊥;
(8) A ◃ ⊥ → ¬A;
(9) ⊥ ◃ A ↔ ⊤;
(10) a®⊥ → ⊥;
(11) ⊥ ⊘ a → ⊥;
(12) (⊖a)⊥ → ⊥;
(13) (Nx)⊥ → ⊥;
(14) (˜⊖)⊥ → ⊥;
(15) (NX)⊥ → ⊥;
(16) A|B ↔ B|A;
(17) (A|B)|C ↔ A|(B|C);
(18) A|0 ↔ A;
(19) a®0 ↔ 0;
(20) a®b®A ↔ b®a®A;
(21) a®((⊖a)A|B) ↔ (⊖a)A|a®B;
(22) a®A → (Nb)b®A{b/a};
(23) a ⊙ X.A → (NY )a ⊙ Y.A{Y/X};
(24) (⊖a)0 ↔ 0;
(25) (⊖a)X ↔ X;
(26) (⊖a)a ⊙ X.A ↔ ⊥;
(27) (⊖a)a⟨B⟩.A ↔ ⊥;
(28) a ̸= b → ((⊖a)b ⊙ X.A ↔ b ⊙ X.(⊖a)A);
(29) a ̸= b → ((⊖a)b⟨B⟩.A ↔ b⟨(⊖a)B⟩.(⊖a)A);
(30) (⊖a)A|(⊖a)B ↔ (⊖a)(A|B);
(31) a ̸= b → ((⊖a)(⊖b)A ↔ (⊖b)(⊖a)A);
(32) (⊖a)a®A ↔ a®A;
(33) (˜⊖)0 ↔ 0;
(34) (˜⊖)X ↔ X;
(35) (˜⊖)a ⊙ X.A ↔ a ⊙ X.(˜⊖)A;
(36) (˜⊖)a⟨B⟩.A ↔ a⟨(˜⊖)B⟩.(˜⊖)A;
(37) (˜⊖)A|(˜⊖)B ↔ (˜⊖)(A|B);
(38) (˜⊖)a®¬(⊖a)⊤ → ⊥;
(39) (Nx)0 ↔ 0;
(40) (Nx)X ↔ X;
(41) (Nx)a ⊙ X.A ↔ a ⊙ X.(Nx)(x ̸= a ∧ A);
47
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

(42) (Nx)a⟨B⟩.A → a⟨(Nx)(x ̸= a ∧ B)⟩.(Nx)(x ̸= a
∧A);
(43) (Nx)(A|B) → (Nx)A|(Nx)B;
(44) (Nx)x ̸= a ∧ a®A → a®(Nx)A;
(45) (NX)0 ↔ 0;
(46) (NX)X → Y ;
(47) (NX)a ⊙ Y.A ↔ a ⊙ Y.(NX)A;
(48) (NX)a⟨B⟩.A → a⟨(NX)B⟩.(NX)A;
(49) (NX)(A|B) → (NX)A|(NX)B;
(50) (NX)a®A ↔ a®(NX)A;
(51) a ⊙ X.(A \ a ⊙ X) → A;
(52) A → (a ⊙ X.A) \ a ⊙ X);
(53) a⟨A \ a⟩.0 → A;
(54) A → ((a⟨A⟩.0) \ a);
(55) (A|A ◃ B) → B;
(56) A → (B ◃ A|B);
(57) a®(A ⊘ a) → A;
(58) A → (a®A ⊘ a);
(59) ⟨α⟩A, A → B ⊢ ⟨α⟩B;
(60) a ⊙ X.A, A → B ⊢ a ⊙ X.B;
(61) a⟨C⟩.A, A → B ⊢ a⟨C⟩.B;
(62) a⟨B⟩.A, B → C ⊢ a⟨C⟩.A;
(63) ⟨a⟨B⟩⟩A, C → B ⊢ ⟨a⟨C⟩⟩A;
(64) ⟨a[B]⟩A, C → B ⊢ ⟨a[C]⟩A;
(65) A \ a ⊙ X, A → B ⊢ B \ a ⊙ X;
(66) A \ a, A → B ⊢ B \ a;
(67) A → B ⊢ A|C → B|C;
(68) a®A, A → B ⊢ a®B;
(69) (⊖a)A, A → B ⊢ (⊖a)B;
(70) (˜⊖)A, A → B ⊢ (˜⊖)B;
(71) a⟨B⟩.A → ⟨a⟨B⟩⟩A;
(72) (⟨τ⟩A)|B → ⟨τ⟩(A|B);
(73) (⟨a⟨C⟩⟩A)|B → ⟨a⟨C⟩⟩(A|B);
(74) (a ⊙ U.A ∧ ((˜⊖)B ↔ B)) → ⟨a[B]⟩A{B/U};
(75) (((⊖b1, ..., ⊖bn)B ↔ B) ∧ ((˜⊖)C ↔ C)) →
((⟨a⟨b1®...bn®C⟩⟩A)|B → ⟨a⟨b1®...bn®C⟩⟩(A|B));
(76) (((⊖b1, ..., ⊖bn)B ↔ B) ∧ ((˜⊖)C ↔ C)) →
((⟨a⟨b1®...bn®C⟩⟩A)|⟨a[C]⟩B → ⟨τ⟩b1®...bn®(A|B));
(77) (a ̸= b ∧ ((⊖a)B ↔ B) ∧ ((˜⊖)B ↔ B)) →
(a®⟨b⟨B⟩⟩A → ⟨b⟨B⟩⟩a®A);
(78) (∧n
i=1a ̸= bi ∧a ̸= c∧((⊖a)B ↔ B)∧((˜⊖)B ↔ B))
→ (a®⟨c⟨b1®...bn®B⟩⟩A → ⟨c⟨b1®...bn®B⟩⟩a®A);
(79) (a ̸= b ∧ (∧n
i=1b ̸= ci) ∧ (B → ¬(⊖b)⊤) ∧ ((˜⊖)B ↔
B)) → (b®⟨a⟨c1®...cn®B⟩⟩A →
⟨a⟨b®c1®...cn®B⟩⟩A);
(80) ⟨a[B]⟩A → ⟨a⟨B⟩⟩A;
(81) ⟨a⟨B⟩⟩A → ⟨a[B]⟩A, where B is syntactically a
valid process in the higher order π − calculus.
(82) A(µX.A(X)) → µX.A(X);
(83) (A(B) → B) → (µX.A(X) → B).
Intuitively, axiom a®A → (Nb)b®A{b/a} means that
if process P satisﬁes (νa)A and b is a fresh name then
P satisﬁes (νb)A{b/a}. Axiom a⟨B⟩.A → ⟨a⟨B⟩⟩A means
that an output preﬁx process can perform an output action,
which is a spatial logical version of Rule OUT in the la-
belled transition system of higher order π-calculus. Axiom
(a ⊙ U.A ∧ ((˜⊖)B ↔ B)) → ⟨a[B]⟩A{B/U} means that an
input preﬁx process can perform an input action, which is a
spatial logical version of Rule IN in the labelled transition sys-
tem of higher order π-calculus. Axiom (((⊖b1, ..., ⊖bn)B ↔
B) ∧ ((˜⊖)C
↔ C)) → ((⟨a⟨b1®...bn®C⟩⟩A)|⟨a[C]⟩B
→ ⟨τ⟩b1®...bn®(A|B)) is a spatial logical version of Rule
COM. Other axioms and rules are spatial logical version
of structural congruence rules or labelled transition rules
similarly.
Deﬁnition 9 If “A1, ..., An infer B” is an instance of an
inference rule, and if the formulas A1, ..., An have appeared
earlier in the proof, then we say that B follows from an
application of an inference rule. A proof is said to be from
Γ to A if the premise is Γ and the last formula is A in the
proof. We say A is provable from Γ in an inference system
AX, and write Γ ⊢AX A, if there is a proof from Γ to A in
AX.
C. Soundness of SL
Inference system of SL is said to be sound with respect to
processes if every formula provable in SL is valid with respect
to processes.
Now, we can prove the soundness of inference system S
of SL:
Proposition 1 Γ ⊢S A ⇒ Γ |=SL A
Proof. See Appendix A.
D. Incompleteness of SL
The system SL is complete with respect to processes if
every formula valid with respect to processes is provable
in SL. For a logic, completeness is an important property.
The soundness and completeness provide a tight connection
between the syntactic notion of provability and the semantic
notion of validity. Unfortunately, by the compactness property
[18], the inference system of SL is not complete.
The depth of higher order processes in Pr, is deﬁned as
below:
48
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

Deﬁnition 10 d(0) = 0; d(U) = 0; d(a(U).P) = 1+d(P);
d(a⟨E⟩.P) = 1 + d(E) + d(P); d(P1|P2) = d(P1) + d(P2);
d((νa)P) = d(P).
Lemma 1 For any P ∈ Pr, there exists n, such that
d(P) = n.
Proof. Induction on the structure of P.
Proposition 2 There is no ﬁnite sound inference system
AX such that Γ |=SL A ⇒ Γ ⊢AX A.
Proof. See Appendix B.
E. Spatial Logic as a Speciﬁcation of Processes
In the reﬁnement calculus [23], imperative programming
languages are extended by speciﬁcation statements, which
specify parts of a program “yet to be developed”. Then
the development of a program begins with a speciﬁcation
statement, and ends with an executable program by reﬁning
a speciﬁcation to its possible implementations. In this paper,
we generalize this idea to the case of process calculi. Roughly
speaking, we extend processes to spatial logic formulas which
are regarded as the speciﬁcation statements. One can view
the intensional operators of spatial logic as the “executable
program statements”, for example, a⟨P⟩.Q, P|Q and etc;
and view the extensional operators of spatial logic as the
“speciﬁcation statements”, for example, A◃B, A\b and etc. For
example, (b⊙Y.a⟨Y ⟩.A1◃⟨τ⟩A2)\b|(d⊙Y.c⟨B1⟩.Y ◃⟨τ⟩B2)\d
represents a speciﬁcation statement which describes a process
consisting of a parallel of two processes satisfying statements
(b ⊙ Y.a⟨Y ⟩.A1 ◃ ⟨τ⟩A2) \ b and (d ⊙ Y.c⟨B1⟩.Y ◃ ⟨τ⟩B2) \ d
respectively. Furthermore, (b ⊙ Y.a⟨Y ⟩.A1 ◃ ⟨τ⟩A2) \ b rep-
resents a speciﬁcation which describes a process P such
that a⟨P⟩.Q satisﬁes A2 for any Q satisfying A1. Similarly,
(d⊙Y.c⟨B1⟩.Y ◃⟨τ⟩B2)\d represents a speciﬁcation statement
which describes a process M such that c⟨N⟩.M satisﬁes B2
for any N satisfying B1. We can also deﬁne reﬁnement relation
on spatial logic formulas. Intuitively, if |=SL A → B, then
A reﬁnes B. For example, a®(a ⊙ X.d.X|a⟨c.0⟩.e.0) reﬁnes
a®(⟨a[c.0]⟩d.c.0|⟨a⟨c.0⟩⟩e.0). Based on spatial logic, one may
develop a theory of reﬁnement for concurrent processes. This
will be a future research direction for us.
F. Processes as Special Formulas of Spatial Logic
Any process can be regarded as a special formula of spatial
logic. For example, (Na)a®(NX)(a ⊙ X.d.X|a⟨c.0⟩.e.0) is
a spatial logic formula, which represents the process which
is structural congruent to (νa)(a(X).d.X|a⟨c.0⟩.e.0). Further-
more, in this section, we will show that structural congruence
and labelled transition relation can be reformulated as the
logical relation of spatial logical formulas.
Deﬁnition 11 The translating function T P S is deﬁned
inductively as follows:
T P S(P)
def
= P for process P that has no operators of
(νa)·, or a(X).·;
T P S((νa)P)
def
= (Ha)T P S(P);
T P S(a(X).P)
def
= (aHX)T P S(P).
Lemma 2 ⊢SL A|!A ↔!A, where !A
def
= ¬µX.¬(A|¬X).
Proof : See Appendix C.
Proposition 3 For any P, Q ∈ Prc, P ≡ Q ⇔ P |=SL
T P S(Q) and Q |=SL T P S(P) ⇔ T P S(P) ⊢SL T P S(Q) and
T P S(Q) ⊢SL T P S(P).
Proof. See Appendix D.
Proposition 4 For any P, Q ∈ Prc, P
α
−→ Q ⇔ P |=SL
⟨α⟩T P S(Q) ⇔ T P S(P) ⊢SL ⟨α⟩T P S(Q).
Proof. See Appendix E.
Although Proposition 2 states that the inference system is
not complete, Propositions 3 and 4 show that this inference
system is complete with respect to structural congruence and
labelled transition relation of processes.
G. Behavioral Equivalence Relation of Spatial Logic
In [9], we introduced a spatial logic called L, and proved
that L gives a characterization of context bisimulation.
Deﬁnition 12 [9] Syntax of logic L
A ::= ¬A | A1∧A2 | ⟨a⟨⊤⟩⟩⊤ | ⟨a⟨⊤⟩⟩⊤ | ⟨τ⟩A | A1◃A2.
It is easy to see that L is a sublogic of SL.
In [9], we proved the equivalence between ∼Ct and logical
equivalence with respect to L.
Proposition 5 [9] For any P, Q ∈ Prc, P ∼Ct Q ⇔for
any formula A ∈ L, P |=L A iff Q |=L A.
Deﬁnition 13 A and B are behavioral equivalent with
respect to L, written A ∼L B, iff for any formula C ∈ L,
|=SL A → C iff |=SL B → C.
By Proposition 5, it is easy to get the following corollary,
which characterizes ∼Ct by SL property.
Corollary 1 For any P, Q ∈ Prc, P ∼Ct Q ⇔ P ∼L Q.
Relation ∼L is a binary relation on spatial logical formulas.
The above results show that ∼L gives a logical characterization
of bisimulation when formulas are in the form of processes.
Moreover, relation ∼L also gives a possibility to generialize
bisimulation on processes to that on spatial logical formulas.
Since we have discussed that spatial logical formulas can be
regarded as speciﬁcations of processes, we may get a concept
of bisimulation on speciﬁcations of processes based on ∼L .
IV.
LOGICS FOR WEAK SEMANTICS
In this section, we present a logic for weak semantics,
named WL. Roughly speaking, in this logic, action temporal
operators ⟨τ⟩, ⟨a⟨A⟩⟩, ⟨a[A]⟩ and ⟨a⟨A⟩⟩ in SL are replaced
by the weak semantics version of operators ⟨⟨ε⟩⟩, ⟨⟨a⟨A⟩⟩⟩,
⟨⟨a[A]⟩⟩ and ⟨⟨a⟨A⟩⟩⟩. Almost all deﬁnitions and results of
SL can be generalized to WL.
49
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

A. Syntax and Semantics of Logic WL
Now we introduce a logic called WL, which is a weak
semantics version of spatial logic.
Deﬁnition 14 Syntax of logic WL
A ::= ⊤| ⊥| ¬A | A1 ∧ A2 | ⟨⟨ε⟩⟩A | ⟨⟨a⟨A1⟩⟩⟩A2 |
⟨⟨a[A1]⟩⟩A2 | ⟨⟨a⟨A1⟩⟩⟩A2 | 0 | X | a ⊙ X.A | A \ a ⊙ X |
a⟨A1⟩.A2 | A \ a | A1|A2 | A1 ◃ A2 | a®A | A ⊘ a | (Nx)A
| (NX)A | (⊖a)A | (˜⊖)A | a ̸= b | X | µX.A(X) where X
occurs positively in A(X), i.e., all free occurrences of X fall
under an even number of negations.
Deﬁnition 15 Semantics of logic WL
In the following, we use
ε
=⇒ to abbreviate the reﬂexive
and transitive closure of
τ
−→, and use
α
=⇒ to abbreviate
ε
=⇒
α
−→
ε
=⇒ . By neglecting the tau action, we can get the
weak semantics of processes. Semantics of formulas of WL
can be the same as formulas of SL, except that semantics of
operators ⟨⟨ε⟩⟩, ⟨⟨a⟨A⟩⟩⟩, ⟨⟨a[A]⟩⟩ and ⟨⟨a⟨A⟩⟩⟩ should be
deﬁned as follows:
[[⟨⟨ε⟩⟩A]]e
P r = {P | ∃Q. P
ε
=⇒ Q and Q ∈ [[A]]e
P r};
[[⟨⟨a⟨A1⟩⟩⟩A2]]e
P r = {P | ∃P1, P2. P
a⟨P1⟩
=⇒ P2, P1 ∈
[[A1]]e
P r and P2 ∈ [[A2]]e
P r};
[[⟨⟨a[A1]⟩⟩A2]]e
P r = {P | ∀R, R ∈ [[A1]]e
P r, ∃Q. P
a⟨R⟩
=⇒ Q
and Q ∈ [[A2]]e
P r};
[[⟨⟨a⟨A1⟩⟩⟩A2]]e
P r
=
{P | ∃P1, P2. P
(νeb)a⟨P1⟩
=⇒
P2,
(νeb)P1 ∈ [[A1]]e
P r and P2 ∈ [[A2]]e
P r}.
B. Inference System of WL
The inference system of WL is similar to the inference
system of SL except that any inference rule about action
temporal operators ⟨τ⟩, ⟨a⟨A⟩⟩, ⟨a[A]⟩ and ⟨a⟨A⟩⟩ in SL is
replaced by one of the following inference rules.
(1) ⟨⟨α⟩⟩⊥ → ⊥;
(2) ⟨⟨α⟩⟩A, A → B ⊢ ⟨⟨α⟩⟩B;
(3) ⟨⟨α⟩⟩A, A → ⟨⟨ε⟩⟩B ⊢ ⟨⟨α⟩⟩B;
(4) ⟨⟨ε⟩⟩A, A → ⟨⟨α⟩⟩B ⊢ ⟨⟨α⟩⟩B;
(5) ⟨⟨a⟨B⟩⟩⟩A, C → B ⊢ ⟨⟨a⟨C⟩⟩⟩A;
(6) ⟨⟨a[B]⟩⟩A, C → B ⊢ ⟨⟨a[C]⟩⟩A;
(7) a⟨B⟩.A → ⟨⟨a⟨B⟩⟩⟩A;
(8) (a ⊙ U.A ∧ ((˜⊖)B ↔ B)) → ⟨⟨a[B]⟩⟩A{B/U};
(9) (⟨⟨ε⟩⟩A)|B → ⟨⟨ε⟩⟩(A|B);
(10) (⟨⟨a⟨C⟩⟩⟩A)|B → ⟨⟨a⟨C⟩⟩⟩(A|B);
(11) (((⊖b1, ..., ⊖bn)B ↔ B) ∧ ((˜⊖)C ↔ C)) →
((⟨⟨a⟨b1®...bn®C⟩⟩⟩A)|B →
⟨⟨a⟨b1®...bn®C⟩⟩⟩(A|B));
(12) (((⊖b1, ..., ⊖bn)B ↔ B) ∧ ((˜⊖)C ↔ C)) →
((⟨⟨a⟨b1®...bn®C⟩⟩⟩A)|⟨⟨a[C]⟩⟩B →
⟨⟨ε⟩⟩b1®...bn®(A|B));
(13) a®⟨⟨ε⟩⟩A → ⟨⟨ε⟩⟩a®A;
(14) (a ̸= b ∧ (((⊖a)B ∧ (˜⊖)B) ↔ B)) →
(a®⟨⟨b⟨B⟩⟩⟩A → ⟨⟨b⟨B⟩⟩⟩a®A);
(15) (∧n
i=1a ̸= bi ∧a ̸= c∧((⊖a)B ↔ B)∧((˜⊖)B ↔ B))
→ (a®⟨⟨c⟨b1®...bn®B⟩⟩⟩A →
⟨⟨c⟨b1®...bn®B⟩⟩⟩a®A);
(16) (a ̸= b ∧ (∧n
i=1b ̸= ci) ∧ (B → ¬(⊖b)⊤) ∧ ((˜⊖)B ↔
B)) → (b®⟨⟨a⟨c1®...cn®B⟩⟩⟩A →
⟨⟨a⟨b®c1®...cn®B⟩⟩⟩A);
(17) ⟨⟨a[B]⟩⟩A → ⟨⟨a⟨B⟩⟩⟩A;
(18) ⟨⟨a⟨B⟩⟩⟩A → ⟨⟨a[B]⟩⟩A, where B is syntactically
a valid process in the higher order π − calculus.
The above axioms and rules are weak semantics version of
corresponding axioms and rules in SL. We name the above
inference system of WL as W.
The soundness and incompleteness of inference system W
of WL can be given similarly as the case of SL:
Proposition 6 Γ ⊢W A ⇒ Γ |=W L A
Proposition 7 There is no ﬁnite sound inference system
AX such that Γ |=W L A ⇒ Γ ⊢AX A.
Similar to Proposition 4, we show that many steps transi-
tion relation
α
=⇒ is provable in WL.
Proposition 8 For any P, Q ∈ Prc, P
α
=⇒ Q ⇔ P |=W L
⟨⟨α⟩⟩T P S(Q) ⇔ T P S(P) ⊢W L ⟨⟨α⟩⟩T P S(Q).
Since structural congruence and labelled transition relation
are central concepts in the theory of processes, and they can be
characterized in WL, the above propositions give a possible
approach to reduce the theory of processes to the theory of
spatial logic in the case of weak semantics.
V.
CONCLUSIONS
Spatial logic was proposed to describe structural and be-
havioral properties of processes. There are many papers on s-
patial logic and process calculi. Spatial logic is related to some
topics on process calculi, such as model checking, structural
congruence, bisimulation and type system. In [16], a spatial
logic for ambients calculus was studied, and a model checking
algorithm was proposed. Some axioms of spatial logic were
given, but the completeness of logic was not studied. Most
spatial logics for concurrency are intensional [27], in the sense
that they induce an equivalence that coincides with structural
congruence, which is much ﬁner than bisimilarity. In [22],
Hirschkoff studied an extensional spatial logic. This logic only
has spatial composition adjunct (◃), revelation adjunct (⊘), a
simple temporal modality (⟨⟩), and an operator for fresh name
quantiﬁcation. For π-calculus, this extensional spatial logic
was proven to induce the same separative power as strong
early bisimilarity. In [9], context bisimulation of higher order
π-calculus was characterized by an extensional spatial logic.
50
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

In [5], a type system of processes based on spatial logic was
given, where types are interpreted as formulas of spatial logic.
In this paper, we want to show that the theory of processes
can be reduced to the theory of spatial logics. We ﬁrstly deﬁned
a logic SL, which comprises some temporal operators and
spatial operators. We gave the inference system of SL and
showed the soundness and incompleteness of SL. Furthermore,
we showed that structural congruence and transition relation of
higher order π-calculus can be reduced to the logical relation
of SL formulas. We also showed that bisimulations in higher
order π-calculus can be characterized by a sublogic of SL.
At last, we propose a weak semantics version of SL, called
WL. These results can be generalized to other process calculi.
Since some important concepts of processes can be described
in spatial logic, we think that this paper may give an approach
of reducing the study of processes to the study of spatial logic.
The further work for us is to develop a reﬁnement calculus [23]
for concurrent processes based on our spatial logic.
ACKNOWLEDGMENT
This work was supported by the Aviation Science Fund of
China under Grant No. 20128052064 and the National Natural
Science Foundation of China under Grant No. 60873025.
REFERENCES
[1]
R. M. Amadio and M. Dam. Reasoning about Higher-order Processes.
In TAPSOFT95, LNCS 915, 1995, pp. 202-216.
[2]
R. M. Amadio. On the Reduction of CHOCS-Bisimulation to π-calculus
Bisimulation. In CONCUR93, LNCS 715, 1993, pp. 112-126.
[3]
A. Arnold and D. Niwinski. Rudiments of µ-calculus. Studies in Logic,
Vol 146, North-Holland, 2001.
[4]
M. Baldamus and J. Dingel. Modal Characterization of Weak Bisimu-
lation for Higher-order Processes. In TAPSOFT97, LNCS 1214, 1997,
pp. 285–296.
[5]
L. Caires. Spatial-Behavioral Types for Concurrency and Resource
Control in Distributed Systems. In Theoretical Computer Science 402(2-
3), 2008, pp. 120-141.
[6]
L. Caires. Logical Semantics of Types for Concurrency . In CALCO’07,
LNCS, 2007, pp. 16-35.
[7]
L. Caires, H. T. Vieira. Extensionality of Spatial Observations in
Distributed Systems. In EXPRESS’2006, ENTCS, 2006.
[8]
L. Caires. Behavioral and spatial observations in a logic for the π-
calculus. In FOSSACS04, LNCS 2987, 2004, pp. 72-87.
[9]
Z. Cao. A Spatial Logical Characterisation of Context Bisimulation. In
Proceeding of ASIAN 2006, LNCS 4435, 2006, pp. 232-240.
[10]
Z. Cao. More on bisimulations for higher-order π-calculus. In FOS-
SACS06, LNCS 3921, 2006, pp. 63-78.
[11]
L. Caires and L. Cardelli. A Spatial Logic for Concurrency (Part II),
Theoretical Computer Science, Vol 322(3), 2004, pp. 517-565.
[12]
L. Caires and L. Cardelli. A Spatial Logic for Concurrency (Part I).
Information and Computation, Vol 186(2), 2003, pp. 194-235.
[13]
W. Charatonik, S. Dal Zilio, A. D. Gordon, S. Mukhopadhyay, and
J.-M. Talbot. The complexity of model checking mobile ambients. In
FoSSaCS’01, LNCS 2030, 2001, pp. 152-167.
[14]
W. Charatonik, S. Dal Zilio, A. D. Gordon, S. Mukhopadhyay, J.-M.
Talbot. Model Checking Mobile Ambients.
[15]
L. Cardelli and A. Gordon. Logical Properties of Name Restriction. In
Proc. of TLCA’01, LNCS 2044. 2001.
[16]
L. Cardelli and A. Gordon. Anytime, Anywhere, Modal Logics for
Mobile Ambients. In Proc. of POPL’00, 2000, pp. 365-377. ACM Press.
[17]
G. Conforti and G. Ghelli. Decidability of Freshness ,Undecidability of
Revelation. In : Proc. of FoSSaCS’04 , LNCS 2987. 2004.
[18]
C. C. Chang. Model Theory. North-Holland, 1977.
[19]
L. Caires1 and E. Lozes. Elimination of Quantiﬁers and Undecidability
in Spatial Logics for Concurrency. In Theoretical Computer ScienceVol-
ume 358 , Issue 2, August 2006, pp. 293 - 314.
[20]
A. Jeffrey, J. Rathke. Contextual equivalence for higher-order π-calculus
revisited. In Proceedings of Mathematical Foundations of Programming
Semantics, Elsevier, 2003.
[21]
D. Hirschkoff, E. Lozes, and D. Sangiorgi. Separability, Expressiveness
and Decidability in the Ambient Logic. In Proc. of LICS’02, 2002, pp.
423-432, IEEE Computer Society.
[22]
D. Hirschkoff. An Extensional Spatial Logic for Mobile Processes.
CONCUR’04, LNCS 3170, 2004, pp. 325-339, Springer-Verlag.
[23]
C. Morgan, P. Gardiner, K. Robision, and T. Vickers. On the Reﬁnement
Calculus. Springer-Verlag, 1994.
[24]
R. Milner, J. Parrow, and D. Walker. Modal logics for mobile processes.
Theoretical Computer Science, 114(1), 1993, pp.149-171.
[25]
L. Gregory Meredith, Matthias Radestock: Namespace Logic: A Logic
for a Reﬂective Higher-Order Calculus. TGC 2005, 2005, pp. 353-369.
[26]
J.Parrow. An introduction to the π-calculus. In J. Bergstra, A. Ponse
and S. Smolka editors, Handbook of Process Algebra, North-Holland,
Amsterdam, 2001.
[27]
D. Sangiorgi. Extensionality and Intensionality of the Ambient Logic.
In Proc. of the 28th POPL, 2001, pp. 4-17. ACM Press,
[28]
D. Sangiorgi. Bisimulation in higher-order calculi. Information and
Computation, 131(2), 1996, pp. 141-178.
[29]
D. Sangiorgi. Expressing mobility in process algebras: ﬁrst-order and
higher-order paradigms. Ph.D thesis, Department of Computer Science,
University of Einburgh, 1992.
[30]
C. Stirling. Modal Logics for Communicating Systems. Theoretical
Computer Science, (49), 1987, pp. 311-347.
[31]
B. Thomsen, Plain CHOCS: A second generation calculus for higher
order processes. Acta Informatica, Vol 30, 1993, pp. 1-59.
Appendix A. Proof of Proposition 1
Proposition 1 Γ ⊢SL A ⇒ Γ |=SL A
Proof. It is enough by proving that every axiom and every
inference rule of inference system is sound. We only discuss
the following cases:
Case (1): Axiom a®((⊖a)A|B) ↔ (⊖a)A|a®B.
Suppose P ∈ [[a®((⊖a)A|B)]], then P ≡ (νa)(P1|P2),
a /∈ fn(P1), P1 ∈ [[A]] and P2 ∈ [[B]]. Therefore we have
P ≡ (νa)(P1|P2) ≡ P1|(νa)P2, P ∈ [[(⊖a)A|a®B]]. Hence
a®((⊖a)A|B) ↔ (⊖a)A|a®B. The inverse case is similar.
Case (2): Axiom a ̸= b → ((⊖a)b⟨B⟩.A ↔ b⟨(⊖a)B⟩.
(⊖a)A).
Suppose a ̸= b and P ∈ [[(⊖a)b⟨B⟩.A]], then P ≡
b⟨P1⟩.P2, a /∈ fn(P1), a /∈ fn(P2), P1 ∈ [[B]] and P2 ∈
[[A]]. Therefore we have P1 ∈ [[(⊖a)B]] and P2 ∈ [[(⊖a)A]],
P ∈ [[b⟨(⊖a)B⟩.(⊖a)A)]]. Hence a ̸= b → ((⊖a)b⟨B⟩.A →
b⟨(⊖a)B⟩.(⊖a)A). The inverse case is similar.
Case (3): Axiom (A|A ◃ B) → B.
Suppose P ∈ [[A|A◃B]], then P ≡ P1|P2, P1 ∈ [[A]] and
P2 ∈ [[A ◃ B]]. Therefore, P ≡ P1|P2 ∈ [[A|A ◃ B]]. Hence
(A|A ◃ B) → B.
Case (4): Axiom A → (B ◃ A|B).
Suppose P ∈ [[A]], then for any Q ∈ [[B]], P|Q ∈ [[A|B]].
Hence A → (B ◃ A|B).
Case (5): Axiom (((⊖b1, ..., ⊖bn)B
↔
B) ∧ ((˜⊖)C
↔ C)) → ((⟨a⟨b1®...bn®C⟩⟩A)|B → ⟨a⟨b1®...bn®C⟩⟩
(A|B)).
51
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

Suppose P
∈ [[(⟨a⟨b1®...bn®C⟩⟩A)|B]], then P
≡
P1|P2, P1
(νb1,...,bn)a⟨Q⟩
−→
P ′
1, P ′
1
∈
[[A]], P2
∈
[[B]]
and Q ∈ [[C]]. Since (⊖b1, ..., bn)B ↔ B, {b1, ..., bn} ∩
fn(P2) = ∅. Therefore we have P1|P2
(νb1,...,bn)a⟨Q⟩
−→
P ′
1|P2.
Hence (((⊖b1, ..., ⊖bn)B
↔
B) ∧ ((˜⊖)C
↔
C))
→
((⟨a⟨b1®...bn®C⟩⟩A)|B → ⟨a⟨b1®...bn®C⟩⟩(A|B)).
Case
(6):
Axiom
(((⊖b1, ..., ⊖bn)B
↔
B) ∧
((˜⊖)C
↔
C))
→
((⟨a⟨b1®...bn®C⟩⟩A)|⟨a[C]⟩B
→
⟨τ⟩b1®...bn®(A|B)).
Suppose P ∈ [[(⟨a⟨b1®...bn®C⟩⟩A)|⟨a[C]⟩B]], then P ≡
P1|P2, P1
(νb1,...,bn)a⟨Q⟩
−→
P ′
1, P2
a⟨Q⟩
−→
P ′
2, P ′
1
∈ [[A]],
P ′
2 ∈ [[B]] and Q ∈ [[C]]. Since (⊖b1, ..., bn)B ↔ B,
{b1, ..., bn} ∩ fn(P ′
2) = ∅. Therefore we have P1|P2
τ
−→
(νb1, ..., bn)(P ′
1|P ′
2). Hence (((⊖b1, ..., ⊖bn)B
↔
B) ∧
((˜⊖)C
↔
C))
→
((⟨a⟨b1®...bn®C⟩⟩A)|⟨a[C]⟩B
→
⟨τ⟩b1®...bn®(A|B)).
Case (7): Axiom (∧n
i=1a ̸= bi ∧ a ̸= c ∧ ((⊖a)B ↔
B) ∧ ((˜⊖)B
↔
B))
→
(a®⟨c⟨b1®...bn®B⟩⟩A
→
⟨c⟨b1®...bn®B⟩⟩a®A).
Suppose P
∈
[[a®⟨c⟨b1®...bn®B⟩⟩A]], then P
≡
(νa)P1, P1
(νb1,...,bn)c⟨Q⟩
−→
P ′
1, Q ∈ [[B]], P ′
1 ∈ [[A]]. Since
∧n
i=1a ̸= bi∧a ̸= c∧((⊖a)B ↔ B)∧((˜⊖)B ↔ B), a /∈ n(Q).
Therefore we have P ≡ (νa)P1
(νb1,...,bn)c⟨Q⟩
−→
(νa)P ′
1. Hence
(∧n
i=1a ̸= bi ∧ a ̸= c ∧ ((⊖a)B ↔ B) ∧ ((˜⊖)B ↔ B)) →
(a®⟨c⟨b1®...bn®B⟩⟩A → ⟨c⟨b1®...bn®B⟩⟩a®A).
Case (8): Axiom (a ̸= b ∧ ∧n
i=1b ̸= ci ∧ ( B
→
¬(⊖b)⊤) ∧ ((˜⊖)B ↔ B)) → (b®⟨a⟨c1®...cn®B⟩⟩A →
⟨a⟨b®c1®...cn®B⟩⟩A).
Suppose P
∈
[[b®⟨a⟨c1®...cn®B⟩⟩A]], then P
≡
(νb)P1, P1
(νc1,...,cn)a⟨Q⟩
−→
P ′
1, Q ∈ [[B]], P ′
1
∈ [[A]].
Since a
̸=
b ∧ ∧n
i=1b
̸=
ci ∧ ( B
→
¬(⊖b)⊤) ∧
((˜⊖)B
↔
B),
b
∈
fn(Q).
Therefore
we
have
P
≡
(νb)P1
(νb)(νc1,...,cn)a⟨Q⟩
−→
P ′
1. Hence (a
̸=
b ∧
∧n
i=1b
̸=
ci ∧ (B
→
¬(⊖b)⊤) ∧ ((˜⊖)B
↔
B))
→
(b®⟨a⟨c1®...cn®B⟩⟩A → ⟨a⟨b®c1®...cn®B⟩⟩A).
Appendix B. Proof of Proposition 2
Proposition 2 There is no ﬁnite sound inference system
AX such that Γ |=SL A ⇒ Γ ⊢AX A.
Proof. Let Φ = {a⟨0⟩.⊤, a⟨0⟩.a⟨b.0⟩.⊤, a⟨0⟩.a⟨b.0⟩.
a⟨b.b.0⟩.⊤, a⟨0⟩.a⟨b.0⟩.a⟨b.b.0⟩.a⟨b.b.b.0⟩.⊤, ...}. It is easy to
see that any ﬁnite subset of Φ can be satisﬁed in Pr, but Φ
can not be satisﬁed in Pr. Suppose it is not true, let P satisﬁes
Φ. By Lemma 1, there exists n, such that d(P) = n. But for
any n, there exists φn in Φ such that for any P satisfying φn,
d(P) > n. This contradicts the assumption. Therefore Φ can
not be satisﬁed in Pr.
Suppose there is a ﬁnite inference system such that Γ |=SL
A ⇒ Γ ⊢SL A. Since Φ can not be be satisﬁed in Pr, we
have Φ |=SL ⊥. By the assumption, Φ ⊢SL ⊥. Hence there
is a proof from Φ to ⊥ in SL. Since proof is a ﬁnite formula
sequence, there is ﬁnite many formulas φi in Φ occur in the
proof. Therefore we have ∧Φi ⊢SL ⊥, where Φi = {φi | φi
is in the proof}. Then by the soundness of inference system
of SL, we have that Φi is not satisﬁable. Since Φi is a ﬁnite
subset of Φ, this contradicts the assumption. Therefore SL
have no ﬁnite complete inference system.
Appendix C. Proof of Lemma 2
Lemma 2 ⊢SL A|!A ↔!A.
Proof
:
Since
by
the
inference
system,
⊢SL
S(µX.S(X)) → µX.S(X), we have ¬µX.S(X) → ¬S(µX.
S(X)). Let S(X)
=
¬(A|¬X), then ¬µX.S(X)
=
¬µX.¬(A|¬X) =!A, ¬S(µX.S(X)) = A|¬µX.¬(A|¬X) =
A|!A. Therefore we get ⊢SL!A → A|!A.
Since by the inference system, ⊢SL!A
→
A|!A, we
have ⊢SL ¬(A|A|!A) → ¬(A|!A). Let T(X) = ¬(A|¬X),
then T(¬(A|!A)) = ¬(A|A|!A). Since ⊢SL T(¬(A|!A)) →
¬(A|!A), by the inference system, we have ⊢SL µX.T(X) →
¬(A|!A). Furthermore, µX.T(X) = µX.¬(A|¬X) = ¬!A,
hence ⊢SL ¬!A → ¬(A|!A), we have ⊢SL A|!A →!A.
Appendix D. Proof of Proposition 3
Proposition 3 For any P, Q ∈ Prc, P ≡ Q ⇔ P |=SL
T P S(Q) and Q |=SL T P S(P) ⇔ T P S(P) ⊢SL T P S(Q) and
T P S(Q) ⊢SL T P S(P).
Proof. It is trivial by the deﬁnition that P ≡ Q ⇔
P |=SL T P S(Q) and Q |=SL T P S(P). By the soundness,
T P S(P) ⊢SL T P S(Q) ⇒ P |=SL T P S(Q). We only need to
prove P ≡ Q ⇒ T P S(P) ⊢SL T P S(Q) and T P S(Q) ⊢SL
T P S(P).
We only discuss the following cases, other cases are similar
or trivial:
Case (1): (νm)(νn)P ≡ (νn)(νm)P : Since m®n®
T P S(P) ↔ n®m®T P S(P), we have m®n®T P S(P) ⊢SL
n®m®T P S(P). The inverse case is similar.
Case (2): (νa)(P|Q) ≡ P|(νa)Q if a /∈ fn(P) : Since
a /∈ fn(P), (⊖a)T P S(P) ↔ T P S(P). Furthermore, since
a®((⊖a)T P S(P)|T P S(Q))
↔
(⊖a)T P S(P)|a®T P S(Q),
we have a®(T P S(P)|T P S(Q)) ⊢SL T P S(P)|a®T P S(Q).
The inverse case is similar.
Appendix E. Proof of Proposition 4
Proposition 4 For any P, Q ∈ Prc, P
α
−→ Q ⇔ P |=SL
⟨α⟩T P S(Q) ⇔ T P S(P) ⊢SL ⟨α⟩T P S(Q).
Proof. It is trivial by the deﬁnition that P
α
−→ Q
⇔ P |=SL ⟨α⟩T P S(Q). By the soundness, T P S(P) ⊢SL
⟨α⟩T P S(Q) ⇒ P |=SL ⟨α⟩T P S(Q). We only need to prove
P
α
−→ Q ⇒ P ⊢SL ⟨α⟩T P S(P).
We apply the induction on the length of the inference tree
of P
α
−→ Q :
Case (1): if the length is 0, then P
α
−→ Q is in the form
of a⟨E⟩.K
a⟨E⟩
−→ K or a(U).K
a⟨E⟩
−→ K{E/U}.
Subcase
(a):
a⟨E⟩.K
a⟨E⟩
−→
K
:
Since
a⟨E⟩.
T P S(K) → ⟨a⟨E⟩⟩T P S(K), we have a⟨E⟩.T P S(K) ⊢SL
⟨a⟨E⟩⟩T P S(K).
52
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

Subcase (b): a(U).K
a⟨E⟩
−→
K{E/U} : Since (a(U).
T P S(K) ∧ ((˜⊖)T P S(E) ↔ T P S(E))) → ⟨a[T P S(E)]⟩
T P S(K){T P S(E)/U},
we
have
a(U).T P S(K)
⊢SL
⟨a[T P S(E)]⟩T P S(K){T P S(E)/U}.
Case (2): Assume the claim holds if length is n, now we
discuss the case that length is n + 1.
Subcase (a): M
(νeb)a⟨E⟩
−→
M ′
N
a⟨E⟩
−→ N ′
M|N
τ
−→ (νeb)(M ′|N ′)
eb ∩ fn(N) = ∅.
Since M
(νeb)a⟨E⟩
−→
M ′, N
a⟨E⟩
−→ N ′, and eb ∩ fn(N) = ∅, we
have T P S(M) → ⟨a⟨eb®T P S(E)⟩⟩T P S(M ′), T P S(N) →
⟨a[T P S(E)]⟩T P S(N ′) and (⊖b1, ..., bn)T P S(E) ↔ T P S(E).
By
the
axiom:
(((⊖b1, ..., bn)T P S(N)
↔
T P S(N))
∧ (˜⊖)T P S(E))
→
((⟨a⟨b1®...bn®T P S(E)⟩⟩T P S(M))|
⟨a[T P S(E)]⟩T P S(N) → ⟨τ⟩b1®...bn®(T P S(M)|T P S(N))),
we have P
≡
T P S(M)|T P S(N)
⊢SL
⟨τ⟩b1®...bn®
(T P S(M ′)|T P S(N ′)).
Subcase (b):
M
b⟨E⟩
−→ M ′
(νa)M
b⟨E⟩
−→ (νa)M ′
a /∈ n(α).
Since M
b⟨E⟩
−→
M ′
and a
/∈
n(b⟨E⟩), we have
T P S(M)
→
⟨b⟨T P S(E)⟩⟩T P S(M ′) and ((⊖a)T P S(E)
∧ (˜⊖)T P S(E))
↔
T P S(E). By the axiom (a
̸=
b
∧ ((⊖a)T P S(E) ∧ (˜⊖)T P S(E))
↔
T P S(E))
→
(a®
⟨b⟨T P S(E)⟩⟩T P S(M)
→
⟨b⟨T P S(E)⟩⟩a®T P S(M)), we
have
T P S(P)
=
a®T P S(M)
⊢SL
a®⟨b⟨T P S(E)⟩⟩
T P S(M) ⊢SL ⟨b⟨T P S(E)⟩⟩a®T P S(M)).
Subcase (c):
M
(νec)a⟨E⟩
−→
M ′
(νb)M
(νb,ec)a⟨E⟩
−→
M ′
a ̸= b, b ∈ fn(E) − ec.
Since M
(νec)a⟨E⟩
−→
M ′ and a ̸= b, b ∈ fn(E) − ec,
we
have
T P S(M)
→
⟨a⟨ec®T P S(E)⟩⟩T P S(M ′)
and
a ̸= b ∧ ∧n
i=1b ̸= ci ∧
(B → ¬(⊖b)⊤). By the axiom
(a ̸= b ∧ ∧n
i=1b ̸= ci ∧
(E → ¬(⊖b)⊤) ∧ ((˜⊖)E ↔
E)) → (b®⟨a⟨c1®...cn®T P S(E)⟩⟩T P S(M ′) → ⟨a⟨b®c1
®...cn®T P S(E)⟩⟩T P S(M ′)),
we
have
T P S(P)
=
b®T P S(M) ⊢SL (b®⟨a⟨c1®...cn®T P S(E)⟩⟩T P S(M ′) ⊢SL
⟨a⟨b®c1®...cn®T P S(E)⟩⟩T P S(M ′).
53
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

