Alignment of Test Driven Development and Relative Correctness-based Development
Marwa Benabdelali
Universit´e de Tunis
Institut Sup´erieur de Gestion de Tunis
Bardo, Tunisia, Lab. RIADI-GD
Email: marwa.benabdelali@yahoo.com
Lamia Labed Jilani
Universit´e de Tunis
Institut Sup´erieur de Gestion de Tunis
Bardo, Tunisia, Lab. RIADI-GD
Email: lamia.labed@isg.rnu.tn
Abstract—Deriving programs by reliability enhancement is the
aim of a program development process based on relative cor-
rectness as presented in previous studies. In fact, it is clear
that nowadays we do not develop programs from scratch but
we exploit existing ones and try to modify and adapt them
according to a given speciﬁcation. On the other hand, the
practice of agile methods is increasingly widespread in software
development. In this paper, we are interested in the relation
between Test Driven Development and Reliability Enhancement
Development. Test Driven Development as a software engineering
methodology is built upon eXtreme Programming. It emphasizes
a test ﬁrst approach, which differs from the traditional software
development cycle and produces better software quality. Relative
correctness is a formal model that permits to verify that a
program P is more-correct than a program P′. This is the core
of a development process based on reliability enhancement. We
align the two processes, compare them and show that : 1)Test
Driven Development is an instance of reliability enhancement
development process and 2) Test Driven Development iteration
can be used as a mean to transform a program P to another
program P′ that is more-correct than P according to a given
speciﬁcation R.
Keywords–Reliability enhancement; Relative correctness; Spec-
iﬁcation; Test Driven Development.
I.
INTRODUCTION
Software maintenance and evolution are known to require
a lot of effort and, to cope with this, developing reusable assets
turns out to be an interesting approach as it allows to reduce the
time and cost for software development. In this context, Test
Driven Development (TDD) and Relative Correctness-Based
Development (RCBD) aim at managing software quality by
means of incrementally developing assets (i.e., test cases and
speciﬁcations) to guarantee that previously added behaviors
still persist after changes and reﬁnements. RCBD [1] proves
its worth as a rigourous theoretical framework that derives
programs by successive correctness enhancing transformations
rather than deriving programs by successive correctness pre-
serving transformations [2][3][4]. Whereas correctness preser-
vation is the prevailing paradigm in programs construction,
correctness enhancement seems to be a promising tentative
for constructing correct and reliable programs and it formally
models a wide range of software activities, as programs repair,
evolution, etc. In this paper, we are speciﬁcally working on
TDD and show that is an instance of RCBD. On the other
hand, we use TDD iterations as a means for transforming one
program P into another more correct program according to a
given speciﬁcation R. Indeed, we discuss that despite the fact
that the program construction process using TDD is different
to that of RCBD, the results obtained by both processes are
the same, where we obtain a sequence of programs that are
respectively more-correct with respect to a speciﬁcation.
The paper is structured as follows; Section 2 brieﬂy in-
troduces some relational mathematics that we use throughout
the paper to represent specications and programs. Section 3
presents the concept of relative correctness as a formal and
generic model that allows the construction of reliable and
correct programs. Section 4 aligns the TDD process and that
of RCBD. Section 5 presents with an illustrative example the
TDD as a strategy to derive reliable programs by correctness
enhancement. Section 6 summarizes our ﬁndings and presents
some perspectives on this work.
II.
MATHEMATICAL BACKGROUND
In this paper, we use relational mathematics [5] to
represent speciﬁcations and program functions. We represent
sets in a program-like notation by writing variable names
and associated data types (sets of values); if we write S as:
x : X;y : Y; then, we mean to let S be the cartesian product S =
X × Y; elements of S are denoted by s and the X −component
of s is denoted by x(s) and the Y −component of s is denoted
by y(s). When no ambiguity arises, we may write x for x(s),
and x′ for x(s′).
Given a program p that operates on a space called S and
all the elements of S are called the states of p that are usually
denoted in lower case s. We let P be the function of p that is
represented as the set of pairs (s,s′) such that if the program
p starts the execution in state s then, it terminates in state s′.
A relation R on a set S is a subset of the cartesian product S
× S; given a set of pairs (s,s′) in R, we say that state s′ is an
image of state s by R.
Relations
on
S
include
the
identity
relation
I = {(s,s′)|s′ ∈ S}, the empty relation φ = {} and the universal
relation L = S × S. As for operations on relations, they
include the set theoretic operations of intersection (R ∩ R′),
difference(R \ R′), complement( ¯R), and union(R ∪ R′). They
also include the converse of a relation bR = {(s,s′)|(s′,s) ∈ R},
the product of two relations (R o R′) or (RR′, for short)
={(s,s′)|∃s′′ : (s,s′′) ∈ R ∧ (s′′,s′) ∈ R′} and the domain of a
relation dom(R) = {s|∃s′ : (s,s′) ∈ R}.
A relation R is symmetric if and only if R = bR,
antisymmetric if and only if R∩ bR ⊆ I and asymmetric if and
only if R ∩ bR = φ. A relation R is transitive if and only if
RR ⊆ R and reflexive if and only if I ⊆ R. A relation R is
partial ordering if and only if it is reflexive, antisymmetric,
217
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

and transitive. A relation R is deterministic if and only if
bRR ⊆ I and total if and only if I ⊆ bRR. A relation R is a
vector if and only if RL = R. Vectors are used to represent
subsets of S. A relation R refines relation R′ (R′ ⊒ R or R ⊑
R′) if and only if RL ∩ R′L ∩( R ∪ R′)= R′.
Deﬁnition 1. Program P on space S is correct with respect to
a speciﬁcation R if and only if P refines R ((R∩P)L = RL).
Note that RL refers to the domain of the speciﬁcation R
that represents the initial states for which candidate programs
must behave according to R. And the relation (R∩P)L refers
to the set of initial states on which the behavior of P satisﬁes
speciﬁcation R. This set is denoted the competence domain of
P with respect to R.
III.
PROGRAM CONSTRUCTION BY RELATIVE
CORRECTNESS
Whereas the traditional approach that preserves correctness
is the dominant paradigm in program construction, the issues
become no longer to develop program from scratch but rather
to achieve a satisfactory reliability threshold with respect
to a given specication. Being in this context, RCBD has
proven its value as an alternative approach to the traditional
reﬁnement-based process of successive correctness-preserving
transformations starting from the speciﬁcation and culminating
in a correct program (Figure 1). Where in the left side, program
construction is done by correctness preserving transformations
starting from a correct speciﬁcation until obtaining a correct
program. In the right side, an abort program is transformed
to a more correct program according to a speciﬁcation R.
Then, series of similar transformations are done to obtain
more and more correct programs (by correctness enhancement
transformations). The process stopped when a correct program
is completely derived.
Figure 1. Program derivation process [1].
The concept of relative correctness was introduced in [1] as
the property of a program to be more correct than another
program with respect to a speciﬁcation. We say that program
P reﬁnes program P if and only if P is more-correct than P
with respect to a speciﬁcation.
Deﬁnition 2. Due to [1] given two programs P0, P1 and a
speciﬁcation R; we say that P1 is more-correct than P0 if and
only if P1 obeys R for a larger set of inputs than P0. This rela-
tion is denoted by P0 ⊑R P1 which is equivalent to the relation:
(R∩P0)oL ⊆ (R∩P1)oL. Also, we say that P1 is strictly more-
correct than P0 with respect to R if and only if P0 ⊏R P1 which
is equivalent to the relation (R∩P0)oL ⊂ (R∩P1)oL.
The relation (R ∩ P0)oL refers to the competence domain
of P0 with respect to R (denoted by CDP0) which is the initial
states on which the behavior of P0 satisﬁes speciﬁcation R.
Relative correctness of P1 over P0 with respect to R simply
means that P1 has a larger competence domain than P0.
To illustrate this deﬁnition; Let S be the space deﬁned by {0,
1, 2, 3} and let R be the following speciﬁcation on S:
R = {(0,1),(0,2),(1,2),(1,3),(2,0),(2,2),(3,1),(3,2),(3,3)}.
We consider the following candidate programs:
P0 = {(0,0),(0,1),(0,2),(1,0),(1,1),(2,0),(2,1),(2,3),(3,0)}.
P1 = {(0,0),(0,1),(1,0),(1,2),(1,3),(2,0),(2,3),(3,0)}.
CDP0 = (R∩P0) = {(0,1),(0,2),(2,0)}
(R∩P0)oL = {0,2}×S
CDP1 = (R∩P1) = {(0,1),(1,2),(1,3),(2,0)}
(R∩P1)oL = {0,1,2}×S
Hence P1 is more-correct than P0 with respect to R. And we
say that P0 ⊑R P1.
IV.
TEST DRIVEN DEVELOPMENT AS AN INSTANCE OF
RELATIVE CORRECTNESS-BASED DEVELOPMENT
TDD [6] is considered to be one of the most effective
development approaches that is derived from the agile software
development methodology called eXtreme Programming (XP)
[7]. It depends on a short development life cycle where the
developer incrementally writes unit tests before any program
code and is considered as a set of iterations where from one
iteration to another we go from a program P to program P′
that is more correct. TDD process revolves around ﬁve steps:
1) Write the ﬁrst test. 2) Run the test and conﬁrm that it
cannot pass without any implemented code. 3) Write enough
code to make test pass. 4) Run the test on the previous code
and conﬁrm the test pass else the code must be modiﬁed
until the test pass. 5) Refactor which means to improve
the code while keeping the same functionalities. The cycle
must be repeated until all the speciﬁcation functionalities are
implemented and therefore we obtain a correct program that
meets the speciﬁcation.
TDD and RCBD are both programs derivation approaches.
Despite the fact that their derivation processes are different,
both processes give as a result a sequence of programs that
are respectively more correct with respect to the speciﬁcation.
So, our aim is to align the TDD process with that of RCBD
and formally validate that TDD is an instance of RCBD.
As shown in Figure 2, using series of test data speciﬁcations
∑n
i=1 Ti, we create a list of programs ∑n
i=1 Pi such as each Pi
is an upgrade of Pi−1. We assume that the Ti’s have disjoint
domains. Let Ri be the sequence of relations deﬁned for
0 ≤ i ≤ n by:
R0 = φ, for 1 ≤ i ≤ n: Ri = ∪i
k=1 Tk.
By this deﬁnition, and by virtue of the hypothesis that the Ti’s
have disjoint domains, for 1 ≤ i ≤ n, we can write: Ri = Ri−1⊔
Ti.
According to this formula, each step of TDD can be modeled
as an instance of program upgrade. Indeed, if we let P0 be
{abort} and we let Pi be the program derived at phase i by
upgrading Pi−1 with speciﬁcation Ti , then, we can prove by
218
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

Figure 2. Alignment of Test Driven Development with relative correctness.
induction that for all i, 0 ≤ i ≤ n, Pi is correct with respect to
Ri. The following proposition provides that if we rename Rn as
R and we let Qi be the pre-restriction of Pi to the domain of Ri
, then {Qi} forms a sequence of increasingly correct programs
with respect to R.
Proposition 1. We consider a space S and a non-empty test
data speciﬁcations Ti on S, 1 ≤ i ≤ n, for some n ≥ 1 such that
TiL ∩ TjL = φ for any i ̸= j. We deﬁne a set of speciﬁcations
{Ri} by:
R0 = φ, for 1 ≤ i ≤ n : Ri = ∪i
k=1 Tk
And we let {Pi}, for 1 ≤ i ≤ n, be a set of programs such that
for all i, Pi is correct with respect to Ri. Further, we let {Qi}
be the set of programs deﬁned by: Qi = Pi ∩ RiL. Then, for
all i, 0 ≤ i ≤ n, Qi+1 is more-correct than Qi with respect to
Rn.
Proof: We rename Rn as R and we resolve to prove that
for all i between 0 and n−1, Qi+1 ⊒R Qi.
To this effect, we must show that the competence domain of
Qi is a subset of that of Qi+1:
(Qi ∩ R)L
=
{Deﬁnition of Qi}
(Pi ∩ RiL ∩ R)L
=
{By construction of R, Ri}
(Pi ∩ Ri)L
=
{By deﬁnition 1}
RiL
⊂
{By construction of Ri, and hypothesis that Ti ̸= φ}
Ri+1L
=
{By deﬁnition 1}
(Pi+1 ∩ Ri+1)L
=
{By construction of R, Ri+1}
(Pi+1 ∩ Ri+1L ∩ R)L
=
{Associativity, Commutativity, Deﬁnition of
Qi+1}
(Qi+1 ∩ R)L
Therefore, TDD can be seen as an instance of RCBD. How-
ever, the main difference between both development processes
is that in the TDD process the speciﬁcation is not known in
advance but is built progressively alongside the program.
Test-driven development with the support of relative cor-
rectness offers the possibility to have a formal way for verify-
ing to what extend sufﬁciently reliable programs are generated.
On the other hand, deriving programs by relative correctness
can use test-driven development iterative steps as a strategy
for transforming one program to another more reliable one.
V.
TEST DRIVEN DEVELOPMENT ITERATION AS A
TRANSFORMATION STRATEGY FOR RELATIVE
CORRECTNESS-BASED DEVELOPMENT
Despite that program derivation by relative correctness
is a promising tentative for constructing reliable programs,
we argue that this latter process is not efﬁcient as program
derivation by reﬁnement calculus which is older, matter and
based on set of strong rules and sophisticated guidelines for
program transformations. For that, we tried in [8] to ﬁnd
some mechanisms and scenarios for program transformation
in the relative correctness- based reliable program construction
approach. The ﬁrst scenario is domain enlargement in which
we keep the same program functionalities and at each transition
from one program to another, we increase the domain of
the program (dom(P)) with respect to the domain of the
speciﬁcation (dom(R)). The second scenario is a particular
case in which the program does something else but in some
particular cases, it does what the speciﬁcation R requires,
so it sufﬁces to generate such program from P to P′. The
third scenario is changing behavior where the behavior of the
program changes depending on the type of input data, hence
the next generated program P′ adds code for a new type of
input in addition to the existing ones in program P. And the
last and fourth scenario is improve program functionality
in which from one program to another, we add a little bit
of code to the program compared to his predecessor until
we reach an absolutely correct program with respect to R or
we reach a sufﬁciency reliability threshold. With these four
scenarios, we can also resort to the reuse-based development
with the reusable programs stored in a repository in which
we start with an abort program that never run successfully and
then, we search in the repository for programs that are more
correct according to the speciﬁcation R by competence domain
calculations.
Being in the context of program repair and as a tentative
for program derivation mechanism by relative correctness,
the authors in [9] present a generic algorithm that proceeds
by successive removed fault as the relative correctness rises
with each fault removal until reaching a correct program
according to a given speciﬁcation. This algorithm is based on
the availability of a patch generator and focuses on the patch
validation steps. The algorithm takes as input; a program P on
space S, a test data set T as a subset of S, a speciﬁcation R
on S, and the domain of the speciﬁcation R (dom(R)). And
depending on patch generator, it returns as output either an
absolutely correct program P′ with respect to R, or a strictly
more-correct program P′ than P with respect to R or a message
indicate that is impossible to more enhance correctness of P
with respect to R.
Another tentative for program derivation mechanism by
relative correctness is based on mutation testing [10] that
allows gradually repairing an incorrect program by removing
its faults one by one. Indeed, the derivation process starts by a
faulty program P and repeatedly applying muJava to generate
mutants.Then, taking mutants which are found to be strictly
more-correct as base programs and recursively repeating the
process until reached a correct program according to given
speciﬁcation R. Hence the transition from faulty program P to
these generated mutants represents a fault removal and falls in
the program repair activity.
Remaining in program derivation strategies by relative cor-
rectness, an iteration in the Test Driven Development process
can be a mechanism that guides and deﬁnes the derivation of
reliable program by exploring the unit test notion which is
219
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

the center of TDD (development process in table I). Indeed,
we start from an abort program (P0) that never run successful
with respect to R (we reuse programs that dont response to
the speciﬁcation or we evolve existing programs). We create
a ﬁrst test (t0), run it on the abort program and conﬁrm its
failure else we rewrite it. then, we create enough code for
P1 to make t0 pass. We create t1 code that must integrate
the t0 code, we run it on P1 and we conﬁrm its failure
else we rewrite it. Then, we create P2 to make t1 pass and
here we check correctness enhancement from P1 to P2 by
ensuring that CDP1 ⊆ CDP2 which means that P2 reﬁnes P1.
Therefore, we write P1 ⊑R P2. Note that for P0 and P1 we
may calculate their competence domains but is not necessary
to ensure thatCDP0 ⊆ CDP1 because P0 is an abort program
that never meets the speciﬁcation R. To create Pn programs,
we need Tn−1 tests. Table I shows a comparison between
the TDD process phases and those of RCBD phases and a
highlight of TDD process contribution to RCBD. Indeed, what
we have done is to draw inspiration from TDD approach to
construct programs using the concept of relative correctness.
To summarize the derivation process, at each transition from
TABLE I. PROGRAM CONSTRUCTION PROCESSES.
Test Driven Develop-
ment process
Relative
correctness
process
Relative
correctness
process using TDD
1
Write ﬁrst test.
Write an abort pro-
gram.
Create an abort pro-
gram and a ﬁrst test.
2
Run test and assure its
failure because code
has
not
yet
imple-
mented.
Create the next pro-
gram using a deriva-
tion mechanism.
Run the test on the
abort
program
and
conﬁrm its failure else
rewrite it.
3
Write enough code to
makes test pass.
Calculate the function
and
the
competence
domain
of
the
pro-
gram.
Create the ﬁrst pro-
gram to make the test
pass.
4
Run test on code and
conﬁrm
its
success
else rewrite the code
until the test pass.
Ensure that CDPi ⊆
CDPi+1.
Calculate the function
and
the
competence
domain
of
the
pro-
gram.
5
Refactor.
Repeat the cycle from
the second step until
reach correct or reli-
able program accord-
ing to the speciﬁca-
tion.
Create the second test,
run it on the ﬁrst pro-
gram and conﬁrm its
failure else rewrite it.
6
Repeat
the
cycle
from
the
beginning
until
reach
correct
program according to
the speciﬁcation.
Create the second pro-
gram
to
make
the
second test pass and
ensure
that CDPi ⊆
CDPi+1.
7
Repeat the cycle from
the
third
step
until
reach correct program
or satisfactory reliabil-
ity threshold.
one program to another we use the notion of test and for each
program created,we must ensure that it reﬁnes his predecessor
so we ensure that CDPi ⊆ CDPi+1. When we create a program
to make the test pass, we obtain a part Ri of the speciﬁcation
R and at the end of the derivation, R is constructed by the
union of all the Ri.
As an illustration of the TDD strategy, we conduct a
simple empirical experimentation using java language and
Junit [11] as a testing frameworks. Junit is the most popular
testing frameworks for Java language used by developers to
implement unit testing. It is based on assertions that test
speciﬁc functionality in the code. The choice of this one is
because it is suitable to be used with test driven development
and eXtreme Programming.
What we are going to do is to follow the construction strategy
presented above to derive either correct or reliable programs
according to given speciﬁcation.
As a hypothesis, we suppose that test cases constitute the
speciﬁcation that is known in advance in the approach of
deriving programs by relative correctness (see proposition 1).
Let S be the space deﬁned by the integer variable x and the
integer array TAB.
and let R be the following speciﬁcation on S:
R = {(s,s′)|((∀i : 0 ≤ i ≤ N : x′ ≥ TAB[i])∧(∃i : 0 ≤ i ≤ N : x′ =
TAB[i]))}.
The speciﬁcation mandates that x be assigned the largest
integer value in TAB.
For the ﬁrst step, we create P0 as an abort program, create
a test T0 and run P0 on this test. As a better example of an
abort program would be one that throws an exception or one
that does not exist at all, as is the case in traditional Test
Driven Development. Therefore, its competence domain is the
empty set. Indeed, it does not meet any functionality of the
speciﬁcation R. We create the test T0 and run it on the abort
program.
T0: import junit.framework.*;
public class TestMax extends TestCase {
public TestMax(String name) {
super(name);}
public void test0() {
assertEquals(200,
Max.maxval(new int[ ] {200, 50, -2, 80, 0 }));}}
Obviously, the console display the red bar which shows
that the abort program (P0) fails to meet the test T0. To make
the later pass, we need to create enough code for P1:
P1: public class Max {
public static int maxval(int[] tab) {
int max = tab[0];
return max;}}
The function of this program and its competence domain
are given as:
P1 = {(s,s′)|((∀i : 0 ≤ i < N : TAB[0] ≥ TAB[i]) ∧ (x′ =
TAB[0]))}
CDP1 = (R∩P1)oL
= {(s,s′)|(∀i : 0 ≤ i < N : TAB[0] ≥ TAB[i])}.
Indeed, this is the competence domain of P1 with respect to
R: which is the arrays that contain the largest value in index
0.
We run P1 on T0. As shown in Figure 3, the console displays
the green bar which means that the P1 succeeds to to meet
the test T0.We may end the derivation at this stage to obtain
therefore a reliable program according to R but in order to
obtain an absolute correct program we continue the derivation
process.
Figure 3. Green bar T0.
For the next step, We create the test T1 and we run it on the
previous program (P1).
We assume that T0 ⊆ T1.
T1: import junit.framework.*;
220
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

public class TestMax extends TestCase {
public TestMax(String name) {
super(name);}
public void test1() {
assertEquals(200,
Max.maxval(new int[ ] {200, 50, -2, 80, 0 }));
assertEquals(200,
Max.maxval(new int[ ] {50, -2, 80, 200, 0}));}}
As the execution result, the console displays the red bar
(Figure 4) which shows that P1 fails to meet the test T1.
Figure 4. Red bar T1.
As we previously did, we create enough code for program P2
to pass the test T1.
P2: public class Max {
public static int maxval(int[] tab) {
int index, max = 0;
for (index = 0; index < tab.length-1; index++){
if (tab[index] > max) {
max = tab[index];}}
return max;}}
The function of this program and its competence domain are
given as:
P2 = {(s,s′)|((∀i : 0 ≤ i < N : x′ ≥ TAB[i]) ∧ (∃i : 0 ≤ i < N :
x′ = TAB[i]))}
CDP2 = (R∩P2)oL
= {(s,s′)|(∀i : 0 ≤ i < N : x′ ≥ TAB[i])}.
Indeed, this is the competence domain of P2 with respect to R:
which is the arrays that contain the largest value in any index
except the last index.
We run P2 on T1. The console displays the green bar (Figure 5)
which means that the P2 succeeds to to meet the test T1. We
conﬁrm that CDP1 ⊆ CDP2 means that P1 ⊑R P2.
Figure 5. Green bar T1.
At this derivation stage, we may end the derivation, hence we
obtain a reliable program according to the speciﬁcation R but
we continue the derivation process until we reach an absolute
correct program.
we create a test T2 and we run it on the previous program. We
assume that T1 ⊆ T2.
T2: import junit.framework.*;
public class TestMax extends TestCase {
public TestMax(String name) {
super(name);}
public void test2() {
assertEquals(200,
Max.maxval(new int[ ] {200, 50, -2, 80, 0 }));
assertEquals(200,
Max.maxval(new int[ ] {50, -2, 80, 200, 0}));
assertEquals(200,
Max.maxval(new int[ ] {50, -2, 80, 0, 200}));}}
As a result of running P2 on T2, the console displays the red
bar (Figure 6) which shows that P2 fails to meet the test T2.
indeed, P2 returns the maximum value that exists in any index
expect the last index of tab however, T2 tests on the maximum
value that exist in any index.
Figure 6. Red bar T2.
As a solution to make the previous test pass(T2), we create a
program P3.
P3: public class Max {
public static int maxval(int[] tab) {
int index, max = 0;
for (index = 0; index < tab.length; index++){
if (tab[index] > max) {
max = tab[index];}}
return max;}}
The function of this program and its competence domain are
given as:
P3 = {(s,s′)|((∀i : 0 ≤ i ≤ N : x′ ≥ TAB[i])∧(∃i : 0 ≤ i ≤ N : x′ =
TAB[i]))}.
CDP3 = (R∩P3)oL = RL = S
The competence domain of P3 is R. Therefore, P3 is correct
according to R. We run P3 on T2. The console displays the
green bar (Figure 7) which means that P3 succeeds to meet
the test T2.
Figure 7. Green bar T1.
At this derivation stage, we obtain a correct program that
meets all the functionalities mandates by the speciﬁcation
221
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

R. Therefore, we do have: CDP1 ⊆ CDP2 ⊆ CDP3. Hence
P1⊑RP2⊑RP3.
VI.
CONCLUSION
TDD has received considerable individual attention since
XPs introduction. Many recent researchers works show that
Test Driven Development gives rise to defect reduction and
quality improvement in academic and professional environ-
ments. On the other hand, RCBD seems to be adequate to do
almost the same thing as Test Driven Development but in a
formal manner. In this work, we showed formally that TDD is
an instance of RCBD and also a TDD iteration (testing, coding,
refactoring) can be an adopted strategy in the transformation
process of Relative Correctness Enhancement. This is also a
way to validate formally each TDD iteration. As near future
work, we are going to test the RCBD on real cases where the
transformation from one program to another is done according
to the TDD iteration strategy.
REFERENCES
[1]
N. Diallo, W. Ghardallou, J. Desharnais, and A. Mili, “Program deriva-
tion by correctness enhacements,” in Proceedings 17th International
Workshop on Reﬁnement, Reﬁne@FM 2015, Oslo, Norway, 22nd June
2015., 2015, pp. 57–70, URL: https://doi.org/10.4204/EPTCS.209.5/
[accessed: 2019-08-04].
[2]
R.-J. Back, “On the Correctness of Reﬁnement Steps in Program
Development,” Ph.D. dissertation, 1978.
[3]
C.
Morgan,
Programming
from
speciﬁcations,
ser.
Spectrum
Book.
Prentice
Hall,
1990,
URL:
https://books.google.tn/books?id=95dQAAAAMAAJ/
[accessed:
2019-08-03].
[4]
R. Back and J. von Wright, Reﬁnement Calculus a Systematic Intro-
duction.
Springer-Verlag New York, 1998.
[5]
C. Brink, W. Kahl, and G. Schmidt, Eds., Relational Methods in
Computer Science.
Berlin, Heidelberg: Springer-Verlag, 1997.
[6]
K. Beck, Test Driven Development. By Example (Addison-Wesley
Signature).
Addison-Wesley Longman, Amsterdam, 2002.
[7]
K. beck, Extreme Programming Explained: Embrace Change.
Boston,
MA, USA: Addison-Wesley Longman Publishing Co., Inc, 2000.
[8]
M. Benabdelali, L. L. Jilani, W. Ghardallou, and A. Mili, “Program-
ming without reﬁning,” in Proceedings 18th Reﬁnement Workshop,
Reﬁne@FM 2018, Oxford, UK, 18th July 2018., 2018, pp. 39–52, URL:
https://doi.org/10.4204/EPTCS.282.4/ [accessed: 2019-08-04].
[9]
B. Khaireddine, A. Zakharchenko, and A. Mili, “A Generic Algorithm
for Program Repair,” in 2017 IEEE/ACM 5th International FME Work-
shop on Formal Methods in Software Engineering (FormaliSE), May
2017, pp. 65–71.
[10]
N. Diallo, W. Ghardallou, and A. Mili, “Program repair by step-
wise correctness enhancement,” in Proceedings First Workshop on
Pre- and Post-Deployment Veriﬁcation Techniques, PrePost@IFM
2016, Reykjav´ık, Iceland, 4th June 2016., 2016, pp. 1–15, URL:
https://doi.org/10.4204/EPTCS.208.1/ [accessed: 2019-08-06].
[11]
K. Beck, JUnit - pocket guide: quick lookup and advice.
O’Reilly
Media, 2009.
222
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

