Worst Case Modeling of Aggregate Scheduling by Network Calculus
Ulrich Klehmet
R¨udiger Berndt
Computer Networks and Communication Systems
Friedrich-Alexander-Universit¨at Erlangen-N¨urnberg, Germany
Email: {ulrich.klehmet, ruediger.berndt}@fau.de
Abstract—Network Calculus (NC) is a powerful mathematical
theory for the performance evaluation of communication systems,
since it allows to obtain worst-case performance measures. In
communications system modeling, the NC theory is often used
to determine Quality of Service (QoS) guarantees, for example of
packet-switched systems. In networking systems, the aggregation
of data ﬂows plays an important role while modeling the
multiplexing scheme. When the multiplexing order is not First
in, First out (FIFO), the strictness of the service curve plays an
important role. This article deals with problems that arise from
the strictness requirement considering aggregate scheduling. The
literature reports that the strictness of an aggregated service
curve is a fundamental precondition to obtain the individual
service curve for a single left-over ﬂow when a node processes
multiple input ﬂows in a non-FIFO manner. In many publica-
tions, this important strictness property is assumed to be a feature
of the service curve only. We will show that, in general, this
assumption is not true. In most cases, only the concrete input ﬂow
in connection with the service curve allows to decide whether the
service curve is strict or non-strict. However, the abstraction from
a concrete input ﬂow with an arrival curve as upper bound is
not enough to determine the service curve’s strictness. Therefore,
to bypass the strict-non-strict problems, we devise theorems to
gain guaranteed performance values for a left-over ﬂow.
Keywords– Worst-case Communication System Modeling;
Network Calculus; Aggregate Scheduling; Strict-non-strict
Service Curves; Backlogged Period
I. INTRODUCTION
For systems with hard real-time requirements, timeliness
plays an important role. This Quality of Service (QoS) re-
quirement can be found in various kinds of systems, includ-
ing cars, airplanes, industrial networks, or power plants [1].
Analytical performance evaluation of such systems cannot be
based on stochastic modeling, like traditional queuing theory,
only. Since worst-case performance parameters like maximum
delay of service times [2] are required, the knowledge of
mean values is not sufﬁcient. In other words, one needs a
mathematical tool to calculate performance ﬁgures—in terms
of bounding values—which are valid in any case. Such a
tool is Network Calculus (NC), as a novel system theory for
deterministic queuing systems [3] [4].
This article is structured as follows: In Section II, we
describe the basic elements of NC. Section III introduces
aggregate scheduling and the use of NC w.r.t. the analysis of
individual ﬂows as part of an aggregation. Section IV shows
possibilities to overcome the problems described in Section III.
Finally, in Section V we draw a conclusion.
II. BASIC MODELING ELEMENTS OF NETWORK CALCULUS
The most important modeling elements of NC are given by
arrival curves, service curves, and the min-plus convolution.
Arrival and service curves are the basis for the computation of
maximum deterministic boundary values, like backlog bounds,
or delay bounds [4].
Deﬁnition 1 (Arrival curve): Let α(t) be a non-negative,
non-decreasing function. Flow F with input x(t) at time t is
constrained by the arrival curve α(t) iff:
∀ 0 ≤ s ≤ t : x(t) − x(s) ≤ α(t − s)
(1)
Flow F is also called α-smooth.
Example 1: A commonly used arrival curve is the token
bucket constraint:
αr,b(t) =
(
r · t + b
for t > 0
0
otherwise
(2)
Figure 1 shows a token bucket arrival curve (dashed blue line)
forming an upper limit for a trafﬁc ﬂow x(t) with an average
rate r and an instantaneous burst b. This means for ∆t := t−s
and ∆t → 0, limt→s{x(t)−x(s)} ≤ lim∆t→0{r·∆t+b} = b.
s
t −
x(t)
r t b
t
( )= ⋅ +
α
s
time
data
b
Figure 1. Token bucket arrival curve
Next to arrival curves, the convolution operation plays an
important role in NC theory.
Deﬁnition 2 (Min-Plus Convolution): Let f(t) and g(t) be
non-negative, non-decreasing functions that are 0 for t ≤ 0. A
third function, called min-plus convolution is deﬁned as:
(f ⊗ g)(t) =
inf
0≤s≤t{f(s) + g(t − s)}
(3)
By applying this operation, arrival curve α(t) can be char-
acterized with respect to x(t) as:
x(t) ≤ (x ⊗ α)(t)
(4)
Service curves, in contrast to arrival curves, are used to
model the output of a system—for example to determine
whether there is a guaranteed minimum output y(t).
44
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-398-8
ICN 2015 : The Fourteenth International Conference on Networks

y(t)
(t)
x
)( )
(
t
x
β
⊗
time
data
Figure 2. Convolution as a lower output bound
Deﬁnition 3 (Service Curve): Let system S with input
ﬂow x(t) and output ﬂow y(t) be given. The system has a
(minimum) service curve β(t), iff β(t) is a non-negative, non-
decreasing function with β(0) = 0 and
y(t) ≥ (x ⊗ β)(t)
(5)
Figure 2 shows (x ⊗ β)(t) = inf0≤s≤t{x(s) + β(t − s)} as
lower bound of output y(t) w.r.t. input x(t).
Example 2: The commonly used rate-latency function re-
ﬂects a service element which offers a minimum service of
rate R after a worst-case latency of T, by doing so, all internal
behavior of the service is hidden and only the worst-case is
described.
β(t) = βR,T (t) = R · [t − T]+ := R · max{0; t − T}
(6)
In Figure 4, the graph of βR,T (t) (green) depicts the rate-
latency service curve with rate R and latency T.
Consider a system S with input ﬂow x(t), arrival curve α(t),
output ﬂow y(t) and service curve β(t). Then, according to
[4], the following three bounds can be calculated.
Proposition 1 (Backlog, Delay and Output bound):
• Backlog bound v:
v(t) = x(t) − y(t) ≤ sups≥0{α(s) − β(s)}
• Delay bound d(t) of input x (FIFO service):
d ≤ sups≥0{inf{τ : α(s) ≤ β(s + τ)}}
• Output bound α∗(t):
α∗(t) = α ⊘ β := sups≥0{α(t + s) − β(s)}
Figure 3 depicts d and v for a general arrival- and service
curve.
time
data
(t)
d
v
α
β
Figure 3. Backlog and delay bound
Example 3: Suppose a system with token bucket input and
rate-latency service, according to (1), (3), (5), and based on
v
time
α
b
r,
R,T
β
R
b
T
d
+
≤
data
β
α ∅
r
R
rT
b +
T
b
Figure 4. Example for all bounds, cf. Proposition 1
Proposition 1 the delay bound is given by d ≤
b
R + T, the
output bound by α∗(t) = r(t + T) + b, and the backlog is
bounded by v = b + rT (see Figure 4).
III. AGGREGATE SCHEDULING
Up to now, only single ﬂow-based scheduling has been con-
sidered. But, in many real-world systems aggregate scheduling
is used [5]. We speak of aggregate scheduling whenever at
least two streams are handled as a single stream. While in
[6], delay bounds for FIFO networks are given, in [7] the
main goal is to derive end-to-end delay bounds for general
multiplexing. Important applications of aggregate scheduling
are, among others, differentiated service domains (DS) of
the Internet, the determination of safety-critical delay bounds
within automotive intra car-communication [8], and diverse
time-critical industrial applications [9].
In order to apply NC to such communication networks,
we have to expand the rules to multiplexing and aggregate
scheduling.
Assume that n ﬂows enter a system (network) or system
node which are scheduled by aggregation. According to [10]
the aggregate input ﬂow and arrival curve are given as follows.
Deﬁnition 4 (Aggregation, Multiplexing): An aggregation
(also: multiplexing) of n ﬂows can be expressed by adding
the single input ﬂows and arrival curves, respectively:
let n = 2, then the aggregated input ﬂow is x(t) = x1(t) +
x2(t) and α(t) = α1(t) + α2(t), where x1, x2 and α1, α2 are
the corresponding single input ﬂows and arrival curves.
( )
( )
( )  
2
1
x t
x t
x t
+
=
( )
( ),
* t
y t
α
Multiplexing 
n = 2
4444
8
4
444
7
6
( )
),
), y ( ),d(
(
( )
),
( ), y ( ),d(
 
*
2
2
2
2
*
1
1
1
1
t
x
t
t
t
x
t
t
α
β
α
β
Unknown:
( )
( )
( )  
2
1
t
t
t
α
α
α
+
=
(t)
β
Demultiplexing
n = 2
(t)
β
β (t)
M
( )
( ),
1
1
t
x t
α
( )
( ),
t
t
x
n
n
α
General case
( )
1 t
y
yn (t)
M
Figure 5. Multiplexing of ﬂows: input xi, output yi, arrival & service curve
αi, β(t) = βaggr
Considering multiplexed streams (Figure 5) the question
is whether Proposition 1 might be applied to the individual
45
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-398-8
ICN 2015 : The Fourteenth International Conference on Networks

streams of an aggregation, for example to calculate the maxi-
mum delay of a single ﬂow xi.
Firstly, this depends on the type of aggregate scheduling,
like FIFO (see [11]), priority-scheduling, or unknown arbitra-
tion, and secondly on the service curve βaggr of the aggregated
ﬂow. If no knowledge about the choice of service between the
ﬂows is present, then we speak of arbitrary multiplexing [12]
(also: blind multiplexing), and the situation is more complex.
In such cases, the distinction between strict and non-strict
aggregate service curves plays an important role [4].
Proposition 2 (Blind Multiplexing): Let a node be serving
the ﬂows x1 and x2 with an unknown arbitration. Assume that
the node guarantees a strict service curve β to the aggregation
of the two ﬂows, and that ﬂow x2 is bounded by α2. Let
β1(t) := [β(t) − α2(t)]+; β1 is a service curve for ﬂow x1 if
it is wide-sense increasing.
Deﬁnition 5 (Strictness of service curve): A system S offers
a strict service curve β to a ﬂow, if during any backlogged
period [s, t] of duration t − s the output y of the ﬂow is at
least equal to β(u), i.e., y(t) − y(s) ≥ β(t − s). Obviously,
any strict service curve is also a service curve.
Example 4: Figure 6 (left) shows a token bucket input
x = rt + b and a service curve β(t) = R · t. Here, the output
y(u) ≥ β(u) in all backlogged periods u: u ≤ busy period.
Thus, β is strict (there is only one backlogged period u).
If we switch to the rate-latency service curve βR,T (t) =
R·[t−T]+ (Figure 6, right), we get a non-strict service curve.
The backlogged period starts at 0 and never ends: because in
the worst case, all input data of x remains in the system for
time T before being served with rate R, but new data of x
always arrives during T. The deﬁnition of the service curve
speciﬁes the output y as y(t) ≥ (x ⊗ β)(t). Indeed, it is valid
that the output y(u0) ≥ βR,T (u0), but this is not guaranteed
regarding the backlogged period u > u0. Thus, it is possible
that y(u) ̸≥ βR,T (u) as (x ⊗ βR,T )(u) − (x ⊗ βR,T )(0) =
(x ⊗ βR,T )(u) < βR,T (u) = βR,T (u) − βR,T (0) if T > 0.
In this scenario, β is non-strict.
The above example raises the issue whether there are
classes of service functions that are always strict or non-strict,
respectively.
In literature, the service curve βR,T (t) = R · [t − T]+
(or even any convex service curve) is often used as a strict
service curve per se; see, for instance, [13]. We will see that
both, strictness and non-strictness, are not only based on the
service curve itself but also on the corresponding input ﬂow
x. Considering aggregate ﬂow situations, this means that the
strictness of an aggregated input ﬂow needs to be checked
before applying the important Proposition 2. Therefore, the
condition y(u) ≥ β(u), ∀ backlogged periods u needs to be
proofed.
First, we will provide and prove some characterizations for
applications using token bucket input ﬂows and the commonly
used rate-latency service curves.
Theorem 1 (Non-strict functions): Let a system with rate-
latency service curve βR,T and token bucket arrival curve αr,b
with r < R and T > 0 be given. Furthermore, the worst case
scenario is assumed: the input is served with minimum rate R
after a possible maximum delay T. We claim that the service
curve βR,T cannot be strict, if the input ﬂow x(t) is a strictly
increasing function.
Proof:
Assume βR,T is strict. Based on Proposition 1 we know
α∗(t) = α ⊘ β := sups≥0{α(t + s) − β(s)}, here α∗(t) =
r(t + T) + b. Because r < R, there is a point in time ts,
so that βR,T (ts) = α∗(ts) and βR,T (t) > α∗(t) if t > ts,
i.e., ∀ t0 > ts : βR,T (t0) − α∗(ts) ≥ α∗(t0) − α∗(ts)
⇒ ∆βR,T = βR,T (t0) − βR,T (ts) ≥ α∗(t0) − α∗(ts) = ∆α∗.
Since x(t) is strictly increasing and latency T > 0: for any
t0 > ts: u := t0 − ts is a backlogged period—cf. Figure 6
(right).
βR,T is supposed to be strict, so output y(u) ≥ βR,T (u) =
βR,T (t0) − βR,T (ts) ≥ α∗(t0) − α∗(ts) = α∗(t0 − ts). But
this is a contradiction to α∗ being an arrival curve for output
y. Thus, the assumption is wrong, i.e., βR,T is non-strict. □
x
R t
t
⋅
( ) =
β
x
⊗ β
x
b
T
+
−
⋅
=
]
[
( )
T
t
R
t
β
b
T
0u
u
⊗ β
x
0
0
u
time
time
data
data
busy period
Figure 6. Strict and non-strict service curve
Unfortunately, the feature of being a non-strictly increasing
input x is not a sufﬁcient condition for a strict service curve
βR,T : using the same token bucket arrival curve αr,b and rate-
latency service curve βR,T , one can ﬁnd non-strictly increasing
input functions x that make the service curve βR,T either
strict or non-strict. This will be demonstrated by the following
example.
Example 5: Let
αr,b :=
(
1, 5t + 5
for t > 0
0
otherwise
(7)
and βR,T := 2(t − 2)+. Furthermore, let the input x be ﬁrst
identical to αr,b, and then stagnate at time t′. The parameter
t′ is computed using equation αr,b(t) = βR,T (t + T). This
guarantees that no displacement of the βR,T graph within the
convolution graph of x ⊗ βR,T occurs:
1, 5t + 5 = 2((t + 2) − 2); t = t′ = 10 fulﬁlls this equation.
So, we deﬁne the input as
x(t) =





0
for t ≤ 0
1, 5t + 5
for t ≤ 10
20
otherwise
(8)
Result: The service curve βR,T is strict (Figure 7).
46
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-398-8
ICN 2015 : The Fourteenth International Conference on Networks

Now, the input x is changed from x to ˜x (˜x is still non-
strictly increasing):
˜x(t) =





0
for t ≤ 0
0, 75t + 2, 5
for t ≤ 10
10
otherwise
(9)
Result: The same service curve βR,T is now non-strict
(Figure 7).
α
r ,b
R ,T
β
2,5
0
2
4
5
10
x
10
20
x~
R T
x
,
~
β
⊗
T
12
R T
x
β ,
⊗
time
data
T
T
Figure 7. Input x changed to ˜x causes non-strictness
Obviously, all input functions x of the form (or multiple
repetitions)
x(t) =
(
mt + n
for t ≤ t′
const
otherwise
(10)
cause the service curve βR,T to be strict, if the constant part
of x starts within or on the border of the red-dashed triangle
of Figure 8.
α
b
r ,
R ,T
β
r
b
P
X
X
X
T
0
R ,T
β
T
ue
ub
ue
b
u
time
data
Figure 8. Input area making βR,T strict
Here, ub is the begin and ue the end of a backlogged period,
b is the burst size of the arrival curve αr,b and P = P(´t, ´y)
with ´t: αr,b(´t) = βR,T (´t + T), i.e., the intersection of αr,b
with the parallel line to βR,T , given by the curve y = Rt.
So, we state: the feature of being strict or non-strict is
not only determined by a service curve itself. In all cases,
this feature depends on both, the service curve and the actual
input x. Since often concrete input ﬂows remain unknown, this
aggravates NC’s application to worst-case analysis of scenarios
including aggregate scheduling.
IV. BYPASSING THE STRICT-NON-STRICT PROBLEM
In the following, we try to overcome the problem of
strictness or non-strictness in case of aggregate scheduling.
Our aim is to look for and—if possible—create a service
curve for a single ﬂow xi of an aggregate ﬂow x without
any consideration, either on FIFO or non-FIFO scheduling,
and strictness (non-strictness) of the aggregate-service curve
βaggr(t).
All together, these considerations provoke the following
statement that determines a generalization of Proposition 2
as it does not differentiate between strict and non-strict:
Theorem 2 (Construction of always-to-use service curves):
Consider a node with some unknown arbitration serving the
ﬂows x1 and x2. Let x be the aggregated input with x = x1 +
x2 and y = y1+y2 the aggregated output, respectively. Assume
that the node offers a service curve β to the aggregation of the
two ﬂows with y(t) ≥ (x ⊗ β)(t), and ﬂow x2 is α2-smooth.
Deﬁne β1(t) := [(x ⊗ β)(t) − α2(t)]+. If β1 is wide-sense
increasing, then β1 is a service curve for ﬂow x1.
Proof:
Since β = βaggr is a service curve for input x, we know:
(i) y ≥ x ⊗ βaggr
Let Φ := {f | f(t1) ≥ f(t0) for t1 ≥ t0, f(t) = 0 for t <
0, f(t) left-continuous, t ∈ R}
In [4] we ﬁnd the following algebraic rule:
If f(0) = g(0) = 0 then (f ⊗ g ≤ min{f, g} ⇒
x ⊗ [(x ⊗ βaggr)] ≤ min{x, (x ⊗ βaggr)} ⇒
x ⊗ [(x ⊗ βaggr)] ≤ x ⊗ βaggr ≤ y.
Thus, x ⊗ [(x ⊗ βaggr)] ≤ y ⇒ expression x ⊗ βaggr itself is
a service curve for x, and together with (i) it is even strict.
But this means: β1(t) := [(x ⊗ β)(t) − α2(t)]+ is a service
curve for ﬂow x1 if β1 is wide-sense increasing. □
Based on Theorem 2, we can derive the construction of a
strict service curve.
Theorem 3 (Construction of a strict service): Suppose a
node with the conditions of Theorem 2 and with a service
curve β to the aggregate with y(t) = (x ⊗ β)(t) instead of
y(t) ≥ (x ⊗ β)(t).
Then the following is always valid:
(i) β∗ := (x ⊗ β) is a strict service curve to the ﬂow x
(ii) β∗ := (x ⊗ β) is the greatest strict service curve to x
Proof:
(i): β is service curve, i.e., y ≥ x⊗β ⇒ y(t) ≥ β∗(t) which
means β∗ is strict.
(ii): Assume β∗ is not the greatest service curve, that means
there is a β′ with β ≥ β′ > β∗ and β′ is strict. Then y ≥ β′,
and ⇒ y = x ⊗ β ≥ β′. Since β∗ := (x ⊗ β) ⇒ β∗ ≥ β′
which contradicts the assumption. □
Thus, we can state the following: the construction of a strict
service curve is possible in case of blind multiplexing with
non-strict service curve to the aggregate input. Of course, if
y(t) ≥ (x ⊗ β)(t) and not y(t) = (x ⊗ β)(t), then it may be
that a greater strict service curve than β∗ := (x ⊗ β) exists
47
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-398-8
ICN 2015 : The Fourteenth International Conference on Networks

(and therefore a better one w.r.t. βi of a single ﬂow xi); but
in any case, it is a strict service curve.
Now we give another theorem to overcome the question of
strictness or non-strictness of a service curve. Due to Theorem
1, the important service curve βR,T cannot be strict, if input
ﬂow x(t) is a strictly increasing function. And, according
to Figure 7, the change of input x to ˜x causes the service
curve βR,T to be non-strict although βR,T is not changed.
Consequently, the assumption of Proposition 2 would not
be fulﬁlled—but sometimes it is possible to characterize an
(aggregated) input x = x1 + x2 so that a service curve β1(t)
of ﬂow x1 exists, even if the service curve β of the aggregate
is non-strict:
Theorem 4 (Singular ﬂow bounded by K): Consider a node
serving the ﬂows x1 and x2 with some unknown arbitration
between the two ﬂows. Let x be the aggregated input with x =
x1 + x2 and y = y1 + y2 the aggregated output, respectively.
Assume that the node offers a service curve β to the aggregate
of the two ﬂows, and let ﬂow x2 be bounded by K > 0. Deﬁne
β1(t) := [β(t)]−K]+. If β1 is wide-sense increasing, then β1
is a service curve for ﬂow x1.
Proof:
Let Φ := {f | f(t1) ≥ f(t0) for t1 ≥ t0, f(t) = 0 for t <
0, f(t) left-continuous, t ∈ R}
According to the algebraic rules in [4]:
Rule a): K + (g ⊗ f) = g ⊗ (K + f) if g, f ∈ Φ, K ∈ R+
Rule b): If f
≤ f
′and g ≤ g
′
⇒ f ⊗ g ≤ f
′ ⊗ g
′
for g, g
′, f, f
′ ∈ Φ, β is service curve, i.e., [y1(t) + y2(t)] ≥
((x1 + x2) ⊗ β)(t)
⇒ y1(t) ≥ ((x1+x2)⊗β)(t)−y2(t) ⇒ Because x1+x2 ≥ x1
and Rule b):
⇒
y1(t) ≥ (x1 ⊗ β)(t) − y2(t). Always is true y2(t) ≤
x2(t) ∀t
⇒ y1(t) ≥ (x1 ⊗ β)(t) − x2(t),
and since by
assumption x2(t) ≤ K ⇒ y1(t) ≥ (x1 ⊗ β)(t) − K.
Applying Rule a) we get (x1 ⊗β)(t)−K = (x1 ⊗(β −K)(t)
⇒ y1(t) ≥ (x1 ⊗ (β − K)(t); which means β1 := [β − K]+
is service curve of x1 if it is wide-sense increasing.□
Remark:
Now, we can state that all (aggregate-) input functions x =
x1 + x2 with x2(t) ≤ K possess the service curve β1 :=
[β − K]+ independent from strictness or non-strictness of β,
as for example of the aggregate x:
x :=
(
mt + n
for any t ∈ R+
const
otherwise
(11)
Example 6: A typical scenario of blind multiplexing is
given by two input ﬂows xlow and xhigh with a worst case
service situation for ﬂow xlow—also called preemptive priority
schedule, i.e., xhigh will be served ﬁrst, and will always
interrupt the xlow-service as soon as data of ﬂow xhigh is
present. Only if there is no data of ﬂow xhigh, ﬂow xlow will
be served.
Proposition 2, Theorem 2, and Theorem 4 may provide a
service curve βlow for the low-priority ﬂow xlow. An impor-
tant question is whether this (minimum) service curve βlow
(2)
(3)
(1)
(4)
( )
( )
( )
t
x t
y t
⊗ β
=
(t)
x
r,b
α
R,T
β
time
data
u
Figure 9. Finite backlogged period u—but βR,T is not strict
together with αlow— if known—can be used to compute the
maximal delay, the maximal backlog bound, or the maximal
output bound of the ﬂow xlow by applying Proposition 1. In
terms of backlog bound we can argue that the service facility
is work-conserving, i.e., the ’unﬁnished work’ x(t) − y(t)
depends only on the arrival instants and the data(packet-
)length, and not on the order of service. Therefore, it is easy to
realize that Proposition 1 (Backlog bound) is applicable here:
xlow(t) − ylow(t) ≤ sup
s≥0
{αlow(s) − βlow(s)}
(12)
Nevertheless, relating to xlow-trafﬁc, both of the other bounds,
i.e., Delay and Output bound—are applicable, too. For exam-
ple, considering the delay bound of xlow:
d ≤ sup
t≥0
{inf{τ : αlow(t) ≤ βlow(t + τ)}}
(13)
Here, the virtual delay
dτ(t) = inf {τ ≥ 0 : αlow(t) ≤ βlow(t + τ)}
(14)
ensures that an input x which arrives at time t will leave
service not later than dτ(t). This is guaranteed for FIFO
scheduling but not for blind multiplexing. However, we may
presume FIFO per single ﬂow (e.g. xlow within the aggregate
of blind multiplexing) and thus apply all three bounding
theorems without any restrictions.
The important statement d ≤ sups≥0{inf{τ : α(s) ≤ β(s+
τ)}} is only valid for FIFO systems. Hence the question is
whether it is possible to state a similar proposition for systems
in general—either FIFO or not. The next theorem is a ﬁrst
answer to this.
Theorem 5 (Delay bounds in general): Let a system S with
input x, arrival curve α, output y, service curve β, and point
in time tα with ∀t > tα : α(t) < β(t) be given. Furthermore,
let U = {u|u is backlogged period}, and l(u) be the length
of a backlogged period. If the service curve β is strict or u is
ﬁnite ∀u ∈ U, then the maximal delay d is given by
d ≤ sup
u∈U
{l(u) : (x ⊗ β)(t) ≤ x(t) ∧ t ∈ u}
(15)
48
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-398-8
ICN 2015 : The Fourteenth International Conference on Networks

0s
1s
2s
0
y
]
[0,
0
1
s
u
=
3s
x
]
,
[
2
1
2
s
s
u
=
3 = 0
u
( )
)( )
(
x t
t
x
=
⊗β
β(t) = r · t
2
( )
u
d t
=
here
data
time
Figure 10. Strict service curve
Proof:
Case: u is ﬁnite ∀u ∈ U—proof is trivial.
Case: service curve β is strict: due to the subsequent Lemma
the backlogged period is ﬁnite. And otherwise a backlogged
period is ﬁnite at time t if x(t) = y(t), cf. Figure 10. Take
any backlogged period u and let s be start and t be the end of
the backlogged period u = [s, t], that means for input x and
output y: y(s) = x(s) and y(t) = x(t). Let β be the service
curve, i.e., output y is lower-bounded by x⊗β; now, ∀ subsets
v ⊆ u with v := [s, z] and z ≤ t:
(i) x(z) ≥ y(z) ≥ (x ⊗ β)(z).
On the other hand: ∀ ∆v := z − s, and due to strictness of β:
y(∆v) ≥ β(∆v) = β(z −s). That means we get the following
equation:
(ii) infs≤˜t≤z{x(s)+β(˜t−s)} = x(s)+β(˜t−s) = (x⊗β)(˜t).
This is because at the points from s to z inside the ﬁnite
backlogged period u = [s, t], the value of convolution x ⊗ β
is determined by the service curve β alone. Therefore, for
z → t we get:
(iii) y(z) = y(t) = (x ⊗ β)(t) and y(t) = x(t)
⇒ x(t) =
(x ⊗ β)(t) where t is the end of backlogged period u.
⇒ l(v) ≤ l(u) with (x ⊗ β)(z) ≤ x(z).
⇒ Maximal delay d: d ≤ supu∈U{l(u) : (x ⊗ β)(t) ≤ x(t) ∧
t ∈ u}. □
Lemma: Let a system S with input x, arrival curve α, output
y, service curve β, and point in time tα with ∀t > tα :
α(t) < β(t) be given. If the service curve β is strict, then
any backlogged period is ﬁnite.
Proof:
Since β is strict we have y(t) ≥ β(t) ∀t.
Of course y(t) ≤ x(t) is always true, altogether
(x ⊗ β)(t) ≤ β(t) ≤ y(t) ≤ x(t) ∀t
(16)
Let u be any backlogged period, and suppose u is not ﬁnite.
Then y(t) < x(t) ∀t and, therefore, also ∀t > tα.
From (16): (x ⊗ β)(t) ≤ β(t) ≤ y(t) < x(t) ≤ α(t − 0) =
α(t). But that means β(t) < α(t) ∀t > tα which contradicts
the precondition of the Lemma. Thus, u is ﬁnite, i.e., ∃ t0 :
y(t0) = x(t0). □
Unfortunately, the opposite statement is not valid as shown
in Figure 9.
V. CONCLUSIONS
This paper deals with worst case modeling of aggregate
scheduling. We want to get guaranteed performance param-
eters, like maximal end-to-end delay of individual so-called
left-over ﬂows of an aggregate. When using the analytical tool
Network Calculus (NC), among others the service curve is re-
quired as main modeling element. In case of blind multiplexing
the following particular problem occurs: the construction of
a service curve for the single output after demultiplexing an
aggregated ﬂow x = x1 + x2 requires the strictness of the
aggregated service curve.
In publications like [13] [12], or others, it is assumed
that the rate latency service curve βR,T (very often used as
aggregated service curve) fulﬁlls the strictness property.
In this article, we demonstrated that the property of being
strict or non-strict does not depend on the service curve solely.
Only in combination with the concrete input—or at least with
a special class of input—one can decide whether a service
curve is strict or non-strict.
By providing and proving, ﬁrstly, theorems to get weaker
forms of strictness and, secondly, a more general approach to
get service curves or worst case delay bounds, we bypassed
this difﬁculty. Therefore, deterministic performance analysis
based on NC in situations comprising aggregate scheduling
remains applicable.
REFERENCES
[1] U. Klehmet, T. Herpel, K.-S. Hielscher, and R. German, “Worst Case
Analysis for Multiple Priorities in Bitwise Arbitration,” in GI/ITG-
Workshop MMBnet 2007, Hamburg, pp. 27-35.
[2] J. Liebeherr, A. Burchard, and F. Ciucu, “Delay Bounds in Communica-
tion Networks with Heavy-tailed and Self-similar Trafﬁc,” IEEE Trans.
Inform. Theory, vol. 58(2), pp. 1010–1024, 2012.
[3] R. Cruz, “A calculus for network delay, part i: Network elements in
isolation,” IEEE Trans. Inform. Theory, vol. 37-1, pp. 114–131, 1991.
[4] J.-Y. Le Boudec and P. Thiran, Network Calculus.
Springer Verlag
LNCS 2050, 2012.
[5] Y. Ying, F. Guillemin, R. Mazumdar, and C. Rosenberg, “Buffer
Overﬂow Asymptotics for Multiplexed Regulated Trafﬁc,” Performance
Evaluation, vol. 65-8, 2008.
[6] A. Charny and J.-Y. Le Boudec, Delay Bounds in a Network with
Aggregate Scheduling.
Springer Verlag LNCS 1922, 2000.
[7] J. Schmitt, F. Zdarsky, and M. Fidler, “Delay Bounds under Arbitrary
Multiplexing,” Technical Report, vol. 360/07, 2007.
[8] T. Herpel, K.-S. Hielscher, U. Klehmet, and R. German, “Stochastic and
Deterministic Performance Evaluation of Automotive CAN Communi-
cation,” Computer Networks, vol. 53, pp. 1171–1185, 2009.
[9] S. Kerschbaum, K.-S. Hielscher, U. Klehmet, and R. German, “A Frame-
work for Establishing Performance Guarantees in Industrial Automation
Networks,” in Proceedings MMB and DFT 2014, Bamberg, pp. 177-191,
March 2014.
[10] M. Fidler and V. Sander, “A Parameter based Admission Control for
Differentiated Services Networks,” Computer Networks, vol. 44, pp.
463–479, 2004.
[11] G. Rizzo, “Stability and Bounds in Aggregate Scheduling Networks,”
Ph.D. dissertation, Ecole Polytechnique Federale De Lausanne, 2008.
[12] J. Schmitt, F. Zdarsky, and I. Martinovic, “Improving Performance
Bounds in Feed-Forward Networks by Paying Multiplexing Only Once,”
in Measurements, Modelling and Evaluation of Computer and Commu-
nication Systems(14th GI/ITG Conference), Dortmund, March 2008.
[13] A. Bouillard, B. Gaujal, and S. Lagrange, “Optimal Routing for End-to-
end Guarantees: the Price of Multiplexing,” in Valuetools ’07, Nantes,
October 2007.
49
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-398-8
ICN 2015 : The Fourteenth International Conference on Networks

