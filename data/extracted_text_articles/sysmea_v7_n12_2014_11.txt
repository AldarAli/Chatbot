Formal Synthesis of Real-Time System Models in a MDE Approach
C´edrick Lelionnais,
J´erˆome Delatour,
and Matthias Brun
ESEO-TRAME
Angers, FRANCE
Email: cedrick.lelionnais@eseo.fr
Email: jerome.delatour@eseo.fr
Email: matthias.brun@eseo.fr
Olivier H. Roux
and Charlotte Seidner
IRCCyN - Universit´e de Nantes
´Ecole Centrale de Nantes
Nantes, FRANCE
Email: olivier-h.roux@irccyn.ec-nantes.fr
Email: charlotte.seidner@irccyn.ec-nantes.fr
Abstract—The development of real-time embedded systems is
quite complex because of the wide range of execution platforms
and of the importance of non-functional requirements. Further-
more, Model Driven Engineering is particularly suitable for han-
dling the diversity of implementation targets. Therefore, several
real-time embedded systems development suites leverage Model
Driven Engineering by automatically generating platform-speciﬁc
code from high-level design models. Such tools may also take non-
functional requirements into account by integrating veriﬁcation
activities. These activities typically rely on the generation of
formal models from the same high-level design descriptions used
for code generation. However, few tool suites support both code
and formal model generation. Furthermore, among these, most
overlook real-time operating systems mechanisms. Therefore,
both code and formal models generated by these tool suites may
not behave as speciﬁed in the high-level design descriptions. The
present work extends the SExPIsTools code generator tool suite
with a support for the generation of formal models. The proposed
strategy relies on the composition of formal model fragments
described using an extension of the classical Time Petri Nets. This
paper presents a formalization of this composition that generically
considers the behavior of platforms. As an illustration, we then
give the formal model describing the behavior of an application
on two different platforms (OSEK/VDX and VxWorks) and check
a safety property on both models.
Keywords—Real-time operating systems, Model Driven Engi-
neering, Time Petri Nets, Multi-platform deployment, Formal model.
I.
INTRODUCTION
Real-Time Embedded Systems (RTES) increasingly sur-
round us in various domains (aircrafts, cars, cell phones,
robotics, etc.). RTES engineers are confronted with the chal-
lenge of developing more complex, higher quality systems,
with shorter development cycles at lower costs. Model Driven
Engineering (MDE) helps engineers to develop tool suites
that partially automate the development of RTES. Using
model transformations, these tool suites mainly produce either
executable code or formal models from high-level design
descriptions of RTES.
Some of these tool suites have both code and formal mod-
els generation processes. However, the mechanisms of Real-
Time Operating Systems (i.e., executable software platforms
supporting real-time applications, RTOS) are often ignored
by these generation processes. As a result, generated code
and generated formal models may not behave as speciﬁed in
the high-level design description. Consequently, veriﬁcation
and validation activities applied on the RTES development
could provide erroneous results. For instance, the detection
of malfunctions (e.g., wrong treatments of critical data, or
bad scheduling of real-time multitasking applications) could
be compromised.
Nevertheless, among these tool suites, some consider real-
time aspects in their generation processes. They thus take the
deployment of real-time applications on RTOS (i.e., mapping
of application concepts to execution platform services in order
to execute them) into account. However, none of them satisﬁes
the four criteria given below:
•
Portability of real-time applications to adapt to the
RTOS heterogeneity;
•
Reusability of generation processes for a rapid mi-
gration of these applications in a multi-platform de-
ployment case;
•
Maintainability of RTES to help all stakeholders in
their interventions;
•
Correctness of generation processes in ordrer to have
conﬁdence in RTES development.
This work is part of an overall strategy of RTES develop-
ment using a MDE approach. This strategy is supported by a
tool suite called SExPIsTools (for Software Execution Platform
Inside Tools). In order to satisfy the criteria previously given,
SExPIsTools relies on the following approach:
•
considering any RTOS as parameter of generation
processes to achieve multi-platform deployment;
•
writing more generic transformation rules to be
independent from the considered RTOS;
•
separating domain concerns (i.e., application de-
ployment choice, RTOS consideration, transformation
rules and veriﬁcation and validation activities) to clar-
ify interventions of each domain specialist;
•
formalizing transformation rules to increase the
correctness of generation processes.
115
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

In the present paper, we focus on the latter point. We need
to construct RTES formal models, i.e., models of the whole
system including the RTOS. For this purpose, our approach
relies on a single transformation that does not depend on any
speciﬁc RTOS. This transformation composes multiple formal
model fragments independently of the target RTOS. Each of
these fragments represents a part of the formal model that
captures the behavior of the RTES.
As a basis of the construction, we use roles to generically
identify connection points. These roles are used as a glue
between the formal fragments. As a consequence, a new
deﬁnition is presented to represent these formal fragments
based on roles. The class of models we use is Time Petri Nets
(TPN). The generic construction is then formalized as a basis
of the transformation rules. Finally, an application example is
proposed to illustrate a multi-platform deployment case, where
two RTOS are considered. As a result of this experimentation, a
scheduling safety property is veriﬁed on both resulting models.
This paper extends our previous work [1] in which the
fundamental rules of composition have been presented. An
extension of these rules is given here to both 1) compose
formal models of multitasking deployed applications with
priority policy, and 2) provide a ﬁrst validation of the generic
construction.
Section II presents multi-platform deployment related
works within a MDE approach [2]. A description of SEx-
PIsTools is then given in Section III. Section IV gives the
formal deﬁnition of the TPN fragments composition operator,
which is based on roles. The application of this operator to the
construction of whole RTES formal models is then described in
Section V. Application examples are presented in Section VI.
The beneﬁts and limits of this approach are discussed in
Section VII. Finally, we conclude in Section VIII.
II.
RELATED WORKS
The following sub-sections present existing tool suites
related to the multi-platform deployment problem.
Firstly, some code generators are introduced. Formal model
generation tool suites are then presented, some of which are
also capable of generating code. Finally, we will take a stand
on the adopted approach.
A. Code generator tool suites
In order to promote the reuse of deployment tools within
a single code generator, the genericity of processes has been
at the heart of concerns. For instance, TransPI [3] relies on
a two-step approach to generate speciﬁc code. A ﬁrst phase
considers a generic behavioral representation of the RTOS
API (Application Programming Interface) in accordance with
POSIX standard. In a second phase, the deployment is reﬁned
by conﬁguring the process rules with the API of the targeted
RTOS. However, the conﬁguration of new rules does not fully
satisfy the reuse of such a process since the tool must be
modiﬁed.
A similar experimentation [4] improves reuse by specifying
the RTOS concerned by the deployment without modiﬁcation
of the process. This orientation has been thought with the aim
of porting real-time applications. This strategy relies on the
transcription of code snippets by conﬁguration of functions
with RTOS information. Those information come from compo-
nents of the targeted RTOS whose architecture was previously
modeled by the generic modeling language AADL, which
is dedicated to the real-time domain. The ﬂexibility of this
process meets the heterogeneous requirements of platforms.
Another approach [5] also contributes to the multi-platform
deployment problem. This ﬁlls the behavioral gap in the
SRM package of the MARTE UML proﬁle [6]. Before deal-
ing with the RTOS behavior, a transformation process was
developped [7] to generate a deployed application model
by considering the targeted RTOS structure described with
SRM. Descriptions of executable concepts (i.e., resources
and services of the API) of the targeted platform required
by the application are instantiated through the deployment
process. This instantiation is completed by a reﬁnement of
descriptions depending on both application data and location
of elements playing a generic role (e.g., a task priority or a
counting semaphore capacity) within the considered platform.
The integration of the behavioral aspect is also based on this
notion of role. Code snippets are assigned to execution services
(e.g., a task creation or a semaphore taking) in accordance with
Java or C++/POSIX implementations.
The main interest of the two last contributions is the
independence of specialists during their interventions regarding
the tool suite. This criterion guarantees the quality of main-
tainability, which is added to the already mentioned reusability
and portability. Despite this, these contributions present a
major drawback that is inherent to all code generators. The
formalization is indeed absent from the addressed processes.
This weakness prevents specialists from applying veriﬁcation
activities on deployed applications.
B. Formal model generation tool suites
The tool suites presented in this section encourage the
behavioral formalization of RTOS.
1) Without code generator: An approach [8] has recently
launched a formal synthesis for composing behavioral models
of RTES. In order to achieve this, both application and plat-
form are modeled with adequate modeling language. With the
help of an Algebra of Communicating and Shared Resources
(ACSR), behavior of the targeted platform is formalized.
Behavior of the application is described by a Timed and
Resource-oriented Statechart (TRoS) including both time an-
notations and resource constraints. A model of the deployed
application is then composed with the obtained formal models
and used for analysis. This synthesis provides a detailed
design of RTES by formalizing their implementation with a
complementary manner. Unfortunately, this process is complex
to use, which forces stakeholders to have a good knowledge
of formalization tools. Moreover, the composition requires
a strong dependency of the application with respect to the
platform.
Metropolis [9] supports both design and analysis of hetero-
geneous embedded systems on the basis of the platform-based
methodology. The behavioral representation is illustrated by
entities such as concurrent and communication activities. In
addition, this environment offers the possibility to use formal
languages in accordance with the LTL logic for verifying both
116
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

functional and non-functional properties once the deployment
reached by mapping of the system components with the plat-
form entities is described. Similarly, GME [10] includes use
constraints on the representation of executable concepts thanks
to the Platform Modeling Language (PML). This consideration
mixed with the integration of formal languages to describe the
behavior of platforms provides a deeper design of embedded
systems. However, the genericity of modeling languages used
for describing the platforms does not facilitate the treatment
of particular domains such as real-time. Furthermore, trans-
formation rules are not entirely clear. This leads to a less
meaningful separation of domain skills and consequently to
a maintainability decrease.
2) With code generator:
More speciﬁcally to RTES,
Ptolemy project [11] is further adapted for describing ex-
ecution models. The deﬁnition of those models relies on
the actor-oriented design and revolves around mechanisms of
concurrency and communication implemented between RTES
components. The behavior represented within those models
is translatable into several execution semantics. This beneﬁt
offers a code-formal model duality of deployed applications.
This approach thus achieves a wide coverage of software
execution platforms. Nevertheless, the concepts of structural
representation are only intended for the modeling of appli-
cations with this approach, and not for RTES themselves.
Mechanisms such as RTES components synchronization must
therefore be simulated with other veriﬁcation tools. In spite
of a very high completeness, the RTES maintainability with
Ptolemy is once again called into question.
C. Positioning
In order to highlight both advantages and drawbacks of
the works presented above, Table I classiﬁes the tool suites
according to their uses. Depending on whether a given tool
suite addresses only code generation, only formal models
generation, or both it will be in the ﬁrst, second, or third
column respectively. The ﬁrst row is for tool suites that are
not adapted to RTOS, while the second row is for tool suites
that are adapted to RTOS.
TABLE I: Tool suites comparison
Code
Formal
Code & Formal
Not adapted to
RTOS
Metropolis [9]
GME [10]
Adapted to
RTOS
TransPI1 [3]
ACSR+TRoS2 [8]
Ptolemy3 [11]
snippets+AADL [4]
SRM [5]
1 Less suitable for both reusability and maintainability
2 Less suitable for reusability
3 Less suitable for maintainability
Ptolemy seems to be the most versatile. Nevertheless,
stakeholders distinction does not appear clearly, which does
not facilitate maintainability.
Within MDE, alternative approaches were compared [12]
to meet these requirements. The adopted strategy offers the
possibility to capitalize most RTOS descriptions for multi-
platform deployment in a generic way.
In conjunction with this objective, SExPIsTools inte-
grates the Real-Time Embedded Platform Modeling Lan-
guage (RTEPML) [13]. RTEPML was developed with the
aim of representing executable platform concepts dedicated
to the real-time domain. To further detail their representation,
RTEPML [14] has been enriched to describe their behavior
in TPN. However, the generation process used to take into
account these behavioral descriptions needs to be formalized,
which was started in [1], and is continued in the work
presented in this paper (see Sections IV and V).
III.
SEXPISTOOLS
This section presents SExPIsTools. Firstly, the modeling
language RTEPML used to describe RTOS mechanisms is
presented. Then, both deployment and formal models gener-
ation processes integrated in SExPIsTools are described. The
role notion used as a generic basis of transformation rules is
highlighted.
A. Modeling with RTEPML
RTEPML distinguishes the RTOS structural modeling from
the behavioral RTOS modeling.
1) Structural description: RTEPML is born from SRM
package [7] mentioned in the previous section. SRM allows the
description of a large number of RTOS [15] and had identiﬁed
all concepts and their mechanisms present in RTOS. In SRM,
these concepts are called resources (e.g., task, semaphore, etc.).
RTEPML keeps the same taxonomy. In Figure 1, a small
part of OSEK/VDX RTOS [16] and VxWorks RTOS [17]
descriptions in RTEPML are given. The task concept, called
schedulable resource in RTEPML, is described for both RTOS.
Fig. 1: Structural representation of OSEK/VDX platform
As depicted in Figure 1, thanks to the notion of roles
(represented in bold between french quotation marks), we
117
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

could specify the priority (an integer) of OSEKVDX Task
or of VxWorks Task. This priority plays the role of priority
element (<<priorityElement>>) for both tasks. Roles are
thus used to identify both structures and features of each
RTOS resource. As another example, on OSEK/VDX model,
the <<terminateService>> role characterizes the terminate-
Service of OSEKVDX Task in Figure 1.
Sometimes, certain concepts do inherently not exist on
RTOS. As an example, the periodic task concept is missing
on both OSEK/VDX and VxWorks platforms. With RTEPML,
sets of concepts (i.e., identiﬁed with the DesignPrototype
role in Figure 1) can be composed to translate this kind of
concept. Thus, a PeriodicTask concept could be viewed at
a composition of a Task and an Alarm for OSEK/VDX.
As regards VxWorks, the PeriodicTask concept is differently
composed of a Task and a Watchdog synchronizing with a
Semaphore.
2) Behavioral description: The behavioral description al-
lows to represent the life cycle of RTOS concepts. Figure 2
extends the representation of OSEK/VDX concepts, given
in Figure 1. The <<behavioralPrototype>> role leads to
the assignation of a behavioral description to each concept,
including services.
Fig. 2: Behavioral representation of OSEK/VDX platform
Each behavioral description is translated into a Time Petri
Net (TPN) [18] [19] whose deﬁnition is given Section IV.
This class of model is used to describe both synchronism and
parallelism, as well as time evolution. Therefore, TPN are well
adapted to our concerns.
In the example given in Figure 2, the TPN describing OS-
EKVDX AlarmBehavior represents the periodic activation of
OSEKVDX Alarm. Informally, once a token is present in the
ENABLE place, making it marked, one token is periodically
distributed in the ACTIVATION place. Distribution of tokens
is initially achieved once the left transition, represented as a
black rectangle, is triggered (i.e., when ENABLE is marked
and the transition clock has reached 0 time unit). The peri-
odicity is then guaranteed by the right transition triggering
(i.e., when LAPSE is marked and the transition clock has
reached p time units). With clocks on transitions, we can
consequently add as many time constraints as necessary, e.g.,
on the OSEKVDX TaskBehavior TPN, a delay between the
READY and RUNNING places could represent the required
time to start the task execution.
B. Model generation processes within SExPIsTools
SExPIsTools is designed for multi-platform deployment.
Both code and formal model generations are performed in two
steps. Figure 3 depicts these two steps.
Fig. 3: Multi-platform deployment process within SExPIsTools
The ﬁrst one concerns the deployment. This is common to
both generations, which avoids to deploy twice. The applica-
tion is deployed on a speciﬁc RTOS [12] [13]. The considered
RTOS is given as a parameter of the deployment process.
Transformation rules of the process are deﬁned independently
from the targeted RTOS. This independence is possible thanks
to roles previously highlighted. The deployment is performed
by mapping each application concept with its execution on
the targeted RTOS. The mapping consists in locating the role
of the executable concept corresponding to each application
concept through the RTOS model. Once a correspondance is
established, the structure of the located executable concept
is instanciated, i.e., duplicated. Each instance is afterwards
enriched by specifying its features with the help of the appro-
priate roles. Features speciﬁcation emanates from application
concepts information. All these speciﬁed instances ﬁnally
constitute the model of the deployed application (i.e., the
platform speciﬁc model of Figure 3).
The following step concerns either the code generation
or the formal model generation. These both processes take
in input the same generated deployed application model.
118
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

The code generator being not our focus in this paper, we
only present the formalization of the deployed application
model. Similarly to the deployment, the generation process of
deployed application formal models instanciates TPN behav-
ioral descriptions [14]. The location of each TPN is carried
out from the structural instances of the deployed application
model. Indeed, knowing the source executable concept of each
structural instance, the corresponding TPN fragment is located
with the <<behavioralPrototype>> role. Each corresponding
TPN is thus duplicated giving a TPN behavioral instance (or
each TPN fragment).
The generation of these TPN fragments engages their com-
position to constitute a global formal model of the deployed
application. The elements serving as connection points must be
located through the set of these TPN fragments. Similarly to
the structural part, these elements are also located with roles.
As instantiation rules, composition rules are based on these
roles. In the interest of consistency, we have formalized the
sequence of composition rules. This sequence is ordered to
avoid any ambiguity in the formal model construction. The
TPN fragments are therefore categorized according to RTOS
concepts generalized in RTEPML:
•
Concurrent resources: tasks, interruptions, alarms,
etc.
•
Interaction resources: semaphores, message queues,
shared data, events, etc.
•
Routines: application treatment including services
called within the application. This treatment is only
represented by the execution time.
The following Algorithm 1 informally describes the se-
quence of composition rules. We admit here that TPN frag-
ments were already instanciated.
Each composition rule is labelled from a) to d) in com-
ments through this algorithm. Firstly, a) each routine instance
is composed of all its called service instances. Then, each
concurrent resource must be composed with its execution
routine. The execution routine is called the entry point of
the concurrent resource. Each entry point is located with the
<<entryPointElement>> role (see Figure 2). As a conse-
quence, b) each concurrent resource instance is composed with
its entry point. The next composition c) concerns all concurrent
resource instances in order to put them in concurrency. As a
ﬁnal step, d) interaction resource instances are composed with
the set of composed concurrent resource instances so that these
latter interact with some of them.
This order will be respected in Section V in which these
rules will be formalized. Next, in Section IV, the composition
operator of TPN based on roles is deﬁned to formally express
these rules afterwards.
IV.
TPN COMPOSITION BASED ON ROLES
In order to deﬁne the composition of TPN fragments, roles
are added to the TPN modeling. These roles are therefore
assigned to places. The interest of such a method is to merge
places [20] [21], which are the connection points of the
deployed system that must be generated in TPN.
Algorithm 1 Composition rules
Input:
• IS = {IS
R1, IS
R2, . . . , IS
Rl}; // The service calls
behavioral instances with ∀j ∈ [1, l], IS
Rj ⊆ IS
and l the number of routines to compose
• IC = {iC1, iC2, . . . , iCm}; // m concurrent re-
sources behavioral instances
• II = {iI1, iI2, . . . , iIn}; // n interaction resources
behavioral instances
Output:
• M // The composed deployed application behav-
ioral model
1: for j = 1 to l do
2:
// a) Each routine behavioral instance is composed
3:
iRj ← ruleComposeRoutine(IS
Rj)
4: end for
5: for k = 1 to m do
6:
for all j such that 1 ≤ j ≤ l do
7:
if ∃iRj such that iRj is the entrypoint of iCk then
8:
// b) Each entry point is composed
9:
iEP k ← ruleComposeEntryPoint(iCk, iRj)
10:
else
11:
iEP k ← iCk
12:
end if
13:
end for
14: end for
15: for all k such that 1 ≤ k ≤ m do
16:
IEP ← {iEP 1} ∪ · · · ∪ {iEP k} ∪ · · · ∪ {iEP m}
17: end for
18:
// c) All concurrent resources are composed
19: iCR ← ruleComposeConcurrentResources(IEP )
20:
// d) All interaction resources are composed
21: iIR ← ruleComposeInteractionResources(iCR, II)
22: M ← iIR
In this section, TPN with roles are ﬁrstly deﬁned. The
deﬁnition of the instantiation of TPN with roles is then given.
Finally, the composition of TPN is highlighted through a
synchronization formalism based on roles.
A. Formal deﬁnition of TPN with roles
TPN are a timed extension of classical Petri nets [22]
in which an implicit clock and an explicit time interval are
associated with each transition of the net. Informally, the clock
measures the time since the transition has been (continuously)
enabled, whereas the interval is interpreted as a ﬁring con-
dition: the transition, once enabled, may be ﬁred only if the
value (or valuation) of its clock belongs to the time interval.
In the following, N denotes the set of natural numbers,
R≥0 the set of non-negative real numbers, ∅ is the empty set
and 0 is the null vector.
Deﬁnition 1 (TPN): A TPN T is a tuple ⟨P, T, Pre, Post,
m0, Is⟩ where:
•
P is a ﬁnite, non-empty set of places;
•
T is a ﬁnite, non-empty set of transitions;
•
Pre : P × T → N is the backward incidence function;
119
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

•
Post : P × T → N is the forward incidence function;
•
m0 is the initial marking of the net;
•
Is : T → N × (N ∪ {+∞}) assigns a static time
interval to each transition.
A marking of the net T is an application from P to N
giving for each place of the net the number of tokens it
contains. A transition t ∈ T is enabled by a marking m,
which is denoted by t ∈ enabled(m), if all of its input
places contain ”enough” tokens; more formally, enabled(m) =
{ t ∈ T | ∀p ∈ P, m(p) ≥ Pre(p, t) }. A transition t ∈ T
is newly enabled by the ﬁring of transition tf from the
marking m, which is denoted by t ∈↑ enabled(m, tf), if
it is enabled by the ﬁnal marking mf deﬁned by ∀p ∈
P, mf(p) = m(p) − Pre(p, tf) + Post(p, tf) but not by
the intermediate marking mi deﬁned by ∀p ∈ P, mi(p) =
m(p) − Pre(p, tf). More formally, ↑enabled(m, tf)
=
enabled(mf) T ((T \ enabled(mi)) ∪ {tf}).
Finally, for any interval Is, we denote by Is
↓ the smallest
left-closed interval with lower bound 0 that contains Is. For
each transition tr there is an associated clock xtr. We consider
valuations on the set of clocks { xtr | tr ∈ T } and we will
slightly abuse the notations by writing v(tr) instead of v(xtr)
to denote the valuation of the clock associated with transition
tr.
The operational semantics of a TPN can be formally
described as a time transition system; as it is a special case of
the semantics of TPN with read and inhibitor arcs (given in
Def. 3, we will omit it here for the sake of clarity.
In order to model such behaviors as conditional executions
and preemption mechanisms, TPN have been extended with
read arcs (represented in the following with a white square
instead of a regular arrow) and inhibitor arcs (represented with
a white circle). It should be noted that these arcs only impact
the enabling rules of the net but not the marking obtained
by ﬁring a transition: read arcs test the presence of tokens in
places without consuming them, whereas an inhibitor arc is
used to stop the elapsing of time on a transition as long as
there is a certain number of tokens in the place.
Deﬁnition 2 (TPN with read/inhibitor arcs): A TPN with
read and
inhibitor arcs (RI TPN) is
a tuple TRI
=
⟨T , Read, Inh⟩ where:
•
T = ⟨P, T, Pre, Post, m0, Is⟩ is a TPN,
•
Read : P × T → N is the read function;
•
Inh : P × T → N ∪ {+∞} is the inhibition function1.
Informally, a transition is enabled if there are ”enough
tokens” in the places linked by either input arcs or read arcs
and if there are ”not too many tokens” in the places linked
by inhibitor arcs. More formally, the deﬁnition of the set of
transitions enabled by a marking m is updated as follows:
enabled(m) = {t ∈ T | ∀p ∈ P,
Inh(p, t) > m(p) ≥ max(Pre(p, t), Read(p, t))}
1If no inhibitor arcs links a transition t to a place p, then Inh(p, t) = +∞.
The deﬁnition of the set of transitions newly enabled from a
marking m by the ﬁring of a transition tf is similarly updated.
Deﬁnition 3 (Semantics of the RI TPN): The operational
semantics of the RI TPN with read and inhibitor arcs TRI
deﬁned above is given by the time transition system S =
(Q, q0 →) such that:
•
Q = NP × RT
≥0;
•
q0 = (m0, 0);
•
→∈ Q × (T ∪ R≥0) × Q is the transition relation and
is composed of:
◦
the discrete transition transition, deﬁned ∀tf ∈
T by (m, v)
tf
−→ (m′, v′) iff:
(tf ∈ enabled(m);
v(tf) ∈ Is(tf);
∀p ∈ P, m′(p) = m(p) − Pre(p, tf) +
Post(p, tf);
∀t
∈
T ,
v′(t)
=
0 if t ∈↑enabled (m, tf)
v(t) otherwise
;
◦
the discrete transition transition, deﬁned ∀d ∈
R≥0
by
(m, v)
d−→
(m, v′)
iff
∀t
∈
enabled(m), ∀δ ∈]0; d], (v(t) + δ) ∈ Is
↓(t).
Deﬁnition 4 (RI TPN with roles): A RI TPN with roles is
a tuple N = ⟨TRI, R, λ⟩ where:
•
TRI is a RI TPN,
•
R is a ﬁnite set of roles,
•
λ : P → R ∪ {⊥} is the function assigning a role to
a place and ⊥ denoting that no role is assigned to a
place. Hereafter, some notations and properties of this
function are enumerated:
1)
Pλ = {p ∈ P | λ(p) ̸= ⊥} is the set of places
with role.
2)
λ\Pλ : Pλ → R is an injective function;
3)
λ−1 : R ∪ {⊥} → P ∪ {∅} such that



∀r ∈ R, λ−1(r) =
p if λ(p) = r
∅ otherwise
λ−1(⊥) = ∅
The operational semantics of the RI TPN with roles N =
⟨TRI, R, λ⟩ is the same as that of RI TPN. Indeed, the use
of roles within the deﬁnition of RI TPN does not impact its
semantics.
B. Instantiation of RI TPN with roles
As seen previously, all RI TPN fragments are instantiated
before being composed. In order to distinguish the fragments to
compose, atomic elements such as roles, places and transitions
must be identiﬁed according to the instances names, but also
according to referenced instances names.
Indeed, referenced instances emerge when instances are
service calls. Each service call refers to a resource instance.
As an example, a task activation service refers to a task. The
two concepts are distinguished because this has an impact
during the composition between a service call instance and
120
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

its referenced resource instance. For this reason, the renaming
of a role and a renaming of places and transitions are dis-
tinctly separated. This distinction is made with the following
instantiation operator.
Let N = ⟨P, T, Pre, Post, m0, Is, Read, Inh, R, λ⟩ be the
RI TPN with roles to instantiate. The following labels ins
and ref respectively gives the names of the instance and the
referenced instance. If the instance is a resource, there is no
referenced instance with ref = ins. The global renaming
function ⇁ is a bijective function from Set to Set′ where
Set ∈ {P, T, R}.
Deﬁnition 5 (Instantiation of RI TPN with roles): The
instantiation of N denoted by Nins = Ins(N, ins, ref) =
⟨Pins, Tins, Preins, Postins, m0−ins, Is−ins, Readins, Inhins, Rref , λins⟩
is deﬁned by:
Nins
=
Ins(N, ins, ref)
=
N
Pins = {pins s.t. p ∈ P and p ⇁ pins},
Tins = {tins s.t. t ∈ T and t ∈ T, t ⇁ tins},
Rref = {rref s.t. r ∈ R and r ⇁ rref },
∀p ∈ P, ∀t ∈ T, ∀r ∈ R, s.t. p ⇁ pins, t ⇁ tins,
and r ⇁ rref we have:
Preins(pins, tins) = Pre(p, t),
Postins(pins, tins) = Post(p, t),
Readins(p, t) = Readins(pins, tins),
Inhins(p, t) = Inhins(pins, tins),
λins(p) = r iff λins(pins) = rref
λins(p) = ⊥ iff λins(pins) = ⊥
C. Speciﬁc extension of instantiated RI TPN with roles
Once RI TPN are instantiated, we have sometimes been
faced with the need to extend them according to the application
to deploy. For intance, in a real-time system based on a
cooperative multitasking application with priorities, eligible
low priority tasks are inhibited by eligible high priority tasks
when allocating the processor.
We have focused on this case through this paper in order to
enrich our previous work [1] in which all tasks had the same
priorities. The cooperative multitasking case with priorities is
depicted in Figure 4. The RI TPN NT 1 = Ins(N, ins, ref)
is an instance of concurrent resource such that a periodic
task where ref = ins = T 1. In bold, some places with
inhibitor arcs, represented with circles, are connected to
the resumeT 1 transition to inhibit the state change from
READYT 1 to RUNNINGT 1. The marking of one of the
places set {READYT 2, READYT 3, . . . , READYT x} carries
out this inhibition action and ensures the cooperative schedul-
ing of tasks.
This action being a scheduling speciﬁc case, we deﬁned
a dedicated operator for adapting instantiated RI TPN of
concurrent resources such that NT 1 to a cooperative scheduling
context.
Let Nins = ⟨Pins, Tins, . . . , λins⟩ be a RI TPN with roles
of a concurrent resource ﬁrstly instantiated as previously seen.
N cs
ins = ⟨P cs
ins, T cs
ins, . . . , λcs
ins⟩ represents the same instance
extended according to a set of n concurrent resources identiﬁed
by INS = {ins1, ins2, . . . , insn} with upper priorities.
Deﬁnition 6 (Extension of RI TPN with roles):
Cooperative
scheduling
of
concurrent
resources:
The
ENABLET 1
enablingT 1
LAP SET 1
ACT IV AT IONT 1
activationT 1
SUSP ENDEDT 1
terminatedStateT 1
[inc; inc]
incrementT 1
[period; period]
cycleT 1
[0;0 ]
resumeT 1
READYT 1
activatedStateT 1
READYT 2
activatedStateT 2
READYT 3
activatedStateT 3
READYT x
activatedStateT x
[0; 0]
activateT 1
P ROCESSORT 1
processorT 1
resumedStateT 1
RUNNINGT 1
startT 1
ST ARTT 1
[0; 0]
executeT 1
endT 1
ENDT 1
NT1
Fig. 4: Speciﬁc extension of periodic task in RI TPN for cooperative multitasking
extension of Nins in concurrence with n instances adapted to
a cooperative scheduling is denoted by:
N cs
ins = CoopSched(Nins, INS)
with ∀t
∈
Tins, ∃Pre(λ−1(activatedStateins), t)
∈
Preins and ∃Post(λ−1(resumedStateins), t) ∈ Postins
Formally, this deﬁnition gives:
•
Rcs
ins = Rins ∪ RINS with RINS =
S
∀i∈[1,n]
{rinsi};
•
P cs
ins = Pins ∪ PINS with PINS =
S
∀i∈[1,n]
{pinsi};
•
T cs
ins = Tins;
•
λcs
ins : P cs
ins → Rcs
ins is deﬁned by:
◦
∀p ∈ P cs
ins \ PINS, λcs
ins(p) = λins(p)
◦
∀p ∈ PINS and ∀i ∈ [1, n], λcs
ins(p) =
rinsi with rinsi ∈ RINS
•
Precs
ins
:
P cs
ins × T cs
ins
→
N is deﬁned ∀p
∈
P cs
ins and ∀t ∈ T cs
ins by Precs
ins(p, t) = Preins(p, t);
•
Postcs
ins
:
P cs
ins × T cs
ins
→
N is deﬁned ∀p
∈
P cs
ins and ∀t ∈ T cs
ins by Postcs
ins(p, t) = Postins(p, t);
•
m0cs
ins
:
P cs
ins
→
N
is deﬁned
∀p
∈
P cs
ins
by
m0cs
ins(p)
=
m0ins(p) if p ∈ P cs
ins \ PINS
m0INS(p) if p ∈ PINS
with
m0INS
is
deﬁned by m0INS : PINS → N;
•
Is
cs
ins : T cs
ins → I is deﬁned ∀t ∈ T cs
ins by Is
cs
ins(t) =
Isins(t);
•
Readcs
ins
:
P cs
ins × T cs
ins
→
N is deﬁned ∀p
∈
P cs
ins and ∀t ∈ T cs
ins by Readcs
ins(p, t) = Readins(p, t);
121
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

•
Inhcs
ins
:
P cs
ins × T cs
ins
→
N is deﬁned ∀p
∈
P cs
ins
and
∀t
∈
T cs
ins
by
Inhcs
ins(p, t)
=

















Inhins(p, t) if p ∈ P cs
ins \ PINS
1 if













p ∈ PINS
t ∈ T cs
ins ,
∃Pre(λ−1(activatedStateins), t) ∈ Preins
and
∃Post(λ−1(resumedStateins), t) ∈ Postins
D. RI TPN Synchronization based on roles
In order to synchronize some RI TPN, we must clarify the
deﬁnition of the composition of RI TPN, which will be based
on roles assigned to places. Let N1, . . . , Nn be n RI TPN
Ni = ⟨Pi, Ti, Prei, Posti, m0i, Isi, Readi, Inhi, Ri, λi⟩ with
roles such that ∀k ̸= k′ ∈ [1, n] =⇒
Tk ∩ Tk′ = ∅ and Pk ∩
Pk′ = ∅. The composition N = ⟨P, T, Pre, Post, m0, Is, R, λ⟩
of the previous RI TPN with roles will be denoted by N =
N1||N2|| . . . ||Nn. Linked to this composition, we deﬁne a
function leading to the merging of places whose assigned roles
will be taken into account in parameters.
The merging function ֒→ is a partial function from (R1 ∪
{•}) × (R2 ∪ {•}) × · · · × (Rn ∪ {•}) → P × R where •
is a special symbol used when a RI TPN is not involved in
a particular merge of the global system. We then extend the
deﬁnition of the assigning inverse function with λ−1(•) = ∅
The composition of n RI TPN with m merging is denoted
by

N1|| . . . ||Nn

(r1
1, . . . , r1
n) ֒→ (p1, r1)
. . .
(rm
1 , . . . , rm
n ) ֒→ (pm, rm)
with ∀i ∈ [1, n], ∀j ∈ [1, m] , rj
i ∈ Ri, rj ∈ R and pj ∈ P,
and ∀k ∈ [1, m], k ̸= j ⇒ rk
i ̸= rj
i
We will subsequently use the following notations:
•
Let P merged
i
⊆ Pi be the set of places of the net
Ni merged by the composition. Formally P merged
i
=
S
∀j∈[1,m]
{λ−1
i (rj
i )}
•
Let P ֒→ ⊆ P be the set of places of the net N ob-
tained by the merging. Formally P ֒→ =
S
∀j∈[1,m]
{pj}
Deﬁnition 7 (Composition of RI TPN with roles): The
composition of the n RI TPN Ni with the merging ֒→
denoted by:
N =

N1|| . . . ||Nn

(r1
1, . . . , r1
n) ֒→ (p1, r1)
. . .
(rm
1 , . . . , rm
n ) ֒→ (pm, rm)
is deﬁned by:
•
R =

S
∀i∈[1,n]

construction will serve as a basis for the transformation process
within the SExPIsTools framework (Figure 3). As described in
Algorithm 1, the process consists of four successive compo-
sition rules, detailled in the paragraphs below and deﬁned by
equations (1) to (4).
A construction example in RI TPN is provided to illustrate
the method. Figure 5 presents some RI TPN with roles,
one per box, instantiated and ready for construction. Every
operation details the fragments involved in the composition.
The mergeable places are represented in double circle and
those ready to be merged are connected by a hook-dotted arc
with a letter corresponding to the construction step, i.e., the
sequence of rules in Algorithm 1. Finally, roles are indicated
above and to the right of places.
The whole model is describing a monoprocessor applica-
tion Proc with two periodic tasks T 1 and T 2 sharing the
same semaphore S. A cooperative multitasking is established
between T 1 and T 2 with a non-preemptive context. T 2 has a
higher priority than T 1. Each task points to an execution rou-
tine composed of three services called in the following order:
Getk(S); Releasek(S); T erminatek(T k) with k ∈ [1, 2].
a) ruleComposeRoutine: The list of services considered
in RTEPML is not exhaustive at the moment. The instructions
described in RI TPN are currently activation and termination
of task, acquisition and release of semaphore and waiting,
notiﬁcation and inhibition of event.
Let n be the number of call services described follow-
ing: {NS1, NS2, . . . , NSn} such that ∀i ∈ [1, n], NSi
=
Ins(NS, Si, ref Si) with NS the RI TPN describing a ser-
vice, Si the instance name and ref Si the referenced in-
stance name. The routine construction then implies n − 1
compositions, each one having mj mergings of places with
j ∈ [1, n − 1]. The construction of a routine instance NR is
given by (1).
Illustration 1 (see Figure 5): By
applying
NR
from (1), ∀k
∈
[1, 2], NT kBody is built from RI TPN
{NGetk(S), NReleasek(S), NT erminatek(T k)}.
This
sequence
describes in the order, an acquisition of S, a release of S and
a termination of T k.
b) ruleComposeEntryPoint: Each resource points to a
routine described by NR previously formed. Consequently,
NR is composed with NCτ = Ins(NC, Cτ, Cτ) where NC
is the RI TPN describing a concurrent resource and Cτ is the
label indexed to identify each instance. The construction NEP
of a concurrent resource instance with its executable body is
given by (2) for m mergings (we admit here that speciﬁc
extensions of NCτ have already been applied for the needs
of the application in this equation).
Illustration 2 (see Figure 5): By applying NEP from (2),
∀φ ∈ [1, 2], NT askφ withBody is built composing NT φ with its
entry point NT φBody. Prior to each composition, NT 1 has been
extended since this task has the lowest priority. This extension
has thus been achieved by the CoopSched(NT 1, {T 2}) oper-
ation.
c) ruleComposeConcurrentResources:
At this stage,
concurrent resources must be linked together with the aim of
being scheduled by the same processor.
Let qC be the number of concurrent resources with their
composed executable bodies such that ∀iC ∈ [1, qC], each
resource is described by NEP iC in accordance with NEP
previously formed. The construction then implies qC −1 com-
positions, each one having mjC mergings with jC ∈ [1, qC−1].
The construction of NCR is given by (3).
Illustration 3 (see Figure 5): By applying NCR from (3),
NDeployedApplicationCR is ﬁrstly composed of NT 1 withBody
and NT 2 withBody.
d) ruleComposeInteractionResources:
Note that the
processor is also a shared resource. It will therefore be
considered as an interaction resource.
Let qI be the number of interaction resources considered
such that ∀iI ∈ [1, qI], each resource is described by NIiI =
Ins(NI, IiI, IiI) with NI the TPN describing an interaction
resource. Each interaction resource is composed with NCR
previously formed. The global construction then implies qI
compositions, each one having mjI mergings with jI ∈ [1, qI].
The global composition NIR is given by (4).
Illustration 4 (see Figure 5): By
applying
NIR
from (4), NDeployedApplication is ﬁnalized by composing
NDeployedApplicationCR, NS and NP roc.
VI.
EXPERIMENTATION
We illustrate the use of the formal model generation
process on a case study. This case study is adapted from a
schedulability case [23] in the context of cooperative multi-
tasking.
A. Case study description
We consider an application with three concurrent real-time
activities implemented as three real-time schedulable tasks T 1,
T 2 and T 3. The concurrency of these tasks emanates from a
cooperative multitasking scheduler (based on a non-preemptive
priority policy). Here are their characteristics:
•
T 1 is periodic with period P1 = a with a ∈ [0, +∞[
and has an execution time C1 ∈ [10, 20].
•
T 2 is sporadic with only a minimal delay of P2 = 2a
time units between two activations. The execution time
of T 2 is C2 ∈ [18, 28].
•
Finally, T 3 is periodic with period P3 = 3a time units
and has an execution time C3 ∈ [20, 28].
These three tasks are deﬁned with the following priority
order: T 1 > T 2 > T 3. Period a of T 1 is a parameter
determining the limit condition of schedulability of the tasks.
B. Purpose
The formal model generation process will be applied for
two different RTOS. The two chosen RTOS are those used
to present RTEPML in Section III: OSEK/VDX [16] and
VxWorks [17]. Both are used in the industrial sector, have
different API and behave differently. Rom´eo [24], the model-
checking tool developed within our team is used to check the
generated formal models.
123
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

NR
=
 
NS1||NS2

(endref S1 , startref S2 ) ֒→ (SS1→S2 , ⊥)
(r2
S1 , r2
S2 ) ֒→ (p2
S2 , r2
S2 )
. . .
(rm1
S1
, rm1
S2
) ֒→ (pm1
S2
, rm1
S2
)
||NS3

(endref S2 , startref S3 ) ֒→ (SS1S2→S3 , ⊥)
(r2
S1S2 , r2
S3 ) ֒→ (p2
S3 , r2
S3 )
. . .
(rm2
S1S2
, rm2
S3
) ֒→ (pm2
S3
, rm2
S3
)
. . . ||NSn
!
(endref Sn−1 , startref Sn ) ֒→ (SS1S2...Sn−1→Sn , ⊥)
(r2
S1S2...Sn−1 , r2
Sn ) ֒→ (p2
Sn , r2
Sn )
. . .
(r
mn−1
S1S2...Sn−1
, r
mn−1
Sn
) ֒→ (p
mn−1
Sn
, r
mn−1
Sn
)
(1)
with ∀k ∈ [1, mj] and n ≥ 2 if k ≥ 2 then rk
S1...Sj = rk
Sj+1
NEP
=

NCτ ||NR

(startCτ , startref S1 ) ֒→ (S, ⊥)
(endCτ , endref Sn ) ֒→ (E, ⊥)
(r3
Cτ , r3
R) ֒→ (p3
Cτ , r3
R)
. . .
(rm
Cτ , rm
R ) ֒→ (pm
Cτ , rm
R )
(2)
with ∀k ∈ [1, m] if k ≥ 3 then rk
Cτ = rk
R
NCR
=

NEP 1||NEP 2

(processorEP 1 , processorEP 2 ) ֒→ (PEP 1→EP 2 , processorP roc)
(r2
EP 1 , r2
EP 2 ) ֒→ (p2
EP 2 , r2
EP 2 )
. . .
(rm1
EP 1
, rm1
EP 2
) ֒→ (pm1
EP 2
, rm1
EP 2
)
. . . ||NEP qC

(processorP roc, processorEP qC
) ֒→ (PEP 1...EP qC −1→EP qC
, processorP roc)
(r2
EP 1...EP qC −1 , r2
EP qC
) ֒→ (p2
EP qC
, r2
EP qC
)
. . .
(r
mqC −1
EP 1...EP qC −1
, r
mqC −1
EP qC
) ֒→ (p
mqC −1
EP qC
, r
mqC −1
EP qC
)
(3)
with ∀kC ∈ [1, mjC] and qC ≥ 2 if kC ≥ 2 then rkC
EP 1...EP jC = rkC
EP jC +1
NIR
=

NCR||NI1

(r1
P , r1
I1 ) ֒→ (p1
I1 , r1
I1 )
. . .
(rm1
P
, rm1
I1
) ֒→ (pm1
I1
, rm1
I1
)
. . . ||NIqI

(r1
P I1...IqI −1 , r1
IqI
) ֒→ (p1
IqI
, r1
IqI
)
. . .
(r
mqI
P I1...IqI −1
, r
mqI
IqI
) ֒→ (p
mqI
IqI
, r
mqI
IqI
)
(4)
with ∀kI ∈ [1, mjI] and qI ≥ 1, rkI
P IjI −1 = rkI
IjI
The aim is to verify the limits of the schedulability and
the valid values of parameter a (i.e., the period of T 1). The
application is schedulable if each activity always has at most
one running instance.
The sufﬁcient condition ensuring that the system is schedu-
lable with a non-preemptive priority policy requires a processor
load U such that:
U =
n
X
i=1
(Ci/Pi) ≤ 1
(5)
with n representing the number of tasks, Ci indicating the
worst execution time of each task, and Pi being the period
(resp. minimal delay) of each periodic (resp. sporadic) task
Ti.
The theoretical expected values (calculated without taking
into account the RTOS mechanism) for the a parameter are
a ≥ 44 [25]. We expect that our formal veriﬁcation on the
two deployed application on VxWorks and OSEK/VDX leads
to the same result.
C. Formal composition fragment
For the sake of clarity, Figure 6 only shows the behavioral
arrangement of task T 3 (NT 3) considering the OSEK/VDX
norm (Figure 6(a)) on the left side, and the VxWorks platform
(Figure 6(b)) on the right side.
T 3 has been chosen as an illustration instead of other tasks
because it has the lowest priority. Consequently, it presents
the most complex case. We can indeed note the presence of
inhibition arcs since tasks are scheduled in accordance with a
cooperative multitasking non-preemptive priority policy. The
NT 3 instance has consequently been extended by applying
CoopSched(NT 3, {T 1, T 2}), for each targeted RTOS.
The body of T 3 is simpliﬁed and contains only one service
call to suspend (in OSEK/VDX variant) or pend (in VxWorks
variant).
On both Figure 6(a) and Figure 6(b), roles appear in
bold to highlight connection points useful for the composition
through the RI TPN. In a similar manner, the mergeable
places connected by a hook-dotted arc are the ones located
to compose T 3 and its body according to equation (2).
The same reasoning is obviously applied to T 1 and T 2
124
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

before composing them with T 3 in compliance with our
formalization through equations (3) and (4).
D. Application veriﬁcation
Once the models are composed, they have subsequently
been checked using Rom´eo in order to determine the limit
value of a so that the RTES application is schedulable. Given
the structure of both nets, the systems are schedulable if, at
any time, there is at most one token in each place (the nets
are then said to be safe). Additionally, Rom´eo provides the set
of values of parameter a for which the property is true. The
outcome is given hereafter:
——-
Checking property AG[0,inf]bounded(1) on TPN:
”/home/clelionnais/TPN/OSEKVDX NonPreemptiveApplication.xml”
Waiting for response...
Result:
{a >= 44
}
——-
Checking property AG[0,inf]bounded(1) on TPN:
”/home/clelionnais/TPN/VxWorks NonPreemptiveApplication.xml”
Waiting for response...
Result:
{a >= 44
}
Both results match the theoretical value mentionned earlier.
We can thus observe that taking into account RTOS mech-
anisms does not change the theoretical result in this case.
Expected constraints are therefore satisﬁed.
Other properties could be veriﬁed, for which taking RTOS
mechanisms into account could have an impact. However, this
is beyond the scope of this paper. Alternatively, the same
property could also be veriﬁed starting from a different design
model. For instance, we could attempt to model periodicity
with a delay instead of an alarm. In such a case, we would be
able to verify that the expected properties are not preserved.
However, the purpose of our present case study is simply to
illustrate that we can support different platforms (OSEK/VDX
and VxWorks) without changing our formalization rules.
VII.
BENEFITS AND LIMITS
One of the major advantage of SExPIsTools is the multi-
platform deployment process. The possibility of capitalizing a
large number of RTOS models as a parameter of the process,
satisﬁes both reusability and portability criteria. The role
notion presented in this paper encourages us in this way to
provide more genericity to our transformation rules.
This role notion also fulﬁlls the maintainability require-
ments. Composition rules have been written independently
of the RTOS modeling. In addition, the formalization of
these rules could have been done without dealing with other
stakeholders concerns. Our Algorithm 1 has been strengthened,
detecting errors (i.e., TPN fragments composition ambiguity
within rules). As a result, the correctness of the generation
process has been improved.
Furthermore, a deployment on two RTOS with different
mechanisms has been achieved to show our strategy. The same
safety property of schedulability has been veriﬁed on both
deployments. This illustrates both genericity and correctness
of deployed application model construction in TPN.
Another important point is the behavioral modeling in TPN.
This results in the possibility to apply veriﬁcation activities.
Moreover, the veriﬁcation of time properties such as RTES
time constraints is possible.
However, to date, this synthesis is an ongoing sketch of
proof. The purpose of such a work is to demonstrate the
feasability to develop a versatile tool suite. This experimen-
tation must deal with other aspects by considering:
•
more complex RTOS mechanisms such as preemp-
tion, priority ceiling protocol or special queues of
message box;
•
other RTOS descriptions such as ARINC-653 [26],
which presents other concepts (e.g., memory parti-
tion);
•
other veriﬁcations such as time constraints;
•
more precisely the application, so that it is not seen
as just an ordered sequence of called services.
VIII.
CONCLUSION
In this paper, we have presented a ﬁrst formalization of the
formal model generation process of our SExPIsTools tool suite.
As its name suggests, this process generates, from high-level
design descriptions, a formal model of the deployed application
on a speciﬁc RTOS.
The presented formalization focuses on both instantiation
and composition rules of the generation process. Indeed, sev-
eral formal model fragments describing parts of the RTOS and
RTES behaviors need to be instantiated and composed. This
results in a veriﬁable global model of the deployed application.
The composition rules are independent of a speciﬁc RTOS
thanks to the notion of role. This notion is an essential point
of our strategy and represents a major beneﬁt compared to
other existing approaches.
This formalization leads to the deﬁnition of a new class of
Petri Net, the Time Petri Net with roles and read/inhibitor arcs.
A new operator, compared to our previous work [1], has been
deﬁned. It allows to model the cooperative scheduling of non-
preemptive tasks. This comes to strengthen the instantiation of
RI TPN behavioral fragments according to a priority policy
before composing them.
An example of a composition of an application with two
RTOS (OSEK/VDX and VxWorks), taking into account the
different behavior of the platform, has been given.
Future prospects are scheduled in order to meet the needs
identiﬁed in Section VII. We are exploring the possibility of
extending the formalization with other model classes such as
Scheduling TPN [27], where both cooperative and preemptive
scheduling are considered.
125
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

REFERENCES
[1]
C. Lelionnais, M. Brun, J. Delatour, O. H. Roux, and C. Seidner,
“Formal
Composition
Based
on Roles
within
a Model
Driven
Engineering Approach,” in Advances in System Testing and Validation.
Venice, Italy: IARIA, Nov. 2013, pp. 27–32. [Online]. Available:
http://hal.archives-ouvertes.fr/hal-00941024 and www.thinkmind.org
[2]
J. Miller and J. Mukerji, “Model Driven Architecture (MDA) Guide,
version 1.0.1.” Tech. Rep., June 2003.
[3]
J. C. Maeng, D. Na, Y. Lee, and M. Ryu, “Model-Driven Development
of RTOS-Based Embedded Software,” in Proceedings of the 21st
International Conference on Computer and Information Sciences, ser.
ISCIS’06.
Berlin, Heidelberg: Springer-Verlag, 2006, pp. 687–696.
[4]
B. Kim, I. Lee, L. T. X. Phan, and O. Sokolsky, “Platform dependent
code generation of real-time embedded software,” in Proceedings of the
4th ACM/IEEE International Conference on Cyber-Physical Systems,
ser. ICCPS ’13.
New York, NY, USA: ACM, 2013, pp. 246–246.
[5]
W. El Hajj Chehade, “Contribution to Multiplatform Deployment of
Multitasking Applications by High-Level Execution Services Behav-
ioral Modeling,” Ph.D. dissertation, Laboratoire d’Ing´enierie Dirig´ee
par les Mod`eles des Syst`emes Temps R´eels Embarqu´es (LISE) - CEA
Saclay, 2011.
[6]
Object Management Group (OMG), “UML Proﬁle for Modeling and
Analysis of Real Time and Embbeded Systems (MARTE), version 1.1.”
Tech. Rep., June 2011.
[7]
F. Thomas, S. G´erard, J. Delatour, and F. Terrier, “Software Real-Time
Resource Modeling,” in Embedded Systems Speciﬁcation and Design
Languages.
Springer, 2008, pp. 169–182.
[8]
J. Kim, I. Kang, J.-Y. Choi, I. Lee, and S. Kang, “Formal synthesis
of application and platform behaviors of embedded software systems,”
Software & Systems Modeling, 2013, pp. 1–21.
[9]
A. Pinto, “Metropolis Design Guidelines,” University of California,
Berkeley, USA, Tech. Rep., Nov. 2004.
[10]
J. Davis, “GME: The Generic Modeling Environment,” in Companion
of the 18th Annual ACM SIGPLAN Conference on Object-oriented
Programming, Systems, Languages, and Applications, ser. OOPSLA
’03.
New York, NY, USA: ACM, 2003, pp. 82–83.
[11]
E. A. Lee, “Overview of the Ptolemy Project,” EECS Department,
University of California, Berkeley, Tech. Rep. UCB/ERL M03/25, July
2003.
[12]
M. Brun, “Contribution to the Software Execution Platform Integration
during an Application Deployment Process,” Ph.D. dissertation, ´Ecole
Centrale de Nantes, Nantes, France, Oct. 2010.
[13]
M. Brun and J. Delatour, “Contribution on the Software Execution
Platform Integration During an Application Deployment Process,” in
First Topcased Day, Toulouse, France, Feb. 2011.
[14]
C. Lelionnais, M. Brun, J. Delatour, O. H. Roux, and C. Seidner,
“Formal Behavioral Modeling of Real-Time Operating Systems,” in
14th Int. Conf. Ent. Information Systems - Model Driven Development
for Information Systems (MDDIS 2012), Wroclaw, Poland, June 2012.
[15]
F. Thomas, J. Delatour, F. Terrier, and S. Gerard, “Towards a Frame-
work for Explicit Platform-Based Transformations,” in 11th IEEE
International Symposium on Object Oriented Real-Time Distributed
Computing (ISORC), May 2008, pp. 211–218.
[16]
OSEK/VDX Group, “OSEK/VDX Operating System Speciﬁcation,
version 2.2.3,” Tech. Rep., Feb. 2005, http://www.osek-vdx.org/.
[17]
WindRiver, “VxWORKS Programmer’s Guide, version 6.9.” Tech. Rep.,
Feb. 2011.
[18]
P. M. Merlin, “A Study of the Recoverability of Computing Systems,”
Ph.D. dissertation, 1974, aAI7511026.
[19]
M. Boyer and O. H. Roux, “On the Compared Expressiveness of
Arc, Place and Transition Time Petri Nets,” Fundamenta Informaticae,
vol. 88, no. 3, 2008, pp. 225–249.
[20]
F. Ta¨ıani, M. Paludetto, and J. Delatour, “Composing Real-Time Ob-
jects: A Case for Petri Nets and Girard’s Linear Logic,” in Proceedings
of the 4th IEEE International Symposium on Object-Oriented Real-
Time Distributed Computing, ISORC-2001.
IEEE, 2001, pp. 298–305.
[21]
F. Peres, B. Berthomieu, and F. Vernadat, “On the Composition of Time
Petri Nets,” Discrete Event Dynamic Systems, vol. 21, no. 3, Sept. 2011,
pp. 395–424.
[22]
C. A. Petri, “Kommunikation mit Automaten,” Ph.D. dissertation,
Institut f¨ur Instrumentelle Mathematik, Bonn, 1962.
[23]
G. Bucci, A. Fedeli, L. Sassoli, and E. Vicario, “Timed State Space
Analysis of Real-Time Preemptive Systems,” IEEE Transactions on
Software Engineering, vol. 30, no. 2, Feb. 2004, pp. 97–111.
[24]
D. Lime, O. H. Roux, C. Seidner, and L. M. Traonouez, “Rom´eo: A
Parametric Model-Checker for Petri Nets with Stopwatches,” in 15th
International Conference on Tools and Algorithms for the Construction
and Analysis of Systems (TACAS 2009), ser. Lecture Notes in Com-
puter Science, S. Kowalewski and A. Philippou, Eds., vol. 5505. York,
United Kingdom: Springer, Mar. 2009, pp. 54–57.
[25]
A. Jovanovi´c, D. Lime, and O. H. Roux, “Integer Parameter Synthesis
for Timed Automata,” in 19th International Conference on Tools and
Algorithms for the Construction and Analysis of Systems (TACAS
2013), ser. Lecture Notes in Computer Science, N. Piterman and
S. Smolka, Eds., vol. 7795.
Rome, Italy: Springer, Mar. 2013, pp.
401–415.
[26]
Airlines Electronic Engineering Committee, “Avionics Application Soft-
ware Standard Interface, ARINC Speciﬁcation 653-1,” Tech. Rep., Oct.
2003, aeronautical radio INC., Annapolis, Maryland, USA.
[27]
D. Lime and O. H. Roux, “Formal Veriﬁcation of Real-Time Systems
with Preemptive Scheduling,” Journal of Real-Time Systems, vol. 41,
no. 2, 2009, pp. 118–151, copyright Springer.
126
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

ENABLET 1
enablingT 1
LAP SET 1
ACT IV AT IONT 1
activationT 1
SUSP ENDEDT 1
terminatedStateT 1
[inc; inc]
incrementT 1
[period; period]
cycleT 1
[0; 0]
resumeT 1
READYT 1
activatedStateT 1
READYT 2
activatedStateT 2
[0; 0]
activateT 1
P ROCESSORT 1
processorT 1
resumedStateT 1
RUNNINGT 1
startT 1
ST ARTT 1
[0; 0]
executeT 1
endT 1
ENDT 1
NT1
NT1 withBody
ENABLET 2
enablingT 2
LAP SET 2
ACT IV AT IONT 2
activationT 2
SUSP ENDEDT 2
terminatedStateT 2
[inc; inc]
incrementT 2
[period; period]
cycleT 2
[0; 0]
resumeT 2
READYT 2
activatedStateT 2
[0; 0]
activateT 2
P ROCESSORT 2
processorT 2
resumedStateT 2
RUNNINGT 2
startT 2
ST ARTT 2
[0; 0]
executeT 2
endT 2
ENDT 2
NT2
NT2 withBody
endS
ENDGet1(S)
countS
F REEGet1(S)
discountS
BUSYGet1(S)
startS
ST ARTGet1(S)
[0; 0]
getGet1(S)
[0; 0]
getBypassGet1(S)
NGet1(S)
endS
ENDGet2(S)
countS
F REEGet2(S)
discountS
BUSYGet2(S)
startS
ST ARTGet2(S)
[0; 0]
getGet2(S)
[0; 0]
getBypassGet2(S)
NGet2(S)
endS
ENDRelease1(S)
countS
F REERelease1(S)
discountS
BUSYRelease1(S)
startS
ST ARTRelease1(S)
[0; 0]
releaseRelease1(S)
[0; 0]
releaseBypassRelease1(S)
NRelease1(S)
endS
ENDRelease2(S)
countS
F REERelease2(S)
discountS
BUSYRelease2(S)
startS
ST ARTRelease2(S)
[0; 0]
releaseRelease2(S)
[0; 0]
releaseBypassRelease2(S)
NRelease2(S)
P ROCESSORT erminate1(T 1)
processorT 1
endT 1
ENDT erminate1(T 1)
resumedStateT 1
RUNNINGT erminate1(T 1)
terminatedStateT 1
SUSP ENDEDT erminate1(T 1)
startT 1
ST ARTT erminate1(T 1)
[0; 0]
terminateT erminate1(T 1)
NTerminate1(T1)
P ROCESSORT erminate2(T 2)
processorT 2
endT 2
ENDT erminate2(T 2)
resumedStateT 2
RUNNINGT erminate2(T 2)
terminatedStateT 2
SUSP ENDEDT erminate2(T 2)
startT 2
ST ARTT erminate2(T 2)
[0; 0]
terminateT erminate2(T 2)
NTerminate2(T2)
NT1Body
NT2Body
P ROCESSOR
processorP roc
NProc
countS
F REES
discountS
BUSYS
NS
NDeployedApplication
(a)
(a)
(a)
(a)
(a)
(a)
(a)
(a)
(b)
(b)
(b)
(b)
(b)
(b)
(b)
(b)
(b)(b)
(c)
(c)
(c)
(c)
(d)
(d)
(d)
Fig. 5: Deployed application of semaphore sharing composed in RI TPN
127
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

LAP SET 3
ACT IV AT IONT 3
activationT 3
SUSP ENDED
terminatedStateT 3
[3a; 3a]
cycleT 3
[0; 0]
resumeT 3
READYT 3
activatedStateT 3
READYT 1
activatedStateT 1
READYT 2
activatedStateT 2
[0; 0]
activateT 3
P ROCESSORT 3
processorT 3
resumedStateT 3
RUNNINGT 3
startT 3
ST ARTT 3
[0; 0]
executeT 3
endT 3
ENDT 3
NT3
NT3 withBody
P ROCESSORT erminate3(T 3)
processorT 3
endT 3
ENDT erminate3(T 3)
resumedStateT 3
RUNNINGT erminate3(T 3)
terminatedStateT 3
SUSP ENDEDT erminate3(T 3)
startT 3
ST ARTT erminate3(T 3)
[0; 0]
terminateT erminate3(T 3)
DEADLINET erminate3(T 3)
[20; 28]
delayT erminate3(T 3)
NTerminate3(T3)
NT3Body
(b)
(b)
(b)
(b)
(b)
(a) OSEK/VDX
W D ENABLEDT 3
[3a; 3a]
cycleT 3
W D ELAP SEDT 3
[0; 0]
wdExecuteT 3
ST ART wdStartT 3
[0; 0]
wdStartT 3
ST ART semGiveT 3
[0; 0]
semGiveT 3
END semGiveT 3
SEM F ULLT 3
countT 3
SEM EMP T YT 3
discountT 3
P ENDEDT 3
suspendedStateT 3
[0; 0]
resumeT 3
READYT 3
activatedStateT 3
READYT 1
activatedStateT 1
READYT 2
activatedStateT 2
[0; 0]
wakeT 3
P ROCESSORT 3
processorT 3
resumedStateT 3
EXECUT INGT 3
startT 3
ST ARTT 3
[0; 0]
executeT 3
endT 3
ENDT 3
NT3
NT3 withBody
P ROCESSORT ake3(SEM T 3)
processorT 3
endT 3
ENDT ake3(SEM T 3)
resumedStateT 3
EXECUT INGT ake3(SEM T 3)
suspendedStateT 3
P ENDEDT ake3(SEM T 3)
SEM F ULLT ake3(SEM T 3)
countT 3
SEM EMP T YT ake3(SEM T 3)
discountT 3
startT 3
ST ARTT ake3(SEM T 3)
[0; 0]
takeT ake3(SEM T 3)
[0; 0]
pendT ake3(SEM T 3)
DEADLINET ake3(SEM T 3)
[20; 28]
delayT ake3(SEM T 3)
NTake3(SEM T3)
NT3Body
(b)
(b)
(b)
(b)
(b)
(b)
(b)
(b) VxWorks
Fig. 6: RI TPN of periodic task implemented on two different RTOS
128
International Journal on Advances in Systems and Measurements, vol 7 no 1 & 2, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

