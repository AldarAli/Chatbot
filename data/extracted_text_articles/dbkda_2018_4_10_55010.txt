Interactive Graph Query Language for Multidimensional Data in
Collaboration Spotting Visual Analytics Framework
Adam Agocs∗, Dimitrios Dardanis∗, Jean-Marie Le Goff∗, Dimitrios Proios∗
∗CERN, CH-1211 Geneva 23, Switzerland
E-mail: {Adam.Agocs, Dimitrios.Dardanis, Jean-Marie.Le.Goff, Dimitrios.Proios}@cern.ch
Abstract—Human reasoning in visual analytics of data networks
relies mainly on the quality of visual perception and the capability
of interactively exploring the data from different perspectives. Vi-
sual quality strongly depends on networks’ size and dimensional
complexity while network exploration capability relies upon the
intuitiveness and expressiveness of user frontends. The approach
taken in this paper aims at addressing the above by decomposing
data networks into multiple networks of smaller dimensions
and building an interactive graph query language that supports
full navigation across the sub-networks. Within sub-networks
of reduced dimensionality, structural abstraction and semantic
techniques can then be used to enhance visual perception further.
Keywords–Visual analytics; labelled graph; graph query lan-
guage; visualisation; patents and publications
I.
INTRODUCTION
According to an English idiom, “A picture is worth a
thousand words”. Visual analytics aims to combine the power
of visual perception with high performance computing in order
to support human analytical reasoning. Since Wong et al. [1]
in 2004, visual analytics has been widely used in various
ﬁelds, such as biology or national security but also in other
ﬁelds, such as climate monitoring [2][3] or social networks
analysis, the ﬁeld originally addressed by the Collaboration
Spotting project (CS). Multidimensional networks built out
of interconnected elements contained in datasets and repre-
sented as directed and labelled graphs are a natural means
of representing data for visual analytics. These graphs - often
referred to as knowledge graphs - comprise labelled nodes and
relationships and their data schemas are graphs of labels that
correspond to the networks’ dimensions.
Graphs as database models and graph query languages
deﬁned over these models have been investigated for some 30
years [4]. These models and languages have been used in many
applications using a wide spectrum of data (e.g., biology, social
network and criminal investigation data), clearly indicating that
the combination of visual analytics with graph query languages
has become quite popular.
According to Wong et al. [5], one of the biggest challenges
in visual analytics is User-Driven Data Reduction which
calls for “a ﬂexible mechanism that users can easily control
according to their data collection practices and analytical
needs” to reduce the amount of data [6]. This essentially
entails an improvement of the visualization clarity and an
escalation of data processing performances irrespective of the
increasing complexity of the data over the years. To meet
this challenge, semantic and structural abstraction techniques,
such as clustering, collapsing, extraction and demonstration
of relationships among graph entities can be used [7] at the
expanse of a loss of information on the network content [8].
Dimension reduction is central to the visualization of data
networks since it enables users to increase their insight into the
data. The approach taken in the Collaboration Spotting project
is to reduce the dimensional complexity of data networks while
maintaining the information about their content. It consists
in decomposing directed and labelled graphs into multiple
directed and weighted graphs of lesser dimensions - named
views - and in building an interactive graph query language
that supports user-speciﬁed views and full navigation across
the data networks using these views as a support to the op-
erations of the language. Within a view, structural abstraction
techniques can then be used to enhance the visual perception
further. The novelty of the approach taken is to combine Visual
graph representation and User interactions [9] at the graph
query language level with a view to supporting interactive
dimension reduction based on the concept of blueprint where
the architectural plan is distributed across different navigable
views. In this context, users can select and combine labels
according to their semantic understanding of the network
models and visualize the corresponding network structures.
Section II gives a short overview on visualisation tech-
niques for visual analytics (focusing on social networks) and
on graph query languages ﬁt to data networks. Section III gives
a short description of the mathematical background supporting
the approach. Section IV, introduces how views are constructed
and Section V shows how the basic operations of the query
language enable users to conduct their analysis. In Section VI,
the use-case that inspired the Collaboration Spotting project
and the graphical query language are presented. This paper
ends with conclusions and future work in Section VII.
II.
RELATED WORK
The related work is twofold since it combines multiple
visual analytics techniques with the power of graph query
languages. In the last 15 years, a lot of visual analytics
articles were published with the aim of showing processes
of transformation of multidimensional data into node-link
diagrams [9][10].
A lot of articles have been published, especially on the
coordinated multiple views topic, which introduces a visual
analytics paradigm supported by an interactive query language
or by a set of operations. These articles can be divided into
four different groups:
•
OLAP [11] inspired paradigms that are using opera-
tions like slice, roll-up, dice, etc. The most relevant pa-
pers are PivotGraph [12], ScatterDice [13], GraphDice
[14], MatrixCube [15] and Orion [16].
56
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

•
Relational algebra-related solutions such as Cross-
ﬁlter views [17] which uses grouping, ﬁltering, pro-
jection and selection operations, Polaris [18] that
introduces and maps its algebra to SQL and Ploceus
[19], which works with ﬁrst-order logic language.
•
Other solutions such as Cross-ﬁlter views with hyper-
graph query language [20], JUNG [21] and Gephi [22]
that allow users to use other programming languages
(JAVA in these cases).
•
Literature on graph query languages is huge [23]–
[30]. It covers the use of different graph models
reﬂecting the variety of requirements for applications
and languages.
The visual analytics model introduced in this paper pro-
motes a different approach to graph query language. The
language operates on a directed, labelled graph that is managed
via user interactions treated as query inputs and follows the
semantic web query language concepts, SPARQL [31] and
Cypher [32][33]. This approach allows users to generate graph
patterns and evaluate them directly on the graph. Reducing
the complexity of network is not a novel idea [34]. The main
differences between existing solutions and the one proposed
in this paper are i) the introduction of a proper mathematical
model based on labelled graphs; ii) a label-based complexity
reduction (views); iii) basic operations to support navigation
across views and iv) an intuitive user interface to drive these
operations.
III.
BASIC GRAPH AND VIEWS
Let graph G be a directed, labelled graph deﬁned as a four-
element tuple G = (V, E, L, α) where V represents a set of
nodes and E ⊆ V × V , a set of edges deﬁned as a subset
of the Cartesian products of these nodes. L is a set of node
labels and α : V → L is a mapping function from nodes to
the corresponding labels. Figure 1 shows an example of such
a graph. We deﬁne the reachability graph over graph G as
label1
v1
label1
v2
label1
v3
label2
v4
label2
v5
label3
v6
label3
v7
label3
v8
label3
v9
label4
v10
label4
v11
label5
v12
label5
v13
label6
v14
label7
v15
Figure 1. Example of graph G where V = {v1, . . . v15} and
L = {label1, . . . label7}
Greachability = (L, Ereachability) where nodes are labels of
graph G, Ereachability ⊆ L × L is deﬁned as the Cartesian
product of the labels where any two nodes of Greachability
are connected if and only if there exists two connected nodes
in graph G and their respective labels correspond to the
two nodes of graph Greachability. Graph Greachability is a
description of graph G, it is also called the graph schema
of graph G. Graph schema helps users view graph G via
different sub-graphs of lesser dimensionality using labels of G
as dimensions and facilitates the generation of approximately
optimal user-deﬁned graph queries. Let graph Gpattern =
(Vpattern, Epattern) be a graph pattern where Vpattern ⊆ L
and Epattern ⊆ Ereachability ∩Vpattern ×Vpattern. To process
the answer to a graph query, one needs to ﬁnd all possible
isomorphic subgraphs of G that are homomorphic to a graph
pattern Gpattern corresponding to the query. This is a graph
pattern matching problem, a well-known part of Mathematics
[35]. In this case, one deﬁnes Graph G′ = (V ′, E′, L, α), a
subgraph of graph G as a sample matching the graph pattern
Gpattern if and only if:
•
∀v′ ∈ V ′ : ∃v ∈ Vpattern, α(v′) = v,
•
∀(u′, v′) ∈ E′ : (α(u′), α(v′)) ∈ Epattern.
The answer to a graph query is a view containing the set of
subgraphs of G matching Gpattern. To build such a view, one
needs ﬁrst to introduce the graph pairing function pair and
the set Pattern. Let Gpattern1 and Gpattern2 be two graph
patterns. These graph patterns are paired iff
•
Vpattern1 = Vpattern2 and
•
∃!a, b ∈ Vpattern1 :
path(a,b) ∈ Epattern1 and path(a,b) ̸∈ Epattern2,
path(b,a) ̸∈ Epattern1and path(b,a) ∈ Epattern2,
Epattern1 \ path(a,b) = Epattern2 \ path(b,a).
Where a path is an alternate non-empty sequence of nodes
and edges, starting and ending with nodes and requiring that
all edges and nodes be distinct from one another. path(a,b) ∈
Epattern1 indicates that all edges of this path are in set
Epattern1. The pair function is deﬁned as
pair(Gpattern) :=

Gpair
pattern
if Gpair
pattern pair of Gpattern
(∅, ∅)
else.
And Pattern, the set of these pairs is deﬁned as Pattern :=
{(g, g′)|g, g′are patterns, g′ = pair(g)}.
A view of graph G is deﬁned as a six-element tuple Gq =
(Cq, Bq, Eq, Lq, ϵq, υq, ) where
•
Cq ⊂ V, LC := {α(v)|v ∈ Cq},
•
Bq ⊂ V, LB := {α(b)|b ∈ Bq},
•
Lq ⊆ L and Lq = LC ∪ LB,
•
Eq := {(u, v)|
u, v ∈ Cq, ∃G′, G′′ ⊆ G,
∃(Gpattern, pair(Gpattern)),
(G′
pattern, pair(G′
pattern)) ∈ Patterns :
G′ matches to Gpattern,
G′′ matches to pair(G′
pattern),
∃b ∈ Bq : path(u, b) ∈ G′, path(b, v) ∈ G′′},
•
ϵq : Eq → P(Bq), ϵq((u, v)) = {b|
b ∈ Bq, ∃G′, G′′ ⊆ G,
∃(Gpattern, pair(Gpattern)),
(G′
pattern, pair(G′
pattern)) ∈ Patterns :
G′ matches to Gpattern,
G′′ matches to pair(G′
pattern),
path(u, b) ∈ G′, path(b, v) ∈ G′′},
57
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

•
υq : Cq → P(Bq), υq(u) = {b|b ∈ Bq,
∃G′ ⊆ G, ∃(Gpattern, pair(Gpattern)) ∈ Patterns :
G′ matches to Gpattern, path(u, b) ∈ G′}.
The use of multiple graph patterns for the construction of graph
Gq is required since the cardinality of set LB and set LC are
not necessary equal to 1 (see details in Section IV-A). To ease
the reading, graph Gq is noted GLC
LB to refer directly to the set
of labels used in the construction of the view. Also, in practice,
we use an aggregation function on edges, respectively on nodes
in graph Gq for determining their respective weights instead of
the elements in set Bq (for instance, the number of elements).
Figure 2 shows an example of a view when the two graph
patterns are Gpattern = ({label1, label3}, {(label1, label3)})
and pair(G′
pattern) = ({label1, label3}, {(label3, label1)}).
label3
v6
label3
v7
label3
v8
label3
v9
{v1}
{v2, v3}
{v3}
{v2}
{v2}
Figure 2. Example of a view where Cq = {v6, . . . , v9},
Bq = {v1, . . . , v3}, LC = {label3}, LB = {label1}.
IV.
GRAPH CREATION FROM USER INTERACTIONS
In this section, we introduce how graph patterns and views
can be created as a result of the following user interactions:
•
Selection of different nodes in the current view,
•
Removal of all nodes with the same label selected in
one of the previous views,
•
Navigation from one view to another.
Users can modify set LC and set LB when performing any
of the above interactions. Let F ⊆ V be the set of nodes
corresponding to a user selection, we deﬁne from F:
1)
LF := {l ∈ L|∃f ∈ F : α(f) = l} which contains
the labels of nodes in set F and,
2)
F|L∗ := {f ∈ F|α(f) ∈ L∗} with L∗ ⊆ L, a subset
of set F, restricted to nodes having their respective
labels in set L∗.
In order for set F to operate as a ﬁlter, the matched sample
deﬁnition of Section III has to be restricted by requiring that
∀v′ ∈ V ′, α(v′) ∈ LF ⇒ v′ ∈ F. Example 1 below shows the
content of LF for user selection F = {v4, v6, v7, v13} from
the graph G depicted in Figure 1.
Example 1.
F
=
{v4, v6, v7, v13}
(1)
LF
=
{label2, label3, label5}
(2)
A. Graph pattern construction
This section shows how to construct a graph pattern with
set LF containing all the labels of nodes in set F. We exploit
the fact that graph patterns are actually only needed when
constructing edges in GLC
LB and their respective weights. A
pair of graph patterns are required for each combination of
labels in set LC and set LB since paths connecting nodes
from set LC and set LB can have different directions, due to
the construction of edges between nodes of Cq and nodes of
Bq. Each pattern has to satisfy the following criteria:
•
It must be a connected and directed graph,
•
It must be minimal,
•
Labels from set L \ LF can be used as intermediate
nodes in the pattern.
These requirements exactly ﬁt a Steiner Minimal Tree problem
[36], known to be NP-complete[37] and for which we use a
minimal spanning tree solver as an approximation algorithm.
Algorithm 3 describes the full process of pair generation.
Figure 4 shows the graph schema of graph G depicted in Figure
1 and the generated patterns pair for {v4, v6, v7, V13} as set F,
with LC = {label4} and LB = {label1}.
Algorithm 3 Pattern generator algorithm
1: function PATTERNGENERATOR(FL, LB, LC)
2:
Patterns ← ∅
3:
B ← LB
4:
while B ̸= ∅ do
5:
from, B ← from ∈ B, B \ {from}
6:
E ← LC
7:
while E ̸= ∅ do
8:
to, E ← to ∈ E, E \ {to}
9:
Left ← SpanningTree(
FL ∪ {from, to}, from, to)
10:
Right ← SpanningTree(
FL ∪ {from, to}, to, from)
11:
Patterns ← Patterns ∪ {(Left, Right)}
12:
end while
13:
end while
14:
return Patterns
15: end function
B. Connecting user interactions and views
Now that graph patterns (Patterns) have been created
using set F, set LC and set LB, one can introduce the
gen function gen : P(V ) × P(L) × P(L) → GLC
LB that
generates views from user interactions, (F
⊆ P(V ) and
LC, LB ⊂ P(L)) as
gen(F, LC, LB) :=
F GLC
LB
= (F Cq,F Bq, Eq, Lq, υq, ϵq)
where
F Cq :=

V ∩ F|LC
if V ∩ F|LC ̸= ∅
V|LC
else
are the nodes of graph F GLC
LB and
F Bq :=
(
b ∈ V ′
|LB

∃G′ = (V ′, E′, L, α) ⊆ G, :
G′ matches to Gpattern, ∀v′ ∈ V ′ :
(v′ ∈ F or α(v′) ̸∈ LF )
are the “interconnection” nodes: The other members of the
six-tuple Gq are unchanged since
58
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

label1
label3
label4
label2
label1
label4
label3
label2
label5
label6
label7
label5
label1
label4
label3
label2
label5
Figure 4. On the left hand-side, the graph schema of graph G; On the
middle and on the right hand-side, an example of a graph pattern pair.
•
labels (set Lq) are not modiﬁed and since
•
edge deﬁnition (set Eq) and weighting functions (υq
and ϵq) only depend on set F Cq and set F Bq.
V.
OPERATIONS ON GRAPHS
User interactions will result in the following graph opera-
tions:
•
Selection: The user selects nodes in a view,
•
Expansion: The user expands a view by removing in
his previous selection, nodes having the same labels,
•
Navigation: The user navigates from a view to another.
To deﬁne these operations one needs ﬁrst to introduce the con-
cepts of visual equivalence and minimal views since there can
be views with nodes of null weight that are hidden to the user
and hence non-selectable. Let F1 and F2 be two different ﬁlters
on the same view complying with F1 \ F1|LC = F2 \ F2|LC.
In essence, this means that there is no difference in the sets of
nodes with labels contained in L\LC which technically should
be empty. View F1GLC
LB and view F2GLC
LB generated using F1
and F2 are said to be visual equivalent if and only if
Deﬁnition 1. (Vis-equivalent)
F1GLC
LB ˙∼ F2GLC
LB ⇔ ∀v ∈ V1 \ V2 : υq(v) = ∅,
∀v′ ∈ V2 \ V1 : υq(v′) = ∅,
where V1 (V2) represents the nodes of view
F1GLC
LB
(F2GLC
LB). Intuitively visual equivalence guaranties that nodes
that are not common to two views have empty weights. It
provides equivalence classiﬁcation on views. It is easy to prove
that for each class of views there is only one which does
not have nodes with empty weights. This view is called the
minimal view.
A. Selection on graphs
Let Fselect be the set of user selected nodes within a view.
Fselect ⊆ V and Fselect ⊆ V ′ where V ′ is a set of nodes from
the minimal view which is visual-equivalent to graph F GLC
LB.
The selection operator σ : Gq × P(V ) → Gq is deﬁned as
Deﬁnition 2. (Selection)
σ(F GLC
LB, Fselect) := gen((F \ F|LC) ∪ Fselect, LC, LB),
where F|LC = {f|f ∈ F, α(f) ∈ LC}. It is to be noted
that at view creation the selection operator uses a more general
deﬁnition of the gen function. Figure 6a and 6b show how the
selection operator works. As a result of applying this operator,
set LC and LB will only contain those nodes that are “related”
to this user selection.
B. Expansion on graphs
The expansion operator ξ is in some sense the “inverse” of
the selection operator. It is deﬁned as
Deﬁnition 3. (Expansion)
ξ(F GLC
LB, LC′) := gen(F \ F|LC′ , LC′, LB).
The expansion operator changes view when LC′ ̸= LC and
removes all nodes in set F that are labelled with labels in LC.
Figure 6d and 6e show how the expansion operator works.
C. Navigation through graphs
By selecting a subset of labels from LC one can build views
of graph G with reduced dimensional complexity. Navigation
across views is required to enable users to apprehend the full
graph G. Therefore the navigation function η goes from view
F GLC
LB to a view labelled as LC′ and LB′ and is deﬁned as:
Deﬁnition 4. (Navigation)
η(F GLC
LB, LC′, LB′) := gen(F, LC′, LB′)
Figure 6b and 6c show how the navigation between views
works.
D. Navigation history
The navigation history can be represented as a navigation
graph Gnav where nodes represent navigation states and edges
navigation steps between states. Gnav = (Nnav, Enav) com-
plies to
•
Nnav ⊂ P(V ) × P(L) × P(L).
•
Enav ⊆ Nnav × Nnav × {σ, ξ, η},
where there is a navigation step between node n1
=
(F1, LC1, LB1) to node n2 = (F2, LC2, LB2) if and only if
one of the following statements is true:
1)
σ(gen(F1, LC1, LB1), F2
\
F1)
=
gen(F2, LC2, LB2), and LC1 = LC2, LB1 = LB2;
2)
ξ(gen(F1, LC1, LB1), LC2)
=
gen(F2, LC2, LB2),
and F2 = F1 \ F1|LC2 , LB1 = LB2;
3)
η(gen(F1, LC1, LB1), LC2, LB2)
=
gen(F2, LC2, LB2) and F1 = F2.
In Enav, the third component of an edge is always one
of the operations σ, ξ or η. It indicates how the step was
processed. The proper size of Nnav is 2n ∗ (3m − 2m+1 + 1)
where n = |V | and m = |L|. A particular navigation history
corresponds to a walk in Gnav. An example of such a walk is
given below.
Example 2 (Walk on graph).
(F0, LC0, LB0), η, (F1, LC1, LB1), σ, . . . , ξ, (Ff, LCv, LBb)
59
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

In practice, a particular set of labels LC0 is used to create
an entry view from which all the above mentioned operations
can then be performed.
VI.
USE-CASE
In the framework of AIDA [38], an FP7 project on Ad-
vanced European Infrastructures for Detectors at Accelerators,
researchers needed to identify key players from academia
and industry for technologies considered as strategic for the
particle physics programme. To this end, the Collaboration
Spotting project was launched in 2012 with a view to enabling
users to search for terms describing particular technologies in
titles and abstracts of publications and patents and viewing
the organisation, subject category, keywords, city and country
landscapes for each of these searches individually. Individual
technology searches are represented as nodes in a view named
Technogram, used as the user entry view in which edges
represent publications and/or patents common to searches.
A. Data
Two different sources are used for searching. The meta-
data records of publications from Web of ScienceTM Core
Collection [39] developed by Clarivate Analytics (in the past,
Thomson Reuters) and the metadata records of patents from
PATSTAT developed by the European Patent Ofﬁce [40].
Although the two sources have a number of labels in common,
such as Organisation, City and Country there are others like
Subject Category and Keyword that only belong to publica-
tions. The subset of data from the two sources corresponding
to the labels of interest for users was used to construct graph
G and its schema Greachability.
B. Storing data in a graph database (Neo4j)
Graph G is stored in a Neo4j graph database [41], in
which individual metadata records are stored as subgraphs
of labelled nodes using Published item, Organisation, Subject
Category, Author Keyword, City, Region and Country as labels.
Figure 5 represents the reachability graph (graph schema) of
this network (Light color nodes represent nodes uploaded by
the data administrator and the dark nodes are created by the
system itself by using search and authentication modules).
Besides these labels, additional labels have been introduced
to support user authentication and authorisation (User) and
technology searches (Graph and Technology). Searches use full
text indices of the Apache Lucene project [42] that have been
integrated into the Neo4j database as legacy indices [41].
Statistic of the graph data: Searches on publications and
patents metadata records from the 2000 - 2014 period can
be performed. The resulting data network contains 45 million
nodes and 150 million edges. Its breakdown is given in Table
I. and Table II.
As can be noticed, the number of region edges is smaller
than the number of country edges due to the use of the 2nd
level of Nomenclature of Territorial Units For Statistic [43]
created by the European Commission, which covers Europe
only.
C. Navigation
The entry point for this use case is individual users. Using
the terminology introduced above, the initial values for set F
are user IDs.
Subject 
Category
Organis.
Technol.
Region
City
Country
Author 
Keyword
Published 
Item
Graph
User
Figure 5. The database schema (reachability graph)
TABLE I. NUMBER OF NODES BY NODE LABELS
TYPE OF NODES
NUMBER OF NODES
Patents
15.000.442
Publications
20.087.904
Organisations
2.918.060
Author Keywords
8.193.604
Subject Categories
230
Cities
7.741
Regions
946
Countries
128
Total
46.209.055
TABLE II. NUMBER OF EDGES BY NODE LABELS. A PATENT DOES
NOT HAVE AUTHOR KEYWORDS OR SUBJECT CATEGORIES
PROPERTY
PATENTS
PUBLICATIONS
TOTAL
Organ.
12.440.903
36.672.677
49.113.580
Author Key.
-
48.941.098
48.941.098
Subject Cat.
-
32.566.806
32.566.806
Cities
3.193.709
8.826.222
12.019.931
Regions
265.421
2.504.441
2.769.862
Count.
3.156.449
8.020.648
11.177.097
Total
19.056.482
137.531.892
156.588.374
Limitations: In the current implementation there is a re-
striction on the size of LC and LB ﬁxed to a single label
Published Item and the visualization system only supports
undirected edges. This calls for the generation of only one
graph pattern instead of two making the system faster.
In Figure 6, a series of pictures illustrate how navigation
operations work. A user enters the system in a technology view
(nodes are labelled with the Technology label). In the example,
this view contains four “technologies” (obtained as results
of searches using Lucene-indices), namely Database, Lan-
guage, Graph Language and Visual Analytics. Links between
nodes indicate publications and patents common to technology
searches. As indicated in the reachability graph of Figure
5, users can access other views via nodes labelled with the
Published Item label. The user selects two technology nodes
from Figure 6a, giving Fselect ={Visual Analytics, Language}.
Figure 6b shows the result of this selection: Language and
60
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

(a) Technology view: (LC = {Technology}, LB = {Published Item});
Selecting two technologies (Fselect = {Visual Analytics, Language})
(b) Result of the selection
(c) Navigation to the “Subject Category view”
(d) Selecting a cluster in the Subject Category view; expanding the view
and going back to the Technology view
(e) Technology view with F = {Language, Lingustics . . . Rehabilitation}
ﬁlter
Figure 6. Example of operations; navigation, selection and expansion on views
Visual Analytics. Changing set LC from value {Technology}
to value {Subject Category} enables the navigation operation
to reach the Subject Category view corresponding to the two
previously selected technology nodes. Figure 6c shows the
61
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

view resulting from this operation. It is optained using the
(LC = {Subject Category}, LB = {Published Item}, F =
{Language, Visual Analytics}) triplet. In Figure 6d, the user
selects a few nodes from the view of Figure 6c (i.e., the F ﬁlter
was extended with Linguistic, ..., values). After selection of
the value {Technology} for LC, the expansion and navigation
operations bring the user back to the technology view of
Figure 6e. This view shows the technology nodes having
publications with nodes labelled with the Subject Category
label corresponding to the last user selection.
VII.
CONCLUSION AND FUTURE WORK
The current version of Collaboration Spotting running at
CERN [44] addresses the implementation of the concepts
using patents and publications metadata records. It is a new
experimental service that aims to provide the High Energy
Physics community (such as HEPTech [45]) with information
on Academia & Industry main players active around key
technologies, with a view to fostering more inter-disciplinary
and inter-sectoral R&D collaborations, and giving the procure-
ment service the opportunity of reaching a wider selection
of high-tech companies for bidding purposes. Collaboration
Spotting is generic in its concepts and implementation. It
can support visual analytics of any kind of data and its
backend is implemented using a Neo4j graph database [41].
Conference papers, technical & business news, trademarks &
designs and ﬁnancial data are amongst the data targeted to
enrich the information on technologies that one can obtain
from publications and patents. The choice of data sources
will depend on users’ priorities. The tool can be of use to
other communities, in particular in dentistry [46] but also to
policy makers and investors if data in the knowledge graph
is enriched with technical & business news and ﬁnancial data.
Collaboration Spotting also addresses other types of data, such
as compatibility and dependency relationships in software and
meta-data [47][48] of the LHCb experiment at CERN.
As an interactive graph query language, Collaboration
Spotting is intended to provide a fully customisable visual
analytics environment. In the current version, data processing
supports searches and contextual queries. In the future, labelled
& directed relationships and attributes on nodes will be in-
cluded in the labelled property graph representation of the data
network and the processing will be extended to more complex
operations directly on the graph resulting from searches and
queries with a view to enhancing the visual perception of users.
ACKNOWLEDGMENT
We are very thankful to Richard Forster, Sotiris Fragkiskos,
Tim Hertweck, Nikos Kasﬁkis, Xavier Ouvrard and Eirik
Skogstad from CERN for their hard work in implementing the
ﬁrst prototypes of Collaboration Spotting. We are also thankful
to Bernard Denis from CERN and Emanuele Leonardi from
INFN who provided very valuable feedback when testing the
early version of the tool; Thierry Lagrange from CERN for
ensuing sufﬁcient funding to support the development.
REFERENCES
[1]
P. C. Wong and J. Thomas, “Visual analytics,” IEEE Comput. Graph.
Appl., vol. 24, no. 5, pp. 20–21, Sep. 2004, ISSN 0272-1716, doi:
10.1109/MCG.2004.39.
[2]
J. B. Kollat, P. M. Reed, and R. M. Maxwell, “Many-objective
groundwater monitoring network design using bias-aware ensemble
Kalman ﬁltering, evolutionary optimization, and visual analytics,” Water
Resour. Res., vol. 47, no. 2, pp. 1:1–1:18, 2011, ISSN 1944-7973, doi:
10.1029/2010WR009194,, w02529.
[3]
A. Scharl, A. Hubmann-Haidvogel, A. Weichselbraun, H. P. Lang,
and M. Sabou, “Media watch on climate change – visual analytics
for aggregating and managing environmental knowledge from online
sources,” in 2013 46th Hawaii Int. Conf. System Sciences, Jan 2013,
pp. 955–964, ISSN 1530-1605, doi: 10.1109/HICSS.2013.398.
[4]
P. T. Wood, “Query languages for graph databases,” SIGMOD
Rec., vol. 41, no. 1, pp. 50–60, Apr. 2012, ISSN 0163-5808, doi:
10.1145/2206869.2206879.
[5]
P. C. Wong, H. W. Shen, C. R. Johnson, C. Chen, and R. B. Ross, “The
top 10 challenges in extreme-scale visual analytics,” IEEE Comput.
Graph. Appl., vol. 32, no. 4, pp. 63–67, July 2012, ISSN 0272-1716,
doi: 10.1109/MCG.2012.87.
[6]
E. Namey, G. Guest, L. Thairu, and L. Johnson, “Data reduction
techniques for large qualitative data sets,” in Handbook for team-based
qualitative research, vol. 2, pp. 137–161, ISBN 978-0-7591-1373-2.
[7]
T. A. Davis and Y. Hu, “The university of Florida sparse matrix
collection,” ACM Trans. Math. Softw., vol. 38, no. 1, pp. 1:1–1:25,
Dec. 2011, ISSN 0098-3500, doi: 10.1145/2049662.2049663.
[8]
Z. Shen, K.-L. Ma, and T. Eliassi-Rad, “Visual analysis of large
heterogeneous social networks by semantic and structural abstraction,”
IEEE Trans. Vis. Comput. Graphics, vol. 12, no. 6, pp. 1427–1439, Nov
2006, ISSN 1077-2626, doi: 10.1109/TVCG.2006.107.
[9]
T. von Landesberger et al., “Visual analysis of large graphs: state-of-
the-art and future research challenges,” Comput. Graph. Forum, vol. 30,
no. 6, pp. 1719–1749, 2011, ISSN 1467-8659, doi: 10.1111/j.1467-
8659.2011.01898.x.
[10]
J. Kehrer and H. Hauser, “Visualization and visual analysis of multi-
faceted scientiﬁc data: A survey,” IEEE Trans. Vis. Comput. Graphics,
vol. 19, no. 3, pp. 495–513, March 2013, ISSN 1077-2626, doi:
10.1109/TVCG.2012.110.
[11]
J. Gray et al., “Data Cube: A relational aggregation operator gener-
alizing group-by, cross-tab, and sub-totals,” Data Min. Knowl. Dis-
cov., vol. 1, no. 1, pp. 29–53, Mar 1997, ISSN 1573-756X, doi:
10.1023/A:1009726021843.
[12]
M. Wattenberg, “Visual exploration of multivariate graphs,” in Proc.
SIGCHI Conf. Human Factors in Computing Systems, ser. CHI ’06.
New York, NY, USA: ACM, 2006, pp. 811–819, ISBN 1-59593-372-7,
doi: 10.1145/1124772.1124891.
[13]
N. Elmqvist, P. Dragicevic, and J. D. Fekete, “Rolling the dice: Multidi-
mensional visual exploration using scatterplot matrix navigation,” IEEE
Trans. Vis. Comput. Graphics, vol. 14, no. 6, pp. 1539–1148, Nov 2008,
ISSN 1077-2626, doi: 10.1109/TVCG.2008.153.
[14]
A. Bezerianos, F. Chevalier, P. Dragicevic, N. Elmqvist, and J. D.
Fekete, “Graphdice: A system for exploring multivariate social net-
works,” in Proc. 12th Eurographics / IEEE - VGTC Conf. Vis.,
ser. EuroVis’10.
Chichester, UK: The Eurographs Association and
John Wiley & Sons, Ltd., 2010, pp. 863–872, doi: 10.1111/j.1467-
8659.2009.01687.x.
[15]
B. Bach, E. Pietriga, and J.-D. Fekete, “Visualizing dynamic networks
with matrix cubes,” in Proc. SIGCHI Conf. Human Factors in Com-
puting Systems, ser. CHI ’14.
New York, NY, USA: ACM, 2014, pp.
877–886, ISBN 978-1-4503-2473-1, doi: 10.1145/2556288.2557010.
[16]
J. Heer and A. Perer, “Orion: A system for modeling, transformation and
visualization of multidimensional heterogeneous networks,” Inf. Vis.,
vol. 13, no. 2, pp. 111–133, 2014, doi: 10.1177/1473871612462152.
[17]
C. Weaver, “Cross-ﬁltered views for multidimensional visual analysis,”
IEEE Trans. Vis. Comput. Graphics, vol. 16, no. 2, pp. 192–204, March
2010, ISSN 1077-2626, doi: 10.1109/TVCG.2009.94.
[18]
C. Stolte, D. Tang, and P. Hanrahan, “Polaris: a system for query,
analysis, and visualization of multidimensional relational databases,”
IEEE Trans. Vis. Comput. Graphics, vol. 8, no. 1, pp. 52–65, Jan 2002,
ISSN 1077-2626, doi: 10.1109/2945.981851.
[19]
Z. Liu, S. B. Navathe, and J. T. Stasko, “Network-based vi-
sual analysis of tabular data,” in 2011 IEEE Conf. Visual Ana-
62
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

lytics Science and Technology (VAST), Oct 2011, pp. 41–50, doi:
10.1109/VAST.2011.6102440.
[20]
R. Shadoan and C. Weaver, “Visual analysis of higher-order conjunctive
relationships in multidimensional data using a hypergraph query sys-
tem,” IEEE Trans. Vis. Comput. Graphics, vol. 19, no. 12, pp. 2070–
2079, Dec 2013, ISSN 1077-2626, doi: 10.1109/TVCG.2013.220.
[21]
J.
O’Madadhain,
D.
Fisher,
S.
White,
and
Y.
Boey,
“The
JUNG
(Java
universal
network/graph)
framework,”
University
of
California,
Irvine,
California,
2003.
[Online].
Available:
http://jung.sourceforge.net/index.html 2018.04.03
[22]
M. Bastian, S. Heymann, and M. Jacomy, “Gephi: an open source
software for exploring and manipulating networks,” 3rd Int. AAAI Conf.
Weblogs and Social Media (ICWSM), vol. 8, pp. 361–362, 2009.
[23]
J. Hidders and J. Paredaens, “Goal, a graph-based object and association
language,” in Adv. Database Systems: Implementations and Applica-
tions, J. Paredaens and L. Tenenbaum, Eds.
Vienna: Springer Vienna,
1994, pp. 247–265, ISBN 978-3-7091-2704-9, doi: 10.1007/978-3-
7091-2704-9 13.
[24]
J. Paredaens, D. V. Gucht, J. V. den Bussche, and M. Gyssens, “A graph-
oriented object database model,” IEEE Trans. Knowl. Data Eng., vol. 6,
pp. 572–586, 08 1994, ISSN 1041-4347, doi: 10.1109/69.298174.
[25]
J. Hidders, “Typing graph-manipulation operations,” in Database Theory
— ICDT 2003, D. Calvanese, M. Lenzerini, and R. Motwani, Eds.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2003, pp. 394–409,
ISBN 978-3-540-36285-2, doi: 10.1007/3-540-36285-1 26.
[26]
R. H. G¨uting, “GraphDB: modeling and querying graphs in databases,”
in Proc. 20th Int. Conf. Very Large Data Bases, ser. VLDB ’94.
San
Francisco, CA, USA: Morgan Kaufmann Publishers Inc., 1994, pp. 297–
308, ISBN 1-55860-153-8.
[27]
H. S. Kunii, “DBMS with graph data model for knowledge handling,” in
Proc. 1987 Fall Joint Computer Conf. Exploring Technology: Today and
Tomorrow, ser. ACM ’87.
Los Alamitos, CA, USA: IEEE Computer
Society Press, 1987, pp. 138–142, ISBN 0-8186-0811-0.
[28]
P. Barcel´o Baeza, “Querying graph databases,” in Proc. 32nd Symp.
Principles of Database Systems, ser. PODS ’13.
New York, NY,
USA: ACM, 2013, pp. 175–188, ISBN 978-1-4503-2066-5, doi:
10.1145/2463664.2465216.
[29]
J. Paredaens, P. Peelman, and L. Tanca, “G-Log: a graph-based query
language,” IEEE Trans. Knowl. Data Eng., vol. 7, no. 3, pp. 436–453,
Jun 1995, ISSN 1041-4347, doi: 10.1109/69.390249.
[30]
J. Yang, S. Zhang, and W. Jin, “DELTA: indexing and querying
multi-labeled graphs,” in Proc. 20th ACM Int. Conf. Information
and Knowledge Management, ser. CIKM ’11.
New York, NY,
USA: ACM, 2011, pp. 1765–1774, ISBN 978-1-4503-0717-8, doi:
10.1145/2063576.2063832.
[31]
S. Harris, A. Seaborne, and E. Prudhommeaux. (2013) Sparql 1.1 query
language. [Online]. Available: https://www.w3.org/TR/sparql11-query/
2018.04.03
[32]
J. Webber, “A programmatic introduction to Neo4J,” in Proc. of
the 3rd Annual Conference on Systems, Programming, and Appli-
cations: Software for Humanity, ser. SPLASH ’12.
New York,
NY, USA: ACM, 2012, pp. 217–218, ISBN 978-1-4503-1563-0, doi:
10.1145/2384716.2384777.
[33]
Neo
Technology.
openCypher
project.
[Online].
Available:
http://www.opencypher.org 2018.04.03
[34]
R. M. Martins et al., “Multidimensional projections for visual anal-
ysis of social networks,” Journal of Computer Science and Technol-
ogy, vol. 27, no. 4, pp. 791–810, Jul 2012, ISSN 1860-4749, doi:
10.1007/s11390-012-1265-5.
[35]
B. Gallagher, “Matching structure and semantics: A survey on graph-
based pattern matching,” AAAI Fall Symp. Capturing and Using
Patterns for Evidence Detection, vol. 6, pp. 45–53, 2006.
[36]
F. K. Hwang, D. S. Richards, and P. Winter, “Introduction,” in The
Steiner Tree Problem, ser. Annals of Discrete Mathematics.
Else-
vier, 1992, vol. 53, pp. 3–19, ISSN 0167-5060, doi: 10.1016/S0167-
5060(08)70192-4.
[37]
M. R. Garey, R. L. Graham, and D. S. Johnson, “The complexity of
computing Steiner minimal trees,” SIAM J. Appl. Math., vol. 32, no. 4,
pp. 835–859, 1977, ISSN 0036-1399, doi: 10.1137/0132072.
[38]
AIDA
Collaboration.
AIDA
-
website.
[Online].
Available:
http://aida2020.web.cern.ch/content/aida 2018.04.03
[39]
Clarivate
Analytics.
Web
of
ScienceTM.
[Online].
Available:
http://webofknowledge.com 2018.04.03
[40]
European Patent Ofﬁce. PATSTAT - worldwide patent statistical
database.
[Online].
Available:
http://www.epo.org/searching-for-
patents/business/patstat.html 2018.04.03
[41]
Neo4j, The Neo4j manual, November 2015, Release 2.3.2. [Online].
Available: http://neo4j.com/docs/stable/index.html 2018.04.03
[42]
LuceneTM/SolrTM
Committers, Apache LuceneTM
Documentation.
[Online]. Available: https://lucene.apache.org/core/documentation.html
2018.04.03
[43]
European
Commision.
NUTS
-
Nomenclature
of
territorial
units
for
statistics.
[Online].
Available:
http://ec.europa.eu/eurostat/web/nuts/overview 2018.04.03
[44]
Collspotting Developerment Team. Collspotting. [Online]. Available:
http://collspotting.web.cern.ch 2018.04.03
[45]
HEPTech Collaboration. HEPTech - website. [Online]. Available:
http://heptech.web.cern.ch 2018.04.03
[46]
E. Leonardi, A. Agocs, S. Fragkiskos, N. Kasﬁkis, J. Le Goff,
M. Cristalli, V. Luzzi, and A. Polimeni, “Collaboration spotting for
dental science,” Minerva Stomatologica, vol. 63, no. 9, pp. 295–306,
Sep 2014.
[47]
M. Cattaneo, M. Clemencic, and I. Shapoval, “LHCb software and
conditions database cross-compatibility tracking system: A graph-theory
approach,” in 2012 IEEE Nuclear Science Symp. and Medical Imaging
Conf. Record (NSS/MIC), Oct 2012, pp. 990–996, ISSN 1082-3654,
doi: 10.1109/NSSMIC.2012.6551255.
[48]
I. Shapoval, M. Clemencic, and M. Cattaneo, “ARIADNE: a tracking
system for relationships in LHCb metadata,” J. Phys. Conf. Ser., vol.
513, no. 4, pp. 1:1–1:7, 2014, 042039.
63
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

