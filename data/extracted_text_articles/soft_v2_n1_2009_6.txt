63
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
A Underlay System for Enhancing Dynamicity within Web Mashups
Heiko Pfeffer
Technische Universit¨at Berlin
Franklinstr. 28/29, 10587 Berlin, Germany
heiko.pfeffer@tu-berlin.de
Abstract
Rich Internet Applications (RIA) and composed Web ap-
plications, referred to as Mashups, have become the new
generation of Web based applications, aggregating multi-
media data such as audio, video and images from multiple
providers and combining them to more powerful and value-
added applications. In the same time, mobile devices such
as smartphones or PDAs are increasingly used to access
the Web and Web based applications. Therefore, Web de-
velopers nowadays face a huge client heterogeneity, where
devices differ in their computing capabilities, screen size,
available bandwidth, and mobility pattern.
This paper introduces a service composition model that
can underlie modern Web applications and can be executed
within a respective runtime at every browser-enabled client.
This model allows software develops to create applications
by abstracting from concrete services and APIs, which are
incorporated dynamically during runtime. Thus, the result-
ing Underlay System for Web Mashups overcomes device
heterogeneity by providing means to execute the applica-
tion logic in a uniﬁed runtime while integrating the concrete
service implementations based on the current context of the
user and the respective client device.
Keywords: Service Composition, Mashups, Composed Web
Applications, Workﬂows, Timed Automata, Realtime
1
Introduction
In 2003, Macromedia coined the term of Rich Internet
Applications (RIA), describing a new breed of upcoming
Web applications that combines the best of desktop soft-
ware, the Web, and advanced communication technologies
[11]. Here, the aim is to build highly interactive Web ap-
plications that feature a broad spectrum of data such as au-
dio, video, images and text in order to enhance the expe-
rience of the user. Lawton later introduced an update on
the deﬁnition of RIA, highlighting the importance of the
usage of Web technologies [18]. At the same time, com-
posed Web applications, i.e. applications that were built
by the incorporation of content from multiple 3rd party ser-
vice providers, referred to as Mashups, gained importance.
On ProgrammableWeb.com [1], 1318 open APIs and 3985
Mashups were registered in May 2009. The most promi-
nent motives for offering data to communities of users and
software developers are the generation of new ideas by inde-
pendent developers, the search for new revenue streams and
the opportunity to draw trafﬁc to the providers’ sites and
remain or become a dominant player in the Web. Through
publicly available APIs the community often develops new
features without assistance from the providers, posing the
possibility of vertical integration for the providers.
However, the development of such Web Mashups as a
composition of 3rd party services is aggravated by differing
interface descriptions of 3rd party services and their varying
return types that considerably reduce the amount of reusable
code and forestall an easy swapping of services with simi-
lar functionality. Thus, today’s composed Web applications
remain tailor-made for speciﬁc purposes.
Other domains have already faced similar challenges
and responded with respective mechanisms. For instance,
architecting distributed applications in open systems with
SOA-based software patterns has proven as good practice
to achieve robustness and extensibility.
Inter-component
dependencies are loosened to on-demand selection and
purpose-driven interaction at runtime, service consuming
and service providing entities stay autonomic; this central
concept is often referred to as late binding of services.
However, SOA based applications incorporate a huge
protocol stack and are thus a bad ﬁt for modern Web appli-
cations based on the REST architectural style [13]. More-
over, SOAs are tailor-made to support large-scale business
processes where end-users are not the center of attention as
opposed to Web Mashups. Business processes completely
lack a presentation layer to display results of computations
and to interact with the user. Moreover, they do not pro-
vide suitable means to remain responsive to user prefer-
ences or context or to support a broad device heterogeneity,

64
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
i.e. mobile users accessing Web applications through small
portable devices with restricted computing capabilities.
Within the remainder of this work, a Underlay System
for Web Mashups is introduced that considerably reduces
the problems entailed by a high device heterogeneity by
incorporating services based on the current context during
runtime. Here, section 2 ﬁrst gives a general introduction to
composed applications, highlighting results from the world
of SOA and the Web, respectively. The conceptual part of
section 3 discusses the Underlay System itself and builds
upon results given in [29], while section 4 highlights an ar-
chitecture for realizing the proposed approach.
2
State of the Art and Related Work
This section gives a short introduction to the most im-
portant concepts relevant within the scope of this work and
relates it to similar approaches. While subsection 2.1 fo-
cuses on the concept of service composition and workﬂow
languages, subsection 2.2 deals with a respective ground-
ing to the Web architecture, discussing Mashups as a poster
child for composed Web applications.
2.1
Service Composition
Service Oriented Architecture (SOA) and Web Services
have successfully addressed the problem of Service Com-
position for business processes by introducing appropriate
composition languages [5], enabling the controlled execu-
tion of multiple accumulated Web Services. However, those
technologies such as UDDI and SOAP strictly rely on ﬁx in-
frastructures for service discovery and provisioning. First
steps towards perpetuating the success of SOA and Web
Services to mobile networks have been achieved by provid-
ing service frameworks for accessing Web Services from
mobile devices such as PDAs and Smartphones [23]. A
static service infrastructure for service discovery and provi-
sioning is nevertheless still indispensable. Successful Ser-
vice Composition methods remain tailor-made for business
processes [17].
Within the world of SOA and Web Services, various
models for service composition are present. The currently
most prominent one is BPEL4WS [3, 8], a combination of
IBM’s graph-based Web Service Flow Language (WSFL)
[19] and Microsoft’s block-oriented XLANG [30]. Beside,
many other composition languages exist, wherefrom none
has made the breakthrough to an holistically accepted stan-
dard for Web Service Composition [33]. In order to pro-
vide more dynamic service composition approaches fea-
turing a functional-based service discovery and binding,
some approaches have replaced the Web Service Descrip-
tion Language (WSDL) [6] by semantic service descrip-
tions such as OWL-S [31]. Especially for mobile devices,
more lightweight descriptions have been proposed in order
to reduce the computation complexity entailed by semantic
reasoning processes [27].
However, dynamic service composition faces the difﬁ-
culty that new semantic service descriptions have to be gen-
erated that can be used for future service discovery and
binding. The approach introduced in this paper therefore
aims at extending the ﬂexibility of service compositions
achieved trough late binding mechanisms to the structure
of service composition plans. This proceeding entails the
generation of multiple equivalent or similar service compo-
sitions with regard to their functionality, which may how-
ever differ in their non-functional properties.
2.2
Mashups - Composed Web Applica-
tions
Mashups are composed Web applications integrating
data from multiple 3rd party providers to provide a value-
added functionality and experience to the user.
Within
this section, we ﬁrst outline the three basic roles within
Mashup based Web applications and then discuss two dif-
ferent Mashups styles that denote possible ways to realize
them, building upon [21] and [22] mainly.
2.2.1
Mashup Roles
In general, Mashups architectures feature three elementary
roles as illustrated in Figure 1. The Content Provider is a
source of data that can be accessed through open APIs over
various Web protocols such as REST, RSS or SOAP. The
Mashup Site is the new build Web application that requests
content and services from various data sources and com-
bines them in order to provide a value-added application
to the user. The Client is the interface to the user (pre-
sented within a Web-browser). The user can interact with
the Mashup through client-side scripting languages such as
JavaScript.
Within the following section, we will ﬁrst focus on the
role of content providers, introducing famous and success-
ful services that are exposed through open APIs. Here, spe-
cial emphasis will be put on the way they expose their APIs,
the types of data they return and how their integration can
characterize the resulting Mashup. Thereafter, we will dis-
cuss basic styles of Mashups, highlighting the different re-
sponsibilities of clients and Mashup sites within the respec-
tive approaches.
2.2.2
Mashup Styles
In general, it is distinguished between two basic styles for
creating and executing Mashups, entailing different respon-
sibilities of the client and the Mashup site in order to exe-
cute the actual Mashup. Both styles expose serious advan-
2

65
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
Client
Mashup Site
Content 
Providers
Figure 1. General Roles of a Mashup Web Ap-
plication.
tages and disadvantages with regard to their performance,
load distribution and security, and thus have to be pondered
against each other carefully with regard to the requirements
of the respective Mashup application.
Server-side Mashups
Within server-side Mashups, ser-
vices and content are integrated at a server, which plays the
role of a proxy between the Web application on the client
and other Web sites that are integrated into the Mashup.
Every request or event originating from the client is for-
warded to this proxy server, which then makes the calls on
the respective Web sites. Because of this central server role
acting as a proxy, server-side Mashups are often referred to
as Proxy Mashups. Figure 2 shows the general setting of a
server-side Mashup.
Whenever a user generates an event at the client Web
browser, e.g. pushes a button or clicks on a map, the event
triggers a JavaScript function (#1). This Java Script func-
tion makes a HTTP request to the Mashup site (#2). Com-
monly, this request is an Ajax request; it will later be dis-
cussed in greater detail. The request is received by a Web
component such as a Servlet or Java Server Page (JSP) on
the Mashup site. Based on the received request, the com-
ponent calls one or multiple methods within a class or mul-
tiple classes containing the application logic to make calls
on 3rd party APIs (#3). Because of their role of acting as
a proxy between the client’s request and the request to the
actual Mashup servers, these classes are often referred to as
Proxy Classes. Note that proxy classes are not restricted in
the way they are realized, thus, they can be implemented as
plain Java classes or large-scale J2EE components. Thus,
the Proxy classes connect to the addressed Mashup servers
and request the respective services (#4). In turn, the Mashup
servers process the request and respond with the resulting
data (#5). The proxy classes receive the response and can
process the data before forwarding it to the Web component
(#6). This option of processing data on the server side en-
ables most of the advantages of a server-side Mashups. For
instance, data can be transformed in a format such as JSON
that is easier to process by the client, it can integrate differ-
ent data sources and only send the integrated piece of data
to the client, or data can be buffered or cached in order to in-
crease the performance of succeeding requests. Finally, the
Web component sends the response to the client (#7). Here,
the view of the page at the client side is updated according
to the response. In case the initial request has been an Ajax
request in form of an XMLHttpRequest object, this page up-
date is achieved by the callback function within the XML-
HttpRequest that manipulates the Document Object Model
(DOM) accordingly.
Client-side Mashups
Within client-side Mashups, the in-
tegration of the single services and data sources is per-
formed at the client instead of using an additional proxy
server. Thus, clients connect directly to 3rd party APIs in
order to request services; a client-side Mashup is abstractly
depicted in Figure 3.
Application 
Logic
(JavaScript)
Client
Mashup Site
Content Provider
Web Server
(Web 
Component)
Mashup 
Application
(Proxy Classes)
Database
User Interface
Web Server
#3
JS Call
#6
Site Update
#1
Request
#2
Response
#3
#6
#4
Request
#5
Response
Figure 3. Client-side Mashup.
Initially, the client’s browser makes a request to the
Mashup site (#1), initiating the server to load the requested
Web page into the client (#2). This Web page provides ac-
cess to JavaScript libraries that enable the client later to di-
rectly call services at 3rd party APIs without addressing the
Mashup site beforehand. There are three common ways
to provide access to JavaScript libraries.
First, the Web
3

66
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
Application 
Logic
(JavaScript & 
XMLHttpRequest)
Client
Mashup Site
Content Provider
Web Server
(Web 
Component)
Mashup 
Application
(Proxy Classes)
Database
User Interface
Web Server
#1
JS Call
#8
Site Update
#2
Request
#7
Response
#3
#6
#4
Request
#5
Response
Figure 2. Server-side Mashup.
page may reference the JavaScript library from the respec-
tive 3rd party service provider such as Google Maps; here,
it is sufﬁcient to reference the library by a valid URL. In
case the 3rd party provider does not expose an appropriate
JavaScript library, the Mashup developer can provide one
on his own and make it available on the Mashup site. Al-
ternatively, other 3rd party libraries may be referenced to
ease the Mashup’s creation. Speciﬁc actions on the Web
page trigger the browser to call a function in the JavaScript
library integrated within the Web page. This function dy-
namically creates a <script> tag in the Web site that points
to the according 3rd party server (#3). Afterwards, the client
initiates an HTTP request based on the ¡script¿ tag includ-
ing the desired format of the response (#4). As discussed
above, the format of the response provided by a service can
commonly vary, ranging from XML to YAML or JSON. For
client-side Mashups, JSONP (JSON with Padding) is the
most common response format since it can be easily evalu-
ated (by the JavaScript function eval()) at the client. JSONP
extends JSON by the capability of appending the name of
a local callback function to the JSON object. Thus, in case
the server provides the response in JSONP, a call is made
on the callback function with the JSON object as parameter
(#6). Finally, the DOM of the page is manipulated by the
JavaScript function and the page is updated accordingly.
3
Underlay System for Web Mashups
Within this section, a Underlay System for Web Mashups
is speciﬁed by introducing a service composition model that
can describe and execute composed Web applications, i.e.
Mashups, and is -in the same time- responsive to the envi-
ronmental user context. Special emphasis is put on over-
coming the high degree of device heterogeneity we face in
today’s Web.
3.1
Distinguishing Mashups and Business
Processes
Business processes and Web Mashups both constitute
composed applications. However, they are created with dif-
ferent requirements. While business processes are tailor-
made to describe large-scale business transactions among
multiple enterprises, Mashups are rapidly created Web ap-
plications for end-users aiming at a high degree of interac-
tivity and graphical presentation, where content from 3rd
party providers is combined to add value to the created Web
application.
The fact that Mashups are built on top of the Web proto-
col stack while business processes are designed for SOAs is
also reﬂected in the underlying technologies for remote ser-
vice invocation and service interworking as shown in Table
1.
Moreover, Table 1 outlines the focus of both technolo-
gies. Business processes are deﬁned by service composition
languages such as BPEL and provide late binding mech-
anisms for services that are described by languages such
as WSDL and stored in repositories where they can be ac-
cessed via UDDI. Thereby, enterprises can modify the im-
plementations of their single services (e.g. upgrade them
to a new version) without any need to notify service con-
sumers of their changes since the services are incorporated
by their descriptions only and thereby decoupled from the
actual service implementation. Mashups on the contrary do
not provide any kind of controlled service execution or late
binding of services. Instead, Web developers directly in-
tegrate the concrete APIs of 3rd party providers into their
4

67
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
Feature
Business Processes (SOA)
Web (Mashups)
Remote Invocation
WebServices (WSA), XML-RPC
XMLHttpRequest (Ajax), JSON RPC,
COMET
Service Interworking
.NET, J2EE
EcmaScript (Java Script)
Service Composition
Yes
No
Composition Languages
BPEL4WS, WSFL, WSCDL
Composition Execution Engines
Bexee, Oracle BPEL Process Manager,
IBM WBISF
Late Binding
Yes
No
Service Description Languages
WSDL, WSDL-S, OWL-S
Service Discovery
UDDI
Interaction
No
Yes
Presentation
HTML, CSS, XML, Streamed audio and
video
User Input
HTML
Forms,
XForms,
JS
Key-
board/Mouse Event Models
Table 1. Business Processes vs. Mashups
Mashups. In return, Mashups provide a connection to the
user by default: Web applications are build by a Web page
that consists of HTML, CSS and Java Script and therefore
possess a presentation and means to interact with the user
by nature. Application logic is only invoked when an event
is created by the user that triggers a certain functionality.
The following can be concluded: While business pro-
cesses enable software developers to create the application
logic of a process without dealing with its graphical presen-
tation and possible user interaction, Mashups are created as
interactive graphic presentations that react on user input and
thereby invoke small parts of application logic that modiﬁes
the presentation of the application.
3.2
Requirements for a Mashup Underlay
System
The objective of this work is to incorporate the ability
of SOA business processes to structure the underlying ap-
plication logic as a service composition and to dynamically
incorporate services or APIs through late binding mecha-
nisms in order to overcome the device heterogeneity of to-
day’ Web Mashups. Moreover, this techniques allow for a
more dynamic adaptation of Mashups to the users’ needs
and their environmental context by providing means to in-
clude services based on the users’ preferences, on the client
device and its respective capabilities, and the current per-
formance of the single services.
Given these requirements, the following components
are identiﬁed as central for the Underlay System for Web
Mashups:
• Workﬂow - A workﬂow graph enables software de-
velopers to specify the execution order of the single
services and APIs.
• Dataﬂow - A dataﬂow graph allows developers to con-
nect data retrieved as output of one service to the inputs
of other services.
• Abstract Service Access - An abstraction layer for
services and APIs deﬁnes a uniﬁed way to access ser-
vices providing the same resource, i.e. the same object
on the presentation and interaction layer. Thus, this
layer allows developers to conceptually include a map
within their Mashups without specifying the concrete
service that is creating this presentation. This proce-
dure does not only free the software developer from
programming against multiple APIs, but also allows
for a dynamic exchange of the bound services or APIs
in case the context of the user changes.
• Context Awareness - The Underlay System provides
an interface to develop selection mechanisms in case
multiple services are available for the same presenta-
tion. For instance, in case both Google Maps and Ya-
hoo Maps are identiﬁed to be capable of presenting a
map to the user, the selection can be made dependent
on user preferences or context.
• Time Awareness - To overcome device heterogeneity,
time is identiﬁed as critical context information that
can trigger the evaluation of the appropriateness of in-
tegrated services. For instance, in case the processing
of a service exceeds a predeﬁned time limit, it can be
concluded that the processing power of the device is
too low and that the service should be replaced. The
same technique can be applied to identify services that
5

68
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
are causing too much trafﬁc given the available band-
width. For instance, one could deﬁne that in case the
response time of a service exceeds a certain time span,
the trafﬁc has to be too high for the currently available
bandwidth such that the service has to be replaced with
a less demanding one.
Within the next subsections, a service composition
model is developed on a theoretical level that builds the
core of the Underlay System for Web Mashups and can be
executed within a respective runtime both on servers and
browser-enabled clients. More insights on the related real-
ization of the Underlay System is given later in section 4.
3.3
Modeling Service Compositions
This section deals with the representation and execu-
tion control of service compositions. Therefore, subsection
3.3.1 deﬁnes a service model assumed for the software com-
ponents serving as basis for service compositions provides a
general overview of the two main representation paradigms
chosen for service compositions. The graph-based repre-
sentation of the workﬂow and the dataﬂow within those
compositions is then discussed in subsections 3.3.2 and
3.3.3, respectively. Finally, the interworking of both graphs
is exemplarily outlined in subsection 3.3.4.
3.3.1
Service Model and Basic Concepts
Services themselves are considered as atomically exe-
cutable parts of application logic, whereby the execution
of the service is independent from outer computations and
data structures. This assumption is in-line with the REST
architectural style of the Web, where services are deﬁned
as stateless. We rely on IOPE descriptions characterizing
a service functionality by its inputs, outputs, preconditions
and effects as discussed by Jaeger et al. [16]. Inputs and
outputs of a service are distinguishable by a unique identi-
ﬁer referred to as a port. Since it is aim at introducing a
representation of service composition plans that is indepen-
dent from the service descriptions they rely on, possible se-
mantically enhanced description of preconditions or effects
are not speciﬁed. Instead, we assume effect to be present
or not, thus, we identify every effect with a boolean indi-
cating whether the effect has already been generated or not.
Preconditions can then be pondered against those boolean
representations of service effects.
To represent service compositions properly as well as to
control their execution, a bipartite graph concept based on
a workﬂow graph controlling the execution of the single
components within a service composition and a dataﬂow
graph deﬁning the passage of data between services’ out-
put and input ports is introduced. Each transition of the
workﬂow graph corresponds to a service containing I/O pa-
rameters and a set of effects it generates during execution as
described above.
In case a services precondition is met, the service can be
executed, thus, an action representing the service function-
ality is performed, which consumes the service’s input and
generates a ﬁnite set of effects and a ﬁnite set of outputs.
Transitions between locations are optionally annotated with
guards, which restrict the passage of the transition by re-
quiring the satisfaction of speciﬁc preconditions or previ-
ously generated outputs. Notably, the output of a service is
not necessarily required as input for a service reached by the
next transition within the workﬂow graph; instead, an out-
put may also become relevant after multiple other services
have been executed. Therefore, a second graph is deﬁned,
specifying the dataﬂow within a service composition. This
dataﬂow graph shares the set of locations with the workﬂow
graph, but represents the ﬂow of outputs from one service
component to the input of another with its transitions. A
guard for passing a transition within a workﬂow graph that
would lead to the execution of the next service can thus de-
pend on the presence of a set of effects (expressed through
preconditions) and on the availability of all inputs that have
to be created as outputs of other services before. Notably,
the dataﬂow graph is not necessarily completely connected,
thus may be a set of graphs.
In the following section, the workﬂow graph of a service
composition is formally deﬁned, specifying its guard based
transition behavior and its time awareness.
3.3.2
Workﬂow Graph
The workﬂow graph is supposed to control the execution or-
der of single services within a service composition. Based
on the requirements identiﬁed in subsection 3.2, automata
theory is proposed as the mathematical basis for service
composition representation. In [24], a transformation from
UML state machines [10] to timed automata has already
proven that automaton theory can be easily accessed by
user-friendly modeling languages such as UML, enabling
the feasibility of the presented approach. Coevally, automa-
ton theory already provides rapid modiﬁcations of the au-
tomaton structure by simple operations, because automata
are represented as basic digraphs. In order to provide re-
altime consideration within service compositions, the def-
inition of workﬂow graphs borrows from timed automata.
Timed automata [2, 9] are ﬁnite automata [4, 12] extended
by a set of real-time valued clocks. In the following, we
will refer to the deﬁnition provided by Clarke et al. in [7].
Let X be a ﬁnite set of real-valued variables standing for
clocks. Clock constraints are then deﬁned as follows.
Deﬁnition 3.1 (Clock Constraints) A clock constraint is a
conjunctive formula of atomic constraints of the form x ∗ n
6

69
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
or x − y ∗ n for x, y ∈ X, ∗ ∈ {≤, <, =, >, ≥} and n ∈ N.
C(X) denotes the set of clock constraints. If ϕ1 is in C(X),
then ϕ1 ∧ ϕ2 is also in C(X).
A Timed Automaton is then deﬁned as follows.
Deﬁnition 3.2 (Timed Automaton) A timed automaton A
is a 6-tuple {Σ, S, s0, X, I, T}, where
1. Σ is a ﬁnite alphabet (standing for actions),
2. S is a ﬁnite set of locations,
3. s0 ∈ S are the initial locations (also called starting
locations),
4. X is a set of clocks,
5. I : S →C(X) assigns invariants to locations, i.e., pro-
vides a mapping from locations to clock constraints,
and
6. T ⊆ S× C(X) × Σ × 2X × S is the set of transitions.
Abbreviatory, we will write s
g,a,λ
→ s′ for ⟨s, g, α, λ, s′⟩, i.e.
the transition leading from location s to s′. The transition is
restricted by the constraint g (often called guard); λ ⊆ X
denotes the set of clocks that is reset during the transition
passage.
Notably, many model checker such as UPPAAL [32], op-
erating on timed automata restrict the location invariants to
downwards closed ones, i.e. do only allow invariants of the
form x ≤ n or x < n for n ∈ N.
Inﬁnite state transition systems (sometimes called inﬁ-
nite state transition graphs) are used as model for a timed
automaton A. Deep introductions into the notion of tran-
sition systems can be found in [15, 20]. Here, the deﬁ-
nition of Clarke et al. [7] will be followed again, speci-
fying an inﬁnite state transition system T (A) for a given
timed automaton A as a 4-tuple T (A) = {Σ, Q, Q0, R}.
A state q ∈ Q of this transition system is deﬁned as a
pair (s, v), where s ∈ S is a location and v : x → R+
is a clock assignment. The initial states are identiﬁed by
all initial locations, where all clocks are set to zero, i.e.
Q0 = {(s, v)|s ∈ S0 ∧ ∀x ∈ X [v(x) = 0]}.
The deﬁnition of the state transition relation is implied
by the following two needs. First, a notion is required to re-
set a clock to zero, i.e., for λ ∈ X, we deﬁne v[λ := 0] for
mapping all clocks in λ to zero. For d ∈ R, we deﬁne v + d
as a clock assignment that maps the current value of v to
v(x) + d for all clocks x ∈ X. Based on this, two different
types of transitions are deﬁned, covering the passage of time
and the triggering of actions. Time can pass while the sys-
tem is in a speciﬁc location as long as the according state in-
variant is not violated. This elapsing of time is referred to as
delayed transition, speciﬁed as (s, v)
d→ (s, v+d), d ∈ R+,
subjected to the condition that the invariant I(s) is not vi-
olated for every v + e, 0 ≤ e ≤ d. The second type of
transitions describes the actual execution of an action and is
thus referred to as action transition. If there is a transition
⟨s, α, g, λ, s′⟩ where v satisﬁes g and v′ = v[λ := 0], we
note (s, v)
α→ (s′, v′) for a transition with α ∈ Σ. To-
gether, we receive the transition relation R for T (A) as
(s, v)R(s′, v′) (also written as (s, v)
α⇒ (s′, v′)), if there
are s′′ and v′′ so that (s, v)
d→ (s′′, v′′)
α→ (s′, v′) for some
d ∈ R. Thus, an action α can also be performed without
elapsing time, i.e. in case d = 0. Moreover α may also
stand for the empty action τ ∈ Σ, i.e. a transition can also
be passed without entailing the execution of an speciﬁc ac-
tion.
Since actions are supposed to model the behaviour of a
service, the execution of an action α is mapped to the con-
sumption of inputs, the creation of outputs and the gener-
ations of effects. Inputs and outputs are regarded as typed
variables bounded to speciﬁc ports, enabling the deﬁnition
of I/O passage by means of a dataﬂow graph. The domains
of variables thus constitute their primitive data type.
The Workﬂow Graphs Θ are now modeled as timed au-
tomata as deﬁned in Deﬁnition 3.2, extended by the ability
of actions α ∈ Σ to operate on typed variables and effects.
Typed variables are deﬁned as 2-tuples (x, Γ (x)), where x
is a variable and Γ (x) its respective domain. For now, only
variables x with x ∈ R ⊂ R are considered. Let V be a
ﬁnite set of typed variables. Regarding the handling of ef-
fects, we deﬁne E as a ﬁnal set of variables γ∗ ∈ {0, 1}
indicating whether an effect γ has been created (γ∗ set to 1)
or not (γ∗ set to 0). We assume that V contains at least all
variables of E, thus, E⊆V.
Deﬁnition 3.3 (Guard Constraints) A
real-value
con-
straint is a propositional logic formula x ∗ n, where x ∈ V
is a typed variable, n ∈ R and ∗ ∈ {<, ≤, ≥, >, ==}.
C(R\V) denotes the set of real-value constraints containing
only variables of V.
If ϕ1 and ϕ2 are in C(R\V), ϕ1 ∧ ϕ2, ϕ1 ∨ ϕ2 and ¬ϕ1
are also in C(R\V).
Let ϕc ∈ C(X) be a clock constraint as deﬁned in Deﬁ-
nition 3.1, ϕr a real-value constraint.
A guard constraint is a formula ϕ = ϕc|ϕr|ϕc∧ϕr eval-
uating to a Boolean. C(X ◦ R\V) denotes the set of all
guard constraints.
The workﬂow graph is now deﬁned as a timed automaton
whose actions and guards can also operate on typed vari-
ables.
Deﬁnition 3.4 (Workﬂow Graph) A workﬂow graph Θ is
a timed automaton as deﬁned in Deﬁnition 3.2, where
7

70
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
1. Σ is a ﬁnite alphabet. The alphabet represents the ac-
tions which are identiﬁed by the single services within
the service composition.
2. S is a ﬁnite set of locations deﬁning the service com-
positions’s current state,
3. s0 ∈ S are the initial locations deﬁning the initial state
of the service composition,
4. X is a set of clocks,
5. I : S → C(X) assigns invariants to locations, restrict-
ing the system in the amount of time it is allowed to
remain in the current state, and
6. T ⊆ S× C(X ◦R\V) ×Σ×2X ×S is the set of transi-
tions, denoting the execution of a service (represented
by an action α). The passage of a transition (and thus
the execution of a service) thereby depends on whether
the according guard is met.
In order to decide whether an output of a service com-
ponent is required as an input for another one, a dataﬂow
graph is introduced in the following section.
3.3.3
Dataﬂow Graph
Dataﬂow graphs represent the connections of output and in-
put ports. They keep the same locations as the workﬂow
graph introduced in Deﬁnition 3.4 and use labeled transi-
tions to express inter-component data passing.
Deﬁnition 3.5 (Dataﬂow Graph Ω) A dataﬂow graph Ω is
a labeled directed digraph Ω = {N, P, E}, where,
1. N is a ﬁnal set of labeled nodes, which is equivalent to
the set of locations S held in the according workﬂow
graph Θ,
2. P is a set of port mappings represented by 2-tuples
p = (p1, p2) indicating the passage of the output from
port p1 to the input port p2, and
3. E ⊆ N × P × N is a ﬁnal set of labeled directed
transitions.
Each location represents the data generated by the execu-
tion of action αi; we therefore label a node with d(αi) in-
dicating the output data from action αi. If a transition is
passed within a workﬂow graph Θ entailing the execution
of action αi, all outgoing transitions from location d(αi)
within the according dataﬂow graph Ω are passed. A tran-
sition passage d(αi)
(pm,pn)
→
d(αj) within Ω effectuates that
the output at port pm from action αi is redirected to input
port pn of action αj in case action αi is executed within Θ.
A service composition is speciﬁed by its workﬂow and
dataﬂow graph, i.e., is deﬁned as a 2-tuple ⟨Θ, Ω⟩.
The following section discusses a small example for ser-
vice composition representation and control.
3.3.4
Workﬂow and Dataﬂow Graph Interworking
The service composition to be represented is abstractly de-
picted in Figure 4.
Figure 4. A Possible Service Composition.
The involved service components are represented by
rectangles labeled with an action αi describing their func-
tionality. The order of execution, i.e., the workﬂow, is de-
picted by bold arrows while the passage of inputs and out-
puts is indicated by dashed arrows. They connect the output
ports of service components with input port of other com-
ponents that are drawn as numbered squares.
The example service composition contains ﬁve service
components (labeled with α1, ..., α5).
After α1 has been started, either α2 or α3 and α4 are
executed. In case both execution paths are enabled, i.e. all
premises in terms of I/O and effect availability are met, a
path is chosen nondeterministically according to the notion
of transition systems.
While service executions in common service composi-
tion representations such as in Figure 4 are represented as
nodes within graphs, the one introduced in this paper mod-
els service executions as actions performed during transi-
tions between locations. The workﬂow graph deduced from
the example service composition is illustrated in Figure 5
(a).
Guards restricting the transition from a location s to a
location s′ operate on the generated effects (through pre-
8

71
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
conditions) and a ﬁnal set of inputs and outputs. Outputs
are not stored but redirected to input ports by means of the
according dataﬂow graph. The dataﬂow graph depicted in
Figure 5 (b) is supposed to belong to the workﬂow graph
illustrated in Figure 5 (a).
For instance, the execution of
Figure 5. (a) An according workﬂow graph.
(b) A dataﬂow graph representing the I/O
Passing.
α1 implies the redirection of the output from the ﬁrst output
port of α1 to the second input port of α2 and the ﬁrst input
port of α3. Moreover, the output from the second output
port of α1 is forwarded to the second input port of α3 and
to the second input port of α5.
3.3.5
Enabling Parallel Execution
Because of their relation to automata and their given tran-
sition relation introduced in section 3.3.2, workﬂow graphs
already support a wide set of control structures required to
guide the execution order of services; the three most im-
portant ones are abstractly depicted in Figure 6.
First,
Figure 6. Basic control structures of au-
tomata semantics. (a) Nondeterministic Se-
lection. (b) Choice. (c) Looping.
nondeterministic decisions between multiple possible ser-
vice invocations are modeled with a ﬁnite set of outgo-
ing transitions labeled with the same guard g. In case the
guard is met, all transitions are enabled and the transition
relation discussed in section 3.3.2 selects a transition non-
deterministically. Decisions such as if-else or switch state-
ments are represented by multiple outgoing transitions la-
beled with different guards g1, ..., gk. Here, deadlocks can
occur in case all guards are evaluated as false under a given
set of constraints. Moreover, multiple guards may be true,
entailing a non-deterministic decision making between the
enabled transitions. Last, looping can be modeled with tran-
sitions pointing back to the origin state as depicted in Figure
6 (c).
However, workﬂow graphs do not provide all means to
model parallel execution of services. By passing a transi-
tion, the according service is executed. Note that the in-
troduced model does not assume that the workﬂow graph
remains in the location reached by the transition passage
until the service’s execution is ﬁnished. Instead, the next
transition is directly passed (in case at least one transi-
tion’s guards are met), entailing the execution of the next
service. Thereby, service execution becomes parallel. If
both services have been started on the same device, the lo-
cal scheduling algorithm ensures their pseudo-parallel ex-
ecution. In case they are executed on different nodes and
therefore multiple processors, they are running in parallel.
However, this approach fails in case the biggest subset of a
given set of services should be executed in parallel.
Assume two services α1 and α2 are selected for paral-
lel execution. In case the services are initiated in the order
9

72
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
α1 → α2, it may be possible that α1 cannot be started since
an input is missing. The blocking of the transition would
entail that also service α2 is not started, although its guard
may be met. Therefore, a control structure for parallel exe-
cution of services is required. The left-hand side of Figure
7 depicts an abstract workﬂow reﬂecting the previously de-
scribed situation of two services α1 and α2 that should be
executed in parallel.
l0
l3
l1
g0 : α0
l2
g1 : α1
g2 : α2
l4
g4 : α4
g3 : α3
α0
α1
α3
α2
α4
Figure 7. Timed automaton structure ensur-
ing parallel execution.
The right-hand side of the same Figure depicts the timed
automaton that corresponds to the abstract service composi-
tion. Here, the execution of α2 would be forestalled in case
guard g1 is not met although g2 may be fulﬁlled. In order
to unblock this behavior, an additional idle state is automat-
ically inserted during the generation of the workﬂow graph
that is entered after every execution of a service that may
be executed in parallel to other services. The accordingly
modiﬁed workﬂow graph is illustrated in Figure 8.
Because of this modiﬁcation, the timed automaton
moves into the idle state as soon as the guard of the next ser-
vice is not met, such that the invocation of another service
can be initiated whose guards is fulﬁlled. The utilization
of semaphores ensures that every service is only executed
once.
Thus, by inserting a special control structure that can
be generated for a given ﬁnite set of services, workﬂow
graphs possess the same expressiveness as other workﬂow
languages such as BPEL, while relying on sound formal
Idle
g2
g2
g3
g3
g1
g1
l0
l3
l1
g0 : α0
l2
g1 : α1
g2 : α2
l4
g4 : α4
g3 : α3
Figure 8. Timed automaton structure ensur-
ing parallel execution.
model featuring realtime consideration and ﬂexibility.
4
An Architecture featuring a Underlay Sys-
tem for Web Mashups
Within this section, the previously introduced formal
method for the representation of workﬂow-based service
compositions within a Underlay System for Web Mashups
is realized as an architecture enabling the utilization of
workﬂows for the representation of Web applications and
features the late binding of 3rd party APIs. This architec-
ture is implemented according to the REST architectural
style, the architectural style of the Web, that was proposed
by Fielding within his PhD thesis and is known for its re-
lated realization within the Web, HTTP [13].
Figure 9 gives an high-level overview of the proposed
architecture.
Here, the Mashup site, i.e. the Mashup proxy, is ex-
tended by 4 key components. First, a workﬂow engine for
the previously introduced model based on timed automata
enables the structured execution of service compositions. In
addition to version for servers written in Java, the runtime is
also implemented in pure Java Script that can be transferred
to any browser enabled client during initialization such that
the workﬂows can be executed on the client side and in-
10

73
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
corporate local services residing on the client. A detailed
description of the implementation was presented in [25].
The single services of the service composition are given
as abstract triples <res, act, attr[]>. Here, res describes
the resource that should result from the respective service
execution, act deﬁned an action that should be performed
on the resource res, and attr[] denotes a set of attributes
that are required for the execution of the speciﬁed action.
Thus, the triple <map, center, lat=23432, long=92834>
Mashup Site
RE
RE
Workflow 
Engine
Service 
Discovery 
Engine
Service 
Call 
Generator
Service 
Repository
Client
3rd Party Service Providers
Service 
Repository
Presentation
Mashup
Request
Extended Mashup Site
Figure 9. Server-side Service Composition
Engine for Composed Web Applications: Ar-
chitecture.
denotes that a map is requested that is centered on the loca-
tion given by the longitude long and latitude lat. In general,
a location is not known by its longitude and latitude, but
by its name. Therefore, another service may be requested
by the triple <location, getCoordinates, location=Berlin>
that generates the longitude and latitude values for the city
“Berlin”. The output of this service can thus be used as in-
put for the next service. Of course, the attribute “Berlin”
can also be given during runtime by a user input.
This proceeding interprets the workﬂow model in a
REST conform way: The developer requests a resource and
is returned a representation of the resource that depends on
the given action and set of attributes. For instance, while
the triple <location, getCoordinates, location=Berlin> re-
turns the location of a given city by its longitude and lat-
itude coordinates, the triple <location, getStreetName, lo-
cation=Peter’s Pub> may return a String contain the street
name of a bar called “Peter’s Pub”.
To enable such an abstraction from actual service imple-
mentations, the proposed architecture features a late bind-
ing engine. Here, 3rd party provides can describe their ex-
posed APIs featuring REST interfaces with the Web Ap-
plication Description Language (WADL) [14]. (The inte-
gration of other services such as classic SOAP Web Ser-
vices described by WSDL [6] are also supported but are not
described in greater detail here.) The late binding engine
is capable of matching the previously introduced triples
denoting abstract descriptions of a requested resource to
these WADL descriptions and return a set of WADL ﬁles
that describe services which can generate the requested re-
source. For instance, a triple <location, getCoordinates,
location=Berlin> may be matched by Google Maps, Ya-
hoo Maps, and suchen.de. One of these WADL based de-
scriptions can now be passed to the Service Call Generator
where a REST call for the chosen service is automatically
created and handed back to the workﬂow engine where the
service can be invoked.
This proceeding enables more responsiveness and dy-
namicity of Web Mashups on multiple levels. First, ser-
vice interfaces are encapsulated behind abstract descrip-
tions which reduce the amount of coding for the software
developer. Thus, instead of dealing with the concrete API
of Google Maps, software developers can interface with the
abstract notion of triples, which is conform to the REST
architectural style of the Web.
Thereby, the integration
of multiple APIs providing a similar functionality can be
avoided. For example, a developer that has always used
Google Maps to integrate a map into his or her Web appli-
cation may decide to use Yahoo Maps instead. In this case,
the developer would have to incorporate a complete new
API into his or her Mashup, although both services provide
the same functionality.
However, the dynamic binding of services does not only
reduce the development time for Mashups, but also enables
the consideration of device capabilities, user proﬁles, con-
text information, and Quality of Service (QoS) parameters
of services. Thus, in case the late binding engine returns
multiple WADL ﬁles, i.e., has discovered multiple services
or APIs that can provide the requested resource, the service
may be explicitly selected that matches the current circum-
stances best. For instance, in case a user has deﬁned in his
proﬁle that he prefers services from Google because of the
11

74
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
familiar user interface, Google Maps may be bound instead
of Yahoo Maps. On the other hand, a monitoring entity may
have noticed that the response time of Yahoo has been con-
siderably shorter than from Google, leading to the incorpo-
ration of Yahoo Maps instead of Google Maps; this incor-
poration of non-functional properties if services has been
introduced in [26]. It also enables the recovery of services
that expose a weak performance during runtime, i.e. in case
a service is not responding or responding too slow, it may
be dynamically replaced during runtime by another service.
In addition to the ﬂexibility provided by the dynamic in-
tegration of single service implementations within the ser-
vice composition, the workﬂow graph itself may be adapted
in its structure to as a response to environmental changes;
this adaption has already been introduced in [28].
Thus, the architecture proposed in this work provides
means to overcome the problem of heterogeneous clients by
providing means to bind and replace services dynamically
before and during runtime based on non-functional proper-
ties of services, context information, device capabilities or
user proﬁles.
5
Conclusion and future Prospect
Within this paper, a Underlay System for Web Mashups
was introduced that combined the advantages of SOA
business processes and the rich presentation and interaction
capabilities of today’s Mashups to overcome the challenge
of device heterogeneity and context dependence in modern
Web applications. Therefore, a formal model for service
compositions based on a bipartite graph concept has been
introduced that consists of a workﬂow graph deﬁned as
a timed automaton over an extended ﬁnite set of typed
variables and a dataﬂow graph specifying the passage of
data between the single services. By introducing a special
structure of a timed automaton, the semantics of classic
automata were extended to support parallel execution of
services beside their given ability to express interleaving,
decisions and looping. The model has then been used to
build the basis for a new type of rich Web Mashups that are
responsive the the users’ preferences and device context
by supporting late binding of 3rd party services during
runtime.
Within future work, algorithms for the automatic creation
of service compositions are developed. Here, the descrip-
tions for 3rd party services are extended by lightweight
semantics to support the automatic creation of workﬂows
and binding of services based on a request given by either a
user or another service. Moreover, a GUI is developed that
enables the manual creation of service compositions in an
intuitive way; this representation is then transformed into
corresponding workﬂow and dataﬂow graphs automatically.
References
[1] www.programmableweb.com.
[2] R. Alur, C. Courcoubetis, and D. Dill. Model-checking for
real-time systems. In Proceedings of of the 5th Annual Sym-
posium on Logic in Computer Science, pages 414–425. IEEE
Computer Society Press, 1990.
[3] T.
Andrews,
F.
Curbera,
H.
Dholakia,
Y.
Goland,
J. Klein, F. Leymann, K. Liu, D. Roller, D. Smith,
S. Thatte, I. Trickovic, and S. Weerawarana.
Busi-
ness
Process
Execution
Language
for
Web
Ser-
vices,
Version 1.1,
May 2003.
[Online]. Available:
http://www.ibm.com/developerworks/library/speciﬁcation/ws-
bpel/. [Accessed: November, 2007].
[4] J. Berstel. Transductions and Context-free Languages. B.G.
Teubner, Stuttgart, 1979.
[5] A. Bucchiarone and S. Gnesi. A Survey on Services Compo-
sition Languages and Models. In A. Bertolino and A. Polini,
editors, in Proceedings of International Workshop on Web
Services Modeling and Testing (WS-MaTe2006), pages 51–
63, Palermo, Sicily, ITALY, June 9th 2006.
[6] R. Chinnici, J.-J. Moreau, A. Ryman, and S. Weerawarana.
Web Services Description Language (WSDL) Version 2.0
Part 1: Core Language.
In World Wide Web Consortium
(W3C) recommendation, January 2006.
[Online]. Avail-
able: http://www.w3c.org/TR/wsdl20/. [Accessed: Mar. 24,
2006].
[7] E. M. J. Clarke, O. Grumberg, and D. A. Peled.
Model
Checking. The MIT Press, Cambridge, Massachusetts and
London, England, 1999.
[8] F. Curbera, Y. Goland, J. Klein, F. Leymann, D. Roller,
S. Thatte, and S. Weerawarana. Business Process Execution
Language for Web Services (Version 1.0), July 2002.
[9] D. Dill. Timing assumptions and veriﬁcation of ﬁnite-state
concurrent systems. In J. Sifakis, editor, Proceedings of the
International Workshop on Automatic Veriﬁcation Methods
for Finite State Systems, number 407 in LNCS, pages 197–
212. Springer, 1989.
[10] L. Doldi. UML2 illstrated, Developing Real-Time & Com-
munication Systems. TMSO, 2003.
[11] J.
Duhl.
Rich
Internet
Applications.
Whitepa-
per
(sponsored
by
Macromedia
and
Intel),
page
Online:
http://www.adobe.com/resources/
busi-
ness/rich internet apps/whitepapers.html, 2003.
[12] S. Eilenberg. Automata, Languages, and Machines, volume
Volume A. Academic Press, New York, 1974.
[13] R. T. Fielding.
Architectural Styles and the Design of
Network-based Software Architectures. PhD thesis, Univer-
sity of California, Irvine, 2000.
[14] M. J. Hadley. Web application description language (wadl).
Technical report, Sun Microsystems Inc., November 2006.
[15] M. Huth and M. Ryan. Logic in Computer Science - Mod-
eling and reasoning about systems. Cambridge University
Press, 2004.
[16] M. Jaeger, L. Engel, and K. Geihs. A Methodology for De-
veloping OWL-S Descriptions. In First International Con-
ference on Interoperability of Enterprise Software and Ap-
plications Workshop on Web Services and Interoperability
(INTEROP-ESA ’05). Springer, 2005.
[17] F. Lautenbacher and B. Bauer. A Survey on Workﬂow An-
notation & Composition Approaches. In Proceedings of the
12

75
International Journal On Advances in Software, vol 2 no 1, year 2009, http://www.iariajournals.org/software/
Workshop on Semantic Business Process and Product Life-
cycle Management (SemBPM) in the context of the European
Semantic Web Conference (ESWC), pages 12–23, Insbruck,
Austria, 7th June 2007.
[18] G. Lawton. New ways to build rich internet applications.
Computer, 41(8):10–12, Aug. 2008.
[19] F. Leymann. Web Service Flow Language (WSFL 1.0). In
IBM, May 2001.
[20] Z. Manna and A. Pnueli. The Temporal Logic of Reactive and
Concurrent Systems: Speciﬁcation. Springer-Verlag, 1992.
[21] E. Ort, S. Brydon, and M. Basler. Mashup styles, part 1:
Server-side mashups. Technical report, Sun Developer Net-
work (SDN), May 2007.
[22] E. Ort, S. Brydon, and M. Basler. Mashup styles, part 2:
Client-side mashups. Technical report, Sun Developer Net-
work (SDN), August 2007.
[23] C.
E.
Ortitz.
Introduction
to
J2ME
Web
Services,
April
2005.
[Online].
Available:
http://developers.sun.com/mobility/apis/articles/wsa.
[Ac-
cessed: October, 2007].
[24] H. Pfeffer. UPPAAL Model Checking as Performance Eval-
uation Technique.
Master’s thesis, Rheinische Friedrich-
Whilhelms-Universit¨at Bonn, 2005.
[25] H. Pfeffer, L. Bassbouss, and S. Steglich. Structured ser-
vice composition execution for mobile web applications. In
Proceedings of the 12th IEEE International Workshop on
Future Trends of Distributed Computing Systems (FTDCS
2008), volume ISBN: 978-0-7695-3377-3, pages 112–118,
Kunming, China, 2008. IEEE Computer Society Press.
[26] H. Pfeffer, S. Kr”ussel, and S. Steglich. Fuzzy Service Com-
position Evaluation In Distributed Environments. In In Pro-
ceedings of I-CENTRIC 2008, 2008.
[27] H. Pfeffer, D. Linner, C. Jacob, and S. Steglich.
To-
wards Light-weight Semantic Descriptions for Decentralized
Service-oriented Systems. In Proceedings of the 1st IEEE
International Conference on Semantic Computing (ICSC
2007), volume CD-ROM, Irvine, California, USA, 17-19
September 2007. PLJ+07.
[28] H. Pfeffer, D. Linner, and S. Steglich. Dynamic adaptation
of workﬂow based service compositions. In ICIC ’08: Pro-
ceedings of the 4th international conference on Intelligent
Computing, number ISBN: 978-3-540-87440-9, pages 763–
774, Berlin, Heidelberg, 2008. Springer-Verlag.
[29] H. Pfeffer, D. Linner, and S. Steglich. Modeling and con-
trolling dynamic service compositions.
Computing in the
Global Information Technology, 2008. ICCGI ’08. The Third
International Multi-Conference on, pages 210–216, 27 2008-
Aug. 1 2008.
[30] S. Thatte. XLANG - Web Services for Business Process De-
sign, 2001.
[31] The OWL Services Coalition. OWL-S: Semantic Markup
for Web Services, November 2004.
[Online]. Available:
http://www.daml.org/services/owls/1.1/. [Accessed: Febru-
ary 26, 2007].
[32] U.
University
and
A.
University.
UPPAAL
4.0.6.
http://www.uppaal.com, December 2007.
[33] W. van der Aalst.
Don’t go with the ﬂow: Web services
composition standards exposed. IEEE Intelligent Systems,
2003.
13

