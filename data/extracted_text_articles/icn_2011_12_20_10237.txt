HYRA: A Software-deﬁned Radio Architecture for
Wireless Embedded Systems
Tiago Rog´erio M¨uck and Antˆonio Augusto Fr¨ohlich
Federal University of Santa Catarina (UFSC)
Software/Hardware Integration Lab (LISHA)
Florian´opolis - Brazil
{tiago, guto}@lisha.ufsc.br
Abstract—Traditional Software-deﬁned Radio (SDR) architec-
tures cannot go with the requirements of embedded systems,
specially in terms of performance and power consumption. Low-
power FPGAs now reaching the market might soon become a
viable alternative to overcome such limitations. The Hybrid Radio
Architecture (HYRA) introduced in this paper contributes to this
scenario as it explores the Hybrid HW/SW Component concept to
enable the implementation of SDRs as direct mappings of high-
level synchronous data ﬂow models. Although addressing SDR
from a higher level of abstraction, HYRA mechanisms proved
far more efﬁcient than those behind GNU Radio when the target
is an embedded reconﬁgurable hardware platform.
Keywords- software-deﬁned radio; embedded systems; FPGA.
I. INTRODUCTION
Wireless communication devices are at the heart of a
growing number of embedded systems. Some of them, such
as smartphones, must implement multiple communication pro-
tocols in face of constantly evolving standards. Others, such
as wireless sensor network gateways, must simultaneously
communicate under multiple protocols and sometimes even
dynamically adapt themselves to preserve connectivity. In this
scenario, Software-deﬁned Radio (SDR) becomes an appealing
approach, since most of the key components in the communi-
cation system—including the physical layer—are pushed into
software, thus making them easy to reconﬁgure [1].
However, the implementation of a wireless communication
system based only on an RF front-end, A/D converters, and
a General-Purpose Processors (GPP) comes at a high cost.
The associated Digital Signal Processing (DSP) algorithms
demand very high processing power, a requirement that contra-
dicts major design premises in the ﬁeld, which usually include
low cost, low energy consumption, and small size. Never-
theless, it is important to notice that this exceeding demand
for processing power arises basically from the serialization
of essentially parallel algorithms that takes place as they are
pushed from hardware to software.
Implementing the key concepts behind an SDR on a recon-
ﬁgurable hardware platform such as an Field Programmable
Gate Array (FPGA) would preserve its main advantage—
ﬂexibility—without requiring a high-performance processor.
For instance, an architecture based on DSP blocks on a
datapath implementing a Synchronous Data Flow (SDF) could
take advantage of the platform’s inherent parallelism for the
implementation of each individual DSP block and also to
interconnect them efﬁciently. This has not been an option to
embedded systems designers until now for a single reason:
power consumption. Recent advances in low-power reconﬁg-
urable hardware, however, suggest that such systems can soon
become viable. Indeed, several groups currently explore the
use of hardware accelerators for the implementation of SDR
algorithms [2]–[4]. Single instruction, multiple data (SIMD)
extensions of GPPs, DSP processors, and functional blocks
implemented in FPGAs are common approaches to limit pro-
cessing power requirements at software level. Notwithstand-
ing, the imminence of embedded SDRs fully implemented in
low-power FPGAs calls for a systematic approach to guide
the development of DSP components, interconnections, and
controllers.
In this paper, we introduce HYRA, the Hybrid Radio Archi-
tecture, as a fundamental step toward a more comprehensive
strategy to deploy SDRs in the context of embedded systems.
HYRA relies on the Hybrid HW/SW Component concept of
Application-driven Embedded System Design (ADESD) [5] to
enable the implementation of an SDR as a direct mapping of
a high-level SDF model. Each functional block in the model
is associated to an hybrid component that can be plugged
into HYRA’s embedded SDR framework. Since hybrid com-
ponents preserve their interfaces independently of how they
are implemented, developers can freely decide which elements
of the SDF graph go to software and which go to hardware.
HYRA’s framework features a programmable interconnect
infrastructure that abstracts the First In, First Out (FIFO)
channels between components. It also features a controller that
dynamically coordinates the ﬂow of data between components.
The remainder of this paper is organized as follows: Section
II discusses related SDR implementation approaches; Section
III recalls ADESD hybrid components, a fundamental concept
behind HYRA; Section IV describes HYRA in details, while
Section V presents an experimental evaluation; Section VI
closes the paper with our conclusions.
II. RELATED WORK
The most straightforward SDR implementation approaches
are the ones based on GPPs. These approaches target ﬂex-
ibility and ease of development, and usually delegate all
processing to a GPP on a PC-like machine. These approaches
246
ICN 2011 : The Tenth International Conference on Networks
Copyright (c) IARIA, 2011              ISBN:978-1-61208-113-7

are not suitable to embedded systems not only because of
cost, energy consumption, and size, but also because of the
overhead imposed by general-purpose operating systems and
by the high-latency, high-jitter communication interfaces used
to reach the RF front-end [6]. The GNU Radio [7] is the most
representative case in this group. It features a framework and
a library of signal processing blocks that enables SDRs to be
built on ordinary PCs. In GNU Radio, the physical layer of a
radio is abstracted as a ﬂow graph in which nodes represent
processing blocks and edges represent the data ﬂow between
them.
Another approach is to delegate signal processing to pro-
grammable devices speciﬁcally designed for that purpose.
Several architectures
[2]–[4] relies on a GPP processor
coordinating multiple DSP processors with SIMD and very
long instruction word (VLIW) datapaths. Some architectures,
such as the Elemental Computing Architecture [8], deﬁne ﬁne-
grained components speciﬁc to a given class of operations
which can be conﬁgured and connected to each other to build
an SDR. Differently from HYRA, these approaches focus
on the efﬁcient implementation of individual DSP blocks,
without addressing the relationship between the implemen-
tation and a high level model. Also, the resource allocation
and synchronization of processing elements must controlled
manually by the programmer. Some tools and languages, such
as SPIR [9], aim to provide means to compile high level
models of DSP applications into code that is suitable to run on
multiprocessor System-on-Chip (MPSoC) DSP architectures.
This is an important step toward a higher level SDR develop-
ment strategy, but, as authors recognize, some algorithms that
require considerably more processing power than the average,
such as ﬁlters, searchers, and Turbo decoder, easily become
bottlenecks in the programmable DSP hardware approach.
Apart from the software-based approaches, the dedicated
implementation of the wireless communication protocols in
FPGAs is another common approach to put together the
ﬂexibility of a reconﬁgurable radio, and the efﬁciency of a
dedicated hardware. However, implementing a complex digital
hardware design is not a straightforward task. Even if tools to
translate high level speciﬁcations to a synthesizable register
transfer level (RTL) description exist [10], [11], there is still
a lack of means to integrate the dedicated hardware dataﬂow
in a control ﬂow that also encompasses software processes on
the GPP. As a result, any change in the SDR protocol that
requires more than a change on the parameters of existing
hardware blocks usually requires the generation of a new
hardware instance.
III. ADESD HYBRID COMPONENTS
HYRAwas developed based on the idea of hybrid hard-
ware/software components [5]. This concept is an elabora-
tion on the concept of hardware mediators proposed in the
Application-driven Embedded System Design (ADESD) [12]
methodology. In ADESD, hardware mediators are a particular
kind of component that are responsible for keeping the high-
level abstractions independent of the hardware platform. This
components are implemented using generative programming
techniques, adapting the hardware interface to the interface
required by the system instead of creating a hardware abstrac-
tion layer. The idea of hybrid hardware/software components
emerges from the fact that different mediators can exists for
the same hardware component, each one designed for different
purposes (e.g., changing the trade-off between performance
and energy consumption). Each component aggregates media-
tors for its many implementations, which could be in hardware,
software or both. According to system requirements of cost,
performance, energy, etc., any one of these implementations
can be selected without any change to the higher system layers
that use the component.
In previous works [5] were deﬁned and implemented in
the Embedded Parallel Operating System (EPOS) [12] some
architectural guidelines for the translation of operating system
related components, such as timers, schedulers, and synchro-
nizers, from software to hardware and vice versa. Whether
such guidelines can also be deﬁned for DSP related compo-
nents has not yet been investigated, but nonetheless, a hybrid
component is a convenient construct to encapsulate functional
blocks on an SDR. This will be demonstrated in the next
sections.
IV. SDR IMPLEMENTATION WITH HYRA
HYRA relies on SDF abstractions of SDRs. In this model,
the SDR processing chain is abstracted as a ﬂow graph, where
the nodes represent processing blocks and the edges represent
the data ﬂow between the blocks. In HYRA, each functional
block in the SDF is associated to a hybrid component that
can be plugged into HYRA’s embedded SDR framework. The
developer uses this framework to specify connections that
deﬁnes the data ﬂow between components. The framework
is responsible for creating the FIFO channels between the
components and for starting the runtime mechanism that
dynamically coordinates the data ﬂow.
Fig. 1.
Overview of HYRA
Figure 1 shows an overview of our architecture. It’s frame-
work have both a hardware and software side. The hardware
side features a conﬁgurable interconnect structure which pro-
vides a FIFO-like stream interface to interconnect the hardware
implementations of hybrid components. Also, it offers the
247
ICN 2011 : The Tenth International Conference on Networks
Copyright (c) IARIA, 2011              ISBN:978-1-61208-113-7

resources necessary to create HW FIFO channels between
components in hardware and to coordinate their execution.
The software side offers the interfaces to connect the software
implementations of hybrid components and the runtime mech-
anism, denominated Flow Controller, which is responsible
for controlling the connections and synchronization between
components. The following sections will explain in more
details each part of the architecture.
A. Flow controller
The ﬂow controller mechanism is responsible for connecting
the components and controlling the data ﬂow between them at
runtime. When the developer speciﬁes a connection between
two components, the ﬂow controller creates a FIFO channel
between them. The size of the FIFO in the channel is deﬁned
by the following equation:
FIFOsize = max(Blkoutputrate
0
, Blkinputrate
1
) · α
(1)
in which an output of Blk0 is being connected to an input of
Blk1, Blkoutputrate
0
is the number of data elements generated
upon each execution of Blk0, and Blkinputrate
1
is the number
of data elements consumed in each execution of Blk1. The
FIFO size is formulated in this way based on the fact that
Blk0 cannot generate data faster then Blk1 can consume. If
this happens in the system, due to modeling error or poor
performance of Blk1, the FIFO will always overﬂow. α is
a safety factor that should be set according to the jitter
characteristics of the platform.
The FIFO allocation will depends on the actual physical
implementation of the hybrid components that the channel is
connecting. If both are implemented on software, a SW FIFO
will be dynamically allocated in the system main memory. If
one or both components are in hardware, the ﬂow controller
mechanism will allocate the FIFO inside the hardware inter-
connect structure. The next section will explain the hardware
side of the framework.
The control of the data ﬂow between software components
is accomplished by creating a thread for each component.
Each thread executes a loop where, at ﬁrst, it remains locked
onto semaphores associated with the channels connected to the
block’s inputs. Each time an element is added to a channel,
the v() method of its associated semaphore is called, unlocking
the threads that consume the data from the channels. After
acquiring all the semaphores, the thread consumes the inputs,
executes the block’s processing, and ﬁnally writes the result
in the output channels, unlocking the threads associated to the
subsequent blocks.
B. Hardware support
Hybrid components implemented in hardware don’t use the
software synchronization mechanism described in the previ-
ous section. Instead, they are controlled directly by signals
provided by the FIFO channels in hardware. The deployment
of HW FIFO channels is supported by the ﬂow controller
hardware structure shown in Figure 2. This structure mainly
consists of a interconnection block that have a set of read ports,
write ports and internal FIFOs, where the connection between
these three elements can be deﬁned by software-controlled
conﬁguration registers.
Fig. 2.
HW layer of HYRA’s framework
All the components that are implemented as hardware have
their inputs connected to the structure’s read ports, and their
outputs connected to the write ports. When these components
are connected, the ﬂow controller mechanism uses the in-
formation provided by the component’s software interface to
deﬁne which port must be connected to which FIFO. Since the
HW FIFOs must have a ﬁxed size, the interconnect structure
allows FIFOs to be interconnected among them. This way,
when two components are connected, it is possible to allocate
a chain of FIFOs between them, in a way in which the total
size of the chain is bigger than or equal to the required FIFO
size.
Figure 3 shows how we have implemented this intercon-
nect structure. We used a simpliﬁed butterﬂy fat tree NoC
architecture [13] optimized for the interconnection of stream
blocks. It consists of a matrix of FIFOs where each FIFO
input is connected to each input port, and each output port is
connected to each FIFO output. Each FIFO output is connected
to the input of the FIFO in the next column on the same line.
With this interconnect scheme we can provide a wide range of
possible allocation for each input/output port, while keeping
the use of FPGA resources by interconnect at a reasonable
level.
Fig. 3.
Overview of the ﬂow controller HW interconnect internal structure
In order to provide all possible connections between HW
248
ICN 2011 : The Tenth International Conference on Networks
Copyright (c) IARIA, 2011              ISBN:978-1-61208-113-7

and SW components, four different FIFO channel implemen-
tation are required: SW FIFO, HW FIFO, SW-HW FIFO,
and HW-SW FIFO. We already explained how channels be-
tween SW-only and HW-only components are created. The
connection between software and hardware components is
achieved through the Block SW Interface shown in Figure 2.
It behaves like a wrapper between the system bus and the
interconnect structure stream interface. When a component in
hardware is connected to a component in software, its respec-
tive ports are connected to ports associated with the Block SW
Interface. When there is a SW→HW connection a SW-HW
FIFO provides a software interface so the source block can
write to the Block SW Interface output port associated to the
destination block input port. But, the HW→SW connection
requires additional runtime and hardware support. When a
HW-SW FIFO is created, it register itself in the interrupt
handler for the Block SW Interface’s interrupts. Every time
new data arrives at one of the FIFOs connected to the Block
SW Interface’s input ports, it will issue an interrupt that will
release the semaphore associated with the FIFO, as described
in the previous section.
V. EVALUATION AND RESULTS
In this work, we have focused only on the architectural
support and data ﬂow aspects for the implementation of SDR.
In order to evaluate the proposed architecture we disconsid-
ered the signal processing function, since they are coved in
other works [10], [11], and focus only on HYRA’s intrinsic
overhead. We have evaluated this overhead in two aspects:
area overhead (FPGA resource utilization) and performance
overhead (latency added to the data ﬂow by the hardware and
software control structures).
A. Evaluation setup
To deﬁne the data ﬂow structures for our evaluations, we
have analyzed the data ﬂow structure of the physical layer
of several protocols covering a wide range of modulation
schemes and application classes: Bluetooth, UWB, ZigBee,
Wi-Fi (802.11a), and W-CDMA. In this analysis we veriﬁed
that all protocols follows a common data ﬂow structure. On the
receive chain, there is usually a ﬁlter before the demodulation
blocks, normally a low pass ﬁlter used to obtain a clean piece
of spectrum that contains the information. Next, there are the
demodulation/synchronization blocks, which normally consists
of one or more data ﬂows being processed in parallel. The last
step is a post-demodulation ﬁlter which normally consists of a
channel decoder for error detection and correction. The trans-
mit chain follows an analogous structure. From this general
structure, we have deﬁned the structures shown in Figure 4
to evaluate the overhead in terms of the number of blocks
in a data ﬂow (4a) and the number of data ﬂows in parallel
(4b), covering many possible variations of the general structure
described previously. We also analyzed how the number of
inputs/outputs of a block affects the overhead (4c).
These structures are composed by three kinds of blocks.
The Timestamp source block generates samples which consist
Fig. 4.
SDRs data ﬂow structures used for the overhead evaluation in terms
of the number of blocks in serial (a), the number of data ﬂows in parallel (b),
and the number of inputs/outputs (c)
of timestamps that represent the time when the sample was
generated. The dummy blocks are empty blocks that just
propagate their inputs to their outputs. After being generated,
the samples will go through the dummy block chain. When a
sample arrives at the Timestamp sink block, the timestamp
is compared with the current time, obtaining the time the
sample took to go through the dummy block chain. Since the
dummy blocks are empty, this resulting time represents only
the overhead imposed by the architecture on the data ﬂow.
There is also the Fork block and Join block which are used to
fork and join the data ﬂows, respectively.
B. System implementation and conﬁguration
To evaluate these three structures, we have implemented
HYRAon the EPOS operating system running on the Xilinx’s
ML403 Embedded Platform. The ML403 features a Virtex-
4 FPGA with an embedded PowerPC 405 microprocessor.
In order to use the same hardware conﬁguration, we have
synthesized the hardware with all of the necessary blocks
for all experiments. We have used the following tools and
parameters: ISE/EDK 10.1; GCC 4.0.2; FPGA and micropro-
cessor clocked at 100 MHz; interconnect structure conﬁgured
with 32 input/output ports, and 64 FIFOs (8 bit wide with
16 elements); the α factor ﬁxed to 1 in order to provide an
evaluation considering low jitter requirements.
Table I shows the resource consumption of the generated
hardware. Separate results are shown for HYRA’s structures
along with the HW dummy blocks, and for the system IPs
generated by EDK (internal memory, memory controller, in-
terruption controller, UART, etc). Our architecture alone uses
about 65% of the available logic and 0% of the available
memory. Due to the lack of memory blocks available on the
device, we chose to implement the FIFOs using the SRL16
capabilities to convert a 4-input LUT into a 16-bit shift
register. Howsoever, this apparently high resource usage is
due to the very limited amount of logic available on the used
device. When compared to other system IPs, we can see that
HYRAuses slightly more resources then a complete set of
basic IO and memory peripherals.
249
ICN 2011 : The Tenth International Conference on Networks
Copyright (c) IARIA, 2011              ISBN:978-1-61208-113-7

TABLE I
AMOUNT OF HW RESOURCES USED BY THE SYNTHESIZED STRUCTURES
Resource
Our IPs
EDK IPs
Full System
4-input LUTs
37%
35%
72%
Slice Flip Flops
67%
31%
98%
Occupied Slices
70%
55%
99%
RAM blocks
0%
63%
63%
Max. frequency
167 MHz
109 MHz
107 MHz
C. Performance overhead
We have done tests to determine the performance overhead
that we have deﬁned as the latency between the Timestamp
source and sink blocks in the three basic data ﬂow structures.
We have implemented each structure in hardware and software
and executed tests with the number of dummy blocks ranging
from 1 to 16. In each test 6 × 107 samples were generated
and we obtained the average value of the latencies of each
sample and the standard deviation which was used to obtain
the coefﬁcient of variation. A sampling rate of 1 × 106
samples/second was used in the tests with blocks in hardware.
For the tests with blocks in software we used a sampling rate
of 1 × 104 due to the low speed of the PowerPC processor.
Figures 5a and 5b show the results. When using only
software blocks, the overhead grows linearly in relation to the
increase in the number of blocks and the number of inputs and
outputs for all structures. The coefﬁcient of variation remained
low in all conﬁgurations. When using only HW blocks, the
latency was about four orders of magnitude lower than when
using software blocks and, as expected, except for the serial
block conﬁguration, the latency remained constant regardless
the size of the structure, due to the full parallelism that can
be explored in this kind of architecture. There is also a null
coefﬁcient of variation in the hardware operations.
To evaluate the communication latency between components
implemented in HW and components implemented in SW,
we have used the data ﬂow shown in Figure 6 which cover
operations on both SW-HW FIFOs and HW-SW FIFOs. We
have performed the same experiment described previously on
this two structures and veriﬁed that the average latency on
both interleaved data ﬂows yielded similar results: 221µs and
234µs for data ﬂows (a) and (b), respectively. Data ﬂow
(a) have more SW blocks then (b), thus showing a higher
SW management overhead. However, both have two SW-HW
FIFOs and two HW-SW FIFOs connecting the blocks. By
comparing the latencies with the ones obtained for SW-only
blocks (221µs) and HW-only blocks (0.31µs) we can see that
the read/write operations SW channels represents the most
signiﬁcant overhead.
We also compared the overhead of our architecture to GNU
Radio. For this comparison, we replicated the same tests
described previously using GNU Radio running over a Linux
operating system in a PC. Our architecture and EPOS were
compiled for the IA32 architecture only with software blocks
support, and evaluated in the same system. For the GNU
2
4
6
8
10
12
14
16
10
−1
10
0
10
1
10
2
10
3
10
4
Number of blocks/inputs/output
Latency (microseconds)
 
 
Blocks in serial (SW)
Blocks in parallel (SW)
Blocks with multiple in/out (SW)
Blocks in serial (HW)
Blocks in parallel (HW)
Blocks with multiple in/out (SW)
(a) Average latency
2
4
6
8
10
12
14
16
0
1
2
3
4
5
6
7
8 x 10
−3
Number of blocks/inputs/outputs
Coefficient of variation
 
 
Blocks in serial (SW)
Blocks in parallel (SW)
Blocks with multiple in/out (SW)
Blocks in serial (HW)
Blocks in parallel (HW)
Blocks with multiple in/out (SW)
(b) Coefﬁcient of variation
Fig. 5. Latency for blocks in serial, in parallel, and with multiple input/output
Fig. 6.
Serial data ﬂows with interleaved SW and HW blocks
Radio experiment, we used GNU Radio 3.2.2 running on a
Linux kernel 2.6.28. The result for the serial blocks data ﬂow
structure shown in Figure 7a demonstrates that our architecture
performance surpasses GNU Radio between 2 and 4 times,
and this difference increases as the number of blocks in the
processing chain increases. Figure 7b also shows that we are
able to achieve smaller latency variations as well.
D. Discussion
The results show that our architecture yields superior per-
formance than an equivalent, in terms of abstraction level,
250
ICN 2011 : The Tenth International Conference on Networks
Copyright (c) IARIA, 2011              ISBN:978-1-61208-113-7

2
4
6
8
10
12
14
16
0
20
40
60
80
100
120
140
Number of blocks
Latency (microseconds)
 
 
Our Architecture (EPOS)
GNU Radio (Linux)
(a) Average latency
2
4
6
8
10
12
14
16
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
Number of blocks
Coefficient of variation
 
 
Our Architecture (EPOS)
GNU Radio (Linux)
(b) Coefﬁcient of variation
Fig. 7.
Latency of the proposed architecture VS GNU Radio on the serial
blocks data ﬂow structure
commonly used architecture. Only software components were
used in this comparison, if a hardware device was used to
generate the timestamps, GNU Radio would suffer an addi-
tional disadvantage. In GNU Radio, the use of any hardware
device to obtain or sink data from/to the environment requires
Linux drivers whose performance is mostly limited by the
kernel’s abstraction layer. A previous work [6] shows that,
due to the Linux kernel overhead, the standard deviation
of the time a sample takes to get to the processing chain
after being generated in the RF Front-end is higher than the
average time. This problem does not appear in EPOS since the
metaprogrammed hardware mediators are dissolved within the
application when the system is compiled, which leads to higher
performance.
However, even with known latency problem, the GNU Ra-
dio is widely used and several protocols have been successfully
implemented using it. The results have shown that with our
architecture we were able to bring similar functionality with
superior performance to the embedded system domain, which
leads to the conclusion that our architecture is suitable for the
implementation of high-end protocols in embedded systems.
VI. CONCLUSION
In this paper we have introduced HYRA, an Hybrid Radio
Architecture that explores the Hybrid Component concept
within ADESD to enable the implementation of SDRs as direct
mappings of high-level SDF models. As hybrid components,
HYRA SDR blocks can be implemented as arbitrary combi-
nation of software and hardware on FPGA-based platforms.
The programmable interconnect infrastructure in HYRA’s
framework ensures transparency in this respect. FIFO channels
can be ﬁne tuned to fulﬁll the requirements of a given SDR
protocol, while the controller dynamically coordinates the ﬂow
of data between components.
In comparison with other approaches, HYRA addresses the
implementation of SDRs in the context of embedded systems
from a higher level of abstraction. Moreover, the evaluation
results presented in this paper conﬁrm that the overhead
caused by the proposed architecture in terms of latency is
much smaller than that of GNU Radio, a widely accepted
architecture. Furthermore, our experiments demonstrated that
HYRA can be implemented on reconﬁgurable hardware plat-
form with minimal additional resources. In combination, this
factors conﬁrm that our architecture meet the requirements
for the implementation of high-end protocols in embedded
systems.
REFERENCES
[1] E. Buracchini, “The software radio concept,” IEEE Comm. Mag., vol. 38,
no. 9, pp. 138–143, 2000.
[2] J. Glossner, E. Hokenek, and M. Moudgill, “The Sandbridge Sandblaster
Communications Processor,” in 3rd WASP, 2004, pp. 53–58.
[3] M. Woh, Y. Lin, S. Seo, S. Mahlke, T. Mudge, C. Chakrabarti, R. Bruce,
D. Kershaw, A. Reid, M. Wilder, and K. Flautner, “From SODA to
scotch: The evolution of a wireless baseband processor,” in MICRO 41.
Washington, DC, USA: IEEE Computer Society, 2008, pp. 152–163.
[4] K. van Berkel, F. Heinle, P. P. E. Meuwissen, K. Moerman, and
M. Weiss, “Vector processing as an enabler for software-deﬁned radio
in handheld devices,” EURASIP, vol. 2005, pp. 2613–2625, 2005.
[5] H. Marcondes and A. A. Fr¨ohlich, “A Hybrid Hardware and Software
Component Architecture for Embedded System Design,” in IESS ’09,
Langenargen, Germany, 2009, pp. 259–270.
[6] G. Nychis, T. Hottelier, Z. Yang, S. Seshan, and P. Steenkiste, “Enabling
MAC Protocols Implementation on Software-deﬁned Radios,” in NSDI
’09, 2009.
[7] GNU FSF project, “The GNU Radio,” 2010, [retrieved, November 8,
2010]. [Online]. Available: http://www.gnu.org/software/gnuradio
[8] Steven
Kelem,
Brian
Box,
Stephen
Wasson,
Robert
Plunkett,
Joseph Hassoun, and Chris Phillips, “An Elemental Computing Archi-
tecture for SD Radio,” in SDR ’07, 2007.
[9] Y. Lin, M. Kudlur, S. Mahlke, and T. Mudge, “Hierarchical coarse-
grained stream compilation for software deﬁned radio,” in CASES ’07.
New York, NY, USA: ACM, 2007, pp. 115–124.
[10] Z. Guo, W. Najjar, and B. Buyukkurt, “Efﬁcient hardware code gener-
ation for FPGAs,” ACM TACO, vol. 5, no. 1, pp. 1–26, 2008.
[11] F. Plavec, Z. Vranesic, and S. Brown, “Towards compilation of streaming
programs into FPGA hardware,” in FDL ’08, 2008, pp. 67–72.
[12] A. A. Fr¨ohlich, Application-Oriented Operating Systems, ser. GMD
Research Series.
Sankt Augustin: GMD - Forschungszentrum Infor-
mationstechnik, Aug. 2001, no. 17.
[13] P. P. Pande, C. Grecu, A. Ivanov, and R. Saleh, “Design of a switch
for network on chip applications,” in ISCAS ’03, vol. 5, 203, pp. V217–
V220.
251
ICN 2011 : The Tenth International Conference on Networks
Copyright (c) IARIA, 2011              ISBN:978-1-61208-113-7

