Efficient Interpolation Architecture for Soft-Decision List Decoding of Reed-
Solomon Codes 
 
Sungman Lee 
The MTH 
426-5, Gasan-dong, Kumcheon-gu 
Seoul, Korea 
e-mail: orozi318@naver.com 
Taegeun Park 
The Catholic University of Korea 
San43-1, Yokok2-dong, Bucheon-shi, 
Kyungki-do, Korea 
e-mail: parktg@catholic.ac.kr
 
 
 
 
Abstract— Recently, algebraic soft-decision decoding algorithm 
for RS codes that can correct the errors beyond the error 
correcting bound has been proposed. The main task in the 
algorithm is the weighted interpolation of a bivariate 
polynomial that requires intensive computations. In this paper, 
we propose an efficient architecture with low hardware 
complexity for interpolation in soft-decision list decoding of 
Reed-Solomon codes. The proposed architecture processes the 
candidate polynomial in such a way that the terms of X degrees 
are processed in serial and the terms of Y degrees are 
processed in parallel. The processing order of candidate 
polynomials adaptively changes to increase the efficiency of 
memory access for coefficients. The proposed interpolation 
architecture for the (255, 239) RS list decoder is designed and 
synthesized using the DonbuAnam 0.18um standard cell 
library. The maximum operating clock frequency is 200MHz 
and the synthesized gate count is about 25.1K gates in two-
input equivalent NAND gates. 
Keywords—VLSI architecture; Polynomial interpolation; 
Reed-Solomon codes; Soft-decision list decoding. 
I. 
 INTRODUCTION 
Among the various kinds of error correcting codes in 
digital communication systems, Reed-Solomon (RS) codes 
are widely used block codes due to their excellent burst 
error-correcting capabilities. It is well known that an       
RS codes have   message symbols and   coded symbols, 
where each symbol belongs to       . An       RS 
codes can correct   symbols and   erasures with 
        . Classical RS decoding scheme can be 
thought of as the bounded minimum distance (BMD) 
algorithm that decodes the received codewords through the 
channel by hard-decision. Efficient algebraic hard-decision 
decoding algorithms, such as Berlekamp-Massey algorithm 
and Euclid algorithm [1] have been widely used to decode 
the Reed-Solomon codes. 
Recently, Guruswami-Sudan (GS) [2] proposed a 
polynomial-time list decoding algorithm that can correct the 
errors beyond the error correcting bound. The proposed list 
                                                           
This work was partially supported by the Korea Research Foundation 
Grant funded by the Korean Government (MOEHRD, Basic Research 
Promotion Fund) (KRF-2008-313-D00743) 
This work was partially supported by the Research Fund, 2011 of The 
Catholic University of Korea. 
decoding algorithm has a decoding radius             
and corrects up to       errors for all code rates [2]. 
With reliable soft-decision data, such as probabilistic channel 
information, RS decoding can achieve better performance in 
correcting errors. Koetter and Vardy (KV) [3] generalized 
the list decoding algorithm that can decode, as long as a 
certain weighted condition is satisfied. The soft-decision list 
decoding algorithm consists of two major processes: 
interpolation process with KV front end and factorization 
process. The interpolation process is quite computationally 
intensive with large latency, so it may suffer low 
performance. The re-encoding scheme can be applied to 
reduce the number of iterations for interpolation [4]. 
Many researchers have proposed a number of the 
interpolation architectures for the soft-decision RS decoder 
[5][6][7][13][14]. Most of the architectures proposed so far 
try to increase the decoding performance by parallelizing the 
processes for the candidate polynomials. This requires 
considerable hardware with memory modules that may be 
hard to apply in some applications. Ahmed, Koetter, and 
Shanbhag proposed the point-serial algorithm that calculates 
all the discrepancy coefficients corresponding to a particular 
interpolation point in parallel [5]. Wang and Ma represent 
the finite field numbers in both regular and power formats, 
i.e., hybrid-format, that can reduce the hardware complexity 
for the DCC block and parallelize the decoder architecture 
[6]. The parallel architecture [7] proposed by Gross, 
Kschischang, and Gulak embeds both a binary tree and a 
linear array in a 2–D array processor, enabling fast 
polynomial evaluation operations. Zhu et. al. have proposed 
backward interpolation, which eliminates interpolation points 
or reduces interpolation multiplicities [13]. The proposed 
architectures share computational units with forward 
interpolation architectures to reduce the hardware complexity. 
In [14], new techniques are employed to achieve high-speed 
interpolation for the iterative bit-level generalized minimum 
distance (BGMD) algebraic soft-decision decoding. They 
also proposed architectures to efficiently integrate the 
combined and backward interpolation techniques. 
In this paper, we propose an efficient architecture with 
low hardware complexity for interpolation in a soft-decision 
list decoding of Reed-Solomon codes. To reduce hardware 
cost, the proposed architecture processes the terms of   
degrees in the candidate polynomial serially, whereas it 
processes the terms of   degrees in the candidate 
25
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-203-5
ICWMC 2012 : The Eighth International Conference on Wireless and Mobile Communications

polynomial in parallel. During the polynomial update in the 
interpolation process, the appropriate polynomial coefficients 
should be read efficiently from memory. The processing 
order of candidate polynomials adaptively changes to 
increase the efficiency of memory access for coefficients. 
This scheduling minimizes the usage of internal registers and 
the number of memory accesses and simplifies the memory 
structure by combining and storing data in memory. Also, 
the proposed architecture shows high hardware efficiency, 
since each module is balanced in terms of latency and the 
modules are maximally overlapped in the schedule. 
II. 
SOFT-DECISION LIST DECODING OF RS CODES 
An       RS codes defined in the Galois field        
have codewords of length       , where   is a 
positive integer and   is the number of information symbols 
in the codeword. RS codes can be obtained by evaluating 
certain subspaces of       in a set of points   
                       . Therefore,       RS codes 
        of length   and dimension   is defined as  
                                             
                               
      (1) 
Guruswami and Sudan verified that the generalized 
Reed-Solomon decoding problem reduces to the polynomial 
reconstruction problem [2]. Now, we define the essential 
elements of the soft decision list decoding algorithm. The 
bivariate polynomial        over    is defined as in [3]. 
          
          
 
 
 
              
                           , 
                                          
     . 
 
 
 
      (2) 
We define the weighted degree of a polynomial, as 
follows. 
 
Definition 1: Let          
 
         
 
 
 
 be a 
bivariate polynomial over       , and let   ,    be real 
numbers. Then, the        -weighted degree of       , 
denoted               , is the maximum over all 
numbers          such that       . 
Definition 2: A bivariate polynomial        is said to 
pass through a point         with multiplicity       , if the 
shifted polynomial              contains a monomial 
of degree        and does not contain a monomial of degree 
less than       . Equivalently, the point         is said to 
be a zero of multiplicity        of the polynomial       . 
 
When        is the shifted version of the polynomial 
       by        , the equation below holds. 
         
          
 
 
 
              
  
                    
 
 
 
. 
                            
, 
     
          . 
 
 
 
      (3) 
The soft-decision RS list decoding can be considered as a 
“curve-fitting” problem. In the first phase, the algorithm 
finds a polynomial        of low degree that fits the points 
       . Next, it finds all small degree roots of       ; and 
each factor of        forms possible candidates of the 
message polynomial. 
We now briefly describe the list decoding algorithm. 
Figure 1 shows the block diagram of the soft-decision RS list 
decoder. The block diagram consists of three steps: 
multiplicity computation, interpolation, and factorization. 
The multiplicity computation step calculates the multiplicity 
matrix that has reliability information from the channel.  
 
 
Let us suppose that we have the set of interpolation 
points                        with corresponding 
multiplicities     . The interpolation step forms the 
nontrivial polynomial        of minimal        -
weighted degree that passes each interpolation point 
          with multiplicity at least     . This bivariate 
polynomial        may contain the message polynomial as 
a root. After the bivariate polynomial        is found, the 
factorization step determines all the factors of        in 
the form of       , where the degree of      is at most 
k. Each root polynomial      is the candidate of the 
message polynomial. Finally, the polynomial with the 
highest probability among the candidates is selected as a 
message polynomial. 
 
III. 
PROPOSED ARCHITECTURE 
Now, we will explain the interpolation algorithm in more 
detail. The interpolation step finds the bivariate polynomial 
that fits the set of points with the corresponding 
multiplicities. Two main interpolation algorithms have been 
proposed so far: a constrained-serial interpolation algorithm 
[6][7][8] and a point-serial interpolation algorithm [5]. The 
point-serial interpolation algorithm is usually less efficient 
and less flexible in architecture than the constraint-serial 
interpolation algorithm [6]. Figure 2 shows the interpolation 
 
 
Figure 2. Interpolation algorithm. 
 
Figure 1.   Block diagram of soft-decision RS list decoder. 
26
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-203-5
ICWMC 2012 : The Eighth International Conference on Wireless and Mobile Communications

algorithm based on the Fundamental Iterative Algorithm 
(FIA) [10]. 
The algorithm consists of two major operations, namely 
the Discrepancy Coefficient Computation (DCC) and the 
Polynomial Update (PU). As we explained earlier, the 
interpolation process finds a bivariate polynomial        
that passes a point         with a multiplicity     . In the 
algorithm, the DCC operation computes the discrepancy 
coefficients corresponding to a particular constraint for each 
candidate polynomial and the PU operation updates the 
polynomial by reducing the corresponding discrepancy 
coefficients to zero. 
A. Proposed interpolation architecture and its scheduling 
Figure 3 shows the block diagram of the proposed 
interpolation architecture. The proposed architecture consists 
of the Discrepancy Coefficient Computation Unit (DCCU) 
that calculates the discrepancy coefficients (DC) using the 
Hasse Derivative (HD), the Polynomial Update Unit (PUU) 
that updates the candidate polynomials, the Polynomial 
Order Sorting Unit (POSU) that decides the processing order 
of data by storing and aligning the weighted degrees of the 
candidate polynomials, and a few memory blocks and 
control logic. The DCCU also consists of the HD 
computation block and the  -generator that calculates the 
power of   for the HD computation. The DCCU takes the 
stream of interpolation points and multiplicities as inputs.  
 
 
 
The proposed architecture parallelizes the computation 
for the terms in   and computes each candidate polynomial 
and the monomials in   sequentially and thus the required 
hardware is reduced. When the polynomials are updated 
sequentially, the “pivot” polynomial        , which has 
the smallest weighted degree and a non-zero DC value, is 
used to update the other polynomials and is updated itself 
last. 
Figure 4 shows the processing schedule of DCCU and 
PUU when    , where    denotes a candidate 
polynomial and       
 
 denotes the coefficient of      in 
  . All the coefficients of  , with the same degree in   , 
(       
 
       
 
       
 
         
 
), are processed simultaneously, 
since the proposed architecture processes the terms in   in 
parallel. We can overlap the computation of the DCCU and 
the PUU by sending the output coefficient of the PUU 
directly to the DCCU, as depicted in Fig.4. The updated 
coefficients in candidate polynomials are stored and sent to 
the DCCU to calculate the next DC simultaneously. Fig.4 
shows the timing diagram when        . We assume that 
the candidate polynomials initially have the constant terms 
only at the first iteration (   ). The value       
 
 at the 
first iteration      denotes the updated coefficient in 
       . 
B. Discrepancy Coefficient Computation Unit (DCCU) 
The DCC defined in equation (4) calculates the 
coefficient of the monomial      in            that 
is the shifted version of        by   and   in  ,   
direction respectively, where     are non-negative integers 
that satisfy      . The following equation shows the 
Hasse derivative [11] to find the DC. 
  
                             
 
 
  
    
        
 
        
    
   
 
   
                   (7) 
The hardware to solve equation (7) may suffer from 
latency, because it consists of a double loop of addition. The 
architecture proposed by Wang and Ma utilized the finite 
field additions, instead of multiplications, by representing the 
symbol by its exponent [6]. The proposed architecture 
calculates the DCs with respect to   in parallel, whereas it 
calculates the DCs with respect to   and the candidate 
polynomials in serial. Equation (7) can be expanded as 
follows. 
  
          
  
         
      
        
      
      
    
   
    
      
        
 
 
       (8) 
The values                 are meaningful 
when        . Fig.5 shows the block diagram of the 
proposed DCCU to compute equation (8). The multiplication 
at the input computes      and the DCC is performed 
monomially and in increasing order of  . Once the multiple 
of  ,      is calculated, it is stored for the next 
computation and distributed to compute the other DCs in 
candidate 
polynomial 
simultaneously. 
In 
Fig.5, 
                denotes the output of the   generator, 
to be explained later, and     
 , which is the output of the 
PUU, is the coefficient of monomial      in the  -th 
candidate polynomial        . The value   
    
   can be 
easily implemented by Lucas’s theorem [11].   
   is the 
 
 
Figure 4. Timing diagram showing overlap between the DCCU and the 
PUU when    . 
 
 
Figure 3. Proposed interpolation architecture. 
27
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-203-5
ICWMC 2012 : The Eighth International Conference on Wireless and Mobile Communications

common term like      that will be distributed and   
   
can be further simplified according to  . The registers on the 
right in Figure 5 store the intermediate DC values for each 
candidate polynomial. 
 
Y generator that is basically the same as that in [9] 
computes the multiple of  . When      ,      
                     . At the first iteration, the 
value when     will be used immediately. As   
increases, the values stored in the registers are shifted down 
and we can compute      for the DCCU without any 
additional hardware.     finite multipliers are required 
for the Y generator and the number of latency to get the first 
output is        . 
C. Polynomial Update Unit (PUU) 
The PU stage updates each candidate polynomial 
        using the selected “pivot” polynomial        , 
where   is the index of the minimum weighted degree 
polynomial among all polynomials with non-zero DCs. As 
explained in Fig.2, the “non-pivot” polynomials are usually 
updated first and the “pivot” polynomial is updated last. 
           
               
                        
                                                    
  
Here,   
      and   
      denotes the DCs of         
and         respectively. The candidate polynomials for 
   , are updated by adding two polynomials:         
multiplied by   
      and         multiplied by   
     . 
This deletes the monomial      in        in equation (3) 
that is the shifted version of the polynomial        by 
       . Last, the polynomial         will be updated by 
multiplying      . 
The proposed architecture processes the polynomials in 
serial but with an efficient schedule. The update for the 
“non-pivot” polynomials in case of     requires the 
information of both         and         before update. 
The monomials with the same   degree in the polynomial 
are computed simultaneously and the update is preceded 
from the constant terms to higher order of monomials, since 
the proposed architecture processes the   degrees in 
parallel.  
We can serialize and rewrite the update procedure, as in 
equation (11). 
                                         
 
 
 
 
 
      (11) 
Figure 6 depicts the structure of one PUU element that 
can update both          and        . When the 
corresponding coefficient     
  in the polynomial         
comes in as an input, the multiplexer select signal ‘sel’ is set 
to ‘0’ and the computation of     
        
        
 
 is 
implemented. In the register, the coefficient       
 
 will be 
stored to update the other polynomials        . Then, this 
structure is used to update the polynomials         by 
setting the multiplexer select signal ‘sel’ to ‘1’, so the 
computation     
         
        
  will be implemented.  
 
 
Figure 7 shows the PUU structure that updates the 
polynomials in   in parallel. PUU consists of       
PUU elements and each PUU element computes for the 
polynomial       in equation (2). The updated coefficients 
will be stored in the registers at the output and will be sent to 
the DCCU simultaneously to overlap the operations of the 
PUU and the DCCU. After finishing update in the registers, 
the data in the registers will be stored in the memory 
immediately, so the memory access occurs once every 
      clock cycles. The number of memory accesses is 
reduced and the memory structure is simplified by applying 
the proposed scheduling. 
 
 
D. Polynomial Order Sorting Unit (POSU) 
In each iteration of the interpolation algorithm, the 
polynomial         needs to be selected by the weighted 
degree and the DC computed in the DCCU. Fig.8 shows the 
structure of the proposed POSU. Instead of computing the 
weighted degrees of the candidate polynomials to select 
        each iteration, we save the candidate polynomials 
with their weighted degrees once in the internal memory and 
 
 
Figure 7.  PUU overall structure. 
 
 
Figure 6.  Structure of one PUU element. 
 
 
Figure 5.  DCCU structure. 
28
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-203-5
ICWMC 2012 : The Eighth International Conference on Wireless and Mobile Communications

update the weighted degrees every iteration. The proposed 
POSU has       registers that store the weight degree 
and its index in one word. As shown in equation (10), the 
degree of the polynomial         will be increased by one 
due to the multiplication by      , whereas the degrees of 
the other polynomials remain the same. 
Figure 8 shows the POSU structure that reorders the 
polynomials by their weighted degrees. The registers consist 
of the       shift registers and each register is partitioned 
to the part for the weighted degrees (  ) and the part for the 
index of the polynomials ( ), where    is initialized to 
                        (  is message symbol,   
is the number of the candidate polynomials) and   is 
initialized to          . The weighted degree    is 
increased by one in case that     and a bubble sort is 
performed to reorder the weighted degrees using comparator 
and shift registers. 
 
 
IV. 
DESIGN AND PERFORMANCE ANALYSIS 
In this section, we apply the proposed architecture to the 
                        defined on       . We 
analyze the proposed architecture in terms of hardware cost, 
latency, and performance and compare it to existing 
architectures. The primitive polynomial used in this paper is 
                  . For fair comparison, we use 
the same experimental condition as that used in [6]. In the 
KV front-end, the maximum multiplicity,     , equals 5, 
using the low complexity method in the case of    . The 
simulation shows the soft-decision decoder with an 
interpolation cost, C = 3,800, can provide more than 0.5dB 
of coding gain at a codeword error rate of      compared 
to the hard-decision decoder [11]. The following equation 
can be applied to estimate the number of bivariate 
polynomials [6]. 
                
      
 
      , 
where Z denotes the set of all integers and C is the cost of 
the interpolation. By applying these parameters to this 
equation, r equals to 5. The re-encoding technique to reduce 
the number of iterations is used to achieve higher throughput. 
The number of iterations when the re-encoding is applied can 
be computed to            
 
            
 
 
   . When    is applied to the interpolation algorithm, the 
number of degrees of   in the polynomials can be 
computed to        
 
     
 
   . The total number 
of latencies is   
  
       , where   is the number of 
clocks to select and control the “pivot” polynomial, 
        in Figure 4. 
 
Table I shows the hardware cost and latency of the 
DCCU and the PUU. The architecture in [5] uses the 
relatively complex dual-port memory. Also, the architectures 
in [5] and [6] divide the memory into        of small 
memory modules that require a bigger area and more 
controls. We expect that the benefit of getting rid of complex 
access control is more than the degradation of power 
consumption and memory access speed. All the required 
coefficients can be read out and stored simultaneously and 
they are fed to the DCC and the PU in an efficient way. Also, 
by utilizing one large memory module with one-port, instead 
of multiple memory banks with dual-ports, the memory 
structure is simplified and efficient. 
 
Table II compares the hardware complexity and the 
performance with the existing architectures. Ahmed, Koetter, 
and Shanbhag use a point-serial algorithm for the 
interpolation and apply a parallelism on polynomials and   
degrees [5]. The point-serial algorithm usually improves the 
performance when the interpolation points have high 
multiplicities. However, the hardware cost of the DCCU also 
increases due to   (          ), which is normally 
greater than  . The architecture proposed by Wang and Ma 
[6] also applies to a parallelism on polynomials and   
degrees and uses a hybrid data format for conversion 
between normal and power representations, so the 
computation complexity between symbols on finite field is 
dramatically reduced. However they need hardware for pre- 
and post-processing for the format conversion, such as a 
look-up table (LUT). 
TABLE II. 
HARDWARE COMPLEXITY AND PERFORMANCE COMPARISON 
Design 
Area 
(# of XOR 
gates 
Critical Path 
(# of gates) Latency Throughput 
(normalized) 
Efficiency 
(normalized) 
[5] 
8535 
12 
1437 
1 
1 
[6] 
11726 
4 
1775 
2.43 
1.77 
[13] 
7872 
10 
916 
1.88 
2.04 
[14] 
10718 
12 
454 
3.17 
2.52 
Proposed 
1321 
4 
10650 
0.4 
2.62 
 
TABLE I. 
HARDWARE COMPLEXITY AND LATENCY OF DCCU AND PUU 
Module 
HW complexity 
Latency 
DCCU 
       multipliers 
     
  
   
       adders 
    
registers 
               
PUU 
       multipliers 
       
  
   
       adders 
      
Registers 
              
Total 
 
 
   
       
 
 
Figure 8.  POSU structure. 
29
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-203-5
ICWMC 2012 : The Eighth International Conference on Wireless and Mobile Communications

A finite field multiplier can be implemented by 64 XOR 
gates and 48 AND gates by employing composite field 
arithmetic, whereas a finite field adder simply requires 8 XOR 
gates. As analyzed in [6], the hardware complexity of the 
interpolation architecture grows linearly with          . 
For fair comparison, the proposed architecture including the 
architectures [5], [6] are scaled down with        since 
     is equal to 2 in the BGMD architectures [13], [14]. 
All possible optimizations have been applied to the 
architectures in [5], [6]. Also, we can apply the pipelining to 
the proposed architecture for further speedup like the 
architecture in [6]. Based on that, the critical path can be 
reduced to the delay of 4 XOR gates. The hardware cost is 
analyzed based on the following assumption. Each AND gate 
or OR gate requires 3/4 of the area of an XOR, each MUX or 
memory cell has the same area as an XOR, and each register 
occupies about 3 times of the area of an XOR. According to 
Table I, the hardware complexity of the proposed 
architecture when        is 5284 in equivalent XOR 
gates including memory. In case of       , the area 
requirement of the proposed architecture is equivalent to that 
of 1321 XOR gates. Since the terms of X degrees are 
processed in serial, the latency of the proposed architecture 
will be increased to the order of      , compared to the 
architecture in [6]. The analysis results for the existing 
architectures in Table II can be found in the paper [14]. Even 
though the throughput is relatively low, the efficiency is 
highest among the architectures in Table II. 
 
 
The proposed interpolation architecture for the (255, 239) 
RS list decoder is designed with VerilogHDL and 
synthesized using a DongbuAnam 0.18 ㎛ standard cell 
library. Table III shows the synthesized gate count for the 
functional blocks in the proposed interpolation architecture. 
We use                    and     as the 
design parameters. The maximum operating clock frequency 
is 200MHz and the synthesized gate count is about 25.1K 
gates in two-input equivalent NAND gates. 
V. 
CONCLUSIONS 
In this paper, we proposed an efficient architecture with 
low hardware complexity for interpolation in soft-decision 
list decoding of Reed-Solomon codes. The proposed 
architecture has several advantages over the existing 
architectures in the following view points: 1) it employs 
parallel processing only for   degrees in bivariate 
polynomial         and shares hardware modules, thus 
reducing the hardware complexity; 2) the schedule is 
adaptively adjusted according to the “pivot” polynomial 
computed at each iteration, so the irregular memory access 
problem is resolved; 3) the number of internal registers is 
reduced by processing the polynomial monomially; 4) 
scheduling minimizes the number of memory accesses and 
simplifies the memory structure by combining and storing 
data in memory, and the proposed architecture consists of 
one-port memory and one bank of memory and is efficient in 
area; 5) the DCCU and the PUU in the proposed architecture 
are overlapped in schedule, so the total latency is reduced. 
The proposed interpolation architecture for the (255, 239) RS 
list decoder is designed with VerilogHDL in a ModelSim 
environment. After logic synthesis, using the DonbuAnam 
0.18um standard cell library, the maximum operating clock 
frequency is 200MHz and the synthesized gate count is about 
25.1K gates in two-input equivalent NAND gates. 
ACKNOWLEDGMENT 
We are grateful to the IC Design Education Center that 
provided us with a design environment. 
REFERENCES 
[1] R. E. Blahut, Theory and practice of Error Control Codes, Addison-
Wesley, Reading MA, 1983. 
[2] V. Guruswami and M. Sudan, "Improved decoding of Reed-Solomon 
and algebraic-geometric codes," IEEE Trans. Inf. Theory, vol. 45, no. 
6, pp. 1755-1764, Sep. 1999. 
[3] R. Koetter and A. Vardy, "Algebraic soft-decision decoding of Reed-
Solomon codes," IEEE Trans. Inf. Theory, vol. 49, no. 11, pp. 2809-
2825, Nov. 2003. 
[4] R. Koetter, J. Ma, A. Vardy and A. Ahmed, "Efficient interpolation 
and factorization in algebraic soft decision decoding of Reed-
Solomon codes," in Proc. of IEEE Symp. On Info. Theory, 2003. 
[5] A. Ahmed, R. Koetter, and N. Shanbhag, "VLSI architectures for 
soft-decision decoding of Reed-Solomon codes," in Proc. ICC, pp. 
2584-2590, 2004. 
[6] Z. Wang and J. Ma, "High-speed interpolation architecture for soft-
decision decoding of Reed-Solomon codes," IEEE Trans. VLSI 
systems, vol. 14, no. 9, pp. 937-950, Sep. 2006. 
[7] W. J. Gross, F. R. Kschischang, and P. Gulak, "Architecture and 
implementation of an interpolation processor for soft-decision Reed-
solomon decoding," IEEE Trans. VLSI systems, vol. 15, no. 3, pp. 
309-318, Mar. 2007. 
[8] W. J. Gross, F. R. Kschsichang, R. Koetter, and P. G. Gulak, "A 
VLSI architecture for interpolation in soft decision list decoding of 
Reed-Solomon codes," in Proc. of IEEE Workshop on Signal 
Processing Systems, 2002. 
[9] A. Ahmed, R. Koetter, and N. Shanbhag, "Systolic interpolation 
architectures for soft-decoding Reed-Solomon codes," in Proc. IEEE 
Workshop Signal Process. Syst., pp. 81-86, 2003. 
[10] G. L. Feng and K. K. Tzeng, "A generalization of the Berlekamp-
Massey algorithm for multisequence shift-register synthesis with 
applications to decoding cyclic codes," IEEE Trans. Inf. Theory, vol. 
37, no. 5, pp. 1274-1287, Sep. 1991. 
[11] H. Hasse, "Theorie der Hoheren differentiale in einem algebraischen 
funktionenkorper mit vollkommenem konstantenkorper bei beliebiger 
charakteristik," J. Reine. Ang. Math., vol. 175, pp. 50-54, 1936. 
[12] V. C. da Rocha Jr., "Digital sequences and the Hasse derivative," in 
Communications Coding and Signal Processing, B. Honary, M. 
Darnell, and P. Farrell (Eds.), Communication Theory and 
Applications, John Wiley and Sons Inc., vol. 4, pp. 256-268, 1997. 
[13] J. Zhu, X. Zhang, and Z. Wang "Backward interpolation architecture 
for algebraic soft-decision Reed–Solomon decoding," IEEE Trans. 
VLSI systems, vol. 17, no. 11, pp. 1602-1615, Nov. 2009. 
[14] X. Zhang and J. Zhu, "High-throughput interpolation architecture for 
algebraic soft-decision Reed–Solomon decoding," IEEE Trans. 
Circuits and systems, vol. 57, no. 3, pp. 581-591, Mar. 2010. 
TABLE III. RESULTS OF DESIGN AND SYNTHESIS 
parameters 
performance 
C 
     r 
  
total latency 
Max clock freq. 
239 
5 
5 
4 
29636 
200 Mhz 
 
 
DCCU 
PUU 
control 
total 
gate count 
7K 
11K 
7.1K 
25.1K 
 
30
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-203-5
ICWMC 2012 : The Eighth International Conference on Wireless and Mobile Communications

