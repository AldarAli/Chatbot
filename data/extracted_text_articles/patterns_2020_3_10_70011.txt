Pattern-based Deployment Models Revisited:
Automated Pattern-driven Deployment Conï¬guration
Lukas Harzenetter, Uwe BreitenbÃ¼cher, Michael Falkenthal, Jasmin Guth, and Frank Leymann
Institute of Architecture of Application Systems (IAAS), University of Stuttgart
UniversitÃ¤tsstrasse 38, 70569 Stuttgart, Germany
Email: {harzenetter, breitenbuecher, falkenthal, guth, leymann}@iaas.uni-stuttgart.de
Abstractâ€”The manual deployment of cloud applications is
error-prone and requires signiï¬cant expertise. Therefore, many
deployment automation technologies have been developed that
enable deploying applications fully automatically by processing
deployment models. However, while these technologies substan-
tially simplify deployment, the manual creation of deployment
models ironically poses similar challenges to manually deploying
applications as technical expertise about the components to be
deployed and their dependencies is required. Therefore, we intro-
duced Pattern-based Deployment Models (PbDMs) in a previous
work that allow using design patterns to model components in
an abstract manner, which are then automatically replaced by
concrete technologies. However, in many scenarios, the resulting
deployment models still have to be subsequently adapted with
regard to the conï¬guration of the selected technologies, e. g.,
to conï¬gure a selected Platform as a Service (PaaS) offering,
such as Amazon Beanstalk, for optimal scaling. Therefore, while
our previous work only enables using design patterns to model
components, in this paper we extend the proposed meta-model
and algorithms by the possibility to specify behavioral aspects of
components and relations also in the form of patterns. Moreover,
we show how these annotated patterns can be automatically
transformed into concrete conï¬gurations that reï¬‚ect their se-
mantics. We present a prototype and a case study to validate
the extensionâ€™s practical feasibility.
Keywords-Deployment Automation; Deployment Modeling; Pat-
terns; Model-driven Architecture; TOSCA.
I. INTRODUCTION
Automating the deployment of applications is of vital impor-
tance as manual deployment is error-prone, time-consuming,
and requires a signiï¬cant amount of technical expertise [1].
Therefore, several deployment automation technologies, such
as Chef, Terraform, or Kubernetes, have been developed to
automate the deployment of applications. The majority of these
technologies use declarative deployment models to describe the
structure of an application to be deployed [2]. These models
specify all components of the application to be deployed,
their conï¬gurations, as well as their dependencies among
each other [3]. For example, to describe the deployment of
a Java 8 based application, a declarative deployment model
may specify its components as follows: The application itself
may be described as an instance of a Java 8 Web App that is
hosted on an Amazon Elastic Beanstalk Environment to enable
its automatic scaling. Additionally, it may be connected to
a MySQL 5.7 database that is installed on an Ubuntu 18.04
Virtual Machine (VM) running on an Amazon EC2 instance.
However, while deployment technologies are an established
means, the manual creation of deployment models ironically
poses similar challenges to manually deploying applications:
First, (i) modelers are required to have signiï¬cant technical
expertise in selecting appropriate components, such as web
servers or operating systems. For example, considering the
example, a modeler has to know which web servers supported
by Beanstalk are able to run Java 8 Web Apps. This often results
in (ii) error-prone modeling that requires testing the created
models multiple times, which quickly becomes a (iii) time-
consuming task. To tackle these issues, we introduced Pattern-
based Deployment Models (PbDM) in a previous work [4],
whereby we used patterns as ï¬rst-class citizens in a declarative
deployment model to describe components in an abstract
manner. For example, instead of specifying a concrete web
server for Beanstalk to run the Java 8 Web App, in a PbDM
only the Platform as a Service (PaaS) pattern [5] needs to
be modeled. Moreover, since PbDM cannot be executed as
they only specify abstract semantics instead of executable
technologies, we also presented algorithms to automatically
reï¬ne all patterns in a PbDM to concrete technologies [4].
However, in many scenarios, the resulting deployment models
have to be adapted with regard to the conï¬guration of the
reï¬ned components, e. g., to conï¬gure the scaling behavior of
Beanstalk. Unfortunately, this again requires technical expertise
and is error-prone. The reason for these problems is that only
components are abstracted by patterns, not their conï¬guration.
Therefore, we extend our proposed meta-model for PbDMs
in this paper by the possibility to specify also behavioral
requirements for components and relations in the form of
abstract patterns. For example, instead of providing a con-
crete conï¬guration of Beanstalkâ€™s scaling behavior, our new
approach enables the annotation of the Unpredictable Workload
Pattern [5] to the Java Web App, which implies that the
underlying infrastructure needs to be elastic, but without the
need to specify any technical conï¬guration. Moreover, we also
extend the reï¬nement algorithms to support reï¬ning patterns
annotated at components and relations. We validate the practical
feasibility of the approach by a case study and a prototype.
Hereafter, Section II describes fundamentals, Sections III
and IV introduce the new concepts while Sections V and VI
explain our case study and prototype. Finally, Section VII
describes related work and Section VIII concludes the paper.
40
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

Order App
(Java 8 Web App)
Order Processor
(Java 8 App)
AutoScaling:
true
ScalingMetric:
NetOut
TimeSpan:
5min
[â€¦]
Order PaaS
(AWS Webserver Env)
Account:
ust-iaas
[â€¦]
PaaS Provider
(Elastic Beanstalk)
AutoScaling:
true
ScalingMetric:
NetOut
TimeSpan:
5min
[â€¦]
Processor PaaS
(AWS Worker Env)
= hostedOn
= Secure-JMS-2.0-Queue-
Connection
Account:
ust-iaas
[â€¦]
PaaS Provider
(Elastic Beanstalk)
Type:
FIFO
Server-Side
Encryption:
Yes
Master-Key:
Default
Queue
(SQS Queue)
Account:
ust-iaas
[â€¦]
MoM Provider
(Simple Queue Service)
Figure 1. A declarative deployment model.
II. FUNDAMENTALS AND MOTIVATION
In this section, we introduce deployment automation concepts
and technologies, as well as our motivating scenario.
A. Deployment Models and Automation
To automate the deployment of applications, many deploy-
ment automation technologies have been developed. Most of
these technologies use Deployment Models to describe the
desired application [3]. Deployment models can be categorized
into two types: (i) declarative deployment models and (ii) imper-
ative deployment models [3]. An imperative deployment model
describes how a deployment is performed as an executable
process including all technical activities and their execution
order [3]. In contrast, a declarative deployment model describes
what has to be achieved but provides no executable process.
Thus, a deployment technology must interpret declarative
models and derive the necessary steps [3]. In this paper, we
focus on declarative models as they are (i) supported by various
deployment technologies [2] and (ii) can be automatically
transformed to imperative deployment models [1].
Declarative models state the desired outcome of a deploy-
ment in the form of the applicationâ€™s structure encompassing
the components of the application, their conï¬gurations, and
the dependencies between them [3]. An example consisting
of components, relations, and their properties is depicted in
Figure 1. It illustrates a frontend component called Order App
and a backend component called Order Processor, both hosted
on Elastic Beanstalk Environments. The Elastic Beanstalk
Environments are conï¬gured to scale automatically, which
is indicated by their â€œAutoScalingâ€ properties. To communicate
to another, the applications use a Queue that is hosted on the
Simple Queue Service (SQS), whereas the Order App expects
that each order is delivered and processed exactly once, which is
hereby ensured by a queue of type â€œFIFOâ€. Finally, the types of
the components and relations are shown. The component types
are depicted in braces, while the relation types are encoded by
their stroke type and color. Thus, the Order App, e. g., is an
instance of the Java 8 Web App while its relation to the Queue
is of type Secure-JMS-2.0-Queue-Connection.
Order App
(Java 8 Web App)
Order Processor
(Java 8 App)
Point-to-Point 
Channel
Message-
oriented 
Middleware
Platform as a 
Service
Public 
Cloud
= hostedOn
= JMS-2.0-Queue-Connection
Figure 2. A Pattern-based Deployment Model (PbDM).
B. Pattern-based Deployment Models
However, even the creation of such simple models poses
several challenges as it requires technical expertise in different
technologies. For instance, it must be known whether Beanstalk
supports Java 8 and which environment is appropriate, or
whether an SQS Queue can be used at all since the apps require
JMS connections. Thus, to reduce the modeling complexity,
we previously introduced Pattern-based Deployment Models
(PbDM) [4], which use Design Patterns [6] as ï¬rst class model
elements. Figure 2 shows an example PbDM representing the
abstract semantics of the deployment shown in Figure 1. Herein,
the Cloud Computing Patterns [5] and Enterprise Integration
Patterns [7] are used to represent components in an abstract,
technology-agnostic way: Instead of specifying concrete ser-
vices, such as Beanstalk and SQS, the applications are hosted on
Platform as a Service (PaaS) patterns [5] while a Point-to-Point
Channel pattern [7] is used for communication that is hosted on
a Message-oriented Middleware (MoM) pattern [5]. Thus, this
model contains no details about technologies but only speciï¬es
the abstract semantics of the required components in the form
of patterns, which is less error-prone and requires less technical
expertise. We refer to patterns that represent the semantics
of components as Component Patterns. Moreover, we also
presented reï¬nement algorithms [4] that replace Component
Patterns with concrete technologies and providers.
However, in many cases, the reï¬ned deployment model
requires additional manual conï¬guration: For example, as
the Order Appâ€™s workload is unpredictable, the Beanstalk
environment must be conï¬gured for automated scaling by
specifying the â€œScalingMetricâ€ and the â€œTimeSpanâ€ to deï¬ne
when scaling will be triggered. Additionally, the Order App
requires the orders to be processed exactly once by the Order
Processor. Thus, the modeler has to select the correct queue
type, i. e., in the context of SQS â€œFIFOâ€ instead of â€œStandardâ€.
Another difï¬culty often results from compliance requirements:
If the orders issued by the Order App contain sensitive data, the
communication between the applications must be secured using
â€œServer-Side Encryptionâ€ and a â€œMaster-Keyâ€. However, to
conï¬gure all components and relations correctly via properties,
immense technical expertise is required on each employed
technology and again results in an error-prone and time-
consuming model conï¬guration step.
41
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

Order App
(Java 8 Web App)
Order Processor
(Java 8 App)
Point-to-Point
Channel
Message-
oriented
Middleware
Platform as
a Service
Public
Cloud
Relational
Database
Private
Cloud
= hostedOn
= JMS-2.0-Queue-Connection
= SQL-Connection
Secure
Channel
Unpredictable
Workload
Static
Workload
Management UI
(Java 8 Web App)
Stateless
Component
Execution
Environment
=1
Exactly-once
Delivery
Information
Obscurity
User Interface
Component
Processing
Component
Figure 3. A Pattern-based Deployment and Conï¬guration Model (PbDCM) following the metamodel deï¬ned in Figure 4.
III. PATTERN-BASED DEPLOYMENT AND
CONFIGURATION MODELS
To tackle the issue of subsequent manual model conï¬gura-
tion, our ï¬rst contribution is an extension of PbDMs to Pattern-
based Deployment and Conï¬guration Models (PbDCMs), which
support annotating Behavior Patterns [8] to components and
relations to describe their desired behavior in an abstract way.
To provide the basis for demonstrating our new approach
in a more complex case study, we ï¬rst enlarge our motivating
scenario as shown in Figure 3: We add the Relational Database
Component Pattern [5] to store the results from the Processor
as well as a management component called Management
UI to maintain the database, which is hosted on Execution
Environment [5] and Private Cloud [5] Component Patterns.
A. Overview of the Modeling Extension
To compensate the shortcomings, we extend PbDMs to
Pattern-based Deployment and Conï¬guration Models: Instead
of using patterns only to abstract components by Component
Patterns, we extend the metamodel to also allow annotating
Behavior Patterns to components and relations: A Behavior
Pattern abstractly describes behavioral requirements that must
be respected by the deployment, e.g., that a component has to
handle unpredictable workload. Figure 3 shows a PbDCM in
which both apps have been annotated with Behavior Patterns,
e.g., the Unpredictable Workload which implies the need for
automatic scaling. To secure communication and to encrypt the
storage, the relations between the applications are annotated
with the Secure Channel pattern [9], while the Relational
Database and the Point-to-Point Channel are annotated with the
Information Obscurity pattern [9]. To ensure that the orders are
processed only once, the Point-to-Point Channel is annotated
with the Exactly-once Delivery pattern [5]. Moreover, patterns
may specify additional semantics, e.g., the Stateless Component,
the User Interface Component and the Processing Component
patterns [5]. Thus, instead of specifying all technical conï¬g-
urations that realize these behaviors manually, our extension
only requires to annotate desired behavior of components and
relations in the form of Behavior Patterns.
B. Metamodel Extensions for PbDCMs
In this section, we describe the formal metamodel for
PbDCMs, which is graphically illustrated in Figure 4. Hereby,
the original PbDM metamodel [4] is extended by the grey
elements, which provide the capabilities to deï¬ne Behavior
Pattern types and to annotate them to components and relations.
The new PbDCM metamodel and the original metamodel are
based on the Essential Deployment Metamodel (EDMM) [2],
which is a normalized metamodel that has been extracted
from the 13 most used deployment technologies including,
e. g., Terraform and the Topology Orchestration Speciï¬cation
for Cloud Applications (TOSCA) [10]. We use EDMM as
basis metamodel to describe our approach in a technology-
agnostic way instead of extending only one certain deployment
technology. Since Section IV describes how PbDCMs can
be automatically transformed into EDMM-compliant models
containing only standard EDMM modeling constructs, the
extension of EDMM only affects the design time while the
reï¬ned models can be directly translated into any of the 13
supported deployment technologies that can be mapped to
EDMM. To demonstrate the approachâ€™s practical feasibility,
we show how the PbDCM metamodel can be realized using
the TOSCA standard and how the models reï¬ned by our
algorithms presented in Section IV can be consumed by a
standard-compliant TOSCA runtime. Let ğ’¯ be the set of all
PbDCMs, then ğ‘¡ âˆˆ ğ’¯ is deï¬ned as a ï¬fteen-tuple as follows:
ğ‘¡ = (Ct, Rt, CPt, CBPt, RBPt, CTt, RTt, CPTt, CBPTt,
RBPTt, PROPt, typet, supertypet, propertiest, annotationst)
1) Basis of the Metamodel: Following EDMM, a deployment
model is a directed, weighted graph, in which nodes represent
components, edges their relations. Components and relations
are typed and specify properties to conï¬gure the deployment.
EDMM deï¬nes more elements, such as Operations, which are,
however, not affected by our approach. Thus, we omit them for
the sake of simplicity. Our previous work of PbDMs extends
this metamodel by Component Patterns that can be used as
nodes [4]. Thus, the following elements of ğ‘¡ are already deï¬ned
by EDMM [2] and the metamodel of PbDMs [4]:
42
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

Relation 
Type
Component
Type
Model 
Element
Model Element 
Type
Pattern Type
Behavior 
Pattern
Property
Component 
Pattern Type
Relation 
Behavior 
Pattern Type
Component
Behavior
Pattern Type
Relation Behavior 
Pattern
Component
has
is of type
is source of
is target of
annotated by
is of type
is of type
is of type
is of type
annotated by
Component 
Pattern
has
Model Node
Component 
Behavior Pattern
Relation
Structure 
Element
Figure 4. Metamodel of Pattern-based Deployment and Conï¬guration Models (extensions to PbDMs are highlighted in grey).
âˆ™ ğ¶ğ‘¡ is the set of Components in ğ‘¡. A Component ğ‘ğ‘– âˆˆ ğ¶ğ‘¡
is a physical, functional, or logical unit of an application.
âˆ™ CPt is the set of Component Patterns in ğ‘¡. A cpi âˆˆ CPt
describes a Component Pattern that must be reï¬ned to a
concrete Component before the applicationâ€™s deployment.
âˆ™ The union of Components ğ¶ğ‘¡ and Component Patterns
CPt form the set of Model Nodes in ğ‘¡: MNt := ğ¶ğ‘¡ âˆªCPt.
âˆ™ ğ‘…ğ‘¡ âŠ† MNt Ã— MNt represents the set of Relations in ğ‘¡.
A Relation ğ‘Ÿğ‘– = (mnsource, mntarget) âˆˆ ğ‘…ğ‘¡ is a directed
physical, functional, or logical dependency between ex-
actly two Model Nodes mnsource, mntarget âˆˆ MNt, where
mnsource is the source and mntarget the target Model Node
of the Relation.
âˆ™ CTt is the set of Component Types in ğ‘¡. A Component
Type cti âˆˆ CTt speciï¬es the semantics of a Component
ğ‘ğ‘— âˆˆ ğ¶ğ‘¡ that has this type assigned.
âˆ™ CPTt is the set of Component Pattern Types in ğ‘¡. A
Component Pattern Type cpti âˆˆ CPTt speciï¬es the
semantics of a Component Pattern cpj âˆˆ CPt that has
this type assigned.
âˆ™ ğ‘…ğ‘‡ğ‘¡ is the set of Relation Types in ğ‘¡. A Relation Type
ğ‘Ÿğ‘¡ğ‘– âˆˆ ğ‘…ğ‘‡ğ‘¡ speciï¬es the semantics of a Relation ğ‘Ÿğ‘— âˆˆ ğ‘…ğ‘¡
that has this type assigned.
âˆ™ PROPt âŠ† ğ›´+ Ã— ğ›´+ is the set of Properties in ğ‘¡. A
Property ğ‘ğ‘Ÿğ‘– = (Key, Value) âˆˆ PROPt describes the
conï¬guration of a Component, Relation, Pattern, or their
types. Its initial value is deï¬ned to be the Empty Word ğœ€.
2) Extension for Behavior Patterns:
âˆ™ CBPt is the set of Component Behavior Patterns in ğ‘¡. A
ğ‘ğ‘ğ‘ğ‘– âˆˆ CBPt represents a pattern annotated to a Model
Node describing its desired behavior in an abstract way.
âˆ™ RBPt is the set of Relation Behavior Patterns in ğ‘¡. A
ğ‘Ÿğ‘ğ‘ğ‘– âˆˆ RBPt represents a pattern that is annotated to a
Relation describing its behavior in an abstract way.
âˆ™ CBPTt is the set of Component Behavior Pattern Types
in ğ‘¡. A cbpti âˆˆ CBPTt speciï¬es the semantics of a
Component Behavior Pattern cbpj âˆˆ CBPt that has this
type assigend.
âˆ™ RBPTt is the set of Relation Behavior Pattern Types in ğ‘¡.
A ğ‘Ÿğ‘ğ‘ğ‘¡ğ‘– âˆˆ RBPTt speciï¬es the semantics of a Relation
Behavior Pattern rbpj âˆˆ RBPt that has this type assigned.
âˆ™ The union set SEt := ğ‘…ğ‘¡ âˆª MNt contains all Structure
Elements in ğ‘¡, while the union set BPt := CBPt âˆª RBPt
contains all Behavior Patterns in ğ‘¡.
âˆ™ The union of all Structure Elements ğ‘†ğ¸ğ‘¡ and Behavior
Patterns BPt form the set of Model Elements MEt in ğ‘¡:
MEt := SEt âˆª BPt.
âˆ™ The union set METt := CTt âˆª RTt âˆª CPTt âˆª CBPTt âˆª
RBPTt contains all Model Element Types in ğ‘¡.
âˆ™ ğ‘ğ‘›ğ‘›ğ‘œğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ ğ‘¡ is the map that assigns a Structure Element
sei âˆˆ SEt to its set of annotated Behavior Patterns.
ğ‘ğ‘›ğ‘›ğ‘œğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ ğ‘¡ : SEt â†’ â„˜(BPt)
(1)
The following maps are already deï¬ned by EDMM [2]
and PbDMs [4]. Since we extended MEt and METt, their
mapping now include also Behavior Patterns and Behavior
Pattern Types:
âˆ™ ğ‘¡ğ‘¦ğ‘ğ‘’ğ‘¡ is a map that assigns all Model Elements ğ‘šğ‘’ğ‘– âˆˆ
MEt to their respective Model Element Type ğ‘šğ‘’ğ‘¡ğ‘— âˆˆ
METt providing the semantics for the Model Element:
ğ‘¡ğ‘¦ğ‘ğ‘’ğ‘¡ : MEt â†’ METt
(2)
âˆ™ ğ‘ ğ‘¢ğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘¦ğ‘ğ‘’ğ‘¡ is the map that assigns each Model Element
Type to its respective supertype. It associates a ğ‘šğ‘’ğ‘¡ğ‘– âˆˆ
METt with a ğ‘šğ‘’ğ‘¡ğ‘— âˆˆ METt where ğ‘– Ì¸= ğ‘—, i. e., that ğ‘šğ‘’ğ‘¡ğ‘—
is the supertype of ğ‘šğ‘’ğ‘¡ğ‘–.
ğ‘ ğ‘¢ğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘¦ğ‘ğ‘’ğ‘¡ : METt â†’ METt
(3)
âˆ™ Additionally, ğ‘ ğ‘¢ğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘¦ğ‘ğ‘’ğ‘ ğ‘¡ assigns a Model Element Type
ğ‘šğ‘’ğ‘¡ğ‘– âˆˆ METt to all of its supertypes that can be
transitively resolved. Thus, ğ‘ ğ‘¢ğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘¦ğ‘ğ‘’ğ‘ ğ‘¡ is deï¬ned as:
ğ‘ ğ‘¢ğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘¦ğ‘ğ‘’ğ‘ ğ‘¡ : METt â†’ â„˜(METt)
(4)
âˆ™ ğ‘ğ‘Ÿğ‘œğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘–ğ‘’ğ‘ ğ‘¡ is the map that assigns each ğ‘šğ‘’ğ‘¡ğ‘– âˆˆ METt
and ğ‘šğ‘’ğ‘— âˆˆ MEt its corresponding set of Properties.
ğ‘ğ‘Ÿğ‘œğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘–ğ‘’ğ‘ ğ‘¡ : METt âˆª MEt â†’ â„˜(PROPt)
(5)
43
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

Pattern-based 
Deployment 
Model
1
Executable
Deployment
Model
PRMs
Repository
2
Figure 5. Reï¬nement of PbDMs to executable models [4].
IV. AUTOMATIC REFINEMENT TO EXECUTABLE
DEPLOYMENT MODELS
PbDCMs are not executable as the contained patterns
only specify abstract semantics. Thus, to get an Executable
Deployment Model, all Component Patterns need to be replaced
by concrete Components and the additional semantics speciï¬ed
by the annotated Behavior Patterns must be considered by
conï¬guring the affected Components and Relations correctly.
In our previous work [4], we presented Pattern Reï¬nement
Models (PRMs) and corresponding reï¬nement algorithms to
replace Component Patterns by concrete Components.
A. Pattern Reï¬nement Models (PRMs)
To deploy a PbDM, we introduced algorithms to automati-
cally replace Component Patterns by concrete technologies [4].
Hereby, Pattern Reï¬nement Models (PRMs) deï¬ne how Com-
ponent Patterns can be reï¬ned to concrete components [4]. As
illustrated in Figure 5, the reï¬nement is an semi-automated,
iterative process: All PRMs contained in a repository are
analyzed whether they can reï¬ne certain Component Patterns
contained in the PbDM to concrete Components. Appropriate
PRMs are selected manually and automatically applied until
the PbDM contains no more patterns resulting in an Executable
Deployment Model, which requires only small manual additions.
A PRM consists of (i) a Detector, (ii) a Reï¬nement Structure,
and (iii) a set of Relation Mappings. The Detector is a PbDM
fragment that speciï¬es the structure of Component Patterns and
their Relations the PRM can reï¬ne to concrete Components.
Thus, if a fragment of a Detector matches a fragment in a
PbDM, this PRM can reï¬ne exactly the matching subgraph.
The Reï¬nement Structure speciï¬es how the Detector fragment
can be reï¬ned to concrete Components and Relations. Hence, if
a fragment in a PbDM matches a Detector fragment of a PRM,
the PbDM fragment can be reï¬ned to the fragment speciï¬ed in
the PRMâ€™s Reï¬nement Structure. For example, Figure 6 shows
a PRM that reï¬nes the PaaS and the Public Cloud patterns to
a concrete Webserver Environment hosted on AWS Beanstalk.
Moreover, to handle external relations of the mapped
Detector fragment, we introduced Relation Mappings [4]
deï¬ning which type of relations can be redirected from which
Model Node in the Detector to which Model Node in the
Reï¬nement Structure. For example, the Relation Mapping in
Figure 6 redirects all incoming Relations of type hostedOn
that target the Public Cloud Component Pattern and that are
not contained in the Detector to the Public Cloud Component.
CBPRM Extensions
(Java 8 Web App)
[â€¦]
PaaS Provider
(Elastic Beanstalk)
[â€¦]
Pulblic Cloud
(AWS)
(Java 8 Web App)
RelationType : hostedOn
Direction: ingoing
SourceType : *
RelationMapping
Stay
Mappings
Reï¬nement
Structure
AutoScaling:
true
ScalingMetric:
NetOut
TimeSpan:
5min
[â€¦]
PaaS
(AWS Webserver Env)
Detector
Figure 6. Exemplary CBPRM respecting Behavior Patterns.
B. Component and Behavior Pattern Reï¬nement Models
(CBPRMs)
In the original approach [4], PRMs were only used to
reï¬ne Component Patterns by concrete Components. Therefore,
Detector fragments of PRMs contained only Component
Patterns and their Relations, but no business components as
they were not affected by the reï¬nement. Thus, only Component
Patterns are considered if a PRM is applicable or not. However,
our extended approach must consider Behavior Patterns that
are attached to business Components or Relations, such as
the Java 8 Web App shown in Figure 6. Hence, we extend
PRMs to Component and Behavior Pattern Reï¬nement Models
(CBPRMs) to also support the reï¬nement of Behavior Patterns.
The extension requires two changes: First, PRMs must be
extended to use PbDCM fragments as Detector and Reï¬nement
Structure instead of PbDM fragments. Second, to consider
Behavior Patterns during the reï¬nement, also the affected
business components must be modeled in the Detector to
deï¬ne which Behavior Patterns a CBPRM considers. This
is, for example, shown in Figure 6: Herein, also the business
Component Java 8 Web App is modeled in the CBPRM Detector
including the two Component Behavior Patterns Unpredictable
Workload and Stateless Component. This business Component
is hosted on Platform as a Service and Public Cloud Component
Patterns. Thus, this Detector speciï¬es that the PaaS and Public
Cloud Component Patterns can be reï¬ned by this CBPRM in a
way that it respects the Behavior Patterns annotated at the Java
8 Web App, i.e. that its Reï¬nement Structure is able to handle
unpredictable workloads of stateless Java 8 Web Apps. Hence,
this Detector is reï¬ned to an elastic PaaS-based solution on
AWS including all required conï¬guration properties, e. g., it
speciï¬es the â€œAutoScalingâ€, â€œScalingMetricâ€, and â€œTimeSpanâ€
Properties of Beanstalk to dynamically scale the application.
Thus, when applying such a CBPRM, all annotated Behavior
Patterns in the Detector must be considered by the Reï¬nement
Structure. Thereby, the Reï¬nement Structure must not contain
any of the Detectorâ€™s or new patterns. Thus, each CBPRM
removes the patterns it reï¬nes from the PbDCM model.
44
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

Detector
Reï¬nement Structure
(ApplicaÆŸon)
Stay
(Database)
Stay
= Secure-SQL-ConnecÆŸon
= SQL-ConnecÆŸon
(ApplicaÆŸon)
(Database)
Figure 7. Exemplary CBPRM that reï¬nes Relations.
However, while business Components and their conï¬guration
Properties must not be changed during the reï¬nement of
Component Patterns, their annotated Behavior Patterns must
be considered. Therefore, we introduce Stay Mappings as a
second extension to PRMs, which state that a Model Node in a
PbDCM mapping to a â€œstayingâ€ Model Node in the CBPRMâ€™s
Detector must not be changed. For example, Figure 6 speciï¬es
that if the Detector can be mapped to a subgraph in the PbDCM,
the Model Node of the PbDCM mapping to the Java 8 Web
App of the Detector must stay as is, i.e., neither its type nor
its conï¬guration must change. Thus, business Components
are essential to specify the pattern-component constellations
a CBPRM can reï¬ne. For example, the CBPRM shown in
Figure 6 states that it is able to reï¬ne Java 8 Web Apps
hosted on PaaS and Public Cloud Component Patterns while
considering the annotated Unpredictable Workload and Stateless
Component Component Behavior Patterns. To specify where
business Components will be located in the PbDCM after
their annotated Component Behavior Patterns are reï¬ned, Stay
Mappings are deï¬ned in CBPRMs. Hence, Stay Mappings are
only required if Behavior Patterns are reï¬ned by a CBPRM.
Moreover, Stay Mappings enable the deï¬nition of CBPRMs
that only reï¬ne a Relation between two Model Nodes that is
annotated with a Relation Behavior Pattern. For example, as
illustrated in Figure 7, it is possible to reï¬ne a SQL-Connection
annotated with the Secure Channel pattern [9] between an
application and a database to a Secure-SQL-Connection without
changing neither the application nor the database. Thus, the
application and the database stay in the given PbDCM while
their Relation gets reï¬ned to a more concrete Relation Type.
C. Metamodel for CBPRMs
In the following, the metamodel for Component and Behavior
Pattern Reï¬nement Models is deï¬ned based on PRMs [4]. Let
CBPRM be the set of all Component and Behavior Pattern
Reï¬nement Models, then a cbprm âˆˆ CBPRM is a four-tuple:
ğ‘ğ‘ğ‘ğ‘Ÿğ‘š = (ğ‘‘cbprm, ğ‘Ÿğ‘ cbprm, ğ‘…ğ‘€cbprm, ğ‘†cbprm)
(6)
The original metamodel of PRMs [4] is adopted for CBPRMs
by exchanging PbDMs by PbDCMs as follows:
âˆ™ ğ‘‘cbprm âˆˆ ğ’¯ is a PbDCM fragment describing the Detector
which can be reï¬ned by this CBPRM.
âˆ™ ğ‘Ÿğ‘ cbprm âˆˆ ğ’¯ is a PbDCM fragment that describes the
Reï¬nement Structure that reï¬nes the Detector fragment.
âˆ™ ğ‘…ğ‘€cbprm is the set of Relation Mappings describing
the rules how external relations of Model Nodes in
the Detector must be redirected to Model Nodes in the
Reï¬nement Structure. A ğ‘Ÿğ‘šğ‘– âˆˆ ğ‘…ğ‘€cbprm is deï¬ned as:
ğ‘Ÿğ‘šğ‘– = (ğ‘šğ‘›1, ğ‘šğ‘›2, ğ‘Ÿğ‘¡, directionrt, ğ‘£ğ‘¡)
(7)
Herein, ğ‘šğ‘›1 âˆˆ MN ğ‘‘cbprm and mn2
âˆˆ MN rscbprm are
Model Nodes of the Detector ğ‘‘cbprm and the Reï¬nement
Structure ğ‘Ÿğ‘ cbprm. ğ‘Ÿğ‘¡ âˆˆ ğ‘…ğ‘‡ is the Relation Type of an
external Relation that targets or sources the Model Node
matching ğ‘šğ‘›1, while the Relationâ€™s direction is deï¬ned as
directionrt âˆˆ {ingoing, outgoing}. ğ‘£ğ‘¡ âˆˆ ğ¶ğ‘‡ âˆªğ¶ğ‘ƒğ‘‡ speciï¬es
the valid type of the Relationâ€™s source Model Node, if it
is ingoing, or target Model Node otherwise. To also reï¬ne
Behavior Patterns, we introduce Stay Mappings in CBPRMs:
âˆ™ ğ‘†cbprm is the set of Stay Mappings. A Stay Mapping
ğ‘ ğ‘– = (mn1, mn2) âˆˆ ğ‘†cbprm is a pair of Model Modes,
whereby mn1 âˆˆ MNdcbprm is matching a Model Node in a
PbDCM that must stay as is at the place of the Reï¬nement
Structureâ€™s Model Node mn2 âˆˆ MNrscbprm.
D. Reï¬nement Step 1: CBPRM Selection
Following our original approach [4], to reï¬ne Component
Patterns in a PbDM, ï¬rst all applicable PRMs are determined.
A PRM is applicable iff (i) its Detector fragment can be found
as a subgraph of compatible Structure Elements in the PbDM
and (ii) all external Relations of all mapped Model Nodes
in the PbDM can be redirected by the CBPRMâ€™s Relation
Mappings [4]. To ï¬nd two compatible Structure Elements their
types and annotated Behavior Patterns must be considered.
Thus, a Structure Element in a CBPRMâ€™s Detector is only
compatible to a Structure Element in a PbDCM iff (i) their
types are compatible and (ii) all Behavior Patterns the CBPRM
deï¬nes in its Detector are also annotated at a matching Structure
Element in the PbDCM. To determine the compatibility of two
Structure Elements in our algorithms, we introduce a formal
Compatibility Rule similarly to BreitenbÃ¼cher [11]: A Structure
Element se1 âˆˆ ğ‘†ğ¸ğ‘‘cbprm of a Detector ğ‘‘cbprm is matching a
Structure Element se2 âˆˆ ğ‘†ğ¸ğ‘¡ in a PbDCM ğ‘¡ iff (i) the type
of se2 or one of its supertypes is equal to the type of se1,
(ii) all annotations deï¬ned at ğ‘ ğ‘’1 are also annotated at se2,
(iii) all Properties that are set in se1 are equally set in se2
or se1 speciï¬es wildcard values â€œ*â€, which means that any
non-empty value is allowed for a Property. Based on this, we
deï¬ne the Compatibility Operator â€œ
â†’â‰ˆâ€ as follows:
se1
â†’â‰ˆ se2 :â‡”
(ï¸
ğ‘¡ğ‘¦ğ‘ğ‘’dcbprm(ğ‘ ğ‘’1) âˆˆ ğ‘ ğ‘¢ğ‘ğ‘’ğ‘Ÿğ‘¡ğ‘¦ğ‘ğ‘’ğ‘ t(ğ‘ ğ‘’2)
âˆ§
(ï¸€
âˆ€ğ‘ğ‘¥ âˆˆ annotationsdcbprm(ğ‘ ğ‘’1)âˆƒğ‘ğ‘¦ âˆˆ annotationst(se2)
(ï¸€
typeğ‘‘cbprm(ğ‘ğ‘¥) = typeğ‘¡(ğ‘ğ‘¦)
)ï¸€)ï¸€
âˆ§
(ï¸€
âˆ€ğ‘ğ‘– âˆˆ propertiesdcbprm(se1)
âˆƒğ‘ğ‘— âˆˆ propertiest(se2)
(ï¸€
ğœ‹1(ğ‘ğ‘–) = ğœ‹1(ğ‘ğ‘—)âˆ§
(ï¸€
ğœ‹2(ğ‘ğ‘–) = ğœ‹2(ğ‘ğ‘—) âˆ¨ (ğœ‹2(ğ‘ğ‘–) = â€œ*â€ âˆ§ ğœ‹2(ğ‘ğ‘—) Ì¸= ğœ€)
)ï¸€)ï¸€)ï¸€)ï¸
The set of SubgraphMappingsğ‘‘cbprm,ğ‘¡ contains all possible
subgraph mappings that exist between a CBPRMâ€™s Detector
ğ‘‘cbprm and a PbDCM ğ‘¡. A Subgraph Mapping ğ‘ ğ‘šğ‘–
âˆˆ
SubgraphMappingsğ‘‘ğ‘ğ‘ğ‘ğ‘Ÿğ‘š,ğ‘¡ is deï¬ned as the set of Element
Mappings between Structure Elements: An Element Mapping
ğ‘’ğ‘šğ‘— = (se1, se2) âˆˆ ğ‘ ğ‘šğ‘– is deï¬ned as a tuple of Structure
Elements, where the Structure Elements ğ‘ ğ‘’1 âˆˆ ğ‘†ğ¸ğ‘‘cbprm and
ğ‘ ğ‘’2 âˆˆ ğ‘†ğ¸ğ‘¡ are compatible, i. e., ğ‘ ğ‘’1
â†’â‰ˆ ğ‘ ğ‘’2 holds.
45
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

E. Reï¬nement Step 2: CBPRM Application
The reï¬nement of an applicable CBPRM cbprm that has
been selected to reï¬ne a matching subgraph in a PbDCM ğ‘¡ is
described in Figure 8. Thus, to apply the ğ‘ğ‘ğ‘ğ‘Ÿğ‘š to ğ‘¡, they are
both passed alongside the Subgraph Mapping ğ‘ ğ‘š containing
the Element Mappings between the cbprmâ€™s Detector and ğ‘¡.
Hereby, Lines 1, 2, 11â€“20, and 23 are used from the original
algorithm [4] and are adapted to support Behavior Patterns
and Stay Mappings: First, all Structure Elements deï¬ned in the
Reï¬nement Structure are added to ğ‘¡ (Line 1), then all affected
Relations must be redirected to their new source or target (Lines
3â€“20). Therefore, all Relations that are in- or outgoing of a
Model Node in ğ‘¡ that is part of the subgraph ğ‘ ğ‘š (Line 2) must
be investigated to redirect (i) Relations between added and
staying MNs (Lines 4â€“10), and (ii) external Relations according
to the Relation Mappings deï¬ned in the cbprm (Lines 12â€“19).
To redirect the Relations that are in- or outgoing of staying
Model Nodes, the Relations added by the ğ‘ğ‘ğ‘ğ‘Ÿğ‘šâ€™s Reï¬nement
Structure must be considered as the type of the Relation can
change. Therefore, all Relations that are in- or outgoing of a
Model Node that has been added from the Reï¬nement Structure
and that is part of a Stay Mapping (Line 4) must be redirected
to the existing Model Node in ğ‘¡. For example, by adding the
Reï¬nement Structure deï¬ned in the CBPRM illustrated in
Figure 6 to the PbDCM shown in Figure 3, the Java 8 Web
App, the PaaS environment, the PaaS Provider, and the Public
Cloud Components, as well as all three Relations are added.
However, as there is a Component in the PbDCM that maps
to the Java 8 Web App, the added application only serves as
a placeholder, where the actual application must be located.
Hence, the Relation between the placeholder and the PaaS
environment must be redirected to the actual Java 8 Web App
Component in the PbDCM. Thus, all Relations in ğ‘¡ that have
been added from ğ‘ğ‘ğ‘ğ‘Ÿğ‘šâ€™s Reï¬nement Structure and are either
the source or the target of a Model Node that is part of a
Stay Mapping must be redirected to the corresponding staying
Model Node that already exists in ğ‘¡. Hence, if the staying
Model Node was the source, the Relationâ€™s source must be
changed, or its target otherwise (Lines 5 to 9).
Similarly, external Relations that are in- and outgoing from
the mapped subgraph in ğ‘¡ must be redirected to the new Model
Nodes that have been added from the ğ‘ğ‘ğ‘ğ‘Ÿğ‘š. For example,
based on the Relation Mapping deï¬ned for ingoing Relations
of type hostedOn at the Public Cloud in Figure 6, all of
these Relations must be redirected to the new Public Cloud
Component of type AWS. Therefore, all Relations in ğ‘¡ that
are the source or the target of the currently processed Model
Node, and that are not part of the subgraph (Line 12) must
be redirected to the added Model Node as dictated by the
ğ‘ğ‘ğ‘ğ‘Ÿğ‘šâ€™s Relation Mappings. Thus, for each Relation ğ‘Ÿğ‘— that
is in- or outgoing of the current Model Node mn2 in ğ‘¡ the
following conditions must hold: (i) the Relation Type deï¬ned
in the Relation Mapping must be in the supertypes of ğ‘Ÿğ‘—, (ii)
the direction deï¬ned in the Relation Mapping must be equal
to the direction of ğ‘Ÿğ‘—, and (iii) the corresponding source or
1: SEt := SEt âˆª SErscbprm
2: for all
(ï¸€
(mn1, mn2) âˆˆ ğ‘ ğ‘š : mn2 âˆˆ ğ‘€ğ‘ğ‘¡
)ï¸€
do
3:
// Redirect added Relations of the RS to staying MNs
4:
for all
(ï¸€
ğ‘Ÿğ‘¦ âˆˆ ğ‘…ğ‘¡ : ğ‘Ÿğ‘¦ âˆˆ ğ‘…rscbprm âˆ§ âˆƒmnğ‘– âˆˆ MNrscbprm
(ï¸€
(mn1, mnğ‘–) âˆˆ ğ‘†cbprm âˆ§ (mnğ‘– = ğœ‹1(ğ‘Ÿğ‘¦)
âˆ¨ mnğ‘– = ğœ‹2(ğ‘Ÿğ‘¦))
)ï¸€)ï¸€
do
5:
if
(ï¸€
mnğ‘– = ğœ‹1(ğ‘Ÿğ‘¦)
)ï¸€
then
6:
ğœ‹1(ğ‘Ÿğ‘¦) := mn2
// update the source of ğ‘Ÿğ‘¦
7:
else
8:
ğœ‹2(ğ‘Ÿğ‘¦) := mn2
// update the target of ğ‘Ÿğ‘¦
9:
end if
10:
end for
11:
// Apply Relation Mappings: redirect external Relations
12:
for all
(ï¸€
ğ‘Ÿğ‘— âˆˆ ğ‘…ğ‘¡ : (mn2 = ğœ‹1(ğ‘Ÿğ‘—) âˆ¨ mn2 = ğœ‹2(ğ‘Ÿğ‘—))
âˆ§ âˆ„rğ‘§(rğ‘§, rğ‘—) âˆˆ ğ‘ ğ‘š
)ï¸€
do
13:
relationMapping := ğ‘Ÿğ‘šğ‘¥ âˆˆ RMcbprm :
(ï¸€
ğœ‹1(rmğ‘¥) = mn1 âˆ§ ğœ‹3(rmğ‘¥) âˆˆ supertypesğ‘¡(ğ‘Ÿğ‘—)
âˆ§ ğœ‹4(rmğ‘¥) = DIRECTION(ğ‘Ÿğ‘—) âˆ§ ğœ‹5(rmğ‘¥) âˆˆ
supertypesğ‘¡(sourceTarget(ğ‘Ÿğ‘—, mn2)))
)ï¸€
14:
if
(ï¸€
DIRECTION(ğ‘Ÿğ‘—) = outgoing
)ï¸€
then
15:
ğœ‹1(ğ‘Ÿğ‘—) := ğœ‹2(relationMapping) // update the source
16:
else if
(ï¸€
DIRECTION(ğ‘Ÿğ‘—) = ingoing
)ï¸€
then
17:
ğœ‹2(ğ‘Ÿğ‘—) := ğœ‹2(relationMapping) // update the target
18:
end if
19:
end for
20: end for
21: // Collect all Model Elements to remove from ğ‘¡
22: MEdel := {seğ‘– âˆˆ SEt : âˆƒse1 âˆˆ SEdcbprm
(ï¸€
(se1, seğ‘–) âˆˆ ğ‘ ğ‘š
(ï¸€
âˆ„mn3 âˆˆ MNrscbprm (se1, mn3) âˆˆ Scbprm
)ï¸€)ï¸€
} âˆª {bpj âˆˆ
BPğ‘¡ :
(ï¸€
âˆƒ(se1, se2) âˆˆ sm
(ï¸€
âˆƒbpx âˆˆ annotationsdcbprm(se1)
(ï¸€
typet(bpj) = typedcbprm(bpx)
)ï¸€)ï¸€)ï¸€
} âˆª {mnk âˆˆ MNrscbprm :
âˆƒmn1 âˆˆ MNdcbprm((mn1, mnk) âˆˆ Scbprm)}
23: MEt := MEt âˆ– MEdel
Figure 8. The extended apply reï¬nement algorithm. It gets the following
inputs: (cbprm âˆˆ CBPRM , ğ‘¡ âˆˆ ğ‘‡, ğ‘ ğ‘š âˆˆ SubgraphMappingsğ‘‘cbrm ,ğ‘¡).
target Model Node, depending on the direction, must be of the
same type as deï¬ned in the Relation Mapping (Line 13). Then,
the Relation ğ‘Ÿğ‘— is redirected to its new source or target Model
Node which has been added from the ğ‘ğ‘ğ‘ğ‘Ÿğ‘š (Lines 14 to 19).
For example, if the CBPRM shown in Figure 6 is applied to
the Order App in Figure 3, all Relations of type hostedOn
that are ingoing at the Public Cloud Component Pattern are
redirected to the Public Cloud Component of type AWS. Hence,
the Message-oriented Middleware, the Platform as a Service
the Order Processor is hosted on, and the Relational Database
are hosted on AWS after the CBPRM has been applied.
Finally, all Model Elements that are part of the subgraph must
be deleted as they have been reï¬ned to concrete technologies
(Lines 22 to 23). This also includes all Behavior Patterns
annotated at any mapped Structure Elements. However, all
staying Model Nodes mapped by the ğ‘ğ‘ğ‘ğ‘Ÿğ‘šâ€™s Detector must
not be deleted, while all placeholder Model Nodes added from
ğ‘ğ‘ğ‘ğ‘Ÿğ‘šâ€™s Reï¬nement Structure must be removed from ğ‘¡.
46
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

Port:
80
[â€¦]
Order App
(Java 8 Web App)
DB-Name:
webshop
[â€¦]
Database
(MySQL Database 5.7)
MaxHeap:
6GB
[â€¦]
Order Processor
(Java 8 App)
Type:
FIFO
Server-Side
Encryption:
Yes
Master-Key:
Default
Queue
(SQS Queue)
API: https://stack.iaas.de
[â€¦]
Private Cloud
(OpenStack)
RAM:
16GB
[â€¦]
Management VM
(Ubuntu 18.04)
= hostedOn
= Secure-JMS-Queue-Connection
= Secure-SQL-Connection
Region:
EU
[â€¦]
Pulblic Cloud
(AWS)
Port:
8080
[â€¦]
Management UI
(Java 8 Web App)
Server-Side
Encryption:
Yes
Master-Key:
Default
[â€¦]
DBMS
(MySQL DBMS 5.7)
JmxPort:
9090
[â€¦]
Webserver
(Tomcat 9.0)
AutoScaling:
true
ScalingMetric:
NetOut
TimeSpan:
5min
[â€¦]
Order PaaS
(AWS Webserver Env)
AutoScaling:
true
ScalingMetric:
NetOut
TimeSpan:
5min
[â€¦]
Processor PaaS
(AWS Worker Env)
Account:
ust-iaas
[â€¦]
PaaS Provider
(Elastic Beanstalk)
Account:
ust-iaas
[â€¦]
PaaS Provider
(Elastic Beanstalk)
Account:
ust-iaas
[â€¦]
DBMS Provider
(Relational Database Service)
Account:
ust-iaas
[â€¦]
MoM Provider
(Simple Queue Serivce)
Figure 9. Executable EDMM deployment model, which results from reï¬ning the PbDCM shown in Figure 3.
V. CASE STUDY
In the following, we describe a possible reï¬nement of the
PbDCM introduced in Figure 3 to an executable deployment
model which is shown in Figure 9: All Component Patterns
hosted on the Public Cloud pattern have been reï¬ned to concrete
services offered by Amazon (AWS). Thus, the PaaS patterns
hosting the Order App and the Order Processor have been
reï¬ned to Elastic Beanstalk Environments that are preconï¬gured
for automatic scaling to realize the Unpredictable Workload
and Stateless Component patterns. Moreover, the types of the
Order App and the Order Processor ensured that appropriate
CBPRMs were chosen to reï¬ne the PaaS pattern to appropriate
Beanstalk environments, i. e., to an AWS Webserver Env and
to an AWS Worker Env respectively.
To realize the Exactly-Once Delivery pattern, the Point-to-
Point Channel has been reï¬ned to a pre-conï¬gured â€œFIFOâ€
SQS Queue, which is hosted on the Simple Queue Service
offered by AWS. Further, the Relational Database pattern was
reï¬ned to (i) a MySQL Database 5.7, (ii) a MySQL Database
Management System (DBMS) 5.7, and (iii) the Relational
Database Service offered by AWS. This is required, since
a DBMS is obligatory to run a database, while the Relational
Database Service provides and maintains the DBMS. To
compensate the annotated Information Obscurity pattern, the
SQS Queue and the DBMS are conï¬gured to use â€œServer-Side
Encryptionâ€. Similarly to the Relational Database pattern, the
Execution Environment pattern hosting the Management UI
has been reï¬ned to multiple Components: An Ubuntu 18.04
and a Tomcat webserver are needed since the Management UI
is a Java 8 Web App and requires an underlying webserver.
Moreover, we created a video [12][13] showing the described
case study in detail, i. e., how the PbDCM shown in Figure 3
can be reï¬ned to the executable deployment model illustrated
in Figure 9 in an automated manner using our prototype.
VI. PROTOTYPICAL VALIDATION
To prove the practical feasibility of the extended modeling
concept, we implemented a prototype based on the Topology Or-
chestration Speciï¬cation for Cloud Applications (TOSCA) [10]
and the open-source ecosystem OpenTOSCA [14][15] TOSCA
is a standardized modeling language for automating the
deployment and management of cloud applications in a portable
way. We chose TOSCA as our basis as it is ontologically
extensible [16] and can be mapped to EDMM as follows:
In TOSCA, a declarative deployment model can be expressed
by a so-called Topology Template. Thereby, Components and
Relations in a PbDCM are represented in TOSCA as Node
Templates and Relationship Templates, which are instances
of Node Types and Relationship Types, respectively. Thus,
similar to our extended metamodel where, e. g., Component
Types deï¬ne the semantics for Components, Node Types and
Relationship Types are deï¬ning the semantics for the Node and
Relationship Templates. We realize Component Patterns and
Component Pattern Types also as Node Templates and Node
Types. To differentiate â€œPattern Node Typesâ€ from â€œnormalâ€
Node Types in TOSCA, a Tag in the Node Type is used. Thus,
all instances of Node Types having this pattern-tag identiï¬es
the corresponding Node Templates as Component Patterns.
To annotate Node Templates in a Topology Template by
Behavior Patterns, Policies can be used in TOSCA. The
semantics of a Policy is hereby deï¬ned by a Policy Type. Hence,
Relation Behavior Patterns and Component Behavior Patterns
can be mapped to Policies, while Relation Behavior Pattern
Types and Component Behavior Pattern Types are represented
by Policy Types in TOSCA. However, according to the TOSCA
Speciï¬cation [10], Relationship Templates cannot be annotated
using Policies. Thus, we extended the TOSCA metamodel to
support annotating Policies at Relationship Templates during
modeling time. This, however, does not inï¬‚uence the standard
47
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

compatibility of our implementation since Topology Templates
that contain patterns are abstract PbDCMs, and, hence, cannot
be deployed directly. By reï¬ning a PbDCM in TOSCA, a
standard compliant model is generated as the reï¬ned Topology
Template does not contain any more patterns, i. e., all Policies
attached to Node and Relationship Templates have been re-
moved. Thus, a reï¬ned Topology Template is standard conform
and can be automatically deployed. Moreover, since we only
use elements of a Topology Template that can be mapped to an
EDMM-based deployment model, a reï¬ned Topology Template
conforms to EDMM as no policies are contained.
Our prototype is part of the OpenTOSCA ecosystem [15].
OpenTOSCA is an implementation of the TOSCA standard and
consists of three components: (i) Winery [17], which provides
modeling capabilities, (ii) the OpenTOSCA Container [18],
which enables automated orchestration and provisioning, and
(iii) the OpenTOSCA UI, offering management functionality to
the user. Since our concept focuses on modeling, we extended
Winery to support the modeling of Behavior Patterns, and the
creation and reï¬nement of PbDCMs and CBPRMs.
VII. RELATED WORK
Diverse approaches in the context of MDA and deployment
models mention patterns, nevertheless we present selected
related work sharing the deï¬nition of patterns by Alexan-
der et al. [6] as proven solutions solving recurring problems.
PbDCMs and their reï¬nement is based on the concept of
Model-driven Architecture (MDA) [19]: A PbDCM represents
a Platform Independent Model (PIM), which is, in the context
of MDA, transformed into a Platform Speciï¬c Model (PSM),
represented by the reï¬nement to an executable deployment
model. There are diverse approaches to transform a PIM into a
PSM present. For instance, the approach of Mellor et al. [20]
requires a deï¬nition and implementation of a mapping between
the abstract metamodel and the metamodel of the target plat-
form. Within our approach, the CBPRMs can be automatically
applied, and, thus, combine the mapping and implementation.
Multiple approaches address the transformation of deploy-
ment models. The approach of BreitenbÃ¼cher [11] enables the
management of composite cloud applications by an automated
relization of management patterns in topologies. Furthermore,
Saatkamp et al. [21][22] use logic programming to formalize
the problem and context domain of patterns enabling an auto-
mated detection and resolving of problems within deployment
models. Moreover, the approaches of Eilam et al. [23][24] and
Arnold et al. [25][26] focus on an automated transformation
of deployment models using predeï¬ned transformation steps.
Nevertheless, within all of the mentioned approaches patterns
are not used to model and deï¬ne the deployment model.
Hallstrom and Soundarajan [27] reï¬ne patterns into sub-
patterns representing realization variants of abstract patterns
which leads to a hierarchy of patterns. Falkenthal et al. [28] in-
troduce a similar approach, which reï¬nes patterns into concrete
technologies. They further present concrete solutions of patterns
capturing reusable implementation realizations, such as code
snippets [29][30], as well as aggregation operators which allow
the combination of multiple concrete solutions into an overall
solution [31]. The introduced CBPRMs can be considered as
concrete solutions, a combination through aggregation operators
will be part of future work. Eden et al. [32] present an approach
for an automated application of patterns to add source code
to a given program. Within this work, patterns are speciï¬ed
on an abstract level and realized in a speciï¬c program in
advance. Even though, those works do not focus on modeling
and deï¬ning deployment models by a pattern application, a
combination of our approach with the presented ones will be
considered in future work.
SchÃ¼rr [33] presents Triple Graph Grammars (TGGs) to
deï¬ne graph transformations in a general manner. Therefore,
correspondence graphs in TGGs specify correspondences
between nodes. In contrast, the presented Relation Mappings
in CBPRMs focus on redirecting external relations to the
exchanged graph fragment. Bolusset and Oquendo [34] in-
troduce a software architecture reï¬nement approach using
transformation patterns based on rewriting logic. Similarly,
Lehrig [35] introduces the Architectural Template (AT) method
to apply patterns in terms of reusable modeling templates to
software architectures. In contrast, transformation patterns and
ATs deï¬ne rewriting rules of architectures and do not use
patterns as components to be reï¬ned to concrete technologies.
Di Martino et al. [36] describe the composition of cloud
services to cloud applications using patterns. Further, they
introduce a semantic model of patterns describing business
processes, cloud applications, and mappings to required cloud
resources for their implementation [37]. Contrary, those map-
pings cannot be used to describe or reï¬ne deployment models.
VIII. CONCLUSION & FUTURE WORK
Using the Pattern-based Deployment and Conï¬guration
Model (PbDCM) approach, the deployment becomes more
variable as Component Patterns can be automatically reï¬ned
to different technologies and vendors for each deployment.
For example, while one modeler chooses AWS as a pub-
lic cloud provider, a second one may choose the Google
Cloud. Moreover, PbDCMs reduce the required knowledge
how technologies must be conï¬gured to meet non-functional
requirements as Behavior Patterns can be annotated at Structure
Elements to abstractly specify their requirements. Thus, if an
application experiences Unpredictable Workload [5], the pattern
can be annotated to the corresponding Components, which are
then automatically reï¬ned to an appropriate conï¬guration. For
example, conï¬gurations required by the General Data Protection
Regulation (GDPR) can be realized by an appropriate selection
of behavioral patterns, such as the Secure Channel pattern [9].
However, to detect applicable CBPRMs that are able to reï¬ne
patterns in a PbDCM, our approach builds upon isomorphic
subgraph matching. Thus, if any Structure Element in a PbDCM
is changed by applying a CBPRM, another CBPRM, which
may have been applicable before, may not be applicable
anymore as the detector subgraph cannot be found. Hence,
the order in which CBPRMs are applied is important and may
result in different solutions. We plan to tackle this issue in
48
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

future work by generating possible permutations of CBPRMs.
Moreover, to close the gap between abstract architectures
and deployment models we plan to combine the approach of
Guth and Leymann [38] with the presented one. Thereby, ï¬rst
architectures are described using abstract patterns [38] which
are then reï¬ned to more concrete patterns [28], and replaced
by concrete technologies using the presented approach. Finally,
we plan to use the Cloud Data Patterns for Conï¬dentiality [39]
to enhance the security of data stored in cloud environments.
ACKNOWLEDGMENT
This work was partially funded by the German Research
Foundation (DFG) project SustainLife (379522012).
REFERENCES
[1] U. BreitenbÃ¼cher et al., â€œCombining Declarative and Imperative Cloud
Application Provisioning based on TOSCA,â€ in International Conference
on Cloud Engineering (IC2E 2014).
IEEE, Mar. 2014, pp. 87â€“96.
[2] M. Wurster et al., â€œThe Essential Deployment Metamodel: A Systematic
Review of Deployment Automation Technologies,â€ Software-Intensive
Cyber-Physical Systems (SICS), Aug. 2019.
[3] C. Endres et al., â€œDeclarative vs. Imperative: Two Modeling Patterns
for the Automated Deployment of Applications,â€ in Proceedings of the
9th International Conference on Pervasive Patterns and Applications
(PATTERNS).
Xpert Publishing Services, Feb. 2017, pp. 22â€“27.
[4] L. Harzenetter et al., â€œPattern-based Deployment Models and Their
Automatic Execution,â€ in 11th IEEE/ACM International Conference on
Utility and Cloud Computing (UCC 2018).
IEEE Computer Society,
Dec. 2018.
[5] C. Fehling, F. Leymann, R. Retter, W. Schupeck, and P. Arbitter, Cloud
Computing Patterns: Fundamentals to Design, Build, and Manage Cloud
Applications.
Springer, Jan. 2014.
[6] C. Alexander, S. Ishikawa, and M. Silverstein, A Pattern Language:
Towns, Buildings, Construction.
Oxford University Press, Aug. 1977.
[7] G. Hohpe and B. Woolf, Enterprise Integration Patterns: Designing,
Building, and Deploying Messaging Solutions.
Addison-Wesley, 2004.
[8] E. Gamma, R. Helm, R. Johnson, and J. Vlissides, Design Patterns:
Elements of Reusable Object-oriented Software.
Addison-Wesley, 1994.
[9] M. Schumacher, E. Fernandez-Buglioni, D. Hybertson, F. Buschmann,
and P. Sommerlad, Security Patterns: Integrating Security and Systems
Engineering.
John Wiley & Sons, Inc., Jan. 2006.
[10] OASIS, TOSCA Simple Proï¬le in YAML Version 1.3, Organization for
the Advancement of Structured Information Standards (OASIS), 2019.
[11] U. BreitenbÃ¼cher, â€œEine musterbasierte Methode zur Automatisierung
des Anwendungsmanagements,â€ Dissertation, University of Stuttgart,
Faculty of Computer Science, Electrical Engineering, and Information
Technology, 2016.
[12] L. Harzenetter, â€œDemonstration Video,â€ 2019, URL: https://youtu.be/
zmU35Detr60 [accessed: 2020-02-18].
[13] â€”â€”, â€œDemonstration TOSCA Repository,â€ 2019, URL: https://github.
com/lharzenetter/tosca-deï¬nitions [accessed: 2020-02-18].
[14] University of Stuttgart, â€œOpenTOSCA,â€ 2019, URL: https://github.com/
OpenTOSCA [accessed: 2020-02-18].
[15] U. BreitenbÃ¼cher et al., â€œThe OpenTOSCA Ecosystem - Concepts &
Tools,â€ in European Space project on Smart Systems, Big Data, Future
Internet - Towards Serving the Grand Societal Challenges - Volume 1:
EPS Rome 2016,.
SciTePress, 2016, pp. 112â€“130.
[16] A. Bergmayr et al., â€œA Systematic Review of Cloud Modeling Languages,â€
ACM Computing Surveys (CSUR), vol. 51, no. 1, Feb. 2018.
[17] O. Kopp, T. Binz, U. BreitenbÃ¼cher, and F. Leymann, â€œWinery â€“ A
Modeling Tool for TOSCA-based Cloud Applications,â€ in Proceedings
of the 11th International Conference on Service-Oriented Computing
(ICSOC 2013).
Springer, Dec. 2013, pp. 700â€“704.
[18] T. Binz et al., â€œOpenTOSCA â€“ A Runtime for TOSCA-based Cloud
Applications,â€ in Proceedings of the 11th International Conference on
Service-Oriented Computing (ICSOC 2013).
Springer, Dec. 2013, pp.
692â€“695.
[19] R. Soley et al., â€œModel driven architecture,â€ OMG white paper, vol. 308,
no. 308, p. 5, 2000.
[20] S. J. Mellor, K. Scott, A. Uhl, and D. Weise, â€œModel-driven architecture,â€
in Advances in Object-Oriented Information Systems.
Springer, 2002,
pp. 290â€“297.
[21] K. Saatkamp, U. BreitenbÃ¼cher, O. Kopp, and F. Leymann, â€œApplication
Scenarios for Automated problem Detection in TOSCA Topologies by
Formalized Patterns,â€ in Papers From the 12th Advanced Summer School
on Service Oriented Computing.
IBM Research Division, Oct. 2018,
pp. 43â€“53.
[22] â€”â€”, â€œAn Approach to Automatically Detect Problems in Restructured
Deployment Models based on Formalizing Architecture and Design
Patterns,â€ SICS Software-Intensive Cyber-Physical Systems, pp. 1â€“13,
2019.
[23] T. Eilam et al., â€œManaging the conï¬guration complexity of distributed
applications in Internet data centers,â€ Communications Magazine, vol. 44,
no. 3, pp. 166â€“177, Mar. 2006.
[24] T. Eilam, M. Elder, A. V. Konstantinou, and E. Snible, â€œPattern-
based Composite Application Deployment,â€ in Proceedings of the 12th
IFIP/IEEE International Symposium on Integrated Network Management
(IM 2011).
IEEE, May 2011, pp. 217â€“224.
[25] W. Arnold, T. Eilam, M. Kalantar, A. Konstantinou, and A. Totok, â€œPattern
Based SOA Deployment,â€ in Proceedings of the Fifth International
Conference on Service-Oriented Computing (ICSOC 2007).
Springer,
Sep. 2007, pp. 1â€“12.
[26] â€”â€”, â€œAutomatic Realization of SOA Deployment Patterns in Distributed
Environments,â€ in Proceedings of the 6th International Conference on
Service-Oriented Computing (ICSOC 2008).
Springer, Dec. 2008, pp.
162â€“179.
[27] J. O. Hallstrom and N. Soundarajan, â€œReusing Patterns through Design
Reï¬nement,â€ in Formal Foundations of Reuse and Domain Engineering.
Springer, 2009, pp. 225â€“235.
[28] M. Falkenthal et al., â€œLeveraging Pattern Application via Pattern
Reï¬nement,â€ in Proceedings of the International Conference on Pursuit
of Pattern Languages for Societal Change (PURPLSOC 2015).
epubli,
Jun. 2015, pp. 38â€“61.
[29] M. Falkenthal, J. Barzen, U. BreitenbÃ¼cher, C. Fehling, and F. Leymann,
â€œFrom Pattern Languages to Solution Implementations,â€ in Proceedings
of the Sixth International Conferences on Pervasive Patterns and
Applications (PATTERNS 2014).
Xpert Publishing Services, May 2014,
pp. 12â€“21.
[30] M. Falkenthal and F. Leymann, â€œEasing pattern application by means of
solution languages,â€ in Proceedings of the 9th International Conferences
on Pervasive Patterns and Applications (PATTERNS).
Xpert Publishing
Services (XPS), 2017, pp. 58â€“64.
[31] M. Falkenthal, J. Barzen, U. BreitenbÃ¼cher, and F. Leymann, â€œOn the
Algebraic Properties of Concrete Solution Aggregation,â€ SICS Software-
Intensive Cyber-Physical Systems, Aug. 2019.
[32] A. Eden, A. Yehudai, and J. Gil, â€œPrecise Speciï¬cation and Automatic
Application of Design Patterns,â€ in Proceedings of the 12th IEEE
International Conference Automated Software Engineering (ASE 1997).
IEEE, Nov. 1997, pp. 143â€“152.
[33] A. SchÃ¼rr, â€œSpeciï¬cation of graph translators with triple graph grammars,â€
in Graph-Theoretic Concepts in Computer Science.
Springer Berlin
Heidelberg, 1995, pp. 151â€“163.
[34] T. Bolusset and F. Oquendo, â€œFormal Reï¬nement of Software Architec-
tures Based on Rewriting Logic,â€ in Proceedings of the International
Workshop on Reï¬nement of Critical Systems, 2002, pp. 200â€“202.
[35] S. M. Lehrig, â€œEfï¬ciently Conducting Quality-of-Service Analyses
by Templating Architectural Knowledge,â€ Dissertation, University of
Stuttgart, Faculty of Computer Science, Electrical Engineering, and
Information Technology, 2018.
[36] B. Di Martino, G. Cretella, and A. Esposito, â€œCloud services compo-
sition through cloud patterns,â€ in Adaptive Resource Management and
Scheduling for Cloud Computing.
Springer, 2015, pp. 128â€“140.
[37] B. Di Martino, A. Esposito, S. Nacchia, and S. A. Maisto, â€œA semantic
model for business process patterns to support cloud deployment,â€
Computer Science - Research and Development, vol. 32, no. 3, pp.
257â€“267, 2017.
[38] J. Guth and F. Leymann, â€œPattern-based rewrite and reï¬nement of
architectures using graph theory,â€ Software-Intensive Cyber-Physical
Systems (SICS), pp. 1â€“12, Aug. 2019.
[39] S. Strauch, U. BreitenbÃ¼cher, O. Kopp, F. Leymann, and T. Unger, â€œCloud
Data Patterns for Conï¬dentiality,â€ in Proceedings of the 2nd International
Conference on Cloud Computing and Services Science (CLOSER 2012).
SciTePress, Apr. 2012, pp. 387â€“394.
49
Copyright (c) IARIA, 2020.     ISBN:  978-1-61208-783-2
PATTERNS 2020 : The Twelfth International Conference on Pervasive Patterns and Applications

