Four Scenarios of Effective Computations on Sum-like Graphs
Elena V. Ravve and Zeev Volkovich
Department of Software Engineering
Ort Braude,
Karmiel, Israel
Email: {cselena,vlvolkov}@braude.ac.il
Abstract—In this paper, we consider computations on sum-
like graphs, which we introduced in our previous works. For
such graphs, we proposed a method that allows us to reduce the
solution of a Monadic Second Order or First Order deﬁnable
problem on the graphs to the solution of effectively derivable
Monadic Second Order or First Order deﬁnable problems on
their components, respectively. Now, we describe in great details
four particular scenarios, where this method may be applied,
and explain how it may improve the complexity of the solution.
This lead us to a generalized formulation of Amdahl’s style laws
for each scenario. Moreover, we consider applications of our
method to the ﬁelds of repetitive and hierarchical structures,
widely used in hardware and software design, as well as parallel
and distributed computations.
Keywords— Sum-like graphs; Translation schemes; (Weighted)
Monadic Second Order Logic ; First Order Logic; Repetitive and
hierarchical structures; Incremental computations; Parallel and dis-
tributed computations.
I. INTRODUCTION
Replacing of solution of a problem on a given graph by
solution of other problems on derived graphs is widely used
in different ﬁelds of science. In this paper, we address the
case, when the original graph is sum-like and we extend the
approach of [1], implemented in the framework of model
checking. In [2], we describe in great details how the concept
of FSM may be interpreted as a graph, and how computation
of its properties may be expressed as a set of logical formulas.
In [3], we investigate the case of computation with weighted
automata on sum-like labeled weighted trees. In this paper,
we are mostly concentrated on the complexity issues of the
approach.
Assume we are given a model of an object in the form of
graph G and a formalized presentation of a problem to be
solved in the form of formula φ, possibly with free variables.
Assume G is built from components Gi, where i ∈ I is
some index set or structure. Assume that G is a sum-like
composition of Gi as deﬁned in [1][2], or it is a sum-like
labeled weighted tree, as deﬁned in [3].
The main results of [1][2][3] show how the solution of φ on
G depends on the components Gi of G and the index structure
I. It is an extension of the Feferman–Vaught Theorem, cf.
[4], for First Order Logic (FOL) to Monadic Second Order
Logic (MSOL) or Weighted Monadic Second Order Logic
(WMSOL). The detailed description of algorithmic use of
Feferman–Vaught Theorem may be found in [5].
The Feferman–Vaught theorem covers a very wide class of
generalized products and sums of structures and is extremely
powerful. We extend these theorems to the case of (Weighted)
Monadic Second Order Logic and it works only for a more
restricted class of sum–like graphs (trees), cf. [1][2][3]. From
our main theorems, we derive a method for solving MSOL
φ on sum-like G, which proceeds as follows (the similar
treatment of WMSOL φ on sum-like T see in [3]):
Preprocessing: Given φ and Φ, but no G, we construct at
once a sequence of formulas ψı, and a function FΦ,φ. This
construction is polynomial in the size of φ and Φ.
Incremental Computation: We compute the values bı, de-
ﬁned by bı, = 1 iff Gi |= ψı,.
Final Integration: Our theorems now state that G |= φ iff
FΦ,φ(¯b) = 1.
In this paper, we investigate how the fact that G is built from
several components may be used in order to make the solution
more effective in the general case as well as how the general
approach is connected to different practical applications. In
fact, this analysis gives a generalized formulation of Amdahl’s
style laws for each described computation model and scenario.
We consider four different scenarios, when the complexity
gain may be reached. The ﬁrst one, described in Section
V, represents the case when our graph G is composed by
repetition of some basic component(s) Gı =
˜G. We may
ﬁnd lots of such constructions, for example, in chemistry:
polymers, VLSI design: adders, shifters, memories and other
applications, etc.
Very often, after the problem φ was solved once on G, it
should be solved again on some light modiﬁcation of G. The
situation is investigated in Section VI. More precisely, let j
denote the solution on the jth variant of G. We assume that
Gj differs from Gj+1 in one component Gi
j+1, otherwise we
may consider a line of such variants Gj=j0, Gj1, . . . , Gjl=j+1.
We consider two situations. The classical one looks at the cost
of solving once the problem φ on G, and uses either the size
of G, the size of φ or the sum of the two as the relevant
input size. In addition, we ask, what our method can gain by
repeating this process many times, with small changes at a
time. For this purpose we also look at the size of the changed
component and the number of iterations.
1
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

In Section VII, we consider the case, when computations
may be done in parallel rather than sequentially on one
computational unit. We show how our general approach leads
us to the BSP computation model, as introduced in [6].
With the frequent use of the Internet, it becomes customary
to have data distributed over many sites. We consider how
our approach works in the case of the distributed databases in
Section VIII. We show that under some reasonable conditions,
our method leads to some variation of LogP model, cf. [7].
The paper is structured as follows:
• We start from a list of notations.
• In Section II, we give a motivating example.
• In Section III, we recall general deﬁnitions and results
taken almost verbatim from [2].
• Section IV provides detailed discussion of the common
basis of all cost evaluations.
• In section V, we analyze complexity of single computa-
tions on repetitive structures.
• In section VI, we analyze complexity of incremental re-
computations on the lightly modiﬁed graphs.
• In section VII, we analyze complexity of parallel com-
putations.
• In section VIII, we analyze complexity of computations
on distributed databases.
• Section IX summarizes the paper.
LIST OF NOTATIONS
πAR
Projection of attributes A from relation R
σθR
Selection from R of tuples satisfying θ
R ▷◁ S
Join of relations R and S
bı,
Boolean values
¯b
Vector of Boolean values
BSP
Bulk synchronous parallel model
E1, E2, Ei, . . .
Sets of edges of a graph
FΦ,φ
Computation, associated with Φ and φ
FOL
First Order Logic
FSM
Finite State Machine
G, GΦ, ˜G, Gı, . . .
Graph structures
I
Index structure
I(R) . . .
Instances of Database schemes
L
Logic
MSOL
Monadic Second Order Logic
P1, P2, Pi, Q1, Q2, Qi
One place relations on the set of vertices
R, RI, . . .
Database schemes
Ri, . . .
Relation symbols
ρ(Ri)
Arity of Ri
SOL
Second Order Logic
Φ
Translation scheme
Φ∗, Φ#
Two mappings of Φ
T
Sum-like tree
v
Vertex of a graph
¯v
Vector of vertices of a graph
V, V1, V2, Vi, VΦ, . . .
Sets of vertices of a graph
VLSI
Very Large Scale Integration
WMSOL
Weighted Monadic Second Order Logic
II. MOTIVATING EXAMPLE
In this section, we consider how veriﬁcation of a MSOL–
property over some composition of graphs can be reduced to
Fig. 1.
A city with bridges [8].
G1
G2
G


□
□
♦
♦
Fig. 2.
Composition of two graphs: G1 ⇌ G2.
its components. Assume we consider a city that is divided
into two parts by a river, see Figure 1 taken from [8]. These
parts are connected by bridges. Without lost of generality, let
us assume that there exist only two bridges. Assume we are
looking for one-way cycles in the city.
We may formulate the situation in the following way.
We are given two ﬁnite graphs G1 = ⟨V1, E1, P1, Q1⟩ and
G2 = ⟨V2, E2, P2, Q2⟩, where Vi denotes a set of vertices, Ei
denotes a set of edges and Pi, Qi are one place relations (ver-
tex colorings) respectively. Let G be the disjoint union of G1
and G2 with additional edges, corresponding to the bridges,
see Figure 2. We deﬁne this composition of two colored graphs
formally as follows: G = G1 ⇌ G2 = ⟨V1 ˙∪V2, E⟩, where
V1 ˙∪V2 denotes disjoint union of sets of vertices, and two
vertices v and u of G belongs to E iff
Φ : (v, u) ∈ E1 ∨ (v, u) ∈ E2
∨(v ∈ Q1 ∧ u ∈ Q2) ∨ (v ∈ Q2 ∧ u ∈ Q1)
∨(v ∈ P1 ∧ u ∈ P2) ∨ (v ∈ P2 ∧ u ∈ P1)
We want to check whether G has cycles. To do so, we
observe that
(*) G has a cycle iff G1 has a cycle, or G2 has a
cycle, or there are at least two connected coloured
vertices in G2−i and at least one coloured vertex in
the same color vertex in Gi+1, where i ∈ {0, 1},
and proceed as follows.
• We ﬁrst write the cyclicity property as a formula φ in
MSOL.
• Then, using (*), which depends only on φ and Φ,
but not G, we look for formulas ψ1,1, . . . , ψ1,n1 and
2
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

ψ2,1, . . . , ψ2,n2 in MSOL , which will give us the
properties to be checked in G1 and G2 respectively.
• Then, again using (*), we look for a boolean function F
of n1 + n2 arguments b1,1, . . . , b2,n2.
• Now we put bi,j = 1 iff Gi |= ψi,j and hope to conclude
that G |= φ iff F(b1,1, . . . , b2,n2) = 1.
Surprisingly, our main theorems from [1][2][3] imply that
this method can be mechanized in certain cost, even if (*) is
not given in advance.
We have explained our main result by using a very simple
example of a disjoint union of two colored graphs with some
edges added, deﬁned by Φ. The main theorems of [1][2][3]
generalize this approach to combination of more than two
structures and more complicated additional relations.
III. GENERAL BACKGROUND
In this section, we recall general deﬁnitions and results taken
almost verbatim from [2]. The corresponding extension to the
case of WMSOL may be found in [3].
A. Translation schemes
In this section, we follow [1] and introduce the general
framework for syntactically deﬁned translation schemes. A
vocabulary is a ﬁnite set of relation symbols and constants.
Deﬁnition 1: General Translation Schemes.
Let τ and σ be two vocabularies and L be a logic, such
as FOL or MSOL. Let σ = {R1, . . . , Rm} and let ρ(Ri)
be the arity of Ri. Let Φ = ⟨φ, ψ1, . . . , ψm⟩ be formulas of
L(τ). Φ is feasible for σ over τ if φ has exactly 1 free ﬁrst
order variable and each ψi has ρ(Ri) distinct free ﬁrst order
variables. Such a Φ = ⟨φ, ψ1, . . . , ψm⟩ is also called a τ–
σ–translation scheme or, shortly, a translation scheme, if the
parameters are clear in the context.
With a translation scheme Φ we can naturally associate
a (partial) function Φ∗ from τ–structures (graphs) to σ–
structures (graphs).
Deﬁnition 2: The induced map Φ∗.
Let G be a τ–graph and Φ be feasible for σ over τ. The graph
GΦ is deﬁned as follows:
1) The universe VΦ of GΦ is the set
VΦ = {v ∈ V : G |= φ(v)};
2) The interpretation of Ri in GΦ is the set
GΦ(Ri) = {¯v ∈ GΦ
ρ(Ri) : G |= ψi(¯v)};
Note that GΦ is a σ–graph of cardinality at most | G |.
3) The partial function Φ∗ : G(τ) → G(σ) is deﬁned by
Φ∗(G) = GΦ. Note that Φ∗(G) is deﬁned iff G |= ∃vφ.
With a translation scheme Φ we can also naturally associate
a function Φ# from MSOL(σ)–formulas to MSOL(τ)–
formulas.
Deﬁnition 3: The induced map Φ#.
Let θ be a σ–formula and Φ be feasible for σ over τ. The
formula θΦ is deﬁned inductively as follows:
1) For Ri ∈ σ and θ = Ri(x1, . . . , xm), we put
θΦ = ψi(v1, . . . , vm).
Φ∗
τ-structure
−→
σ-structure
Φ
τ-formulas
←−
σ-formulas
Φ#
Fig. 3.
Translation scheme and its components.
2) For the boolean connectives, the translation distributes,
i.e., if θ = (θ1 ∨ θ2) then θΦ = (θ1Φ ∨ θ2Φ) and if
θ = ¬θ1 then θΦ = ¬θ1Φ, and similarly for ∧.
3) For the existential quantiﬁer, we use relativization, i.e.,
if θ = ∃vθ1, we put θΦ = ∃v(φ(v) ∧ (θ1)Φ).
4) For second order variables U of arity ℓ and u a vector of
length ℓ of ﬁrst order variables or constants we translate
θ = ∃Uθ1, by treating U like a relation symbol and put
θΦ = ∃U(∀u(U(u) → (φ(u1) ∧ . . . φ(uℓ) ∧ (θ1)Φ))).
5) The function Φ# : MSOL(σ) → MSOL(τ) is deﬁned
by Φ#(θ) = θΦ.
The following fact holds, see Figure 3:
Proposition 1:
Let Φ = ⟨φ, ψ1, . . . , ψm⟩ be a τ–σ–translation scheme, G a
τ-graph and θ a σ–formula. Then G |= Φ#(θ) iff Φ∗(G) |= θ.
The proof may be found in [9][10].
B. Sum-like graphs
In this section, we discuss ways of obtaining graphs from
components. The Disjoint Union of a family of graphs is the
simplest example of juxtaposing graphs, where none of the
components are linked to each other. For our purpose, we
include the index set I in the resulting structure as well.
Deﬁnition 4: Disjoint Union of Graphs
Let τı = ⟨Rı
1, . . . , Rı
ı⟩ be a vocabulary of graph Gı. In the
general case the resulting graph G = ˙F
ı∈IGı is
G = ⟨V = I ∪ ˙S
ı∈IVı, RI
j(1 ≤ j ≤ I), Rı
ji(ı ∈ I, 1 ≤ ji ≤ ı)⟩
for all ı ∈ I, or rather any graph, isomorphic to it.
We assume existence of the following mappings:
• hν : V → I, hν(v) = ı if v ∈ Vı;
• hι : PS(V) → PS(Vı), hι(V ) = Vı if Vı is a ıth
component of V, while PS denotes the power set.
Deﬁnition 5: Partitioned Index Structure
Let I be an index structure. I is called ﬁnitely partitioned
into ℓ parts if there are unary predicates Iα, α < ℓ, in the
vocabulary of I such that their interpretation forms a partition
of the universe of I.
The following holds:
Theorem 1:
Let I be a ﬁnitely partitioned index structure.
Let G = ˙F
i∈IGi be a τ–graph, where each Gi is isomorphic
to some B1, . . . , Bℓ over the vocabularies τ1, . . . , τℓ, in accor-
3
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

dance to the partition (ℓ is the number of the classes).
For every φ ∈ MSOL(τ) there are:
• a boolean function Fφ(b1,1, . . . , b1,j1, . . . , bℓ,1, . . . , bℓ,jℓ,
bI,1, . . . , bI,jI)
• MSOL–formulas ψ1,1, . . . , ψ1,j1, . . . , ψℓ,1, . . . , ψℓ,jℓ
• MSOL–formulas ψI,1, . . . , ψI,jI
such that for every G, I and Bı as above with
Bı |= ψı, iff bı, = 1 and I |= ψI, iff bI, = 1
we have
G |= φ iff
Fφ(b1,1, . . . , b1,j1, . . . , bℓ,1, . . . , bℓ,jℓ, bI,1, . . . , bI,jI) = 1.
Moreover, Fφ and the ψı, are computable from φ, ℓ and
vocabularies alone, but are exponential in the quantiﬁer depth
of φ.
The disjoint union as such is not very interesting. However,
combining it with translation schemes gives us a rich repertoire
of patching techniques. Let τ0, τ1, τ be ﬁnite vocabularies of
graphs. For a τ0-model I (serving as index model), τ1-graphs
are pairwise disjoint for simplicity Gı(ı ∈ I) and a τ-graph G
is the disjoint union of ⟨Gı : ı ∈ I⟩ with G = ˙F
i∈IGi. Now
we generalize the disjoint union of graphs to sum-like graphs
in the following way:
Deﬁnition 6: Sum–like Graphs
Let I be a ﬁnitely partitioned index structure.
Let G = ˙F
i∈IGi be a τ–graph, where each Gi is isomor-
phic to some B1, . . . , Bℓ over the vocabularies τ1, . . . , τℓ, in
accordance with the partition. Furthermore let Φ be a τ–σ
MSOL–translation scheme. The Φ–sum of B1, . . . , Bℓ over
I is the graph Φ∗(G), or rather any graph isomorphic to it.
Theorem 2:
Let I be a ﬁnitely partitioned index structure and let G be the
Φ–sum of B1, . . . , Bℓ over I, as above.
For every φ ∈ MSOL(τ) there are:
• a boolean function FΦ,φ(b1,1, . . . , b1,j1, . . . , bℓ,1, . . . , bℓ,jℓ,
bI,1, . . . , bI,jI)
• MSOL–formulas ψ1,1, . . . , ψ1,j1, . . . , ψℓ,1, . . . , ψℓ,jℓ
• MSOL–formulas ψI,1, . . . , ψI,jI
such that for every G, I and Bı as above with
Bı |= ψı, iff bı, = 1 and I |= ψI, iff bI, = 1
we have
G |= φ iff
FΦ,φ(b1,1, . . . , b1,j1, . . . , bℓ,1, . . . , bℓ,jℓ, bI,1, . . . , bI,jI) = 1.
Moreover, FΦ,φ and the ψı, are computable from Φ# and φ,
but are exponential in the quantiﬁer depth of φ.
Moreover, in [3], we prove that:
Theorem 3:
Let I be a ﬁnitely partitioned index structure and a tree is the
Φ–sum. For every φ ∈ WMSOL(τ) there are:
• a computation on values ϖ1,1, . . . , ϖℓ,jℓ
FΦ,φ(ϖ1,1, . . . , ϖ1,j1, . . . , ϖℓ,1, . . . , ϖℓ,jℓ)
and
• WMSOL–formulas ψ1,1, . . . , ψ1,j1, . . . , ψℓ,1, . . . , ψℓ,jℓ
such that ϖı, = ϱı, iff [ψı,] = ϱı, we have
[φ] = ϱ iff FΦ,φ(ϖ1,1, . . . , ϖ1,j1, . . . , ϖℓ,1, . . . , ϖℓ,jℓ) = ϱ.
Moreover, FΦ,φ and the ψı, are computable from Φ# and φ,
but are exponential in the quantiﬁer depth of φ.
IV. GENERAL COMPLEXITY ANALYSIS
In this section, we discuss under what conditions theorems
of [1][2][3] improve the complexity of computations, when
measured in the size of the composed graphs (trees) only.
Our scenarios are as follows: A (W)MSOL formula (set of
formulas) φ is given in advance. A sum-like graph (tree) is
now submitted to a computation unit and we want to know,
how long it takes to check whether φ is true on the graph
(tree). Now we give the general complexity analysis of the
computation on sum-like graphs (trees).
A. Complexity of computation for different logics
Theorems of [1][2] hold for MSOL and, with restrictions,
also for FOL. Computation for FOL is polynomial (even
in logarithmic space), whereas computation for MSOL is
likely to be non–polynomial, as it sits fully in the polynomial
hierarchy. Theorems of [3] hold for WMSOL. Computation
for WMSOL may be done, using Weighted Tree Automata.
More precisely, the complexity of computation (in the size
of the graph) of Second Order Logic expressible properties can
be described as follows. The class NP of non-deterministic
polynomial-time problems is the set of properties, which are
expressible by Existential Second Order Logic on ﬁnite struc-
tures, cf. [11]. Computation for SOL deﬁnable properties is in
the polynomial hierarchy, cf. [12]. Moreover, for every level
of the polynomial hierarchy there is a problem, expressible
in SOL, that belongs to this class. The same fact hold for
MSOL, too, as observed in [13].
Computation for properties, deﬁnable in Fixed Point Logic,
is polynomial, cf. [14]. CTL∗ is a superset of Computational
Tree Logic and Linear Temporal Logic. All the problems,
which are expressible by CTL∗, can be computed in polyno-
mial time, cf. [15]. Most properties, which appears in real life
applications, are stronger than FOL but weaker than MSOL,
and their computational complexity is polynomial. In [16], it
was shown that the similar theorems are valid for Transitive
Closure and Monadic Fixed Point Logic. However, it does not
hold for all of the languages (logics).
B. General analysis
Assume that G is a sum-like graph (or a sum-like tree). Its
components are Gı with index structure I, and we want to
check whether φ is true in G. Assume that:
• T (N) or Told(N) denotes time to solve the problem by
the traditional sequential way (N denotes the size of the
coding of graph G);
• EI denotes time to extract index structure I from G;
• Eı denotes time to extract each Gı from G;
4
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

Fig. 4.
Layout of a full 10-bit adder [22].
• CI(nI) denotes time to compute all values of bI,, where
nI is the size of I;
• Cı(nı) denotes time to compute all values of bı,, where
nı is the size of Gı;
• TFΦ,φ denotes time to build FΦ,φ;
• TS denotes time to achieve one result of FΦ,φ.
According to these symbols, the new computation time is:
Tnew = EI + Σı∈IEı + CI + Σı∈ICı + TFΦ,φ + TS
(1)
and the question to answer is: when Told > Tnew.
V. SCENARIO A: SINGLE COMPUTATION ON REPETITIVE
STRUCTURES
In this section, we consider the underlying structure, the
formula and the modularity as well as possible applications of
our method for single computations on repetitive structures.
We analyze the corresponding complexity gain for the com-
putations of properties, expressible in different logics.
A. The underlying structure, the formula and the modularity
Our underlying structure is a sum-like graph G, where for
each ı: Gı = ˜G. The property, which we want to check on it, is
expressible in formula φ of MSOL, which has an exponential
checker. We check whether G |= φ.
B. Applications
Different repetitive combinations of graphs have been under
deep investigation for long time, cf. [17][18][19]. Polygraphs
were introduced as generalization of polymers in chemistry,
cf. [20], and explored in VLSI design, cf. [21].
We restrict ourselves to VLSI design, which widely uses
repetition of blocks (Figure 4 taken from [22]) and hierar-
chical structures. Many basic elements of the design, such
that shifters, adders, registers, etc. are build in this manner.
Repetition of modules is explored also in control logic and
other kinds of hardware design. Memory is another example
of a repetitive structure in VLSI design. If we go up in
the hierarchy of our design, we found multi-core processors,
which are single computing components with two or more
independent processors (called ”cores”).
C. Complexity gain for MSOL
Assume that our design is presented as a graph (FSM),
such that:
• N is a size of G, n is a size of ˜G and l is a size of index
structure I.
• The decomposition is given: EI = Eı = 0.
• The computation is exponential in the form: T = eg(x).
In this case Tnew = P p(T (n), T (l)), where P p denotes
polynomial of degree p, and Told = T (l · n).
The question to answer is: when f(n · l) > P p(f(n), f(l)).
According to our assumptions, we obtain that the comparison
of the computation times in (1) looks like:
eg(n·l) > ap(ep·g(n) + ep·g(l)).
Assume that n = l. Then g(n2) > p · g(n) + ln2 + ln(ap).
Assume that g(x) = ln2(x), then f(x) = xln(x). In this case
we obtain that (1) is transformed to: ln2(n2) > p · ln2(n) +
ln2 + ln(ap) or ln2(n) > ln(2·ap)
2−p
.
D. Complexity gain for other logics
If we use FOL or another logic, where the computational
procedure is polynomial in the sizes of G and in I and each
Gı too, then we do not obtain any time gain.
VI. SCENARIO B: INCREMENTAL RE-COMPUTATIONS
In this section, we consider the underlying structure, the
formula and the modularity as well as possible applications
of our method for incremental re-computations. We analyze
the corresponding complexity gain for the computations of
properties, expressible in different logics.
A. The underlying structure, the formula and the modularity
Our underlying structure is a sum-like graph, and the
property, which we want to check on it, is expressible in a
formula φ that has a polynomial checker. Assume that we
change several times (let us denote the number of the times
by ς) some ﬁxed component ˘G of G. We check each time
whether G |= φ.
B. Applications
We restrict ourselves to the case of hardware veriﬁcation,
where we ﬁnd the following situation: We are given a mathe-
matical model of a device in form of a ﬁnite relational structure
G (FSM or Kripke model) and a formalized property φ.
Usually φ is given in advance and G is being built with the aim
to satisfy φ. Checking whether φ holds in G is to be atomized.
This process is called model checking. The literature is rich
in papers addressing this problem, cf. [15].
As a rule, hardware design G is built from components
(modules) Gi, where i ∈ I. The modules are the building
blocks, installing one in other that gives the design hierarchy.
The communication between a module and its environment
is executed using ports. All but the top-level modules in a
hierarchy have ports. In the process of building G, several
candidate structures Gj have to be checked for φ, where j
denotes the jth attempt of designing G. Often Gj differs from
Gj+1 in one component Gi
j+1. It is easy to see (Figure 2)
that our motivating example exactly fails in this framework,
when we are talking about hardware design rather than about
city maps. Combination of graphs in terms of graph grammars
may be found also in [23].
5
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

C. Complexity gain for FOL
Let Told be time to solve the given problem by the tradi-
tionally applied way. It should be clear that Told = ς · T (N).
Let Tnew be time to solve the same problem, when structure
G is viewed as a generalized sum. It is easy to see that
Tnew(N, n) = T (N − n) + ς · T (n) + TFΦ,φ + ς · TS.
The question to answer is: which value of n provides that
Told > Tnew. Assume that T (x) = x2, then (1) becomes to
be:
ς · N 2 > (N − n)2 + ς · n2 + TFΦ,φ + ς · TS
N 2 − 2 · n · N + n2(ς + 1) + TFΦ,φ + ς · TS − ς · N 2 < 0
n1,2 =
N±√
N 2+(ς+1)(N 2(ς−1)−TFΦ,φ−ς·TS)
ς+1
.
If n1 ≤ n ≤ n2 then Told > Tnew.
n2 =
N+√
ς2(N 2−TS)−ς(TS+T FΦ,φ)−TFΦ,φ
ς+1
limς→∞n2 = √N 2 − TS.
The same consideration can be done for other polynomial
dependencies T (x) for FOL-deﬁnable logics.
D. Complexity gain for other logics
Let L be any proper sub-logic of MSOL stronger that
FOL. Our theorems do not hold in the following: if we apply
it then ψı, are not necessary in L.
VII. SCENARIO C: PARALLEL COMPUTATIONS
In this section, we consider the underlying structure, the
formula and the modularity as well as possible applications of
our method for parallel computations. We analyze the corre-
sponding complexity gain for the computations of properties,
expressible in different logics.
A. The underlying structure, the formula and the modularity
Our underlying structure is a sum-like graph G, and the
property, which we want to check on the structure, is express-
ible in formula φ of a logic. We check whether G |= φ.
B. Applications
Let us consider the following composition of two input
graphs H and G. G can be viewed as a display graph, where
on each node we want to have a copy of H, such that certain
additional edges are added. In practice, this is a model on how
a pipeline works. The nodes marked with Lj are the latches.
Let G = ⟨VG, R⟩ and H = ⟨VH, S, Lj(j ∈ J)⟩ be two
relational structures (J is ﬁnite), then their composition C =
⟨VC, L1
C, ..., L|J|
C , SC, Rj
C(j ∈ J)⟩ is deﬁned as follows, see
Figure 5:
• VC = ˙S
g∈GV g
H, where each V g
H is isomorphic to VH;
• Lj
C(w) is true if w belongs to Lj;
• SC = {(w, v) : w ∈ V g
H, v ∈ V g
H, S(w, v)};
• Rj
C = {(w, v) : Lj(w), Lj(v), P(i, w), P(i′, v), R(i, i′)}.
C can be obtained from the disjoint union ˙F
g∈GH by a FOL
translation scheme. In this example, depending on the choice
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
6
6
6

*

*
HHHHH
H
Y
HHHHH
H
Y

:
XXXXXXXXXXX
X
y
6
6
6

*

*
HHHHH
H
Y
HHHHH
H
Y

:
XXXXXXXXXXX
X
y
6
6
6

*

*
HHHHH
H
Y
HHHHH
H
Y

:
XXXXXXXXXXX
X
y
6
6
6
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
H
G
Fig. 5.
Uniform graph substitution.
of the interpretation of the Lj’s, more sophisticated parallel
computations can be modeled, but not all.
C. Complexity gain
In (1), the new computation time is calculated as:
Tnew = EI + Σı∈IEı + CI + Σı∈ICı + TFΦ,φ + TS
for the case, when all the computations are done sequentially
on a single computational unit. In fact, now even personal
computers and smartphones have several cores. In this case,
the computation may be done in the following way (we
assume that there exist enough computational units for total
parallelism) :
Extraction Super Step: The extraction of the index structure
I from G and each Gı from G may be done in parallel as
well as the building of FΦ,φ. We denote the extraction time
by: E = max{EI, maxı∈I{Eı}, TFΦ,φ}.
Computational Super Step: The computation of all values
of bI, and bı, may be done in parallel as well. We denote
by C = max{CI(nI), maxı∈I{Cı(nı)}}. In fact, at this step,
even more parallelism may be reached if we compute all bı,
in parallel.
Final Proceeding: TS still denotes time to search one result
of FΦ,φ. The new computation time for the case of full
parallelism is: T BSP
new
= E + C + TS. The computation model
fails in the general framework of BSP, cf. [6].
D. Complexity gain for MSOL
The computation is exponential in the form: T = eg(x).
In this case Told = T = f(N) = eg(N) and T BSP
new
= E +
P p(eg( N
k ))+TS and the question to answer is: when f(n·k) >
P p(f(n)). According to our assumptions, we obtain:
eg(n·k) > E + ap · ep·g(n) + TS.
Assume that k = n, it means that there exist enough compu-
tation units for full parallelization. In this case, the condition
of the effective computation looks like:
eg(n2) > E + ap · ep·g(n) + TS.
6
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

E. Complexity gain for FOL and other logics with polynomial
checkers
Assume that again T (x) = x2, and each Gı are of the same
size N
k then:
Told = N 2 and T BSP
new
= E + ( N
k )2 + TS
N 2 > E + ( N
k )2 + TS ; N 2 − ( N
k )2 > E + TS
Now the condition of the effective computation looks like:
N 2 · (k2−1)
k2
> E + TS
Complexity consideration for other logics L, which are proper
sublogics of MSOL stronger that First Order Logic, are
similar to the given in subsection VI-D.
VIII. SCENARIO D: PARALLEL COMPUTATIONS ON
DISTRIBUTED DATA
In this section, we consider the underlying structure, the
formula and the modularity as well as possible applications of
our method for parallel computations on distributed databases.
We analyze the corresponding complexity gain for the com-
putations of queries, expressible in different logics.
A. The underlying structure, the formula and the modularity
Our underlying structure is a sum-like graph G that is
stored in the distributed way: each Gı is stored in the ıth
site. The property, which we want to check on the structure, is
expressible in formula φ of a logic. We check whether G |= φ.
B. Applications
We
restrict
ourselves
to
investigation
of
distributed
databases. In this case, a user sees one (virtual) database
instance over a ﬁxed database scheme. Queries and updates
are submitted to a central processing site which will compute
the required view or transaction by distributing the appropriate
sub-tasks among the different sites.
While Datalog is hard to check, cf. [14], in [24], a new
variant of Datalog was introduced: Datalog LITE. On the one
hand, the deductive query language has linear time model
checking. On the other hand, it encompasses modal and
temporal logics, such as CTL and alternation-free µ-calculus.
Moreover, it was shown that Datalog LITE with only unary
and binary input predicates is contained in MSOL.
Assume we are given a database scheme that contains four
relations: R = (R1, R2, R3, R4). Assume that we want to
deﬁne a view that is derived from the database by applying
the following query, given in the format of relational algebra:
(πAR1 ∪ R2) ▷◁ (R3 − σξR4). In this case, the corresponding
translation scheme is: ΦV iew = ⟨x = x, φV iew⟩, where
φV iew = (πAR1 ∪ R2) ▷◁ (R3 − σξR4).
Let RI be an index scheme with ﬁnite domain and
|I| = n (to simplify the example, let n=2) and let R1 =
(R(y1, . . . , yr1)), R2 = (R(y1, . . . , yr2)) be database schemes
Rı(i ∈ {1, 2}), where rj(j ∈ {1, 2}) be an arity of the cor-
responding relation. Let R=F
ı∈IRı= (P(ı, x),I(x), R1, R2)
be a R database scheme, which is the disjoint union of Rı’s.
We deﬁne the following translation scheme ΦJoin from the
R-instances to S-instances, where S = (S).
ΦJoin = ⟨y ≈ y, ∃y1
r1∃y2
1(R1(y1
1, . . . , y1
r1)∧
R1(y2
1, . . . , y2
r1) ∧ φ=(y1
r1, y2
1))⟩.
Assume we are given a sum-like database and we want to
compute the view (query), deﬁned by φ. Now, given a tuple t
over I(R), in order to check whether t belongs to the view,
deﬁned by φ, we compute the following:
1) V iewi
j = {t ∈ Ii(R) : ψj}, the views at site i, deﬁned
by the queries ψj.
2) Xt
j = {i ∈ I : t ∈ V iewi
j}, the set of sites where t
belongs to the view, deﬁned by ψj;
3) The truth value of I(RI) |= ψI(Xt
1, . . . , Xt
n).
By our theorems: tuple t belongs to the view, deﬁned by φ,
iff I(RI) |= ψI(Xt
1, . . . , Xt
n). In other words
{t : I(R) |= φ} = {t : I(RI) |= ψI(Xt
1, . . . , Xt
n)}.
We see that V iewi
j is computed at the site i and only the
queries ψj have to be sent over the net. The V iewi
j’s can
be computed in parallel. Furthermore, when we compute Xt
j,
only the tuple t is sent over the net. Finally, evaluating ψI
can be done in PSpace (in the size of I). However, it is
likely that for special cases of ψI (when φ is a pure Datalog
query) the complexity (in the size of I) becomes (at least non-
deterministically) polynomial.
In distributed databases, where the data are measured in
gigabytes (terabytes) and the size of I is a small ﬁnite set (say
≤ 100), this method, in spite of its considerable overhead,
gives a considerable improvement over any other method,
which moves parts of the databases over the net.
Further gains can be achieved by exploiting a hierarchical
structure of the way the databases are distributed: we introduce
virtual sites (gather sites), which gather the data of its sub-
sites and make sure that the number of sub-sites remains
bounded (say ≤ 10). At each gathering site, the evaluation
of ψI remains thus feasible.
As it was shown in [25], our method generalizes the
propagation technique from [26] for relational algebra and
the incremental re-computation technique from [27] for some
kinds of Datalog programs to cases of deﬁnable sets of tuples
to be deleted or inserted.
In addition, assume that the query language allows us to
ask optimization questions. In such cases, our generalized
propagation technique may be directly extended to the case
of incremental optimization as considered in [28][29][30].
Using our method, the ﬁnal optimal result is computed from
the local (not necessarily optimal) solutions as explained in
[3]. Moreover, our approach is directly connected to Parallel
Distributed Genetic Programming as introduced in [31].
C. Complexity gain
The full computation process is composed now from the
following steps (the above E = 0):
7
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

Computational
Super
Step
The
computation
of
all
values of bI, and bı, is done in parallel in the corresponding
sites. We still denote by C = max{CI(nI), maxı∈I{Cı(nı)}}.
Recall that in each site, the bı, still may be computed in
parallel if the corresponding computer has several cores.
Communication Super Step The results bI, and bı, must
be sent for the ﬁnal proceeding. We denote by TI time to
transfer all values of bI,, and by Tı time to transfer all
values of bı,. The communication time now is calculated as
T = max{TI, maxı∈I{Tı)}}.
Final Proceeding TS still denotes time to search one result
of FΦ,φ.
The new computation time of (1) for the case of the
distributed storage and computation is: T distr
new
= C + T + TS.
If the computations and the data transfer in each site may be
done in parallel then we may combine two ﬁrst super steps
in the above model in one step that, in fact, leads to some
variation of LogP model, introduced in [7]. If we denote by
D = max{(CI(nI) + TI), maxı∈I{(Cı(nı) + Tı)}}, then the
corresponding computation time is: T LogP
new
= D + TS.
IX. CONCLUSION
In this work, we consider computations on sum-like graphs.
We considered different scenarios, when our method leads
to improvement in the complexity of the computations. We
have shown several applications of our method in the ﬁelds of
design and veriﬁcation of repetitive and hierarchical structures,
parallel computations, computations on distributed data.
Each of the considered computational models may be
combined with each of scenarios A-D in order to analyze
Told/Tnew. In fact, this analysis is a generalized formulation of
Amdahl’s style law for each computation model and scenario.
Acknowledgments
We are would like to thank Prof. J. A. Makowsky for valu-
able discussions as well as for his reading of the contribution
and his many suggestions.
Finally we would like to thank the referees for their careful
reading and constructive suggestions.
REFERENCES
[1] J. Makowsky and E. Ravve, “Incremental model checking for decom-
posable structures,” in Mathematical Foundations of Computer Science
(MFCS’95), ser. Lecture Notes in Computer Science, vol. 969. Springer
Verlag, 1995, pp. 540–551.
[2] E. Ravve and Z. Volkovich, “A systematic approach to computations on
decomposable graphs,” 2013, to appear in Proceedings of SYNASC13.
[3] E. Ravve, Z. Volkovich, and G.-W. Weber, “Effective optimization with
weighted automata on decomposable trees,” 2013, optimization Journal
Special Issue at ECCO 2013.
[4] S. Feferman and R. Vaught, “The ﬁrst order properties of products of
algebraic systems,” Fundamenta Mathematicae, vol. 47, pp. 57–103,
1959.
[5] J. Makowsky, “Algorithmic uses of the Feferman-Vaught theorem,”
Annals of Pure and Applied Logic, vol. 126, pp. 159–213, 2004.
[6] L. Valiant, “A bridging model for parallel computation,” Communica-
tions of the ACM, vol. 33(B), pp. 103–111, 1990.
[7] D. Culler, R. Karp, D. Patterson, A. Sahay, K. Schauser, E. Santos,
R. Subramonian, and T. von Eicken, “LogP: towards a realistic model
of parallel computation,” in PPOPP ’93 Proceedings of the fourth
ACM SIGPLAN Symposium on Principles and practice of parallel
programming, vol. 28(7), 1993, pp. 1–12.
[8] (2013,
Jan)
Seville
map.
[Online].
Available:
http://www.lonelyplanet.com/maps/europe/spain/andalucia/seville/
[9] H. Ebbinghaus, J. Flum, and W. Thomas, Mathematical Logic, 2nd
edition, ser. Undergraduate Texts in Mathematics.
Springer-Verlag,
1994.
[10] J. Makowsky, “Translations, interpretations and reductions,” 1994, un-
published Manuscript.
[11] R. Fagin, “Generalized ﬁrst-order spectra and polynomial time recogniz-
able sets,” in Complexity of Computation, ser. American Mathematical
Society Proc, R. Karp, Ed., vol. 7.
Society for Industrial and Applied
Mathematics, 1974, pp. 27–41.
[12] M. Garey and D. Johnson, Computers and Intractability, ser. Mathemat-
ical Series.
W.H. Freeman and Company, 1979.
[13] J. Makowsky and Y. Pnueli, “Arity vs. alternation in second order
deﬁnability,” in LFCS’94, ser. Lecture Notes in Computer Science, vol.
813.
Springer, 1994, pp. 240–252, (Extended version to appear in the
Annals of Pure and Applied Logic, 1995).
[14] M. Vardi, “The complexity of relational query languages,” in STOC’82.
ACM, 1982, pp. 137–146.
[15] E. Emerson, “Temporal and modal logic,” in Handbook of Theoretical
Computer Science, J. van Leeuwen, Ed.
Elsevier Science Publishers,
1990, vol. 2, ch. 16.
[16] J. Makowsky and E. Ravve, “Incremental model checking for ﬁxed
point properties of decomposable structures,” 1995, technical Report
TR844, revised version, April 1995, Department of Computer Science,
Technion–Israel Institute of Technology, Haifa, Israel.
[17] N. Biggs, R. Damerell, and D. Sands, “Recursive families of graphs,”
Journal of Combinatorial Theory, vol. 12, pp. 123–131, 1972.
[18] B. Courcelle and J. Makowsky, “Fusion in relational structures and
the veriﬁcation of monadic second-order properties,” Mathematical.
Structures in Comp. Sci., vol. 12, pp. 203–235, April 2002. [Online].
Available: http://dl.acm.org/citation.cfm?id=966880.966886
[19] E.
Fischer
and
J.
Makowsky,
“Linear
recurrence
relations
for
graph
polynomials,”
in
Pillars
of
computer
science,
A.
Avron,
N.
Dershowitz,
and
A.
Rabinovich,
Eds.
Berlin,
Heidelberg: Springer-Verlag, 2008, pp. 266–279. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1805839.1805854
[20] D. Babi´c, A. Graovac, B. Mohar, and T. Pisanski, “The matching
polynomial of a polygraph,” Discrete Applied Mathematics, vol. 15, pp.
11–24, 1986.
[21] E. Cockayne, E. Hare, S. Hedetniemi, and T. Wimer, “Bounds for the
domination number of grid graphs,” Congr. Numer, vol. 47, pp. 217–228,
1985.
[22] D. Crandall. (2013, Jan) CSE 477 design project speciﬁcations
report for the discrete cosine transform decoder. [Online]. Avail-
able: http://www.cs.indiana.edu/ djcran/projects/cse477/report3/report3-
2.html
[23] A. Glikson and J. Makowsky, “NCE graph grammars and clique-width,”
in WG’03, 2003, pp. 237–248.
[24] G. Gottlob, E. Gr¨adel, and H. Veith, “Datalog LITE: a deductive
query language with linear time model checking,” ACM Transactions
on Computational Logic, vol. 3(1), 2002.
[25] E. Ravve, “Decomposition of databases with translation schemes,” Ph.D.
dissertation, Department of Computer Science, Technion–Israel Institute
of Technology, Haifa, 1998.
[26] X. Quan and G. Wiederhold, “Incremental recomputation of active
relational expressions,” IEEE Transactions on Knowledge and Data
Engineering, vol. 3, no. 3, pp. 337–341, 1991.
[27] G. Dong and R. Topor, “Incremental evaluation of Datalog queries,” in
Database Theory, 4th ICDT’92, ser. Lecture Notes in Computer Science,
J. Biskup and R. Hull, Eds., vol. 646.
Springer Verlag, 1992, pp. 282–
296.
[28] R. Neal and G. Hinton, “A view of the EM algorithm that justiﬁes
incremental, sparse, and other variants,” in Learning in Graphical
Models.
Kluwer Academic Publishers, 1998, pp. 355–368.
[29] S. Ahn, J. A. Fessler, D. Blatt, and A. Hero, “Convergent incremental
optimization transfer algorithms: Application to tomography,” IEEE
Trans. Med. Imaging, vol. 25(3), pp. 283–296, 2006.
[30] O. S¸eref, R. Ahuja, and J. Orlin, “Incremental network optimization:
Theory and algorithms,” Operations Research, vol. 57, pp. 586–594,
2009.
[31] R. Poli, “Evolution of graph-like programs with parallel distributed
genetic programming,” in Proceedings of 7th ICGA, 1997, pp. 346–353.
8
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

