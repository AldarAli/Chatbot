An Invariant based Passive Testing approach for Protocol Data parts
Felipe Lalanne, Stephane Maag
Institut Telecom / TELECOM SudParis
CNRS UMR 5157
9, rue Charles Fourier
F-91011 Evry Cedex, France
{Felipe.Lalanne, Stephane.Maag}@it-sudparis.eu
Abstract—Conformance of implementations to protocol spec-
iﬁcations is essential to assure interoperability between peers
in network communications. Monitoring or passive testing
techniques are used when no access to the communication
interfaces is available or when the normal operation of the
system cannot be interrupted. Most monitoring techniques
only consider control portion of exchanged messages, usually
ignoring the data part. However, as protocols become more
complex and message exchange more data intensive, testing
for data relations and constraints between exchanged messages
becomes essential. In this paper we propose a novel approach
for deﬁning such relations as properties called invariants and
show how they can be tested directly on traces using logic
programming. Experimental results for SIP protocol traces are
provided.
Keywords-monitoring; invariant-based testing; data con-
straints; logic programming; network management
I. INTRODUCTION
Communication standards for network protocols make it
possible for different types of systems or different types
of implementations to interoperate. Conformance to stan-
dards is essential to achieve communication on the Internet.
Formal methods and testing techniques [1] allow to assess
the conformance of implementations, usually by generating
test cases from some type of speciﬁcation based on the
requirements of the protocol. These test cases are then
provided as input to the Implementation Under Test (IUT)
and the answers checked against those of the speciﬁcation.
This approach, however, is not feasible when the IUT is in
a production environment where its normal function cannot
be disrupted. Monitoring (or Passive testing) techniques
rely on observing the inputs/outputs provided by normal
operation of the IUT, and then attempt to detect faults,
either by comparing the observed events with the speciﬁ-
cation [2], [3], or by directly evaluating certain properties
on the input/output trace [4], [5], [6]. For this last approach,
called invariant-based testing, some properties (invariants)
are deﬁned, either by experts, directly from the protocol
standard, or by extracting them from a formal speciﬁcation.
This techniques allows to test properties such as “If x
happens, then y MUST happen” or “For x to happen, then
y MUST have happened before” directly on the trace.
The current work deals with the application of such
invariant-based techniques, particularly on the context of IP
Multimedia Subsystem (IMS) applications. These kind of
applications present interesting challenges for passive moni-
toring, given the distributed architecture of the IMS, and the
utilization of a common protocol, the Session Initialization
Protocol[7] (SIP) on most session management procedures,
evaluating properties on a trace becomes non-trivial as
shown by Figure 1. In [8] we deﬁned some properties for
testing on the Push-to-talk Over Cellular[9] (PoC) service
traces, based on the protocol standard requirements, for
instance
INV ITE(CSeq = c0, From = u0, To = u1)/θ, ∗,
θ/OK(CSeq = c0, From = u0, To = u1)
indicates that a SIP OK response can only be received if an
INVITE request was received ﬁrst. As it can be seen in the
Figure 1, the PoC trace also contains OK responses for SUB-
SCRIBE and NOTIFY requests, used by the Presence[10]
service for communication. This produced false positive
FAIL verdicts when tested on the trace, given that the
property cannot distinguish between an OK response for an
INVITE message from other OK for other type of request,
or even from responses to a different INVITE message.
Granted, it can be argued that the deﬁned property is
rather simplistic in its deﬁnition, but shows the limitation
of the expressive power of invariant properties deﬁned this
way to express data relations between messages, essential
to perform more accurate testing. We believe that a more
complete deﬁnition of message data and data relations for
network protocol testing is necessary. This is the main
motivation for the current paper.
In network protocols, communication is achieved through
an exchange of messages between peers, where each peer
can intermittently act as a receiver or as an emitter of
the messages. As protocols evolve, messages become richer
in data. Most passive testing approaches consider a small
part of the message information called the control part (the
INVITE, OK in the previous example), but very few consider
the data constraints and relations for the message exchanges.
A couple of examples of this are presented in [11] and
[12]. In the ﬁrst one, the authors use an interval reﬁnement
94
AICT 2011 : The Seventh Advanced International Conference on Telecommunications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6

SIP Request: INVITE
SIP Request: INVITE
SIP Response: 200 OK
SIP Request: SUBSCRIBE
SIP Response: 200 OK
SIP Request: NOTIFY
SIP Request: NOTIFY
SIP Response: 200 OK
IMS Core
PoC
Presence
Figure 1.
Interactions between applications of the IMS Subsystem.
The PoC service, an IMS application, communicates with the Presence
application and with the clients throught the IMS Core, all using functions
of the SIP protocol.
approach to determine faults in a trace, either in data or
state, by evaluation into a EEFSM (Event-driven Extended
Final State Machine) formal speciﬁcation. In the second one,
the authors develop an algorithm to verify invariants on an
EFSM speciﬁcation and extract data constraints from them.
However these works require a speciﬁcation of the system
under test, and in the industry, a complete speciﬁcation is
rarely available, particularly for large systems. In our work
we test properties directly in the trace without the help of
any formal speciﬁcation.
We propose a methodology, based on ﬁrst-order logic,
that makes it possible to formally specify data-oriented
invariants, and show how they can be tested in ofﬂine traces
using a logic programming approach.
The main contributions of our work are:
• We reﬁne the deﬁnitions of message and trace using
ﬁrst-order logic concepts, to better consider data do-
mains and properties inside messages.
• With this new deﬁnition we describe how to specify
data constraints and relations between messages, and
deﬁne invariants as formulas in ﬁrst-order logic.
• We prove the soundness of the deﬁnition to show that
if an invariant veriﬁed in a formal speciﬁcation does
not hold in a trace, the corresponding implementation
does not conform to the formal speciﬁcation.
• We show how invariant formulas can be tested in real
traces using logic programming and the equivalence
with the ﬁrst-order logic deﬁnitions.
• Finally, we present an example on the SIP protocol
and show the results of testing in PoC service traces
in comparison with our previous work.
II. PRELIMINARIES
In this section we describe some necessary concepts that
are the basis for the introduction of data into invariants and
to demonstrate the correctness of the deﬁnitions. The Event-
driven Extended Finite State Machine formalism and ﬁrst-
order logic.
A. Event-driven Extended Finite State Machine
For the purpose of this paper, we use the Event-driven
Extended Finite State Machine (EEFSM) formalism, suitable
for monitoring techniques, introduced by the authors of [11]
and [13].
Deﬁnition 1. An Event-driven Extended Finite State Ma-
chine (EEFSM) is a 6-tuple M =< S, s0, Σ, ⃗x, ⃗y, T > where
S = {s0, s1, . . . , sn−1} is a ﬁnite set of states with s0 ∈ S as
the initial state, Σ is a ﬁnite set of events, where for each
e(⃗y) ∈ Σ, e is the event name and ⃗y = {y1, . . . , yq} is the
ﬁnite set of event parameters, ⃗x = {x1, . . . , xp} is a ﬁnite
set of internal variables, and T is a ﬁnite set of transitions.
For a transition t =< s, s′, e(⃗y), P(⃗x, ⃗y), A(⃗x, ⃗y) >, s, s′ ∈ S
are the starting and ending states of the transition, e(⃗y) is
the triggering event, P(⃗x, ⃗y) is a predicate and A(⃗x, ⃗y) is an
action, which is a sequence of assignments ⃗x := A(⃗x, ⃗y),
where ⃗x and ⃗y are the current variable and event parameter
values, respectively.
Example
1.
The
EEFSM
transition
t
:
s
?a(y1),[y1>x1],x2:=y1+8
−−−−−−−−−−−−−−−−→
s′,
indicates
that
when
the
system is in state s, upon reception of event a with
parameters y1, if [y1 > x1] then it will assign to variable x2
the new value of y1 + 8 and ﬁnally leave the system in state
s′.
B. First-order Logic
Some basic concepts of ﬁrst order logic are provided
since they are necessary to include data for invariants. A
more complete reference on ﬁrst-order theory for computer
science can be found in [14].
The ﬁrst-order logic vocabulary is composed by two sets:
a set of predicate symbols P and a set of function symbols
F. Each type comes with an arity, the number of parameters
it expects. Functions of arity 0 are called constants. The pair
(F, P) is called a logical signature.
The ﬁrst-order vocabulary rules can be deﬁned with the
introduction of terms and formulas, where a term is deﬁned
in Backus-Naur form as t ::= x|f(t, ..., t) where x is a
variable, f ∈ F has arity n, and formula is deﬁned as
φ ::= P(t1, t2, ..., tn)|¬φ|φ ∧ φ|φ ∨ φ|φ ⇒ φ|∀xφ|∃xφ where
P ∈ P is a predicate of arity n, ti are terms and x is a
variable.
In order to semantically evaluate ﬁrst-order logic formu-
las, a meaning must be given to the predicate and function
symbols, that is, they must be associated with real predicates
and functions of a speciﬁc context or universe. A model M
is deﬁned as a triplet < U, (fM)f∈F, (PM)P ∈P >, where
• U is a non-empty set called universe.
• For each f ∈ F with arity n, a concrete function fM is
deﬁned as fM : U n −→ U
• For every P ∈ P with arity n, PM ⊆ U n
Finally, in order to evaluate formulas, variables have to be
mapped to particular values in the universe. Given a set X
95
AICT 2011 : The Seventh Advanced International Conference on Telecommunications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6

of variables a function l : X → U is called an interpretation.
With this concept, given a model M for a signature (F, P)
and a formula φ, a satisfaction relation is deﬁned as M |=l φ
meaning that the formula φ is true with respect to M under
interpretation l.
III. DATA IN NETWORK PROTOCOLS
In a network protocol, a communication peer decides
the course of action on the basis of two things: Locally
stored state information (including internal data), and data
contained in received messages from different peers. In
passive testing, while the observed message data is available
to the tester, state information and internal data are unknown.
In order to test data, focus on the exchange of messages is
fundamental, however, a formal deﬁnition must be provided
ﬁrst.
A protocol message is, in general, a collection of data
ﬁelds of different domain, where each data ﬁeld has a
function in the data exchange. The format of the message,
the function and domain of each ﬁeld are deﬁned in the
requirements speciﬁcation of the protocol.
The most basic domains of data we can ﬁnd in protocols,
are numeric and alphanumeric (string) values. Basic data
domains can be combined in order to deﬁne more complex
domains. For instance, an email data element can be de-
ﬁned as mailbox ::= local-part "@" domain, in
order to distinguish the recipient from the sending address.
Traditional passive testing deﬁnitions, distinguish between
a control portion and a data portion of messages, this
is actually an abstraction necessary for compatibility with
model-based testing. In practice, a trace is only a sequence
of messages containing data. These messages are classiﬁed
afterwards, according to their function in the protocol,
determined by the data. This function is what constitutes
the control portion. Although this is not really necessary
for our approach, we will include the distinction between
control and data in the deﬁnition of a message, in particular
to make it compatible with the EEFSM formalism.
Deﬁnition 2. A message is a structure m = e(⃗x) where e
is the message label belonging to some ﬁnite set L, and
⃗x = (x1, . . . , xn) is a ﬁnite set of message parameters or
message variables, where each xi ∈ Dj ∪ {ϵ}, with Dj as
its data domain (Dj’s are not necessarily disjoint). The null
value is represented by ϵ, where ϵ /∈ Dj, ∀j ∈ 1 . . . n.
In the deﬁnition, e constitutes the control portion of the
message and ⃗x is the data portion. The null value ϵ is used
to allow messages with dynamic number of variables within
the ﬁxed-size set ⃗x.
It is easy to see that this deﬁnition of a message is
compatible with the one of event in an EEFSM and every
possible message is an event, however it should be clear
that not every possible EEFSM event is a message. From
here on, we will denote as M the domain of all possible
messages for a given EEFSM.
In order to reference a particular variable for a message
m we will use the symbol ‘.’ to reference it, for instance
m.email to reference the variable of name email in message
m. This should be considered only as a convention in order
to ease the writing of formulas and not a formal deﬁnition.
IV. INCORPORATING DATA INTO INVARIANTS
In this section we describe how we incorporate data into
invariants, by using the previously described logic concepts.
We start by deﬁning a new way to represent traces more
suitable with a ﬁrst-order model.
A. Trace representation
Using the traditional model-based approach, a trace
can be deﬁned in terms of an EEFSM: Given M
=<
S, s0, Σ, ⃗x, ⃗y, T
>, we say that the sequence
T
=<
e1(⃗y1), e2(⃗y2), . . . , en(⃗yn)
> is a trace for M, if there
exist states s, s1, . . . , sn−1, s′
∈
S such that we have
the following transitions s
e1(⃗y1);P1(⃗x0,⃗y1);A1(⃗x0,⃗y1)
−−−−−−−−−−−−−−−−−−→
s1,
. . . , sn−1
en(⃗yn);P1(⃗xn−1,⃗yn);An(⃗xn−1,⃗yn)
−−−−−−−−−−−−−−−−−−−−−−→ s′, where ⃗x0 is t
he internal variable state before the ﬁrst transition, and
P1, . . . , Pn and A1, . . . , An are respectively the predicates and
actions for the transitions. In order to make the concept
of trace more compatible with our current approach, we
propose an alternative representation
Deﬁnition 3. Let M =< S, s0, Σ, ⃗x, ⃗y, T > be an EEFSM and
M the domain of all possible messages for M, the structure
T =< R, m0, Next > is deﬁned, where
• R ⊆ M is a ﬁnite, non-empty set of messages.
• m0 ∈ R is the ﬁrst message of the trace.
• Next ⊆ R × R is a relation that maps a message to its
next on the trace. i.e Next(x, y) indicates that x comes
immediately after y on the trace. This relation must
satisfy the property Next(x, y) ∧ Next(x, z) ⇔ y = z,
to restrict to a single successor for each element.
T
is
said
to
be
a
trace
for
M
if
there
exist
states
s, s1, . . . , sn−1, s′
∈
S
such that the following
transitions exist:
s
m1=e1(⃗y1);P1(⃗x0,⃗y1);A1(⃗x0,⃗y1)
−−−−−−−−−−−−−−−−−−−−−→
s1, . . . ,
sn−1
mn=en(⃗yn);P1(⃗xn−1,⃗yn);An(⃗xn−1,⃗yn)
−−−−−−−−−−−−−−−−−−−−−−−−−−→
s′, where mi
=
ei(⃗yi) ∈ R and Next(mi, mi+1) holds for every i = 1 . . . n−1.
For convenience we also deﬁne the following relations for
the trace.
• Prev(x, y) indicates that message x comes immediately
before y in the trace.
• After(x, y) the relation indicating that message x
comes after message y in the trace.
• Before(x, y) the relation indicating that message x
comes before message y in the trace.
For the remainder of the paper, it should be assumed that
the variables domain is the trace. That is, the expression
∃u1, . . . , un is equivalent to ∃u1, . . . , un ∈ T.
96
AICT 2011 : The Seventh Advanced International Conference on Telecommunications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6

Finally, we deﬁne Traces(M) as the set of all possible
traces for the EEFSM M.
B. A model for protocol traces
As our interest is to interpret invariant properties seman-
tically, it is necessary to ﬁrst deﬁne a model. We deﬁne
the universe of the model as the trace, where properties are
expected to hold.
Given (F, P) a logical signature, and a trace T
=
(R, m0, Next), we specify the sets
• F ′ = F
• P′ = P ∪ {Next, Prev, Before, After}.
With (F ′, P′) as a new signature, a model for the trace
M(T) is constructed as follows
• The universe U = T.
• Each P ∈ P′ is speciﬁed as a formula on the message
variables for the involved messages. For instance let’s
suppose that each message in the trace contains a
variable index indicating the order where each message
was collected into the trace. Then the predicate Next
can be stated as
Next(x, y) ← x.index = y.index + 1
• For each f ∈ F ′ of arity n a concrete function is deﬁned
as fM(T) : Tn → T. We do not impose any restrictions
on the kind of functions that can be deﬁned, other than
they must be within the domain of the trace, however,
for the examples in this paper we will not make use of
them.
C. Invariant deﬁnition
As the name implies, an invariant is a property that must
be true for every trace from an implementation, formally we
deﬁne
Deﬁnition 4. Let M =< S, s0, Σ, ⃗x, ⃗y, T > be an EEFSM,
M(T) =< T, (fM(T))f∈F, (PM(T))P ∈P > be a model for a
trace T and X a set of variables, an invariant is any formula
φ such that there exists at least one interpretation l : X → T
where M(T) |=l φ for every trace T ∈ Traces(M).
The fact that an invariant must hold every trace from the
model, immediately imposes a restriction on the type of
formulas that are possible, since a trace may not involve
a particular property being evaluated. In particular, the
deﬁnition restricts invariants to formulas of the type φ ⇒ ψ.
Due to the rules of logical implication, if the ﬁrst part of
the formula is false, the value of the formula is immediately
true. For our approach, we will further restrict to formulas
of the type: ∀x1, . . . , xpφ ⇒ ∃y1, . . . , yqψ, making it possible
to describe properties such as “Whenever x happens then y
must (have) happen(ed)”.
V. CORRECTNESS OF CHECKING INVARIANTS IN A
TRACE
In this section we will ﬁrst show the correctness of our
approach, by using a trace preorder implementation relation,
and then we show how to test invariants on the trace.
We begin by introducing the trace preorder implementation
relation deﬁnition as
Deﬁnition 5. Let S and I be two EEFSMs. We say that
I trace conforms to S, denoted I ≤tr S if and only if
Traces(I) ⊆ Traces(S) ∧ Traces(I) ̸= ∅.
This deﬁnition of conformance, requires that every possi-
ble trace generated by the implementation, must be possible
in the speciﬁcation. To prove the soundness of our deﬁni-
tions, we also need to deﬁne correctness of an EEFSM trace
with respect to an invariant as
Deﬁnition 6. Let I
def= ∀x1, . . . , xpφ ⇒ ∃y1, . . . , yqψ be an
invariant and T a trace from an EEFSM. We say that T is
correct with respect to I if there exists an interpretation
l : var(I) → T, such that I holds.
Theorem 1. Let S and I be two EEFSM and I be an
invariant veriﬁed on S. Let T be a trace recorded from I. If
the trace T is not correct by Deﬁnition 6, with respect to I,
then I does not conform to S.
The proof is direct with the provided deﬁnitions.
Proof: Let I be a correct invariant and T ∈ Traces(I) a
trace that is not correct with respect to I. By Deﬁnition 4, I
holds for every trace in S, which means that T /∈ Traces(S),
then Traces(I) ⊈ Traces(S), therefore, by Deﬁnition 5, I
does not conform to S.
We conclude this section by describing how we can check
the correctness of invariants directly on a real trace by using
logic programming. A description of logic programming is
not provided, we recommend [15] as a good reference.
In logic programming, a program is composed by a set
of clauses of the type A0 ← A1 ∧ . . . ∧ An where each Ai is
an atomic formula (a predicate) that states a fact. Programs
allow to test goals, or statements for which we want to obtain
a truth value. The goal G is valid in the program P if P |= G.
In our approach, we can make the parallel between
clauses and predicate deﬁnitions, and between goals and
invariants. In order to test the invariants on a real trace, the
trace messages have to be stated using logic programming.
To solve this we deﬁne for the program the predicate
TraceMsg(index, msg) to state that the set of values in msg
is a trace message in the position index. With this deﬁnition,
a real trace consists of the set of statements
T raceMsg(1, msg1)
...
T raceMsg(n, msgn)
where msg1, . . . , msgn are real message values. This way, on
giving the program the goal TraceMsg(1, x), it will respond
97
AICT 2011 : The Seventh Advanced International Conference on Telecommunications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6

x = msg1. The predicate Next, for instance, can be deﬁned
with the use of TraceMsg as
Next(x, y)
←
T raceMsg(i1, x) ∧ T raceMsg(i2, y)
∧
i1 = i2 + 1
These deﬁnitions give to the program the same informa-
tion as the model for the trace deﬁned in Section IV-B, then,
a trace is correct with respect to an invariant, if such invariant
holds in the corresponding program.
Finally, in order to test the invariants, it is necessary
to remove the quantiﬁers, since most logic programming
languages do not support them. As in testing it is more
interesting to check the traces that fail the invariant, the
quantiﬁers can be easily removed. Let I be an invariant
I = ∀x1, . . . , xpφ ⇒ ∃y1, . . . , yqψ
by the deﬁnition of logical implication this is equivalent to
I = ∃x1, . . . , xp¬φ ∨ ∃y1, . . . , yqψ
Since we want to know whether a trace fails an invariant, we
need to test the negation of the invariant Ineg = ¬I which
leaves the formula in
Ineg ← φ ∧ ¬ψ
easily tested using logic programming.
VI. INVARIANT DEFINITION FOR THE SIP PROTOCOL
The Session Initiation Protocol (SIP) [7] is an application-
layer (control) signaling protocol for creating, modifying,
and terminating sessions with one or more participants.
These sessions include Internet telephone calls, multimedia
distribution, and multimedia conferences.
The SIP protocol is a fundamental part in the IMS frame-
work, where the main elements in the core IMS network
behave as different SIP entities (user agent server, user agent
client, proxy) and communicate between them using this
protocol.
In this section we apply the concepts previously explained
to the SIP protocol. First, we deﬁne the message structure,
then we deﬁne some predicates and their meaning in terms of
variables and ﬁnally, we use them to specify some invariants.
A. SIP Messages
A SIP Message is either a request from a client to a server,
or a response from a server to a client. The basic message
format is the one established by RFC 3621, as follows
generic-message = start-line
*message-header
CRLF
[ message-body ]
start-line
= Request-Line | Status-Line
When the message is a request, it contains a Request-Line
providing the Method Request-URI and SIP-Version. SIP
requests contain a Status-Line as a start-line, containing the
information SIP-Version, Status-Code and Reason-Phrase.
With the available information, for our approach we deﬁne
the following message variables.
• method ∈ RequestMethod, where RequestMethod =
{‘REGISTER’, ‘INVITE’, ‘ACK’, ‘CANCEL’, ‘BYE’,
‘OPTIONS’}. For this document we only consider the
Method ﬁeld, although a message variable could be
easily deﬁned to contain information for the request
URI.
• statusCode ∈ Code, where Code ⊂ N is the set of
possible status codes for the protocol.
We deﬁne a message m in SIP as at least the sequence
m = (method, statusCode). As it can be noticed, we are
not including the control part in the message deﬁnition.
Although it depends on the speciﬁcation, the control part
here would be a combination of the method and status code,
since they deﬁne the function of the message, here we will
just specify them as data variables. Along with the message
deﬁnition, the following predicates will also be useful to
identify a message as request or response
Request(m) ← m.method ̸= ϵ ∧ m.statusCode = ϵ
Response(m) ← m.method = ϵ ∧ m.statusCode ̸= ϵ
1) SIP Requests: According to the standard “A valid
SIP request formulated by a UAC MUST, at a min-
imum, contain the following header ﬁelds: To, From,
CSeq, Call-ID, Max-Forwards, and Via; all of these
header ﬁelds are mandatory in all SIP requests”. In
addition to the request line, these header ﬁelds allow
the main functionality for the main SIP routing ser-
vices. Adding them to the message deﬁnition,
m
=
(method, statusCode, to, from, cSeqNum, cSeqMethod,
callId, maxForwards, via).
We do not detail on the on the function of this headers,
but the reader is invited to refer to section 8.1.1 of [7] for
further information.
2) SIP Responses:
The basic procedures on how to
construct a response to a request are speciﬁed in section
8.2.6.2 of the RFC. They can be translated into the following
predicate
RespondsT o(x, y)
←
Response(x) ∧ Request(y)
∧
x.from = y.from
∧
x.callId = y.callId
∧
x.cSeq.seq = y.cSeq.seq
∧
x.cSeq.method = y.cSeq.method
∧
x.via = y.via
∧
x.to = y.to
Meaning that if the message x is a response to the mes-
sage y, then the indicated variable values must be the
same in both. Using this property and, given a trace
T for an implementation, we can deﬁne the invariant
I1 ← ∀x ∈ T, Request(x) ∧ x.method ̸= ‘ACK’ ⇒ ∃y ∈
T, RespondsTo(y, x) ∧ After(y, x), meaning that if there is
a request message in the trace, there must exist a response
message to it. In the same way, the invariant I2 ← ∀x ∈
T, Response(x) ⇒ ∃y ∈ T, RespondsTo(x, y) ∧ Before(y, x),
indicates that if there exists a response message in the trace,
98
AICT 2011 : The Seventh Advanced International Conference on Telecommunications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6

then there must be a request for it at some point before it in
the trace. This invariant is a more general version of the one
presented in the introduction, stating the relation between
INVITE and OK. This one states a relation between every
request and response, allowing to test more cases than the
original one.
B. SIP Registration
In SIP, registration allows a user to be located by other
peers. By sending a message to a server called the registrar,
the user agent client (UAC) informs the server of the location
(IP address, network) where a SIP user (speciﬁed by an URI)
can be located.
In terms of the protocol, in order to authenticate, the
user agent client sends a REGISTER request to the server
and the server responds with a 200 OK response when the
registration is accepted. A series of messages are sent in
between, in order to perform authentication (if required by
the server), determine capabilities of the server, and others.
However for the purpose of this document we only consider
whether a registration was successful. To achieve this, we
deﬁne the following predicate
Registration(x, y)
←
ResponseT o(y, x)
∧
x.method = ‘REGISTER’
∧
y.statusCode = 200
C. SIP Session Establishment
In order to establish a session between two users, one of
the UACs sends an INVITE request to the server which
contacts the second UAC. An exchange of messages takes
place in order to setup a session (using session description
protocol), different provisional responses are sent to the ﬁrst
UAC to indicate the status of the process (100 Trying,
180 Ringing, etc). The session is established after the
negotiation where a 200 OK message is sent to the origi-
nating UAC, and an ACK request is sent back to the server
to acknowledge the reception.
The ACK message, in accordance to section 17.1.1.3 in
the RFC, is constructed with the Call-ID, From and Request-
URI values from the original request, and the To header from
the response being acknowledged. The CSeq header in the
ACK must contain the same sequence number as the original
request, but the method parameter must be equal to “ACK”.
Then in order to determine that the session establishment
was successful we need to consider three messages as
described by the following predicate.
SessionEstabl(x, y, z)
←
RespondsT o(y, x)
∧
Request(z)
∧
x.method = ‘INVITE’
∧
y.statusCode = 200
∧
z.method = ‘ACK’
∧
z.to = y.to
∧
z.callId = x.callId
∧
z.from = x.from
∧
z.cSeq.seq = x.cSeq.seq
∧
z.cSeq.method = ‘ACK’
Again we have done some simpliﬁcations according to the
previous deﬁnitions with respect to the RFC. This predicate
speciﬁes when three messages conform to a session estab-
lishment.
D. Invariant examples for the PoC service
The SIP protocol is designed for extensibility and usability
in different contexts, because of that, there are not many
restrictions on when a session should be established, only
on the message exchange in order to establish it. However, a
service using SIP can deﬁne requirements for its infrastruc-
ture. For instance, the PoC service requires that a session
can be established only by registered clients. Then invariant
I3 can verify that requirement on the trace
I3 ← ∀x, y, z ∈ T, SessionEstabl(x, y, z) ⇒
∃u, v ∈ T, Registration(u, v)
∧ x.from = u.from ∧ Before(v, x)
indicating that whenever a session establishment is found
on the trace, then a registration must previously appear on
the trace from the same user. This invariant in particular is
interesting for its complexity, given that it requires testing
several messages in order to be checked. Such kind of
property is not easy to deﬁne using similar invariant testing
methodologies.
VII. EXPERIMENTS AND RESULTS
In this section we brieﬂy describe the methodology used
to test the invariants deﬁned in Section VI on real protocol
traces.
We deﬁned the predicates and invariants using the Prolog
programming language. We chose this language due to its
deﬁnition as an ISO standard (ISO/IEC 13211-1), portability
and maturity of its implementations. In particular we used
the ISO compliant SWI-Prolog implementation, because of
its large library of functions. A SIP message was deﬁned as
a structure msg(Request, StatusCode, ...) and
predicates were deﬁned in terms of variables as described
in Section VI. Invariants were speciﬁed in the negative form
φ∧¬ψ, for instance, for invariant I1 the following predicate
was deﬁned
negInv1(X) :-
trace_msg(_, X), request(X),
not(msg_method(’ACK’,X)), trace_msg(_, Y),
not((
after(Y,X), responds(Y,X)
)).
where msg_method(Method, Msg) is true if the
value of the variable Method equals the method of the
message in Msg. In the program, the execution of the goal
negInv1(X) will return all request messages for which a
response message is not available in the trace.
Trace ﬁles were provided by Alcatel-Lucent for a PoC
service implementation, a single trace was chosen for testing,
containing the establishment of an Ad-Hoc group session by
2 clients. In order to test the traces using logical program-
ming, we implemented a prototype tool in C to convert from
the XML (PDML) format exported with the tool Wireshark
99
AICT 2011 : The Seventh Advanced International Conference on Telecommunications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6

into a set of statements of the form trace_msg(index,
msg) as described in Section V.
In our tool, a conﬁguration ﬁle deﬁnes how to relate
a message variable in Prolog with a ﬁeld of a respective
packet, as follows
message: {
Method = "sip.Method";
StatusCode = "sip.Status-Code";
To = "sip.to.addr";
From = "sip.from.addr";
...
}
Using this conﬁguration, along with the trace, the tool
outputs a Prolog ﬁle containing the list of trace_msg
statements, where each message is assigned an index ac-
cording to its order in the trace, as follows
trace_msg(1, msg(‘INVITE’, nil,
‘sip:user1@b.c’, ‘sip:user2@b.c’, ... )).
trace_msg(2, msg(nil, 180,
‘sip:user1@b.c’, ‘sip:user2@b.c’, ... )).
trace_msg(3, msg(nil, 200,
‘sip:user1@b.c’, ‘sip:user2@b.c’, ... )).
If a particular ﬁeld is not found in a trace message, it is
replaced by the empty value nil (as the Method ﬁeld in SIP
response messages). However, if none of the deﬁned ﬁelds
are found, the message is ignored. This allows the tool to
also act as a ﬁlter for messages of the studied protocol.
We performed experiments by manually introducing some
errors on the implementation traces to evaluate the detection
capabilities of our approach. The results were successful,
the errors introduced were correctly detected by execution
of the program, and no false positive results were produced,
given that the deﬁnitions were speciﬁcally targeted to the
PoC service, the process allowed to correctly ﬁlter out the
Presence service messages. Even for a complex invariant
such as invariant 3 the approach did not present any issues.
In addition to the detection of the introduced errors, the
program also found some legitimate errors in the trace,
that were not found by previous testing. These occurred for
invariant 2, where some responses to an INVITE were found
in the trace where the request could not be found. Upon
further examination of the trace, we found that the error
was due to a problem in the collection of the trace, since
there were several responses from the server, indicating that
the request must have been correctly received. This raises
an issue about the reliability of trace collection tools and
techniques, however this was an isolated case and since we
only have access to the trace it is not possible to make a
full assessment without further experimentation.
One issue that should be addressed is the performance of
the approach. Since Prolog is a general purpose program-
ming language and not a dedicated program, the number of
evaluations performed in order to evaluate an invariant on
the trace is large. For invariant 1, in a trace with only 407
messages, the program performed 5559 inferences (proce-
dure calls) to arrive to a conclusion, however, the problem
is better illustrated for invariant 3, the most complex one,
where the number of inferences performed was of 583440
(although in only 0.09 seconds) to obtain a verdict. A dedi-
cated algorithm could perform less inferences by limiting the
range of comparison in the trace, instead of testing for every
possible combination as Prolog does. This issue is even more
critical as the number of messages involved in the property
increases. Although some optimizations are possible, the
creation of a dedicated program is indispensable.
VIII. RELATED WORK
A short overview of works related to ours are given in
this section, to complement the references cited throughout
the paper.
Formal testing methods have been used for years to prove
correctness of implementations by combining test cases
evaluation with proofs of critical properties. In [16], [1]
the authors present a description of the state of the art and
theory behind these techniques. Within this domain, and in
particular for network protocols, passive testing techniques
have to be used to test already deployed platforms or
when direct access to the interfaces is not available. Some
examples of these techniques using FSM derivations are
described in [2], [17]. Most of these techniques consider
only control portions, in [11], [13], [3], data portion testing
is approached by evaluation of traces in EEFSM and SEFSM
(Simpliﬁed Extended Finite State Machine) models, testing
correctness in the speciﬁcation states and internal variable
values. Our approach, although inspired by it, is different in
the sense that we test critical properties directly on the trace,
and using a model only for their veriﬁcation. A different
methodology can be found in [18], where I/O Automata
and ﬁrst-order logic are used to prove the correctness of
the implementation w.r.t. the speciﬁcation for distributed
algorithms. Data relations are also taken into account. Again,
this work relies on a speciﬁcation to perform testing, which
is not always available. There exists a considerable number
of works with similar approach in literature. In [19], [4]
the invariant approach was presented, and studied also in
[5], [12]. A study of the application of invariants to an IMS
service was also presented by us in [20], [8]. Although these
invariant approaches consider in some level the data part, it
is not their main objective. Some improvements have been
made to invariant techniques by the authors of [6] to include
temporal restrictions. Although their approach is very useful
with temporal speciﬁcations, it is not extensible for testing of
data. Our method improves on invariant testing by allowing
to deﬁne properties with complex data relations by using a
restriction on ﬁrst-order logic formulas.
IX. CONCLUSION AND FUTURE WORK
In this article we describe a new approach to invariant-
based passive testing. We improve the expressiveness of in-
variant properties by using ﬁrst-order logic, thus allowing to
100
AICT 2011 : The Seventh Advanced International Conference on Telecommunications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6

test data constraints between messages directly into protocol
traces. We also demonstrate the soundness of our approach,
showing that if a trace from an implementation is not correct
with respect to an invariant veriﬁed in a speciﬁcation, then
the implementation does not conform to such speciﬁcation.
We detail on how invariants deﬁned using our deﬁnition can
be tested using logic programming. We provide an example
of deﬁnition of invariants for the SIP protocol directly from
the protocol standard and detail on the results obtained
by testing using a Prolog implementation on a real trace
obtained from a PoC service implementation.
Our experiments showed that our approach makes it
possible to test complex properties directly into the trace.
The expressive power of invariants deﬁned in the way
described is very large, given the few limitations imposed
to the deﬁnition of formulas.
However our testing approach still requires improvement.
In particular, testing using logic programming showed to be
very expensive in terms of the number of procedure calls
required to arrive to a conclusion. One of the reasons for
this is that the evaluation of the formulas does not take
into account the linearity of the trace, and always tests
every message in the trace, even though it is only necessary
to evaluate in a single direction in the trace, forward or
backward, depending on the property.
As future work, we plan to develop an algorithm to
allow more efﬁcient testing of properties by taking into
account the linearity of the trace and also by optimizing
the invariant formulas. This could also allow for real time
passive monitoring and testing of invariants in protocol
implementations.
REFERENCES
[1] R. M. Hierons, P. Krause, G. L¨uttgen, A. J. H. Simons,
S. Vilkomir, M. R. Woodward, H. Zedan, K. Bogdanov, J. P.
Bowen, R. Cleaveland, J. Derrick, J. Dick, M. Gheorghe,
M. Harman, and K. Kapoor, “Using formal speciﬁcations to
support testing,” ACM Computing Surveys, vol. 41, no. 2, pp.
1–76, 2009.
[2] D. Lee, A. Netravali, K. Sabnani, B. Sugla, and A. John,
“Passive testing and applications to network management,”
in Proceedings 1997 International Conference on Network
Protocols.
IEEE Comput. Soc, 1997, pp. 113–122.
[3] H. Ural and Z. Xu, “An EFSM-Based Passive Fault Detection
Approach,” Lecture Notes in Computer Science, pp. 335–350,
2007.
[4] A. Cavalli, S. Prokopenko, and C. Gervy, “New approaches
for passive testing using an Extended Finite State Machine
speciﬁcation,” Information and Software Technology, vol. 45,
no. 12, pp. 837–852, September 2003.
[5] E. Bayse, A. Cavalli, M. N´u˜nez, and F. Za¨ıdi, “A passive
testing approach based on invariants: application to the wap,”
Computer Networks, vol. 48, no. 2, pp. 247–266, 2005.
[6] C. Andr´es, M. G. Merayo, and M. N´u˜nez, “Formal Correct-
ness of a Passive Testing Approach for Timed Systems,” 2009
International Conference on Software Testing, Veriﬁcation,
and Validation Workshops, pp. 67–76, 2009.
[7] J. Rosenberg, H. Schulzrinne, G. Camarillo, A. Johnston,
J. Peterson, R. Sparks, M. Handley, and E. Schooler, “SIP:
Session Initiation Protocol. RFC 3261,” 2002.
[8] F. Lalanne, S. Maag, E. M. D. Oca, A. Cavalli, W. Mallouli,
and A. Gonguet, “An Automated Passive Testing Approach
for the IMS PoC Service,” in 2009 IEEE/ACM International
Conference on Automated Software Engineering, 2009.
[9] Open Mobile Alliance, “Push to Talk over Cellular Require-
ments. Approved Version 1.0,” Jun. 2006.
[10] Open Mobile Alliance, “Internet Messaging and Presence
Service Features and Functions. Approved Version 1.2,” Jan.
2005.
[11] D. Lee and R. E. Miller, “A formal approach for passive
testing of protocol data portions,” in 10th IEEE International
Conference on Network Protocols, 2002. Proceedings. IEEE
Comput. Soc, 2002, pp. 122–131.
[12] B. Ladani, B. Alcalde, and A. Cavalli, “Passive testing: a
constrained invariant checking approach,” in Proc. 17th IFIP
Int. Conf. on Testing of Communicating Systems.
Springer,
2005, pp. 9–22.
[13] D. Lee, D. Chen, R. Hao, R. E. Miller, J. Wu, and X. Yin,
“Network protocol system monitoring-a formal approach with
passive testing,” IEEE/ACM Transactions on Networking,
vol. 14, no. 2, pp. 424–437, April 2006.
[14] M. Huth and M. Ryan, Logic in Computer Science: Modelling
and reasoning about systems.
Cambridge Univ Pr, 2004.
[15] U.
Nilsson
and
J.
Maluszynski,
Logic,
programming
and Prolog, 2nd ed.
Wiley, 1990. [Online]. Available:
http://www.ida.liu.se/˜ulfni/lpp
[16] D. Lee and M. Yannakakis, “Principles and methods of testing
ﬁnite state machines: A survey,” Proceedings of the IEEE,
vol. 84, pp. 1090–1123, 1996.
[17] M. Tabourier and A. Cavalli, “Passive testing and application
to the GSM-MAP protocol,” Information and Software Tech-
nology, vol. 41, no. 11-12, pp. 813–821, September 1999.
[18] J. Sogaard-Andersen, S. Garland, J. Guttag, N. Lynch, and
A. Pogosyants, “Computer-assisted simulation proofs,” in
Computer Aided Veriﬁcation, vol. 124, no. 1-3.
Springer,
March 1984, pp. 305–319.
[19] J. Arnedo, A. Cavalli, and M. Nunez, “Fast testing of critical
properties through passive testing,” Testing of Communicating
Systems, pp. 608–608, 2003.
[20] F. Lalanne and S. Maag, “From the IMS PoC service mon-
itoring to its formal conformance testing,” in Proceedings
of the 6th International Conference on Mobile Technology,
Application & Systems - Mobility ’09.
Nice, France: ACM
Press, 2009, pp. 1–8.
101
AICT 2011 : The Seventh Advanced International Conference on Telecommunications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6

