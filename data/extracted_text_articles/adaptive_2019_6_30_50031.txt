Consistent Persistence of Context-Dependent Runtime Models
Thomas K¨uhn and Christopher Werner
Software Technology Group
Technische Universit¨at Dresden
Dresden, Germany
Email: {thomas.kuehn3, christopher.werner}@tu-dresden.de
Tobias J¨akel
Database Systems Group
Technische Universit¨at Dresden
Dresden, Germany
Email: tobias.jaekel@tu-dresden.de
Abstract—Today’s complex software systems act in various situa-
tions and contexts and thus, have to adapt themselves correspond-
ingly during runtime. To model and represent the underlying
context-dependent domain knowledge, contextual modeling lan-
guages, such as the Compartment Role Object Model (CROM),
can be employed. However, these models and their instances
become unwieldy rather quickly and are subject to many adap-
tations. Especially, when persisting a runtime model of a self-
adaptive system this becomes a huge performance bottleneck.
Notably, though not all elements of a context-dependent domain
model have to be persisted to save the overall state of the
application. Yet, simply removing information can easily lead to
inconsistent models and instances in the database. To remedy too
much or too less data saving and maintain adaptation processes,
the persistent elements of a context-dependent domain model
have to be annotated, such that the persisted domain model
and instance is consistent with the runtime domain model and
instance. For our solution, we introduce a formal approach to
derive a persistent CROM from an arbitrary CROM model
with persistence annotations, such that the persistent CROM is
well-formed and consistent to the domain model and instance
at runtime. In conclusion, this will allow context-aware systems
to persist partial runtime model instances of context-dependent
domain models while guaranteeing their consistency and the
automatic adaptation of the persistent model after adapting the
domain model.
Keywords–CROM; RSQL; context-dependent domain model;
persistency; transformation function.
I.
INTRODUCTION
Self-adaptive Systems (SaS) have been conquering a lot
of areas in automation, like robotics, control systems, or even
home automation [1]. In recent years, several deﬁnitions of
SaS arose, as shown in [1][2]. Notably, all deﬁnitions share the
characteristic that SaS monitor themselves, their environment,
and/or related components to adjust their behavior accordingly,
e.g., dynamic production systems, autonomous mobile robots,
and smart home solutions. To represent SaS’ knowledge bases,
current SaS employ context-dependent domain models [3][4],
like CROM [5]. These domain models capture the system’s
situational state by means of contexts [2], as well as its
context-dependent relations and constraints. Moreover, they are
adapted and extended over time. For instance, a self-adaptive
smart home, which monitors itself and features two basic
contexts: a regular context and an emergency context. In the
emergency context, for example, the front door is unlocked,
such that the rescue team may enter faster, or the connected
smart devices emit alarm sounds to alert the residents. How-
ever, such context-dependent domain models become unwieldy
rather quickly, because all environmental information, as well
as the system’s context-dependent structure is modeled.
This, especially, holds true for the resulting instances of
such models at runtime. Considering persistence, this will
result in a huge database containing potentially unnecessarily
stored information, such as auxiliary sensor data. Yet, simply
removing this unnecessary information can easily lead to
inconsistent, invalid models and instances in the database [5].
Moreover, in case of system failure and recovery, this leads
to invalid model instances at runtime. Especially, in case
of context-dependent domain models, such as CROM [6],
invalid instances can ultimately lead to unanticipated system
behavior [7, p. 58]. For instance, persisting empty contexts
or contextually unassigned behavior violates CROM’s validity,
as shown in [8]. To remedy this, the persistent elements of
a context-dependent domain model must be annotated, such
that the persisted domain model and instance is consistent
with the runtime domain model and instance. The adaptation,
like modiﬁcation of running contexts and integration of new
contexts, of the context-dependent domain models leads to an
adaptation of the underlying database schema and the created
persistency annotations. To manage this adaptation scenario,
like adding a new context-aware application to a smart home,
an automated transformation algorithm is needed that maps the
update of the domain model to the evolution of the persisted
domain model and underlying database schema. We employ
CROM [5] as modeling language for context-dependent do-
main models and provide a formal approach for deriving both
a well-formed persistence model, as well as a valid, reduced
instance from an arbitrarily annotated CROM model and
corresponding instances. Moreover, we utilize the role-based
contextual database system (RSQL) [9] as the corresponding
target database system for the resulting persistent models and
instances. Finally, we demonstrate our algorithm utilizing a
small example scenario within a smart home setting, and prove
that our method guarantees the consistency of the resulting
persistence models and reduced instances [10]. In sum, this
will allow SaS to persist partial runtime model instances of
context-dependent domains models before and after adaptation
steps while guaranteeing their consistency.
The paper is organized as follows: Before delving into
the formal deﬁnitions, Section II introduces a simple smart
home scenario as our running example. Afterwards, Section III
presents a brief introduction to both CROM and RSQL. In
Section IV, our formal transformation algorithm is deﬁned.
Moreover, it is proven that this algorithm ensures well-
formedness and validity persisted context-dependent domain
models and instances. To illustrate the application of our
approach, Section V applies the transformation algorithm to
the running example. Related work is discussed in Section VI
and the paper is concluded in Section VII.
88
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

FireAlarm (FA)
-
Set of attributes
-
Set of methods
Natural Type
-
Set of attributes
-
Set of methods
Role Type
Compartment Type
- Set of attributes
Cardinality
Fills relation
Legend
- triggerAlarm(t:boolean) : void
AnnouncementProcess (AP)
- logs : string
- fireDetected() : void
FireDetector (FD)
- place : coord
- announceFire() : void
Announcer (A)
- volume : int
- turnOn() : void
- turnOff() : void
FeedBackSensor (FBS)
- state : boolean
detectors
1
1..*
1..*
1..*
1..*
0..*
announcers
1
1..*
1
0..*
feedback
- call(num:string):void
Phone (P)
Room (R)
Sensor
- type : int
0..*
Actuator
- state : string
0..*
- number : string
- activate() : void
Speaker (S)
- maxVolume : int
- detect() : void
SmokeDetector (SD)
- ID : int
- switchMode(m:Int) : void
Camera (C)
- mode : int
Relationship Type
OccurenceConstraint
P
- number : int
P
Persistence annotation
- Set of methods
Figure 1. Annotated CROM Model of a Fire Alarm Scenario.
II.
RUNNING EXAMPLE
Emergencies usually require SaS behavior and conse-
quently utilize context-dependent domain models, because
typical behavior is substituted with an adequate emergency
response. Henceforth, we focus on ﬁre as an emergency within
a smart home, illustrated in Figure 1. Like any regular house,
the smart home setting features Rooms (R). Additionally,
we assume that each R may contain several Sensors and
Actuators. A Sensor can be either a SmokeDetector (SD) or
a Camera (C). As player type for the Actuator role type, we
assume Phones (P), as well as Speakers (S). While speakers are
stationary, phones have the tendency to move around with their
owner. In each room, with at least one sensor and actuator, the
FireAlarm (FA) compartment is created. The available sensors
and actuators of the room will start playing the FireDetector
(FD) and Announcer (A) role type, respectively. In case a ﬁre
is detected by a ﬁre detector, the AnnouncementProcess (AP)
is triggered, which announces the ﬁre alarm via all actuators
playing the announcer role. For example, a smart speaker
could announce the ﬁre by activating noisy sounds or notifying
the ﬁre ﬁghter department via Internet. All the detection and
announcement procedures are coordinated by the AP role
type, which also holds the log information. Additionally, our
scenario requires the system to store the log information of
each ﬁre alarm persistently in a database system. Thus, the
most basic annotation is the AP role type, which is in fact an
invalid model with respect to the CROM metamodel. In case
of restoring the system after a breakdown, an AP role could
not be situated in any compartment, since this information will
not be persistently stored. However, applying the Persistency
Transformation algorithm ϕ will ensure a consistent database
model by adding additional types to the database schema.
III.
PRELIMINARIES
Before describing our method to restrict a context-
dependent domain model to a consistent partial persistence
model, we ﬁrst introduce CROM and RSQL to model respec-
tively persistent context-dependent domain models.
A. Compartment Role Object Model
CROM [5] permits modeling dynamic, context-dependent
domains by introducing compartment types to represent an
objectiﬁed context, i.e., containing role types and relationship
types. Natural types, in turn, fulﬁll role types in multiple
compartment types. The following deﬁnitions are retrieved
from [5], where a more detailed discussion can be found.
Deﬁnition 1 (Compartment Role Object Model). Let NT,
RT, CT, and RST be mutual disjoint sets of Natural Types,
Role Types, Compartment Types, and Relationship Types. Then,
M = (NT, RT, CT, RST, ﬁlls, rel) is a CROM, where ﬁlls ⊆
T ×CT ×RT is a relation and rel : RST ×CT → (RT ×RT)
is a partial function. Here, T := NT ∪ CT denotes the set of
all rigid types. A CROM is well-formed if it holds that:
∀rt ∈RT ∃ t∈T ∃!ct ∈CT : (t, ct, rt)∈ﬁlls
(1)
∀ct ∈CT : (t, ct, rt)∈ﬁlls
(2)
∀rst∈RST ∃ct ∈CT :
(rst, ct)∈domain(rel)
(3)
∀(rt1, rt1) ∈codomain(rel) : rt1 ̸=rt2
(4)
∀(rst, ct) ∈domain(rel) :
rel(rst, ct)=(rt1, rt2) ∧
( , rt1, ct), ( , rt2, ct)∈ﬁlls
(5)
In detail, ﬁlls denotes that rigid types can play roles of a certain
role type in which compartment type and rel capture the two
role types at the respective ends of each relationship type. The
well-formedness rules ensure that the ﬁlls relation is surjective
(1); each compartment type has a nonempty, disjoint set of role
types as its parts (2, 3); and rel maps each relationship type
to exactly two distinct role types of the same compartment
type (4, 5). For a given function f :A → B, domain(f)=A
returns the domain and codomain(f)=B the range of f. For
comprehensibility, we use subscripts to indicate the model a
set, relation or function belongs to, e.g., RTM denotes the set
of role types of the CROM M. Accordingly, a CROM can be
constructed for the ﬁre alarm scenario, depicted in Figure 1.
89
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

Example 1 (Fire Alarm Model). Let F = (NT, RT, CT, RST,
ﬁlls, parts, rel) be the model of the ﬁre alarm scenario, where
the components are deﬁned as:
NT :={SD, C, P, S}
CT := {FA, R}
RT :={FD, AP, A, FBS, Sensor, Aktuator}
RST :={detectors, announcers, feedback}
ﬁlls :={(SD, FA, FD), (C, FA, FD), (A, FA, AP),
(S, FA, A), . . . }
rel :={(detectors, FA) → (FD, AP),
(feedback, FA) → (AP, FBS),
(announcers, FA) → (AP, A), . . . }
Unsurprisingly, a well-formed CROM can directly encode
concepts of context-dependent domains. A CROM instance
features naturals, roles, compartments and relationships.
Deﬁnition 2 (Compartment Role Object Instance). Let M =
(NT, RT, CT, RST, ﬁlls, rel) be a well-formed CROM and N,
R, and C be mutual disjoint sets of Naturals, Roles and Com-
partments, respectively. Then, a Compartment Role Object In-
stance (CROI) of M is a tuple i = (N, R, C, type, plays, links),
where type : (N → NT) ∪ (R → RT) ∪ (C → CT) is a
labeling function, plays ⊆ (N ∪ C) × C × R a relation, and
links : RST × C → P(R × R) is a total function. Moreover,
O := N ∪C denotes the set of all objects in i. To be compliant
to the model M the instance i must satisfy the following
conditions:
∀(o, c, r) ∈plays : (type(o), type(c), type(r))∈ﬁlls
(6)
∀(o, c, r), (o, c, r′) ∈plays : r̸=r′ ⇒ type(r)̸=type(r′) (7)
∀r∈R ∃!o∈O ∃!c∈C : (o, c, r)∈plays
(8)
∀rst ∈RST∀c∈C ∀(r1, r2)∈links(rst, c) :
(rst, type(c))∈domain(rel) ∧
rel(rst, type(c))=(type(r1), type(r2)) ∧
( , c, r1), ( , c, r2)∈plays
(9)
The type function assigns a distinct type to each instance, plays
identiﬁes the objects (either natural or compartment) playing
a certain role in a speciﬁc compartment, and links captures
the roles currently linked by a relationship type in a certain
compartment. A compliant CROI guarantees the consistency of
both the plays relation and the links function with the model
M. Axioms (6), (7) and (8) restrict the plays relation, such that
it is consistent to the types deﬁned in the ﬁlls relation and the
parts function, an object is prohibited to play instances of the
same role type multiple times in the same compartment, and
each role has one distinct player in one distinct compartment,
respectively. In contrast, Axiom (9) ensures that the links
function only contains those roles, which participate in the
same compartment c as the relationship and whose types are
consistent to the relationship’s deﬁnition in the rel function.
Admittedly, neither Deﬁnition 1 nor 2 captures constraints
of context-dependent domains. Hence, two context-dependent
constraints, i.e., occurrence constraints and relationship cardi-
nalities are introduced. Henceforth, cardinalities are given as
Card ⊂ N × (N ∪ {∞}) with i ≤ j, whereas elements of Card
are written as i..j.
Next, the Constraint Model is deﬁned to collect all con-
straints imposed on a particular CROM M.
Deﬁnition 3 (Constraint Model). Let M = (NT, RT, CT,
RST, ﬁlls, rel) be a well-formed CROM. Then C = (occur,
card) is a Constraint Model over M, where occur : CT →
P(Card × RT) and card : RST × CT → (Card × Card) are
partial functions. A Constraint Model is compliant to M, iff:
∀ct ∈domain(occur) ∀( , rt)∈occur(ct) :
( , ct, rt)∈ﬁlls
(10)
domain(card) ⊆ domain(rel)
(11)
In detail, occur collects a cardinality limiting the occurrence
of the given role type in each compartment. Moreover, card
assigns a cardinality to each relationship type. Notably, all
these constraints are deﬁned context-dependent, i.e., no con-
straint crosses the boundary of a compartment type. In contrast
to [5], our deﬁnition excludes empty counter roles ε and Role
Groups. Similar to the CROM F, the corresponding compliant
constraint model is easily derived, from Figure 1:
Example 2 (Fire Alarm Constraints). Let F be the ﬁre alarm
from Example 1. Then CF = (occur, card) is the compliant
constraint model with the following components:
occur:= {FA→{(1..∞, FD), (1..∞, AP), (1..∞, A)}}
card:= {(detectors, FA)→(1..∞, 1..1),
(announcers, FA)→(1..1, 1..∞),
(feedback, FA)→(1..1, 0..∞)}
Finally, the validity of a given CROI is deﬁned with respect
to a CROM and corresponding constraint model.
Deﬁnition
4
(Validity). Let M
=
(NT, RT, CT, RST,
ﬁlls, rel) be a well-formed CROM, C = (occur, card) a con-
straint model on M, and i = (N, R, C, type, plays, links) a
CROI compliant to M. Then i is valid with respect to C iff the
following conditions hold:
∀c∈C ∀(i..j, rt)∈occur(type(c)) : i ≤
Rc
rt
 ≤ j
(12)
∀c∈C∀rst∈RST : rel(rst, type(c))=(rt1, rt2)∧
card(rst, type(c))=(i..j, k..l) ∧

B. Role-Based Contextual Database System (RSQL)
RSQL directly addresses the persistence of context-
dependent information in a database system [9]. In particular,
RSQL combines a metatype distinction in the database model,
an adapted query language on the database model’s basis,
and ﬁnally a proper result representation [11]. The database
model, including the metatype distinction, consists of two
levels, (i) the schema level and (ii) the instance level. On the
schema level, RSQL introduces Dynamic Data Types (DDT)
that combine the notion of an entity type with the notion of
roles while fully implementing the metatype distinction on
the basis of CROM [11, p. 72]. On the instance level, the
database model introduces Dynamic Tuples (DT) [11, p. 78],
that are deﬁned to allow for dynamic structure adaptations
during runtime without changing an entity’s overall type [9].
Hence, DDTs deﬁne the space in which DTs might expand or
shrink their structure, depending on the context they are acting
in. Also, RSQL features a set of formal operators to process
context-dependent information on the basis of DTs [11, p. 84].
The query language, as external database system interface,
features an individual data deﬁnition (DDL), data manipulation
(DML), and data query language (DQL) [9]. As the database
model, the query language implements a metatype distinction
on the basis of CROM as ﬁrst class citizen. The list of DDL
statements and grammar, DML statements, and DQL statement
grammar are shown in [11, p. 116, p. 122, p. 127].
Finally, to complete the database integration of context-
dependent information, RSQL returns RSQL Result Nets.
These represent a novel data structure for results, which feature
various functionalities to navigate through players, their roles,
compartments, and relationships [11, p. 147].
IV.
PERSISTENCE ALGORITHM
Henceforth, we present an algorithm that transforms an
annotated CROM model into a dedicated CROM model for
persistence. In detail, we ﬁrst introduce persistence annotations
to annotate CROM model elements. Afterwards, the transfor-
mation algorithm is presented. Finally, we prove that given a
well-formed CROM model with persistence annotations and a
valid CROM instance, the resulting limited CROM model is
well-formed and the restricted CROI is valid.
A. Persistence Annotation
Accordingly, the following deﬁnition extends CROM by
introducing annotations for modeling elements.
Deﬁnition 5 (Persistence Annotation). Let M = (NT, RT,
CT, RST, ﬁlls, rel)
be
an
arbitrary
CROM,
then
P
=
(NT, RT, CT, rel) denotes a persistence annotation of M,
whereas NTP ⊆ NTM, RTP ⊆ RTM, CTP ⊆ CTM, and
relP ⊆ domain(relM)
In general, this deﬁnition permits to select a subset of natural
types, role types, compartment types, and context-dependent
relationship types. For the sake of simplicity, we excluded
attributes, because persisting attributes does not add any com-
plexity to the proposed method. In case of the ﬁre alarm sce-
nario (Figure 1), the persistence annotation for the CROM F
could be deﬁned as P = (∅, {AP}, ∅, ∅). As the transformation
must be aware of compartment types, which are existentially
dependent on at least one of its containing role types, we deﬁne
the following auxiliary deﬁnitions.
Deﬁnition 6 (Existential Parts). Let M = (NT, RT, CT, RST,
ﬁlls, parts, rel) be an arbitrary CROM, C = (occur, card) a
constraint model on M, and ct ∈ CT an arbitrary com-
partment type in M. Then ext(ct) := {rt
| (t, ct, rt) ∈
ﬁlls ∧ (i..j, rt) ∈ occur(ct) ∧ i ≥ 1} collects the set of
existential parts of the compartment type ct.
In general, this deﬁnition introduces the ext function to de-
termine the existential parts of the given compartment type,
i.e., contain a role type with an occurrence constraint (i..j)
with i ≥ 1. For instance, while the room R has no existential
parts, the ﬁre alarm compartment type FA has three, i.e.,
ext(FA) = {FD, AP, A}.
B. Transformation Algorithm
After deﬁning persistence annotations over CROM models,
it is possible to deﬁne the Persistency Transformation for
arbitrary CROM models and corresponding constraint models,
as follows:
Deﬁnition 7 (Persistency Transformation). Let M be a well-
formed CROM, C a constraint model compliant to M, and
P = (NTP , RTP , CTP , relP ) a persistence annotation over
M. Then (N, D) = ϕ(M, C, P) constructs the persistence
model N = (NT, RT, CT, RST, ﬁlls, rel) and respective con-
straint model D = (occur, card) from the given CROM,
constraint model, and persistence annotation. ϕ ﬁrst computes
the ﬁllsN relation and relN function by applying the inference
rules depicted in Figure 2. From them, the sets NTN , RTN ,
CTN , RSTN can be determined as:
TN := {t | (t, ct, rt)∈ﬁllsN }
(14)
CTN := {ct | (t, ct, rt)∈ﬁllsN }
(15)
RTN := {rt | (t, ct, rt)∈ﬁllsN }
(16)
NTN := NTP ∪ (TN \ CTN )
(17)
RSTN := {rst | (rst, ct)∈domain(relN )}
(18)
Finally, the partial function occur and card can be restricted
to the model N, as showcased in Figure 2.
To put it succinctly, the Persistency Transformation ﬁrst con-
structs the CROM N for persistence by inductively creating the
ﬁllsN relation and the relN partial function before creating the
carrier sets NTN , RTN , CTN , RSTN . Lastly, the constraint
model D is constructed by restricting the occurD and cardD
functions accordingly. In case of ﬁlls, the axioms (19), (20),
(25), and (26) initialize ﬁllsN with respect to the annotated
compartment types, role types, and relationships types, re-
spectively. Afterwards, ﬁllsN is inductively extended in three
ways. First, (23) checks all compartment types that fulﬁll a
previously selected role type and adds all of its existential parts
(role types), if any exist. Likewise, (24) checks all previously
selected compartment types and includes all of its existential
parts (role types), if any exist. Third, (25) and (26) check if
a previously selected role type has a relationship to another
role type with a cardinality (i..j) with i ≥ 1. By contrast, rel
is initialized only with relationships either directly annotated
(27) or contained in an annotated compartment type (28).
Afterwards, this partial function is inductively expanded, if
a previously selected role type has a relationship to another
role type with a cardinality greater than zero. Consequently,
the components of N are derived from the contents of both
ﬁllsN and relN .
91
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

Inductive deﬁnition of ﬁllsN :
CTSel
ct ∈CTP
(t, ct, rt)∈ﬁllsM
(t, ct, rt)∈ﬁllsN
(19)
RTSel
rt ∈RTP
(t, ct, rt)∈ﬁllsM
(t, ct, rt)∈ﬁllsN
(20)
RelSelLeft
(rst, ct)∈relP
relM(rst, ct)=(rt1, rt2)
(t, ct, rt1)∈ﬁllsM
(t, ct, rt1)∈ﬁllsN
(21)
RelSelRight
(rst, ct)∈relP
relM(rst, ct)=(rt1, rt2)
(t, ct, rt2)∈ﬁllsM
(t, ct, rt2)∈ﬁllsN
(22)
Induction cases for ﬁllsN :
CTExt
(ct1, ct2, )∈ﬁllsN
(t, ct1, rt)∈ﬁllsM
ct1 ∈CTM
rt ∈extM(ct1)
(t, ct1, rt)∈ﬁllsN
(23)
OccurExt
(s, ct, rt′)∈ﬁllsN
rt ∈extM(ct)
(t, ct, rt)∈ﬁllsM
(t, ct, rt)∈ﬁllsN
(24)
RelExtRight
(s, ct, rt1)∈ﬁllsN
(t, ct, rt2)∈ﬁllsM
(rst, ct)∈domain(cardC)
relM(rst, ct)=(rt1, rt2)
cardC(rst, ct)=(i..j, k..l)
k ≥ 1
(t, ct, rt2)∈ﬁllsN
(25)
RelExtLeft
(t, ct, rt2)∈ﬁllsN
(s, ct, rt1)∈ﬁllsM
(rst, ct)∈domain(cardC)
relM(rst, ct)=(rt1, rt2)
cardC(rst, ct)=(i..j, k..l)
i ≥ 1
(s, ct, rt1)∈ﬁllsN
(26)
Inductive deﬁnition of relN :
RelSel
(rst, ct)∈relP
relN (rst, ct) := relM(rst, ct)
(27)
RelInCT
ct ∈CTP
(rst, ct)∈domain(relM)
relN (rst, ct) := relM(rst, ct)
(28)
Induction case for relN :
RelExt
(s, ct, rt1), (t, ct, rt2)∈ﬁllsN
(rst, ct)∈domain(cardC)
relM(rst, ct)=(rt1, rt2)
cardC(rst, ct)=(i..j, k..l)
(i ≥ 1 ∨ k ≥ 1)
relN (rst, ct) := relM(rst, ct)
(29)
Deﬁnition of occurD and cardD:
OccurIn
(t, ct, rt)∈ﬁllsN
(i..j, rt)∈occurC(ct)
(i..j, rt)∈occurD(ct)
(30)
CardIn
(rst, ct)∈domain(relN )
(rst, ct)∈domain(cardC)
cardD(rst, ct) := cardC(rst, ct)
(31)
Figure 2. Inductive deﬁnition of ﬁllsN , relN , occurD, and cardD.
Besides the CROM N, the components of the constraint
model D are deﬁned inductively, as well. In detail, (30) and
(31) restrict the occurrence respectively cardinality constraints
of C to those compliant to the target model N, i.e., include all
rules from occurC for all compartment types and role types in
N and the cardinality from cardC for all relationship types
deﬁned in relN . In conclusion, ϕ generates both a CROM
N and a corresponding D from the given CROM M, the
constraint model C, and persistence annotation P.
Up to this point, this deﬁnition is only applicable to the type
level, and has no direct effect on the instance level. However,
to store an instance of an annotated CROM model, it must be
reduced, as well.
Deﬁnition
8
(Instance
Restriction).
Let
M
=
(NT, RT, CT, RST, ﬁlls, rel) be a well-formed CROM and i
an arbitrary CROI. Then p := Ψ(M, i) is a restriction of i
with respect to M. In detail, p = (N, R, C, type, plays, links)
is determined by ﬁrst applying the induction rules, shown
in Figure 3, to determine playsp and linksp. Afterwards, the
other components are deﬁned as follows:
Np := {o | (o, c, r)∈playsp ∧ typei(o)∈NTM}
(32)
Rp := {r | (o, c, r)∈playsp}
(33)
Cp := {o | (o, c, r)∈playsp ∧ typei(o)∈CTM}
∪ {c | (o, c, r)∈playsp}
(34)
typep := typei
(35)
92
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

Inductive deﬁnition of playsp:
(o, c, r)∈playsi
(typei(o), typei(c), typei(r))∈ﬁllsM
(o, c, r)∈playsp
(36)
Inductive deﬁnition of linksp:
(rst, c)∈domain(linksi)
(r1, r2)∈linksi(rst, c)
(rst, typei(c))∈domain(relM)
relM(rst, typei(c))=(typei(r1), typei(r2))
(r1, r2)∈linksp(rst, c)
(37)
Figure 3. Deﬁnitions of the restriction of playsp and linksp.
In fact, the restriction of a CROI i with respect to a CROM M
is derived by only including elements from playsi whose types
correspond to ﬁllsM (36) and by only including relationships
from linksi that have been deﬁned in M including the correct
types of the left and right side (37). Afterwards, the carrier
sets N, R, C are computed simply based on playsp. Notably,
typei is passed as is, because the typing of entities must be
retained after restricting the CROI. In conclusion, both the
Persistency Transformation ϕ and the instance restriction ψ
work in concert. While ϕ generates the persistence CROM
model N and constraints D from a given CROM model M
with constraints C, ψ can be employed to restrict a CROI
instance i of M to the persistence CROM model N, ultimately,
constructing the persistence CROI instance.
C. Well-formedness, Compliance, and Validity
Although, both transformations were designed thoroughly,
their suitability for persisting context-dependent domain mod-
els is determined by their ability to retain the well-formedness,
compliance, and validity of the created models and instances.
In detail, this entails that given a well-formed CROM M
and compliant constraint model C, ϕ will always generate a
well-formed CROM N and compliant constraint model D for
persistence. Moreover, given an arbitrary CROI i compliant to
M and valid with respect to C, then ψ will always create a
restricted CROI p that is compliant to N and valid with respect
to D. Thus, the resulting partial domain model can be safely
stored in and loaded from a database system.
Conversely, we henceforth discuss three main theorems. First,
we show that the Persistency Transformation ensures well-
formedness of the model and compliance of the constraints.
Second, we extend this result to the compliance and validity
of instances of such CROM models. Finally, we show that each
restricted instance is also a compliant and valid instance of the
original model. Consequently, this guarantees the consistency
of stored partial runtime model instances of context-dependent
domains models. For brevity, the full proofs are omitted, but
will be presented in a separate technical report.
Theorem 1 (Well-formedness and Compliance). Let M be
a well-formed CROM, C a constraint model compliant to
M, and P a persistence annotation of M. Then (N, D) :=
ϕ(M, C, P) constructs a well-formed persistence model N
and corresponding constraint model D compliant to N.
⊤
M
N
C
D
ϕ(P )
wf
wf
ϕ(P )
comp.
comp.
Figure 4. Commutative diagram for well-formedness and compliance.
Proof: Before proving this theorem, we can make the
following observations when investigating the inference rules
(cf. Figure 2). Speciﬁcally, from the structure of (19–29) we
can deduce the following relations between a given CROM M
and the resulting N:
ﬁllsN ⊆ﬁllsM
domain(relN )⊆domain(relM)
∀(rst, ct)∈domain(relN ): relN (rst, ct)=relM(rst, ct)
Similarly, the structure of (30–31) entails the following rela-
tions between the constraint model C and D:
domain(occurD)⊆domain(occurC)
∀ct ∈ domain(occurC): occurD(ct)⊆occurC(ct)
domain(cardD)⊆domain(cardC)
∀(rst, ct)∈ domain(cardD): cardD(rst, ct)=cardC(rst, ct)
Finally, Theorem 1 can be shown to hold for well-formed
CROMs M and corresponding compliant constraint models C
following the commutative diagram in Figure 4. To show that
the well-formedness of N is implied by M, we successively
apply the relations between N and M to the axioms (1–5).
Likewise, the compliance of D to N can be entailed from the
compliance of C to M by applying the relations between D
and C to axioms (10) and (11).
After proving that ϕ preserves the well-formedness and com-
pliance of the generated persistence CROM and constraint
model, the ﬁnal step is to prove that ψ restricts a CROI i
compliant to M and valid with respect to C to a persistence
CROI p, which is itself compliant and valid to the persistence
CROM of M and C, respectively.
Theorem 2 (Validity). Let M be a well-formed CROM, C a
constraint model compliant to M, P a persistence annotation
of M, as well as i a CROI compliant to M and valid with
respect to C. Then the construction (N, D) := ϕ(M, C, P)
and the restriction p := ψ(N, i) entails that p is compliant to
N and valid with respect to D.
Proof: Again, to prove Theorem 2 major conclusions can
already be drawn from Deﬁnition 8 (cf. Figure 3) and the fact
that i is compliant to the well-formed CROM M. Thus, the
following relations between p and i can be deduced:
playsp ⊆playsi
domain(linksp)⊆domain(linksi)
∀(rst, c)∈domain(linksi) : linksp(rst, c)=linksi(rst, c)
To show that Theorem 2 holds for all i compliant to M and
valid wrt. C, we need to show the compliance of p to N and
the validity to D (cf. Figure 5).
93
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

(M, C)
(N, D)
(M, C)
i
p
q
ϕ(P )
ϕ(P )
ψ(N )
valid
valid
ψ(M)
valid
Figure 5. Commutative diagram for validity and lifted validity.
The compliance of p to N can be shown by applying the
relations between p and i to the axioms (6–9) assuming that i
is compliant to M. Conversely, the validity of p with respect
to D is entailed from the validity of i with respect to C, as well
as from Deﬁnition 8. Especially, it holds that if a role type is
persisted rt∈RTN then all corresponding role (instances) are
retained from i in p, such that Rc
rt,p =Rc
rt,i holds for all c∈Ci.
Applying these entailments to (12) and (13), we can show that
p is valid with respect to D.
While this proves the consistency of stored partial context-
dependent domain models and instances, the question arises
whether the persistent partial runtime model can be safely used
as starting point after a system breakdown. To show this, we
extend the notion of compliance and validity of a persisted
CROI p to the original CROM M and corresponding C. Yet,
the persisted CROI p must ﬁrst be lifted to the original CROM
M, i.e., ψ(M, p). This leads to the following theorem:
Theorem 3 (Lifted Validity). Let M be a well-formed CROM,
C a constraint model compliant to M, P a persistence annota-
tion of M, as well as i a CROI compliant to M and valid with
respect to C. Then the construction (N, D) := ϕ(M, C, P) and
the restriction q := ψ(M, ψ(N, i)) entails that q is compliant
to M and valid with respect to C.
Proof: As a consequence of Theorem 2, it also holds
that p := ψ(N, i) is compliant to N and valid with respect
to D. Thus, to prove Theorem 3, we need to show that
q := ψ(M, p) is compliant to M and valid with respect to
C, as the right side of Figure 5 indicates. Moreover, though
from Deﬁnition 7 it follows, that N might contain natural
types, which where deﬁned as compartment types in M.
Accordingly, q := ψ(M, p) leaves the CROI as is and only
moves affected instances form Np to Cq, in short, transforming
natural instances back to compartment instances. However, as
both rules (23) and (24) ensure that only compartment types
without existential parts (cf. Deﬁnition 6) will be persisted
as natural type, consequently, for each compartment instance
c∈Cq with typeq(c)∈(CTM∩NTN ), its type has no existential
parts ext(typeq(c)) = ∅ and Rc
rt,q = ∅ for all rt ∈ RTM. As
a result, the compliance of q to M immediately follows from
the compliance of p to N. In contrast, the validity of q with
respect to C can be easily entailed from the emptiness of Rc
rt,q
(see above) applied to axioms (12) and (13).
In conclusion, these theorems prove that the transformation al-
gorithm guarantees well-formedness, compliance and validity
of the generated persistent context-dependent domain model
and their instance. This does not only entail correct storage,
but also retrieval after a system breakdown. Simply put, the
transformation ensures that the persisted instance model p can
also be loaded back as a valid instance model q of the runtime
domain model (M, C). To put it succinctly, the transformation
guarantees that any persisted instance model is also valid
wrt. the complete domain model and constraints.
V.
ILLUSTRATIVE CASE STUDY
A. Model Transformation
The Persistency Transformation will produce the persis-
tence model depicted in Figure 6. As it can be seen, the FBS
role type is gone, as well as R has been transformed into a
natural type, because it has no existential parts that will not
be persisted in the database schema. All other role types and
natural types are necessary for compliance and consistency
to the domain model. However, in the following we will
demonstrate the algorithm step by step and explain how the
algorithm extends the model and why.
We start with the source model F and the constraint model
CF as deﬁned in Example 1 and 2, respectively. Additionally,
we assume the persistence annotation P = (∅, {AP}, ∅, ∅).
Henceforth, we deﬁne the persisted CROM model P
=
(NTP, RTP, CTP, RSTP, ﬁllsP, relP). At ﬁrst, the ﬁllsP and
relP relations are constructed by the rules given in Figure 2. By
applying Rule (20), ﬁllsP is extended by (R, FA, AP) with all
their respective player types. Next, Rule (24) must be applied,
resulting in four new entries in ﬁllsP. Speciﬁcally, all role
types with an occurrence constraint greater than 0 are added,
which applies to FD and A. Consequently, the resulting ﬁllsP
is populated with the following triples:
ﬁllsP = {(R, FA, AP), (SD, FA, FD), (C, FA, FD),
(P, FA, A), (S, FA, A)}
Additionally, the relP is populated by the rules (27–29),
whereas rules (27) and (28) do not apply here, since neither a
relationship type is annotated nor a compartment type. Hence,
the relationship types detectors and announcers are collected
by Rule (29), because they link role types that are already in
ﬁllsP and have a cardinality constraint of at least 1. As a result,
the relP is populated as following:
relP(detectors, FA) = (FD, AP)
relP(announcer, FA) = (AP, A)
Out of these two relations, the corresponding type sets are
created by employing rules (15–18) and are the following:
CTP ={FA}
RSTP ={detectors, announcers}
RTP ={AP, FD, A}
NTP ={SD, C, P, S, R}
detectors
1
1..*
announcers
1
1..*
FireAlarm (FA)
Phone (P)
- number : string
Speaker (S)
- maxVolume : int
SmokeDetector (SD)
- ID : int
Camera (C)
- mode : int
Room (R)
- number : int
AnnouncementProcess (AP)
- logs : string
FireDetector (FD)
- place : coord
Announcer (A)
- volume : int
1..*
1..*
1..*
Figure 6. The resulting persisted CROM model.
94
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

1
CREATE CT FA (ID Int PRIMARY KEY);
2
CREATE RT FD (place Coord,ID Int PRIMARY KEY)
,→ PLAYED BY (SD,C) PART OF FA WITH OCC (1,*);
3
CREATE RT A (loud Int,ID Int PRIMARY KEY)
,→ PLAYED BY (P,S) PART OF FA WITH OCC (1,*);
4
CREATE RT AP (logs Text,ID Int PRIMARY KEY)
,→ PLAYED BY (R) PART OF FA WITH OCC (1,*);
5
CREATE RST detectors CONSISTING OF
,→ FD BEING (1..*) AND AP BEING (1..1);
6
CREATE RST announcers CONSISTING OF
,→ AP BEING (1..1) AND A BEING (1..*);
Listing 1. RSQL Data Deﬁnition Language Statements to Create N.
After inductively deﬁning the persisted CROM P, the con-
straint model DP := {occur, card} is computed from CF by
applying (30) and (31). This results in the following partial
function deﬁnitions, where the feedback cardinality constraint
is removed.
occurDP := {FA→{(1..∞, FD), (1..∞, AP), (1..∞, A)}}
cardDP := {(detectors, FA)→(1..∞, 1..1),
(announcers, FA)→(1..1, 1..∞)}
Finally, the CROM P and constraint model DP is used to
create a database schema and persist valid instances of the ﬁre
alarm model.
B. Database Schema
As aforementioned, the persistence CROM model P will
be stored in an RSQL database that preserves the context-
dependent semantics and information [9]. RSQL is able to di-
rectly store CROM-based models, thereby avoiding the need to
transfer runtime semantics onto traditional database semantics.
Listing 1 lists the RSQL data deﬁnition language statements to
create the schema for P. Please note, for the sake of brevity,
we assume that all natural types have already been created. In
practice, this schema can be generated from a given CROM
and corresponding constraint model [12]. Additionally, queries
directly leverage the context-dependent information during
query processing. This allows the SaS to consistently persist,
i.e., insert, update, delete and query, parts of the context-
dependent knowledge base into the RSQL database system.
VI.
RELATED WORK
The Uniﬁed Modeling Language (UML) lacks expressive
power to model context-dependent domains and while some
approaches extended UML in this regard [13][14][15][16],
their semantics is usually more ambiguous.
The Metamodel for Roles [14] tries to be the most general
formalization of context-dependent roles. Similar to CROM,
it distinguishes between Players, Roles, and Context on the
type and the instance level. Yet, the metamodel is too general
to be useful, because the sets of entities are not required
to be disjoint (on both the type and instance level) [5].
Similarly, the Information Networking Model (INM) [17] is a
data modeling approach designed to overcome the inability of
data models to capture context-dependent information. While
this approach allows to model nested Contexts with attributes
containing Roles, the various kinds of relations cannot be
constrained [17]. By extension, the few hybrid models are
presented in the HELENA approach [16]. It features Ensembles
as compartments to capture a collaborative task by means
of roles that are played by Components. In particular, HE-
LENA provides formal deﬁnitions for both type and instance
level, as well as an operational semantics based on sets and
labeled transition systems [16]. Furthermore, HELENA only
supports occurrence constraints on roles, and no cardinality
constraints on relationships. In contrast to them, CROM has
a well-deﬁned, formal semantics [5], has graphical editing
support [12][18] and supports reasoning [6]. A more detailed
comparison of context-dependent modeling and programming
languages can be found in [19][8].
To persist context-dependent domain models, several ap-
proaches are proposed. Generally, these can be classiﬁed
by their implemented technique. In detail, we distinguish
the following techniques: (i) mapping engines, (ii) persistent
programming languages, and (iii) full DBS implementation.
Firstly, mapping engines, as technique to bridge the tran-
sient application and persistent database world, are well-known
from the object-relational impedance mismatch [20]. However,
mapping engines like DAMPF [21], ObjectTeams JPA [22], or
ConQuer [23] store the transient runtime information in tradi-
tional database systems, which does not preserve the context-
dependent semantics and thus, cannot be leveraged for storing
or querying. Additionally, in multi-application scenarios the
database system cannot ensure the metamodel constraints,
because the mapping engines hide these constraints from the
database system. Secondly, persistent programming languages
like the Dynamic Object-Oriented Database Programming
Language with Roles (DOOR) [24] or Fibonacci [25] unify the
transient application world with the persistent database world.
Unfortunately, these approaches help in single application
scenarios only, because the persistent data storage is part of
the individual applications and thus, not shared with other
applications. Especially for self-adaptive software systems,
several applications need to share their information, not only
directly, but also using a persistent database system, which
makes persistent programming language inappropriate for such
systems. Finally, the last class of approached comprises the
integration of contextual semantics with a database system.
The conceptual model of INM has been implemented into a
database system and features a dedicated query language [17],
[26]. However, INM misses the constraints of relations be-
tween the classes. However, none of them considers to partially
persist a context-dependent domain model while ensuring its
well-formedness and validity.
VII.
CONCLUSION AND FUTURE WORK
SaS rely on context-dependent domain models at runtime
to reason about their environmental situations and system
state. Considering persistence, not all information captured
in the knowledge base needs to be stored persistently. Yet,
ﬁnding a valid partial model that is consistent with the
original domain model is a daunting task, as the model’s
well-formedness and validity depends on the well-formedness
rules, constraints, and instances of the model itself and also
changes after an adaptation of the original domain model. To
remedy this, we proposed the Persistency Transformation ϕ,
an algorithm that computes a minimal valid partial runtime
model given a set of annotated model elements. In fact, we
employed CROM, a dedicated, formalized modeling language
for context-dependent domain models. Based on CROM, we
were able to show that our transformation ensures both the
95
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

well-formedness of the partial CROM model (including the
compliance of the partial constraint model). Moreover, we
showed that arbitrary valid instances of a CROM model can be
automatically restricted (Instance Restriction ψ) with respect
to the partial CROM model, ultimately, yielding valid partial
instances of the partial CROM model. Furthermore, we proved
that such a valid partial instance can be lifted (Instance
Restriction ψ) to the complete CROM model retaining its
validity and compliance. Conversely, we can ensure, in case
of restoring, such context-dependent information will result in
a valid and well-formed runtime model. While the proposed
transformation is independent of the underlying database sys-
tem, our case study employed RSQL, a dedicated database
system for storage and retrieval of context-dependent knowl-
edge bases. Regardless of the underlying database system,
our approach does not only automate ﬁnding a viable partial
model, but also guarantees the consistency of this partial
model and runtime instances. This reduces the requirements
for databases persisting context-dependent knowledge bases of
SaS by reducing the memory footprint and avoiding unintended
system behavior after a system restore. Notably, the presented
algorithm relies on the formal underpinning of CROM and thus
might not be applicable to other context-dependent domain
models. Moreover, the performance and complexity of the
algorithm was not considered in this work. Furthermore, the
presented approach explicitly excludes role groups, as they
can express arbitrary propositional logic formulas [5], thus
signiﬁcantly increasing the expressiveness of CROM.
In the future, we want to fully evaluate the feasibility
of our approach by developing a reference implementation
and evaluating its performance in more realistic application
scenarios. Moreover, we want to introduce role groups by
extending the Persistency Transformation and investigating the
resulting time complexity in the presence of arbitrary role
groups. Ultimately, we want to set up a persistence framework
for context-dependent domain models. Such an integrated
framework would combine modeling the SaS graphically,
adding persistence annotations, computing the valid partial
persistence model, as well as creating the corresponding RSQL
schema statements. Finally, the designed SaS could directly
utilize this framework to consistently persist partial context-
dependent domain models.
ACKNOWLEDGMENT
This work has been funded by the German Research
Foundation within the Research Training Group ”Role-based
Software Infrastructures for continuous-context-sensitive Sys-
tems” (GRK 1907).
REFERENCES
[1]
F. D. Mac´ıas-Escriv´a, R. Haber, R. del Toro, and V. Hernandez, “Self-
adaptive Systems: A Survey of current Approaches, Research Chal-
lenges and Applications,” Expert Systems with Applications, vol. 40,
no. 18, 2013, pp. 7267–7279.
[2]
C. Krupitzer, F. M. Roth, S. VanSyckel, G. Schiele, and C. Becker, “A
survey on engineering approaches for self-adaptive systems,” Pervasive
and Mobile Computing, vol. 17, 2015, pp. 184 – 206.
[3]
C. Hoareau and I. Satoh, “Modeling and processing information for
context-aware computing: A survey,” New Generation Computing,
vol. 27, no. 3, May 2009, pp. 177–196.
[4]
T. J¨akel, M. Weissbach, K. Herrmann, H. Voigt, and M. Leuth¨auser,
“Position Paper: Runtime Model for Role-Based Software Sys-
tems,” in International Conference on Autonomic Computing, ICAC.
Wuerzburg, Germany: IEEE, Jul. 2016, pp. 380–387.
[5]
T. K¨uhn, S. B¨ohme, S. G¨otz, C. Seidl, and U. Aßmann, “A Combined
Formal Model for Relational Context-Dependent Roles,” in Interna-
tional Conference on Software Language Engineering.
ACM, 2015,
pp. 113–124.
[6]
S. B¨ohme and T. K¨uhn, “Reasoning on context-dependent domain
models,” in 7th Joint International Conference on Semantic Technology.
Springer, November 2017, pp. 69–85.
[7]
Y. Brun et al., “Engineering self-adaptive systems through feedback
loops,” in Software engineering for self-adaptive systems.
Springer,
2009, pp. 48–70.
[8]
T. K¨uhn, “A family of role-based languages,” Ph.D. dissertation, Tech-
nische Universit¨at Dresden, 2017.
[9]
T. J¨akel, T. K¨uhn, H. Voigt, and W. Lehner, “Towards a Role-Based
Contextual Database,” in 20th East European Conference on Advances
in Databases and Information Systems.
Springer International Pub-
lishing, 2016, pp. 89–103.
[10]
T. K¨uhn, “Persistence transformation,” 2019. [Online]. Available:
https://github.com/Eden-06/formalCROM/tree/master/persistency
[11]
T. J¨akel, “Role-based data management,” Ph.D. dissertation, Technische
Universit¨at Dresden, 2017.
[12]
T. K¨uhn, K. Bierzynski, S. Richly, and U. Aßmann, “Framed: Full-
ﬂedge role modeling editor (tool demo),” in International Conference
on Software Language Engineering.
ACM, 2016, pp. 132–136.
[13]
Q. Z. Sheng and B. Benatallah, “ContextUML: a UML-based Modeling
Language for Model-driven Development of Context-aware Web Ser-
vices,” in International Conference on Mobile Business.
IEEE, 2005,
pp. 206–212.
[14]
V. Genovese, “A Meta-Model for Roles: Introducing Sessions,” in 2nd
Workshop on Roles and Relationships in Object Oriented Programming,
Multiagent Systems, and Ontologies, 2007, pp. 27–38.
[15]
G. Guizzardi and G. Wagner, “Conceptual Simulation Modeling with
onto-UML,” in Winter Simulation Conference.
Winter Simulation
Conference, 2012, pp. 5:1–5:15.
[16]
R. Hennicker and A. Klarl, “Foundations for Ensemble Modeling–The
Helena Approach,” in Speciﬁcation, Algebra, and Software.
Springer,
2014, pp. 359–381.
[17]
M. Liu and J. Hu, “Information Networking Model,” in International
Conference on Conceptual Modeling.
Springer, 2009, pp. 131–144.
[18]
T. K¨uhn, K. I. Kassin, W. Cazzola, and U. Aßmann, “Modular feature-
oriented graphical editor product lines,” in 22th International Software
Product Line Conference.
Gothenburg, Sweden: ACM, 10th-14th of
September 2018, pp. 76–86.
[19]
T. K¨uhn, M. Leuth¨auser, S. G¨otz, C. Seidl, and U. Aßmann, “A Meta-
model Family for Role-based Modeling and Programming Languages,”
in 7th International Conference on Software Language Engineering.
Springer, 2014, pp. 141–160.
[20]
C. Ireland, D. Bowers, M. Newton, and K. Waugh, “A Classiﬁcation
of Object-relational Impedance Mismatch,” in Advances in Databases,
Knowledge, and Data Applications.
IEEE, 2009, pp. 36–43.
[21]
S. G¨otz, “Dampf - Dresden Auto-Managed Persistence Framework,”
Technische Universit¨at Dresden, Diploma Thesis, 2010.
[22]
O. Otto, “Development of a Persistence Solution for Object Teams based
on the Java Persistence API (dt: Entwicklung einer Persistenzl¨osung
f¨ur Object Teams auf Basis der Java Persistence API),” Technische
Universit¨at Berlin, Diploma Thesis, 2009.
[23]
A. Bloesch and T. Halpin, “Conceptual Queries using ConQuer-II,” in
International Conference on Conceptual Modeling. Springer, 1997, pp.
113–126.
[24]
R. Wong, L. Chau, and F. Lochovsky, “A Data Model and Semantics
of Objects with Dynamic Roles,” in International Conference on Data
Engineering.
IEEE, Apr 1997, pp. 402–411.
[25]
A. Albano, G. Ghelli, and R. Orsini, “Fibonacci: A Programming
Language for Object Databases,” The VLDB Journal, vol. 4, no. 3,
1995, pp. 403–444.
[26]
J. Hu, Q. Fu, and M. Liu, “Query Processing in INM Database System,”
in Web-Age Information Management.
Springer, 2010, pp. 525–536.
96
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

