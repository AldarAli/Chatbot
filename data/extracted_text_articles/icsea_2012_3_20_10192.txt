Decoupled Model-Based Elicitation of Stakeholder Scenarios
Gregor Gabrysiak, Regina Hebig, and Holger Giese
Hasso Plattner Institute at the University of Potsdam
Prof.-Dr.-Helmert-Str. 2-3, 14482 Potsdam, Germany
{gregor.gabrysiak|regina.hebig|holger.giese}@hpi.uni-potsdam.de
Abstract— Requirements engineers iteratively elicit scenarios
by capturing and combining individual stakeholder perspec-
tives into a consistent overall scenario model. This model has
to be validated to exclude elicitation errors and check whether
all alternatives are covered. While involving all stakeholders at
once is considered beneﬁcial, it is usually not feasible due to
scheduling and resource constraints. Consequently, techniques
that permit all stakeholders to be involved in the elicitation
and validation independently, i.e., temporally and locally de-
coupled, are required. In this paper, we present an approach
that enables stakeholders to participate in the elicitation of
their collaborative scenarios remotely and decoupled from
other stakeholders. The resulting fragmentation of the elicited
scenarios is overcome by allowing stakeholders to express their
expectation on how a scenario is usually complemented by
activities of other stakeholders. Our approach systematically
combines these decoupled perspectives to establish the overall
scenario model.
Keywords-decoupled requirements elicitation; scenario synthe-
sis; incomplete scenarios.
I. INTRODUCTION
A requirements engineer gets people to tell the stories
of what their systems are meant to do, as pointed out
by Alexander and Maiden [2]. For complex systems with
multiple, collaborating stakeholder groups, a requirements
engineer needs to listen to all of their stories and to synthe-
size these stories into suitable scenario models. Among other
aspects, these scenarios have to capture how the involved
stakeholders interact to achieve their common goals.
The requirements engineers start by eliciting scenarios
from individual stakeholder perspectives. After combining
these separate scenarios into a consistent overall scenario
model, they validate this model to exclude elicitation errors
and check whether they covered all alternatives. Then,
these initial activities continue iteratively with additional
elicitation activities, updates of the scenario model, and
subsequent validation activities until the result stabilizes.
The overall scenario model is the crucial element to ensure
that a consistent understanding of the different stakeholder
perspectives can be established.
The elicitation and validation of such scenarios requires
less effort if all stakeholders are involved simultaneously.
By directly commenting on whether they agree with the
statements of other stakeholders, the requirements engineer
might obtain a commonly agreed-upon scenario model di-
rectly within an elicitation session [15]. However, due to
scheduling and resource constraints such a setting is usually
not feasible, if not less efﬁcient compared to elicitations with
individual stakeholders [17]. Also, experience shows that in
case of group meetings social effects can result in suppress-
ing opinions and observations of stakeholders positioned
lower in the hierarchy. Furthermore, the stakeholders who
participate are sometimes chosen based on who is noncritical
for the daily work to continue without interruptions [1]. To
limit such effects, techniques that permit all stakeholders
to be involved in the elicitation, consistency, and validation
without the necessity to be present in person at the same
location and at the same time are required.
In our former work we developed a model-based approach
[9]. After initial elicitation interviews, an overall scenario
model is set up and can be validated by stakeholders in
an interactive simulation (play-out, cf. [12]). Stakeholders
can complement each other’s activities through reﬁnement
or playing in additional activities, which result in consistent
model updates. Still, the initial elicitation of new scenarios
remained a problem. Since the simulator cannot know how
to react if no suitable response was observed before, stake-
holders run into dead ends during their elicitation sessions
(referred to as stalemates). Arrange a meeting of all involved
stakeholders to elicit the new scenarios in one simulation
session is a complex, time-consuming solution. If this is
not feasible, the only alternative is to perform multiple
simulation sessions with individual stakeholders. To play-
in her parts of one scenario, a stakeholder is enforced to
participate in multiple sessions, waiting in-between for other
stakeholders to play-in their continuations for the scenario.
Especially for stakeholders playing coordinating roles, this
can lead to numerous sessions.
In this paper, we present an extension of the simulation
approach, that overcomes this challenge and can reduce the
number of necessary sessions. Therefore, we use the simula-
tor’s property to not capture scenarios in an explicit process
view, but in form of reachable states and possible transitions
between them. The idea is to empower stakeholders to
explicitly express the responses they usually expect when
interacting with other stakeholders in form of partial states.
Based on a partial state, a stakeholder can continue playing-
in her parts of the scenario, without requiring additional
elicitation sessions. The extension of the simulator is able
to recognize the fulﬁllment of such expectations, thus, iden-
70
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Role
Artifact
Boat 
Notiﬁer
Communications 
Operative
Boatman
ArtifactState
Overturned
State
isIn
isAt
isAt
Communications
OverturnedBoat
Notiﬁcation
sender
receiver
isOn
Location
next
WalkieTalkie
Message
GoTo
Message
EstimatedArrival
Message
Successful
RescueMessage
RescueFailed
Message
LowOnFuel
Message
Figure 1.
(Abridged) ontology DW elicited from a lifeguard service
tifying a suitable continuation of incomplete interactions.
Consequently, the results of multiple simulation sessions can
be combined automatically.
The paper is structured as follows: At ﬁrst, we present
our model-based approach for the validation, additional
elicitation and model update of scenario models and discuss
its limits in Section II. Based on practical examples elicited
from a lifeguard service, we discuss our approach on how
stakeholders can describe their expected continuations by
simply answering three questions, thereby overcoming these
limitations in Section III. Then, two different types of
triggers are presented in Section IV. Section V explains
how such triggers are fulﬁlled and how the overall scenarios
can be synthesized automatically. The paper closes with a
discussion of related work in Section VI and a conclusion.
II. MODEL-BASED REQUIREMENTS VALIDATION
Requirements engineers can hope to solve the stakehold-
ers’ problems only if they capture the concepts of the
stakeholders’ domain correctly [4]. This can be achieved
by a domain ontology D, which is gathered by the re-
quirements engineers similar to a glossary of commonly
agreed upon deﬁnitions of concepts. By collecting all con-
cepts of the domain under investigation, the requirements
engineers obtain a model suitable to describe scenarios
in that domain. Similar to Artifact Models [3], D also
captures how these concepts relate to each other. As outlined
in [7], a domain ontology D contains the roles involved
and identiﬁed from their scenarios, the artifacts that they
use, and the speciﬁc information that they share. For our
example, Figure 1 illustrates the abridged version DW of
the domain ontology elicited from a lifeguard service. In this
example, the communication between a bystander notifying
the lifeguards (referred to as Notiﬁer) about an emergency,
the corresponding communications operative (ComOp), and
a boatman are elicited.
K¨uhne [14] argues, that metamodels such as D specify a
language that can be used to describe instance situations.
Thus, DW provides a language for describing states as
they can be observed during the scenarios of the lifeguards.
someBoat
:Boat
a:Location
b:Location
d:Location
:Notiﬁer
:Communications 
Operative
c:Location
:Overturned
State
:Boatman
lifeGuard
:Boat
isAt
isAt
isAt
isOn
isIn
isAt
Figure 2.
An initial state sinit of the lifeguard service scenarios
Figure 3. An example of a workplace visualization that allows stakeholders
to interact with other, simulated roles to validate their interactions [6]
Similar to a Uniﬁed Modeling Language (UML) Class Di-
agram, DW prescribes all possible states of the scenarios.
States, in turn, can be speciﬁed using UML Object Dia-
grams.
Such a state is illustrated in Figure 2. It is also
the initial state sinit referred to in the sequence diagrams
throughout the paper. In the following, all state labels
in sequence diagrams refer to complete or partial states
represented by such object diagrams.
Based on the idea of Harel and Marelly’s play-out [12],
our approach includes a simulator, which is able to play-out
behavioral speciﬁcations to simulate the behavior observed
beforehand from speciﬁc stakeholders. This simulator allows
participating stakeholders to experience interactions with
other stakeholders who are not participating in the same
simulation session. Our simulator [9] decouples these inter-
actions temporally by replaying them using the speciﬁcations
to complement activities of participating stakeholders and,
thus, allows stakeholders to validate each other’s behavior
without having to be in the same session or the same room.
Each stakeholder participating in our simulation has an
individual interactive visualization (Figure 3, cf. [6]) of their
distinct perspective on the current state of the simulation.
Depending on the considered domain, different concepts are
visible at different points in time. In case of the lifeguards,
boats can only be seen if the stakeholder is at the same
location (cf. Figure 1). The same holds for different artifacts
or even other stakeholders. Thus, what has to be visualized
to reproduce a distinct stakeholder’s individual perspective
is domain-speciﬁc. However, the requirements engineers can
prototype what has to be shown to quickly get the details
right. Then, the same rules usually apply for all stakeholders.
By using the visualization to interact with the simula-
tion, participating stakeholders can change the state of the
simulation according to what they would normally do in
a corresponding situation, e.g., a boatman might move on
to the next location or upturn an overturned boat. This
visualization allows stakeholders to play through scenarios
by interacting either directly with their colleagues or with
roles that are simulated based on prior observations. In a
related experiment, the state visualization has been evaluated
successfully [8]. Thus, the play-out enables stakeholders to
validate what has been observed and captured so far.
71
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

someBoat
:Boat
a:Location
this
:Notiﬁer
:Overturned
State
:Communications 
Operative
isIn
isAt
isAt
++sender
++receiver
:OverturnedBoat
Notiﬁcation
(a) Notifying the life guard service
(b) Going to the next location
:Location
:Location
--isAt
this
:Boatman
lifeGuard
:Boat
isOn
++isAt
next
Figure 4.
Story patterns of a Notiﬁer informing a CommunicationsOp-
erative about an overturned boat he sees (a) and of a Boatman going from
one location to the next (b)
After stakeholders have played through one of the valid
scenarios, all states observed in-between their initial state
sinit and the ﬁnal state describe the activities of individual
stakeholders and how they interacted. To formally capture
what happened between succeeding states, our approach
relies on graph transformations (speciﬁcally story patterns).
Graph transformations, as described by Heckel [13], consist
of a precondition and a postcondition. Similar to an object
diagram, the precondition is a structural speciﬁcation. If
a state contains an exact match for the precondition of a
story pattern, the matching elements are restructured through
the addition or deletion of the corresponding elements
and associations to match the story pattern’s postcondition,
which is also a structural speciﬁcation. In story patterns, the
elements that need to change are color-coded. Additions,
i.e., instances and associations which have to be added, are
marked using green and “++”, while “– –” in red indicates
removals. For example, Figure 4 illustrates a Notiﬁer noti-
fying a ComOp (a) and a Boatman changing locations (b).
By observing scenarios, i.e., sequences of states, the
simulator can automatically derive story patterns based on
the changes between two succeeding states. Each story
pattern is then assigned to a speciﬁc role, i.e., to the one
represented by the stakeholder, who was observed executing
the behavior that changed the state of the simulation. In each
story pattern, the instance of the speciﬁc role it belongs to
is named this (cf. Figure 4).
As mentioned before, each stakeholder participating in a
simulation has a unique perspective on a state si during a
simulation session. After each activity of another role, the
stakeholder might be affected by the result. Still, only some
of these activities and their results are even visible to the role
that this stakeholder represents. Consequently, every time a
stakeholder participating in the simulation is affected by a
change of the current state of the simulation, e.g., when a
boat arrives at his location or an artifact is brought to his
attention, this change has to be reﬂected in the stakeholder’s
visualization. This visualization illustrates the current state
si of the simulation reduced to what a stakeholder’s role
is able to perceive. We refer to the reduction of a state si
to what is visible for a role RoleT as projection. Thus, a
partial state si|RoleT can be derived from a state si using
the visibility information, which apply for a domain while
si|RoleT ⊆ si has to hold. Per default, si|RoleT contains
an instance of RoleT itself as well as all artifacts and
information this role has access to in si.
Local Changes for Notiﬁer
:Communications
Operative
:Notiﬁer
?
?
sinit
sm
sm|Notiﬁer
s'
What has to happen next?
> After [you (Notiﬁer)]
   sent [OverturnedBoatNotiﬁcation] 
   to [CommunicationsOperative] ...
> [Communications Operative] 
   sends [EstimatedArrivalMessage] 
   to [you (Notiﬁer)]
(unknown sequence of activities and 
interactions between other roles)
Local Changes for Notiﬁer
sm|Notiﬁer
sm|Notiﬁer
s'
OverturnedBoat
Notiﬁcation
EstimatedArrival
Message
Figure 5. While the Notiﬁer knows how she informs the ComOp (green),
she does not know how the ComOp continues this scenario (gray); still,
the Notiﬁer can validate his expectations, i.e., how he is affected (yellow),
in a natural language representation (right)
To allow stakeholders to comment on story patterns or
describe what they can perceive or expect directly, the
underlying object diagrams offer a Natural Language rep-
resentation that is easier to understand for stakeholders as
illustrated in Figure 5.
Based on stakeholder observations of what they do and
how they do it, the story patterns derived from these ob-
servations can be used to replay and simulate the behavior
observed from the individual stakeholders. This, in turn,
enables the simulator to employ strategies to simulate other
stakeholders and, thus, to steer the simulation into conﬂicting
or unresolved states. Consequently, stakeholders can validate
the behavior of other stakeholders by either agreeing to it or
pointing out errors. Through the simulation of other roles,
it becomes unnecessary to get all interacting stakeholders
together in one room at the same time. Attending the simula-
tion does not even require the attendees to be at the same lo-
cation, since the visualization is web-based and, thus, allows
for remote sessions [6]. Since the stakeholders can play-in
incomplete scenarios, which can then be used to simulate
them during simulation sessions with other stakeholders, the
simulator also decouples the stakeholders temporally. By
providing a model-based validation for behavioral models
describing collaborative scenarios, our simulator tries to
solve the problem of elicitation and validation for complex
systems with multiple collaborating stakeholders.
If a stakeholder is observed starting an alternative scenario
the simulator cannot respond appropriately, i.e., cannot offer
any reasonable continuations. Since no behavior is available
that completes this unknown situation, the requirements
engineers have to talk to other stakeholders ﬁrst to get
to know a reasonable continuation for this scenario. Still,
the remainder of the scenario might be unknown as well.
Consequently, in the worst case, the requirements engineers
have to go back and forth between different stakeholders to
complete this scenario. In the worst case, to elicit a simple
scenario between two stakeholders, each of them might have
to be interviewed once for each interaction they have.
III. APPROACH: CHANGES IN PARTIAL STATES
As illustrated in Figure 6, the requirements engineers have
to deal with individual perspectives as well as handovers. It
72
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

:Boatman
:Communications
Operative
:Communications
Operative
:Boatman
: Notiﬁer
:Communications
Operative
?
Estimated Arrival
Message
Overturned Boat
Notiﬁcation
?
Figure 6.
The scenario on the left (a Notiﬁer calling in an emergency)
is incomplete and the Notiﬁer cannot know, which of the possible contin-
uations (right) will occur
TABLE I
BY ANSWERING THESE QUESTIONS, STAKEHOLDERS DESCRIBE, WHICH
INTERACTIONS USUALLY OCCUR AND HOW THEY END
Question for Stakeholder
Answer of Notiﬁer
Named
Q1
Who did you interact with?
CommunicationsOperative
RoleReq
Q2
Who, if not [RoleReq], do
you expect to get an answer
from?
CommunicationsOperative
(default: RoleReq)
RoleResp
Q3
How are you affected by
the outcome? What do you
expect [to get]?
“An
Estimated
Arrival
Message is sent to me”
s′
m|RoleT
happens quite often, that a stakeholder RoleT telling his
story cannot continue after he hands over a critical artifact,
requests information or starts any other form of interaction
with another stakeholder RoleReq. Since RoleT does not
know what Desai et al. [5] refer to as local and usually
private policies, which dictate how RoleReq acts or reacts
in a speciﬁc situation, we can never be completely sure
what happens. We refer to such a potential dead end during
the elicitation as a stalemate – without information on how
another role continues the scenario, requirements engineers
and the stakeholder can only guess what happens next.
Generally, a stalemate can only be overcome if the
requirements engineers gather the other side of the story.
Similar to a black box, we can only assume how RoleReq
continues after being triggered. Still, while RoleReq’s ac-
tions are not yet known, RoleT can describe most of the
possible outcomes, i.e., how he is affected by the result,
based on experience. Similar to a jigsaw puzzle, many pieces
of information exist, however, only few of them are required
to complete individual scenarios. Thus, it is essential that
individual stakeholders do not give up at the ﬁrst stalemate,
but are able to continue to describe their expectation(s) as
well as their follow-up actions. Even if a stalemate occurs
during an elicitation of a scenario, a stakeholder can still
answer the questions in Table I.
Q1 provides the requirements engineers with the informa-
tion of who to talk to next to complete the scenario. Only
a stakeholder identiﬁed as role RoleReq, i.e., someone who
usually receives RoleT ’s request, knows how to continue.
For the Notiﬁer, this would be the CommunicationsOperative
(ComOp) who he notiﬁes about an emergency (Figure 6).
After this operative passed on the information, the Notiﬁer
expects to hear from her again – consequently, the Q2 would
be answered the same. Still, in other cases, the person being
interacted with is not the one who responds. To be able
to distinguish between different responses from different
stakeholders, Q2 provides information on who else might
provide a response RoleT expects.
The simulation has a speciﬁc state sm, in which the
stalemate occurred. In this state, an interaction has been
started that results in a change for RoleT – although he
does not know how anyone else might be affected as a side
effect, the stakeholder can still describe what changes for
him (Q3). Since stakeholders can only describe changes
that affect them directly and that are visible for them,
the expectation can only be a partial state based on the
perspective of an individual stakeholder. In the example
provided in Table I, the Notiﬁer expects to receive an
estimation on when someone will arrive. Thus, using the
vocabulary already established as part of the domain model
DW , this expectation can be described explicitly.
IV. EXPECTATION TRIGGERS & FOLLOW-UP ACTIONS
We deﬁne an expectation as the partial state a role expects
to perceive between a pair of states sm and s′
m. Since a
single stakeholder cannot know how the overall state of all
stakeholders changed in-between, he can only specify his
perspectives of the respective states. Thus, in case of the No-
tiﬁer, he expects sm|Notiﬁer and s′
m|Notiﬁer to be identical,
except that he has to receive an EstimatedArrivalMessage
from a CommunicationsOperative. Whether a boat already
departed to his location or whether another emergency hap-
pened somewhere else is unknown to the Notiﬁer, as long as
none of those things are visible to him. The expected follow-
up state can be represented and described in different ways to
be suitable for stakeholders. While Figure 7 (right) illustrates
it as a partial state in an object diagram, Figure 5 (right)
presents a natural language representation that can easily
be understood and modiﬁed: [CommunicationsOperative]
sends [EstimatedArrivalMessage] to [you (Notiﬁer)].
In Section III, a stalemate sm occurred and the partic-
ipating stakeholder representing a Notiﬁer was asked to
verbalize his expectations on how another stakeholder he
interacted with might respond or, more generally, how his
context might change. From his answers to the questions in
Table I, a trigger for the other stakeholder can be generated.
A trigger is a tuple (ssm, RoleT , RoleReq, RoleResp,
s′
sm|RoleT ). It contains the stalemate state ssm as it occurred
during the simulation. Further, the role of the participant
who deﬁned the trigger (RoleT ) is included. Additionally,
to resolve the trigger, it is essential to know, which role
is expected to continue the scenario and which role di-
rectly interacts with RoleT next (RoleReq and RoleResp,
respectively). Finally, the partial state s′
sm|RoleT that RoleT
expects to observe afterwards is included as well. Based
on the answers of Notiﬁer in Section III, the resulting
73
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

someBoat
:Boat
a:Location
b:Location
d:Location
:Notiﬁer
:Communications 
Operative
c:Location
:Overturned
State
:Boatman
lifeGuard
:Boat
isAt
isAt
isAt
isOn
isIn
isAt
sender
receiver
:OverturnedBoat
Notiﬁcation
t1
:Notiﬁer
:Communications 
Operative
sender
receiver
:EstimatedArrival
Message
?
?
?
?
?
?
?
Figure 7.
Based on sm (left, Notiﬁer’s visibility is highlighted in blue),
the Notiﬁer can describe changes he expects as a partial state s′
m|Notiﬁer
(right) in DW ’s vocabulary, leading to trigger t1
:Location
:Notiﬁer
this:Communications
Operative
:Boatman
isAt
--sender
--receiver
:Estimated
ArrivalMessage
++sender
++receiver
:Estimated
ArrivalMessage
?
?
?
?
?
?
?
isAt
isAt
isIn
:Notiﬁer
someBoat
:Boat
a:Location
:Overturned
State
lifeGuard
:Boat
:Boatman
isAt
isOn
(a) Story pattern x based on follow-up 
action f1
(b) Eventually, the Notifier expects a lifeguard 
boat to arrive at his location
Figure 8.
While the ComOp deﬁnes a follow-up action f1, which leads
to story pattern x (a), the Notiﬁer expects to see a lifeguard boat (b).
trigger would be t1 =(sm, Notiﬁer, ComOp, ComOp,
s′
m|Notiﬁer), as illustrated in Figure 7.
A. Triggers and Alternatives
After the ComOp’s GoTo message sending a Boat-
man
to
another
location
in
response
to
the
noti-
ﬁcation,
ComOp
expects
that
the
Boatman
responds
with
an
EstimatedArrivalTime
as
prescribed
by
their
protocol. Consequently, the ComOp deﬁnes a trigger
t2 = (sn, ComOp, Boatman, Boatman, s′
n|ComOp) expect-
ing this message. While the ComOp might usually get an
EstimatedArrival message, she might also be confronted
with a LowOnFuel message, indicating that the boat needs
to refuel ﬁrst (Figure 9). Of course, the ComOp knows that
all boats are fueled up at the beginning of each weekend.
However, she does not know how much gas each boat may
have left after several hours of service – an information
only available to each respective Boatman. Thus, although
a ComOp knows both possible outcomes, she cannot know,
which one she will be confronted with, since she has no
access to the information required for this decision.
From sn, as for most stalemates, multiple continuations
are possible from ComOp’s point of view. Consequently,
the LowOnFuel alternative can re-use sn and is deﬁned as
trigger t3 = (sn, ComOp, Boatman, Boatman, s′′
n|ComOp)
(cf. Figure 9).
B. Follow-Up Actions
A follow-up action f is an activity of a role, which
is expected to apply if a speciﬁc precondition is fulﬁlled.
It is characterized by a pair of states, the ﬁrst being a
precondition (sF |RoleT ), which has to be fulﬁlled to execute
the changes speciﬁed in the second (s′
F |RoleT ). As sketched
in Table II, a follow-up action is the answer on how a
role would continue after a stalemate has been overcome,
alt
:Communications 
Operative
:Boatman
What has to happen next?
> When [you (CommunicationsOperative)]
   sent [GoToMessage] to [Boatman] ...
> [you (CommunicationsOperative)] 
   receive [EstimatedArrivalMessage] 
   from [Boatman]
Expectation 1
> [you (CommunicationsOperative)] 
   receive [LowOnFuelMessage] 
   from [Boatman]
Expectation 2
sm
sn
?
GoToMessage
EstimatedArrival
Message
?
LowOnFuel
Message
?
sn|ComOp
  '
sn|ComOp
  ''
Figure 9.
Both expectations on how a Boatman may react to a GoTo
message as experienced before and, thus, expected by a ComOp
TABLE II
BY ANSWERING THESE QUESTIONS, A STAKEHOLDER SPECIFIES A
DISTINCT STATE AND HOW HE OR SHE FOLLOWS UP ON IT
Question for Stakeholder
Answer of ComOp
Named
QA
When do you become
active?
“After
the
Boatman
sent me an Estimated-
ArrivalMessage”
sF |RoleT
QB
How do you continue af-
ter [sF |RoleT ]?
“I send the Notiﬁer an
EstimatedArrivalMes-
sage”
s′
F |RoleT
i.e., after the expectation has been fulﬁlled. After ComOp’s
expectations have been captured in t2, the participating
stakeholder can still describe how she as a ComOp would
continue after her expectation (s′
n|ComOp) is fulﬁlled. Con-
sequently, s′
n|ComOp is presented to the stakeholder, either
in an interactive visualization or in a textual representation.
Based on this perspective, the stakeholder is able to specify
the differences that her follow-up actions result in. In our
example, the answer would be: “I send the Notiﬁer an
EstimatedArrivalMessage” (s′′′
n |ComOp, cf. Table II). Since
the trigger has to be resolved for the stakeholder to follow
up, the current state of the simulation needs to match the
postcondition of the trigger. Thus, the postcondition of this
trigger can be used as the precondition of the follow-up
action. Combined with the follow-up state, this leads to the
follow-up action f1 = (s′
n|ComOp, s′′′
n |ComOp). Similar to a
pair of complete states, these two partial states can be used
to derive a story pattern x (Figure 8a), which captures what
the ComOp wants to achieve from her perspective.
In case of the ComOp, the precondition was already de-
ﬁned and was reused. If no trigger was deﬁned beforehand,
the stakeholder may still describe both situations, i.e., answer
QA and QB, using natural language as sketched in Figure 5
(right). Of course, after having deﬁned a follow-up action,
additional follow-up actions can be deﬁned.
V. RESOLVING TRIGGERS – SYNTHESIS
After the requirements engineer elicited an incomplete
scenario ending in a stalemate ssm and at least one trigger
tm =(ssm, RoleT , RoleReq, RoleResp, s′
sm|RoleT ), the
next stakeholder to talk to is already predetermined. To
complete this scenario, a stakeholder of the corresponding
role RoleReq needs to participate to continue the interaction
with RoleT .
The requirements engineer starts a simula-
74
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

(a) Incomplete scenario after a Notifier session
(b) Same scenario after a ComOp follows up 
t1
:Communications 
Operative
:Boatman
sm
sinit
sn|ComOp
  '
x
?
?
t2
sn
sn |ComOp
  '''
f1
:Notiﬁer
sm|Notiﬁer
  '
:Communications 
Operative
:Boatman
?
?
t1
:Notiﬁer
sm|Notiﬁer
  '
sm
sinit
Figure 10.
The expectation described in t1 (a) might be fulﬁlled after t2
has been resolved and follow-up action f1 was executed (b)
tion session by loading the state ssm for RoleReq. The
visualization of ssm corresponding to RoleReq’s perspective
should visualize the last interaction with RoleT in such a
way, that the participating stakeholder is able to identify,
which scenario the requirements engineers are currently
interested in. By explicitly loading ssm, inconsistencies
between different triggers and their continuations can be
avoided, since all follow-up activities are direct responses
leading towards the expectation s′
sm|RoleT .
In a simple case, RoleReq is also the responding role
RoleResp, which can answer directly and fulﬁll RoleT ’s
expectation immediately with a suitable response. In case of
t1, however, ComOp cannot yet fulﬁll Notiﬁer’s expectation
(s′
m|Notiﬁer). During the simulation for t1, all activities of
ComOp (RoleReq and RoleResp) and any other role involved
(Boatman) within the interactive visualization of sm lead to
a state sx, in which ComOp responded as expected.
An expectation is fulﬁlled, if its partial state s′
sm|RoleT
expected by RoleT can be found in sx. Since s′
sm|RoleT
and sx are structural speciﬁcations conforming to DW , the
simulator can try to match the expectation s′
sm|RoleT to a
part of sx. If such a match can be identiﬁed, the context of
RoleT in sx is as expected: sx ⊇ sx|RoleT ⊇ s′
sm|RoleT .
Consequently, if RoleResp’s activities led to such a state,
these observed activities are a suitable continuation for the
scenario from the point of views of RoleT and RoleResp.
To resolve the trigger t1, that Notiﬁer created in a ﬁrst
session (1st row in Figure 12), its stalemate sm (illustrated in
Figure 7) is loaded and the participating ComOp stakeholder
receives Notiﬁer’s notiﬁcation of an overturned boat in the
corresponding visualization of sm. As always, the ComOp
continues by starting an interaction with a Boatman by send-
ing a GoToMessage, thereby bringing the simulation into the
state sn (2nd row). At this point, the ComOp cannot continue
to play-in what needs to be done, since a stalemate sn is
reached in which she cannot deterministically predict how
the Boatman will react. As outlined in Section IV-A, two
different scenarios are possible. After the ComOp deﬁned
someBoat
:Boat
a:Location
b:Location
d:Location
:Notiﬁer
:Communications 
Operative
c:Location
:Overturned
State
:Boatman
lifeGuard
:Boat
isAt
isAt
isAt
isOn
isIn
isAt
sender
receiver
:Estimated
ArrivalMessage
Figure 11.
After ComOp is simulated using the story pattern x, the
simulation is in state sx with sx ⊃ s′
m|Notiﬁer = s′′′
n |ComOp (fulﬁlling
the highlighted expectation in Figure 7)
both corresponding expectations (t2 and t3), she also deﬁnes
the follow-up action f1 (cf. Section IV-B), which leads to
the story pattern x (cf. Figure 8a) of how she continues after
the expectation of t2 has been fulﬁlled.
As speciﬁed in t2 and t3, the next role to talk to is
Boatman, who needs to continue from sn. After the stake-
holder reviewed sn in his visualization, he responds with
an estimated arrival time (3rd row), thereby leading the
simulation into state sq in which Boatman fulﬁlled ComOp’s
expectation as deﬁned in t2. In sq, ComOp’s follow-up
action f1 is applicable since its precondition is identical to
t2’s postcondition (s′
n|ComOp). Consequently, by resolving
t2, the story pattern x is executed to simulate ComOp’s
follow-up action, leading the simulation into the follow-up
state sx (4th row). More importantly, the initial expectation
of Notiﬁer, i.e., the partial state s′
m|Notiﬁer, can be matched
since the expected answer was provided through ComOp’s
follow-up action (cf. Figure 11). Thus, the requirements
engineers end up with a completed scenario (5th row). Also,
the story patterns necessary to reproduce and simulate it
for other stakeholders can be derived from observations
or follow-up actions. Now, the requirements engineers can
continue by collecting alternatives, e.g., what has to happen
when a Boatman fulﬁlls the expectation described in t3?
All triggers that are collected along the way are stored
next to the story patterns, which are derived from observed
scenarios. To resolve them, the simulator simply checks
whether the expected outcome of an interaction (s′
sm|RoleT )
can be matched in the current state si of the simulation.
Based on this algorithm, scenarios are completed step by
step from stakeholder to stakeholder as illustrated for the
notiﬁcation example in Figure 12. The possibility remains,
that no state sx ⊇ s′
m|Notifier can be reached – even after
multiple sessions of the role that is expected to reply. In
this case, the requirements engineer has to be notiﬁed and
two options are present: directly intervene and either talk to
RoleResp to ask, e.g., what needs to be true for the Boatman
to not answer
as expected or talk to Notiﬁer (RoleT ) to
check whether the expectation that was described is correct.
VI. RELATED WORK
One of the main contributions of Harel and Marelly’s
Play-approach [11], [12], is the possibility not only replaying
captured system behavior (play-out), but the possibility
to capture additional system behavior (play-in) and, thus,
75
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

sm|Notiﬁer
  '
sm|Notiﬁer
  '
sx
sn  |ComOp
  '''
sn|ComOp
  '
sq
sq
sn|ComOp
  '
t2=(sn, ComOp, Boatman, Boatman, sn|ComOp)
and t3 (not shown) are deﬁned along with the
follow-up action f1
  '
Boatman
Session:
Execute 
ComOp's
Follow-up
sm 
m
sinit
sn
n
t1
q
t1 is fulﬁlled since sx|Notiﬁer = sm|Notiﬁer
  '
Notiﬁer
Session
sm 
m
sinit
t1
sm|Notiﬁer
  '
t1=(sm, Notiﬁer, ComOp, ComOp, sm|Notiﬁer)
is deﬁned
  '
ComOp
Session
sm 
m
sinit
sn
n
t1
t2
Boatman
Session
t2 is fulﬁlled since sq|ComOp = sn|ComOp
and story pattern x (derived from f1) can be 
executed on sq to simulate ComOp
  '
sm 
m
sinit
sn
n
t1
t2
q
sm|Notiﬁer
  '
sn  |ComOp
  '''
f1
sn  |ComOp
  '''
f1
x
sx
sq
Complete
Scenario
sm 
m
sinit
sn
n
x
q
Results: 
- complete scenario which can be simulated
- 5 story patterns (m,n,p,q,x) which may
  already cover alternative scenarios
a partial state as  expected 
by a ComOp (based on sn ) 
sn 
t2
a trigger      connecting a 
stalemate      and its 
corresponding expectation
sn|ComOp
  '
sn|ComOp
  '
sn  |ComOp
  '''
f1
a follow-up action     deﬁning 
what ComOp does after an 
expectation is fulﬁlled
si
simulation session starting 
in si and ending in si+1
si+1
a state sq fulﬁlling an 
expectation of a ComOp
sn|ComOp
  '
sq
a state sn
sn
f1
t2
sn
KEY
Figure 12.
After only three stakeholder sessions, the scenario has been completed with two triggers and one follow-up action
new scenarios while doing so. Their approach, however, is
centered around user interfaces – for each input the user
provides, she can play-in how the system should react.
While this might sufﬁce to capture the interaction between
individual stakeholders and a software system, i.e., its user
interface (UI), the elicitation of interactions between differ-
ent stakeholders is more complex.
Still, the play-engine [12] can be used to enable stakehold-
ers to perceive the complete state the system is in, reduced
to what is presented in the UI. The similar visualization
approach is used by Ponsard et al. for speciﬁc goals such as
whether a door of a train is closed when its moving [21] or
even to represent domain-speciﬁc UI elements and how they
affect each other from the point of view of a speciﬁc stake-
holder [16]. However, these approaches are limited to single
stakeholders and their interaction with a software system
only – collaborative processes with information asymmetry
cannot be elicited or validated.
Scenario-based approaches have been researched quite
broadly, most notably by Uchitel et al. [18][19][20]. Starting
with sets of potentially incomplete, implied or negative sce-
narios, they are able to derive state machines for the involved
components that are suitable for all of these scenarios, in
case of Whittleetal. even hierarchical ones [23]. Still, these
approaches are not suitable to elicit human interactions,
which are limited by what stakeholders can perceive from
their individual context. To obtain behavioral models of
what the stakeholders do, it does not sufﬁce to know,
which messages arrived at a stakeholder in which sequence,
but rather, which artifacts and information they can see
or access.
For instance, the Notiﬁer’s expectation, that a
lifeguard boat arrives (Figure 8b) can only be fulﬁlled by
the Boatman moving to the corresponding location (Figure
4b). Only by eliciting and validating them in a state-based
manner, it becomes viable to visualize the current state a
stakeholder is in based on what she has access to.
Similar to our approach, Ghezzi et al. [10] compare pairs
of succeeding states to derive the behavior of Java classes as
graph transformations. While their method of automatically
eliciting behavior is identical, their approach is restricted to a
single actor, i.e., an instance of a class, and cannot cope with
information asymmetry. The same goes for van der Aalst’s
ProM approach [22], which is able to derive a process model
of how people can achieve their goals collaboratively based
on log ﬁles detailing different scenarios. However, ProM is
only able to use the information that is available in these
logs, provided a logging system is already in place and
analog interactions cannot be captured.
VII. CONCLUSION AND FUTURE WORK
In this paper, we presented an approach that reduces
the effort necessary to elicit and validate new collabora-
tive scenarios. Thereby, the number of sessions necessary
to elicit a stakeholder’s actions within a scenario can be
reduced. In case of stalemates, stakeholders can express
their expectations on interaction results in form of par-
tial states. Based on these partial scenarios, stakeholders
are then able to play-in continuing behavior decoupled
from one another. Our simulator synthesizes the captured
individual perspectives to obtain the complete scenarios,
thereby overcoming the inherent fragmentation of different
perspectives. We discussed how this technique extends our
model-based validation approach to be applicable for model-
based elicitation, too. The method was illustrated on a real
life example of a lifeguard service.
Using the old approach, the requirements engineer would
have to go back and forth between two or more stakeholders
for each interaction. Thus, the total number of sessions
required to elicit a complete scenario related to the number
of stalemates the stakeholders ran into during the elicitation,
76
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

since an additional session is necessary for each stalemate
that occurred. Generally, the number of stalemates per role
can vary strongly. Especially for the role ComOp in the
lifeguard example, at least ten interactions need to be elicited
for each scenario, which leads to the same number of
sessions to resolve the implied stalemates. However, by
being able to express her expectations and, thus, triggers
intuitively, the ComOp is now able to defer the completion
of all scenarios to other stakeholders later on. Consequently,
instead of ten sessions to overcome ComOp’s stalemates
only, ComOp can express all her contributions to the collab-
orative scenarios in just one session. Decoupled from her,
the other stakeholders can then complement the scenarios
accordingly. By systematically completing these scenarios,
the total number of elicitation sessions no longer depends on
the number of interactions and stalemates, but on the number
of roles and their ability to express their expectations. In
this case, our approach can end up with only one elicitation
session per role.
For future work, we want to evaluate whether stakeholders
are able to describe all of their interactions in the proposed
way and investigate, for which domains and scenarios this
technique works best. Our approach currently focuses on
completing one scenario at a time. We plan to investigate
how the overall number of sessions can be further reduced
by taking into account how stakeholders interact in multiple
scenarios. For instance, the resolution of triggers from
multiple scenarios might be handled in the same session.
REFERENCES
[1] A. Al-Rawas and S. Easterbrook. Communication Problems
in Requirements Engineering: A Field Study. In Proc. of the
First Westminster Conference on Professional Awareness in
Software Engineering. Royal Society, London, 1996.
[2] I. Alexander and N. Maiden, editors. Scenarios, Stories, Use
Cases: Through the Systems Development Life-Cycle. John
Wiley, New York, 2004.
[3] B. Berenbach, D. Paulish, J. Kazmeier, and A. Rudorfer.
Software & Systems Requirements Engineering: In Practice.
McGraw-Hill, Inc., New York, NY, USA, 2009.
[4] A. Davis and K. Nori.
Requirements, plato’s cave, and
perceptions of reality. Computer Software and Applications
Conference, Annual Int., 2:487–492, 2007.
[5] N. Desai, A. Mallya, A. Chopra, and M. Singh. Interaction
protocols as design abstractions for business processes. IEEE
Transactions on Software Engineering, 31:1015–1027, 2005.
[6] G. Gabrysiak, H. Giese, and A. Seibel. Interactive Visual-
ization for Elicitation and Validation of Requirements with
Scenario-Based Prototyping. In Proc. of the 4th International
Workshop on Requirements Engineering Visualization, pages
41–45, Los Alamitos, USA, 2009. IEEE Computer Society.
[7] G. Gabrysiak, H. Giese, and A. Seibel. Using Ontologies for
Flexibly Specifying Multi-User Processes. In Proc. of ICSE
2010 Workshop on Flexible Modeling Tools, Cape Town,
South Africa, 2010.
[8] G. Gabrysiak, H. Giese, and A. Seibel.
Towards Next-
Generation Design Thinking II: Virtual Multi-User Software
Prototypes. In H. Plattner, C. Meinel, and L. Leifer, editors,
Design Thinking Research, Understanding Innovation, pages
107–126. Springer, 2012.
[9] G. Gabrysiak, R. Hebig, and H. Giese. Simulation-assisted
elicitation and validation of behavioral speciﬁcations for
multiple stakeholders. In Proc. of the 21st IEEE International
Conference on Collaboration Technologies and Infrastruc-
tures, Toulouse, France, June 2012.
[10] C. Ghezzi, A. Mocci, and M. Monga. Synthesizing intensional
behavior models by graph transformation.
In Proc. of the
IEEE International Conference on Software Engineering,
pages430–440, Washington, USA, 2009. IEEE.
[11] D. Harel, H. Kugler, and A. Pnueli. Synthesis revisited: Gen-
erating statechart models from scenario-based requirements.
In H.-J. Kreowski, U. Montanari, F. Orejas, G. Rozenberg,
and G. Taentzer, editors, Formal Methods in Software and
Systems Modeling, pages 309–324. Springer, 2005.
[12] D. Harel and R. Marelly. Come, Let’s Play: Scenario-Based
Programming Using LSC’s and the Play-Engine. Springer-
Verlag New York, Inc., Secaucus, NJ, USA, 2003.
[13] R. Heckel. Graph transformation in a nutshell. Electronic
Notes in Theoretical Computer Science, 148(1):187 – 198,
2006.
Proc. of the School of SegraVis Research Training
Network on Foundations of Visual Modelling Techniques.
[14] T. K¨uhne. Matters of (meta-) modeling. Software and Systems
Modeling, 5:369–385, 2006.
[15] A. Luebbe and M. Weske.
Tangible media in process
modeling – a controlled experiment. In H. Mouratidis and
C. Roland, editors, 23th Conference on Advanced Information
Systems Engineering (CAiSE 2011), pages 283–298, 2011.
[16] C. Ponsard, N. Balych, P. Massonet, J. Vanderdonckt, and A.
van Lamsweerde. Goal-Oriented Design of Domain Control
Panels. In S. W. Gilroy and M. D. Harrison, editors, DSV-IS,
volume 3941 of LNCS, pages 249–260. Springer, 2005.
[17] N. Seyff, N. Maiden, K. Karlsen, J. Lockerbie, P. Gr¨unbacher,
F. Graf, and C. Ncube. Exploring how to use scenarios to
discover requirements. Requirements Engineering, 14(2):91–
111, 2009.
[18] S. Uchitel, G. Brunet, and M. Chechik. Synthesis of Partial
Behavior Models from Properties and Scenarios.
IEEE
Transactions on Software Engineering, 35(3):384–406, 2009.
[19] S. Uchitel, J. Kramer, and J. Magee.
Detecting implied
scenarios in message sequence chart speciﬁcations. SIGSOFT
Softw. Eng. Notes, 26:74–82, September 2001.
[20] S. Uchitel, J. Kramer, and J. Magee. Incremental elaboration
of scenario-based speciﬁcations and behavior models using
implied scenarios. ACM Trans. Softw. Eng. Methodol., 13:37–
85, 2004.
[21] H. T. Van, A. van Lamsweerde, P. Massonet, and C. Ponsard.
Goal-oriented requirements animation.
Requirements Engi-
neering, IEEE International Conference on, 218–228, 2004.
[22] W.M.P. van der Aalst. Trends in business process analysis:
Fromvalidationtoprocessmining. In International Conference
onEnterpriseInformationSystems, Funchal, Portugal, 2007.
[23] J. Whittle and P. Jayaraman. Synthesizing hierarchical state
machines from expressive scenario descriptions. ACM Trans.
Softw. Eng. Methodol., 19:8:1–8:45, 2010.
77
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

