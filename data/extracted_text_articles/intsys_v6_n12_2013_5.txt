53
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Inverse Kinematics with Dual-Quaternions,
Exponential-Maps, and Joint Limits
Ben Kenwright
Newcastle University
School of Computing Science
United Kingdom
b.kenwright@ncl.ac.uk
Abstract—We present a novel approach for solving articu-
lated inverse kinematic problems (e.g., character structures)
by means of an iterative dual-quaternion and exponential-
mapping approach. As dual-quaternions are a break from the
norm and offer a straightforward and computationally efﬁcient
technique for representing kinematic transforms (i.e., position
and translation). Dual-quaternions are capable of represent
both translation and rotation in a uniﬁed state space variable
with its own set of algebraic equations for concatenation
and manipulation. Hence, an articulated structure can be
represented by a set of dual-quaternion transforms, which we
can manipulate using inverse kinematics (IK) to accomplish
speciﬁc goals (e.g., moving end-effectors towards targets). We
use the projected Gauss-Seidel iterative method to solve the IK
problem with joint limits. Our approach is ﬂexible and robust
enough for use in interactive applications, such as games. We
use numerical examples to demonstrate our approach, which
performed successfully in all our test cases and produced
pleasing visual results.
Keywords-Inverse Kinematics; Gauss-Seidel; Articulated Char-
acter; Games; Joint Limits; Iterative; Dual-Quaternion; Jaco-
bian; Exponential-Map
I. INTRODUCTION
Generating fast reliable Inverse Kinematic (IK) solutions
in real-time with angular limits for highly articulated ﬁgures
(e.g., human bipeds including hands and feet) is challenging
and important [1, 2, 3, 4, 5]. The subject is studied across
numerous disciplines, such as graphics, robotics, and biome-
chanics, and is employed by numerous applications in the
ﬁlm, animation, virtual reality, and game industry
However, articulated models (e.g., bipeds and hands) can
be highly complex; even the most simpliﬁed models of
20-30 joints can generate a vast number of poses [6, 7].
Whereby producing a simple pose to achieve a solitary task
can produce ambiguous solutions that make the problem
highly nonlinear and computationally expensive to solve. For
example, even a straightforward task of reaching to pickup
an object can be accomplished by means of any number of
motions.
This paper focuses using dual-quaternions and quaternion
exponential-maps with an iterative Gauss-Seidel algorithm
[8] to solve an articulated IK problem; such as the hand
model shown in Figure 2. The Gauss-Seidel algorithm
is an iterative, efﬁcient, low memory method of solving
linear systems of equations of the form Ax = b. Hence,
we integrate the Gauss-Seidel iterative algorithm with an
articulated IK problem to produce a ﬂexible whole system
IK solution for time critical systems, such as games. This
method is used as it offers a ﬂexible, robust solution with
the ability to trade accuracy for speed and give good visual
outcomes.
Furthermore, to make the Gauss-Seidel method a practical
IK solution for an articulated hand structure, it needs to
enforce joint limits. We incorporate joint limits by modi-
fying the update scheme to include an iterative projection
technique. Additionally, to ensure real-time speeds we take
advantage of spatial coherency between frames as a warm
starting approximation for the solver. Another important
advantage of the proposed method is the simplicity of the
algorithm and how it can be easily conﬁgured for custom
IK problems.
The main contribution of the paper is the practical demon-
stration and discussion of using the Gauss-Seidel method
for real-time articulated IK problem with joint limits, dual-
quaternions [9], and exponential-quaternion mapping [10].
Furthermore, we discuss constraint conditions, speedup ap-
proaches and robustness factors for solving highly non-linear
IK problems in real-time.
The roadmap for rest of the paper is organized as fol-
lows. Firstly, we brieﬂy review existing work in Section
II. Section III describes the articulated model, we use for
our simulations. Then in Section IV, we present essential
mathematical algorithms and principles for the paper (e.g.,
dual-quaternion algebra). We follow on by explaining the IK
problem in Section V. While in Section VI, we explain the
Jacobian matrix, then in Section VII we discuss our approach
for solving the IK problem with the Gauss-Seidel algorithm.
Finally, we present results in Section IX, then Section X
discusses limitations, followed by the closing conclusion and
discussion in Section XI.
II. RELATED WORK
Inverse kinematics is a popular problem across numerous
disciplines (e.g., graphical animation, robotics, biomechan-

54
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 1.
Forward & Inverse Kinematics. Illustrating the relationship
between forward and inverse kinematics parameters.
ics). IK is a vital component that can be implemented using a
wide range of solutions. We give a brief overview of existing,
current, and cutting-edge approaches to help emphasise the
different ways of approaching the problem; enabling the
reader to see where our method sits.
In general, however, for very simple problems with just
a few links, analytical methods are employed to solve the
IK problem. Alternatively, for larger conﬁgurations, iterative
numerical methods must be employed due to the complexity
of the problem.
The articulated IK problem of ﬁnding a solution for
poses that satisfy positional and orientation constraints has
been well studied, e.g., [11, 3, 12, 7]. The problem is
highly nonlinear, meaning there can be numerous solutions;
hence, multiple poses fulﬁlling the constraint conditions.
In practical situations, there can even be cases where no
solution exists due to the poor placement of end-effectors.
IK systems typically use cut down models, e.g., merely
performing IK on individual limbs (as in body, arms, legs)
[13, 14, 6]. This makes the problem computationally simpler
and less ambiguous.
Numerous solutions from various ﬁelds of research have
been implemented to solving the IK problem. The Jacobian-
based matrix approach is one of the most popular methods
and the method upon which we base our iterative solution
[7, 15, 16]. The Jacobian matrix method aims to ﬁnd a linear
approximation to the problem by modelling the end-effectors
movements relative to the instantaneous systems changes of
the links translations and orientations. Numerous different
methods have been presented for calculating the Jacobian
inverse, such as, Jacobian Transpose, Damped Least-Squares
(DLS), Damped Least-Squares with Singular Value De-
composition (SVD-DLS), Selectively Damped Least-Square
(SDLS) [17, 5, 18, 19, 20, 15].
An alternative method uses the Newton method; whereby
the problem is formulated as a minimization problem from
which conﬁguration poses are sought. The method has the
disadvantage of being complex, difﬁcult to implement and
computationally expensive to computer-per-iteration [16].
The Cyclic Coordinate Descent (CCD) is a popular real-
time IK method used in the computer games industry [21].
Originally introduced by Wang et al. [22] and then later
extended to include constraints by Welman et al. [3]. The
CCD method was designed to handle serial chains and is
thus difﬁcult to extend to complex hierarchies. It has the
advantage of not needing to formulate any matrices and has
a lower computational cost for each joint per iteration. Its
downside is that the character poses even with constraints
can produce sporadic and unrealistic poses. However, further
work has been done to extend CCD to work better with
human based character hierarchies [4, 6, 23].
A novel method recently proposed was to use a Sequential
Monte Carlo approach but was found to be computationally
expensive and only applicable for ofﬂine processing [24, 25].
Data driven IK systems have been presented; Grochow et
al. [26] method searched a library of poses to determine an
initial best guess solution to achieve real-time results. An
ofﬂine mesh-based for human and non-human animations
was achieved by learning the deformation space; generating
new shapes while respecting the models constrains [27, 28].
A method known as ”Follow-The-Leader” (FTL) was
presented by Brown et al. [29] and offered real-time results
using a non-iterative technique. However, this approach was
later built upon by Aristidou et al. [30] and presented an
iterative version of the solver known as FABRIK.
The Triangular IK method [31, 32], uses trigonometric
properties of the cosine rule to calculate joint angles, be-
ginning at the root and moving outwards towards the end-
effectors. While the algorithm can be computationally fast,
due to it being able to propagate the full hierarchy in a single
iteration, it cannot handle multiple end-effectors well and is
primarily based around singly linked systems.
The advantages of an iterative IK system for articulated
structures, such as character, was also presented by the
interesting paper by Tang et al. [33] who explored IK tech-
niques for animation using a method based on the SHAKE
algorithm. The SHAKE algorithm is an iterative numerical
integration scheme considered similar to the Verlet method
[34], which can exploit substantial step-sizes to improve
speed yet remain stable when solving large constrained
systems. The algorithm is also proven to have the same local
convergence criterion as the Gauss-Seidel method we present
here as long as the displacement size is kept sufﬁciently
small.
The paper by Arechavaleta et al. [35] presents a well
written explanation of using iterative methods (primarily
the Gauss-Seidel technique) for computing fast and accurate
solutions for ill-conditioned LCP problems.
We use the iterative Gauss-Seidel approach presented
by Kenwright [1], however, we store the joint angles as
quaternion-exponent and employ dual-quaternion algebra [9]
for solving forward and inverse kinematic problems. As
unit-quaternions are an ideal tool for orientations of rigid
transforms, however, they do not contain any translation
information about the location of points in 3D space. Hence,
dual-quaternions are an extension of quaternion by means
of dual-number theory as a compact, efﬁcient, and smart
approach of representing both rotation and translation in a
single vector with its own algebraic rules (e.g., calculating

55
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 2.
Articulated Hand Model. The articulated hand model (including
the wrist) was used for the simulations and possessed 22 degrees of freedom
(DOF). The structure comprised of 17 links and 16 joints.
differences, inverting, interpolating). The robotic community
has exploited dual-quaternions to solve IK problems; for
example, Hoang-Lan et al. [36] solved IK problem by
formulating a dual-quaternion metric error measurement for
constructing the Jacobian.
III. ARTICULATED MODEL
The articulated model used for our simulations and evalu-
ation of our approach is shown in Figure 2. The mechanical
functioning is of a human hand and is constructed using a
series of interconnected rigid segments (or links) connected
by joints (also, note, an interconnected series of links is
also called a kinematic chain). As shown in Figure 2, we
represent the hand as a collection of 17 rigid body segments
connected using 16 primary joints. The character’s hand
gives us 22 degrees of freedom (DOF). Joints such as the
wrist have three DOF corresponding to abduction/adduction,
ﬂexion/extension and internal/external rotation (i.e., rotation
around the x, y, and z axis). Where complex joints such as
the ball-and-socket (i.e., with 3 DOF) can be formed from
multiple simpler joints (i.e., 3 single DOF joints). So a joint
with n DOF is equivalent to n joints of 1 DOF connected by
n-1 links of length zero. Thus, for example, the wrist joint
can be described as a sequence of 2 separate joints of 1 DOF,
where 1 of the joints connecting links has a zero length,
as done by Kenwright [1]. Euler angles are an intuitive and
straightforward means of representing orientation, since they
are easy to visualize and enforce upper and lower boundary
limits. However, we store each joint rotation as a quaternion-
exponential (i.e., axis-angle combination), as it offers a sim-
ilarly compact parameterization as Euler angles but without
the gimbals lock problem. We combine the exponential-
mapping with quaternion and dual-quaternion algebra to
solve the IK solution, while clamping angular limits through
a twist-and-swing decomposition of the orientation.
As shown in Figure 2, the single DOF connected joints
were colored in accordance with their axis type; the x, y, and
z representing the colors red, green and blue. The foot was
set as the base for the IK with ﬁve end-effectors (i.e., head,
pelvis, right-hand, left-hand and left-foot). We developed an
application for an artist to interrogate and experiment with
the skeletal IK system; setting end-effectors locations and
viewing the generated poses. Each end-effector has a 6 DOF
constraint applied to it; representing the target position and
orientation. The ideal end-effectors are drawn in red, and
the current end-effectors are drawn in green. This can be
seen clearly in Figure 5, where the target end-effectors are
located at unreachable goals.
IV. MATHEMATICAL BACKGROUND
We give a brief introduction to the essential mathematical
deﬁnitions on quaternion and dual-quaternion algebra. For
a more detailed introduction and an overview of their
practical advantages, see Kenwright [9]. Since quaternions
have proven themselves in many ﬁelds of science and
computing as providing an unambiguous, un-cumbersome,
computationally efﬁcient method of representing rotational
information. We combine dual-number theory to extend
quaternions to dual-quaternions, so we can use them to
represent rigid transforms (i.e., translations and rotations).
A. Deﬁnitions
To reduce ambiguity and make the paper as readable as
possible, we deﬁne variable symbol deﬁnitions:
q quaternion
ˆq unit-quaternion
q dual-quaternion
ˆq unit dual-quaternion
⃗v vector
ˆv unit-vector
(1)
While we mostly represent quaternions and dual-quaternions
with the letter q, there are instances where we use the letter
t to indicate that the dual-quaternion or quaternion is a pure
translation component.
B. Quaternions
The quaternion was introduced by Hamilton [37] in 1860
and has the following form:
q = qs + qxi + qyj + qzk
(qs, qx, qy, qz ∈ R)
(2)
where ii = jj = kk = ijk = −1.
While w is sometimes used to represent the scalar com-
ponent in quaternions, we us the letter s, to avoid ambiguity
with exponential-mapping variable (⃗w). Alternatively, it is
more commonly deﬁned as a pair (s,⃗v) with s ∈ R and
⃗v ∈ R3.
A unit-quaternion has a unit-length with q2
s + q2
x + q2
y +
q2
z = 1 and the inverse of a unit-quaternion is its conjugate

56
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
q∗ = qs − ⃗v. Given an axis and angle of rotation a unit-
quaternion can be calculated using:
qs = cos(θ/2),
qx = nxsin(θ/2)
qy = nysin(θ/2),
qz = nzsin(θ/2)
(3)
where ˆn = nx, ny, nz is a unit-vector representing the axis
of rotation and θ is the angle of rotation. Whereby, given a
point in 3D space ⃗x we can rotate to give ⃗x′ using:
⃗x′ = ˆq⃗xˆq∗
(4)
Addition, subtraction, and the product of two quaternions,
is deﬁned by:
q0 + q1 = (s0 + s1, ⃗v0 + ⃗v1)
q0 − q1 = (s0 − s1, ⃗v0 − ⃗v1)
q0q1 = (s0s1 − ⃗v0 ⃗v1, s0 ⃗v1 + s1 ⃗v0 + ⃗v0 ⃗v1)
(5)
A crucial fact that we exploit in this paper is that the
exponential of a unit-quaternion is the combined axis-angle
component:
exp(ˆq) = [0, ˆnθ]
= [0, ⃗w]
(6)
where ˆn is the unit-vector representing the axis of rotation
and θ is the angle magnitude in radians. The logarithm of a
quaternion is the inverse of the exponential enabling us to
convert to and from the axis-angle component. The expo-
nential of a unit-quaternion is often called the exponential
map, which we denote as ⃗w.
θ = ||⃗w||
ˆv =
⃗w
||⃗w||
(7)
The exponential-map can be computed robustly, even in
the neighborhood of the origin [10].
C. Dual-Numbers
Dual-number theory was introduced by Clifford [38] in
1873 and is deﬁned as:
ˆz = r + ϵd
with ϵ2 = 0 but ϵ ̸= 0
(8)
where r is the real-part, d is the dual-part, and ϵ is the dual
operator. While dual-number theory can be used to represent
different quantities (e.g., dual-vectors), we are primarily
interested in dual-quaternions because it gives us the ability
of unifying rigid transform space into a single state-space
variable (i.e., position and translation).
D. Dual-Quaternions
A dual-quaternion is deﬁned as a dual-number with
quaternion components and has the ability to represent 3D
Euclidean coordinate space (i.e., rotation and translation) as
a single parameter.
q = qr + ϵqd
(9)
where qr and qd are quaternions. Additionally, since the
dual-quaternion consists of two quaternion components it
can be represented as: q = [q0, q1, q2, q3, q4, q5, q6, q7]T . The
common algebraic operations are deﬁned as:
αq = αqr + αϵqd
q0 + q1 = qr0 + qr1 + ϵ(qd0 + qd1)
q0 q1 = qr0qr1 + ϵ(qr0qd1 + qd0qr1)
(10)
The conjugate of a dual-quaternion q∗ = q∗
r + ϵq∗
d with the
norm (or length) of a dual-quaternion given by ||q|| = qq∗
and the unity condition (i.e., for unit dual-quaternions) is:
q q∗ = 1
q∗
rqd + q∗
dqr = 0
(11)
A unit dual-quaternion can be used to represent any rigid
transformation (i.e., position and rotation); we construct a
unit dual-quaternion rigid transformation using:
ˆq = qrot + ϵ1
2qrotqpos
(rotation then translation)
or
ˆq = qrot + ϵ1
2qposqrot
(translation then rotation)
= (1 + ϵ1
2qpos)qrot
(12)
where qrot and qpos are the rotation and translation quater-
nions respectively, with the translation quaternion qpos =
[0, tx, ty, tz].
V. FORWARD AND INVERSE KINEMATICS
Forward and inverse kinematics is the process of cal-
culating positions and orientations either from joint space
(i.e., using interconnected positions and orientations of the
joints) or from Cartesian space (i.e., the world positions and
orientations) as shown in Figure 1.
A. Forward Kinematics (FK)
The FK problem is straightforward to calculate and has
no ambiguity or singularities. For an articulated structure,
we can concatenate the dual-quaternion transforms through
multiplication to generate the ﬁnal positions and orientations
of the interconnected links. For example, a serial chain of n
links would be:
ˆq = ˆq0ˆq1ˆq2...ˆqn−1
(13)
where ˆq0...ˆqn−1 deﬁne each individual joints rotation and
translation.

57
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
B. Inverse Kinematics (IK)
IK is the reverse of FK. While FK remains fast and
simple for large interconnected structures, IK solutions can
be computationally expensive, possess singularity problems
and contain multiple solutions. However, in practice, we
attempt to ﬁnd a best ﬁt approximation that will meet the
desired constraints. For example, in Equation (13), we know
ˆq and would seek to ﬁnd the orientation (and/or translation)
for each link (ˆq0..ˆqn−1), and ˆq is the position and orientation
of the combined links (i.e., for the end-effector).
C. Pure Rotation and Pure Translation
A dual-quaternion’s transformation can be represented by
two pure dual-quaternions, i.e., a pure rotation and pure
translation:
ˆqtra = 1 + ϵ1
2 ˆqpos
(pure translation)
ˆqrot = ˆqrot + ϵˆ0
(pure rotation)
(14)
where we concatenate the pure dual-quaternion transforms
by multiplication to calculate the combined set of trans-
forms, as shown in Equation (12); however, be warned the
order of multiplication determines if translation or rotation is
performed ﬁrst. For example, we represent the FK problem
as:
ˆq = ˆq0ˆq1ˆq2...ˆqn−1
= (ˆqt
0ˆqr
0)(ˆqt
1ˆqr
1)(ˆqt
2ˆqr
2)...(ˆqt
n−1ˆqr
n−1)
(15)
where the superscript letter r and t indicates a pure rotation
or pure translation dual-quaternion transform respectively (as
deﬁned in Equation (14) ).
VI. JACOBIAN MATRIX
The Jacobian J is a matrix that represents the change
in joint orientations to displacement of end-effectors. Each
frame we calculate the Jacobian matrix from the current
angles and end-effectors. We assume a right-handed coor-
dinate system. To illustrate how we calculate the Jacobian
for an articulated system, we consider the simple example
shown in Figure 3. For a more detailed description see
[17, 5, 18, 19, 20, 15]. The example demonstrates how we
decompose the problem and represent it as a matrix for a sole
linked chain with a single three DOF end-effector. We then
extend this method to multiple linked-chains with multiple
end-effectors (each with six DOF) to represent the character
hierarchy.
Each joint is stored as an axis-angle component (w = ˆnθ):
w =


⃗w0
⃗w1
⃗w2
...
⃗wn


(16)
where ⃗wi is the rotation (i.e., axis-angle) of joint i relative to
joint i−1, and e for the end-effectors global position. From
these matrices, we can determine that the end-effectors,
and the joint angles are related. This leads to the forward
kinematics deﬁnition, deﬁned as:
e =


ex
ey
ez


(17)
The
end-effectors
and
the
joint
orientation
(i.e.,
quaternion-exponent) are related and is deﬁned by:
e = f( w )
(18)
We can differentiate the kinematic equation for the rela-
tionship between end-effectors and joint orientation. This
relationship between a change in joint orientation and a
change in end-effectors location is represented by the Ja-
cobian matrix and is given by:
˙e = J ˙w
(19)
The Jacobian J is the partial derivatives for the change in
end-effectors locations by change in joint angles.
J = ∂e
∂w
(20)
If we re-arrange the kinematic problem:
w = f −1(e)
(21)
We can conclude a similar relationship for the Jacobian:
˙w = J−1 ˙e
(22)
For small changes, we can approximate the differentials
by their equivalent deltas:
∆e = etarget − ecurrent
(23)
Figure 3.
Forward & Inverse Kinematics Example. Illustrating the rela-
tionship between the different parameters, e.g., end-effector error and joint
orientations. ⃗w quaternion exponential-map for each joint (i.e., axis-angle
combination ⃗w = ˆnθ).

58
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 4.
A simple three link serial chain example, where ⃗w is the axis-
angle combination (i.e., quaternion- exponential-map), ⃗t is the translation
vector, ˆn is the unit-length axis of rotation, and θ is the angle. For a simple
2D case (i.e., only in the x-y axis) the axis of rotation is ˆn = [0, 0, 1]..
For these small changes, we can then use the Jacobian to
represent an approximate relationship between the changes
of the end-effectors with the changes of the joint angles.
∆w = J−1∆e
(24)
We can substitute the result back in:
wcurrent = wprevious + ∆w
(25)
For a step-by-step explanation of the process of calculat-
ing the Jacobian for the quaternion-exponent see Appendix
B-B. For example, calculating the Jacobian for Figure 4
gives:
J =


∂e
∂w0
∂e
∂w1
∂e
∂w2


and
e = ecurrent − etarget
(26)
The Jacobian matrix is calculated for the system so that
we can calculate the inverse and hence the solution. Alterna-
tively, a good explanation of the Jacobian and its applications
is also presented by Buss [15], who gives an introduction
to IK methods using the Transpose, Pseudoinverse, and
Damped Least-Square method.
VII. GAUSS-SEIDEL ALGORITHM
We set up the IK problem into a particular arrangement,
so that we can solve for the unknowns using the Gauss-
Seidel method. Whereby, we construct the IK formulation
using the Jacobian matrix with the linear equation format of
the form:
Linear Equation:
Ax = b
(27)
The IK problem is then composed as:
JT J∆q = JT ∆e
(28)
Equating equivalent variables:
A = JT J
b = JT ∆e
x = ∆q = unknown
(29)
A. Damping and Stability
1) Damping: With the Gauss-Seidel iterative method, we
solve for the unknown x value. To prevent singularities
and make the ﬁnal method more stable and robust we
incorporated a damping value:
A = (JT J + δI)
(30)
where δ is a damping constant (e.g., ∼0.0001), and I is an
identity matrix.
2) Singularities: The exponential-map of a quaternion
(i.e., the axis-angle combination) is parameterized in ∈ R3
and hence contains singularities similar to Euler angles
possessing gimbals lock singularities. However, for our IK
iterative situation, we take small incremental steps (i.e.,
angular change is less than π) we can avoid the singularity
problem, since we can shift the exponential-map singularity
away from the safe working region [10]. The exponenential-
map has singularities at a radius of 2nπ (for n = 1, 2, 3..).
Hence, if the exponential-map angle ||⃗w|| is close to π we
replace ⃗w by (1 − 2π/||⃗w||)⃗w, which is the same rotation
but shifted away from the singularity problem.
B. Gauss-Seidel Implementation
The Gauss-Seidel iterative algorithm is a technique de-
veloped for solving a set of linear equations of the form
Ax = b. The method has gained a great deal of acclaim
in the physics-based community for providing a computa-
tionally fast robust method for solving multiple constraint
rigid body problems [39, 40, 41]. The iterative algorithm is
based on matrix splitting [42], and its computational cost
per iteration is O(n), where n is the number of constraints.
Furthermore, the number of constraints and the number
of iterations is what dominates the performance of the
algorithm. Algorithm 1 is the basic Gauss-Seidel method for
a generic linear system of equations of the form Ax = b; for
the unknowns, an initial guess is needed. Naively this value
could be zero and result in the system having a cold start.
Then the algorithm would proceed, while at each iteration,
the corresponding elements from A, b and x (current) act as
a feedback term to move x (next) closer to the solution.

59
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Algorithm 1 Gauss-Seidel iterative algorithm to solve Ax =
b given x0
1: x = x0
2: for iter=1 to iteration limit do
3:
for i=1 to n do
4:
∆xi =
"
bi−
n
P
j=1
Aijxj
#
Aii
5:
xi = xi + ∆xi
6:
end for
7: end for
The conditions for the Gauss-Seidel iterative Algorithm 1
terminating are:
• If a maximum number of iterations has been reached
• If the error ||Ax−b|| drops below a minimum threshold
• If ||∆xi|| falls below a tolerance
• If ||∆xi|| remains the same as the previous frame
(within some tolerance)
It is essential that the coefﬁcients along the diagonal part
of the matrix be dominant for the Gauss-Seidel method to
converge on a solution.
C. Angular Limits - Twist-and-Swing
Any practical character-based IK system needs to have
the ability to enforce angular joint limits before it can
be considered a viable real-world solution. We incorporate
angular joint limits into the simple iterative algorithm by
clamping the modiﬁed angle orientations at each iteration
update (see Equation (31)). While this can be accomplished
easily with Euler angles by setting a minimum and max-
imum angle. For the exponential-map (i.e., the axis-angle
combination) parameterization, we use the twist-and-swing
decomposition [10], since it presented a fast, robust, and
simple technique for robustly calculating angular errors
and enforcing limits (as demonstrated and shown by Kall-
mann [43]).
w =



lower
: if (w + J−1∆e) < lower
upper
: if (w + J−1∆e) > upper
w + J−1∆e : otherwise
(31)
For complex joint models, such as the ball-and-socket
joint, the twist-and-swing decomposition presents a practical
and intuitive representation. The twist-and-swing allows us
to deﬁne and enforce joint limits intuitively. The twist is
around the ‘x-axis’ while the swing is around the ‘yz-plane’.
We can decompose a quaternion orientation into its twist and
swing components shown in Equation 32. This is in world
space but can easily be converted to local space (e.g., joint
space).
qtwistx =
 
qs
p
q2s + q2x
,
qx
p
q2s + q2x
, 0, 0
!
qswingyz =
 
p
q2s + q2x, 0, qsqy − qxqz
p
q2s + q2x
, qsqz + qxqy
p
q2s + q2x
!
q = qswingyzqtwistx
(32)
qtwisty =


qs
q
q2s + q2y
, 0,
qy
q
q2s + q2y
, 0


qswingxz =


q
q2s + q2y, 0, qsqx + qyqz
q
q2s + q2y
, qsqz − qxqy
q
q2s + q2y


q = qswingxzqtwisty
(33)
qtwistz =
 
qs
p
q2s + q2z
, 0, 0,
qz
p
q2s + q2z
!
qswingxy =
 
p
q2s + q2z, 0, qsqx − qyqz
p
q2s + q2z
, qsqy − qxqz
p
q2s + q2z
!
q = qswingxzqtwisty
(34)
where qx, qy, and qz are the rotations around the x-, y-
, and z-axis respectively, and qxy, qxz, and qyz are the
rotations a vector in the xy-, xz-, and yz-plane respectively
(see Appendix A for proof). We can validate the twist-
and-swing decomposition by multiplying them together and
reconstructing the original quaternion.
This extension of the basic Gauss-Seidel algorithm to
handle constraint limits for the unknowns is called the
Projected Gauss-Seidel (PGS) algorithm. The angular limits
form bounds that are in form of upper and lower joint angles
that are easily enforced through clamping. Furthermore, the
PGS algorithm has O(n) running time and convergence is
guaranteed as long as the matrix is positive deﬁnite [8]. In
practice, we have found the algorithm to provide promising
visual and numerical results.
VIII. SPATIAL AND TEMPORAL COHERENCY
We give the iterative solver a warm-start approximation
at the start of each iteration update by taking advantage of
spatial and temporal coherency of the problem. Since the
PGS solver is iterative by design and without a warm-start
approximation, its convergence rate can be very slow (i.e.,
depending upon the eigenvalues of the matrix it is solving).
However, by caching the result between updates (i.e., use
previous solution as the start for the next update), we can
considerably reduce the number of iterations, especially for
cases when there are only minuscule changes for the system.

60
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 5.
Simulation Screenshots A. Experimental poses for our articu-
lated hand.
IX. EXPERIMENTAL RESULTS
On average, the small spatial coherent transitions between
frame updates resulted in the Gauss-Seidel method requiring
only two or three iterations for the end-effectors to reach
acceptable answers. This resulted in the IK solver being
able to easily maintain a low-computational overhead and
run at real-time frame-rates. While our Gauss-Seidel im-
plementation was straightforward it was implemented in a
single threaded program and did not exploit any parallel
architecture speed ups (e.g., using a multi-core CPU or
GPU); however, numerous methods were demonstrated by
Courtecuisse et al. [44] for exploiting multi-core archi-
tectures to achieve much improved performance using the
Gauss-Seidel algorithm.
The performance of our iterative Gauss-Seidel IK im-
plementation was computationally fast and ran at real-time
frame-rates enabling the IK problem to be modiﬁed on the
ﬂy. For cases when little or no movement occurred the solver
would perform 1 to 2 iterations at most, while for sporadic
changes in the articulated posture resulted in approx. 10
or more iterations. Furthermore, our Gauss-Seidel method
would only require a few milliseconds to compute the
solution. However, the cost of calculating the IK solution can
vary greatly depending upon the starting assumption. Our
implementation performed at real-time rates and maintained
a consistent frame-rate well above a 100Hz. Simulations
were performed on a machine with the following speci-
ﬁcations: Windows7 64-bit, 16Gb Memory, Intel i7-2600
3.4Ghz CPU. Compiled and tested with Visual Studio 2012.
One important criteria was that the IK solver remained
stable, e.g., when the end-effectors are placed out of reach,
so that no solution exists. In practice, when no result was
obtainable, a best reach condition was always presented,
stretching to obtain the end-effectors but remaining stable
(i.e., not oscillating or jittering). Furthermore, when end-
effectors were started at radically different locations, the
resulting solution would haphazardly jerk; however, the
result always converged on acceptable poses.
We experimented with a diverse range of poses of gener-
Figure 6.
Simulation Screenshots B. Experimental poses for our articu-
lated hand.
ally unpredictable and chaotic ﬁnger movement to explore
the stability and ﬂexibility of our approach. For example, we
did random on the spot compositions of the hand opening,
closing, stretching, and so on, and always converged on
a solution. It should be pointed out that the hand has
less problems with angular limits and singularity conditions
compared to a full body articulated structure. However,
the hand has enough degrees of freedom and ﬂexibility to
perform a suitably detailed set of tests.
X. LIMITATIONS
We did not include any inter-link collision detection so it
was possible for ﬁngers to pass through one another. During
situations when joints were against their angular limits, it
would take longer for the iterative IK solver to converge on
a solution, since joints that could not move further would be
constantly pushed back. Finally, we did not weight or couple
any of the angular joints; hence, the ﬁnal pose could look
uncomfortable and unnatural while still being physically-
plausible. For example, in a real-world human hand, if the
index ﬁnger is pulled downwards towards the wrist, it should

61
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
affect its neighboring ﬁngers.
XI. CONCLUSION AND DISCUSSION
We presented the Gauss-Seidel technique as a method for
solving real-time articulated IK problems with quaternion-
exponential maps and dual-quaternions. We used temporal
caching to reduce the computational cost and gain real-time
performance speeds. The results of the IK system performed
well enough to be used in time critical systems (such as
games). With the angular limits, the method can suffer from
singularity problems if the end-effectors jump; however,
due to the end-effectors following small spatial transitions
singularities are mostly avoided. All in all, the algorithm
is simple to implement, computationally fast, little memory
overhead, and is fairly robust. The IK solution can work
with multiple end-effectors to produce poses with smooth
movement with and without constraints.
While we demonstrated the practical aspect of using the
Gauss-Seidel method as a valid real-time method for a
articulated IK system, further work still needs to be done
for a more detailed statistical comparison between the afore-
mentioned IK solutions; comparing memory, complexity and
computational costs.
A further area of study would be combining the IK solver
with a physics-based system (i.e., rigid body constraint
solver) and explore object interaction (e.g., picking up a
ball or a pencil). Furthermore, to enable greater simulation
speeds, the possible investigation and exploration of making
the solver more parallel, for example, Poulsen [45] demon-
strated a Parallel Projected Gauss-Seidel Method.
This paper exploited the Gauss-Seidel iterative method in
conjunction with a set of highly non-linear equations to solve
an inverse kinematic problem for an articulated structure.
While we demonstrated the practical viability of the Gauss-
Seidel method with exponential-maps, we did not implement
and compare our approach with the many different numerical
techniques(e.g., Newton or Broyden approach) and is an area
of further investigation.
ACKNOWLEDGMENT
The authors would like to thank the reviewers for taking
time out of their busy schedules to provide valuable, helpful,
and insightful feedback that has contributed towards making
this better paper more clear, concise, and correct.
REFERENCES
[1] B. Kenwright, “Real-time character inverse kinematics
using the gauss-seidel iterative approximation method,”
CONTENT 2012, The Fourth International Conference
on Creative Content Technologies, pp. 63–68, 2012. 1,
2, 3
[2] B. Kenwright, “Synthesizing balancing character mo-
tions,” Workshop on Virtual Reality Interaction and
Figure 7.
Simulation Screenshots C. Experimental poses for our articu-
lated hand.
Physical Simulation VRIPHYS 2012, pp. 87–96, 2012.
1
[3] C. Welman, Inverse kinematics and geometric con-
straints for articulated ﬁgure manipulation. PhD thesis,
1993. 1, 2
[4] L. Unzueta, M. Peinado, R. Boulic, and A. Suescun,
“Full-body performance animation with Sequential In-
verse Kinematics,” Graphical Models, vol. 70, pp. 87–
104, Sept. 2008. 1, 2
[5] W. Wolovich and H. Elliott, “A computational tech-
nique for inverse kinematics,” in The 23rd IEEE
Conference on, Decision and Control, 1984, vol. 23,
pp. 1359–1363, IEEE, 1984. 1, 2, 5
[6] R. Kulpa and F. Multon, “Fast inverse kinematics
and kinetics solver for human-like ﬁgures,” IEEE Hu-
manoid Robots, vol. December, no. 5, pp. 38–43, 2005.
1, 2
[7] J. Zhao and N. Badler, “Inverse kinematics positioning
using nonlinear programming for highly articulated ﬁg-
ures,” ACM Transactions on Graphics (TOG), vol. 13,
no. 4, pp. 313–336, 1994. 1, 2
[8] W. R. Cottle, J.-S. Pang, and E. R. Stone, The Linear
Complementarity Problem. Academic Press, 1992. 1,

62
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
7
[9] B. Kenwright, “A beginners guide to dual-quaternions:
What they are, how they work, and how to use them for
3d character hierarchies,” pp. 1–13, 2012. WSCG 2012
Communication Proceedings, Conference June. 2012.
1, 2, 3
[10] F. S. Grassia, “Practical parameterization of rotations
using the exponential map,” J. Graph. Tools, vol. 3,
pp. 29–48, Mar. 1998. 1, 4, 6, 7
[11] M. Girard and A. Maciejewski, “Computational mod-
eling for the computer animation of legged ﬁgures,”
in ACM SIGGRAPH Computer Graphics, vol. 19,
pp. 263–270, ACM, 1985. 2
[12] B. Rose, S. Rosenthal, and J. Pella, “The process of
motion capture: Dealing with the data,” in Computer
Animation and Simulation, vol. 97, pp. 1–14, Citeseer,
1997. 2
[13] K. Yamane and Y. Nakamura, “Natural motion anima-
tion through constraining and deconstraining at will,”
IEEE Transactions on Visualization and Computer
Graphics, vol. 9, pp. 352–360, July 2003. 2
[14] L. Zhao, “Gesticulation behaviors for virtual humans,”
Paciﬁc Graphics ’98. Sixth Paciﬁc Conference on Com-
puter Graphics and Applications, pp. 161–168, 1998.
2
[15] S. R. Buss and J.-S. Kim, “Selectively damped least
squares for inverse kinematics,” Journal of Graphics
Tools, vol. 10, pp. 37–49, 2004. 2, 5, 6
[16] R. Fletcher, Practical methods of optimization, Volume
1. Wiley, 1987. 2
[17] A. Balestrino, G. D. Maria, and L. Sciavicco, “Robust
control of robotic manipulators,” Proc. Of the 9th IFAC
World Congress, vol. 5, pp. 2435–2440, 1984. 2, 5
[18] J. Baillieul, “Kinematic programming alternatives for
redundant manipulators,” in Robotics and Automation.
Proceedings. 1985 IEEE International Conference on,
vol. 2, pp. 722–728, IEEE, 1985. 2, 5
[19] C. Wampler, “Manipulator inverse kinematic solutions
based on vector formulations and damped least-squares
methods,” Systems, Man and Cybernetics, IEEE Trans-
actions on, vol. 16, pp. 93–101, Jan. 1986. 2, 5
[20] Y. Nakamura and H. Hanafusa, “Inverse kinematic
solutions with singularity robustness for robot manip-
ulator control,” Journal of Dynamic Systems, Measure-
ment, and Control, vol. 108, no. 3, pp. 163–171, 1986.
2, 5
[21] J. Lander, “Making kine more ﬂexible,” Game Devel-
oper Magazine, no. November, 1998. 2
[22] L. Wang, “A combined optimization method for solv-
ing the inverse kinematics problems of mechanical
manipulators,” Robotics and Automation, IEEE, vol. 1,
no. 4, 1991. 2
[23] R. Boulic, J. Varona, L. Unzueta, M. Peinado, A. Sues-
cun, and F. Perales, “Evaluation of on-line analytic
and numeric inverse kinematics approaches driven by
partial vision input,” Virtual Reality, vol. 10, pp. 48–61,
Apr. 2006. 2
[24] N. Courty and E. Arnaud, “Inverse kinematics using
sequential monte carlo methods,” Articulated Motion
and Deformable Objects, pp. 1–10, 2008. 2
[25] C. Hecker, B. Raabe, R. W. Enslow, J. DeWeese,
J. Maynard, and K. van Prooijen, “Real-time motion re-
targeting to highly varied user-created morphologies,”
ACM Transactions on Graphics, vol. 27, p. 1, Aug.
2008. 2
[26] K. Grochow, S. Martin, A. Hertzmann, and Z. Popovi´c,
“Style-based inverse kinematics,” in ACM Transactions
on Graphics (TOG), vol. 23, pp. 522–531, ACM, 2004.
2
[27] R. Sumner, M. Zwicker, C. Gotsman, and J. Popovi´c,
“Mesh-based inverse kinematics,” in ACM Transac-
tions on Graphics (TOG), vol. 24, pp. 488–495, ACM,
2005. 2
[28] K. Der, R. Sumner, and J. Popovi´c, “Inverse kinematics
for reduced deformable models,” in ACM Transactions
on Graphics (TOG), vol. 25, pp. 1174–1179, ACM,
2006. 2
[29] J. Brown, J. Latombe, and K. Montgomery, “Real-time
knot-tying simulation,” The Visual Computer, vol. 20,
no. 2, pp. 165–179, 2004. 2
[30] A. Aristidou and J. Lasenby, “FABRIK: A fast, iterative
solver for the Inverse Kinematics problem,” Graphical
Models, vol. 73, pp. 243–260, Sept. 2011. 2
[31] R. Mukundan, “A robust inverse kinematics algorithm
for animating a joint chain,” International Journal of
Computer Applications in Technology, vol. 34, no. 4,
p. 303, 2009. 2
[32] R. Muller-Cajar and R. Mukundan, “Triangualation-
a new algorithm for inverse kinematics,” Proc. of the
Image and Vision Computing New Zealand, pp. 181–
186, 2007. 2
[33] W. Tang, M. Cavazza, and D. Mountain, “A con-
strained inverse kinematics technique for real-time mo-
tion capture animation,” The Visual Computer, vol. 15,
pp. 413–425, Nov. 1999. 2
[34] L. Verlet, “Computer experiments on classical ﬂu-
ids. I. Thermodynamical properties of Lennard-Jones
molecules,” Physical Review, vol. 159, no. 1, pp. 98–
103, 1967. 2
[35] G. Arechavaleta, E. Lopez-Damian, and J. Morales,
“On the use of iterative lcp solvers for dry frictional
contacts in grasping,” in Advanced Robotics, 2009.
ICAR 2009. International Conference on, pp. 1–6,
June. 2
[36] H.-L. Pham, V. Perdereau, B. V. Adorno, and P. Fraisse,
“Position and orientation control of robot manipulators
using dual quaternion feedback,” in IROS, pp. 658–663,
2010. 3

63
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[37] W. R. Hamilton, “Elements of quaternions,” Reprinted
by Chelsea Pub, New York in 1969, 1860. 3
[38] Clifford, “Preliminary sketch of biquaternions,” In
Oxford Journals, Proceedings London Mathematical
Society, 1-4,, pp. 381–395, 1873. 4
[39] F. Jourdan, P. Alart, and M. Jean, “A Gauss-Seidel like
algorithm to solve frictional contact problems,” Com-
puter Methods in Applied Mechanics and Engineering,
vol. 155, pp. 31–47, Mar. 1998. 6
[40] T.
Liu
and
M.
Wang,
“Computation
of
three-
dimensional rigid-body dynamics with multiple uni-
lateral contacts using time-stepping and gauss-seidel
methods,” Automation Science and Engineering, IEEE
Transactions on, vol. 2, no. 1, pp. 19–31, 2005. 6
[41] E. Catto, “Iterative dynamics with temporal coher-
ence,” in Game Developer Conference, pp. 1–24, 2005.
6
[42] H. G. Gene and F. V. L. Charles, Matrix Computations.
The Johns Hopkins University Press, 3rd editio ed.,
1996. 6
[43] M. Kallmann, “Analytical inverse kinematics with body
posture control,” Computer Animation and Virtual
Worlds, vol. 19, pp. 71–91, May 2008. 7
[44] H. Courtecuisse and J. Allard, “Parallel Dense Gauss-
Seidel Algorithm on Many-Core Processors,” 2009
11th IEEE International Conference on High Per-
formance Computing and Communications, no. 1,
pp. 139–147, 2009. 8
[45] M. Poulsen, “Parallel projected gauss-seidel method,”
Master’s thesis, University of Copenhagen, 2010. 9
[46] M. Bartelink, “Global inverse kinematics solver for
linked mechanisms under joint limits and contacts,”
Master’s thesis, Universiteit Utrecht (European Design
Centre), 2012. 12
APPENDIX A.
PROOF OF TWIST-AND-SWING DECOMPOSITION
EQUATION
We show through quaternion algebra the mathematical
proof for Equation 32, which can similarly be applied to
Equation (33) and Equation (34), and how a 3D unit-
quaternion can be decomposed into two parts: the twist and
swing components. We start with a unit-quaternion rotation
shown in Equation 35.
q = (qs, qx, qy, qz)
(35)
where is the vector component, and is the scalar component.
We can calculate a quaternion from an axis-angle using
Equation 36.
qs = cxyz = cos
θ
2

qx = sx = vx sin
θ
2

qy = sy = vy sin
θ
2

qz = sz = vz sin
θ
2

(36)
where v is a unit-vector representing the axis of rotation, and
is the angle of rotation. Hence, we can say since the twist
is only around the x-axis we can deduce that the yz-axis
components will be zero and give us Equation 37.
qtwist = qx = (cx, sx, 0, 0)
(37)
Furthermore, we can also deduce that the swing x-axis
component will be zero in the resulting quaternion as shown
in Equation 38.
qswing = qyz = (cyz, 0, sy, sz)
(38)
where c and s represent the scalar cos and sin component
of the half angles (i.e., see Equation 36). A unit-quaternion
must obey Equation 39.
q2
s + q2
x + q2
y + q2
z = 1
(39)
Hence, from Equation 37 and Equation 38 we can derive
Equation 40.
c2
x + s2
x = 1
c2
yz + s2
y + s2
z = 1
(40)
Subsequently, if we multiply the individual twist and
swing quaternions together we can reconstruct the original
quaternion as shown in Equation 41.
qxyz = qyzqx
= (cyz, 0, sy, sz)(cx, sx, 0, 0)
= ((cxcyz), (sxcyz), (cxsy + sxsz), (cxsz − sxsy))
(41)
Hence, from Equation 37 and knowing the vector sum of
the two non-zero components from Equation 41 sums up to
one, we can derive qtwist, as shown in Equation 42.
qtwist = q2
s + q2
x
= (cxcyz)2 + (sxcyz)2
= c2
yz(c2
x + s2
x)
(knowing,
cos2 + sin2 = 1)
= c2
yz
(42)

64
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Therefore, we have Equation 43.
cyz =
p
q2s + q2x
(43)
We can multiply Equation 41 by the inverse of Equa-
tion 43 to remove the quaternion swing component and leave
the quaternion twist part (shown in Equation 44).
qtwist = qx
= (cx, sx, 0, 0)
= ((cxcyz), (sxcyz), 0, 0) 1
cyz
= (qs, qx, 0, 0)
1
p
q2s + q2x
(44)
We extract the swing component by multiply the quater-
nion by the inverted (conjugated) twist quaternion (shown
in Equation 45).
qswing = qxyzq∗
twist
= (qs, qx, qy, qz)(qs, −qx, 0, 0)
1
p
q2s + q2x
= (cyz, 0, sy, sz)
= ((q2
s + q2
x), 0, (qsqy − qxqz), (qsqz + qxqy))
1
p
q2s + q2x
(45)
Whereby, Equation 44 and Equation 45 sums-up our
algebraic proof. Similarly the twist-and-swing can be proved
for the y-, and z-axis (as shown in Equation (33) and
Equation (34)).
APPENDIX B.
CALCULATING THE JACOBIAN
The joint-space and Cartesian space are the two state
space variables for the kinematic system (shown in Figure
1). The Jacobian matrix relates the changes in joint angles
θ with change in position or orientation X of some point on
the connected hierarchy of links (i.e., Cartesian space) and
is deﬁned as:
J = ∂X
∂θ
(46)
A. Finite-Difference Method
The ﬁnite-difference method is an approximation tech-
nique given by Equation (47). The error is proportional to
the δ step and is limited by numerical accuracy (e.g., a 32-bit
ﬂoating point) and the computational speed of the system.
The method is idea for situations where it is difﬁcult or
impossible to ﬁnd an analytical solution for the kinematic
system due to its complexity and size. However, the method
is a good solution for estimating an approximate Jacobian
solution.
dy
dx ≈ y(x + δ) − y(x)
δ
(47)
The ﬁnite-difference implementation for calculating an
approximate Jacobian is given in Algorithm 2.
Algorithm 2 Finite-Different Method for Approximating the
Jacobian
p = f(q)
for n = 0 to n − 1 do
pδ = f(q + enδ)
Jn = pδ−p
δ
end for
return J
B. Analytical Formulation of the Jacobian using Dual-
Quaternions and Quaternion Exponentials
As
step-by-step
derivation
of
the
Jacobian
Dual-
quaternion to Quaternion Exponential Mapping from the
work by Bartelink [46] is presented below in Figure 8.

65
International Journal on Advances in Intelligent Systems, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/intelligent_systems/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 8.
Step-by-Step Formulation of Dual-Quaternion and Quaternion Exponential Jacobian.

