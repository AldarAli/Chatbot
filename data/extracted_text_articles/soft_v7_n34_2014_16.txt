632
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Automated Feature Construction for Classiﬁcation
of Time Ordered Data Sequences
Michael Schaidnagel, Thomas Connolly
School of Computing
University of the West of Scotland
Email: B00260359@studentmail.uws.ac.uk
Thomas.Connolly@uws.ac.uk
Fritz Laux
Faculty of Computer Science
Reutlingen University
Email: fritz.laux@reutlingen-university.de
Abstract—The recent years and especially the Internet have
changed the ways in which data is stored. It is now common to
store data in the form of transactions, together with its creation
time-stamp. These transactions can often be attributed to logical
units, e.g., all transactions that belong to one customer. These
groups, we refer to them as data sequences, have a more complex
structure than tuple-based data. This makes it more difﬁcult to
ﬁnd discriminatory patterns for classiﬁcation purposes. However,
the complex structure potentially enables us to track behaviour
and its change over the course of time. This is quite interesting,
especially in the e-commerce area, in which classiﬁcation of a
sequence of customer actions is still a challenging task for data
miners. However, before standard algorithms such as Decision
Trees, Neural Nets, Naive Bayes or Bayesian Belief Networks
can be applied on sequential data, preparations are required in
order to capture the information stored within the sequences.
Therefore, this work presents a systematic approach on how
to reveal sequence patterns among data and how to construct
powerful features out of the primitive sequence attributes. This
is achieved by sequence aggregation and the incorporation of
time dimension into the feature construction step. The proposed
algorithm is described in detail and applied on a real-life data
set, which demonstrates the ability of the proposed algorithm to
boost the classiﬁcation performance of well-known data mining
algorithms for binary classiﬁcation tasks.
Index Terms—feature construction, sequential data, temporal
data mining
I. INTRODUCTION
This work extends our previous work in the ﬁeld of feature
construction reported in [1]. It presents new feature construc-
tion techniques as well as new experimental results.
Signiﬁcant amounts of data are being generated on a
daily basis, in almost every industry and scientiﬁc research
area. Advancements in computer science as well as computer
hardware enable us to store these data. The rate of growth
of data surpasses the capability of analysing all the stored
data. It is believed that less than 10 % of all data stored
is retrieved or analysed [2]. Particularly in the e-commerce
area it is common to log all user activities in an online
shop. Such data can be ordered by their timestamp and can
be allocated to data sequences of particular users. However,
the logged activities or actions are not stored in a form that
enables immediate data mining. Therefore, it is important to
pre-process the data before analyzing it (see also [3] [4]).
When data is only represented by primitive attributes and
there is no prior domain expert knowledge available, the pre-
processing task becomes challenging and creates the need
for automated techniques. At this point attribute selection
and/or feature construction techniques need to be applied.
Attribute selection can be deﬁned as the task of selecting a
subset of attributes, which are able to perform at least as
good on a given data mining task as the original attributes
set. The original values of the data set are called attributes,
while the constructed data are called features. It is possible
that primitive attributes are not able to adequately describe
eventually existing relations among primitive attributes. Such
interrelations (or also called interactions [6]) can occur in a
data set if the relation between one attribute and the target
concept depends on another attribute (see also [7]).
A. Structure of the paper
The remainder of this section will provide a short intro-
duction into the related ﬁelds of Feature Construction and
Sequential Data Mining. It will also present the problem at
hand. Section II will provide a short overview about the related
research ﬁelds and brieﬂy introduces well-known Feature
Construction techniques. Subsection II-C will highlight our
contribution to the particular research ﬁeld of sequential data
classiﬁcation. The characteristics of such data are described
in Section III. Our approach to sequential feature construction
will be described in detail in Section IV. This is followed by an
experimental analysis in Section V, in which we demonstrate
the ability of our proposed algorithm to boost classiﬁcation
performance on a real-life data set. The paper then provides
some conclusion (Section VI) and future work (Section VII).
B. Feature Construction
Attribute selection alone can fail to ﬁnd existing interaction
among data. Therefore, one goal for feature construction is
to ﬁnd and highlight interactions. Feature construction can be
deﬁned as the process of creating new compound properties
using functional expressions on the primitive attributes. There
are also the terms Attribute Construction (Han and Kamber
[3]) and Feature Extraction (Guyon et al. [9]) used in the
literature to denote this research area. Guyon et al. are more
focused on the Feature Selection task and uses the term Feature

633
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Extraction as a compound term to denote both Feature Con-
struction and Feature Selection tasks. This work will continue
to use the term Feature Construction. Feature Construction
is part of the data preparation step within the KDD process.
There are two groups of data preparation techniques: one
contains techniques that do not alter the space dimensionality
of the given data, such as signal enhancement, normalization
and standardization. The other group reduces or enlarges
the feature space. Examples for this group are non-linear
expansions, feature discretization [9]. Feature Construction
can ﬁt into both groups, depending on the goals of the data
preparation step. Another goal of Feature Construction is to
reduce the data dimension by removing redundant or irrelevant
attributes [7]. This is done by constructing new features out
of several of the given attributes to help the mining process
[3]. In this case the constructed feature replaces the attributes
it was constructed from [7]. However, it is important to not
discard important information, which is necessary to describe
the target hypothesis. If done correctly, Feature Construction
is the key data preparation step to build classiﬁers that are able
to describe complex patterns. The positive impact of feature
construction was also shown in a comparative study focusing
on predictive accuracy [7]. Liu and Motoda deﬁne Feature
Construction as the process ’that discovers missing informa-
tion about the relationships between features and augments the
space of features by inferring or creating additional features’
[4]. This means that the original representation of data is
altered and the feature space is extended by the new features.
Usually, logical operators are used to combine features. A
simple example for a Feature Construction technique on a
two dimensional problem is the following: assume that A1
is the width and A2 is the length of a rectangle. This can be
transformed into a one-dimensional problem by creating the
feature F1 as area F1 = A1 ∗ A2 [4]. However, the success
of feature construction is dependent on the goal of the Data
Mining problem at hand. There is no use in calculating the area
as a feature; if the pattern (that can be used for discrimination
between the two given labels) is connected to the aspect ratio
of the rectangles. Shafti and P´erez distinguish between two
types of features construction techniques in terms of their
construction strategy:
• hypothesis-driven: create features based on a hypothesis
(which is expressed as a set of rules). These features are
then added to the original data set and are used for the
next iteration, in which a new hypothesis will be tested.
This process continues until a termination requirement is
satisﬁed.
• data-driven methods: create features based on prede-
termined functional expressions, which are applied on
combinations of primitive features of a data set. These
strategies are normally non-iterative and the new features
are evaluated by directly assessing the data.
The transformation of the feature space is a standard procedure
in Data Mining, since it may improve the recognition process
of classiﬁers. In general the transformation function is denoted
as y = F(x). It is used to transform an n-dimensional
original pattern x, that exists as a vector of the n-dimensional
pattern space, into an m-dimensional pattern y [10]. Finding
a good transformation function is very domain speciﬁc and
also depends on the available measurements [9]. After the
transformation, data objects are represented as feature vectors
in the expanded and augmented feature space. This effectively
pulls apart examples of the same class, so that it is easier
for the classiﬁer to distinguish them [12]. However, Feature
Construction must be used with some precautions: if a new
classiﬁcation problem is presented, it is not obvious, which
of the various data representations should be used. It is also
possible that none of the constructed features are able to
express the target concept sufﬁciently. This can be the case in
many real-life scenarios and it needs to be dealt with by using
domain-speciﬁc knowledge. Feature Construction techniques
are mostly based on a ﬁxed set of basic operators. There
is no easy way to alter the existing constructor set. This
is also a disadvantage if the classiﬁcation problem requires
a combination of several construction functions to ﬁnd a
discriminatory form of data representation [11]. Some feature
construction techniques only use Boolean representations of
features, which cover only part of the potential relations
between data attributes. Markovitch and Rosenstein [11] also
points out that the basic Boolean operators such as AND and
OR are already inherently represented in the structure of a
decision tree.
C. Sequential Data Mining
Feature Construction prepares the data before the actual
mining is done. This can be difﬁcult, if the data has a complex
structure, such as sequences. Therefore, this section brieﬂy
introduces the rather young research ﬁeld of Sequential Data
Mining. Due to the increasing ability to store complex data
sequences, it has become one of the most important and active
subﬁelds of data mining research. Dong and Pei [19] deﬁne
it as special subﬁeld of data mining for certain structured
data. The term structured data thereby refers to data that is
structured in an explicit way and comprises of a set of data
items. In terms of sequences this structure can include (partial)
orderings, temporal orderings, hierarchical structure as well as
network structures. A more formal description of the sequence
structure is also given in Section III. Other forms of structured
data, which are not in the scope of this work, are for example
tree data, graph data, time series data or also text data.
The complex data structure of sequences is what sets
Sequential Data Mining apart from standard Data Mining. Al-
though the structure makes it more difﬁcult to mine sequential
data, there is also the reward to access information that can be
contained in the structure of a sequence. Bautista-Thompson
and Brito-Guevara [20] stress that the collective behaviour and
the hidden relations between such data, can contain decisive
information. Furthermore, they point out that the structure of
sequences can have a certain dynamics (such as stationary,
random, complex).

634
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
1) Tasks in Sequential Data Mining: Sequential Data Min-
ing was primarily applied in the ﬁeld of bioinformatics on
genomic data and also, in the ﬁeld of business intelligence
on transactional data (especially from the retailer industry).
Therefore, the following three tasks of Sequential Data Mining
have emerged:
• Clustering: This task is about the grouping of unlabelled
sequences into clusters. In general, this task is solved
by combining well-known clustering algorithms with an
appropriate distance function that is applied to sequences.
Therefore the special properties of sequences and their
structure need to be taken into account.
• Classiﬁcation: This is most common task that includes
building a classiﬁer that is able to distinguish between
two existing classes (labels). This is normally achieved by
combining standard classiﬁcation methods in conjunction
with suitable feature construction techniques. The goal for
the classiﬁcation can be to decide if a sequence belongs
to a certain class or if a sequence contains a subsequence
of interest and its position (especially interesting for com-
parison of genomic data). The presented work focuses on
the classiﬁcation task.
• Hybrid: As the name suggests, this task is concerned with
both: the identiﬁcation of sequences classes as well as the
characterization of the occurring sequential patterns [19].
2) Issues in Sequential Data Mining: Research in Sequen-
tial Data Mining usually revolves around so-called sequential
databases in order to ﬁnd sequential patterns. Therefore,
sequential data mining research should consider the following
four technical issues:
• Concept formulation: creating new concepts that lead to
advances in the research ﬁeld
• Design: creating novel techniques that are able to handle
large volumes of data with a large number of dimensions.
The techniques need to be able to handle the complex
data structure while being able to take advantage of the
underlying structure of the given sequential data.
• Optimizing cluster/classifying quality: modifying/altering
existing techniques to achieve a better accuracy. Quality
measurements in terms of classiﬁcation are accuracy,
precision and recall. In terms of clustering inter-precision
or inter-cluster similarity are used.
• Optimizing pattern interestingness: this task aims to im-
prove techniques in terms of their usefulness for the user.
Measures include support, conﬁdence, lift, novelty and
actionability. Xing et al. [21] state that in addition to
accurate quality results, the interpretability of sequence
classiﬁers is both important and difﬁcult
This research work deals with all four issues and focuses
on the concept formulation as well as the design of a new
sequence classiﬁcation algorithm.
D. Problem description
As discussed in previous sections, the KDD process and
Data Mining are about ﬁnding patterns in data. Initially these
data comprised of static feature vectors that did not change
over time [8]. The later years have brought more complex
objects that need to be stored. The latest development in
data collection and storage technologies allows companies
to keep extremely large quantities of data relating to their
daily activities [5]. This process introduced the temporal
dimension into the ﬁeld of Data Mining and allowed the
storage of evolving (or dynamic) data over time. However, this
dimension is neglected by most of the researchers: ’In Data
Mining community, researchers pay little attention to time-
stamps in temporal behavior [...] during classiﬁcation’ [14].
This is quite a sub-optimal situation since ’knowledge about
the behavior of objects is an integral part of understanding
complex relationships in real-world systems and applications’
[8]. Time is necessary to markup complex behaviour. Kriegel
argues that due to historical reasons (i.e., given their static data
during the 1980s) many researchers created their algorithms
only for static descriptions of objects and are therefore not
designed to input data with dynamic behavior. The inclusion
of dynamic properties of modern complex data models would
allow revealing the information hidden in their temporal aspect
and in addition to that, describe the relationship between
complex objects. The type of information that is visible in the
temporal dimension of a series of events is called sequential
pattern.
Most of the sequence analysis work (see also Section II) is
focused on ﬁnding frequent item sets, associate them with a
certain order and then predict what items are bought next in a
sequence. The research work described in this article is about
ﬁnding a technique that is able to take the time span between
a series of events into account and unveil hidden information
that can be used for classiﬁcation purposes.
This work will present an algorithm that is able to ﬁnd
discriminatory patterns in temporal based data and use them
for classiﬁcation purposes. The algorithms suggested so far
have not been able to use the information hidden in sequential
and time ordered data. Such information can be captured by
creating sequence based features out of the original attributes
of the given data set. The time dimension is thereby used in
the construction step.
II. RELATED WORK
Earlier work in the ﬁeld of feature construction was done
by Setiono and Liu [13]. They used a neuronal network to
construct features in an automatic way for continuous and
discrete data. Pagallo [15] proposed FRINGE, which builds a
decision tree based on the primitive attributes to ﬁnd suitable
boolean combinations of attributes near the fringe of the
tree. The newly constructed features are then added to the
initial attributes set and the process is repeated until no
new features are created. Zupan and Bohanec [16] used a
neuronal net for attribute selection and applied the resulting
feature set on the well known C4.5 [17] induction algorithm.
Feature construction can also be used in conjunction with
linguistic fuzzy rule models. Garc´ıa [18] et al. use previously
deﬁned functions over the input variables in order to test if

635
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
the resulting combination returns more information about the
classiﬁcation than the single variables. This process can lead
to fuzzy rules of the following schema, which can include
functions in the antecedent:
IF x1 IS A1AND SUM(x1, x2) IS A3 THEN Y IS B
A3 and B represent fuzzy subset values that belong to the
function‘s domain. The used function SUM(x1, x2) is thereby
treated as a new variable. However, in order to deal with
increasing complexity of their genetic algorithm in the em-
pirical part, Garc´ıa only used three functions (SUM(xi, xj),
PRODUCT(xi, xj), SUBSTRACT ABS(xi, xj)) to en-
large the feature space. Another approach to feature construc-
tion, which utilizes a genetic algorithm, is described by Alfred
[23]. Although, his approach is not using different functions to
create new combinations of features, it can create a big variety
of features since it is not limited to binary combination. That
means that it is able to combine more than two attributes at
a time. The genetic algorithm selects thereby the crossover
points for the feature sequences. Sia [24] proposes a ’Fixed-
Length Feature Construction with Substitution’ method called
FLFCWS. It constructs a set that consist of randomly com-
bined feature subsets. This allows initial features to be used
more than once for feature construction.
The next two subsections present the two most famous
Feature Construction techniques for sequential data in greater
detail.
A. MFE3/GA
Shafti [7] presents MFE3/GA (Multi-Feature Extraction
using GA), a method that uses a global search strategy
(i.e., ﬁnding the optimal solution) to reduce the original data
dimensions and ﬁnd new non-algebraic representations of
features. Her primary focus is to ﬁnd interactions between the
original attributes (such as the interaction of several cards in
a poker game that form a certain hand). MFE3/GA basically
searches through the initial space of attribute subsets to ﬁnd
subset of interaction attributes as well as a function over each
of the found subsets. The suitable functions are then added
as new features to the original data set. The C4.5 learner
is then applied for the data mining process. So far only
nominal attributes are being processed, so that class labels and
binary/continuous attributes need to be normalized. A feature
is thereby a bit-string of length N, where each bit shows the
presence or absence of one of the N original attributes. Subsets
of these features are associated with a function deﬁned over the
attributes in the subset. This allows a non-algebraic (operator-
free) representation of the original attributes. The output of the
associated functions fi for each subset Si = (xi1, . . . , xim)
are basically the binary class labels. The labels are retrieved
from the training samples that match the subset. It can be
possible that both labels for one subset are occuring in the
training data. In this case a so called mixed-tuple label can
be associated with the subset (other labels are types pure and
unknown).
B. FeatureMine
Lesh, Zaki and Ogihara present FeatureMine [12] - another
well known feature construction technique for sequential data.
It combines two data mining paradigms: sequence mining
and classiﬁcation algorithms. They understand sequences as
a series of events, e.g., AB → B → CD. There is also
a timestamp associated with each event. FeatureMine starts
by mining frequent and strong patterns within the sequences.
Frequency is deﬁned by a threshold that is speciﬁed by the
user. Strong is deﬁned as a conﬁdence level that needs to be
over a user speciﬁc threshold. The found frequent sequence
patterns are pruned and selected using some heuristics. The
prevailing sequences lattices are stored in a matrix n ∗ m
database layout, whereby the rows n represents the sequences
and the columns m represent the prevailing sequence lattices.
The cells of the matrix contain and boolean indicator if a
sequence contains the corresponding sequence lattice. The
constructed features are associated with a class label and then
feed into the Naive Bayes classiﬁcation algorithms.
C. Contribution
We propose an automated algorithm that is able to systemat-
ically construct and assess suitable new features based on data
sequences for binary classiﬁcation tasks. It thereby is also able
to utilize the time dimension in a sequence of events in order
to access information, which can have a signiﬁcant impact on
the discriminatory power of features. Thereby, the algorithm
transforms sequential data into tuple-based data in a way,
that allows standard algorithm such as Neuronal Networks,
Bayesian Belief Network, Decision Trees or Naive Bayes to
be applied on sequential data.
So far, feature construction techniques build new features by
combining columns of a data set (i.e., ’horizontally’). We also
apply these techniques with a larger variety of mathematical
operators. In addition to that, we are able to utilize the time
elapsed between data points. Our approach is novel, since we
include the vertical dimension of data, i.e., the rows of a
sequence, in order to create new features. This is achieved
by combining numeric values (or its probabilities in terms
of string attributes) of the corresponding occurrences. The
original values are aggregated during the feature construction
process. This allows to store sequence based information on
tuple level. As a result of that, the above mentioned standard
algorithms can be applied (not all are able to handle sequenced
data sets right away).
The proposed techniques are extending the given problem-
space and search for a combination of dimensions that allow to
separate the binary classes that need to be classiﬁed. It thereby
utilizes abstracted patterns that can occur in the data and is
able to validate the created combinations.
III. GENERAL CHARACTERISTICS OF SEQUENTIAL DATA
This work often refers to the term sequential data. Thereby,
we understand data, that can be ordered by time and can
be grouped to logical units (i.e., the sequence). A simple
example for that are sessions in an online shop. Customers

636
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
TABLE I: Schema of sequence data
r
t
sid
a1
a2
. . .
ai
slabel
r1
t1
sid1
a11
a21
. . .
ai1
0
r2
t2
sid1
a12
a22
. . .
ai2
0
r3
t3
sid1
a13
a23
. . .
ai3
0
r4
t4
sid2
a14
a24
. . .
ai4
1
r5
t5
sid2
a15
a25
. . .
ai5
1
r6
t6
sid2
a16
a26
. . .
ai6
1
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
rm
tm
sidn
a1m
a2m
. . .
aim
. . .
can view products and put them into their shopping basket.
Every action can be represented in a data set E as a row r
with several attributes ai ∈ E. Each row is provided with a
timestamp t. A row can be associated to a logical unit sid
(in our case the session id). There are n sequences sidn in
a data set E. Each sequence sidn consist of at least one row
r. The number of rows in a sequence equals to the length
of a sequence ls, so that 1 ≤ ls ≤ m. Table I depicts
the general schema of sequential data: It is important to
differentiate between the number of rows (or tuples) m of
a data set and the number of sequences n. Sequence sid1, for
example, has a length ls of three and contains a matrix such
as sid1 =


a11
a21
. . .
ai1
a12
a22
. . .
ai2
a13
a23
. . .
ai3


In order to use our proposed method, which is described in
detail in the following section, the user has also to annotate
the following columns on a data set:
• t: timestamp column that is used for temporal based
features. It is used to calculate the time elapsed between
the collected data points of a sequence.
• sid: sequence identiﬁer column that is used for sequence
aggregation. It identiﬁes events/objects that can be logi-
cally associated to one entity
• slabel: the proposed algorithm requires a binary column
as target value. This is needed in order to automatically
calculate the information gain of newly constructed fea-
tures. Every sequence must only have one label, i.e., a
customer in an online shop is either a returning customer
or not (it can not be both at the same time).
During the feature construction process, we will create a
feature table, which includes the sid, slabel and the created
features fp ∈ S. S is thereby deﬁned as a set of constructed
features. Please refer to Table II, for a schema of such a table.
TABLE II: Schema of feature table
sid
f1
f2
. . .
fp
slabel
sid1
f11
f21
. . .
fp1
0
sid2
f12
f22
. . .
fp2
1
. . .
. . .
. . .
. . .
. . .
. . .
sidn
f1n
f2n
. . .
fpn
. . .
The data sequences are aggregated on a tuple-based level.
This enables the application of many standard classiﬁcation
algorithms.
IV. FEATURE CONSTRUCTION FOR DATA SEQUENCES
Our goal is to extend and search the initial problem space
as much as possible. Problem space is thereby deﬁned through
the primitive (original) attributes E, which are used to solve
a binary classiﬁcation task. The accessible feature space ex-
pands, if more features are constructed. Albeit, this leads to
an increase in search time, it brings a higher chance to ﬁnd
discriminatory features. In order to keep things as simple as
possible, we describe the algorithm in ﬁve different subsec-
tions, each describing a certain sort of features construction
technique. Please note that the initial attributes are, in a ﬁrst
step, categorized in string and numeric attributes. Reason for
this is, that not all described functions are applicable on string
values. Note, that after each feature construction technique,
we normalize the newly generated features with min-max
normalization, depicted in (1). This provides an easy way
to compare values that are on different numerical scales or
different units of measure.
Normalized(ei) =
ei − Emin
Emax − Emin
, for Emax > Emin
(1)
The ﬁrst Subsection IV-A will show construction techniques
for both string and numeric attributes. The second Subsec-
tion IV-B describes construction techniques for string-only
attributes. After that we will focus in the third Subsection
IV-C on numeric-only construction techniques. Subsection
IV-D describes temporal based feature construction techniques.
This section is concluded by Subsection IV-E, which describes
feature construction based on sequence distribution.
A. Distinct occurrences based features
The general idea for this feature construction technique is
to analyze if different occurrences per sequence allows to
discriminate between the given labels. Basically, we aggregate
all sequences sidn and count the distinct occurrences (so no
duplicates are counted) for each given string as well as for
each numeric attribute aim. The constructed features fp are
then collected in S, together with its corresponding sequence
identiﬁer sid and the corresponding session label slabel. Please
note that the sequence identiﬁer sid is unique in S (as opposed
to E). The corresponding pseudo-code is depicted in Fig. 1.
In order to assess the quality of the new constructed feature
fi, we calculate two measurements in order to assess the
quality. The ﬁrst one is the average of all aggregated values
per label slabel ∈ {0, 1}. The normalized difference between
both averages is called split and is calculated as depicted in
(4).
avg0 =
avg({fp ∈ S|slabel = 0})
(2)
avg1 =
avg({fp ∈ S|slabel = 1})
(3)
splitfi =
|avg0−avg1|
avg0+avg1
(4)
The second measurement to assess the quality of the con-
structed features is the number of zero and NULL values for
each target label. This is a support measurement that denotes
if the achieved split value is based on many sequences or not.

637
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Input: E // set of nominal and continuous attributes
slabel ∈ {0, 1} // binary label indication
Def: ai ∈ E // single attribute or a column in a data set
sid = (r1, r2, . . . , rm) // sequences of rows ri
S = ∅ // set of constructed features
for each ai ∈ E {
for each sid ∈ E {
fp := (|{ain}|, sid, slabel)
S := S ∪ fp
}
}
return S
Fig. 1: Pseudo-code feature construction based on distinct
occurences per label
So there could be the situation that a constructed feature has a
high split value, but might be useless since it cannot be used
very often due to large number of 0 values for the particular
features.
B. Concatenation based features
The purpose of this type of feature construction is to
highlight simpler interactions among data. We systematically
concatenate every string attribute in pairs of two and then
again, count the distinct value-pairs per sequence identiﬁer.
Thereby, interactions such as, if a1 AND a2 have low value-
pair variety for label 0, but a high value-pair variety for label
1, are highlighted. Even for data sets with a high number
of different occurrences, this kind of feature construction
will highlight distinct occurrences between both labels. This
procedure is only applicable on string attributes. This approach
is similar to most common column combinations that is de-
scribed widely in the literature (e.g., [7], [16], [23]). However,
we once again use this technique on a different abstraction
layer since we aggregate via the sequence identiﬁer sid. The
corresponding pseudo-code is depicted in Fig. 2.
The algorithm copies the input attribute list E for looping
purposes into a second variable E2. Right after the second
loop, it deletes the current attribute from the copied list
(E2 − a2i). Reason for this is to avoid the same features to
occur twice, due to symmetric properties. If, for example, we
combine column ai = X and aj = Y of a data set, we will
yield feature XY . This feature will have the same variability
per sequence as the vice versa feature Y X. The construction
of such features can be avoided by deleting the current feature
from the copied feature list E2.
C. Numeric operator based features
The basic idea of this feature construction technique is to
combine two numeric attributes with basic arithmetic operators
such as ’+’, ’-’, ’*’ or ’/’. Garcia [18] and Pagallo [15] for
instance are using similar techniques with fewer operators. In
addition to the repeated use of arithmetic operators we, once
again, use the sequence identiﬁer attribute to aggregate the
constructed features for each sequence. Lets put this into an
Input: E // set of nominal attributes
slabel ∈ {0, 1} // binary label indication
Def: ai ∈ E // single attribute or a column in a data set
sid = (r1, r2, . . . , rm) // sequences of rows r
S = ∅ // set of constructed features
E2 = E // copy of E, used for looping
con() // concatenates two values
for each ai ∈ E {
//remove ai to avoid vice versa features
E2 := E2 − {ai}
for each aj ∈ E2 {
for each sid ∈ E {
fp = (|(con(ai, aj))|, sid, slabel)
S = S ∪ fp
}
}
}
return S
Fig. 2: Pseudo-code feature construction based on
concatenated string attributes
example: attributes ai and aj are combined with the multipli-
cation operator ’*’ for a sequence sid1. The resulting feature
f = ai ∗aj is derived from the sequence sid1 =


ai1
aj1
ai2
aj2
ai3
aj3


The sequence consists of three data points. In the aggre-
gation phase, we sum up the multiplied attributes for all
sequences P 3
j=1fij. This process is repeated for all possi-
ble combinations of numeric attributes for all of the above
mentioned mathematical operators. The full pseudo-code is
depicted in Fig. 3. For this technique, we also avoid vice versa
features as described in previous Subsection IV-B.
D. Temporal axis based features
The general idea for this feature construction technique is to
use the time axis, which is given in each sequence by the time
indicator column t. This is applicable for both, numeric as well
as string attributes. However, for string attributes, there needs
to be some preparations done, which are explained further
down in this subsection. We continue here to describe the
process for numeric attributes. What the algorithm basically
does, is to multiply the time interval (e.g., days, hours,
minutes), between earliest data point and the current data
point with the numeric value of corresponding attribute, which
results in a weighting.
Table III shows this for two example sequences. We have
two attributes ai and aj for two sequences as well as the t
column. In order to calculate the temporal based feature for
attribute sequence sid = 1 in terms of attribute ai, we ﬁrst have
to calculate the time between the earliest data point min(t)
with t ∈ sequence(sid) and each of the ’current’ data points t.
In Table III, this is depicted by the ∆time in days column.
The next step is to multiply the value of each ti in sid = 1 with

638
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Input: E // set of primitive numeric attributes
slabel ∈ {0, 1} // single value label indication
Def: ai ∈ E // single attribute or a column in a data set
sid = (r1, r2, . . . , rm) // sequences of rows r
S = ∅ // set of constructed features
E2 = E // copy of E, used for looping
O // set of arithmetic operators
ls // length of a sequence sid
for each ai ∈ E {
//remove ai to avoid vice versa features
E2 := E2 − {ai}
for each aj ∈ E2 {
for each o ∈ O {
for each sid ∈ E {
fp = (Pls
i=1(ai o aj), sid, slabel)
S = S ∪ fp
}
}
}
}
return S
Fig. 3: Pseudo-code feature construction based on numeric
attributes
its corresponding delta time value: (ai1 ∗ 1, ai2 ∗ 11, . . . , ai4 ∗
24). The sum of this value is the new time based constructed
feature fp. This process is repeated for all sequences s and
for all numerical attributes E.
TABLE III: Example for creating temporal based features
sid
t
min(t)
per sid
∆time−
in days
ai
aj
slabel
1
01.01.2013
01.01.2013
1
ai1
aj1
0
1
10.01.2013
01.01.2013
11
ai2
aj2
0
1
15.01.2013
01.01.2013
16
ai3
aj3
0
1
23.01.2013
01.01.2013
24
ai4
aj4
0
2
24.01.2013
24.01.2013
1
ai5
aj5
1
2
28.01.2013
24.01.2013
5
ai6
aj6
1
2
30.01.2013
24.01.2013
7
ai7
aj7
1
However, there are two directions of including the time
for this feature construction technique. What we described
above puts a stronger emphasis on the recent history. It
is also possible to increase the weight of the past by us-
ing the (max date - current date) operator to calculate the
∆time in days column. An example of this is depicted in
Table IV. The complete pseudo code is depicted in Fig. 4.
The above mentioned techniques are applicable on numeric
attributes. For string attributes, it is possible to replace the
string by the posterior probability p(θ|x) (see also Hand [26],
pp. 117-118 and pp. 354-356). Thereby, θ represents the
probability of the parameters for a given evidence x. In our
example case, we have the distribution of our two labels as
parameters θ and occurrences of ai as evidence x.
Based on this the posterior probability can be calculated as
TABLE IV: Example for creating temporal based attributes
with a stronger emphasis on the distant past
sid
t
max(t)
per sid
∆time−
in days
ai
aj
slabel
1
01.01.2013
23.01.2013
24
ai1
aj1
0
1
10.01.2013
23.01.2013
14
ai2
aj2
0
1
15.01.2013
23.01.2013
9
ai3
aj3
0
1
23.01.2013
23.01.2013
1
ai4
aj4
0
2
24.01.2013
30.01.2013
7
ai5
aj5
1
2
28.01.2013
30.01.2013
3
ai6
aj6
1
2
30.01.2013
30.01.2013
1
ai7
aj7
1
Input: E // set of continuous/numeric attributes
t // time indicator column
slabel ∈ {0, 1} //binary label indication
Def: ai ∈ E // single attribute or a column in a data set
sid = (r1, r2, . . . , rm) // sequences of rows r
S = ∅ // set of constructed features
E2 = E // copy of E, used for looping
ls // length of a sequence sid
max() // returns max value of a set
for each ai ∈ E {
for each sid {
fp = (Pls
i=1(( max
k=1,...,ls(tk) − ti) ∗ ai), sid, slabel)
S = {S ∪ fp}
}
}
return S
Fig. 4: Pseudo-code feature construction of temporal based
attributes
depicted in (5)
p(slabel = 1|ai) =
p(ai|slabel=1)∗p(slabel=1))
p(ai)
(5)
In order to apply this for string based attributes, we can
construct new features f for string attributes as depicted in
(6)
fp =
ls
X
i=1
( max
k=1,...,m(tk) − ti) ∗ (p(slabel = 1|ai))
(6)
If there are occurrences in the data that have a great tendency
towards a particular label (i.e., having a high probability for
one label), we can make this pattern visible by multiplying
the posterior possibility with the temporal axis of the given
sequence.
However, if there are too many different occurrences, lets
say more than 1.000 different values per attribute, this tech-
nique could have problems dealing with very small proba-
bilities. So, it is recommended to take the logarithm of the
posterior probability for cases with high cardinality.
E. Sequence distribution based features
It is also possible that a discriminatory pattern evolves
around distributions of numeric values in the given sequences.

639
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Input: E // set of continuous/numeric attributes
slabel ∈ {0, 1} // binary label indication
Def: ai ∈ E // single numeric attribute in a data set
sid = (r1, r2, . . . , rm) // sequences of rows r
S = ∅ // set of constructed features
E2 = E // copy of E, used for looping
O // set of arithmetic operators
for each ai ∈ E {
for each sid ∈ E {
fp = (STD DEV (sid), sid, slabel)
fp = fp ∪ (V AR(sid), sid, slabel)
fp = fp ∪ (AV G(sid), sid, slabel)
S = S ∪ fp
}
}
return S
Fig. 5: Pseudo-code feature construction based on sequence
distribution
Therefore, this feature construction technique is focusing on
patterns that are based on variability, standard deviation and
average. This construction techniques highlights patterns as
for example:
• one numeric value of a class is oscillating while the value
is stable for the other class
• the values for one class are more spread out than for the
other class
• the average value of an attribute per sequence of a certain
class is in general higher or lower, then of the other class
In principle, we calculate the above mentioned values for each
sequence of each numeric attribute in a data set. The full
pseudo-code is depicted in Fig. 5.
V. EXPERIMENTAL SETUP AND RESULTS
This section is divided into three subsection in which we
will ﬁrst look at the technical framework we used during our
experiments. This is followed by a brief look at the data proﬁle
and the corresponding classiﬁcation task. The third subsection
will then compare and discuss the results of our experiments.
A. Technical Framework and Infrastructure
All implementations and experiments were carried out on
a Microsoft Windows Server 2008 R2 Enterprise Edition
(6.1.7601 Service Pack 1 Build 7601) with four Intel Xeon
CPUs E5320 (1.86 GHz, 1862 MHz). The available RAM
comprised of 20 GB installed physical memory and 62 GB
virtual memory (size of page ﬁle 42 GB). The widespread
freeware data mining software RapidMiner (version 5.2.008)
was used for the standard methods under comparison: Decision
Tree, Naive Bayes, Neuronal Network and Random Forrest
(for a closer description please also see Witten [25] pp. 191-
294, Han [3] pp. 291-337). The method Bayesian Belief
Network required the installation of the free RapidMiner
extension WEKA. We used the default parameters for all of
the above mentioned classiﬁcation algorithms.
B. Data Proﬁle
The data we used for our experiments was retrieved from
the DataMiningCup 2013. The training as well as the test data
set can be downloaded on the following site: http://www.data-
mining-cup.de/en/review/dmc-2013/. The given historical data
from an online shop consisting of session activities from
customers. The goal of the task is to classify sessions into
a buyer and a non-buyer class. The parameters of the train
data was predeﬁned by the task of the DataMiningCup 2013
and are as follows:
• total number of rows: 429,013
• number of sessions: 50,000
• number of numeric attributes: 21
• number of string attributes: 2
The test data was also given by the DataMiningCup require-
ments, which had the following parameters:
• total number of rows: 45,068
• number of sessions: 5,111
• number of numeric attributes: 21
• number of string attributes: 2
Most of the given attributes are numeric. Please note that
there is no exact time column given. Therefore, we used a
artiﬁcial id column to map the temporal order of the various
sessions. We also used this column to calculate the temporal
based features described in Subsection IV-D.
C. Comparison of original attributes vs constructed features
sets
As a ﬁrst step, we used the given primitive attributes to
solve the task. We used the accuracy measurement (7) due to
a similar label distribution (45 % to 55 %) and both labels are
associated with the same ’costs’ for misclassiﬁcation.
Accuracy =
TP + TN
TP + TN + FP + FN
(7)
As it can be seen in Fig. 6, the Naive Bayes classiﬁcation
algorithm was able to achieve better result than the base line
(the other algorithms defaulted and predicted label = 0 for all
sessions). The Bayesian Belief Networks are not applicable
for situations in which the same sid can occur several time
(therefore a accuracy rate of 0 %). In a next step, we used our
suggested feature construction algorithm in order to aggregate
the sessions and ﬁnd useful features. During this process, a
grand total of 860 features were created:
• # of distinct occurrences based features: 19
• # of string concatenation based features: 2
• # of arithmetic based features: 760
• # of temporal axis based features: 20
• # of sequence distribution based features: 59
All constructed features were normalized with the min-max
normalization. They were, in a ﬁrst series of experiments,
assessed by calculating the split value for each feature. The

640
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Fig. 6: Accuracy rate comparison original data set with primitive attributes variations of constructed features.
Fig. 7: All constructed features ranked by their split value.
features were ranked by their split value, as it can be seen
in Fig. 7. The best feature achieve a split value of 0.843, the
lowest of 0.0003. In order to keep execution times low, we
chose only the top 32 constructed features from the ranked list
for our second run. Fig. 6 shows the impressive improvement
for the compared standard methods. Since the sid is unique
for the constructed features set, the Bayesian Belief Networks
are applicable.
However, focusing only on the split measurement for feature
selection is not enough. In a second range of experiments, we
only included those features, which achieved a minimum split
value of 0,70 and a had a minimum support value of 0,50. A
total number of 13 features met these criteria (10 operator
numeric and 3 sequence distribution based features). The
results for the best feature are shown in Fig. 6. It can be seen
that the smaller constructed feature space is able to perform
better or at least as good as the top 29 features only ranked by
split. This shows that complex problems with sequential data
can be simpliﬁed and solved by features construction. We can
also see that for this data set, operator numeric features turned
out to be the most beneﬁting ones. Reason for this is that
there were only two string attributes in the original data set as
well as the lack of a proper timeline (see also Section V-B).
This means that in this data set, the pattern to distinguish
between the two given labels is not that dependent on the
temporal dimension than in other data sets (e.g., [1]). This also
highlights the importance of the presented features selection
techniques. Without them, arbitrary and useless features would
have mislead the used classiﬁers.
VI. CONCLUSION
Data pre-processing and selection are important steps in the
data mining process. This can be challenging, if there is no
domain expert knowledge available. The algorithm proposed in
this work helps, not only to understand the patterns within the
data, but also, to simplify more complex data structures (such
as sequential data). This is achieved by various aggregation
and combination techniques that allow to increase the feature
space of a given data set and eventually, to highlight present
feature interactions. The feature construction algorithm can be
applied in conjunction with well known standard algorithms
and boosts classiﬁcation performance in a big variety of ﬁelds
with similar speciﬁcations (such as the detection of credit
card fraud, network intrusions, bots in computer games). Its
systematic approach can also help domain experts to ﬁnd
previously unknown interactions among data and therefore,
to get a better understanding of their domain.
VII. FUTURE WORK
Further ways for extending the features space could be to
implement more numerical features generated by logarithm,
exponential function or combinations of more than two at-
tributes. The algorithm itself could be optimized to assess
the quality of a candidate feature before actually calculating

641
International Journal on Advances in Software, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/software/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
it. Another development direction could be to align the con-
structed features in a way, that would allow to classify data
without the help of one of the standard algorithms.
REFERENCES
[1] M. Schaidnagel and F. Laux, ”Feature construction for time ordered
data sequences,” in Proceedings of the Sixth International Conference on
Advances in Databases, Knowledge, and Data Applications, Chamonix,
April 20-24, 2014, pp. 1-6.
[2] W. Lee, ”A Data mining framework for constructing features and mod-
els for intrusion detection systems,” PhD thesis, Columbia University,
Graduate School of Arts and Sciences, 1999.
[3] J. Han and M. Kamber, Data mining: concepts and techniques 2. edition
pp. 48-97 second edition, San Francisco, Morgan Kaufmann, 2006.
[4] H. Liu and H. Motoda, Feature extraction, construction and selection: a
data mining perspective, Boston, Kluwe Academic Publisher, 1998.
[5] W. Lin, M. Orgun, and W.J. Graham, ”An overview of temporal data
mining,” in Proceedings of the 1st Australian data mining workshop,
Canberra, Australia, 2002, pp. 83-90.
[6] L. S. Shafti and E. P´erez, ”Constructive induction and genetic algorithms
for learning concepts with complex interaction,” in Proceedings of The
Genetic and Evolutionary Computation Conference, Washington, June
2005, pp. 1811-1818.
[7] L. S. Shafti and E. P´erez, ”Data reduction by genetic algorithms and non-
algebraic feature construction: a case study,” in Proceedings of: Eighth In-
ternational Conference on Hybrid Intelligent Systems, Barcelona, Septem-
ber 2008, pp. 573-578.
[8] H.P. Kriegel, K. M. Borgwardt, P. Krger, A. Pryakhin, M. Schubert, and
A. Zimek, ”Future trends in data mining,” in Data Mining and Knowledge
Discovery, vol. 15, no. 1, Springer, 2007, pp. 87-97.
[9] I. Guyon, S. Gunn, M. Nikravesh, and L. A. Zadeh, Feature extraction:
foundations and applications, Berlin, Springer, 2006.
[10] K. Cios, W. Pedrycz, R. W. Swiniarski, and L. A. Kurgan,Data mining:
a knowledge discovery approach, New York, Springer US, 2007.
[11] S. Markovitch and D. Rosenstein, ”Feature generation using general
constructor functions,” in Machine Learning, vol. 49, no. 1, Kluwer
Academic Publishers, 2002, pp. 59-98.
[12] N. Lesh, M. J. Zaki, and M. Ogihara, ”Scalable feature mining for
sequential data,” in IEEE Intell. Syst. No. 2, 2000, pp. 48-56.
[13] R. Setiono and H. Liu, ”Fragmentation problem and automated feature
construction,” in Proceedings of: 4th Conference on Data Mining and
Optimization (DMO), Langkawi, September 2012, pp. 53-58.
[14] Y. Yang, L. Cao, and L. Liu, ”Time-sensitive feature mining for temporal
sequence classiﬁcation,” in Proceedings 11th Paciﬁc Rim International
Conference, Wellington, December 2013, pp. 315326.
[15] G. Pagallo, ”Learning DNF by decision trees,” Machine Learning, pp.
71-99 Kluwer Academic Publishers, 1990.
[16] B. Zupan and M. Bohanec, ”Feature transformation by function decom-
position,” in Journal IEEE Intelligent Systems archive. Volume 13 Issue
2, March 1998, pp. 38-43.
[17] J.R. Quinlan, ”C4.5: programs for machine learning”. Morgan Kauf-
mann, 1993.
[18] D. Garc´ıa, A. Gonz´alez, and R. P´erez, ”A two-step approach of feature
construction for a genetic learning algorithm,” in Proceedings of: IEEE
International Conference on Fuzzy Systems, Taipei, June 2011, pp. 1255-
1262.
[19] G. Dong and J. Pei, Sequence data mining, New York, Springer US,
2007.
[20] E. Bautista-Thompson and R. Brito-Guevara, ”Classiﬁcation of data se-
quences by similarity analysis of recurrence plot patterns,” in Proceedings
of Seventh Mexican International Conference on Artiﬁcial Intelligence,
Tuxtla Gutirrez, Mexico, 2008.
[21] Z. Xing, J. Pei, and E. Keogh, ”A brief survey on sequence classiﬁca-
tion,” in ACM SIGKDD Explorations Newsletter, No 1, 2010, pp. 40-48.
[22] D. Garc´ıa, Antonio Gonz´alez, and R. P´erez, ”An iterative strategy
for feature construction on a fuzzy rule-based learning algorithm,” in
Proceedings of: 11th International Conference on Intelligent Systems
Design and Applications, Cordoba, November 2011, pp. 1235-1240.
[23] R. Alfred, ”DARA: data summarisation with feature construction,” in
Proceedings of: Second Asia International Conference on Modelling &
Simulation, Kuala Lumpur, May 2008, pp. 830-835.
[24] F. Sia and R. Alfred, ”Evolutionary-based feature construction with
substitution for data summarization using DARA,” in Proceedings of:
fourth Conference on Data Mining and Optimization (DMO), Langkawi,
September 2012, pp. 53-58.
[25] I. Witten and F. Eibe, Data mining : practical machine learning tools
and techniques 2. edition, San Francisco, Morgan Kaufmann, 2005, pp.
48-97.
[26] D. Hand, H. Mannila, and P. Smyth, Principles of Data Mining, MIT
Press, 2001.

