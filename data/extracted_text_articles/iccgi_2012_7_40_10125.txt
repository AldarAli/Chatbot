Variability Identiﬁcation by Selective Targeting of Signiﬁcant Nodes
Anilloy Frank
Institute of Technical Informatics,
Technische Universitt
Inffeldgasse 16, 8010 Graz, Austria
Email: anilloy.frank@student.tugraz.at
Eugen Brenner
Institute of Technical Informatics,
Technische Universitt
Inffeldgasse 16, 8010 Graz, Austria
Email: brenner@tugraz.at
Abstract—The automotive industry is characterized by nu-
merous product variants, often driven by embedded software.
With ever increasing complexity of embedded software, the
electrical/electronic models in automotive applications are get-
ting enormously unmanageable. Signiﬁcant concepts for model-
ing and management of variability in the software architecture
are under development. Models are hugely hierarchical in
nature with numerous composite components deeply embedded
within projects comprising of Simulink models, implementa-
tions in legacy C, and other formats. Hence, it is often necessary
to deﬁne a mechanism to identify reusable components from
these that are embedded deep within. The proposed approach
is selectively targeting the component-feature model (CF)
instead of an inclusive search to improve the identiﬁcation. We
explore the components and their features from a predeﬁned
component node list and the features node vector respectively.
It addresses the issues to identify commonality in identiﬁcation,
speciﬁcation and realization of variants within a product
development. Since the approach does not depend on the depth
of the components or on its order, it serves well with all
the scenarios, thereby exhibiting a generic nature. The results
obtained are faster and more accurate compared to other
methods.
Keywords-Design Tools; Embedded Systems; Feature Extrac-
tion; Software Reusability; Variability Management.
I. INTRODUCTION
Embedded systems are microcontroller-based systems
built into technical equipment mainly designed for a dedi-
cated purpose, where communication with the outside world
occurs via sensors and actuators [1]. Although this deﬁnition
implies that embedded systems are used as isolated units,
there is also a trend to construct distributed pervasive sys-
tems by connecting several embedded devices, as noted by
Tanenbaum and van Steen [2].
The current development trend in automotive software
is to map software components on networked Electronic
Control Units (ECU), which includes the shift from an
ECU based approach to a function based approach. Also,
according to data presented by Ebert and Jones, up to 70
electronic units are used in a car containing embedded
software consisting of more than 100 million lines of object
code, which is mainly responsible for the value creation of
the car.
Variants of embedded software functions are vital in
customizing for different regions (Europe, Asia, etc.), to
meet regulations of the respective regions. Also different
sensors / actuators, different device drivers, and distribution
of functionality on different ECUs necessitate variants. Man-
aging variability involves extremely complex and challeng-
ing tasks, which must be supported by effective methods,
techniques, and tools [3].
Ebert and Jones present recent data about embedded soft-
ware in [4], stating that the volume of embedded software
is increasing between 10 and 20 percent per year as a
consequence of the increasing automation of devices and
their application in real world scenarios.
The proposed strategy is to introduce a variability iden-
tiﬁcation layer. It intends to facilitate a reusable software
solution. We start by analyzing the textual representation of
the model structure. Based on this we form a concept to
extract an element list to facilitate the identiﬁcation of vari-
ability. Both implementation and evaluation of the proposed
strategy is based on a technically advanced adaptation of a
formal mathematical model, which is beyond the scope of
this paper.
II. SOFTWARE REUSE
In the 1960s, reuse of software started with subroutines,
followed by modules in the 1970s and objects in the 1980s.
About 1990 components appeared, followed by services at
about 2000. Currently, Software Product Lines (SPL) are
state of the art in the reuse of software.
Figure 1.
Software reuse history.
Figure 1 shows a short history of the usage of reuse in
software development. The key idea of Product Lines is
very old; it is based on Henry Ford’s mass customization
to provide a effective way for cheap individual cars. Today,
148
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-202-8
ICCGI 2012 : The Seventh International Multi-Conference on Computing in the Global Information Technology

many different approaches exist to the implementation of
Software Product Lines.
A SPL is a set of software-intensive systems that share
a common set of features for satisfying a particular market
segment’s needs. SPL can reduce development costs, shorten
time-to-market, and improve product quality by reusing core
assets for project-speciﬁc customizations [3][5].
Despite of all the hype, there is a lack of an overall
reasoning about variability management.
The SPL approach promotes the generation of speciﬁc
products from a set of core assets, domains in which
products have well deﬁned communalities and variation
points[6].
Although variability management is recognized as an
important issue for the success of SPLs, there are not many
solutions available [7]. However, there are currently no
commonly accepted approaches that deal with variability
holistically at architectural level [8].
III. VARIABILITY MANAGEMENT
One of the fundamental activity in Software Product
Line Engineering (SPLE) is Variability management (VM).
Throughout the SPL life cycle, VM explicitly represents
variations of software artifacts, managing dependencies
among variants and supporting their instantiations [3].
Figure 2.
Variability management in product lines.
To enable reuse on a large scale, SPLE identiﬁes and
manages commonalities and variations across a set of system
artifacts such as requirements, architectures, code compo-
nents, and test cases. As seen in the Product Line Hall of
Fame [9], many companies have adopted this development
approach.
SPLE as depicted in Figure 2 can be categorized into
domain engineering and application engineering [10][11].
Domain engineering involves design, analysis and imple-
mentation of core objects, whereas application engineering
is reusing these objects for product development.
Activities on the variant management process involves
variability identiﬁcation, variability speciﬁcation and vari-
ability realization [12].
• The Variability Identiﬁcation Process will incorporate
feature extraction and feature modeling.
• The Variability Speciﬁcation Process is to derive a
pattern.
• The Variability Realization Process is a mechanism to
allow variability.
IV. SOFTWARE ARCHITECTURE
Figure 3 depicts a layered software architecture that is
considered in the proposed architecture. It shows a compar-
ison of distributed systems and platform with the proposed
layered architecture and the feasibility of mapping the cor-
responding artifacts and responsibilities for each layer.
Figure 3.
Comparison of architecture, system, and platform.
The deﬁnition of software architecture given in the
ISO/IEC 42010 IEEE Std 1471-2000: “The fundamental
organization of a system embodied in its components, their
relationships to each other, and to the environment, and the
principles guiding its design and evolution [13].”
In the middle illustrates a distributed system. Tanenbaum
and van Steen deﬁne distributed systems as “A distributed
system is a collection of independent computers that appears
to its users as a single coherent system [2].”
Similarly to the right side is depicted a typical platform
as speciﬁed by Atkinson and K¨uhner in Model Driven
Architectures (MDA) [14].
V. SPECIFICATION OF THE CASES
To enable identiﬁcation of variability for software compo-
nents in a distributed system within the automotive domain
[15][16], we enlist the speciﬁcations below:
• Speciﬁcation of components by compatibility
The product is tested using software functions of a
certain variant and version. These products may exhibit
compatibility issues between functional blocks, whilst
149
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-202-8
ICCGI 2012 : The Seventh International Multi-Conference on Computing in the Global Information Technology

using later version of the function may fail to perform
as expected.
• Extract, identify, and specify features
To enable parallel development, it is necessary to be
able to extract features, and to identify and specify the
functional blocks in the repository based on architecture
and functionality.
• Usability and prevention of inconsistencies
A process that tracks usability and prevents inconsis-
tencies due to deprecate variants and versions in the
repository is required.
• Testing mechanism for validations
A testing mechanism for validations in order to main-
tain high quality for components and its variants has to
be established.
• Mechanism for simpliﬁed assistance
The developer has to be assisted by a process to
intelligently determine whether a functional block or
its variant should exist in the data backbone to avoid
redesign of existing functions, thereby improving pro-
ductivity.
VI. PROPOSED APPROACH FOR VARIABILITY
IDENTIFICATION
Models conﬁrming to numerous tools like ESCAPE R
⃝,
EAST-ADL R
⃝, UML R
⃝ tools, SysML R
⃝ speciﬁcations and
AUTOSAR R
⃝ were considered. Although this concept is not
limited to automotive domain alone.
A. Project analysis
An analysis of the models exhibits a common architecture.
Figure 4 depicts the textual representation that underlies
several graphical model. The textual representation usually
is given in XML, which strictly validates to a schema.
A heterogeneous modeling environment may consist of
numerous design tools, each with its own unique schema, to
offer integrity and avoid inconsistencies. Developed projects
have to be strictly validated to the schemas of these tools.
A closure examination of the nodes in the textual repre-
sentation of models depicted in Figure 5 reveals some inter-
esting information. The nodes outlined in rectangles provide
important information regarding the identity, speciﬁcation,
physical attributes, etc. of a component, but are insigniﬁcant
from the perspective of variant.
B. Concept and approach
The basic concept to identify variability is depicted in
Figure 6.
The left side is a set of projects that have software compo-
nents hierarchically embedded. These projects validate to the
corresponding schemas. The middle layer is an identiﬁcation
layer with three functional blocks. A set of component lists is
derived from the node list in the schema. Similarly a feature
vector is derived from it that corresponds to components.
Figure 4.
Mapping textual and graphical representations.
Figure 5.
XML Nodes that are not signiﬁcant for variability.
The second block is a customized parser that generates a
relevant lexicon from the set of software components within
a project. The third block is a set of rules (viz., mandatory,
optional, exclude) to govern the identiﬁcation of variability.
The basic concept can be extended to obtain a working
model for the identiﬁcation of variants. The work ﬂow is
depicted in Figure 7. The top layer here represents the
domain or core assets. The middle layer is a semi-automatic
identiﬁcation layer for variants. A component list and a
150
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-202-8
ICCGI 2012 : The Seventh International Multi-Conference on Computing in the Global Information Technology

Figure 6.
Basic Concept.
feature vector is derived manually from the schema of the
project; a collection of elements that represent components
and their descriptive features that signiﬁcantly contribute to
the identiﬁcation of the component’s variant.
Figure 7.
Work ﬂow of the identiﬁcation process.
The workﬂow can be further extended to adapt a hetero-
geneous environment which consist of projects developed
using several modeling and simulation tools. The identiﬁca-
tion layer is separated into two parts. Numerous component
lists and feature vectors can be derived for each distinct
schema as depicted in Figure 8, whereas a common lexicon
and common rules govern the identiﬁcation process.
C. Evaluation
A prototype of the architecture presented here has been
implemented. These case studies targeted the design of
model-based software components ﬁrstly in an industrial use
Figure 8.
Work ﬂow of the identiﬁcation process for heterogeneous
systems.
case where the project model was developed using the design
tool ESCAPE R
⃝ [17], and secondly in a case study targeting
the execution of speciﬁc paradigms based on the naming
convention of AUTOSAR R
⃝ [18].
The speciﬁc project data set depicted in Figure 9, which
was used to verify the implementation, consisted of a total
of 32909 elements. Of these elements a total of 1583
elements signify components, these were categorized into
23 categories when enlisted in the component list. A total
of 13353 elements signiﬁed features that were assigned into
12 categories.
Figure 9.
Dataset summary of project using ESCAPE design tool.
151
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-202-8
ICCGI 2012 : The Seventh International Multi-Conference on Computing in the Global Information Technology

Three different approaches were adopted to evaluate and
determine the performance with respect to matches and time.
• Evaluation using a single element speciﬁcation set
The ﬁrst experiment was conducted on a single element
speciﬁcation set. A group of ten sets formed the input to
determine the result set in both comprehensive (global)
search and selective search as illustrated in Figure 10.
The notion of comprehensive search is used, when
scanning all occurrences of the speciﬁcation set within
projects, irrespective of whether they are components or
features of those components. This can return a result
set that contains false matches.
Figure 10.
Occurrence graph for a single element speciﬁcation set.
Figure 11.
Time graph for a single element speciﬁcation set.
The pattern of the results displayed similar behavior.
Observations
– The comprehensive search yields a result set that
contains every occurrence of the speciﬁcation set,
even if these nodes do not characterize a compo-
nent.
– The nodes representing components yield a result
set which is somewhat realistic, though these do
not epitomize the complete set desired. This is
often observed when the component nodes do not
match, but their features collectively match the
speciﬁcation set.
– These nodes along with the feature set yield a more
elaborate result set. A match contained by any node
in a set of features would result in representing the
component to which it belongs.
Figure 11 depicts the time taken to obtain the speciﬁca-
tion set illustrated in Figure 10. The time graph depicts
the aggregate time required for global and selective
search for a set of ten speciﬁcation sets.
Observations
– It is evident from these ﬁgures that the time
required for comprehensive search exceeds the
selective search - which is the method proposed
in this article - by almost a factor of 5; this may
be a dominant factor for large speciﬁcation sets.
• Evaluation using multiple element speciﬁcation set
The second experiment was conducted using one up to
seven element speciﬁcation sets as a group illustrated
in Figure 12.
Figure 12.
Occurrence graph for multiple element speciﬁcation sets.
Observations
– The comprehensive search often yielded large re-
sult sets, as it searches in individual nodes that are
treated as atomic.
– The exhibited behavior is similar to the vary-
ing size of the speciﬁcation set. As observed in
Figure 12, the selective component-feature search
result set demonstrates a value when the size of
speciﬁcation set exceeds 3, because in this case
the matches take place across the boundary of
the feature within the component. On the other
hand the other methods return null result set as the
search is only within the boundary of the element.
– For any given size of speciﬁcation set, the selective
component-feature search returns a much smaller
result set and is more precise.
– Convergence is optimal with a speciﬁcation set of
size 3. If the size of the speciﬁcation is too large
the result may be null for both methods as shown
in Figure 12.
• Evaluation using different starting points for ele-
ments in speciﬁcation sets
152
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-202-8
ICCGI 2012 : The Seventh International Multi-Conference on Computing in the Global Information Technology

Figure 13.
Occurrence graph for different starting points.
The third experiment was conducted searching for ele-
ments within speciﬁcation sets using different starting
points. Figure 13 depicts the result sets in comprehen-
sive search and selective search.
To determine the effect of different starting points, a
multiple-element speciﬁcation set was used, where the
orders of the elements were changed to obtain ﬁve sets.
The result set for this exhibits the same pattern as the
two experiments above.
VII. CONCLUSION
Managing variants is of utmost importance in today’s
large software bases as they reﬂect legal constraints, mar-
keting decisions, and development cycles. As these software
bases often grew from different sources and were developed
by different teams using different tools it is in many cases
very complicated if not nearly impossible to ﬁnd artefacts
that might be variants, both for historical reasons as for
development purposes.
Searching algorithms have to reﬂect both the capability to
match keywords and to reﬂect the structure that characterizes
a component. Our proposed method is capable of both
aspects and therefore helps the developer to ﬁnd matches
even in large and heterogeneous databases. In addition to
that not only the required time for the search is a lot shorter,
but also accuracy of the retrieved set of candidates is highly
improved.
The developed prototype is itself independent of a speciﬁc
tool as it works on textual descriptions that typically are
available in XML.
REFERENCES
[1] Ebert, C. and Salecker, J.; Guest editors’ introduction: Embed-
ded software technologies and trends.
Software, IEEE, Vol
26(3): pp. 14-18, 2009
[2] Tanenbaum, A.S. and van Steen, M.;
Distributed Systems:
Principles and Paradigms (2nd Edition).
Prentice Hall, 2006
[3] Clements, P. and Northrop, L.; Software Product Lines: Prac-
tices and Patterns,
Addison-Wesley, 2007
[4] Ebert, C. and Jones, C.;
Embedded software: Facts, ﬁgures,
and future.
Computer, IEEE Vol 42(4): pp. 42-52, 2009
[5] Gomaa, H. and Webber, D.L.; Modeling Adaptive and Evolv-
able Software Product Lines Using the Variation Point Model.
The Proceedings of the 37th Hawaii international Conference
on System Sciences, 2004
[6] Oliveira, E., Gimenes, I., and Maldonado, J.;
A variability
management process for software product lines.
CASCON
2005, The conference of the Centre for Advanced Studies on
Collaborative research: pp. 225 - 241
[7] Heymans, P. and Trigaux, J.;
Software product line: state
of the art.
Technical report for PLENTY project, Institut
d’Informatique FUNDP, Namur, 2003
[8] Galster, M. and Avgeriou, P.; Handling variability in software
architecture: Problem and implications.
WICSA 2011, Ninth
Working IEEE/IFIP Confernce on Software Architecture: pp.
171-180
[9] PRODUCT
LINE
HALL
OF
FAME;
”http://splc.net/fame.html”.
retrieved: 04,2012
[10] Bachmann, F. and Clements, P. C.; Variability in Software
Product Lines,
Technical Report -CMU/SEI-2005-TR-012,
2005.
[11] Bosch, J.; Design and Use of Software Architectures: Adopt-
ing and Evolving a Product-Line Approach,
Addison-Wesley,
2000
[12] Burgareli, L.A., Selma, Melnikoff, S.S., and Mauricio Fer-
reira, G. V.; A Variation Mechanism Based on Adaptive Ob-
ject Model for Software Product Line of Brazilian Satellite
Launcher,
ECBS-EERC 2009, First IEEE Eastern European
Conference on the Engineering of Computer Based Systems:
pp. 24-31
[13] IEEE; Iso/iec standard for systems and software engineer-
ing - Rrecommended practice for architectural description of
software-intensive systems.
Technical report, IEEE, 2000
[14] Atkinson, C. and K¨uhne, T.; A generalized notion of platforms
for model-driven development.
Model-Driven Software
Development, Springer-Verlag, Berlin: pp. 119–136, 2005
[15] Frank, A.A. and Brenner, E.; Model-based Variability Man-
agement for Complex Embedded Networks.
ICCGI 2010,
The Fifth International Multi-conference on Computing in the
Global Information Technology: pp. 305-309
[16] Frank, A.A. and Brenner, E.; Strategy for modeling variability
in conﬁgurable software.
PDES 2010, The 10th IFAC
workshop on Programmable Devices and Embedded Systems
[17] ESCAPE; ”http://www.gigatronik2.de/index.php?seite=escape
produktinfos de&navigation=3019&root=192&kanal=html”.
retrieved: 04,2012
[18] AUTOSAR; ”http://www.autosar.org/download/conferencedocs
/03 AUTOSAR Tutorial.pdf”.
retrieved: 04,2012
153
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-202-8
ICCGI 2012 : The Seventh International Multi-Conference on Computing in the Global Information Technology

