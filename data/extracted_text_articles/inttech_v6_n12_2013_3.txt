32
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Evaluation of an Architecture for Providing Mobile Web Services  
Marc Jansen 
Computer Science Institute 
University of Applied Sciences Ruhr West 
Bottrop, Germany 
marc.jansen@hs-ruhrwest.de 
 
Abstract—As the role of mobile devices as Web Service 
consumers is widely accepted, already today a large number of 
mobile applications consume Web Services in order to fulfill 
their task. Still, no reasonable approach exists as yet, to allow 
deploying Web Services on mobile devices and thus use these 
kinds of devices as Web Service providers. In this paper, our 
approach is presented that allows deploying Web Services on 
mobile devices by the usage of well-known protocols and 
standards. In order to achieve this, the presented approach 
overcomes problems that usually occur when mobile devices 
are used as service providers. Here, the description of an 
implementation is presented, along with first performance tests 
and an evaluation of the battery consumption that results in 
using the presented approach. The performance test shows 
that the described approach provides a reasonable way to 
introduce Web Service provisioning for mobile devices, but the 
results for the battery consumption provide some challenges 
that need to be met, e.g., the determination and evaluation of 
scenarios that benefit from using mobile Web Services. Last 
but not least, this paper provides first ideas how complex 
mobile scenarios can be evaluated in order to decide whether 
they benefit from using mobile Web Services. 
Keywords - mobile devices; Web Services; mobile Web 
Service provider, battery consumption, scenario development. 
I. INTRODUCTION  
As already explained in [1], a need for a technology that 
allows  deploying Web Services on mobile devices is 
necessary. In recent years, the number of reasonably 
powerful mobile devices has increased dramatically. 
According to [2], 216.2 million smartphones where just so 
sold in Q1 2013 worldwide.  
 
 
 
Figure 1.  Distribution of different operating systems for smartphones in 
2013. 
On the other hand, this huge number of smartphones 
represents a large number of heterogeneous devices with 
respect to the operating systems smartphones are currently 
using. According to [3], there were at least five different 
operating systems for smartphones available on the market in 
2010, and their distribution is shown in Figure 1. It thus 
seems to be necessary to have a platform-independent 
mechanism for the communication with services provided by 
smartphones in order to not re-implement each service for 
each of the mentioned operating systems. 
Usually, Web Services are used in order to provide a 
standardized and widely used methodology that is capable of 
achieving a platform-independent way to provide services. 
Unfortunately, in contrast to consuming Web Services on 
mobile devices, providing Web Services on mobile devices 
is not yet standardized due to several problems that occur 
when a service runs on a mobile device. To change this was 
one of the major motivations for the work described in this 
paper. Providing a framework that allows to deploy 
standardized Web Services on mobile devices provides big 
advantages for a number of different mobile technologies, 
e.g., in order to contextualize mobile users. 
Therefore, this paper presents the description of a 
framework that allows providing Web Services on mobile 
devices. The outline of the paper is as follows: the next 
section provides an overview of related work and the 
motivation for the development of the described approach, 
after which the scenario - together with the problems that 
usually occur if Web Services should be provided by a 
mobile device - is explained. The following section explains 
the implementation of the framework in detail and the results 
of a first performance test are presented. Afterwards, the 
power consumption of the presented approach is evaluated 
and discussed with respect to user acceptance and possible 
types of scenarios that benefit from consuming Web Services 
deployed to mobile devices. Furthermore, another section 
provides first ideas about how different scenarios can be 
determined and evaluated with respect to the question if 
these scenarios would benefit by consuming Web Services 
deployed to mobile devices. The paper is closed by a 
conclusion and an outlook for further research questions. 
II. MOTIVATION 
The idea of providing Web Services on mobile devices 
was probably presented first by IBM [4]. This work presents 
a solution for a specific scenario where Web Services are 
hosted on mobile devices. More general approaches for 
providing Web Services on mobile devices are presented in 

33
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[5] and [6].  In [7], another approach, focusing on the 
optimization of the HTTP protocol for mobile Web Services 
provisioning, is presented. Importantly, none of the 
mentioned approaches manages to overcome certain 
limitations of mobile devices, as demonstrated in the next 
section.  
The major difference between previous research and the 
approach presented in this paper is that, to the best of our 
knowledge, previous research focused very much on 
bringing Web Services to mobile devices by implementing 
server side functionality to the mobile device in question. 
The approach presented here follows a different line: from a 
technical and communication point of view, the mobile Web 
Service provider communicates as a Web Service client with 
a dynamically generated Web Service proxy. This approach 
provides an advantage for overcoming certain problems with 
mobile Web Services as described in the next section. 
Furthermore, this approach does not rely on an efficient 
server side implementation of Web Services on the mobile 
device, and thus allows to implement a very lightweight 
substitution to a common application server where a 
common Web Service is running. 
Since nothing comes for free, this approach has some 
drawbacks as well, e.g., it implements a polling mechanism 
that permanently polls for new service requests. Therefore, 
this approach produces an overhead with respect to the 
network communication and the computational power of the 
mobile device. The computational overhead, though, can be 
dramatically reduced by adjusting the priority of the polling 
mechanism according to the priority of the provided Web 
Service. 
Another drawback of the presented approach is that it 
relies on a publicly available proxy infrastructure for the part 
of the framework that dynamically generates the Web 
Service proxies. This drawback can be overcome if, for 
example, mobile telecommunication companies provide this 
kind of infrastructure centrally. 
In contrast to the aforementioned approaches, the 
approach presented in this paper differs with respect to one 
major aspect: from a network technical point of view there is 
no server instance installed on the mobile device. Therefore, 
a certain Web Service client does not call the Web Service 
on the mobile device directly but calls a centrally deployed 
proxy. The Web Service running on the mobile device polls 
in regular intervals for any new message requests of interest. 
The sequence of the Web Service request from the client 
point of view and from the Web Service point of view is 
shown in the sequence diagram in Figure 2. 
The exact sequence of the different messages and events 
will be described in more detail later. Since especially 
polling mechanisms cause certain drawbacks, one of the 
major questions concerning the presented approach is the 
question of benefits and drawbacks of the polling mechanism 
and, in particular, whether the benefits justify the drawbacks. 
One of the major problems of dealing with Web Services 
on mobile devices is the fact that mobile devices often switch 
between  networks. Therefore, the Web Service running on a 
mobile device is usually not available under a fixed address, 
a fact that leads to a number of problems for the consumer of 
a mobile Web Service: Besides the usual network switch, the 
fact that mobile devices are usually not meant to provide 
24/7 availability, but are designed towards providing the user 
with the possibility to exploit certain services, e.g., phone 
calls, short messages, writing and receiving emails, etc., 
yields the problem that mobile devices might get switched 
off by the user. Hence, not only that the provided Web 
Service might be available under different network 
addresses, but it might not be available at all. 
 
 
 
Figure 2. Sequence diagram of the Web Service requests in the presented 
approach. 
 
  
All these drawbacks can be solved by using the approach 
presented here. By using the central proxy, the service 
requests of a certain Web Service client can be stored and if 
the mobile Web Service is running, it can pull for service 
requests that are of interest to it. Since from a technical point 
of view the Web Service provider only acts as a client to the 
Web Service proxy, the potentially changing network 
addresses of the mobile device does not pose a problem at 
all. 
In addition, one of the major drawbacks of the described 
polling mechanism can be limited by adjusting the priority of 
the Web Service running on the mobile device, resulting in a 
lower frequency of the polling for the service request. 
To conclude, in our opinion, the advantages of the 
described mechanism justify the drawbacks that are inherent 
to the approach. 
III. SCENARIO DESCRIPTION 
The major idea behind the implementation of the 
middleware is to provide a Web Service proxy, according to 
the proxy design pattern [8], in order to overcome certain 
problems in mobile scenarios as described by [9]. One major 
problem here is that mobile devices often switch networks, 
e.g., at home the mobile phone might be connected to a Wi-
Fi network, at work the connection might be established 
through another Wi-Fi network and on the way home from 
work the mobile phone might be connected to a 
GPRS/UMTS-network. Each of these different networks 
provides different IP addresses and possibly different 

34
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
network scenarios. For example, it can be private IP 
addresses with network address translation (NAT), where the 
Web Services running on the device are not directly 
accessible from the internet, or public IP addresses.  
Frequently switching between IP addresses, and therefore 
frequently changing IP addresses (as occurs especially with 
mobile devices), might raise certain problems for the 
provision of Web Services, since the client of a certain 
service always needs to know the actual IP address at which 
the service can be reached. More than that, within a private 
network the provided Web Services are usually not reachable 
at all from the internet. Therefore, the problem, from the 
client point of view, is that the service is not always 
accessible under the same (and constant) IP address. The 
presented approach provides a solution to overcome this 
problem, with the exception of the case when a device is 
completely switched off. The switch off problem can be 
overcome as well, in which case slight modifications to the 
presented approach, together with an asynchronous call of 
the Web Service, are necessary. 
The approach presented here suggests solving these 
problems by implementing a Web Service proxy that 
dynamically creates a proxy for each Web Service that gets 
deployed on a mobile device. The created proxy allows 
receiving service requests as a representative to the actual 
service and storing a service request along with the necessary 
data. In the next step, the mobile Web Service provider 
continuously polls for requests to its services, performs the 
services and sends the result back to the dynamically 
generated Web Service proxy. Receiving the result, the Web 
Service proxy can send the result back to the client that 
originally performed the service request. 
IV. IMPLEMENTATION 
The major goal of the work presented here is to provide a 
solution 
to 
the 
described 
scenario. 
Therefore, 
we 
implemented a middleware that allows the provision of Web 
Services on mobile devices. Here, the standard protocols, 
e.g., WSDL for the description of the Web Service interface, 
SOAP/REST as the standard network protocol and http as 
the usual transport protocol, are used such that there is no 
additional effort on the client side for requesting a mobile 
Web Service.  
The following three sections provide a short introduction 
to the services offered by the middleware, followed by a 
description of the communication between the mobile Web 
Service provider and the Web Service client/consumer. Last 
but not least some details are presented about the Java based 
implementation for the test scenario. 
A. Use-Case Analysis 
In order to achieve the goal of implementing a Web 
Service proxy, an analysis of use-cases that this proxy will 
have to support has been performed. The result of this 
analysis is shown in Figure 3.  
Relations in this Use-Case diagram reflect the interaction 
between the different use cases or an actor and the use case. 
From a technology point of view four different actors 
participate in the scenario.  
A.1 The Web Service Provider 
Obviously, a provider for the mobile Web Service is necessary. 
This is a piece of software running on the mobile device that 
provides the Web Service itself. This piece of software can best be 
compared with an application server hosting a Web Service in a 
scenario where the Web Service is provided by a common server 
system  
 
Figure 3. Use-Case description of the developed middleware. 
 
A.2 The Web Service Client 
The second quite obvious actor is the consumer of the 
Web Service: the Web Service client. This is a piece of 
software running on the client side, performing requests to 
the Web Service. 
A.3 The Web Service Proxy 
As already described, one of the major ideas of the 
presented approach is to provide a proxy for the Web 
Services provided by the mobile devices. Therefore, the Web 
Service proxy is another actor that participates in the 
scenario. The proxy represents a surrogate of the Web 
Service provided by the mobile device. The basic function of 
this proxy is to implement the same interface (same methods 
with identical parameter lists and return values) as the Web 
Service itself. Moreover, the methods provided by the proxy 
(in order to register a service, de-register a service, etc.), 
should be accessible via the standard network protocols of 
Web Services and the description of the proxy interface 
should also be available in WSDL (in the implementation 
here the SOAP protocol was chosen). The proxys’ major task 
is to receive client requests, store them in a database and wait 
for the mobile Web Service to provide the result of the 
service request. While in the traditional proxy pattern the 
proxy would directly forward (push) the incoming service 
requests to the Web Service, we have decided to just store 
the requests in a database in order to allow the mobile Web 
Services to pull the requests from the proxy. This change to 

35
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
the traditional proxy pattern basically allows handling 
constantly changing network connections (as explained 
before), since within this approach neither the Web Service 
proxy nor the Web Service client need to know the actual IP 
address of the mobile device that provides the actual Web 
Service.  
A.4 The Database 
Fourth and last, the database is taken to be an actor of the 
middleware. Usually, the database would more likely be 
modeled as a system (and not as an actor), but for the sake of 
clarity and consistency, we decided to model the database 
also as an actor in the system. The major task of the database 
is to store the necessary information about the service 
request in order to allow the Web Service running on the 
mobile device to perform the requested task, and to later-on 
store the return values of the service request as well. By 
storing also the return value, the Web Service proxy is able 
to send the result back to the client that made the request. 
This is necessary since the usage of the proxy is transparent 
to the client, in the sense that the client is not aware that the 
actual service request is not answered by the proxy, but by 
the Web Service running on the mobile device. Therefore, 
the Web Service proxy needs to send the result of the service 
to the Web Service client, and not the mobile Web Service 
itself.  
Besides the four actors, a number of use-cases need to be 
implemented in order to fully run the described scenario. 
A.5 Service Registration  
First of all, a mobile Web Service provider needs to be 
able to register a service to be provided. Besides the Web 
Service provider, the Web Service proxy and the database 
are interacting within this use-case, too. The Web Service 
proxy needs to dynamically implement the interface of the 
mobile Web Service and the storage of the metadata 
(basically the name of the method that should be called and 
its parameter values) of the service requests. The database 
needs to provide certain storage for the parameter values of 
each method (in case of a relational database: a table) and the 
according return values of the mobile Web Service. 
A.6 Receive Service Requests 
The second, quite obvious, use-case is that the mobile 
Web Service provider needs to be able to receive service 
requests. Besides the mobile Web Service provider, the Web 
Service proxy participates in this use-case also, since this is 
the instance that directly receives the requests from the Web 
Service client and stores the necessary information in the 
database.  
A.7 Perform and Receive Service Requests 
Two additional use-cases, namely, perform service 
requests and receive service request results, participate in the 
store service request metadata use-case. 
A.8 Storing Service Metadata and Handling of Return 
Values 
Additionally, we have identified two other use-cases that 
are necessary for the handling of the service request 
metadata (store service request metadata) and the handling of 
the return values (store service result). The first of these two 
use-cases interacts with two actors: the Web Service proxy 
and the database; the second one additionally interacts with 
the Web Service Provider. 
Beside the fact that the provision of these use-cases 
allows the implementation of the described scenario, one of 
the major advantages of this approach is that the Web 
Service client only interacts with the performed service 
request and receives corresponding answers from the service 
request result use-case. Therefore, from a client point of 
view, the request to a mobile Web Service is no more than a 
usual service request. No additional effort is necessary on the 
client side in order to receive results from a Web Service 
running on a mobile device. 
B. Communication between the mobile Web Service and 
its clients  
In order to explain the necessary communication for a 
service request from the Web Service client to the mobile 
Web Service provider, we modeled the communication flow 
within the sequence diagram shown in Figure 4. 
Within the sequence diagram we have modeled an object 
life line for each of the actors, to be discussed later. First of 
all, the mobile Web Service provider needs to register its 
service with the Web Service proxy. As part of the service 
registration process the Web Service proxy creates the 
necessary data structure for storing the service requests in the 
database. 
After the mobile Web Service provider has registered its 
service, it permanently polls the Web Service proxy for new 
service requests. The Web Service proxy asks the database if 
a new service request for the respective mobile Web Service 
provider is available and if so, returns the request’s metadata 
to the mobile Web Service provider. After receiving the 
metadata of a new service request, the mobile Web Service 
provider performs the service and sends the result of the 
service to the Web Service proxy that directly stores the 
result in the database. 
From a client point of view, the Web Service client 
simply calls the service provided by the Web Service proxy. 
While receiving a new service request, the Web Service 
proxy stores the necessary request metadata in the database. 
Afterwards the Web Service proxy directly starts to poll the 
database periodically for the result of the respective service 
request. Once the mobile Web Service provider has finished 
performing the request and has stored the result (via the Web 
Service proxy) in the database, the Web Service provider is 
able to send the result of the service request back to the 
client. 
C. A sample implementation 
In order to test the described approach with respect to its 
performance, we implemented the Web Service proxy in 
Java. Additionally, the mobile Web Service provider was 
implemented for Android. Here, we focused on an intuitive 
and easy way for the implementation of the Web Service, 
and have therefore, oriented ourselves by the JAX-WS (Java 
API for XML-Based Web Services), as described in the Java 
Specification Request 224 (JSR 224). The major idea, 
adapted from JAX-WS, was that a Web Service can easily be  
 

36
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
 
implemented by the use of two different annotations: the 
@MobileWebService annotation marks a class as a Web 
Services and methods within this class can be marked as 
method available through the mobile Web Service with the 
@MobileWebMethod annotation. 
With the help of these two annotations a simple mobile 
Web Service, which only calculates given integer values, can 
be implemented as follows: 
 
@MobileWebService 
public class TestService { 
 
 
@MobileWebMethod 
 
public int add(int a, int b) { 
 
 
return a + b; 
 
} 
 
 
}  
 
The basic relationships between the major classes of the 
sample implementation are shown in Figure 5. For the sake 
of simplicity and transparency, less important classes (and 
methods of each class) have not been modeled. Basically, the 
implementation consists of two packages. Package one is the 
proxy package which is usually deployed on a server that is 
reachable from the internet via a public IP address. Here, we 
find one class that implements the necessary methods for the 
registration of a new mobile Web Service, the permanent 
polling from the mobile Web Service for the service request 
metadata and the method that allows storing the result of the  
 
service request in the database. All these methods are 
reachable as Web Services themselves, so that the 
communication between the instance running the mobile 
Web Service and the Web Service proxy is completely Web 
Service-based. 
 
 
Figure 5. UML class diagram of major parts of the sample implementation. 
 
In the provider package we find, as one of the major 
classes, the MobileWebServiceRunner class to which the 
mobile Web Service gets deployed. This class is basically 
comparable to an application server in a common Web 
Service environment, but with a dramatically lower footprint. 
This lower footprint is extremely important to mobile 
devices due to their usually limited resources. Additionally, 
this package also provides the two formerly mentioned 
Figure 4. The UML sequence diagram for the communication between a mobile Web Service and its client. 

37
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
annotations that allow an easy marking of a class as a mobile 
Web Service and, accordingly, a certain method of such a 
class as a mobile Web Method. Last but not least, this 
package also implements the ServiceRequestFetcher class. 
This class inherits the java.lang.Thread class since its 
responsibility is to permanently poll the Web Service 
provider for new service requests. 
V. PERFORMANCE TESTS 
Since the communication is a little bit more complicated, 
in comparison to a common Web Service call, one concern 
of this approach is the question of its performance. In order 
to get a first idea of how good or bad this implementation 
behaves with respect to performance issues, we implemented 
a simple performance test. Here, we focused only on the 
evaluation of the transmission delay, since this seemed to be 
the most critical parameter. Other parameters like the 
number of lost packets, etc. were not taken into account yet. 
 
A. Description of the test scenario 
For the performance test and the sake of simplicity we 
implemented a very simple mobile Web Service. This 
service only calculates the sum of two given integers and 
returns the respective value as the result. The major 
advantage of such a simple mobile Web Service is that 
almost the entire duration of the mobile Web Service call is 
dedicated to the communication, and almost no amount of 
the round-trip time is used for the calculation itself. Since the 
communication is the complex part of the presented 
approach, we assume that this method of performance testing 
would provide the best overview about the communication 
performance of the presented approach. In the test scenario a 
common client (running on a common PC) had to put a 
number of service requests to the mobile Web Service. 
In order to compare the results against the performance 
of common Web Service requests, we implemented the test 
scenario also the other way around: we implemented a 
common Web Service (running on a common server) and 
called this Web Service from a mobile device. Here, the 
basic idea was to use the same hard- and software- 
environment with minimal changes and also to maintain the 
same network environments in all of the tests. 
In addition, we were interested in the communication 
performance in different network settings. Therefore, we 
performed the same tests in four different network settings. 
For each of the tests the (mobile) Web Service and its 
consumer where running: 
• 
… in the same (Wi-Fi) network,  
• 
… different networks, and the mobile device 
was connected via Wi-Fi, 
• 
… different networks, and the mobile device 
was connected via UMTS 
• 
… different networks, and the mobile device 
was connected via GPRS 
 We conducted eight different test cases: four for the 
different network scenarios with a mobile Web Service 
running on a mobile device and a Web Service client running 
on a common PC, and four test cases where the Web Service 
was running on a common Server and the client was running 
on a mobile device. The test cases, in which the (mobile) 
Web Service and the consumer were both connected to the 
same network, were only conducted in order to receive 
results with minimal latency.  
In the test cases where the (mobile) Web Service 
provider and the client were not connected to the same 
network, the central components have been deployed to a 
server running via Amazon Web Services (AWS), as a Cloud 
Computing provider. 
B. Test results 
Within each of these eight test cases, one hundred service 
calls were performed and the duration of each call was 
measured.  
The results for the mobile Web Service in the different 
network scenarios are shown in Figure 6. 
 
Figure 6. Results for the mobile Web Service in different network 
scenarios. 
 
As expected the performance for the mobile Web Service 
requests are pretty good and pretty constant if the mobile 
device is connected with a Wi-Fi network. The average time 
if both, the mobile Web Service provider and the client, are 
connected to the same Wi-Fi network, was M = 147.69ms 
(SD = 76.00ms). Having the mobile Web Service provider 
connected to a different, still Wi-Fi, network, the average 
time for one service call calculates to M = 339.04ms (SD = 
61.71ms). 
Of course, we measured less performance of the service 
calls when the mobile Web Service provider was connected 
to a mobile network, the performance of the service calls was 
lower. The results for the UMTS based network connection 
of the mobile Web Service show an average of M = 
827.55ms (SD = 250.35ms) for each service call, while the 
results for the GPRS based network are even worse. Here, 
the average for a single service call is M = 1355.96ms (SD = 
986.38ms). As can be seen from the values for the standard 
deviation, the performance of single service calls differs 
dramatically as well, e.g., the minimum duration measured 
within the UMTS scenario was MIN = 283ms and the 
maximum was MAX = 2169ms. The results for the GPRS 
based scenario are even worse, with a MIN = 142ms and 
MAX = 5123ms. 

38
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
The task of the second step of the test was to compare the 
performance results with the performance of a common Web 
Service call. For that purpose we conducted the same test, 
but this time the Web Service was not running on a mobile 
device but on a common server, while the Web Service client 
was running on a mobile device - again in the four different 
network settings. The results of these tests are shown in 
Figure 7. As demonstrated, the results are better from both 
perspectives - the overall performance and the standard 
deviation in the different network settings. A common Web 
Service call, if the Web Service provider and the mobile 
Web Service consumer are connected to the same Wi-Fi 
network, has an average round-trip duration of M = 61.16ms 
(SD = 301.36ms). When the Web Service client was 
connected to a different (still Wi-Fi) network the average 
performance was M = 156.71ms (SD = 15.24ms). 
 
 
 
Figure 7. Results for the usual Web Service requests in the different 
network scenarios. 
 
Here, again, the values for the Web Service client 
connected to a mobile network are somewhat  lower. In the 
case of the UMTS network, the average service call showed 
a performance of M = 528.55ms (SD = 273.34ms), and the 
results for the GPRS based network were even worse with an 
average for each of the service calls of M = 1299.10ms (SD 
= 658.75ms). 
The next step was to compare the different results. The 
major goal of this comparison was to get an idea of how 
good the performance of the presented approach for mobile 
Web Service requests is, in comparison to common Web 
Service requests. Therefore, we calculated the difference in 
the average performance of a single Web Service call in the 
different scenarios first, and as a second step we calculated 
the percentage of the performance difference in the different 
scenarios. The results are shown in Table 1. 
 
TABLE 1: COMPARISON OF THE COMMON WEB SERVICE 
REQUESTS AND THE MOBILE WEB SERVICE REQUESTS 
IN THE DIFFERENT NETWORK SCENARIOS 
 
 
The table shows that, in comparison to common Web 
Service requests, the performance of the presented approach 
was not too good when the mobile Web Service was 
connected to a Wi-Fi network. The results for the mobile 
Web Service provider and the client connected to the same 
network showed a performance overhead of 137.60 per cent, 
and when the mobile Web Service was provided within a 
different Wi-Fi network the performance overhead was about 
116.35 per cent. But, if the mobile Web Service was 
connected to a mobile network, the performance overhead 
was not that dramatic anymore. In the case of the UMTS 
network the overhead was limited to 56.57 per cent, and for 
the GPRS based network the overhead was even lower at 
4.38 per cent. Therefore, on the basis of our test results, it 
can be said that the performance degredation seems to 
decrease with the presented approach for mobile Web 
Services (in comparison to common Web Services) in lower 
quality networks, e.g. networks with lower bandwidth. This 
could best be seen by the results for the GPRS based 
network, where the actual overhead for the presented 
approach was below 5 per cent.   
VI. TESTS FOR BATTERY CONSUMPTION 
Beside the technical performance of the described 
solution, another very important aspect of the technical 
implementation is the impact of the implementation for the 
battery consumption of the mobile device. Already a lot 
research in the area of energy consumption for Android 
based devices has been conducted, e.g. [10], [11]. In general, 
the battery consumption is still one of the critical aspects for 
modern mobile devices. Users are still complaining about 
devices that need to be recharged daily. Therefore, users are 
for sure not interested in technical solutions that 
unnecessarily exploit the battery life of their mobile devices.  
In order to investigate the battery consumption of the 
described technical implementation, a small testing scenario, 
based on the ideas described in [12], was implemented. With 
a set of five equal mobile devices (Android based mobile 
phones) the following test procedure was implemented. 
As described in [13] each and every service running on 
the device might be the reason for a significantly higher 
amount of power, and therefore battery consumption. In 
order to test the effect that the described approach has on the 
battery consumption, the following steps were conducted. 
For the first step the battery of each device was 
completely loaded and a little software was implemented that 
measured the actual status of the battery each ten minutes. 
This software allowed the measurement of the battery 
consumption for each single device. Within the first step, no 
other application (beside the usual operating system services) 
was running on the devices and the device was connected to 
the local wireless LAN.  
In the second phase of the experiment, the described 
solution for the provision of mobile Web Service  was 
deployed to the same devices and the battery of the devices 
was completely loaded again. Still, the devices where 
connected to the local wireless LAN. The proxy architecture 
for the mobile Web Services was deployed to a server 
running at the Amazon AWS Cloud system. A very simple 

39
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
mobile Web Service was deployed on each of the devices, 
and the service polled every second for new service requests. 
Here, the decision for a simple Web Service, that only 
calculates the sum of two numbers, was taken, since this test 
was designed in order to provide a first inside of the battery 
consumption of the technology itself. Of course, the more 
complex the deployed mobile Web Service gets, the more 
battery it will consume. Therefore, the concentration on a 
very simple service seemed reasonable for the results that the 
performed test should bring. Again, with the help of the 
software that allows the measurement of the battery status of 
the mobile devices, the battery consumption was measured 
every ten minutes.  
The results show that the battery consumption differs of 
course a little bit from device to device. Anyway, in average 
the five mobile devices still had about 91.2% of their battery 
capacity available after a twelve hours test run and the 
consumption took, as it could be assumed also beforehand, 
an almost linear degression. 
The results for the second phase, in which the mobile 
Web Service was deployed to each of the mobile devices 
show also an almost linear degression of the battery power, 
but in this case the devices had only 85.2% of their battery 
load left after another twelve hours test run. The difference 
becomes  clearer by comparing only the average values, as 
shown in Figure 8. 
 
 
Figure 8. Comparison of the average values for the two different 
phases. 
 
Here it can be seen that the average power consumption 
of the devices running the mobile Web Service with the 
described approach, is bigger than for the devices that are not 
running the mobile Web Service. 
In order to check whether the difference between the 
power consumption is statistically significant, a simple t-test 
was conducted over the data provided by the experiment. 
Therefore, the hypothesis was:  
 
H0: Statistically the amount of power consumed by the 
mobile Web Service deployed to each mobile device is 
different from zero. 
 
In order to test this hypothesis the difference between the 
measured battery status for the experiment with and without 
the mobile Web Service running on the mobile device was 
calculated for every measuring point. Afterwards, with the 
help of the average of the calculated differences, the standard 
deviation, the number of measurements and the control value 
(which is actually zero in this case, since the hypothesis was 
chosen that the amount of consumed power is different from 
zero), the according t-value was calculated. The results of 
this test show significant values for n = 72 (the number of 
measurements) and α = 0.01. Therefore, the hypothesis H0 
can be seen as correct and we can assume that the deployed 
mobile Web Service is using around 6% of additional 
energy.  
Having in mind that battery consumption is still a critical 
issue for owners of mobile devices, the consumption of at 
least additional 6% of their battery for a simple service with 
a polling interval of about a second, does not seem to be 
feasible. 
On the other hand, the measured battery consumption 
might also lead to the question what kind of scenarios can be 
supported with the help of the described technology. Since 
the results of the performed test show that there is a 
significant amount of the battery consumed by the presented 
technology, also if the deployed mobile Web Service is itself 
not at all complex and the polling interval is just about each 
second, the solution might probably be to identify scenarios 
in which the polling interval for the provided services on the 
mobile device is significantly longer than one second. 
VII. DEVELOPMENT OF SCENARIOS THAT BENEFIT FROM 
MOBILE WEB SERVICES 
As already indicated in the previous section, beside the 
technical feasibility of the described technical solution as 
explained in this paper, the development of scenarios that 
benefit from Web Services deployed to mobile devices is a 
critical issue in order to make this technology a success. 
Usually, Web Services are deployed on large servers in 
data center environments in order to provide at least one of 
the following three different benefits to the consumer of such 
a Web Service: 
 
• 
Access to large computing resources, e.g. 
computational power or memory 
• 
Access to large databases that cannot be stored 
locally 
• 
Access to data and/or procedures that are not 
available locally 
 
Obviously, the provision of Web Services on mobile 
devices is not interesting for the first two scenarios, since 
mobile devices do usually not provide enough power neither 
with respect to computational power nor with respect to the 
amount of the provided memory. Also, large databases are 
usually not installed on mobile devices for similar reasons. 
Therefore, the only possibility for reasonable approaches 
in which scenarios might benefit from Web Services 
deployed to mobile devices is the last one, in which these 

40
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
mobile Web Services either provide access to certain data 
and/or procedures especially available on mobile devices. 
Following this idea, one of the major advantages of  
todays modern mobile devices is that they are more of a set 
of sensors rather than a single device: looking at a modern 
mobile phone, these devices usually encapsulate a GPS 
sensor, a digital compass, an acceleration sensor, … Most of 
these sensors allow to easily contextualize the user in his/her 
current situation, e.g., the GPS sensor can be used in order to 
determine the actual position of the user of the mobile 
device, additionally the digital compass provides the 
direction in which the user is probably looking currently.  
Therefore, scenarios that on the one hand need to 
contextualize a single user, e.g., supporting the user in 
finding the fastest way to work or providing commercials for 
goods the user can buy in a store close to his/her current 
position and in his/her current viewpoint. On the other hand 
these kinds of scenarios typically do not need poll 
permanently for actual information, e.g., determine the actual 
temperature at the current position of the user, are ideal 
candidates to consume services provided by mobile devices. 
Another type of scenarios in which the usage of mobile 
Web 
Services 
seem 
reasonable, 
are 
scenarios 
that 
concentrate more on procedures where the user of a mobile 
device is actively integrated. Here, scenarios that need fast 
feedback from users might benefit from reaching users that 
are currently mobile, e.g., crowd sourcing [14]. Also a 
combination of both ideas, like a short survey (consisting of 
a very limited number of questions) send to a customer that 
leaves a certain store about how he/she felt during his/her 
stay in the store might provide a reasonable scenario for 
mobile Web Services. 
In order to determine and evaluate different scenarios 
that might benefit from consuming mobile Web Services, the 
sensitivity model, as described in [15], might provide a 
reasonable approach in order to evaluate whether a certain 
scenario benefits from using mobile Web Services. This 
cybernetic based approach allows to evaluate different 
parameters with respect to their effectiveness in order to 
reach a certain goal, also if these parameters do interact with 
each other. Since usually the different parameters that are 
important for the success of a mobile application/service 
interact with each other, this approach seems to provide a 
good starting point for the evaluation of mobile Web 
Services. 
The basic steps that need to be performed in order to 
provide a sensitivity model are: 
 
• 
Description of the system: Here, the system 
itself in which the services are provided, has to 
be described. 
• 
Determination of different variables: In this step 
different variables of the system (with respect to 
the currently evaluated service) are determined. 
• 
Evaluation of relevance of the variables: Since 
so far the different variables are only 
determined, their relevance for the system has to 
be evaluated in a separate step. 
• 
Determination of the interaction of the different 
variables: Here, for each of the variables a value 
has to be determined, how much this variable 
interacts with any other variable in the system. 
• 
Clarification of the role of each variable: In this 
step, a role is attached to each variable that 
reflects e.g., how active and how critical this 
variable is in the system. 
 
With the help of this information, certain tests and 
simulation can be run against the set of variables that reflect 
their behavior in the system.  
VIII. CONCLUSIONS AND FUTURE WORK 
As demonstrated in this paper, todays’ modern and 
powerful mobile devices can be used as Web Service 
providers by using well-known and accepted standards and 
protocols. The presented approach is capable of solving 
some of the problems that usually occur while providing 
Web Services on mobile devices, e.g., the problem of 
constantly changing IP addresses. Furthermore, the overhead 
that is inherent (resulting in a transmission delay) in the 
presented approach does not seem to be a show stopper. As 
shown, the performance in commonly available mobile 
networks, like UMTS or GPRS, is comparable to common 
Web Service requests. 
It can, therefore, be concluded that the presented 
approach provides an interesting alternative to the common 
Web Service provisioning by using mobile devices that act 
as a server also from a technical point of view. It eliminates 
certain problems that usually occur if mobile devices provide 
Web Service provider infrastructures, and the resulting 
drawbacks from the performance point of view are 
acceptable. 
Having in mind the power that the presented approach 
would provide for new approaches and scenarios, it could be 
asserted that bringing Web Services to mobile devices will 
probably become more important in the future and that we 
will most likely see an increasing number of applications 
making use of that kind of technology. 
Anyway, as shown by the test of the battery consumption 
of the presented approach, the provisioning of mobile Web 
Services also provides a number of drawbacks. Here, it will 
be important in the future to develop scenarios that on the 
one hand actually benefit from using mobile Web Services 
and on the other hand try to decrease the battery 
consumption of the presented approach by lowering the 
polling interval accordingly. Therefore, a complete new 
understanding for Web Services needs to be established, with 
respect to mobile Web Services. As discussed, mobile Web 
Services do usually not provide additional computational 
power, access to more memory or access to large databases, 
but may provide access to data from personal sensors, e.g., 
for the contextualization of the user.  
On the other hand, other technologies, like C2DM 
(Cloud-to-Device-Management), 
an 
Android 
based 
technology that allows to send activation commands to a 
certain mobile device might help to further decrease the 

41
International Journal on Advances in Internet Technology, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/internet_technology/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
battery consumption for the provisioning of mobile Web 
Services. 
As also discussed in the last section, the development of 
scenarios that benefit from consuming mobile Web Services 
also need a new approach that on the one hand reflect the 
complexity for the evaluation of mobile scenarios in general 
and on the other hand the different view on mobile Web 
Services (in contrast to usual Web Services) as described 
above. 
The last two points, using other technologies like C2DM 
and the development and evaluation of scenarios with 
respect to using mobile Web Services, will be part of future 
investigations and research. 
ACKNOWLEDGMENT 
This work was partly supported by an Amazon AWS 
research grant. 
REFERENCES 
 
[1] M. Jansen, “About an Architecture That Allows to Become a 
Mobile Web Service Provider”, In: Proceedings of the 7th 
International Conference on Internet and Web Applications 
and Services (ICIW 2012), pp. 90-96. 
[2] IDC Worldwide Quarterly Mobile Phone Tracker (May 2013) 
[3] B. Tudor, C. Pettey, “Gartner Says Worldwide Mobile Phone 
Sales Grew 35 Percent in Third Quarter 2010”, Smartphone 
Sales 
Increased 
96 
Percent, 
Gartner, 
http://www.gartner.com/it/page.jsp?id=1466313, last visited 
19.11.2011 
[4] S. McFaddin, C. Narayanaswami, M. Raghunath, “Web 
Services 
on 
Mobile 
Devices 
– 
Implementation 
and 
Experience”, In: Proceedings of the 5th IEEE Workshop on 
Mobile Computing Systems & Applications (WMCSA’03), pp. 
100-109, Monterey, CA 
[5] S. Srirama, M. Jarke, W. Prinz, “Mobile Web Service 
Provisioning”, In: Proceedings of the Advanced International 
Conference 
on 
Telecommunications 
and 
International 
Conference on Internet and Web Applications and Services 
(AICT/ICIW 2006), p. 120,  Guadeloupe, French Caribbean 
[6] F. AlShahwan, K. Moessner, “Providing SOAP Web Services 
and REST Web Services from Mobile Hosts”, In: Fifth 
International Conference on Internet and Web Applications 
and Services (ICIW 2010), pp. 174-179. 
[7] L. Li, W. Chou, “COFOCUS – Compact and Expanded Restful 
Services for Mobile Environments”, In: Proceedings of the 7th 
International Conference on Web Information Systems and 
Technologies, pp. 51-60, Noordwijkerhout, The Netherlands 
[8] E. Gamma, R. Helm, R. Johnson, J. Vlissides, “Design Pattern 
– Elements of Reusable Object-Oriented Software”, pp. 185-
195, Addison-Wesley. 
[9] D. Svensson, “Assemblies of Pervasive Services. Dept. of 
Computer 
Science,” 
Institutional 
Repository 
– 
Lund 
University. 
[10] T. Kundu, K. Paul, “Android on Mobile Devices – An Energy 
Perspective”, In: Proceedings of the 10th IEEE International 
Conference on Computer and Information Technology (CIT 
2010)  
[11] A. N. Moldovan, O. Ormond, G.-M. Muntean, “Energy 
consumption analysis of video streaming to Android mobile 
devices”, In: Proceedings of Network Operations and 
Management Symposium (NOMS), IEEE 
[12] F. Ding, F. Xia, W. Zhang, X. Zhao, C. Ma, “Monitoring 
Energy Consumption of Smartphones”, In: Proceedings of the 
1st International Workshop on Sensing, Networking, and 
Computing with Smartphones 
[13] A. Caroll, G. Heiser, “An analysis of power consumption in a 
smartphone”; In: Proceedings of the 2010 Annual Technical  
Conference on USENIX 
[14] S. Roth, “The Diaspora as a Nation’s Capital: Crowdsourcing 
Strategies for the Caucasus”, International Journal of 
Transition and Innovation Systems 1(1), pp. 44-58. 
[15] F. Vester, “The Art of interconnected thinking: Tools and 
concepts for a new approach to tackling complexity”, pp. 149-
256, McB 
 
 
  
 
 

