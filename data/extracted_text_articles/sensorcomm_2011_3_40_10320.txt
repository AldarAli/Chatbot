Time Synchronization for Resource-Constrained Multi-Hop Wireless Sensor
Networks based on Hop Delay Estimation
Ville Kaseva, Timo D. Hämäläinen, Marko Hännikäinen
Tampere University of Technology, Department of Computer Systems
P.O.Box 553, FI-33101 Tampere, Finland
{ville.a.kaseva, timo.d.hamalainen, marko.hannikainen}@tut.ﬁ
Abstract—Ultra
low-power
Wireless
Sensor
Networks
(WSNs) use duty cycled medium access protocols and dynamic
routing for multi-hop communication. Transmitted packets
can have variable delays and routes. Thus, data timestamps
and temporal order of the packets are unknown. However,
timing information is essential for many WSN applications. In
this paper, we present a novel time synchronization protocol
for application packets in multi-hop WSNs. The proposed
protocol is based on calculating delays as packets traverse from
node to node. It provides high energy-efﬁciency by minimizing
communication overhead. Fault tolerance is achieved by fully
distributed operation. The protocol computational complexity
is low, including only simple operations. We experimented the
proposed protocol using real WSN hardware communicating
in 2.4 GHz radio band. The maximum synchronization errors
ranged from 72 µs to 909 µs, and the average errors from
20 µs to 153 µs when the hop count was varied from two to
six and varying protocol parameters were used. With values
extrapolated from the experimental results, the maximum error
was 15 ms, which occurred with 100 hops. The paper presents
the design, implementation, and experimental results for low-
complexity synchronization protocol with maximum errors
ranging from 72 µs to 15 ms with varying network sizes.
Keywords-Wireless Sensor Networks; Time synchronization.
I. INTRODUCTION
Ubiquitous computing requires small and low-cost devices
embedded into everyday objects. Wireless Sensor Networks
(WSNs) form a key building block in the construction
of these smart environments. WSNs consist of densely
deployed, independent, and collaborating low-cost sensor
nodes, which are highly resource-constrained in terms of
energy, processing, and data storage capacity [1]. The nodes
can sense their environment, process data, and communicate
over multiple short distance wireless hops. The network self-
organizes and implements its functionality by co-operative
effort. WSN nodes must operate for years with small bat-
teries or by harvesting their energy from the environment.
Minimizing communication is essential in achieving energy-
efﬁciency since the radio transceiver is the most power-
consuming component in a WSN node [2].
Ultra low-power WSNs use duty cycled Medium Access
Control (MAC) protocols and autonomous dynamic routing.
The nodes are active only a fraction of the time and the
routes of subsequent packets can differ. This results in
unknown sensing times, variable forwarding delays, and
unguaranteed temporal order of the packets. However, many
applications require that timing information of sensed phe-
nomena can be resolved. In basic monitoring, it is usually
critical to know the actual sensing times of the reported
values. Furthermore, e.g., inferring target velocity from a
series of proximity detections [3] requires that the order of
(inferring) the sensed events is known.
The most straightforward way for obtaining accurate
time information would be to equip every node with a
Global Positioning System (GPS) receiver, Universal Time
Coordinated (UTC) signal receiver or an accurate atomic
clock. However, this would be infeasible in WSN nodes due
to increased size, cost, and energy consumption. Although
effective in the Internet, the widely used Network Time
Protocol (NTP) [4] is too inﬂexible for WSNs with ad-hoc
operation [5].
Commonly, WSN synchronization protocols target at
achieving common time locally among a set of neighboring
nodes or globally to the whole network. In these, the
synchronization protocol operation is fully de-coupled from
application-level operation resulting in continuous common
time keeping among the nodes. Thus, there is constant
synchronization overhead and the overhead is also included
in nodes that do not require time information. In these
protocols, the time service quality is common to every node
and application. This may result in unnecessary accuracy and
overhead for some applications, and redundant synchroniza-
tion overhead during periods time information is not actually
needed.
In this paper, we present a delay-based time synchroniza-
tion (D-DYNC) protocol for application-level time resolu-
tion in multi-hop WSNs. The proposed protocol is based on
calculating delays as packets traverse from node to node. D-
SYNC provides following key beneﬁts compared to related
protocols:
• High energy-efﬁciency: D-SYNC does not require ex-
plicit messaging to achieve synchronization. The delay
information is piggybacked in application packets. The
timing accuracy can be adjusted with simple delay ﬁeld
shift operations according to application requirements.
This adjustment minimizes the packet delay ﬁeld size,
79
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

and thus, the transmitted overhead data while providing
required accuracy. Synchronization can be switched on
on-demand only for required time periods, e.g., when
a speciﬁc event is sensed. These characteristics min-
imize the communication overhead, and thus, energy
consumed by the radio.
• Fault tolerance: D-SYNC is fully distributed having
no dedicated time reference nodes nor single points of
failure. In dynamic WSNs, there may be periods when
nodes are not in the radio range of any other nodes in
the network or multiple re-transmissions are required
due to poor links. D-SYNC can still maintain timing for
the buffered packets and the buffers can be unloaded
as connectivity is re-established.
• Minimal computational complexity: The complexity
of the D-SYNC protocol is low including only times-
tamp value saving, delay calculation using subtraction,
and shifting for timing accuracy adjustment.
We present a mathematical analysis and prototype experi-
ments for the D-SYNC protocol. The mathematical analysis
provides tools for estimating the maximum achievable accu-
racy and the required minimum delay ﬁeld width for variable
WSN deployments. We experimented the D-SYNC protocol
with real resource-constrained WSN nodes. Accuracy results
are presented for varying hop and delay ﬁeld shift amounts.
The used hardware is typical for resource-constrained WSN
nodes having a simple 8-bit microcontroller with 2 MIPS
performance for processing and a low-power low-cost 2.4
GHz radio for communication. The radio frame length is
32 B requiring minimal protocol overhead for maximizing
application payload data content in the packet.
The rest of this paper is organized as follows. The related
work is presented in Section II. The D-SYNC design and
mathematical analysis are presented in Section III. Sec-
tion IV introduces the used prototype hardware platform.
The experiments and results are presented in Section V.
Finally, Section VI concludes the paper and present the
future work.
II. RELATED WORK
Next, we present the most essential multi-hop time syn-
chronization protocols proposed for WSNs surveyed, e.g., in
[5] and [6]. The protocols represent fundamental approaches
to clock synchronization [6]. We compare them against D-
SYNC beneﬁts listed in the previous section.
The Timing-sync Protocol for Sensor Networks (TPSN)
[7], the Lightweight Tree-based Synchronization (LTS) pro-
tocol [8], the Delay Measurement Time Synchronization
(DMTS) protocol [9], and the TSync protocol [10] use
a dedicated time reference node, a tree structure, and
periodical synchronization messages forwarded throughout
the tree. In these, the periodical synchronization message
exchanges inﬂict continuous energy consumption overhead
to the nodes. Fault tolerance against lost time reference
node is not considered at all or is mitigated by using
several reference nodes, which are chosen using a leader
election algorithm. In either case, single points of failure,
the reference node(s), exist in the network.
LTS and TSync provide also a de-centralized version
where nodes can query time information from a reference
node. In these, the messaging overhead is large since the
queries have to be ﬁrst forwarded to the reference node,
possibly via multiple hops, and then synchronization is
achieved by reversing the path of the query.
The Flooding Time Synchronization Protocol (FTSP)
[11] ﬂoods synchronization messages, originating from a
reference node, periodically through the network inﬂicting
signiﬁcant continuous energy consumption overhead. There
is no single point of failure since any node in the network
can act as the time reference.
In Reference-Broadcast Synchronization (RBS) [12],
clock parameters are exchanged with every neighboring
node. This method incurs signiﬁcant messaging overhead
and energy consumption penalty, which increases with the
density of the nodes. RBS reduces the overhead with on-
demand post-facto synchronization in situations where con-
tinuous synchronization is not not needed. Still, when con-
tinuous synchronization is required, a constant messaging
overhead occurs also in RBS.
The protocol presented in [13] achieves multi-hop syn-
chronization using a tree structure. The periodical syn-
chronization message exchanges inﬂict continuous energy
consumption overhead to the network. Also, since clock
parameters are exchanged with every neighboring node, with
which synchronization is required, the overhead increases
with the synchronized neighbor amount.
The Time-Diffusion synchronization Protocol (TDP) [14],
and the protocol proposed by Li et al. [15] achieve network
wide time by co-operative effort of all the nodes in the
network. The complexity of both protocols is high requiring
lot of messaging [5]. The protocols do not rely on a single
reference node increasing fault tolerance.
III. D-SYNC DESIGN
The D-SYNC protocol is based on calculating cumulative
delay for a packet as it traverses via a multi-hop network.
Each synchronized packet includes a delay ﬁeld, which is
updated at every hop. Every node forwarding a synchronized
packet adds the local delay incurred by that node using its
local clock. Using this delay value included in the packet,
a destination node can resolve the source event time in its
local time base.
A. Single-Hop Delay Calculation
The undeterministic delays during a packet exchange are
the main contributors for synchronization inaccuracy. The
total delay incurred by one packet exchange can be divided
80
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

into send, access, transmission, propagation, and receive
delays [16]:
• The send delay includes the time spent at the source
node to construct the packet, the delays incurred by
the operating system, the buffering delays including
re-tranmsissions, and the time required to transfer the
packet to the MAC layer for transmission. The send
delay is undeterministic and highly variable.
• The access delay includes the time spent waiting for
access to the wireless communication medium. It de-
pends on the used MAC protocol. The access delay is
undeterministic and can be highly variable.
• The transmission delay (ttx) refers to the time it takes
to transmit a single packet over the wireless medium. It
is directly proportional to the length of the transmitted
packet and inversely proportional to the radio data rate
making it relatively deterministic. This delay also in-
cludes deterministic and undeterministic radio speciﬁc
delays. An example of a deterministic radio delay is
the radio start-up transient time, during which the radio
hardware is powered up.
• The propagation delay changes as a function of dis-
tance. For radio waves it is below 1 µs for distances
under 300 m. The ns scale error caused by it does not
contribute signiﬁcantly to the error budget of synchro-
nization in WSNs [12] and is considered to be zero.
• The reception delay consists of the time it takes for
the radio receiver to process the incoming bits and
notify the host of packet arrival. Commonly, much of
the physical packet processing is done in the radio
hardware and a packet is delivered to the host via a
digital interface. Thus, this delay is relatively small. The
undeterministic components can be mainly contributed
to the small variability in interrupt latencies.
• The receive delay includes the time required to transfer
the packet to the receiving layer. It includes the delays
incurred by the operating system and the buffering
delays. The receive delay is undeterministic and highly
variable.
The operation principle for calculating single hop delay
in the D-SYNC protocol is illustrated in Figure 1. A packet
is triggered for transmission at time t0 at the source Node
i. The time value is saved to internal packet data structure
in the local time of Node i, Li(t0), where Li(tk) denotes
real time tk in the time base of node i. After t0, the packet
is constructed and scheduled for transmission. Just prior to
transmission, at time t1, the delay value is calculated using
the previously saved and current time values. This delay is
inserted to the packet at the MAC protocol or the radio driver
(depends on implementation speciﬁcs). The calculated delay
value is Li(t1)−Li(t0). Now, the packet is transferred to the
radio transceiver hardware, which transmits it after a radio
speciﬁc delay. Calculating the delay just before transmission
Reception delay
Receive delay
Transmission 
delay 
Trigger packet 
transmission, save 
current local time
Construct packet and 
schedule it for 
transmission
Send 
delay
Access 
delay
Propagation 
delay
Save RX time in 
interrupt service 
routine, add 
transmission 
delay, schedule 
frame for RX to 
the receiving layer
t0
t1
t2
t3
t4
Node i
(Packetsource)
Node j
(Packetrecipient)
Calculate delay, insert 
delay value to packet, 
start packet TX
Packet received 
→ Process or 
forward
Wait for medium access
Time
Figure 1. Example of single hop delay calculation. The total delay
incurred by one packet exchange can be divided into send, access,
transmission, propagation, and receive delays. By calculating delay
values just prior to transmission, the highly undeterministic delays
can be mitigated and delay estimation accuracy improved.
mitigates the highly variable send and access delays.
Furthermore, the time Li(t1) is again saved to the internal
packet structure in case the packet is not actually received by
the next hop node and re-transmission is needed. In the case
of re-transmission the additional delay can be calculated and
added to the current delay value using the saved time value
Li(t1) and the new transmission moment of the packet.
After the transmission delay (ttx) and the propagation
delay, the packet is received by the recipient Node j at time
t2. After interrupt latency, the recipient saves the reception
time of the packet Lj(t3). This saved value can be again used
for internal delay calculation at node j. Saving the time value
just after reception mitigates the highly variable reception
and receive delays. Furthermore, the transmission delay is
added to the packet delay at this stage due to successful
packet exchange. Thus, the only remaining inaccuracies
are the propagation delay and the possibly undeterministic
timing inﬂicted by the radio hardware.
B. Multi-Hop Delay Calculation and Time Resolution
To calculate the multi-hop delay, the single hop delay
calculation is performed at every hop and the resulting
delays added to the delay ﬁeld in the packet. This means
that also the inaccuracies accumulate hop-by-hop but are
minimized by low-level timestamping. An example of the
multi-hop delay calculation is presented in Figure 2. Node
1 schedules packet for transmission at time t0 and saves
time value L1(t0) to the internal packet data structure. The
physical packet transmission to the next hop (Node 2) is
started at at time t1. Thus, calculated delay from packet
81
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

t1
Node 1 
(Source)
t2
t3
t4
t0
t5
t6
Node 2
Node 3
Node 4 
(Destination)
Node 1 
(Source)
Node 2
Node 3
Node 4 
(Destination)
t7
1) Processing at node, buffering, 
channel access delay, re-
transmissions...
2) Transmission and 
propagation delays
Time
1)
2)
Calculate internal delay 
from packet construction 
to TX, insert delay value 
to transmitted packet 
Calculate internal delay 
from packet RX to TX 
and add to packet delay 
value
Calculate internal delay 
from packet RX to 
processing and add to 
packet delay value
Figure 2. To calculate the multi-hop delay, the single hop delay
calculation is performed at every hop and the resulting delays added
to the delay ﬁeld in the packet.
construction to transmission, inserted to the packet at Node
1, is L1(t1) − L1(t0).
A packet is received at Node 2 at time t2 and the time
value L2(t2) is saved. Also, the transmission time (ttx) of
the previous wireless packet exchange is added to the total
delay at this stage. The physical packet transmission to the
next hop (Node 3) is started at at time t3. Thus, calculated
delay from packet reception to transmission, added to the
packet delay ﬁeld at Node 2, is L2(t3) − L2(t2) + ttx.
Similarly, the added delay at Node 3 is L3(t5)−L3(t4)+ttx.
Finally, the packet is received at the destination, Node 4,
at time t6. Again, the packet reception time is saved as the
local time of Node 4, L4(t6). The ﬁnal delay, from reception
to actual processing moment, added at Node 4, is L4(t7) −
L4(t6) + ttx.
Thus, the remove event time (t0), as estimated by the
destination Node 4 at time t7 in its local time base, is
L4(t7) − tdelay, where tdelay is the cumulative delay value
obtained from the received packet. Since all the delay
calculations are done locally no continuous synchronization
nor time base conversions are required.
In general, the remote event time for packet k (tpkt(k)) in
the time base of destination node i is
Li(tpkt(k)) = Li(tpr) − tdelay(k),
(1)
where tpr is time the packet is processed at the destination,
and tdelay(k) is the cumulative delay value for packet k
obtained from the packet.
C. Accuracy and Resource Consumption
There is a tradeoff between the maximum achievable
accuracy and the amount of used bits for synchronization
messaging (overhead). These can be be varied by simple
shift operations. When the delay ﬁeld is shifted to the right
the least signiﬁcant bits are lost but most signiﬁcant bits are
Accelerometer
Push button and 
LEDs
Batteries
Radio
Antenna
Figure 3. Prototype hardware platform circuit board.
gained. This results in lower accuracy but less overheard bits
and larger maximum delay value.
Thus, the delay ﬁeld overhead can be minimized when
the scale of required accuracy, maximum number of hops in
the WSN, and the worst case hop delay can be estimated.
On the other hand, the shifting enables graceful degradation
of accuracy at run-time. With a ﬁxed delay ﬁeld width, the
ﬁeld overﬂow can be monitored hop-by-hop and additional
shifting can be used when required.
With shift amount of S bits, the maximum achievable
accuracy in ticks (ε) is given by
ε = 2S
(2)
and the maximum presentable delay in ticks (D) is
D = 2Nbits+S − 1,
(3)
where Nbits is the number of bits in the delay ﬁeld.
E.g., for a WSN where maximum number of hops is 20,
the worst case hop delay is 10 s, and the internal clock tick in
the nodes is 1 µs, the maximum achievable accuracy values
and presentable delays with varying delay ﬁeld widths are
as follows.
With an 8-bit delay ﬁeld the required shift amount is 20
bits resulting in maximum accuracy of 1 s and maximum
presentable delay of 268 s. The corresponding values for
16-bit and 24-bit delay ﬁelds are shift of 12 and 4 bits, and
maximum accuracy of 4 ms and 16 µs, respectively. For 16-
bit and 24-bit delay ﬁelds the maximum presentable delay is
268 s with the given shift values. With a 32-bit delay ﬁeld, no
shift is required, maximum accuracy is 1 µs corresponding
to one clock tick, and the maximum presentable delay is
4295 s.
IV. PROTOTYPE HARDWARE PLATFORM
The prototype hardware platform is presented in Figure 3.
The platform uses a Microchip PIC18F8722 MCU, which
integrates an 8-bit processor core with 128 kB of FLASH
program memory, 4 kB of RAM data memory, and 1 kB
EEPROM. The used clock speed of the MCU is 8 MHz
resulting in 2 MIPS performance.
For wireless communication the platform uses a Nordic
Semiconductor nRF24L01 radio transceiver operating in the
2.4 GHz ISM frequency band. The radio data rate is 1 Mbps
and there are 80 available frequency channels. Transmission
power level is selectable from four levels between -18 dBm
and 0 dBm with 6 dBm intervals and ±4 dBm accuracy.
Loop type antenna is implemented as a trace on the Printed
Circuit Board (PCB).
82
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

Packet source and final destination node
Intermediate node
Hop 1
Hop 2
Hop 3
Hop 4
1. Save packet TX time using local clock
2. Save packet RX time using local clock
3. Calculate real delay using saved values
4. Compare real delay to D-SYNC delay
1. Add cumulative 
delay (D-SYNC)
2. Forward packet to 
next hop
Figure 4. Example experimental scenario for 4 hops. The packet
traverses a loop and source node local clock is used as a reference.
The platform is equipped with a 32.768 kHz crystal for
real-time clock implementation. This results in clock reso-
lution of approximately 30 µs. The resolution is enhanced
by using the MCU’s own oscillator and delay loops for ﬁne
timing below 30 µs.
V. EXPERIMENTS AND RESULTS
For the experiments, the D-SYNC protocol was imple-
mented on the prototype hardware platform. For communi-
cation, a multi-hop protocol stack implementation with ﬁxed
routing and ﬁxed one second delay per hop was used. A
ring topology was used to implement scenarios with varying
amount of hops. An example of the topology with 4 hops
is illustrated in Figure 4. The scenarios are general as the
path traversed by a single packet can always be reduced to
a simple chain of nodes independent of the actual network
topology used.
The experimental scenarios consisted of 2, 4, and 6 hops.
Each of the three scenarios was experimented with no
shift, giving a time resolution of 1 µs, and with shift of
8 bits, giving a time resolution of 256 µs. For each test,
the packet was transmitted 100 times, of which maximum
delay errors and average delay errors were calculated. It
must be noted that the experimented scenarios represent a
subset of possible scenarios that can occur in a WSN. The
number of hops, the length of channel access delays, and
the required shift amount can have variations. These are
inherently handled by the D-SYNC protocol. The presented
experimental setup provides a well-deﬁned and reproducible
framework for estimating the orders of magnitude of achiev-
able accuracy. Furthermore, it gives total control over the
scenario parameters.
In the experiments, the source node was set to be also the
ﬁnal destination node letting the transmitted packet traverse
a loop. Upon transmitting a packet, the source node saved
the initial packet transmission time and after reception the
reception time. Using these times a reference delay was
calculated. The intermediate nodes forwarded the packet
and added the cumulative delay value given by the D-
SYNC protocol. The reference time value was compared
to the value given by the D-SYNC protocol for calculating
accuracy results.
The results are presented in Figure 5. With shift of 8
0
2
4
6
0
200
400
600
800
1000
1200
Number of hops
Delay error [µs]
 
 
Max, 8−bit shift
Max, no shift
Avg, 8−bit shift
Avg, no shift
Figure 5. D-SYNC delay error as a function of hop count.
0
20
40
60
80
100
0
5
10
15
Number of hops
Delay error [ms]
 
 
Max, 8−bit shift
Max, no shift
Avg, 8−bit shift
Avg, no shift
Figure 6. D-SYNC delay error results with least squares linear
ﬁtting and extrapolation to 100 hops.
bits, the maximum synchronization errors were 300 µs for
2 hops, 573 µs for 4 hops, and 909 µs for 6 hops. The
corresponding values with no shift were 72 µs, 194 µs, and
223 µs, respectively. With the 8-bit shift, average errors were
60 µs, 76 µs, and 153 µs with the given hop amounts. The
corresponding average values with no shift were 20 µs, 105
µs, and 118 µs, respectively.
The results show an almost linear increase in delay as
the hop count increases. Figure 6 presents least squares
linear ﬁt of the results extrapolated to 100 hops. Using these
values the synchronization error can be estimated beyond the
experimented 6 hops. With shift of 8 bits, for 25, 50, 75,
and 100 hops, the estimated maximum errors are 3.7 ms, 7.5
ms, 11.2 ms, and 15.0 ms, respectively. The corresponding
values with no shift are 1.0 ms, 2.0 ms, 3.0 ms, and 4.0
ms. With the 8-bit shift, for 25, 50, 75, and 100 hops, the
estimated average errors are 0.6 ms, 1.2 ms, 1.8 ms, and 2.4
ms, respectively. The corresponding values with no shift are
0.5 ms, 1.1 ms, 1.6 ms, and 2.2 ms.
The main error source in the experiments was the real-
time clock of the used prototype platform. The usage of
delay loops for ﬁne timing produces inaccuracies when clock
resolution is below 30 µs. First, this incurs error in the actual
delay calculation. Furthermore, the same clock is used at the
83
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

radio driver. This causes errors in the packet transmission
times and packet reception time registering.
The results show that the shifting has an obvious impact
on the maximum synchronization errors, which accumulate
when the hop count increases. However, the difference
between the average synchronization errors between the 8-
bit shift and no shift is much smaller. With the experimented
four hops the average synchronization error was even smaller
with the 8-bit shift compared to no shift. The surprisingly
small difference in the average synchronization errors can be
explained by the fact that with the 8-bit shift the maximum
error ﬂuctuated between positive and negative and was
almost equal to both directions whilst with no shift the
maximum error was almost always positive.
VI. CONCLUSION AND FUTURE WORK
In this paper, we presented D-SYNC time synchroniza-
tion protocol for multi-hop WSNs. The proposed protocol
is based on multi-hop delay calculation for synchronized
packets. High energy-efﬁciency is achieved by minimizing
communication overhead. Accuracy versus overhead tradeoff
can be adjusted using simple shift operations. Timing is
maintained on-demand removing redundant overhead when
synchronization is not needed. D-SYNC operation is fault
tolerant having no single points of failure and supporting
disconnected periods. The protocol complexity is low, in-
cluding only timestamp value saving, delay calculation using
subtraction, and shifting for timing accuracy adjustment.
We presented a mathematical analysis and tools for es-
timating the D-SYNC accuracy and overhead tradeoff. D-
SYNC was implemented on real resource-constrained WSN
nodes and its accuracy was experimented with variable hop
and shift amounts. The maximum synchronization errors
ranged from 72 µs to 909 µs, and the average errors from
20 µs to 153 µs when the hop count was varied from two
to six and the shift amount was varied for zero to eight bits.
With values extrapolated from the experimental results, the
maximum error was 15 ms, which occurred with 100 hops
and 8-bit shift. The experiments show that the errors have a
predictable change when the hop amount increases and the
error remains in the ms-scale even for large networks.
Our future work concentrates on clock drift compensation
in the delay calculation. Synchronized MAC protocols rely
on accurate local synchronization among neighboring nodes.
This information can also be used to derive clock drift values
for the D-SYNC protocol.
REFERENCES
[1] I. Akyildiz, W. Su, Y. Sankarasubramaniam, and E. Cayirci,
“A survey on sensor networks,” Communications Magazine,
IEEE, vol. 40, no. 8, pp. 102–114, 2002.
[2] M. Kohvakka, J. Suhonen, M. Kuorilehto, V. A. Kaseva,
M. Hannikainen, and T. D. Hamalainen, “Energy-efﬁcient
neighbor discovery protocol for mobile wireless sensor net-
works,” Elsevier Ad Hoc Networks, 2008.
[3] A. Cerpa, J. Elson, M. Hamilton, J. Zhao, D. Estrin, and
L. Girod, “Habitat monitoring: application driver for wireless
communications technology,” in SIGCOMM LA ’01: Work-
shop on Data Communication in Latin America and the
Caribbean.
New York, NY, USA: ACM, 2001, pp. 20–41.
[4] D. Mills, “Internet time synchronization: the network time
protocol,” Communications, IEEE Transactions on, vol. 39,
no. 10, pp. 1482–1493, Oct 1991.
[5] B. Sundararaman, U. Buy, and A. D. Kshemkalyani, “Clock
synchronization for wireless sensor networks: a survey,” Ad
Hoc Networks, vol. 3, no. 3, pp. 281 – 323, 2005.
[6] Y.-C. Wu, Q. Chaudhari, and E. Serpedin, “Clock synchro-
nization of wireless sensor networks,” Signal Processing
Magazine, IEEE, vol. 28, no. 1, pp. 124 –138, 2011.
[7] S. Ganeriwal, R. Kumar, and M. B. Srivastava, “Timing-sync
protocol for sensor networks,” in SenSys ’03: Proceedings
of the 1st International Conference on Embedded Networked
Sensor Systems.
New York, NY, USA: ACM, 2003, pp.
138–149.
[8] J. V. Greunen and J. Rabaey, “Lightweight time synchro-
nization for sensor networks,” in WSNA ’03: Proceedings of
the 2nd ACM International Conference on Wireless Sensor
Networks and Applications.
New York, NY, USA: ACM,
2003, pp. 11–19.
[9] S. Ping, “Delay measurement time synchronization for wire-
less sensor networks,” Intel Research Berkeley Lab, Tech.
Rep. IRB-TR-03-013, june 2003.
[10] H. Dai and R. Han, “Tsync: a lightweight bidirectional
time synchronization service for wireless sensor networks,”
SIGMOBILE Mob. Comput. Commun. Rev., vol. 8, no. 1, pp.
125–139, 2004.
[11] M. Maróti, B. Kusy, G. Simon, and A. Lédeczi, “The ﬂooding
time synchronization protocol,” in SenSys ’04: Proceedings of
the 2nd International Conference on Embedded Networked
Sensor Systems.
New York, NY, USA: ACM, 2004, pp.
39–49.
[12] J. Elson, L. Girod, and D. Estrin, “Fine-grained network time
synchronization using reference broadcasts,” SIGOPS Oper.
Syst. Rev., vol. 36, no. SI, pp. 147–163, 2002.
[13] M. Sichitiu and C. Veerarittiphan, “Simple, accurate time
synchronization for wireless sensor networks,” in WCNC ’03:
Proceedings of the IEEE Conference on Wireless Communi-
cations and Networking, March 2003.
[14] W. Su and I. F. Akyildiz, “Time-diffusion synchronization
protocol for wireless sensor networks,” IEEE/ACM Trans.
Netw., vol. 13, no. 2, pp. 384–397, 2005.
[15] Q. Li and D. Rus, “Global clock synchronization in sensor
networks,” IEEE Trans. Comput., vol. 55, no. 2, pp. 214–226,
2006.
[16] H. Kopetz and W. Schwabl, “Global time in distributed
realtime systems,” Technishe Univesität Wien, Tech. Rep.
15/89, 1989.
84
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

