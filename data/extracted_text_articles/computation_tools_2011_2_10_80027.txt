Formal Veriﬁcation of Parameterized Multi-agent Systems Using Predicate
Diagrams*
Cecilia E. Nugraheni
Informatics Department
Parahyangan Catholic University
Bandung, Indonesia
Email: cheni@unpar.ac.id
Abstract—This paper presents a formal diagram-based ver-
iﬁcation technique for multi-agent systems. A multi-agent
system is a collection of intelligent agents that interact with
each others and work together to achieve a goal. We view multi-
agent systems as parameterized systems which are systems
that consist of several similar processes whose number is
determined by an input parameter. The motivation of this
work is that by treating multi-agent systems as parameterized
systems, the speciﬁcation and veriﬁcation processes can be
done in the same way regardless of the number of agents
involved in the multi-agent systems. In this paper, we show how
predicate diagrams* can be used to represent the abstractions
of parameterized multi-agent systems described by speciﬁca-
tions written in TLA*. The veriﬁcation process is done by
integrating deduction veriﬁcation and algorithmic techniques.
The correspondence between the original speciﬁcation and
the diagram is established by non-temporal proof obligations;
whereas model checker SPIN is used to verify properties over
ﬁnite-state abstractions.
Keywords-multi-agent systems; parameterized systems; veriﬁ-
cation; predicate diagrams*; TLA*; TLA+.
I. INTRODUCTION
A multi-agent system is understood as a collection of
intelligent agents, in this case are software or programs that
interact with each others and work together to achieve a
goal. Sycara [22] said that ”Agent-based systems technology
has generated lots of excitement in recent years because
of its promise as a new paradigm for conceptualizing,
designing, and implementing software systems. This promise
is particularly attractive for creating software that operates
in environments that are distributed and open, such as the
internet.” Because of this promise, many researches on
multi-agent systems have been conducted. Most of these
researches concentrate on the speciﬁcation and veriﬁcation
of the agents’ behaviors and the coordination among agents.
In this work, we focus on multi-agent systems which
consist of several similar processes. Having this property,
a multi-agent system can be viewed as a parameterized
system, which is a system that consists of several similar
processes whose number is determined by an input pa-
rameter. Many interesting systems are of this form. One
of them is mutual exclusion algorithms for an arbitrary
number of processes wanting to use a common resource.
The motivation of this work is that by treating multi-
agent systems as parameterized systems, the speciﬁcation
and veriﬁcation processes can be done more easily. Both
processes are expected to be done in the same way regardless
of the number of agents involved in the multi-agent systems.
Veriﬁcation consists of establishing whether a system sat-
isﬁes some properties, that is, whether all possible behaviors
of the system are included in the properties speciﬁed. It is
common to classify the approaches to formal veriﬁcation
into two groups, which are the deductive approach and
the algorithmic approach. The deductive approach is based
on theorem proving and typically reduces the proof of a
temporal property to a set of proofs of ﬁrst-order veriﬁca-
tion conditions. The most popular algorithmic veriﬁcation
method is model checking [6], [7], [21]. Although this
method is fully automatic for ﬁnite-state systems, it suffers
from the so-called state-explosion problem.
The need for a more intuitive approach to veriﬁcation
leads to the use of diagram-based formalisms. Basically, a
diagram is a graph whose nodes represent sets of system
states and whose edges represent the transition of the sys-
tems. Diagram-based approach combines the advantages of
deductive and algorithmic approach, which are the process
is goal-directed, incremental and can handle inﬁnite-state
systems.
In the context of parameterized systems, to provide
methods for the uniform veriﬁcation of such systems is a
challenging problem. One solution of this problem is to
treat or to represent a family of objects as a single syntactic
object. This technique is called parameterization.
In [20], a diagram-based veriﬁcation for parameterized
systems is proposed. The diagrams, which are called pred-
icate diagrams*, are variants of diagrams proposed by
Cansell et al. In [5], they presented a class of diagrams called
predicate diagrams and showed how to use the diagrams in
formal veriﬁcation. In [20], a little modiﬁcation of the deﬁni-
tion of the original predicate diagrams is made, in particular
the deﬁnition related to the actions. Instead of actions, the
new approach concentrates only on parameterized actions
which are actions of the form A(k). This form of actions is
usually used in modeling actions of a particular process in
19
COMPUTATION TOOLS 2011 : The Second International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-159-5

the system. TLA* [17] is used to formalize this approach
and TLA+ [13] style is used to write speciﬁcations.
This paper is structured as follows. Section II explains
brieﬂy the formal speciﬁcation of parameterized systems
in TLA*. Section III describes the deﬁnition and the use
of predicate diagrams* in the veriﬁcation of parameterized
systems. The next section describes the aplication of this
approach on a case study which is block world problem.
Discussion about the result and some related works are given
in Section V. Finally, conclusion and future work will be
given in Section VI.
II. PAMETERIZED SYSTEMS SPECIFICATION
This work is restricted to a class of parameterized systems
that are interleaving and consist of a ﬁnitely, but arbitrarily,
discrete components. Let M denote a ﬁnite and non-empty
set of processes running in the system. A parameterized
system can be described as a formula of the form:
parSpec ≡ ∀k ∈ M : Init(k) ∧ □[Next(k)]v[k] ∧ L(k).
where
• Init is a state predicate describing the global initial
condition,
• Next(k) is an action characterizing the next-state re-
lation of a process k,
• v is a state function representing the variables of the
system and
• L(k) is a formula stating the liveness conditions ex-
pected from the process or subsystem k.
III. PREDICATE DIAGRAMS*
Basically, a predicate diagram* is a ﬁnite graph whose
nodes are labeled with sets of (possibly negated) predicates,
and whose edges are labeled with actions as well as op-
tional annotations. This section gives a brief description of
predicate diagrams*. For a detail explanation for predicate
diagrams*, the readers may consult [20].
A. Deﬁnition
It is assumed that the underlying assertion language
contains a ﬁnite set O of binary relation symbols ≺ that
are interpreted by well-founded orderings. For ≺∈ O, its
reﬂexive closure is denoted by ⪯. We write O= to denote
the set of relation symbols ≺ and ⪯ for ≺∈ O.
Deﬁnition 1. Assume given two ﬁnite sets P and A of
state predicates and parameterized action names. A predicate
diagram* G = (N, I, δ, o, ζ) over P and A consists of :
• a ﬁnite set N ⊆ 2P of nodes where P denotes the set
of literals formed by the predicates in P,
• a ﬁnite set I ⊆ N of initial nodes,
• a family of δA where A ∈ A of relations δA⊆N×N;
we also denote by δ the union of the relations δA, for
A ∈ A and write δ= to denote the reﬂexive closure of
the union of these relations,
• an
edge
labeling
o
that
associates
a
ﬁnite
set
{(t1, 1), . . . , (tk, k)}, of terms ti paired with a relation
≺i∈ O= with every edge (n, m) ∈ δ, and
• a mapping ζ : A → {NF,WF,SF} that associates
a fairness condition with every parameterized action
in A; the possible values represent no fairness, weak
fairness, and strong fairness.
A parameterized action A ∈ A can be taken at node n ∈
N iff (n, m) ∈ δA holds for some m ∈ N. The set of nodes
where A can be taken is denoted by En(A) .
A run of a predicate diagram* is a sequence of triples, ρ =
(s0, n0, A0)(s1, n1, A1) . . . where si is a state, ni ∈ N is a
node and Ai ∈ A ∪ {τ} (τ denotes stuttering transition). A
trace through a predicate diagram*, σ = s0s1 . . ., is deﬁned
as the set of those behaviors that correspond to fair runs
satisfying the node and edge labels.
B. Veriﬁcation using predicate diagrams*
The veriﬁcation process using predicate diagrams* is done
in two steps. The ﬁrst step is to ﬁnd a predicate diagram*
that conforms to the system speciﬁcation. Theorem 1 is used
to prove the conformance.
Theorem 1. Let G = (N, I, δ, o, ζ) be a predicate diagram*
over P and and A, let parSpec = Init ∧ □[∃k ∈ M :
Next(k)]v ∧ ∀k ∈ M : L(k) be a parameterized system.
If all the following conditions hold then G conforms to
parSpec:
1) For all n ∈ I, |= Init → n.
2) |≈ n ∧ [∃k ∈ M : Next(k)]v →
n′ ∨
^
(m,A(k)):(n,m)∈δA(k)
⟨∃k ∈ M : A(k)⟩v ∧ m′
3) For all n, m ∈ N and all (t, ≺) ∈ o(n, m):
a) |≈ n ∧ m′ ∧
^
A(k):(n,m)∈δA(k)
⟨∃k ∈ M : A(k)⟩v → t′ ≺ t.
b) |≈ n ∧ [∃k ∈ M : Next(k)]v ∧ n′ → t′ ⪯ t.
4) For every parameterized action A(k) ∈ A such that
ζ(A(k)) ̸= NF:
a) If ζ(A(k)) = WF then
|= parSpec → WFv(∃k ∈ M : A(k)).
b) If ζ(A(k)) = SF then
|= parSpec → SFv(∃k ∈ M : A(k)).
c) |≈ n → ENABLED ⟨∃k ∈ M : A(k)⟩v holds
whenever n ∈ En(A(k)).
d) |≈ n ∧ ⟨∃k ∈ M : A(k)⟩v → m′ holds for all
n, m ∈ N such that (n, m) /∈ δA(k).
The second step of the veriﬁcation process is to prove
that all traces through a predicate diagram* satisfy some
property F. In this step, a diagram predicate* is viewed as
a ﬁnite transition system. As a ﬁnite transition system, its
20
COMPUTATION TOOLS 2011 : The Second International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-159-5

Figure 1.
An example of block world problem.
runs can be encoded in the input language of standard model
checkers such as SPIN [3].
IV. THE BLOCK WORLD : A CASE STUDY
A. Problem statement
One of the most famous planning domains in artiﬁcial
intelligence is the block world problem. This problem can
be brieﬂy described as follows [23]: given a set of cubes
(blocks) on a table and two types of robots whose task is
to change the vertical stacks of blocks, from the initial con-
ﬁguration into a new different conﬁguration. It is assumed
that only one block may be moved at a time: it may either
be placed on the table or placed atop another block. Any
block that is, at a given time, under another block cannot
be moved. Each robot has different capability: one robot is
only capable of ’freeing’ one block from another, while the
other is only capable of ’moving’ one block and putting it
on top of another.
As illustration, Figure 1 shows an example of this prob-
lem. There are four blocks on the table. Each block is
labeled with a number. The left-hand side represents the
initial state of the world or initial conﬁguration, whereas the
right-hand side represents the goal (the ﬁnal conﬁguration)
to be achieved.
B. Speciﬁcation
From the problem statement, it is clear that the agents or
the robots in the block world problem are not homogeneous.
In order to model this problem as a parameterized system
as required, one simple solution is taken, which is: (1)
every robot is associated with an integer stating its type
and (2) the capabilities of every robot type’s are stated in a
separate action. This is done in order to give an impression
that the robots have different capabilities. Only now, an
additional condition or precondition is added to each action.
The homogeneity requirement is still guaranteed by using
the same Next action for each agent.
The speciﬁcation for the block world problem is given
in Figure 2. In this speciﬁcation we use a set of positive
integers, Blocks, to represent the collection of the blocks
and an array ag type to identify the agent’s type.
To represent the state or conﬁguration of the blocks,
we use an array whose elements are pairs of non-negative
integers. Each element represents the condition of a block.
isDone ≡ CState = FState
move(k) ≡ ∧ ¬isDone ∧ ag type[k] = 1
∧ ∃x, y ∈ Blocks :
∧ x ̸= y
∧CState[x] = ⟨0, 0⟩ ∧ CState[y][2] = 0
∧CState′ = [CState EXCEPT ![x][1] = y,
![y][2] = x]
free(k) ≡ ∧ ¬isDone ∧ ag type[k] = 2
∧ ∃x, y ∈ Blocks :
∧ x ̸= y
∧CState[x][2] = 0 ∧ CState[y][2] = x
∧CState′ = [CState EXCEPT ![x] = ⟨0, 0⟩,
![y][2] = 0]
Init ≡ ∧ CState = IState ∧ CState ̸= FState
∧ ∀k ∈ M : ag type[k] ∈ {1, 2}
Next(k) ≡ Move(k) ∨ Free(k)
L(k) ≡ WFv(Move(k))∧WFv(Free(k))
v ≡ ⟨CState⟩
BWorld ≡ ∧Init ∧ □[∃k ∈ M : Next(k)]v
∧∀k ∈ M : L(k)
Figure 2.
Speciﬁcation for Block World Problem.
For example, if the second element of the array is ⟨3, 1⟩
then it means that the block number 3 is under the block
number 2 and the block number 1 is on the block number 2.
A special number, 0, is used to represent table or nothing.
Thus, the initial conﬁguration of Figure 1 is represented
by ⟨⟨0, 2⟩, ⟨⟨1, 0⟩, ⟨0, 0⟩, ⟨0, 0⟩⟩ and the ﬁnal conﬁguration
is represented by ⟨⟨0, 3⟩, ⟨0, 0⟩, ⟨1, 0⟩, ⟨0, 0⟩⟩.
Three state arrays are used, which are IState, CState
and FState. Each array is used to represent initial, ﬁnal,
and current conﬁguration, respectively. Current conﬁguration
records the last conﬁguration of the system. The goal is
achieved whenever isDone is true, which means that the
current and the ﬁnal conﬁguration have the same values.
Action move(k) can be taken only by an agent whose
capability is to move a block from the table and put it
onto another block. Action free(k) can be taken only by an
agent whose capability is to free one block on the top of a
stack and put it on the table. Formula CState′ = [CState
EXCEPT![x][1] = y, ![y][2] = x] in move(k) action means
that except the values of CState[x] and CState[y], the
values of CState′ won’t change after the action is taken.
The values of Blocks, ag type, IState, and FState de-
pend on the problem instance at hand. If the number of boxes
and agent types change, we simply change Blocks and
ag types accordingly. This holds also for the capabilities
of the agents. We need only to add precondition to every
action as explained.
C. Veriﬁcation
We take a problem instance in Figure 1 for the veriﬁcation
purpose. The following formulas are added to our speciﬁca-
tion in Figure 2:
• Blocks ≡ {1, 2, 3, 4}
• IState ≡ ⟨⟨0, 2⟩, ⟨1, 0⟩, ⟨0, 0⟩, ⟨0, 0⟩⟩
21
COMPUTATION TOOLS 2011 : The Second International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-159-5

Figure 3.
Predicate diagrams* for Block World Problem.
• FState ≡ ⟨⟨0, 3⟩, ⟨0, 0⟩, ⟨1, 0⟩, ⟨0, 0⟩⟩
The veriﬁcation can be stated as to prove the following
theorem:
BWorld → □(Init → ♦isDone).
For the ﬁrst step, we have to ﬁnd a suitable predicate
diagram* for the BWorld. Figure 3 depicts one of the
possible predicate diagrams* for BWorld.
We set P to contain six predicates. The union of those
predicates deﬁne the properties of system’s states that hold
on every node. There are two predicates that are not written
explicitly, which are :k ∈ {1, 2} and ∀k ∈ M : ag type ∈
{1, 2}. These predicates hold on every node. We also use two
sets Moved and Freed which are sets of integers to indicate
the blocks that can be moved or can be freed, respectively.
It is assume that the following conditions hold:
• ∀i ∈ Blocks : i ∈ Moved ↔ (∃j ∈ Blocks : i ̸=
j ∧ CState[i] = ⟨0, 0⟩ ∧ CState[j][2] = 0)
• ∀i ∈ Blocks : i ∈ Freed ↔ (∃j ∈ Blocks : i ̸=
j ∧ CState[i]⟨j, 0⟩ ∧ CState[j][2] = i)
Using Theorem 1 it can be shown that the predicate
diagram* in Figure 3 conforms to the speciﬁcation in Figure
2. This is done by proving the following formulas:
• Init → ¬isDone ∧ ¬(CState = IState) ∧ Moved =
{3, 4} ∧ Freed = {2}
• ¬isDone ∧ ¬(CState = IState) ∧ Moved = {3, 4} ∧
Freed = {2} ∧ [∃ ∈ M : Next(k)]v →
(¬isDone′ ∧ ¬(CState′ = IState′) ∧ Moved′ = {3, 4} ∧
Freed′ = {2})∨
((⟨∃k ∈ M
: free(k)⟩v ∧ ¬isDone′ ∧ ¬(CState′ =
IState′) ∧ Moved′ = {3, 4} ∧ Freed′ = {2, 3, 4})∨
(⟨∃k ∈ M
: free(k)⟩v ∧ ¬isDone′ ∧ ¬(CState′
=
IState′) ∧ Moved′ = {} ∧ Freed′ = {1, 2, 3, 4}))
• ¬isDone∧¬(CState = IState)∧Moved = {}∧Freed =
{1, 2, 3, 4} ∧ [∃ ∈ M : Next(k)]v →
(¬isDone′ ∧ ¬(CState′ = IState′) ∧ Moved′ = {} ∧
Freed′ = {1, 2, 3, 4})∨
((⟨∃k ∈ M
: move(k)⟩v ∧ isDone′ ∧ ¬(CState′
=
IState′) ∧ Moved′ = {2, 4} ∧ Freed′ = {3})∨
(⟨∃k ∈ M
: move(k)⟩v ∧ ¬isDone′ ∧ ¬(CState′ =
IState′) ∧ Moved′ = {1, 2, 3, 4} ∧ Freed′ = {1, 2, 3, 4}))
• ¬isDone ∧ ¬(CState = IState) ∧ Moved = {1, 2, 3, 4} ∧
Freed = {1, 2, 3, 4} ∧ [∃ ∈ M : Next(k)]v →
(¬isDone′ ∧ ¬(CState′
=
IState′) ∧ Moved′
=
{1, 2, 3, 4} ∧ Freed′ = {1, 2, 3, 4})∨
((⟨∃k ∈ M
: free(k)⟩v ∧ (isDone′ ∧ ¬(CState′ =
IState′) ∧ Moved′
=
{} ∧ Freed′
=
{1, 2, 3, 4} ∨
¬isDone ∧ ¬(CState = IState) ∧ Moved = {1, 2, 3, 4} ∧
Freed = {1, 2, 3, 4}))∨
(⟨∃k ∈ M : move(k)⟩v ∧ ¬isDone′ ∧ (¬(CState′ =
IState′) ∧ Moved′ = {2, 4} ∧ Freed′ = {3} ∨ ¬isDone ∧
¬(CState = IState) ∧ Moved = {1, 2, 3, 4} ∧ Freed =
{1, 2, 3, 4}))
• (isDone ∧ ¬(CState = IState) ∧ Moved = {2, 4} ∧
Freed = {3}) ∧ [∃ ∈ M : Next(k)]v →
(isDone′ ∧ ¬(CState′ = IState′) ∧ Moved′ = {2, 4} ∧
Freed′ = {3})
• (¬isDone ∧ ¬(CState = IState) ∧ Moved = {3, 4} ∧
Freed = {2, 3, 4}) ∧ [∃ ∈ M : Next(k)]v →
(¬isDone′ ∧ ¬(CState′ = IState′) ∧ Moved′ = {3, 4} ∧
Freed′ = {2, 3, 4})∨
((⟨∃k ∈ M : free(k)⟩v∧(¬isDone′∧CState′ = IState′∧
Moved′ = {3, 4} ∧ Freed′ = {2}))∨
(⟨∃k ∈ M : move(k)⟩v ∧ ¬isDone′ ∧ (¬(CState′ =
IState′) ∧ Moved′ = {} ∧ Freed′ = {3, 4}))
• (¬isDone ∧ ¬(CState = IState) ∧ Moved = {} ∧
Freed = {3, 4}) ∧ [∃ ∈ M : Next(k)]v →
(¬isDone′ ∧ ¬(CState′ = IState′) ∧ Moved′ = {} ∧
Freed′ = {3, 4})∨
((⟨∃k ∈ M : free(k)⟩v ∧ (¬isDone′ ∧ ¬(CState′ =
IState′) ∧ Moved′ = {3, 4} ∧ Freed′ = {2, 3, 4})))
The next step we encode the diagram in the input language
of SPIN. We use 12 variables, which are:
• action and node to indicate the last action taken and
the current node,
• done to indicate whether isDone is true or not,
• cistate to indicate whether CState = IState is true
or not,
• m1, m2, m3, and m4 to represent predicate 1 ∈
Moved, 2 ∈ Moved, 3 ∈ Moved and 4 ∈ Moved,
respectively, and
• f1, f2, f3, and f4 to represent predicate 1 ∈ Freed,
2 ∈ Freed, 3 ∈ Freed and 4 ∈ Freed, respectively,
The theorem to be proven is now can be written as
□((¬done ∧ cistate ∧ ¬m1 ∧ ¬m2 ∧ m3 ∧ m4 ∧ ¬f1 ∧
f2 ∧ ¬f3 ∧ ¬f4) → ♦(done ∧ ¬cistate ∧ ¬m1 ∧ m2 ∧
¬m3 ∧ m4 ∧ ¬f1 ∧ ¬f2 ∧ f3 ∧ ¬f4)). Last, by using SPIN
we model-checked the resulted transition system. As result,
we concluded that the speciﬁcation satisﬁes the property we
want to prove.
V. RELATED WORK
Many works are devoted to the formal speciﬁcation of
multi-agent systems. Most of these works concentrate on the
speciﬁcation of the agents’ behaviors and the coordination
among agents. Abouaissa et al. [1] presented a formal
22
COMPUTATION TOOLS 2011 : The Second International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-159-5

approach for speciﬁcation of multi-agent systems. This ap-
proach is based on roles and organization notions and high-
level Petri nets and is applied on a multi-modal platform
associating combined rail-road transportation system. Mer-
ayom et al. [16] proposed a formalism called Utility State
Machines for specifying e-commerce multi agent systems.
Brazier et al. [3] used the DESIRE framework to specify
a real-world multi-agent application on a conceptual level.
Originally DESIRE is designed for formal speciﬁcation of
complex reasoning systems. Fischer and Wooldridge [9]
described ﬁrst step towards the formal speciﬁcation and ver-
iﬁcation of multi-agent systems, through the use of temporal
belief logics. This work is closed to the one of Taibi [23].
The similarity is that we use TLA-based to formalize our
approaches. However, Taibi’s work did not treat the multi
-agent systems as parameterized systems.
Besides formal speciﬁcation, formal veriﬁcation is also a
popular topic in the ﬁeld of multi-agent systems. Several
approaches can be found in [2], [10], [11], [15], [23].
In [11], Giese et al. presented an approach for making
complex multi-agent system speciﬁcations. Every speciﬁca-
tion includes a detailed environment model that amenable
to veriﬁcation. The veriﬁcation process is done by means
of simulation and formal veriﬁcation. Taibi used TLC,
the TLA model checker, to verify the speciﬁcation [23].
Gaud et al. proposed a formal framework based on multi-
formalisms language for writing system speciﬁcation and
used abstraction to reduce the state space of the system
[10]. Ayed et al. proposed a diagram-based veriﬁcation by
using AUML protocol diagrams for representing multi-agent
systems. These diagrams are then translated into event-B
language for veriﬁcation purpose [2]. In [15], Massaci et
al. concerned about the use of access control for limiting
the agent capability of distributed systems. They presented
a preﬁxed tableau method for the calculus of access control.
The calculus was the basis for the development and the
veriﬁcation of an implemented system.
Because diagrams can reﬂect the intuitive understanding
of the systems and their speciﬁcations, they are proposed to
be used for veriﬁcation. A diagram can also be seen as an
abstraction of the system, where properties of the diagram
are guaranteed to hold for the systems as well. In particular,
the use of diagrams in veriﬁcation of distributed systems
can be found; for example in [5] the author proposed the
use of predicate diagrams, introduced in [4], for analyzing
a self-stabilizing algorithm.
VI. CONCLUSION
We have shown how a multi-agent system can be viewed
and thus can be formally speciﬁed and veriﬁed as a param-
eterized system. In particular, we deﬁne a general form for
speciﬁcation of parameterized multi-agent systems in TLA*.
By considering a case study, we have shown that a multi-
agent system whose agents are not homogenous still can be
speciﬁed as a parameterized system.
In this paper, we have successfully write speciﬁcation and
verify the block world problem. This problem is an example
of multi-agent system whose agents are not homogeneous.
In order to fulﬁll the homogeneity requirement, we add
preconditions to actions in the speciﬁcation to guarantee that
only the appropriate agent may take a particular action. For
veriﬁcation process we use predicate diagram* to represent
the abstractions of the systems. The correspondence between
the original speciﬁcation and the diagram is established
by non-temporal proof obligations; whereas model checker
SPIN is used to verify properties over ﬁnite-state abstrac-
tions.
In the context of parameterized systems, there are two
classes of properties that may be considered, namely the
properties related to the whole processes and the ones related
to a single process in the system. It is planned to investigate
those properties of the block world problem. The veriﬁcation
will be conducted by using a diagram-based veriﬁcation
called parameterized predicate diagrams [18], [19].
REFERENCES
[1] H. Abouaissa, J.C. Nicolas, A. Benasser, and E. Czesnalow-
icz. Formal speciﬁcation of multi-agent systems: approach
based on meta-models and high-level Petri nets - case study
of a transportation system. Proceedings of IEEE International
Conference on Systems, Man and Cybernetics, Vol.5, pp. 429-
434, 2002.
[2] B. Ayed and F. Siala. Event-B based Veriﬁcation of Interaction
Properties In Multi-Agent Systems. Journal of Software, Vol.
4, No. 4, pp. 357-364, June 2009
[3] F. Brazier, B. Dunin-Keplicz, N.R. Jennings, and J. Treur.
Formal Speciﬁcation of Multi-Agent Systems: a Real World
Case. Proceedings of the First International Conference on
Multi-Agent Systems, ICMAS’95, MIT Press, Cambridge,
MA, 1995, pp.25-32.
[4] D. Cansell, D. M´ery, and S. Merz. Predicate diagrams for
the veriﬁcation of reactive systems. In 2nd Intl. Conf. on
Integrated Formal Methods IFM 2000, vol. 1945 of Lectures
Notes in Computer Science, pp. 380-397, 2000. Springer-
Verlag.
[5] D. Cansell, D. M´ery, and S. Merz. Formal analysis of a self-
stabilizing algorithm using predicate diagrams. GI Jahresta-
gung (1) 2001: 39-45.
[6] E.M. Clarke and E.A. Emerson. Characterizing correctness
properties of parallel programs using ﬁxpoints. International
Colloquim on Automata, Languages and Programming. Vol.
85 of Lecture Nodes in Computer Science, pp. 169-181,
Springer-Verlag, July, 1980.
[7] E.M. Clarke and E.A. Emerson. Design and synthesis of syn-
chronization skeletons using branching time temporal logic.
Workshop on Logic of Programs, Yorktown Heights, NY.
Vol. 131 of Lecture Nodes in Computer Science, pp. 52-71,
Springer-Verlag, 1981.
23
COMPUTATION TOOLS 2011 : The Second International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-159-5

[8] E. A. Emerson and K. S. Namjoshi. Veriﬁcation of a param-
eterized bus arbitration protocol. Volume 1427 of Lecture
Notes in Computer Science, pp. 452–463. Springer,1998.
[9] M. Fisher and M. Wooldridge. On the Formal Speciﬁcation
and Veriﬁcation of Multi-Agent Systems. Int. J. Cooperative
Inf. Syst., 1997: 37-66.
[10] N. Gaud. A Veriﬁcation by Abstraction Framework for orga-
nizational Multi-Agent Systems. Jung, Michel, Ricci and Petta
(eds.): AT2AI-6 Working Notes, From Agent Theory to Agent
Implementation, 6th Int. Workshop, May 13, 2008, AAMAS
2008, pp. 67-73, Estoril, Portugal, EU.
[11] H. Giese and F. Klein. Systematic veriﬁcation of multi-agent
systems based on rigorous executable speciﬁcations. Journal
International Journal of Agent-Oriented Software Engineer-
ing, Volume 1 Issue 1, pp. 28-62, April 2007.
[12] G. Holzmann. The SPIN model checker. IEEE Trans. On
software engineering, 16(5):1512-1542. May 1997.
[13] L. Lamport. The Temporal Logic of Actions. ACM Transac-
tions on Programming Languages and Systems, 16(3) : 872-
923, May 1994.
[14] Z. Manna and A. Pnueli. Veriﬁcation of parameterized pro-
grams. In Speciﬁcation and Validation Methods (E. Borger,
ed.), Oxford University Press, pp. 167-230, 1994.
[15] F. Massacci. Tableau Methods for Formal Veriﬁcation of
Multi-Agent Distributed Systems. Journal of Logic and Com-
putation, 8(3), 1998.
[16] M.G. Merayo. Formal speciﬁcation of multi-agent systems by
using EUSMs. Proceedings of the 2007 international confer-
ence on Fundamentals of software engineering, pp. 318-833.
[17] S. Merz. Logic-based analysis of reactive systems: hid-
ing, composition and abstraction. Habilitationsschrift. Institut
fr Informatik. Ludwig-Maximillians-Universitt, Munich Ger-
many. December 2001.
[18] C.E. Nugraheni. Predicate diagrams as basis for the veriﬁ-
cation of reactive systems. PhD Thesis. Institut fr Informatik.
Ludwig-Maximillians-Universitt, Munich Germany. February
2004.
[19] C.E. Nugraheni. Universal properties veriﬁcation of parame-
terized parallel systems. In Proceeding of the International
Confe-rence on Computational Scince and its Applications
(ICCSA 2005), Volume 3482 of Lecture Notes in Computer
Science, pp. 453-462. Springer, 2005.
[20] C.E. Nugraheni. Formal Veriﬁcation of Ring-based Leader
Election Protocol using Predicate Diagrams*. IJCSNS Vol.
9. no. 8, pp. 1-8, August 2009.
[21] J.P. Quielle and J. Sifakis. Speciﬁcation and veriﬁcation
of concurrent systems in CESAR. In M. Dezani-Cianzaglini
and Ugo Montanari, editors, International Symposium on
Programming. Volume 137 of Lecture Notes in Computer
Science, pp. 337-350. Springer-Verlag, 1981.
[22] K.P. Sycara. Multiagent Systems. AI Magazine, Vol 19, No
2, pp. 79-92, Summer 1998.
[23] T. Taibi. Formal speciﬁcation and validation of multi-agent
behaviour using TLA+ and TLC model checker. Int. J. Ar-
tiﬁcial Intelligence and Soft Computing, Vol. 1, No. 1, pp.
99-113, 2008.
24
COMPUTATION TOOLS 2011 : The Second International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-159-5

