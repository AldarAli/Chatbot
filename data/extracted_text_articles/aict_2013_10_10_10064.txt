Reduced Complexity Decision Feedback Channel Equalizer using Series
Expansion Division
S. Yassin, H. Tawﬁk
Department of Electronics and Communications
Cairo University Faculty of Engineering
Cairo, Egypt
syassin@eece.cu.edu.eg, Hazim.Tawﬁk@eece.cu.edu.eg
Abstract—Decision Feedback Equalizers (DFE) are used to
eliminate the effect of Inter Symbol Interference (ISI) in band
limited channels. The Recursive Least Squares (RLS) is one of
the algorithms that are used to update the coefﬁcients of the
equalizer due to its fast convergence. However, its complexity is
in the order of O(N 2) multiplication per iteration. Fast ﬁxed
order algorithms are used to solve the RLS algorithm using
explicit set of equations. Therefore, their complexity is in the
order of O(N). However, divisions are needed to perform these
algorithms, making it difﬁcult to choose the one with lower
computational cost. In this paper a new metric is proposed
to calculate a weight score for any algorithm. To verify the
validity of the proposed metric, the algorithms are compared
by a recent study of RLS based on Decent Coordinate Descent
(DCD) iterations using computer simulation. In addition, a new
method to optimize the weight score is proposed, by using
multiplicative techniques to perform divisions required for the
fast ﬁxed algorithms. Results have been veriﬁed by implementing
a DFE on Field Programmable Gate Array (FPGA).
Keywords-reduced complexity; channel equalization; signal processing;
division; multiplication.
I. INTRODUCTION
ISI is a common phenomenon encountered when recovering
band limited channels. ISI occurs if modulation bandwidth
increases beyond the channel coherence bandwidth [1]. Chan-
nel equalization is used to compensate for ISI at the receiver
to decrease the bit errors. In the family of DFE equalizers
the previous output decisions inﬂuence the current estimated
symbol [2]. Therefore, DFE has better tracking performance
than the family of linear equalizers when the channel has
severe distortion and many nulls in the pass band. Both linear
and non-linear equalizers are identiﬁed by a structure and an
algorithm as shown in Figure 1. In the following paragraph,
we will describe the structure and algorithm of DFE brieﬂy.
The structure of DFE may be linear transversal or lattice.
Both types will be treated in a similar approach to evaluate
their complexity. The choice of an algorithm to update the
equalizer weights is of great importance. Rate of conver-
gence, misadjustment, computational complexity, and numer-
ical properties are used to evaluate different algorithms [1].
The main focus of this paper is to evaluate the computational
cost or complexity for DFE that is generic enough to be used
for DFE with any algorihm and structure. A comprehensive
survey on DFE can be found in [2].
Lattice
Transversal
Decision Feedback 
Equalizer
LMS,
RLS,
FTF, FAEST, 
Fast Kalman
A priori,
A Posterior
Structure
Algorithm
Fig. 1. DFE is classiﬁed by a structure and an algorithm
Related work such as [3], [4], and [5] are focused on the
complexity reduction of DFE, because reduction in complexity
leads to reduction in power consumption. This is desirable
for applications with battery operated devices, where power
consumption is main concern. In [3], the complexity is reduced
by observing that in communication systems the input data
has shift structure. In [4], spectral factorization is used to
calculate the DFE coefﬁcients in fast and efﬁcient way. In
[5], a new Dichotomous Coordinate Descent (DCD) algorithm
is used to solve the RLS equations. Related work propose
different solutions, but they are all have one thing in common.
The common is the reduction of the total number of required
mathematical operations.
The work in this paper is two fold. First, a new metric
to evaluate the complexity of different DFE. This would
decrease the effort to choose a suitable algorithm to be
implemented. Second, DFE algorithms containing division
operations consume large chip area, and it is advised to avoid
them for implementation in programmable devices [6]. This
work proposes a new method to implement division process.
Hence, it is now permitted to use DFE containing division
operations under reduced complexity constraints.
The rest of this paper is organized as follows; in Section II,
candidate DFE algorithms are compared from computational
cost point of view as reported in the literature. Then a
new metric is proposed to evaluate the computational cost
between those algorithms, and the comparison is repeated to
validate the proposed metric. In Section III, it is proposed to
219
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

use multiplicative techniques to perform division operations
involved in DFE algorithm. Therefore, the DFE weight score
will be reduced, where a smaller weight score corresponds
to less complexity. In Section IV, results of comparison using
the proposed metric are veriﬁed using computer simulations. In
addition, to verify that the weight score of division is reduced,
one algorithm is implemented into FPGA using hardware
description language. Resource utilization for the number of
used cells in the FPGA is also reported to show the number
of used cells by a DFE. Conclusion is presented in Section V.
II. COMPUTATIONAL COST OF DFE-RLS
A. Complexity as Number of operations
In the literature of adaptive ﬁltering such as [2] and [4], the
computational cost of DFE is reported as the number of four
basic mathematical operations in addition to square root. To
reduce complexity it is advised neither to use divisions nor
square root, and as few multiplications as possible [5]. In this
paper the use of division will be permitted by reducing its
weight score as will be discussed in Section III.
Let N be the total number of forward and backward taps of
DFE and consider two algorithms A and B. Algorithm A has
O(7N) multiplications and two divisions, while algorithm B
has O(8N) multiplications and one division. Note that O(7N)
represents that the total number of an operation is dominated
by a term that is seven times the number of taps in DFE. It
is not straightforward to determine which algorithm has lower
computational cost. Hence, it is required to ﬁnd a metric or
weighting score for each basic arithmetic operation to be able
to determine the overall computational cost. The value of the
weight score will represent the overall complexity of DFE. A
lower weight score corresponds to reduced complexity.
In previous work where the complexity of DFE is addressed,
the weight score is reported as the number of basic mathe-
matical operations [4], [5], and [6]. The complexity of DFE is
usually reported for real data and linear ﬁltering. These results
are extended to include complex data, which is the general case
for communication systems [7] as shown in Table I. In [8], it
was shown that the computational cost of DFE is the same as
linear ﬁltering for the same total number of taps. Hence, the
calculations are not only applied for linear ﬁltering but also
for the DFE problem.
Candidate algorithms will be chosen to represent the fami-
lies of conventional Least Mean Square (LMS), conventional
RLS, fast ﬁxed order, lattice, and the family of DCD. Each
candidate algorithm is generic enough to represent its family.
The same procedure can be used to calculate the weight score
for any other algorithm. Due to the desirable feature of fast
ﬁxed order family [3] with the complexity in the order of
O(N), three members of this family will be evaluated; namely
Fast Transversal Filter (FTF), Fast Aposterior Error Sequential
Technique (FAEST) and Fast Kalman. In the rest of this
subsection, each family of algorithms will be discussed brieﬂy.
(LMS) algorithm has the lowest computational cost [2].
Although LMS has the slowest convergence rate, it will be
TABLE I
COMPUTATIONAL COST OF DFE USING RLS ALGORITHM FOR GENERAL
COMPLEX DATA WHERE N IS THE TOTAL NUMBER OF TAPS
Algorithm
×
+
÷
Conventional
4N2 + 16N + 1
4N2 + 12N − 1
1
Apriori Lattice
64N
32N
32N
FAEST
28N + 6
28N + 2
5
FTF
28N + 10
28N + 1
3
Fast Kalman
36N + 2
32N + 1
2
ERLS-DCD-16
12N
134N
0
LMS
8N + 2
8N
0
used as a reference scenario for the proposed metric.
Fast ﬁxed order algorithms are based on RLS; namely FTF,
FAEST and Fast Kalman. Their complexity is in the order
of O(N) and their rate rate of convergence is similar to
the conventional RLS, which is considered fast. Therefore,
they will be suitable for systems needing short iterations to
reach optimum weights of the channel to reduce transmission
overhead [1].
The lattice RLS algorithms have a lot of desirable features
such as improved numerical properties and modularity [6].
However, lattice ﬁlters have higher computational require-
ments and can not be used in all applications [5]. They will be
compared here with other families, to show the effectiveness
of using the proposed metric. It will be shown in Section IV
how the proposed metric simpliﬁes the comparison between
different families.
A recent study to reduce the complexity of RLS algorithm is
based on DCD iterations [5]. The RLS is expressed in terms
of auxiliary normal equations with respect to increments of
the ﬁlter weights. Auxiliary equations are solved using line
search methods. These methods have more than one solution
for conventional RLS problem. One of these solutions is
chosen, which has the least computational cost among its
family namely; Exponentially Weighted RLS with 16 iterations
per sample (ERLS-DCD-16). However, the ERLS-DCD offer
reduced complexity at the expense of low convergence time.
After describing the candidate algorithms brieﬂy, it can
be observed from Table I that it is not straightforward to
determine which algorithm has the least computational cost.
Moreover, it is impossible to arrange the rows in Table I in a
descending order according to computational cost. Therefore,
we found a need to develop a new metric to evaluate the
weight score of DFE. To accomplish this goal, it is proposed to
normalize all operations to a weight score as will be discussed
in Subsection II-B.
B. Complexity Weight Score
As stated in [9] the simplest mathematical operation is the
binary addition. Therefore, all operations should be mapped
to a ﬁnite number of additions. Then, the overall weight score
of DFE will be a linear summation of the weight score of
all used operations. In order to accomplish the normalization,
220
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

TABLE II
MULTIPLICATION USING ADD AND SHIFT METHOD
Multiplicand
.........x3 x2 x1 x0
Multiplier
.........y3 y2 y1 y0
Partial Products
...x3y0 x2y0 x1y0 x0y0
...x3y1 x2y1 x1y1 x0y1
...x3y2 x2y2 x1y2 x0y2
...........................
Final Product
ZMc+Ml−1..................... Z2
Z1
Z0
we propose to analyse the low level details of each operation
involved in DFE. In the following, the normalization will be
developed for the multiplication operation. This normalization
enables one to compare fairly between different families of
algorithms.
As described in Table II the binary multiplication may be
performed by adding the multiplier to the multiplicand and
storing the result. Then the multiplier is shifted one bit to
the left and added to the previous result [9]. To illustrate the
multiplication of X and Y Let Ml and Mc be the data width
for multiplier and multiplicand respectively. The ﬁrst partial
product is the binary multiplication of ﬁrst bit in the multiplier
y0 and each bit in the multiplicand xi where i is in the range
0 to Mc−1. Recalling that binary multiplication is the logical
”AND” operation, the ﬁrst bit of the ﬁrst partial product equals
x0y0, and the second bit of the ﬁrst partial product equals
x1y0, up to xMc−1y0. The same procedure is repeated for
each bit in the multiplier until all of the partial products are
generated.
This method is the simplest from complexity point of view
because it can be implemented using only one adder and one
shifter. However, from processing time point of view it is
considered the slowest to store the ﬁnal result.
Another multiplication method is the Wallace Tree [9]. It
is based on parallel generation of the required number of
partial products. Afterwards this number of partial products
is reduced. It is the fastest multiplier scheme at the expense
of increased computational cost. A method that is considered a
good compromise between processing time and computational
cost is the iterative array of cells [9]. Hence, the iterative
array multiplication will be used in the rest of this paper.
However, the new proposed metric can be calculated for all
multiplication methods as will be discussed in the following
paragraph. In general, the iterative array method is used
for short data lengths, which is the case for communication
receiver [10], because its delay increases with operand length
[9].
Multiplication consists of a ﬁnite number of cells or building
blocks. To perform one multiplication, a ﬁnite number of
building blocks are needed. let G be the number of building
blocks needed to perform one multiplication. In order to cal-
culate the number of required building blocks G, the following
Fig. 2. Structure of 4 x 4 multiplier using full adder cells
Fig. 3. Compromise between G and ml × mc. Each black circle is used to
represent one adder cell.
relation is used [9]
G = ⌈Ml × Mc
ml × mc
⌉
(1)
Where and ml and mc are the data width of the building block
used. For example, using Ml = Mc = 12 and ml = mc = 4
will result in G = 9. Therefore, nine building blocks will be
needed to construct one multiplier and each building block is
mc × ml multiplier.
To complete the normalization, each building block is
composed of ﬁnite number of 1-bit full adder cell as shown
in Figure 2. Hence, one multiplier building block is composed
of [(ml − 1) × (mc) + 1] 1-bit full adder blocks. Therefore,
the weight cost of multiplication Mscore can be rewritten as
Mscore = ((ml − 1) × mc + 1) × G
(2)
Equation 2 explains how to calculate the weight score of
multiplication operation in terms of 1-bit full adder cells. In
Section III, the weight score of division operation will be
calculated in terms of adder cells similarly.
It can be observed that there exist an inverse proportional
relation between the data width of the building block and
the number of building blocks G. As ml × mc increases, the
number of required building blocks G decreases as shown in
Figure 3. From complexity point of view, the weight score
of multiplier is independent of the number of used building
blocks G. Intuitively it does not matter whether to use one
large building block or many small building blocks. In both
situations the total number of 1-bit full adder cells are the same
as shown in Figure 3. However, from processing time point
of view it is favoured to use smaller building blocks. This is
due to the fact that the processing time to have a result is
proportional to the width of the building block [11].
221
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

It can be observed, from Figure 3, that using 3×3 building
block generates an extra partial product because the data width
is not integer multiple of the building block data width. This
extra partial product will be zeros and may be skipped using a
multiplexer [11]. In general, for any Ml ×Mc data width, and
any ml × mc building block width the extra partial products
will not affect the ﬁnal weight score. This is because the
weight score is used for comparison based on the number of
used 1-bit full adder cells and not on the number of building
blocks.
III. DIVISION USING SERIES EXPANSION
Division algorithms can be divided into two categories;
the ﬁrst category is based on iteration of subtraction and the
second is based on iteration of multiplication [9]. The ﬁrst
category is performed as the normal pencil and paper division.
At each iteration, there is remainder R, divisor D, and quotient
Q. The ith bit of quotient qi can be calculated using the
following equation
R(i) = R(i + 1) − qi ∗ D ∗ 10i
(3)
For example, the ﬁrst iteration of division of 4000 over
3 will be 4000 − 1 × 3 × 1000 where R(i + 1) = 4000,
q3 = 1, D = 3 and 10i = 103. Each iteration qi is chosen
to be 0 or 1 according to the negative or positive value of
R(i) respectively. This method is considered slow because
the delay is proportional to the ratio between the divisor and
the dividend. Therefore, we will consider another category of
division algorithms, which has less processing time.
The second category of division algorithms is based on the
use of Maclaurin series expansion [9]. The division a
b will be
obtained as the multiplication of a and 1
b. Note that, according
to the ﬂoating point standard [12], numbers are represented in
either 32 or 64 bits with the format 1.x×radixexponent where
x is a fraction. Therefore, one can use b = 1 + x and ignore
higher orders of x, depending on the required accuracy, in the
familiar series expansion
1
b =
1
1 + x = (1 − x)(1 + x2)(1 + x4)(1 + x8)
|
{z
}
MemorylocationAddress
(4)
All possible values of the reciprocal are stored in a memory
element with its length proportional to the data width. This
would replace the need to true division with a simple memory
allocation. In typical communication systems [10] the data
widths are in the range 8, 10, 12 or 14 bits, because a memory
block of size 2c is needed to store all values of a digital word
with data width c bits. Hence, the memory size needed is
approximately 0.25, 1, 4 or 16 kbits.
To form one divider a ﬁnite number of adders and multipli-
ers is needed to form the memory address. This number varies
according to the desired data accuracy. For 8-bit data accuracy,
six multipliers and four adders are needed to implement one
divider and the calculation of the memory address is shown in
Figure 4. To calculate the memory element address we need to
calculate the powers x2, x4, and x8 depending on the desired
Fig. 4. Division using series expansion for 8-bit accuracy.
accuracy. For 8-bit accuracy, the weight score of one division
Dscore can be calculated according to the following relation
Dscore = 6 ∗ Mscore + 4
(5)
To achieve higher accuracy for the division operation, higher
powers of x should be considered. For increased accuracy,
such as 12-bit, x12 can be calculated by multiplying x4 by
x8, which have been calculated earlier as shown in Figure 4.
Consequently, one extra multiplier and two adders are needed.
The weight score can be modiﬁed accordingly to be
Dscore = 7 ∗ Mscore + 6
(6)
According to equations 5 and 6 the division is normalized
into a ﬁnite number of 1-bit full adder cells. In the following
section results of weight score for different algorithms are
presented.
IV. SIMULATION RESULTS
In this section, results obtained by computer simulation are
presented. The complexity weight score of different algorithms
is plotted against ﬁlter order N. First, the weight score of
each operation is calculated according to equations 2 and 5.
For each algorithm the total computational cost is calculated
according to Table II. Then the number of multiplications and
divisions in the table is multiplied by Mscore and Dscore
respectively. In this manner the computational cost is com-
pared fairly. The total weight score of each algorithm is
the linear summation between the weight score of additions,
multiplications and divisions included in that algorithm. This
procedure is repeated for different values of equalizer order
N as shown in Figure 5.
The conventional RLS was not plotted due to its high weight
score that would compress all other graphs at the bottom of the
y-axis. The weight score of conventional RLS is almost 5.5k
at N = 10. However, its complexity increases exponentially
afterwards until it reaches 20k at N = 20.
It is observed that the LMS has the least weight score over
all values of N. This result was expected as was mentioned
in Section II-A. The ERLS-DCD-16 has slightly higher com-
plexity than LMS. This result conforms to the results in [5],
222
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

Fig. 5. Complexity of DFE versus the total number of taps
TABLE III
FPGA RESOURCES FOR THE PROPOSED ENHANCEMNT FOR FTF
Resources
N = 8
N = 12
N = 16
Slice
127(1%)
177(1%)
206(1%)
D-FF
136(1%)
186(1%)
226(1%)
LUT-4
206(1%)
313(1%)
403(1%)
BRAM
1(1%)
2(2%)
4(4%)
DSP48
2(2%)
3(3%)
3(3%)
which states that LMS complexity is proportional to 2N, while
ERLS-DCD-16 complexity is proportional to 3N. Both FTF
and FAEST have almost the same weight score over N. It
is important to observe that fast Kalman has higher weight
score than FASET. This result was not obvious before using
the weight score metric because FAEST has 5 divisons while
Fast Kalman has 2 divisions only.
In order to verify the usage of the proposed division method
experimentally, the resource utilization for the Xilinx FPGA
”Spartan3A-DSP1800” [13] is shown in Table III. Results
are obtained using Xilinx development suite ISE12.1. Using
the automatic synthesis procedure, the synthesizer fails to
design the division process and ends with error messages. This
result was expected because the implementation of division
operation into FPGA is problematic [14]. Different division
implementations such as restoring, non restoring, and Xilinx
Intellectual Property(IP) consumes large area of the FPGA
chip. Afterwards, divisions are implemented as proposed using
memory elements, which is called Block RAM (BRAM). The
synthesis process succeeded with low chip utilization . Note
that the multiplication and the tapped delay line of the DFE
are implemented using the DSP blocks of the FPGA [13].
V. CONCLUSION
DFE equalizers are used to eliminate ISI phenomena. Many
algorithms are used to adopt the coefﬁcients of equalizers
such as conventional RLS. However, RLS complexity is high
and in the order of O(N 2). Other algorithms have lower
complexity such as fast RLS algorithms with computational
cost in the order of O(N), and ERLS-DCD-16. However,
it is not straightforward to compare fairly between different
algorithms. In this paper a new metric, weight score, is
proposed to measure the complexity of each algorithm. Each
algorithm is normalized as a function of the number of 1-
bit full adder units needed to construct the DFE. Comparison
results were presented using computer simulation. In addition,
a new method was proposed to decrease the weight score of the
division operation. This is accomplished by using the iterative
array division, which is based on Maclaurin series expansion.
To verify the reduction of weight score experimentally one
algorithm, (FTF), is implemented in FPGA and resource
utilization results were presented. It was shown that division
operation can be implemented into FPGA with low chip area
utilization.
ACKNOWLEDGMENT
This work is supported by the Egyptian National Telecom-
munication Regulatory Authority (NTRA).
REFERENCES
[1] T. Rappaport, Wireless Communication: Priciples and Practices, 2nd ed.,
New Jersey: Prentice Hall, 2001, pp. 308-318
[2] J. Proakis, “Adaptive Equalization for TDMA Mobile Radio”, IEEE
Transactions on Vehicular Technology, vol. 40, no. 2, May. 1991, pp.
333-341
[3] J. Ciofﬁ and T. Kailath, “Fast, Recursive Least-Squares Transversal Filters
for Adaptive Filtering”, IEEE Transactions on Acoustics, Speech, and
Signal processing, vol. 32, Apr. 1984, pp. 304-337
[4] N. Al-Dhahir, J. Ciofﬁ, “Fast computation for Channel-Estimate based
Equalizers in Packet Data Transmission”, IEEE Transactions on Signal
Processing, vol. 43, no. 11, Nov. 1995, pp. 2462-2473
[5] Y. Zakharov, G. White, and J. Liu, “Low-Complexity RLS Algorithms
Using Dichotomous Coordinate Descent Iterations”, IEEE Transactions
on Signal Processing, vol. 56, no. 7, July. 2008, pp. 3150-3161
[6] H. Sayed, Fundamentals of Adaptive Filtering, 2nd ed., New Jersey:
Wiley-IEEE Press, 2003, pp. 600-620
[7] B. Bjerke, J. Proakis, K. Martin Lee, and Z. Zvonar, “A Comparison
of GSM Receivers for Fading Multipath Channels with Adjacent- and
Co-Channel Interference”, IEEE Journal on selected areas in communi-
cations, vol. 18, Nov. 2000, pp. 2211-2219
[8] Y. Yang, X. Gao, Z. Gao, and X. Wang, “An Classiﬁcation-based Adaptive
Decision Feedback Equalizer for Rayleigh Multipath Channel”, Journal of
Computational Information Systems, vol. 8, no. 2, Jan. 2012, pp. 869-876
[9] M.J. Flynn, and S.F. Oberman, Advanced Computer Arithmetic Design”,
2nd ed., New York: John Wiley and Sons, 2001, pp. 113-125
[10] O. Dabeer, and U. Madhow “Channel Estimation with Low-Precision
Analog-to-Digital Conversion”, IEEE International Conference on Com-
munications (ICC 10), vol. 2, May. 2010, pp. 23-27
[11] R. Singh, P. Kumar, and B. Singh, “Performance Analysis of 32-Bit
Array Multiplier with a Carry Save Adder and with a Carry Look-Ahead
Adder”, International Journal of Recent Trends in Engineering, vol. 2,
no. 6, Nov. 2009, pp. 83-86
[12] IEEE Standard for Floating-Point Arithmetic,“IEEE Std 754-2008”,
pp.2-7, Aug. 2008, doi: 10.1109/IEEESTD.2008.4610935.
[13] Xilinx Inc., “XtremeDSP DSP48A for Spartan-3A DSP FPGAs User
Guide”, UG431 (v1.3), July. 2008, pp.32-34
[14] N. Sorokin, “Implementation of high-speed ﬁxed-point dividers on
FPGA”, Journal of Computer Science and Technology, vol. 6 no. 1, May.
2006, pp. 8-11
223
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-279-0
AICT 2013 : The Ninth Advanced International Conference on Telecommunications

