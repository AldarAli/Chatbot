Routing with Metric-based Topology Investigation
Frank Bohdanowicz, Harald Dickel, and Christoph Steigner
Institute for Computer Science
University of Koblenz-Landau
{bohdan,dickel,steigner}@uni-koblenz.de
ABSTRACT
As routing takes place in an entirely distributed system
where local routers have no direct access to globally con-
sistent network state information, a routing algorithm has
to make uncertain forwarding decisions.
As the network
state may change, due to failures or new adoptions of net-
works, routing algorithms have to adapt themselves to the
new situation. This network convergence phase should be
carried out as quickly and precisely as possible.
Besides
the problem of generating the proper updates for the locally
distributed routers, the problem of forwarding the routing
updates is also manifest: routing updates travelling along
routing loops may become obsolete or outdated. We devel-
oped a new distance vector algorithm which solves the prob-
lem of routing loops. This provides distance vector routing
with crucially improved convergence, stability, and scalabil-
ity abilities, thus making distance vector routing once again
an attractive revitalized alternative to link state routing.
Keywords– routing; distance vector routing; metric-based
topology investigation; routing loops; counting to inﬁnity prob-
lem; routing convergence
1.
INTRODUCTION
The major goal of all routing algorithms is to achieve a
fast and correct convergence after a change in the network
topology. In this phase, the forwarding of the actual routing
updates is crucial in contrast to the forwarding of existent
but obsolete update information. In distance vector algo-
rithms, routing updates which have made their way along
network loops contain in most of the cases obsolete informa-
tion which should not be considered anywhere further on.
Whenever network topologies in the Internet contain loops,
alternative routes are available in case of a link failure. Un-
fortunately, topology loops complicate the correct detection
of routes.
The major approaches to cope with this problem are dis-
tance vector, link state, and vector path algorithms.
Distance vector routing algorithms like the Routing Infor-
mation Protocol (RIP) [10] cannot cope with routing loops
eﬃciently.
A routing loop is the trace of a routing up-
date which occurs at a router again reporting seemingly new
reachability information which is based on already known in-
formation. This event results in a temporary inconsistency
during the convergence process. The well-known split hori-
zon approach fails if the network topology contains loops.
In this case, the routing convergence is impeded because
invalid old routing updates may ﬁnd their way along topol-
ogy loops and cause routing loops which appear as the well-
known counting to inﬁnity (CTI) problem [10]. RIP, as a
classic representative of the distance vector protocol family,
can only inadequately cope with CTIs by limiting the metric
to a small maximum. This does not solve the CTI problem
since misguided data traﬃc may congest the trace of the
routing loop and the maximum metric cannot be reached in
a short time. Up to now there has been no proper solution
for the CTI problem.
We show in this paper that the distance vector approach
can be improved by a mechanism that can recognize all those
outdated updates which were propagated along loops. Our
simulation results and analysis show that distance vector
routing can be signiﬁcanty improved. Our new Routing with
Metric-based Topology Investigation (RMTI) protocol can
alleviate the CTI problem found in distance vector routing
protocols like RIP. Our RMTI protocol is entirely compat-
ible to RIP since it uses the same routing update message
format. The convergence time of our RMTI protocol does
not depend on an upper metric limit, so it is applicable in
large-scale network environments.
Path vector routing like the interdomain Border Gateway
Protocol (BGP) [17] was designed to solve the routing loop
problem by including the entire path (AS-path) from source
to destination in its updates in order to detect the occur-
rence of routing loops. It has, however, been shown that
BGP suﬀers from forwarding loops during routing conver-
gence after topology changes [12, 15].
Due to the drawbacks of the classical distance vector rout-
ing, in recent years the focus in further development of in-
terior routing protocols was on link state routing. But link
state routing like Open Shortest Path First (OSPF) [11] do
not solve the routing loop problem entirely due to the fact
that these routing algorithms also suﬀer from forwarding
loops [6, 8, 22]. The brute force eﬀort of the link state algo-
rithms, the overhead prone reliable ﬂooding technique, lim-
its its deployment [9]. Besides this, the link state approach
has some disadvantages such as the absence of local routing
policy facilities which provide network administrators with
comprehensive capabilities to inﬂuence traﬃc density.
In
distance vector and path vector routing, the routing update
ﬂow is directly related to the actuated traﬃc ﬂow. Thus dis-
tance vector and path vector algorithms can naturally cope
with routing policies. By our deployment of RMTI, we show
that distance vector routing algorithms can be an attractive
alternative to the link state routing suite.
135
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

This paper gives a detailed description of our RMTI pro-
tocol, implementation, and evaluation results based on [1,
2]. The paper is organized as follows: In Section 2 we give a
short overview of other approaches to distance vector rout-
ing which solve the CTI problem. In Section 3 we discuss the
routing problem as a loop problem and state our vocabulary
of loop concepts. In Section 4 we present the principles of
our new RMTI approach. In Section 5 we present our pro-
tocol together with some characteristic examples of routing
loop detection and update rejection.
In Section 6 we de-
scribe our implementation. We close with our conclusion in
Section 7.
2.
RELATED WORK
To avoid routing loops and the CTI problem, several en-
hanced distance vector protocols which increase the amount
of information exchanged among nodes and new routing ar-
chitectures have been proposed.
The Ad hoc On-Demand Distance Vector (AODV) proto-
col [14] by Perkins expands the distance vector information
originally based on subnet N, next hop NH and distance
D, to a 4-tuple (N,NH,D,SEQ), where SEQ denotes the se-
quence number. The result is that although this approach is
provably loop free [13], it is not compatible with RIP due to
the required protocol changes. The Enhanced Interior Gate-
way Routing Protocol (EIGRP) used by Cisco is based on
the DUAL algorithm [7] proposed by Garcia-Luna-Aceves.
DUAL provides loop-free paths at every instance, which was
proved in [7]. However, it is a Cisco proprietary routing pro-
tocol and not compatible with RIP due to a diﬀerent proto-
col design. A solution called Source Tracing was proposed
by Cheng et al [3] and Faimann [5]. In this approach, up-
dates and routing tables provide additional information by
adding a ﬁrst-hop indication (the head of the path). Loops
can be recognized recursively.
These protocols avoid the CTI problem because they pro-
vide loop freedom, but they are likewise not compatible with
the RIPv2 standard or are proprietary approaches.
In contrast to these approaches, we aim to provide a solu-
tion that has a complete and solid backward compatibility
with every existing implementation of RIPv2 [10]. The en-
hanced knowledge is based on the information already pro-
vided by the RIP protocol. So even deploying a new RMTI
router only at selected nodes is possible.
3.
THE ROUTING PROBLEM
In a computer network, a router’s task is to connect sev-
eral subnets to build an internetwork. Routers have to en-
sure that, within this internetwork, communication between
arbitrary locations in diﬀerent subnets becomes possible. In
the following we use the term network as a synonym for the
term internetwork. The Internet Protocol (IP) is the key
communication protocol in such networks. It uses packet for-
warding to deliver a data packet addressed to a destination
in a certain subnet. A data packet is forwarded from router
to router until it reaches a router which is directly connected
to the data packet’s destination subnet. Finally this router
delivers the data packet to its destination. A router has to
know which router is the next hop router in the forwarding
process in order to reach a subnet. Therefore it maintains
a forwarding table.
Basically a forwarding table is a list
of entries containing the next hop router for every subnet.
The task of building up and maintaining a correct forward-
ing table is called routing. Usually, routing is achieved by
a routing protocol which is running distributed among the
routers. The fact that a routing protocol is a distributed
system oﬀers some favorable and welcome properties such
as enhanced reliability and scalability, when compared to a
centralized approach.
A real network is far from being a static entity. New sub-
nets are connected, sometimes old ones are removed, new
links between subnets are established via routers, or exist-
ing links and routers may fail. A routing protocol has to deal
with all these events. Therefore routers have to communi-
cate among each other all changes in the network relevant
to the routing task. They are exchanging update messages
to announce their actual view of the network state. Unfor-
tunately it always needs some time to distribute the update
messages all over the network. It is impossible to guarantee
that all routers share a common and consistent view at any
one time. Furthermore it is possible that update messages
on their way through the network become outdated. The
information enclosed may be no longer valid and may cause
misleading assumptions by a router which receives such out-
dated information. It is still an ongoing challenge to design
a routing protocol and make it work as a real distributed
system that solves all routing problems.
All these problems get worse with the presence of loops
in the network topology.
Further on we will look at the
problems caused by loops in detail.
Loops appear in diﬀerent forms and on several occasions
throughout this paper. We use ﬁve variations of the term
loop: topology loop, forwarding loop, routing loop, Simple
Loop, and Source Loop.
To avoid confusion, we have to
make a proper distinction between these concepts and the
usage of the term loop in this paper.
A topology loop is a loop within the network based on
the physical network topology.
In Figure 1a we have the
topology loop (r1, s1, r2, s2, r3, s3, r1) and in Figure 1c an
additional topology loop (r1, s4, r4, s5, r5, s6, r1). Topology
loops add redundancy by oﬀering multiple routes to certain
subnets and enhance the reliability of a network.
Data packet delivery in an IP network is done by hop
by hop packet forwarding as stated above. A data packet
addressed to a destination in a certain subnet s is sent to
the appropriate next hop router listed in the forwarding ta-
ble.
If a data packet forwarded by a router r returns to
router r again after some intermediate hops, the entries in
the forwarding tables of the routers have built a forwarding
loop. Once a data packet gets into such a forwarding loop,
it sticks in this loop and circles around, never reaching its
destination.
The functionality of the data forwarding principle is based
on the assumption that the next hop router has a shorter dis-
tance to the subnet s than the actual router. Unfortunately,
diﬀerent routers may have a diﬀerent and inconsistent view
of the distances to a destination subnet caused by the dis-
tributed nature of the routing protocol. This inconsistent
view may lead to the conﬁguration of a forwarding loop.
Forwarding loops can consume a large amount of network
bandwidth and can impact the end-to-end performance of
the network. Therefore it is necessary to recognize and to
prevent forwarding loops. In practice all common routing
protocols suﬀer from forwarding loops during the conver-
gence process after a topology change in the network [8].
136
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

A
rr33
rr22
ss11
ss55=d
=d
ss33
ss22
B
rr11=i
=i
rr44
ss44
A
rr33
rr22
ss11
ss33
rr11=i
=i
rr44
ss44
ss55
ss22=d
=d
i,d
CP
i,d
A
P
i,d
BP
i,d,i
PA,C
i,d,i
A,B
P
i,d
A
P
(a)
(b)
B
C
C
A
rr33
rr22
ss11
ss55=d
=d
ss33
ss22
B
rr44
ss44
(c)
C
rr55
ss66
rr11=i
=i
D
Figure 1: Three examples of loops in a network. (a) shows a Simple Loop P i,d,i
A,B between the neighbor interfaces A
and B. (b) shows a Source Loop P i,d,i
A,C between the neighbor interfaces A and C. The path P i,d
B
is part of the path
P i,d
A . (c) shows a diﬀerent topology with another Source Loop P i,d,i
A,C between the neighbor interfaces A and C. Here
the path P i,d
B
is not enclosed in the path P i,d
A .
Forwarding loops arise in link state routing by computing
inconsistent shortest path trees by distinct routers on the
basis of diﬀerent link state databases [22], or in distance
vector routing due to the occurrence of a routing loop.
While the term forwarding loop denotes a loop in the for-
warding process of a data packet, we use the term routing
loop exclusively to denote a loop in the trace of a routing
update. Like a forwarding loop reﬂects a loop in the for-
warding process, a routing loop reﬂects a loop in the routing
process. The routing process manages the forwarding table
of a router and has direct inﬂuence on the forwarding pro-
cess. Every routing loop is in close relation to a forwarding
loop. If router r1 in Figure 1a sends a routing update des-
ignating the reachability of subnet s4 to router r2, then r2
may insert an updated entry to subnet s4 in its forwarding
table. Now r2 forwards data packets to s4 via r1. The traﬃc
ﬂow takes the opposite direction of the update ﬂow. So in
fact every routing loop causes a corresponding forwarding
loop in the opposite direction.
In distance vector routing, routing loops appear as the
counting to inﬁnity problem. Our RMTI approach avoids
CTIs by evaluating the metrics of the routing updates more
carefully than other distance vector algorithms. RMTI de-
tects and distinguishes two diﬀerent shapes of loops com-
posed of traces of routing updates. We call these loops Sim-
ple Loop and Source Loop. A Simple Loop (Figure 1a) is
a path which leaves a distinct router at one interface and
comes back to the same router on another interface, with-
out having passed through the same router in between. A
Source Loop (Figure 1b+c) is a path which leaves a distinct
router at one interface and comes back to the same router on
another interface, having passed the same router in between.
In contrast to RIP, we can detect these loops by not delet-
ing old routing information as soon as new and better infor-
mation arrives at a router; rather, we maintain some infor-
mation in order to detect Simple Loops and Source Loops.
We show that the detection of Source Loops enables us
to avoid all kinds of CTI situations in all loop topologies
by rejecting malicious routing updates.
We implemented
a fully functional version of RMTI and did comprehensive
tests with diﬀerent network topologies in order to analyze
and evaluate the RMTI behavior.
4.
DESIGN RATIONALE
Now we present a formal network model and a notation
which is suﬃciently comprehensive to sketch out and prove
the concept of our approach.
4.1
The Network Model
A computer network is a collection of devices like hosts,
routers, switches, or subnets which are connected via net-
work links. In formal modeling, a computer network is typ-
ically represented by a graph. The devices are the nodes of
the graph and the edges correspond to the network links.
The routing problem is to ﬁnd a path between any two
nodes. For the purpose of discussing the routing problem
in computer networks, it is suﬃcient to consider two types
of nodes (subnets and routers) and one type of edges (in-
terfaces). Figure 2 shows a network graph with 7 subnets
(s1, . . . , s7), 5 routers (r1, . . . , r5) and 13 interfaces (A, . . . , M).
The number of subnets s1, . . . , sn are subsumed to the set
S = {s1, . . . , sn}.
The subnets are connected via routers
and the routers are attached to subnets via interfaces. The
interfaces represent the network links and correspond to the
edges of the graph.
In general we use upper-case characters to denote inter-
faces and I is the set of interfaces I = {A, B, C, D, . . . }.
An interface is assigned to exactly one router and in our
model a router is fully speciﬁed by its interfaces.
So, we
use the interfaces which are assigned to a router r to deﬁne
r = {U1, U2, . . . , Un}, U1 . . . Un ∈ I. In Figure 2 by example
we have r1 = {A, B, C}, r2 = {D, E}, . . . , etc.
Let R denote the set of routers R = {r1, . . . , rk}. Since
an interface is an element of one unique router only, we have
∀U ∈ I (U ∈ ri ⇒ U ̸∈ rj),
ri, rj ∈ R, i ̸= j.
Every interface is attached to exactly one subnet.
An
interface is the link of a router to one certain subnet.
137
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

A
B
C
D
E
F
G
H
K
L
M
I
J
ss11
ss22
ss33
ss44
ss55
ss66
ss77
rr11
rr22
rr33
rr44
rr55
Figure 2: Formal representation of a network.
The topology of the network graph is given by the relation
CON ⊆ I × S and deﬁnes the mapping between interfaces
and subnets: (Ui, sj) ∈ CON, Ui ∈ I, sj ∈ S, if and only if
interface Ui is connected to subnet sj.
Finally, a router r ∈ R is connected to subnet s ∈ S, if
and only if one of its interfaces U ∈ r is connected to subnet
s that is ∃ U ∈ r with (U, s) ∈ CON.
Given the sets of subnets S, interfaces I, and routers R
together with the connection relation CON, we have a com-
plete formal speciﬁcation of the topology of a network. It
can be represented as a graph like the one in Figure 2. This
graph is the representation of the following speciﬁcation:
S = {s1, . . . , s7}, I = {A, . . . , M}, R = {r1, . . . , r5} with r1 =
{A, B, C}, r2 = {D, E}, r3 = {F, G, H}, r4 = {I, J}, r5 =
{K, L, M}, and CON = {(A, s1), (B, s2), (C, s3), (D, s2),
(E, s4), (F, s3), (G, s4), (H, s5), (I, s4), (J, s6), (K, s5), (L, s6),
(M, s7)}
Router nodes are drawn as cylinder, subnet nodes as clouds,
and there is an edge between a router r ∈ R and a subnet
s ∈ S if and only if ∃ U ∈ r with (U, s) ∈ CON.
To discuss the basic questions in the area of routing, namely
”Is there a route from a certain node in the network to a cer-
tain destination?”, we have to deﬁne some useful terms and
properties about transitions from node to node in a network
graph.
An elementary step from a router i ∈ R via outgoing
interface O ∈ i to an adjacent router j ∈ R via incoming
interface I ∈ j using subnet s ∈ S is called a hop (see
Figure 3). It is deﬁned by a 3-tuple Hi,j = (O, s, I), whereas
(O, s), (I, s) ∈ CON.
If the destination of a hop is simply given by a subnet and
not by a designated interface of a router, we use the special
symbol ∗ as the last element of the 3-tuple, i.e. the hop from
router i to subnet d is notated as Hi,d = (O, d, ∗).
Definition 1. (Hop)
A hop H from a router i ∈ R via outgoing interface O ∈ i to
an adjacent router j ∈ R via incoming interface I ∈ j using
subnet s ∈ S is the 3-tuple H = (O, s, I) with (O, s), (I, s) ∈
CON and H denotes the set of all hops.
In abbreviated form we use the router identiﬁers as a su-
perscript and the interface identiﬁers as a subscript to spec-
ify a hop.
The notation Hi,j
O,I indicates that this hop is
O
I
ss
ii
jj
HH
i,j
O,I
Figure 3: The hop Hi,j
O,I = (O, s, I) from router i to router
j uses the outgoing interface O and reaches the incoming
interface I of router j via subnet s.
ss11
ss22
ss33
rr22
rr33
rr11=i
=i
rr44=j
=j
O2
O1
B=O3
A=I1
I2
I3
H1
H2
H3
Figure 4: A path P i,j
A,B from router i to router j.
P i,j
A,B = (H1, H2, H3) = ((O1, s1, A), (O2, s2, I2), (B, s3, I3))
leaving router i via interface O and leading to router j via
interface I (Figure 3).
If two routers i and j are connected to the same subnet s,
then there exists one hop Hi,j from i to j as well as a hop
Hj,i from j to i. In this case i and j are called neighbors.
Definition 2. (Neighbor)
Let i, j ∈ R, i ̸= j be two distinct routers. j is a neighbor of
i, iﬀ ∃O ∈ i, I ∈ j, and Hi,j
O,I ∈ H.
In Figure 2 r1 is a neighbor of r2 and r2 is a neighbor of
r4 but r1 and r4 are not neighbors.
If router j is a neighbor of router i there exists a hop
Hi,j
O,I from i to j. According the deﬁnition of a hop, O is
an interface of router i and I is an interface of i’s neighbor
j, where O and I are connected to the same subnet s. To
point out this relationship between router i and interface I
we call I a neighbor interface of i. In Figure 2 r2 has the
three neighbor interfaces B, G, and I.
A path through the network is a sequence of hops (Figure
4).
Definition 3. (Path)
A path P i,j
A,B beginning at router i ∈ R leading to router
j ∈ R is a sequence of hops
P i,j
A,B
=
(H1, H2, . . . , Hl)
=
((O1, s1, I1), (O2, s2, I2), . . . , (Ol, sl, Il))
=
((O1, s1, A), (O2, s2, I2), . . . , (B, sl, Il))
with O1 ∈ i, Il ∈ j, I1 = A, Ol = B and ∃ r ∈ R with
Ij, Oj+1 ∈ r for 1 ≤ j < l. The metric of P i,j
A,B is mi,j
A,B = l
which is simply the number of hops and P denotes the set of
all paths.
Again, we use an abbreviated form with superscripts to
indicate the start and the destination router of a path and
subscripts to specify the ﬁrst and the last hop of a path more
precisely. By using the notation P i,j
A,B of a path P ∈ P, we
specify that interface A is a neighbor interface of router i,
and interface B is a neighbor interface of router j. With
this notation we can distinguish in Figure 2 a path from r2
to r5 via r3 and a path via r4. The former is noted P r2,r5
G,H
and the latter P r2,r5
I,J
.
If a path from router i leads to a subnet d, then the last
hop Hl in the sequence of hops takes the form Hl = (Ol, d, ∗)
and we simply write P i,d using d ∈ S as a superscript instead
of a destination router. And ﬁnally, we write P i,d,j to denote
a path P ∈ P which traverses subnet d. In this case there
exists a hop Hk, 1 ≤ k ≤ l in P with Hk = (Ok, d, Ik).
4.2
Simple Loops and Source Loops
A closed path P i,i
A,B begins and ends at router i through
the network where the ﬁrst hop H1 = (O1, s1, A) leaving
router i and the last hop Hl = (B, sl, Il) returning to router
i use the diﬀerent neighbor interfaces A and B (Figure 1).
138
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

U
V
A
B
dd
V
U
B
U
A
V
dd
=A
=B
(a)
(b)
(c)
i,d
B
m
i,d
 mA
i,d
 mA
i,d
 mA
i,d
mB
i,d
B
m
dd
U=ANY, V=ANY
=ANY
=ANY
Figure 5: Source Loop types. If a path P i,d,i
A,B is a Source Loop, the router i is passed in between via two neighbor
interfaces. These may be interface A, B, or ANY (any other) neighbor interface of router i. Therefore we have 32 = 9
possible Source Loop types (Table 1). Let us call these intermediate interfaces U and V . (a) shows the Source Loop
type with U = ANY and V = ANY , (b) results with U = A and V = ANY , and in (c) we have U = ANY and V = B.
It is tempting to assume that such a closed path oﬀers
two distinct useful paths to a subnet d that is part of this
path P i,d,i
A,B as shown in Figure 1a. However, this has to be
considered very carefully. Figures 1b and 1c show examples
that this assumption does not hold in general.
Figure 1a shows the network graph of an example net-
work topology. If we examine paths from router r1 = i to a
destination subnet d = s2, there is a path P i,d
A
via interface
A from neighbor router r2 and a path P i,d
B
via interface B
from neighbor router r3 to subnet d. If we combine these
paths, we obtain a closed path P i,d,i
A,B , starting at router i via
neighbor r2 and ending at router i coming in from neighbor
r3.
The network topologies of Figures 1b and 1c show a dif-
ferent situation. Again there are two diﬀerent paths from
router r1 = i to a destination subnet d. There is a path P i,d
C
from router i via neighbor interface C to subnet d = s5 and
a path P i,d
A
from router i via neighbor interface A to subnet
d. If we combine these paths, we obtain a closed path P i,d,i
A,C
once again with both paths building a loop. But there is an
important diﬀerence between the path P i,d,i
A,B in Figure 1a
and the two paths P i,d,i
A,C in Figures 1b and 1c.
In Figure 1a there is a topology loop between the neighbor
interfaces A and B of router i. If the path P i,d
B
is no longer
usable (due to a link or router failure on that path), there
is an alternative path P i,d
A
to subnet d which router i might
use. But in the topologies of Figures 1b and 1c the paths
P i,d,i
A,C traverse router i in between. There is no topology loop
via the neighbor interfaces A and C at router i. If the path
P i,d
C
is no longer usable, there is no alternative path P i,d
A
to
subnet d which router i might use since P i,d
C
is part of the
path P i,d
A . Therefore we have to distinguish between these
two diﬀerent types of closed paths. A path from router i,
traversing a subnet d, ending at router i but never passing
router i in between is called a Simple Loop.
Definition 4. (Simple Loop)
A Simple Loop is a path P i,d,i
A,B where O1, Il ∈ i, I1 = A,
Ol = B, ∃n 1 ≤ n ≤ l sn = d, and ∀Ij 1 ≤ j < l Ij ̸∈ i.
We denote the set of all Simple Loops within a network
with SIL and the metric of a Simple Loop P i,d,i
A,B ∈ SIL is
silmi,d,i
A,B = mi,d,i
A,B = l.
A path from router i, traversing a subnet d and ending at
router i but this time passing router i in between is called a
Source Loop.
Definition 5. (Source Loop)
A Source Loop is a path P i,d,i
A,B where O1, Il ∈ i, I1 = A,
Ol = B, ∃n 1 ≤ n ≤ l sn = d, and ∃Ij 1 ≤ j < l Ij ∈ i
Figure 5 explains the possible Source Loop types depending
on what interfaces are used by the intermediate passing of
router i. Only a Simple Loop provides an alternative path
to a destination subnet (Figure 1a).
On the other hand,
the attempt to use the ﬁrst hop of a Source Loop P i,d,i
A,B
in order to reach subnet d results in the conﬁguration of
a routing loop (Figure 1b and 1c).
Discovering a Simple
Loop at a router requires the exclusion of the possibility that
a closed path P i,d,i
A,B is a Source Loop. In order to detect
Source Loops, we need to identify the Simple Loop with
the lowest metric out of a set of recognized Simple Loops of
diﬀerent metric sizes. This can be done by simply inspecting
all Simple Loop metrics.
The minimal Simple Loop metric (msilm) between two
neighbor interfaces A and B on router i is:
msilmi
A,B = min{silmi,d,i
A,B for all subnets d}
Furthermore, we deﬁne the minimal return path metric
(mrpm) which can be derived from the minimal Simple Loop
metric (msilm). The minimal return path metric (mrpm) via
an interface A on router i is:
mrpmi
A = min{msilmi
A,B for all neighbor interfaces
B ̸= A of router i}
Based on the minimal return path metrics, we are able to
give a criterion which is suﬃcient to rule out that a path is
a Source Loop.
Theorem 1. (Simple Loop Test)
Let P i,d
B
be the path to subnet d with the lowest metric mi,d
B
and P i,d
A
another path to subnet d with metric mi,d
A , and
B ̸= A. Then the path P i,d,i
A,B is a Simple Loop if the following
inequality holds:
mi,d
A < mrpmi
A + mi,d
B
(1)
Proof. The path P i,d,i
A,B consists of the constituents P i,d
A
and P i,d
B
with mi,d,i
A,B = mi,d
A + mi,d
B − 1. If P i,d,i
A,B is a Source
Loop, the constituent P i,d
A
passes router i and consists of
P i,i
A,C and P i,d
D
for some interfaces A, C, D ∈ IF with mi,d
A =
mi,i
A,C + mi,d
D . mrpmi
A is the minimal return path metric via
A, so that mi,i
A,C ≥ mrpmi
A. mi,d
D ≥ mi,d
B , because mi,d
B
is
139
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

the lowest metric to subnet d by precondition. This results
in mi,d
A
= mi,i
A,C + mi,d
D
≥ mrpmi
A + mi,d
B .
So, if mi,d
A
<
mrpmi
A + mi,d
B , the path P i,d,i
A,B is not a Source Loop and
therefore must be a Simple Loop.
2
In order to form a Source Loop, the lower limit of mi,d
A is
the sum of the minimal return path metric mrpmi
A and the
metric mi,d
B in order to reach destination subnet d via neigh-
bor interface B. If the inequality holds, the path P i,d,i
A,B is
simply too short to be a Source Loop and therefore must be
a Simple Loop. We call the veriﬁcation that this inequality
holds the Simple Loop Test. The metric of this path P i,d,i
A,B
is:
mi,d,i
A,B = mi,d
A + mi,d
B − 1
(2)
If the Simple Loop Test holds for a path P i,d,i
A,B , we have
detected a Simple Loop of metric mi,d,i
A,B = mi,d
A + mi,d
B − 1.
Figure 1a shows a Simple Loop. There is a path P i,d
B
with
metric mi,d
B = 2 and a path P i,d
A
with metric mi,d
A = 2, too.
The minimal return path metric mrpmi
A is 3 which yields:
mi,d
A = 2 < 3 + 2 = mrpmi
A + mi,d
B
The inequality is satisﬁed, the Simple Loop Test is successful
and therefore it is proved that P i,d,i
A,B is a Simple Loop.
Figure 1b shows a concrete Source Loop of Figure 5c’s
type. The topology of the network is the same as in Figure
1a, so again mrpmi
A is 3, but we choose a diﬀerent subnet
d = s5. The path P i,d
C
has the metric mi,d
C
= 2 and the
metric of path P i,d
A
is 5. In this case the inequality is not
fulﬁlled and the Simple Loop Test fails:
mi,d
A = 5 ̸< 3 + 2 = mrpmi
A + mi,d
B
Figure 1c shows a Source Loop in a diﬀerent network
topology. It is of Figure 5a’s type. The path P i,d
A
consists
of the Simple Loop P i,i
A,B and the path P i,d
D . The Simple
Loop Test is always performed using the path with the low-
est metric to the destination subnet, which is in this case
P i,d
B . Given that the metric mi,d
B ≤ mi,d
D it is evident that
no Source Loop can pass the Simple Loop Test:
mi,d
A = 5 ̸< 3 + 2 = mrpmi
A + mi,d
B
(≤ mrpmi
A + mi,d
D )
Again the Simple Loop Test fails.
So far we have analyzed the properties of paths in a static
network. We developed the Simple Loop Test in order to
identify Simple Loops out of the metric of a closed path in
a network. To apply these considerations to distance vector
routing, we have to take the distance vector routing process
into account. The metrics to destination subnets are sent
via update messages between adjacent routers throughout
V = B
V = A
V = ANY
U = A
ESH
ISH+ESH
ESH (ﬁg.3b)
U = B
ISH
SLT
SLT
U = ANY
SLT (ﬁg.3c)
SLT
SLT (ﬁg.3a)
Table 1: Four of the nine Source Loop types (see Figure
5) are prohibited by the application of the split hori-
zon rule at the local router (internal split horizon, ISH)
or the split horizon rule at the neighbor router (exter-
nal split horizon, ESH). The remaining ﬁve Source Loop
types are detected by the application of the Simple Loop
Test (SLT).
the network. So we have to look at the potential succession
patterns of update messages and the chronological sequence
in which these messages arrive at a router. However, the
Simple Loop Test together with the split horizon rule is suf-
ﬁcient to prevent the acceptance of any update message that
produces a Source Loop. To prove this, we examined all pos-
sible Source Loop types produced by a simple combinatorial
scheme.
Assume an update message arrives at router i via neighbor
interface A containing the metric mi,d
A to subnet d. If router
i has already an entry in its routing table to subnet d via
a neighbor interface B ̸= A and metric mi,d
B , we can build
a closed path P i,d,i
A,B with metric mi,d,i
A,B = mi,d
A + mi,d
B − 1.
If this path P i,d,i
A,B is a Simple Loop, there is a loop in the
network between the neighbor interfaces A and B of router
i. However, it is also possible that P i,d,i
A,B is a Source Loop.
If the path P i,d,i
A,B = (H1, H2, . . . , Hl) is a Source Loop,
the router i is passed in between via two neighbor interfaces
U and V of router i. Therefore, Hn and Hn+1, (1 < n <
l, In, On+1 ∈ i) exists in the sequence of hops with Hn =
(U, sn, In) and Hn+1 = (On+1, sn+1, V) (Figure 5).
In this case router i must have received an update message
from some neighbor interface V sometime in the past and
sent out an update message to some neighbor interface U
containing metric mi,d
V . This information must have traveled
through the network in a loop, ﬁnally returning to router i
from neighbor interface A. Since U or V may be neighbor
interfaces A, B, or any other neighbor interface of router
i, there are 32 = 9 possible Source Loop types. Thus, the
occurrence of a Source Loop is either prohibited by the split
horizon rule or can be detected by the Simple Loop Test
(Table 1).
If U = V , the split horizon rule of the local router i (in-
ternal split horizon) eliminates the possibility that such a
Source Loop occurs.
If U = A, the split horizon rule of
the neighbor router with interface A (external split horizon)
eliminates the possibility that such a Source Loop occurs
(Figure 5b). If U = ANY and V = B (Figure 5c), the Sim-
ple Loop Test detects a Source Loop like in Figure 1b. And
ﬁnally, if U ̸= A and V ̸= B (Figure 5a), the Simple Loop
Test detects a Source Loop like in Figure 1c.
4.3
RMTI
The basic functionality of RMTI is the evaluation of re-
dundant routing information which would usually be re-
jected immediately by the router.
The RMTI processes
are independent of the underlaying distance vector protocol.
There is no need for an additional or altered communication
between routers enhanced with RMTI. RMTI improves the
underlaying routing protocol and allows it to maintain or
enlarge the existing network infrastructure.
Up to now, we have implemented RMTI on the basis of
the Routing Information Protocol (RIP). Thus, our RMTI-
protocol is compatible to RIP. RIP works as follows: Assume
that a RIP router i receives a routing update from an adja-
cent RIP router j to subnet d with metric mj,d via interface
A of router j. This indicates the existence of a correspond-
ing path P j,d from RIP router j to subnet d. Router i does
not know the complete path P j,d, but knows the number of
hops this path consists of. Then, from the view of router
i, there will be a path P i,d
A
with metric mi,d
A = mj,d + 1 by
prepending a hop from i to j to the path P j,d. Therefore,
140
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

reachability of subnet d from router r1
on failure an alternative 
route is available
on failure no alternative 
route available
only one route to d
multiple routes to d
on failure all routes 
become defunct 
link 
failure
d
r1
link 
failure
d
r1
link 
failure
d
r1
(a)
(b)
(c)
Figure 6: The basic topologies containing a network loop. The position of the loop and the location of a link failure
determines the availability of alternative routes
router i knows the metric mi,d
A
and the ﬁrst hop toward d.
If a RIP router has a valid path to subnet d, it will reject
all equivalent or inferior paths to the same subnet.
RIP has three timers: an update timer (default 30 sec) for
sending out routing updates periodically, a timeout timer
(default 180 sec) to recognize invalid entries in the routing
table and to mark them as unreachable when the timer ex-
pires, and a garbage collection timer (default 120 sec) to
completely delete an entry from the routing table.
The drawback of distance vector routing in general, and
RIP in particular, is the vulnerability to routing loops and,
in correlation to that, the CTI problem. Due to this CTI
problem, the RIP speciﬁcation limits the distance of a route
to a subnet to the maximum metric of 15 hops. Metric 16
marks the subnet as unreachable and is deﬁned by the RIP
term inﬁnity. This restriction does not avoid the CTI prob-
lem but reduces its duration and, therefore, its impact on the
network. Besides that, it also limits the maximum size and
complexity of RIP networks.
The split horizon technique
only avoids routing loops between two directly connected
routers (two-hop loops), but fails within topology loops.
In addition to the usual operation of distance vector rout-
ing, RMTI builds up two tables containing information about
topology loops in the local network environment. The msilm-
table contains upper bounds for the minimal Simple Loop
metrics between every two neighbor interfaces and the mrpm-
table contains the minimal return path metrics mrpmi
A for
all neighbor interfaces of the local router i.
As shown in Figure 1a, assume that router i has an entry
to subnet d via neighbor interface B with metric mi,d
B . This
indicates a path P i,d
B . Now i receives an update to subnet d
via neighbor interface A ̸= B. This indicates an alternative
path P i,d
A
to subnet d with metric mi,d
A .
A combination
of these paths results in a closed path P i,d,i
A,B with metric
mi,d,i
A,B = mi,d
A + mi,d
B − 1. We perform the Simple Loop Test
to verify that P i,d,i
A,B is a Simple Loop. If this test is passed,
we have detected a Simple Loop with metric mi,d,i
A,B. If this
Simple Loop is the ﬁrst one between the interfaces A and B
that we have detected so far, or it has a lower metric than all
other detected Simple Loops between A and B, we update
the entry in the msilm table and calculate the new minimal
return path metrics mrpmi
A and mrpmi
B.
Due to the fact that the mrpm entry corresponds to the
metric of a minimal Simple Loop and the mrpm entries are
needed in the Simple Loop Test, the question of initializa-
tion has to be considered.
At the beginning, the initial
upper bound values for the minimal Simple Loop metrics
(msilm) and the minimal return path metrics (mrpm) are
set to 2 ∗ inﬁnity − 1 (with the usual value inﬁnity= 16 this
is 31), indicating that no actual upper bounds have been
calculated out of updates so far. In addition, we have to
perform the Simple Loop Test by replacing the initial value
for mrpmi
A with 2 in order to perform the strictest possible
application of this test (2 is the metric of the smallest pos-
sible Simple Loop generally). Thus the Simple Loop Test
is reduced to test 2 > |mi,d
A − mi,d
B | in this case.
Every
Simple Loop contains at least one subnet which is located
opposite to the considered router in the topology loop. Both
neighbor routers, which span the Simple Loop over the un-
derlaying topology loop, advertise a route to this subnet and
the diﬀerence between the metrics of the two routes will be
smaller than 2. So there is always a subnet d, that allows
the detection of a Simple Loop in the initial case. Once the
initial Simple Loop Test is passed successfully, the metric of
the ﬁrst Simple Loop can be calculated on the metrics of the
two corresponding routes. By the time the routing process is
converged, every router has detected all local Simple Loops.
This loop knowledge now enables RMTI to eﬀectively meet
all challenges during the convergence phase of a network af-
ter link failures and topology changes, as the next section
will show.
5.
PERFORMANCE AND PARADIGMS
Topology loops provide connection redundancy in order
to ensure reliability and stability of the network. Figure 6
shows basic topologies containing a topology loop. Three
basic cases are illustrated there. If a network topology con-
tains loops, certain subnets are reachable from a router by
more than one link. In case of a link failure on the preferred
route, there might be an alternative route to the subnet.
The answer to the question, whether or not there is an
alternative route available from router r1 to subnet d after
a link failure, depends on the position of the loop and the
location of the link failure in the topology.
In Figure 6a, there exists only one route to subnet d from
router r1. In case of a link failure to that route, there is no
alternative route available to subnet d despite the existence
of the loop. In the topology of Figure 6b, the loop provides
two possible routes from router r1 to subnet d. There is an
alternative route available if a link failure occurs within this
141
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

loop. However, if the link failure occurs beyond this loop,
all routes to subnet d from router r1 become defunct and no
alternative route exists (Figure 6c).
If router r1 is a conventional RIP router, the topology
of Figure 6a is prone to routing loops and the CTI prob-
lem. Router r1 accepts malicious routing updates to subnet
d from its neighbors. Section 5.3 presents the test results
with RMTI instead of RIP in operation and demonstrates
the main advantage of RMTI over RIP. Complex network
topologies with multiple loops are composed of the basic
topologies in Figure 6. Section 5.4 demonstrates the abil-
ity of RMTI to handle these complex network topologies.
The test results show that RMTI is far superior in solving
routing decisions as compared to standard RIP.
We implemented RMTI on top of an existing RIP router
in order to perform the following performance tests. Thus,
we are able to demonstrate the applicability of the RMTI
approach in real deployment environments and substantiate
its beneﬁts, especially compared to standard RIP.
We use the well-known and widely used Quagga routing
software suite to enable and explore the routing process. The
Quagga routing suite consists of several advanced routing
software daemons for Linux and Unix-like systems, where
the ripd daemon implements the RIPv2 protocol used as the
underlaying routing protocol. We additionally implemented
a communication link in a network test environment which
allow us to inﬂuence the succession of routing updates and
evaluate network situations frequently.
5.1
The Test Environment
Figure 7 shows the operation schema of our test environ-
ment we developed in order to evaluate the performance of
our RMTI daemon. We extended our routing daemon by
a client-server communication to a supervisor which allows
us to inﬂuence the succession of routing updates and the
logging of all local information which appear on the rout-
ing daemon. Thus, we get a comprehensive representation
of the available network information. The supervisor allows
us to manipulate the routing behavior of every routing dae-
mon by triggering updates in a predeﬁned sequence in or-
der to test critical network situations like the CTI problem.
Our evaluation focused on topologies containing a loop. In
Figure 7: The operation scheme of our test environment
topologies without a loop RMTI works just as well as stan-
dard RIP. We examined both routing daemons on a huge
number of various network scenarios to verify the beneﬁt
of RMTI when it was exposed to the CTI problem and to
verify the equality in the absence of the CTI problem. We
performed a frequent modiﬁcation of the network topology
by using the open source virtualization tool Virtual Net-
work User Mode Linux (VNUML) [19] which is based on
User Mode Linux (UML) [4]. Using User Mode Linux is an
eﬃcient way to run various Linux systems inside one physi-
cal machine and connect them via virtual interfaces to build
up arbitrary network topologies. VNUML is a comfortable
tool to quickly design and boot up virtual network scenarios.
A VNUML network can be administered and used just like
a network with real Linux machines. Virtualization tech-
niques are especially good for setting up arbitrary network
topologies. They provide an opportunity to utilize real oper-
ating systems and routing software without the need for all
the hardware like routers, switches and the cabling. Apart
from this, a modiﬁcation of the virtual network topology
is much easier and quicker to perform than with real net-
works. Virtualization techniques are particularly suited to
support the study of routing performance in complex net-
work topologies. As we didn’t want our RMTI daemon to
become heavily optimized for virtual networks, we addition-
ally connected real router hardware to our VNUML virtual
networks. We used Linksys WRT54G routers equipped with
the open source router operating system openwrt [20], which
is a Linux-based routing system. Thus, we also tested the
functionality of our RMTI daemon on real router hardware.
VNUML additionally oﬀers a complex but ﬂexible network
topology.
Our supervisor consists of a routing update generator which
can coordinate all updates, so that all crucial succession pat-
terns (latency and timing issues) in a speciﬁc topology will
be exhausted. First, a topology of routing daemons has to
be chosen and launched by VNUML. Second, all paths which
contain a loop have then to be identiﬁed and represented.
Third, this knowledge is used by the generator to control
the updates of every routing daemon, to provoke a situation
where the CTI problem will arise. Additionally all events are
logged. After these initial conditions have been established,
all routers are switched back to automatic mode, where they
are no longer controlled and act autonomously. The provo-
cation of a CTI causes the one update with old information
to be injected into the topology loop, and the routing pro-
tocol has to react to this event. As shown in this section,
RIP propagates faulty information and the course of CTI
events begins within the topology loop. Metric changes are
displayed directly in the test environment so CTIs can be
observed or detected automatically. The curve diagrams de-
picted in this section describe the metric progression of a
considered route on a distinct router in diﬀerent network
scenarios.
All network scenarios described in this section
were performed in our test environment and analyzed with
our supervisor.
5.2
The Counting to Inﬁnity Problem
In the following we demonstrate the occurrence of the CTI
problem within the network scenario exempliﬁed by Figure
8, which is the basic topology of Figure 6a. Starting from
router r1, which holds a route to subnet d via neighbor in-
terface B with metric mB = 3, we assume that the link to
142
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

Figure 8: The CTI problem arises.
Figure 9:
The curve follows the metric of the route
to subnet d on router r1.
It depicts the course of CTI
events.
subnet d via router r4 becomes corrupted. This is announced
by an update which router r1 receives from r4 and, therefore,
the corresponding route in r1’s routing table is marked as
unreachable. Next r1 receives a routing update via neighbor
interface A from router r3 advertising an alternative route
to subnet d (via r2) with metric mA = 6.
However, the
routing information of this update was propagated along a
Source Loop.
If router r1 is a conventional RIP router, it will accept
this faulty routing update from r3, adapt its routing table,
and propagate the new routing information. Then a routing
loop is established and the course of CTI events will begin.
Moreover, as long as the CTI events have not come to an
end, a forwarding loop exists and a large amount of network
bandwidth is consumed, due to data packets having been
sent to subnet d and circulating in the forwarding loop. The
CTI events also suppress the propagation of the correct rout-
ing update announcing the subnet as unreachable. Existing
RIP extensions like triggered updates would speed up the
CTI problem but in the worst case routing updates would
get lost and the elimination of the routing loop would re-
quire more time. The RIP extension Split Horizon also does
not avoid the CTI problem in this situation.
The curve chart in Figure 9 refers to the network situa-
tion described in Figure 8. It shows the metric values of the
route to subnet d, captured on the router r1 while the events
of the CTI sequence are progressing. The y-axis represents
the metric of the route to subnet d in the range from 0, as
the destination subnet is unknown to the router r1, to 16,
as the destination subnet is known with metric 16 (inﬁn-
ity). The x-axis represents the number of check and update
events in relation to the corresponding route entry in the
routing table of the regarded router, e.g., incoming updates.
Metric changes are directly displayed in a time-synchronous
manner. The curve chart is generated automatically by our
supervisor.
The curve chart in ﬁgure 9 shows the metric of the route
to subnet d on router r1 and describes the CTI progression.
As depicted in the chart, router r1 holds a route to subnet
d via router r4 with metric 3 (x-axis 1-9). Just before the
CTI arises, the route to subnet d becomes corrupted (x-axis
10) and router r1 marks it with inﬁnity (metric 16). Next,
router r1 gets a supposed alternative route to subnet d from
router r3 with metric 6 (x-axis 11). However, this route is
outdated and invalid and belongs to a path which already
includes router r1. If router r1 is equipped with standard
RIP, it accepts the route to subnet d via router r3 and a
routing loop occurs. The sequential incrementation of the
metric up to inﬁnity (x-axis 12-15) is the characteristic of
the CTI problem.
5.3
Basic Topologies
The CTI problem in Figure 8 is prevented by router r1,
if it is enhanced with our RMTI approach. Regarding the
situation in Figure 8, the routing update from r3 will be re-
jected by r1 and subnet d is kept unreachable in r1’s routing
table because there is no Simple Loop spanned over router
r3 and r4.
The test results captured on router r1 are shown in Fig-
ure 10. The separate, unﬁlled, downward pointing triangle
indicates that RMTI on r1 receives and rejects the criti-
cal update that would have induced the CTI problem (gray
curve in the background of Figure 10). The symbols and
curve lines used are explained in the corresponding legend
of each curve chart.
In the network situation of Figure 8, the RMTI router
r1 decides whether the update from router r3 should be ac-
cepted or not after a link failure.
As there is no Simple
Loop between r3 and r4, the same information cannot be
advertised from both routers.
The following case study (see Figure 11) refers to a pitfall
of Simple Loop detection. It is not suﬃcient to perform the
Simple Loop Test (Equation 1, Section 4.2) just with the
last valid entry for a subnet d in the forwarding table of a
router ri. This may lead to detecting a Source Loop as a
Simple Loop by mistake. Instead, we always have to use the
smallest metric for subnet d recently known by ri.
Starting from router r1, which holds a route to subnet d
via r2, we assume that subnet d becomes unreachable due
to a link failure behind r2. Router r2 sends a routing up-
date with metric 16 to router r1 and r4. Router r1 adapts its
routing table and advertises the new information about sub-
net d to its neighbors. Before router r4 receives this routing
update from r2, it sends a routing update with old invalid
reachability information about subnet d to r1. Router r1
accepts the routing update from r4 as seemingly new infor-
mation about subnet d.
Additionally, we assume the situation is similar to the CTI
Figure 10:
The CTI is prevented by RMTI router r1
discarding the faulty route information from r3.
143
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

Figure 11:
The CTI problem arises.
In this situation
using the right values to perform the Simple Loop Test
is essential to detect all Simple Loops correctly.
problem in Figure 8. Router r5 receives the routing update
with metric 16 which was sent from r1 before. Router r5
adapts its routing table and marks the route to subnet d as
unreachable. However, router r3 does not receive the rout-
ing update from r1 and keeps its route to subnet d as reach-
able. Next, router r5 receives a routing update from r3 with
seemingly alternative reachability information about subnet
d. Router r5 accepts this route information and advertises
it to r1.
Although router r1 does not accept the routing
update, it detects a Simple Loop between its neighbor in-
terfaces A and D. This is because r1 receives information
about subnet d from r4 with metric mD = 3 and from r5
with metric mA = 5 and the Simple Loop Test of r1 is passed
with mA < mrpmA + mD ⇒ 5 < 3 + 3. Hence, a CTI could
occur, due to a falsely detected and stored Simple Loop.
We handle such situations by not immediately adjusting
the internal data of RMTI with every accepted routing up-
Figure 12: The curve diagram of the CTI problem in
relation to Figure 11.
Figure 13:
The CTI problem is prevented by RMTI
using always the shortest route to the destination subnet
of the recent past.
date that changes the routing table. The RMTI has to be
performed with the smallest metric of the route to subnet
d seen in a short time interval before the metric is changed
to a higher value or is set to inﬁnity. Therefore, we have to
store the smallest metric of the recent past. The time inter-
val should depend on the RIP update timer interval. In this
case r1 receives redundant information about subnet d from
r4 and r5 but RMTI still uses the information about subnet
d from r2 with metric mB = 2. Thus, the Simple Loop Test
fails with mA < mrpmA + mB ⇒ 5 < 3 + 2 and the Source
Loop is detected.
If router r1 marks its route to subnet d as unreachable and
gets a routing update from r5 with seemingly new informa-
tion about subnet d, r1 recognizes the malicious update by
the missing Simple Loop between its neighbor interfaces A
and B. The curve chart in Figure 12 shows the succession of
metric changes while the CTI problem occurs. However, as
shown in Figure 13, although the routing information which
returns to the router is no longer available in the routing
table, RMTI can prevent the CTI problem.
5.4
Complex Topologies
In complex topologies the Simple Loop Test is needed (see
Equation 1, Section 4.2) to prevent the CTI problem. In
Figure 14, the network topology that was shown in Figure
8 is extended by a link between router r3 and r4. In this
topology, a routing update sent from router r3 to r1 might
contain valid reachability information about subnet d be-
cause of the existing Simple Loop. If r1 loses the route to
subnet d via r4, subnet d could be either still reachable or
completely unreachable depending on the unknown location
of the failed link. If the link between r1 and r4 fails, subnet
d will still be reachable for r1 via r3. Whereas if the link
between r4 and r5 fails, subnet d will become unreachable
for r1. However, if the CTI problem occurs, RMTI can still
cope with these situations.
If the link between router r4 and r5 is corrupted and sub-
net d is not reachable anymore, then router r4 will propagate
a routing update to its neighbors r1 and r3. Both accept the
new route information from r4 and mark their route to sub-
net d as unreachable. But router r2, having learned the route
from r1, sends a routing update with old route information
to r3. Router r3 accepts this update from r2 as a new valid
route and replaces the old route entry in its routing table. If
the routing update is then announced back to r1, a Source
Loop will appear. The RMTI router r1 detects this Source
Loop and prevents the CTI problem by rejecting the routing
update from router r3. The Simple Loop Test of r1 fails with
mA < mrpmA + mB ⇒ 6 < 3 + 3. Therefore, the Source
Loop is detected due to the inappropriate metrics.
However, due to an invalid old routing update from r3 very
shortly after the link failure was perceived by r1 but not yet
by r3, router r1 accepts the old invalid information about
subnet d from r3 as a seemingly valid alternative route. This
cannot be prevented because the routing update from r3
could be invalid old route information as well as a valid
alternative route information, e.g., if either the link between
r4 and r5 or the link between r1 and r4 became corrupted.
Again, the major question in this situation concerns the
data used in the Simple Loop Test.
Assuming router r1
and r3 lost their route to subnet d. Then shortly after r1
marks the route as unreachable, it accepts a faulty old rout-
ing update from r3 with invalid route information. Router
144
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

Figure 14:
Such a faulty routing update is generally
diﬃcult to detect for routers because the location of the
link failure creates an ambiguous situation.
However,
the acceptance of the update does not induce a CTI in
this case and does not confuse RMTI router r1 which can
still prevent the occurrence of the CTI problem.
Figure 15: RMTI router r1 is able to detect this routing
update via the Simple Loop Test.
r3 immediately corrects this by sending another routing up-
date announcing subnet d as unreachable. Router r1’s last
valid route to subnet d describes a path via r3 whereas r2
still has the old route information from r1. If this route in-
formation is announced back to r1 in a Source Loop via r3,
as described in Figure 15, the Simple Loop Test in r1 per-
forms mA < mrpmA + mB ⇒ 6 < 4 + 3 and is passed with
6 < 7. Hence, if RMTI router r1 would perform the Simple
Loop Test in this way, simply with the latest valid metric of
the route from the routing table, it would accept the routing
update and the CTI problem would occur in this situation.
With the topology explained in Figure 11, we have shown
how to handle such situations by not immediately adapting
new route information from the routing table into RMTI.
The behavior of the Simple Loop Test is stricter with lower
metrics than with higher metrics. In this situation RMTI
ignores the routing update from r3 with metric 4 long enough
Figure 16:
The RMTI ignores routing updates which
are advertised directly after a route failure because they
could cause confusion. The routing update from r3 (x-
axis 16) is ignored by RMTI, otherwise the CTI problem
could not be prevented.
and prevents the CTI problem. The metric progression of
this network situation is shown in Figure 16.
5.5
Indistinguishable Routes
A special case is shown in Figure 17 where the decision to
accept or to reject a route not only depends on the length
of the routes’ metrics. It may be possible that the metric
of an alternative route is equal to or even larger than the
limit given by the Simple Loop Test. As shown in Figure 17,
the routing updates may contain a valid alternative route to
subnet d (dashed line) or an invalid Source Loop (dotted
line). Both variants of routing updates advertise the same
metric 6 to r1. The Simple Loop Test of r1 performs mA <
mrpmA + mB ⇒ 6 < 3 + 3 and fails with 6 < 6. Therefore,
the routing update is rejected by the RMTI router r1.
Figure 17 shows a Source Loop (dotted line) and an al-
ternative path (dashed line). Router r1 cannot distinguish
the diﬀerence between these paths due to the same metric.
In order to solve this decision problem, RMTI uses a timer
to limit the execution time of the Simple Loop Test. RMTI
supposes that Source Loops can be deleted by sending a
routing update with metric inﬁnity. Then a timer is started
for a given time interval and further incoming routing up-
dates with a valid metric will be blocked. If within this time
interval a routing update with metric 16 is transmitted by
r3, a Source Loop has just been deleted and a CTI is pre-
vented. If the timer expires and the route is still oﬀered with
a valid metric, it has to be a valid route. As the critical pe-
riod for CTI situations is rather short, the timeout interval
Figure 17:
RMTI has to distinguish between a valid
and an invalid routing update with the same metric an-
nounced via the same neighbor interface.
Figure 18: RMTI mainly decides on metrics. However,
if a route is refused by RMTI, it will be blocked just
for a short time interval. During this time interval, an
existing Source Loop should be deleted by a transmitted
routing update.
145
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

Time
Route Status
RIP
RMTI
Start
Insert the route into the routing table and use it for forwarding.
Phase 1
Default
timeout
timer
is
reini-
tialized with every incoming up-
date. By default the timeout timer
expires after 6 missing updates.
(route metric < inﬁnity)
Shorter routes overwrite longer
routes.
Shorter
routes
overwrite
longer
routes. The minimal Simple Loops
are identiﬁed and stored
The route becomes
invalid (e.g., time-
out timer expires)
Set the metric to inﬁnity and do not use it for forwarding. Stop the timeout timer and start the garbage
collection timer.
Phase 2
Default
garbage
collection
timer
will be stopped by an incoming up-
date with a metric smaller than in-
ﬁnity. (route metric = inﬁnity)
The ﬁrst routing update adver-
tised with a metric smaller than
inﬁnity is accepted as alternative
route.
Only routes in a Simple Loop with
the route’s adjacent subnet are ac-
cepted as alternative routes.
Garbage Collection
Timer expired.
Delete the route from the routing table.
Table 2: Comparison between RIP and RMTI operation phases
of the timer can be short, too. The timer could depend on
the routing update interval or on the metric of the Simple
Loops involved.
The curve diagram in Figure 18 shows the test results of
the RMTI router within the network situation described in
Figure 17. First, the CTI problem is avoided and no alter-
native route to the destination subnet (x-axis 18-23) exists.
Second, a valid alternative route is advertised by router r3;
again r1 rejects the update for the ﬁrst time (also an in-
coming update from router r2) but then the timer expires,
a request is sent, and the alternative route is accepted next
(x-axis 24-26).
6.
IMPLEMENTATION OF RMTI
Up to now we have implemented RMTI as a slight ex-
tension to standard RIP. RMTI simply enhances RIP on
detection of topology loops and prevention of routing loops.
There is no need to change the RIP interaction behavior or
any of the RIP message formats. Therefore, RMTI is com-
patible with RIP and both can be deployed on routers in
the same network. In this section we introduce the imple-
mentation of RMTI in more detail and describe the changes
which must be made in an existing RIP implementation.
The template of a RMTI implementation which is described
here is based on our existing RMTI daemon implementation.
RMTI is implemented as an extension to the RIP update
procedure of the routing table in which the present route in-
formation is compared with incoming new route information
about the same destination subnet.
The control ﬂow of the entire RMTI process is described
in a ﬂow chart in Figure 19. As shown in Figure 19a, the
RIP implementation has to be extended at a particular point
where the RMTI enhancements are then implemented. The
control ﬂow diagram is divided into a data collection phase
(Figure 19b) and a decision phase (Figure 19c) in relation
to the two distinct phases RMTI mainly operates in. Simple
Loops will be detected in the data collection phase whereas
Source Loops will be prevented in the decision phase. If the
present route in the routing table is valid and an alterna-
tive route to the same subnet is advertised to the RMTI
router, the metric of the corresponding path composed of
the two routes will be calculated by equation 2 (see Sec-
tion 4.2). The obtained path is a Simple Loop if equation
1 holds. Only the Simple Loop with the smallest metric is
stored as the minimal Simple Loop of the corresponding two
neighbor interfaces for further use. This happens as long as
the route to the destination subnet is still available with a
valid metric. When the route becomes invalid and is marked
as unreachable in the routing table, the information about
the existing Simple Loops is used to decide, whether or not
to accept an advertised alternative route to the subnet via
another neighbor router. Table 2 summarizes all operation
phases and compares the behavior of RMTI with standard
RIP.
constant name
meaning
RMTIinﬁnity
RIP inﬁnity ∗2
RMTIalive
RIP timeout timer +
RIP garbage collection timer
Table 3: RMTI constants
variable name
meaning
destination
the IP-address of the destination subnet
of the route.
metric (mB)
the distance to the destination subnet.
nexthop
the next hop router (or gateway) along
the route to the destination, this is the
IP-address of the neighbor interface.
timer
the amount of time since the entry was
last updated.
rmti oldmetric
the last valid metric, used to calculate the
metric of the path combination when the
route is timed out and the metric is set to
inﬁnity.
rmti oldnexthop
the
corresponding
next
hop
to
the
rmti oldmetric variable.
rmti validity
a boolean variable which indicates the
phases the RMTI protocol operates in
(RMTI data collection phase or RMTI de-
cision phase).
rmti synctime
a time stamp variable which speciﬁes a
time interval to control the point when the
old metric and the old next hop should
be adjusted with the information in the
routing table.
rmti checktime
a time stamp variable which marks the
route in the routing table to recognize
route advertisements which have already
been rejected before.
Table 4: The variables in the route structure
146
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

check the old route 
information in the
routing table
RMTI Decision
start
rmti_validity
m     < msilm  
?
the information in the 
routing table is timed out, 
check for Source Loops,
calculate metric (m     )
of the path combination,
checkout msilm  
false
true
false
there is a Simple Loop
between next hops A and B,
check for a complex topology
and multiple loops over hop B
#msilm    = 1
there is exactly one 
Simple Loop between
the next hops A and B
false
?
Source Loop detected,
send a response message
to all neighbor routers, 
enable rmti_checktime
m  < m r p m  + m  
true
?
true
return
true
end
end
return 
false
rmti_checktime
activated
?
the route information 
in the routing table 
is marked, there was 
a check of m  before
rmti_checktime
expired
?
true
true
the route information 
was not checked before
false
false
false
true
there are multiple loops,
check for an existing
Simple Loop with the
Simple Loop Test,
checkout mrpm
?
the new route information
with metric m   is valid
and can replace the old one
check if the 
RMTI information
has to be adjusted 
with the information
in the routing table
update rmti_validity,
rmti_oldmetric 
and rmti_oldnexthop
with information
from the routing-table,
reinit rmti_synctime
true
RMTI Data Collection
start
(rmti_synctime
expired or
m <rmti_oldmetric)
?
false
do not update rmti_validity, 
rmti_oldmetric and 
rmti_oldnexthop, 
replace msilm 
with m    ,
check mrpm  
and mrpm  to
be minimal
false
return
(m <mrpm +m 
and
m     <msilm    )
true
rmti_validity
?
the existing information
in the routing table is
valid, checkout
msilm    and mrpm  , 
calculate the metric 
(m     ) of the
path combination
end
true
false
?
incoming (route)
reachability information
destination
subnet already
known
add/change 
route information
to/in the routing table
true
false
reject the
new route 
information
true
false
RMTI Routing Decision Process
route information is 
already existing,
compare old and new
(same next hop or
better metric)
start
?
?
RMTI Decision
?
true
false
controlflow of
conventional RIP
implementations
RMTI Data Collection
end
(a)
(b)
(c)
A
A
B
A,B
i,d,i
A,B
A,B
i,d,i
A
B
A,B
i,d,i
A,B
A
A
A
B
A
X,B
A,B
A,B
i,d,i
A,B
i,d,i
B
A,B
A,B
B
X   {hops}
*
(
(2)
(3)
(4)
(5)
(6)
(7)
(1)
(2)
(3)
(5)
(6)
(4)
i,d
A
i,d
i,d
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
i
Figure 19: Flow charts of the RMTI implementation
(a) The ﬂow chart of the entire RMTI process embedded in standard RIP. The RMTI algorithm can be
implemented as a separate procedure independent of the existing implementation.
(b) The procedure of collecting information data by RMTI. If the route to the destination subnet in the
routing table is available, the RMTI detects Simple Loops and stores the minimal one.
(c) This is the core procedure of RMTI which is entered only if the route in the routing table is marked
with metric 16 (inﬁnity) and might be replaced by the new alternative route information. Depending on the
relation between the metric of the combined path of the two routes and the corresponding msilm value the
return value of RMTI is true if the new route information meets all requirements of RMTI or false if not (see
Equation 1, Section 4.2). Nevertheless, if the new alternative route information is accepted by RMTI, it also
has to pass the remaining RIP decision procedures to be eventually inserted in the routing table. However,
it will be completely discarded if the new alternative route is refused by the RMTI.
147
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

6.1
Constants and Data Structures
Based on a RIP implementation as underlaying router
platform, there are two new constants necessary for an im-
plementation of RMTI. They are constructed on well-known
RIP constants. Table 3 describes the RMTI constants and
their relation to the existing RIP constants. RMTIinﬁnity
correlates to the inﬁnity metric of RIP and marks a detected
Simple Loop as no longer valid. RMTIinﬁnity corresponds
to the longest possible Simple Loop metric calculated by
equation 2 (see Section 4.2), when both routes to the des-
tination subnet are marked as unreachable with metric in-
ﬁnity. As the metric of inﬁnity is 16 in standard RIP, the
metric of RMTIinﬁnity is 31.
The timeout constant RMTIalive corresponds to the num-
ber of seconds before a detected Simple Loop is marked as
invalid with metric RMTIinﬁnity. RMTIalive is deﬁned by
the sum of the timeout timer and the garbage collection
timer of the underlaying standard RIP implementation.
In comparison with RIP, RMTI needs a slightly modiﬁed
routing table with a few additional constants. The routing
table of standard RIP contains routes consisting at least of
the destination subnet, the next hop router, and the metric
of the route. Furthermore, a timer variable is needed to han-
dle invalid routes. Table 4 describes all variables of a route
entry in the routing table, which have to be implemented
within RMTI based on RIP. Furthermore, RMTI uses two
global tables, called msilm and mrpm table.
Both tables
store the metrics of the detected minimal Simple Loops to
be used for the decision whether to accept or reject an al-
ternative route advertisement.
The msilm table (see Table 5) stores the minimal simple
loop metric.
An entry in the msilm table consists of the
two related neighbor interfaces which are identiﬁed by the
source IP addresses of the incoming routing updates and the
calculated metric of the corresponding Simple Loop. Addi-
tionally, a timer variable is used to detect if a Simple Loop
is corrupted and the corresponding msilm entry is not valid
anymore. Although the complexity of the msilm table in-
creases quadratically with each stored metric, the msilm ta-
ble remains rather small because the maximum number of
Simple Loops depends on the number of neighbors.
The
msilm table is symmetric, i.e., the table entry msilmA,B is
equal to entry msilmB,A. There is no need to store both
values, so the table can be linearized to save storage space
and speed up access rates.
The mrpm table (see Table 6) contains the minimal return
path metric addressed with the one corresponding neighbor
interface. The mrpm entry corresponds to the smallest met-
ric of any Simple Loop which starts at the speciﬁc neigh-
bor interface and returns at the router via another arbitrary
neighbor interface.
Thus the mrpm entry is the smallest
msilm value of a distinct neighbor interface and could be
implemented as a reference to the corresponding msilm en-
try.
If the topology changes or a neighbor router becomes
corrupted, the corresponding mrpm entry must be deleted.
Therefore, the validity of the mrpm entry is proved with
a timer variable and marked with RMTIinﬁnity when the
timer expires.
6.2
The RMTI Data Collection Phase
As long as the route in the routing table is valid with a
metric lower than inﬁnity, RMTI gathers information about
Simple Loops in relation to the subnet under considera-
tion and updates the msilm and mrpm tables (Figure 19b).
When the RMTI data collection phase is provided with fur-
ther routing updates, the rmti synctime variable is being
evaluated ﬁrst. The rmti synctime variable is needed to cope
with the problem of malicious updates (see Section 5.3). The
information in the msilm and mrpm tables are not adjusted
as soon as new routing information is entered in the routing
table, but also the rmti synctime variable has to be expired.
If the given time interval is exceeded, it will be reset and
the present information in RMTI will be adjusted with the
information in the routing table.
Due to malicious routing updates which would aﬀect RMTI
negatively, we do not use the very last route information
from the routing table but instead the last route informa-
tion with the smallest metric in the given time interval. If
the rmti validity variable is false (resp. metric = infinity),
the process will be aborted, because the considered route in
the routing table is marked as unreachable and could not be
part of a Simple Loop. If the rmti validity variable is true
(metric < infinity), RMTI will detect and update Simple
Loops.
The Simple Loop Test is used to prove if the new incoming
alternative route and the present route in the routing table
can be combined to a valid Simple Loop. If the Simple Loop
Test passes successfully, the metric of the detected Simple
Loop will be calculated.
The Simple Loop with the smallest metric is stored as
the minimal Simple Loop metric according to the two corre-
sponding neighbor interfaces in the msilm table. If a msilm
entry is changed, the mrpm entries of each neighbor inter-
face must be recalculated. Then the RMTI data collection
phase has come to an end and the decision phase has started.
6.3
The RMTI Decision Phase
Figure 19c describes the control ﬂow of the RMTI deci-
sion phase. In this phase an alternative route would be com-
pletely rejected or passed along to the standard RIP decision
process. At the beginning of the RMTI decision phase the
rmti checktime variable is checked in order to handle indis-
tinguishable routes we have explained in Section 5.5. When
an identical routing update was rejected by RMTI in the
recent past, the rmti checktime variable contains the time
since the ﬁrst rejection.
variable name
meaning
interfaceA
the IP address of the neighbor interface A
interfaceB
the IP address of the neighbor interface B
msilmA,B
the minimal Simple Loop metric between
the neighbor interfaces A and B
timer
the amount of time since the msilm entry
was last acknowledged by routing updates
Table 5: The structure of the msilm entry
variable name
meaning
interfaceA
the IP address of the neighbor interface A
mrpmA
the minimal return path metric of neigh-
bor interface A
timer
the amount of time since the mrpm entry
was last acknowledged
Table 6: The structure of the mrpm entry
148
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

If the value of the rmti checktime variable exceeds a prede-
ﬁned time span an incoming alternative route will be passed
along to the conventional RIP decision process without any
further checks by RMTI and the rmti checktime variable
will be set to zero. If the rmti checktime variable is zero an
incoming alternative route will always be checked by RMTI.
If rmti validity is true (resp. metric < infinity), a valid
route exists in the routing table and the RMTI decision
phase can be aborted without further consideration. If it
is not true (metric = infinity), the new route information
has to be processed to decide if it can replace the existing
route information in the routing table. RMTI calculates the
metric of the path combination and compares it to the msilm
entry msilmi
A,B. If msilmi
A,B is higher, then no Simple Loop
has been detected between the two neighbor interfaces in-
volved and the new route information can be completely
rejected. If any Simple Loop exists between two neighbor
interfaces, the metric of the smallest Simple Loop is stored
in the msilm table.
Otherwise, if no Simple Loop exists,
the msilm table contains the initial value RMTIinﬁnity for
this pair of neighbor interfaces. If a Simple Loop is stored
in the msilm table, the presence of multiple loops must be
excluded before the alternative route information can be ap-
proved. Dealing with multiple loops is more complex. We
have explained the characteristics of complex topologies in
Section 5.4.
Complex topologies can be discovered by counting the en-
tries of a neighbor interface in the msilm table. If the neigh-
bor interface of the old existing information has exact one
entry listed in the msilm table, it has only one Simple Loop
with another neighbor interface. Then the new alternative
route information is passed along. If a complex topology is
discovered, the Simple Loop Test (Equation 1, Section 4.2)
has to be performed. If the Simple Loop Test fails, the new
route information must be rejected and the present route
information with metric inﬁnity will be kept. If the Simple
Loop Test passes, the new alternative route information will
be accepted and passed along to the routing decision process
of RIP.
As described in Section 5.5, due to indistinguishable routes
with equal metrics, a new alternative route information is
blocked by RMTI within a short period of time. When the
ﬁrst rejection of a route occurs, the rmti checktime variable
for the existing route in the routing table is activated and
a corresponding routing update with metric inﬁnity is sent
out to all neighbors. This routing update will delete an ex-
isting Source Loop by purging the malicious route entries in
all routers involved. Then any correlated CTI problems and
routing loops are prevented.
If the present route in the routing table is marked as un-
reachable and there is a valid alternative route to the same
destination subnet with an indistinguishable metric, then
the ﬁrst incoming corresponding routing update would be
rejected by RMTI. But the convergence time would not be
appreciably impaired due to the rmti checktime variable.
7.
CONCLUSION
It has been shown that our new RMTI protocol can rec-
ognize loops and therefore oﬀers better convergence prop-
erties than other distance vector routing protocols. On the
other hand, it is fully compatible with RIP by evaluating
the common RIP updates more carefully. Every router can
thus recognize all loops starting and ending at the router.
This loop knowledge is used together with the states of the
routing table before and after a network change in order to
decide on the acceptance or rejection of an incoming new
routing update. It has been shown that our RMTI protocol
can handle simple and complex topologies as well. Problems
like counting to inﬁnity can no longer appear because we can
detect every routing update from a router via a loop back
to the same router. Therefore RMTI does not need to cal-
culate with a given hop-count-limit like standard RIP does.
As RMTI is a solution to the routing loop problem, over-
head prone techniques like ﬂooding of routing updates are
not necessary. Investigations in our test environment showed
that RMTI can converge faster than other distance vector
routing protocols. In contrast to link-state protocols, RMTI
allows the administration of local routing policies, which is
a powerful method in order to impact the traﬃc density in
the network. As RMTI does only a few additional loop tests
in comparison to RIP, the runtime complexity grows still
linearly with the number of subnets in a network domain.
Further investigations will be done to ﬁnd rules for the
optimization of the timer adjustments in order to maximize
the beneﬁt of the new RMTI technique. We will oﬀer our
new protocol as a Quagga daemon for Linux in order to
invite readers to try out this new routing protocol. As RMTI
can prevent all problems triggered by routing loops, it is a
crucial improvement on the distance vector approach.
8.
REFERENCES
[1] Ch. Steigner, H. Dickel, and T. Keupen, RIP-MTI: A
New Way to Cope with Routing Loops, in Proceedings
of the Seventh International Conference on
Networking (ICN 2008), Cancun, Mexico , 2008.
[2] F. Bohdanowicz, H. Dickel, and Ch. Steigner,
Metric-based Topology Investigation, in Proceedings of
the Eighth International Conference on Networking
(ICN 2009), Gosier, Guadeloupe/France, 2009.
[3] C. Cheng, R. Riley, S.P.R. Kumar, and J. J.
Garcia-Luna-Aceves, A loop-free extended bellman-ford
routing protocol without bouncing eﬀect, ACM Sigc.
Symp. Commun. Arch. and Prot., pp. 224-236, 1989.
[4] J. Dike, User Mode Linux, Prentice Hall, 2006.
[5] B. Rajagopalan and M. Faiman, A new responsive
distributed shortest-path routing algorithm, ACM
Sigcomm Symposium Commun. Arch. and Protocols,
pp. 237-246, 1989.
[6] Francois, P. Bonaventure, O., Avoiding Transient
Loops During the Convergence of Link-State Routing
Protocols, Transactions on Networking, IEEE/ACM
Volume: 15, Issue: 6, Dec. 2007
[7] J.J. Garcia-Luna-Aceves, Loop Free Routing Using
Diﬀusing Computations, IEEE Transactions on
Networking, 1993.
[8] Hengartner, U., Moon, S., Mortier R., and Diot, C.,
Detection and Analysis of Routing Loops in Packet
Traces, Proc. of 2nd Internet Measurement Workshop
(IMW 2002), Marseille, France, November 2002
[9] Kirill Levchenko, Geoﬀrey M. Voelker, Ramamohan
Paturi, and Stefan Savage , XL: An Eﬃcient Network
Routing Algorithm, Proc. Sigcomm 2008, August,
2008.
[10] G. Malkin, RIP Version 2, RFC 2453, 1998, URL:
http://tools.ietf.org/html/rfc2453, 05.08.2009.
149
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

[11] J. Moy, OSPF Version 2, RFC 2328, 1998, URL:
http://tools.ietf.org/html/rfc2328, 05.08.2009.
[12] D. Pei, X. Zhao, D. Massey, and L. Zhang, A Study of
BGP Path Vector Route Looping Behavior, IEEE
International Conference on Distributed Computing
Systems (ICDCS), March, 2004.
[13] C. E. Perkins, Ad hoc networking, Addison-Wesley,
Amsterdam 2001.
[14] C. E. Perkins, E. Belding-Royer, S. Das, Ad hoc
On-Demand Distance Vector (AODV) Routing, RFC
3561, 2003, URL: http://tools.ietf.org/html/rfc3561,
05.08.2009.
[15] Jian Qiu, Feng Wang and Lixin Gao, BGP Rerouting
Solutions for Transient Routing Failures and Loops, in
Proceedings of MILCOM, October, 2006.
[16] Quagga home page, http://www.quagga.net/,
05.08.2009.
[17] Y. Rekhter, T. Li, S. Hares, A Border Gateway
Protocol 4, RFC 4271, 2006, URL:
http://tools.ietf.org/html/rfc4271, 05.08.2009.
[18] A. Schmid and Ch. Steigner, Avoiding Counting to
Inﬁnity in Distance Vector Routing,
Telecommunication Systems 19 (3-4): 497-514, March
- April, 2002, Kluwer Academic Publishers.
[19] VNUML Project home page,
http://www.dit.upm.es/vnumlwiki, 05.08.2009,
Technical University of Madrid (UPM).
[20] OpenWRT Project home page,
http://www.openwrt.org, 05.08.2009.
[21] Andrew S. Tanenbaum, Computer Networks, 3rd ed.,
Prentice Hall PTR, 1996, pp. 358-359
[22] Zifei Zhong, Ram Keralapura, Srihari Nelakuditi,
Yinzhe Yu, Junling Wang, Chen-Nee Chuah and
Sanghwan Lee, Avoiding Transient Loops Through
Interface-Speciﬁc Forwarding, Transactions on
Networking, IEEE/ACM, Volume: 15, Issue: 6, Dec.
2007 Transactions on Networking, Dec. 2007
150
International Journal On Advances in Internet Technology, vol 2 no 1, year 2009, http://www.iariajournals.org/internet_technology/

