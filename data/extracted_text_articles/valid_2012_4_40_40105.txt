Model Checking Executable Speciﬁcation for Reactive Components
Bruno Blaˇskovi´c
Faculty of Electrical Engineering and Computing
Zagreb, Croatia
Email: bruno.blaskovic@fer.hr
Abstract—Finding design errors in the earliest phase of
software developments is still challenging area of research. This
paper deals with model checking of executable speciﬁcation.
Executable speciﬁcation is introduced as C program. After
that, C program is transformed into an input model for the
Spin model checker. At the end, an example for the Zune30
bug is presented.
Keywords-executable speciﬁcation; reactive component; soft-
ware model checking; model transformation
I. INTRODUCTION
Telecommunication
network
software
system
can
be
modeled
as
the
set
of
hierarchically
connected
communicating ﬁnite state automata (FSA). The basic unit
of behavior is reactive component, modeled as FSA and
referred as model M in this paper. FSA is implemented
in C language subset. Such approach provides executable
speciﬁcation for component behavior analysis. In this
paper, analysis is focused on component model checking.
Executable speciﬁcation can also serve as starting point
for test cases deﬁnition, component simulator and target
code skeleton generation. Component quality assurance is
provided through safety (“Bad things will never happen”)
and
liveness
(“Good
things
will
eventually
happen”)
properties veriﬁcation.
If property do not hold, component exhibits illegal
behavior. Model checking approach deﬁne the model and
check the properties of the model by means of assertions
(invariants) and temporal logic formulas. In the case of
illegal behavior, model checker provides counterexamples.
Counterexample consists of a set of actions that describe
paths (sequence of actions) to the errors.
FSA transitions describe dynamic behavior: C instructions
are abstractions for internal actions like method calls or
external actions like message sending/receiving events.
There are no pointers or arrays in C code yielding
straightforward translation; there is always the same FSA
with different syntax representation.
First, designer deﬁnes FSA as C program. After that,
C program is transformed to the form suitable for model
checking. In short, FSA is designer’s viewpoint about
component behavior.
In
order
to
model
check
or
verify
component
behavior
additional
commands
like
assertions
(assert(<condition>))
and
labels
are
included
into the program source. If all assertions are true, or if they
are never false, program satisﬁes “liveness” property. The
problem is where to put assertions: false assertion are hard
to detect because that part of the code can be unreachable.
Even the more, desired behavior can include another kind
of assertions that can be true “many times”, “inﬁnitely
often” or “only once”. Such “assertions” are expressed
with Linear Time Logic (LTL) formula. In Section VI-A,
an example of linear time logic formula usage is presented.
Labels are used to check regular behavior and illegal
behavior, respectively. Program is “safe” if “error” labels
are always be unreachable, and “end” labels are eventually
reachable. Program testing will not ﬁnd all false assertions,
so additional efforts are required. Model checker Spin
has built–in facilities to detect assertion violations and
unreached labels. In this paper we use model checker
Spin to ﬁnd unreached “end–state” and “non–progress”
loops. Spin can also check concurrent errors from the
speciﬁcation. We expect separate study in order to extend
speciﬁcation with concurrent issue and to improve the
abstraction for unbounded data values. Another set of
problems are space–time limits. Space time limits are
known as state explosion problem, because number of
states grows exponentially. If only part of the system,
consisting of several components is under consideration,
state explosion problem can be under control.
This paper is organized as follows. After Introduction, in
Section II related work is described. Scope and motivations
are in Section III and theoretical background is presented in
Section IV. After that, sketches of ψ–algorithms for model
transformations are introduced in Section V. Description
of a C source to the Promela code is in Section VI. The
results of an experiment are given in Section VI-A, and, at
the end, are conclusion and further research directions.
II. RELATED WORK
First, we introduce three approaches where speciﬁcation
in various formalism is translated into an model for model
checkers. The origin of formal speciﬁcation with Statechart
is introduced by Harel in [1]. Statechart is an extension
of FSA. Every statechart user deﬁnes speciﬁc properties
that are hard to express in unique speciﬁcation language,
because statechart have no unique and clear semantic.
107
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

Object–oriented statechart semantic based on Statemate tool
is formalized as labeled transition system in [2]. Graphic
editing tool TCM can produce output to SMV, NuSMV
and KRONOS model checkers. Bharadwaj and Heitmeyer
[3] uses SCR (Software Cost Reduction) tabular notation
as speciﬁcation language. SCR speciﬁcations is transformed
into an input model for Spin and SMV model checker. In
all mentioned approaches [1] [2] [3], model deﬁnition phase
prepares speciﬁcation for model checkers. Our approach
uses FSA encoded in C language. With such an approach,
we avoid problems with semi–formal statechart semantic and
the usage of speciﬁcation languages outside UML set of
diagrams.
Translating C programs to Promela [4] is another ap-
proach that checks C programs. A similar approach exists in
[5] where Promela model is extended with direct inclusion
of C code. Both approaches [4] and [5]) addresses C–code
model checking. Our approach targets model checking of
speciﬁcation modeled as C program.
In [6] [7], cbmc C program model checker is described.
C source is abstracted as Boolean program that is checked
with satisﬁability (SAT) tool. Our approach uses model
extractor that is the part of cbmc. Extracted FSA follows
BNF deﬁnition for FSA introduced later in Figure 4. We
ﬁnd this combination of tools useful because cbmc extracts
models and Spin can check properties expressed in linear
time temporal logic. At the end of this Section, the model
checking fundamentals are introduced in [8]. Explicit state
model checker Spin with industrial strength experience is
described in [9]. Spin modeling language is called Promela.
III. SCOPE AND MOTIVATION
It is well known fact that design errors like deadlock
states, non–progress loops, illegal program termination, and
message buffers overﬂow must be discovered as early as
possible during the software life cycle. This paper is fo-
cused on executable speciﬁcation analysis and the model
transformation of executable speciﬁcation to Promela model.
For that purposes an illustrative example regarding zune30
bug has been selected from [10]. In our case, real scale
example were components for e–Invoice service where an
inﬁnite loop has been discovered. Zune30 bug example
has similar features as ﬁnd in real scale examples, like
unreached code or inﬁnite loop. Similar piece of code with
“small” programming mistake in telephone switch software
canceled 50% of 133 million long distance calls.
The approach introduced within the paper bridges the gap
between the tools capable of ﬁnding design errors and semi–
formal speciﬁcation. Usual approach for system speciﬁcation
is textual or semi–formal form, using UML or SDL+MSC
diagrams. This paper starts from the C language model
M as executable speciﬁcation of state–transition system. It
is designers responsibility to provide component model as
much as possible close to the original. For that purpose,
C language speciﬁcation uses only small part of C lan-
guage constructs that have direct implementation in Promela,
because there is no need for pointers, complex data–type
structures or arrays. After translation to Promela model, Spin
[9] builds pan validator where checking procedures take
place. Besides that, after model checker has proved desired
properties, executable speciﬁcation can be transformed to
code skeleton (target language implementation).
Another possibility is to model speciﬁcation as statechart
and directly transform to the model that can understand
the model checker. This approach yields several design
inconsistencies:
− the semantic for a Statechart model of speciﬁcation and
the semantic of Promela model for the same speciﬁcation
is in general case different because speciﬁcation can be
interpreted in different ways,
− introducing executable speciﬁcation as an intermediate
representation (Figure 3.) provides the “simulator” for
real application yielding information about overall system
semantic and behavior, avoiding design inconsistencies,
− target code and model checking results are inconsistent
without executable speciﬁcation.
Instructions from the C language executable speciﬁcations
are transitions that represents the real system behavior. Sin-
gle transition is model or abstraction that describe method
call, indivisible sequence of method calls, FSA execution
or network of connected FSA executions.
Although the
model M, in most cases, describes single FSA, we can easily
compose communicating FSA to the single higher level
FSA using asynchronous product of FSA. Asynchronous
product of FSA is built in feature of Spin (for details see
[9] Appendix A). Each FSA is separate process in Promela
model. Generic model M for reactive component or generic
FSA or proces from Promela are syntactically different but
semantically equivalent basic building block for component
speciﬁcation and deﬁnition. Transition tM from Figure 3.
describes the position of executable speciﬁcation within
the generic model, models behavior and unify transition
semantic between all models. Each transition has the same
form as Mealy FSA but with extended transition semantic
(1).
input event
output action
(1)
Input events are:
− guards, control–ﬂow instructions, i.g., if
− message receiving events
Output events are:
- message sending events,
- method calls,
- assignments,
- call of another FSA or FSA network.
108
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

IV. THEORETICAL BACKGROUND
Theoretical background is based on model M transfor-
mations [11] and consists of the following parts :
(1) “Triptych” environment for two–phase model transfor-
mations (Figure 2): (1) from high–level speciﬁcation or
requirements to executable speciﬁcation and (2) from
executable speciﬁcation to veriﬁcation (Promela–prml)
or (2) to implementation code.
(2) model M for generic reactive component (Figure 3).
Component is ﬁnite state automaton (FSA) with C lan-
guage or Promela proctype construct representation,
(3) C program as executable speciﬁcation (Section V-C).
Executable speciﬁcation can also be tested like any piece
of C code,
(4) Mtr model transformation as framework for model
checking executable speciﬁcation (Figure 1),
(5) ψ algorithms for Mtr model transformations. Due to
restricted instruction set in C speciﬁcation, model trans-
formations are simple Perl scripts.
We perform model checking for model M for property ϕ.
Our approach follows usual approach [8] for model checking
as described in Equation 2:
MFSA |= ϕLTL
(2)
A model M is an executable speciﬁcation expressed as
state–transition system or more precisely as extended FSA
(eFSA). Extended FSA models:
− single eFSA,
− network of communicating FSA (cFSA),
− hierarchical network of communicating eFSA (hcFSA).
There is no universal approach for model checking exe-
cutable speciﬁcation. That means every domain is speciﬁc
regarding designers or users requirements. As a conse-
quence, we focus our attention to reactive software com-
ponents generic model M (Figure 3) as the basic building
block for FSA, extended FSA (eFSA), communicating FSA
(cFSA) and hierarchical FSA (h(cFSA)).
From initial state s0 (Figure 3) transition to initiates
the component. There are two possible end states, regular
(end_OK) and illegal (end_NOK), respectively.
Regular behavior is abstracted within the single transition
tM. As previously said tM can abstract the behavior of
cFSA or h(cFSA). Illegal behavior is executed within t¬M
transition. In regular cases FSA returns to initial state s0 with
Mω
C
ψ2
: 2 fg; fg2prml
Mπ
prml
ψ1
Mα
spec
Figure 1.
Model transformation sequence
tOK transition while in illegal cases FSA returns to initial
state with tNOK transition (represented with dashed line on
Figure 3), respectively. Following Equation 2. we introduce
model M as triple in Floyd–Hoare logic and properties ϕ
for safety and liveness:
M ≡ ⟨{INV pre} code {INV post}⟩ −→ ⟨ϕ ≡ ♦ □ np ⟩
(3)
Introduced linear time logicformula is checked with the pan
analyzer of model checker Spin [9]. Executable speciﬁcation
<exe utable-sp
e i ation>
<prml>
ψ2
: 2 fg; fg2prml
ψ1
<sp
e i ation>
< o
de>
Figure 2.
Triptych
is derived from top level semi–formal speciﬁcation as de-
scribed on Figure 2. (<specification> labeled circle).
Top level speciﬁcation (Mspec on Figure 1.) is transformed
to executable speciﬁcation with ψ1 algorithm. In this paper
<end_OK>
end_n_2_17
<end_NOK>
tM
s0
:<start>
tOK
tNOK
t0
t¬M
Figure 3.
eFSA generic model M for Reactive Component
we focus our attention on translation of an executable
speciﬁcation to the Promela model. Promela model is the
input to Spin model checker suitable for analysis of property
ϕ from 3.
Code generation and transformation to executable speci-
ﬁcation are not the subject of this paper. The sequence of
model transformation is summarized on Figure 1. In order
to unify syntax representation for all internal FSA model
transformation BNF representation is introduced in Figure
4.
V. ψ-ALGORITHMS
First, we introduce the deﬁnition of ccfg–c control flow
graph. We shall refer ccfg simply as control ﬂow graph
cfg. A cfg is triple (S, T, L) where:
S
set of states si, si ∈ S;
T
(or −→) is the set of transitions such that T ⊆
S × L × S
L
is labeling functions (assign C instruction to the
label lj, l ∈ L
109
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

1
2 <eFSA> ::= <header> <body> | <comment>
3
<header> ::= [h|H]
(.)* ’\n’
4
<comment> ::= # (.)* ’\n’
5
<body> ::= <keyw> <records>
6
<records> ::= <record> ’\n’
7
<record> ::= <fields> <separator>
8
<fields> ::= ’[\w-_\(\)]’+
9
<separator> ::= ’\s’+ | ’\t’+ | ’:’ | ’,’
10
<keyw> ::= INIT | STATES | LABELS |
11
TRANSITIONS} | FINAL | SL | LT
12
Figure 4.
BNF for M FSA
Control ﬂow graph cfg follows previously mentioned BNF
syntax for eFSA, cfg derived from C source is presented
in lisp–like form as the set of state–label pairs and the set
of state–arrow–next-state triples, respectively:
(si, lj)
(si −→ si+i)
A. ψ2–c to cfg
This algorithm (c2cfg) is model extraction [7] for C
program. We use goto-cc model extractor introduced in
[6].
B. ψ2–cfg to prml
Control
ﬂow
graph
translation
to
Promela
model
(cfg2prml) algorithm consists of the following steps:
(1) substitute arrow → with label:
(si → si+i) −→ (si lj si+i)
(2) abstract label lj: lj −→< lj >: abstraction is already
in C source.
(3) ∀si ∈ S substitute si with Promela if block or label
abstraction
(4) ”End of function” → end
ψ2–cfg to prml translation is realized asPerl script.
C. Example
As an example we present model M of Zune30 bug. C
program has been taken from [10] and translated to Mprml
Promela model. This C program serves as executable
speciﬁcation model. Similar models Mspec of executable
speciﬁcation are derived from semi formal speciﬁcation of
distributed web applications, business processes and control
software. For inputs like 366, 10593 zune30.c program
enter endless loop. Assertion from line 15 with Q1:
label is never executed in C program, yielding no assert–
violation:
"MC C source for zune30"
1
2 /* BUG: issue ./zune30 366, 10593 */
3 /* and have endless loop
*/
4
5 #include <stdio.h>
6 #include <stdlib.h>
7 #include <assert.h>
8
9 int zune30(int days) {
10
11
int year = 1980;
12
while (days > 365) {
13
if ((year % 4) == 0){
14
if (days > 366) {
15 Q1:
assert(1);
16
days = days - 366;
17
year = year + 1;
18
}
19 /*
else { */
20 /*
}
*/
21
}
22
else {
23
days = days - 365;
24
year = year + 1;
25
}
26
}
27
printf("%d\n", year);
28
return 1;
29 }
30
After transformation C source (MC) is translated to Promela
model (Mprml). Analysis of Promela model Mprml gives
the sequence of instructions that raise undesired behavior.
"Mπ
prml: the Promela model"
1
2 int UNKNOWN;
3 int year;
4 int days;
5 int cprntf;
6 int cgoto;
7 int creturn;
8 int cassertif;
9 int cassertFALSE;
10 int cassertTRUE;
11
12 active proctype acz() {
13
14 #if DAYS
15
days=DAYS;
16 #endif
17
18 n_2_0: UNKNOWN=0; -> goto n_2_1;
19
20 n_2_1: year = 1980; ->
goto n_2_2;
21
22 n_2_2:
23 if
24 :: !(days > 365) -> goto n_2_15;
//true
25 ::
(days > 365) -> goto n_2_3;
// false
26 fi;
27
28 n_2_15: cprntf=1 -> goto n_2_16;
29
30 n_2_3:
31 if
32 :: !(year % 4 == 0) -> goto n_2_12;
// true
33 ::
(year % 4 == 0) -> goto n_2_4;
// false
110
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

34 fi;
35
36 n_2_16: creturn=2 -> goto end_n_2_17;
37 n_2_12: days = days - 365 -> goto n_2_13;
38
39 n_2_4:
40 if
41 :: !(days > 366) ->
goto n_2_11;
// true
42 ::
(days > 366) -> goto n_2_5;
//
false
43 fi;
44
45 n_2_13: year = year + 1 -> goto n_2_14;
46 n_2_11: cgoto=3 -> goto n_2_14;
47
48 n_2_5:
49 if
50 :: cassertif=4 ->
goto n_2_8;
//true
51 :: cassertif=5 ->
goto n_2_6;
//false
52 fi;
53
54 n_2_14: cgoto=6 -> goto n_2_2;
55 n_2_8: cassertFALSE=7 -> goto n_2_9;
56 n_2_6: cassertTRUE=8 -> goto n_2_7;
57 n_2_9: days = days - 366 -> goto n_2_10;
58 n_2_7: cgoto=9 -> goto n_2_9;
59 n_2_10: year = year + 1 -> goto n_2_11;
60
61 end_n_2_17: skip;
// End of Function
62 }
63
Next section will explain transformation from C source to
Promela model.
VI. MODEL TRANSFORMATION: FROM C TO Promela
Model transformation is performed following the theoret-
ical concepts from the Section IV and Figure 1. The ﬁrst
step is call to goto-cc that implements transformation of
C source to control ﬂow graph cfg. (Mω
cfg −→ Mω
cfg).
Transformation is implemented in ψ:c2cfg algorithm.
Vertexes from Figure 5 are executable instructions and
edges are “connections” between instructions, respectively.
Nodes are assignments like year=year+1 or if state-
ments (for example: if(days >365). In real situations
additional assignments are method calls. We assume that
methods are safe and live, thus always return desired values.
That means methods have assume-guarantee property that is
checked separately.
The result of the transformation is coded in lisp–like
syntax:
"Mω
cfg cfg for zune30 in lisp--like syntax"
1
2 SL
3 (n_2_0
UNKNOWN)
4 (n_2_1
"year = 1980;")
5 (n_2_2
"!(days > 365)?")
6 (n_2_15
"PRINTF("%d\n",year)")
7 (n_2_3
"!(year % 4 == 0)?")
8 (n_2_16
"return 1;")
9 (n_2_12
"days = days - 365;")
10 (n_2_4
"!(days > 366)?")
UNKNOWN
year = 1980;
!(days > 365)?
PRINTF(&"%d\n"[0], year);
true
!(year % 4 == 0)?
false
return 1;
days = days - 365;
true
!(days > 366)?
false
End of Function
year = year + 1;
Goto
true
days = days - 366;
false
Goto
year = year + 1;
Figure 5.
C Control ﬂow graph cfg for zune30 example
11 (n_2_17
"End of Function")
12 (n_2_13
"year = year + 1;")
13 (n_2_11
Goto)
14 (n_2_5
"!(_Bool)1?")
15 (n_2_14
Goto)
16 (n_2_8
"Assert(FALSE)")
17 (n_2_6
"(void)0;")
18 (n_2_9
"days = days - 366;")
19 (n_2_7
Goto)
20 (n_2_10
"year = year + 1;")
21
22 LT
23 (n_2_0 -> n_2_1)
24 (n_2_1 -> n_2_2)
25 (n_2_2 -> n_2_15
true)
26 (n_2_2 -> n_2_3
false)
27 (n_2_15 -> n_2_16)
28 (n_2_3 -> n_2_12 true)
29 (n_2_3 -> n_2_4
false)
30 (n_2_16 -> n_2_17)
31 (n_2_12 -> n_2_13)
32 (n_2_4 -> n_2_11 true)
33 (n_2_4 -> n_2_5
false)
34 (n_2_13 -> n_2_14)
35 (n_2_11 -> n_2_14)
36 (n_2_5 -> n_2_8 true)
37 (n_2_5 -> n_2_6 false)
38 (n_2_14 -> n_2_2)
39 (n_2_8 -> n_2_9)
40 (n_2_6 -> n_2_7)
41 (n_2_9 -> n_2_10)
42 (n_2_7 -> n_2_9)
43 (n_2_10 -> n_2_11)
For example, vertexes n_2_1 is assignment for C statement
year=1980 and transitions between vertexes are triples
(n_2_1
−→ n_2_2), respectively.
111
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

acz
S1
S2
days = -(36)
S4
UNKNOWN = 0
S10
year = 1980
S12
(!((days>365)))
S18
((days>365))
S20
cprntf = 1
S22
(!(((year%4)==0)))
S28
(((year%4)==0))
S52
creturn = 2
S53
(1)
S0
-end-
S30
days = (days-365)
S32
(!((days>366)))
S38
((days>366))
S40
year = (year+1)
cgoto = 6
cgoto = 3
S42
cassertif = 4
S44
cassertif = 5
S46
cassertFALSE = 7
S48
cassertTRUE = 8
S50
days = (days-366)
year = (year+1)
cgoto = 9
Figure 6.
FSA for Promela model Mπ
prml
After that, algorithm ψ2:cfg2prml is applied, resulting in
Promela model Mπ
prml as presented in Section. V-C. The
algorithm translates control ﬂow graph to Promela code
Mπ
cfg −→ Mπ
form of Mπprml. The Promela model is another invariant
C model, Figure 6 visualize it as an ﬁnite
state automaton. Spin‘s veriﬁer pan has options that enable
visualization of Promela models as automaton.
There are signiﬁcant difference from cfa from ﬁgure
5, instructions lj are placed on transition labels and many
instructions have abstracted form < lj >, for example,
assert is replaced with cassertif=4 abstracted form.
Next step is Promela model analysis of liveness and safety
properties.
A. Experiment result analysis
The analysis of Promela model from Section V-C yields
the following results:
− there are unreached portions of code
− there are endless loops
In order to achieve this results two veriﬁer runs are required:
− Non–progress cycles (loops) are detected with linear
temporal logic formula: ♦□np_, where np_ is Promela
built–in variable for marking the progress of global
system state status. In our example, formula is false
producing counterexample with non–progress cycle.
− unreached instruction from Promela model (“dead–
code”) is standard built–in function into the pan veriﬁer.
The output from the pan veriﬁer is counterexample with
the path to the error. Each row presents the line number
of instruction from the Promela model presented in Section
V-C. Non–progress loop is sequence of instructions with line
numbers 24 32 40 45 53 24 32 40 ...
"non-progres loops"
1
2
z30.ltg.prml:14
[days = 366]
3
days = 366
4
z30.ltg.prml:17
[UNKNOWN = 0]
5
z30.ltg.prml:19
[year = 1980]
6
year = 1980
7
<<<<<START OF CYCLE>>>>>
8
z30.ltg.prml:24
[((days>365))]
9
z30.ltg.prml:32
[(((year%4)==0))]
10
z30.ltg.prml:40
[(!((days>366)))]
11
z30.ltg.prml:45
[cgoto = 3]
12
cgoto = 3
13
z30.ltg.prml:53
[cgoto = 6]
14
cgoto = 6
15 spin: trail ends after 16 steps
16
year = 1980
17
days = 366
Counterexample pointing unreached code use pan veriﬁer
built in options for unreached code detection. Each row
presents the line number of unreached instruction from
Promela model presented in Section V-C (27, 35, 36, 44,
...).
"unreached end--state"
1
2 unreached in proctype z30
3
4
z30.ltg.prml:27,
"cprntf = 1"
5
z30.ltg.prml:35,
"creturn = 2"
6
z30.ltg.prml:36,
"days = (days-365)"
7
z30.ltg.prml:44,
"year = (year+1)"
8
z30.ltg.prml:44,
"year = (year+1)"
9
z30.ltg.prml:49,
"cassertif = 4"
10
z30.ltg.prml:49,
"cassertif = 5"
11
z30.ltg.prml:54,
"cassertFALSE = 7"
12
z30.ltg.prml:55,
"cassertTRUE = 8"
13
z30.ltg.prml:56,
"days = (days-366)"
14
z30.ltg.prml:57,
"cgoto = 9"
15
z30.ltg.prml:58,
"year = (year+1)"
16
z30.ltg.prml:61,
"-end-"
17
(11 of 53 states)
VII. CONCLUSION AND FURTHER WORK
We have presented model checking of speciﬁcation as
software model checking for C language.
We ﬁnd that Spin model checker is feasible solution
because Spin ﬁnds deadlocks, unreached code, assertion
violations, invalid end states, and analyze linear time log-
icformula. In the same time, executable speciﬁcation can be
112
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

analyzed, tested as every C program. Our approach avoids
complex and long term development of model extractor with
tools like CIL. Another beneﬁt is the application of linear
time logicformula on C speciﬁcation. Usual approach puts
assertions in the code in the place according to the designer’s
discretion. Sometimes it is necessary that assertion is true
to “some point in the future inﬁnitely often” which can
be expressed as temporal logic formula. With our approach
linear time logic formula is the part of Promela model and
consequently also the part of C speciﬁcation. State explosion
and designer mistakes during speciﬁcation deﬁnition are still
problems that needs improvements. “Designers will never
use it” syndrome is always the problem when introducing
development paradigms.
Further work will focus on more rigid data–types consis-
tency check. That requires formal development of abstract
data structures. In most cases, such data structures are
deﬁned over inﬁnite domains so further reﬁnements should
avoid inﬁnite data domains, or introduce data abstractions.
Besides Spin, the comparison with other model checkers,
like Petri net tools, could improve veriﬁcation. Model check-
ers search for solutions within ﬁnite space, the improvement
of model checking with unbounded parameters (days in our
example) yields: M(days) |= ϕ.
Bounded model checking [12] and the usage satisﬁability
modulo theory (SAT [13] and SMT [14]) solvers are the
promising research direction.
Automated code generation from executable speciﬁca-
tion is another possible direction for research. The most
promising is TDD “Test Driven Development” because code
skeleton is populated with test case commands.
REFERENCES
[1] D. Harel, “Statecharts in the making: a personal account,”
in Proceedings of the Third ACM SIGPLAN History of
Programming Languages Conference (HOPL-III).
San
Diego, California: ACM, 9-10 June 2007, pp. 1–43.
[2] R. Eshuis, D. N. Jansen, and R. Wieringa, “Requirements-
level semantics and model checking of object-oriented stat-
echarts.” Requirements Engineering, vol. 7, no. 4, pp. 243–
263, 2002.
[3] R. Bharadwaj and C. L. Heitmeyer, “Model Checking
Complete Requirements Speciﬁcations Using Abstraction,”
Automated Softwware Engineering, vol. 6, no. 1, pp. 37–68,
1999.
[4] K. Jiang, “Model Checking C Programs by Translating C to
Promela,” Master’s thesis, Uppsala Universitet, Department
of Information Technology, 2009.
[5] G. J. Holzmann, “Logic Veriﬁcation of ANSI-C Code with
SPIN,” in SPIN Model Checking and Software Veriﬁcation,
ser. Lecture Notes in Computer Science, K. Havelund,
J. Penix, and W. Visser, Eds., vol. 1885, 7th International
SPIN Workshop.
Stanford CA USA: Springer, August
2000, pp. 131–147.
[6] “CBMC is a Bounded Model Checker for ANSI-C,”
(last time visited July, 5th2012). [Online]. Available:
http://www.cprover.org/cbmc
[7] E. Clarke, D. Kroening, and F. Lerda, “ A Tool for Check-
ing ANSI-C Programs ,” in
Tools and Algorithms for
the Construction and Analysis of Systems (TACAS 2004)
, ser. Lecture Notes in Computer Science, K. Jensen and
A. Podelski, Eds., vol. 2988.
Springer, 2004, pp. 168–176.
[8] E. M. Clarke, O. Grumberg, and D. A. Peled, Model
Checking.
The MIT Press, January 1999.
[9] G. Holzmann, Spin model checker, the: primer and reference
manual, 1st ed.
Addison-Wesley Professional, 2004.
[10] W. Weimer, S. Forrest, C. L. Goues, and T. Nguyen,
“Automatic program repair with evolutionary computation,”
Commun. ACM, vol. 53, no. 5, pp. 109–116, 2010.
[11] A. Metzger, “A systematic look at model transformations,” in
Model-Driven Software Development, S. Beydeda, M. Book,
and V. Gruhn, Eds.
Springer Berlin Heidelberg, 2005, pp.
19–33.
[12] Armin Biere and Alessandro Cimatti and Edmund M. Clarke
and Ofer Strichman and Yunshan Zhu, “Bounded Model
Checking,” Advances in Computers, vol. 58, pp. 117–148,
2003.
[13] Biere, Armin and Heule, Marijn J. H. and van Maaren,
Hans and Walsh, Toby, Ed., Handbook of Satisﬁability, ser.
Frontiers in Artiﬁcial Intelligence and Applications.
IOS
Press, February 2009, vol. 185.
[14] Armando, Alessandro and Mantovani, Jacopo and Platania,
Lorenzo, “Bounded model checking of software using SMT
solvers instead of SAT solvers,” Int. J. Softw. Tools Technol.
Transf., vol. 11, no. 1, pp. 69–83, Jan. 2009.
113
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

