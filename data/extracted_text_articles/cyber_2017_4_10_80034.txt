Vaccine: A Block Cipher Method for  
Masking and Unmasking of Ciphertexts‚Äô Features  
Ray R. Hashemi 
Amar Rasheed 
Jeffrey Young 
Department of Computer Science 
Armstrong State University,  
Savannah, GA, USA 
e-mails: {rayhashemi, amarrasheed, 
alanyoung7}@gmail.com 
 
Azita A. Bahrami 
IT Consultation 
Savannah, GA, USA 
e-mail: Azita.G.Bahrami@gmail.com 
 
 
 
 
 
 
Abstract‚Äî A ciphertext inherits some properties of the 
plaintext, which is considered as a source of vulnerability and, 
therefore, it may be decrypted through a vigorous datamining 
process.  Masking the ciphertext is the solution to the problem.  
In this paper, we have developed a new block cipher technique 
named Vaccine for which the block size is random and each 
block is further divided into segments of random size.  Each 
byte within a segment is instantiated using a dynamic multi-
instantiation approach, which means (i) the use of Vaccine 
does not produce the same masked outcome for the same given 
ciphertext and key and (ii) the options for masking different 
occurrences of a byte is extremely high. Two sets (100 
members in each) of 1K long plaintexts of natural (borrowed 
from natural texts) and synthesized (randomly generated from 
10 characters to increase the frequency of characters in the 
plaintext) are built.  For each plaintext, two ciphertexts are 
generated using Advanced Encryption System (AES-128) and 
Data Encryption Standard (DES) algorithms. Vaccine and two 
well-known masking approaches of Cipher Block Chaining 
(CBC), and Cipher Feedback (CFB) are applied separately on 
each ciphertext.   On average: (a) the Hamming distance 
between masked and unmasked occurrences of a byte using 
Vaccine is 0.72 bits higher than using the CBC, and CFB, and 
(b) Vaccine throughput is also 3.4 times and 1.8 times higher 
than the throughput for CBC and CFB, correspondingly, and 
(c) Vaccine masking strength is 1.5% and 1.8% higher than the 
masking strength for CBC and CFB, respectively. 
 
Keywords- Cyber Security; Masking and Unmasking 
Ciphertext; 
Variable-Block 
Cipher 
Vaccination; 
Masking 
Strength  
I. INTRODUCTION 
 
Protecting 
sensitive 
electronic 
documents 
and 
electronic messages from unintended eyes is a critical task.  
Such protections are often provided by applying encryption.  
However, the encrypted text (ciphertext) is often vulnerable 
to datamining.   For example, let us consider the plaintext 
message of: ‚ÄúThe center is under an imminent attack‚Äù.  The 
plaintext may be converted into the following ciphertext 
using, for instance, a simple displacement encryption 
algorithm: ‚Äúxligirxvmwyrhivermqqmrirxexxego‚Äù.  The 
features of the plaintext are also inherited by the 
ciphertext‚Äîa point of vulnerability.    
 
To explain it further, word ‚Äúattack‚Äù is among the key 
words related to security.  The characteristics of the word 
are: (i) length is six, (ii) the first and the fourth characters 
are the same, and (iii) the second and the third characters 
are the same.  Using these characteristics, one can mine the 
given ciphertext and isolate the subtext of ‚Äúexxego‚Äù that 
stands for ‚Äúattack" which, in turn, may lead to decryption of 
the entire message.   
 
More sophisticated encryption modes, such as CBC and 
CFB [1][2][3] are not exempt from the inherited-features 
problem.  The Block cipher techniques that employ 
CBC/CFB encryption mode to produce distinct ciphertexts 
are vulnerable to information leakage. In the case of 
CBC/CFB employing the same Initial text Vector (IV) with 
the same encryption key for multiple encryption operations 
could reveal information about the first block of plaintext, 
and about any common prefix shared by two plaintext 
messages. In CBC mode, the IV must, in addition, be 
unpredictable at encryption time; in particular, the 
(previously) common practice of re-using the last ciphertext 
block of a message as the IV for the next message is 
insecure (for example, this method was used by SSL 2.0). If 
an attacker knows the IV (or the previous block of 
ciphertext) before he specifies the next plaintext, he can 
check his guess about plaintext of some block that was 
encrypted with the same key before (this is known as the 
TLS CBC IV attack) [4]. 
 
The logical solution for inherited-features problem is to 
mask the ciphertext using a masking mechanism that is 
dynamic and supports a high degree of multi-instantiations 
for each byte.  A dynamic masking mechanism does not 
produce the same masked outcome for the same given 
ciphertext and the same key.  The high degree of multi-
instantiation masking mechanism replaces the n occurrences 
of a given byte in the ciphertext with m new bytes such that 
m is either equal to n or extremely close to n.  The literature 
addresses many of these masking techniques [5][6]. 
 
Our goal is to introduce a masking mechanism named 
Vaccine that can mask the inherited features of a ciphertext 
in the eye of a data miner while providing for 
transformation of masked ciphertext into its original form, 
when needed. Vaccine will be dynamic and support a high 
41
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-605-7
CYBER 2017 : The Second International Conference on Cyber-Technologies and Cyber-Systems

(a) 
 p1                                           p2 
(i) Flip 
ùëù 1 
(ii) 
Circular 
Swap 
  p1 p2 p3  p4 p5  p6 p7  p8 
(i) Flip 
ùëù 1ùëù 3 ùëù 6ùëù 7  
 (ii) Circular 
Swap 
(b) 
degree of multi-instantiations for each byte of data, and has 
the following three unique traits, which makes it a powerful 
masking mechanism:   It (1) divides the ciphertext into 
random size blocks, (2) divides each block into random size 
segments, and (3) every byte within each segment is 
randomly instantiated into another byte.  All three traits are 
major departures from the norm of masking mechanisms.   
 
The rest of the paper is organized as follows. The 
Previous Works is the subject of Section 2.  The 
Methodology is presented in Section 3.  The Empirical 
Results are discussed in Section 4. The Conclusions and 
Future Research are covered in Section 5. 
II. PREVIOUS WORKS 
 
Masking the features of a ciphertext that are either 
inherited from the plaintext or generated by the encryption 
scheme itself is the essential step in protecting a ciphertext.  
The block cipher and stream cipher mode of operations 
provides for such a step.  We are specifically interested in 
CBC [7][8][9] and CFB [10] as samples of the block cipher 
and stream cipher mode of operations.  They are to some 
degree comparable to the proposed Vaccine. 
 
CBC divides the ciphertext into fixed‚Äìlength blocks 
and masks each block separately. The use of fixed-length 
block demands padding for the last partial block of the 
ciphertext, if the latter exist.  The CBC avoids generating 
the same ciphertext when the input text and key remain the 
same by employing an Initial text Vector (IV).  CFB 
eliminates the need for possible padding of the last block 
(that is considered vulnerability for CBC [11]) by assuming 
the unit of transmission is 8-bits.  However, CFB also uses 
IV for the same purpose that it was used by CBC.  In 
contrast, Vaccine splits the ciphertext into the random size 
blocks and then divides each block into segments of random 
size.  Masking each pair of segments is done by using a pair 
of randomly generated patterns.  As a result, Vaccine needs 
neither padding nor IV.  The randomness of the block size, 
segment size, and patterns used for instantiation of a given 
character are the major departure points of Vaccine from the 
other block and stream cipher approaches. 
 III. METHODOLOGY 
 
We first present our methodology for instantiation of a 
byte, which contributes into dynamicity of Vaccine and then 
introduce our methodology for building Vaccine.   The 
details of the two methodologies are the subjects of the 
following two subsections. 
A.  Instantiation  
 
Instantiation is the replacement of a byte, c, by another 
one, c‚Äô, such that c‚Äô is created by some modifications in c.  
To perform the instantiation, we present our two methods of 
Self-substitution and Mixed-Substitution. Through these 
methods, a number of parameters are introduced that are 
referred to as the masking parameters. At the end of this 
subsection, we present the masking parameters as a profile 
for the patterns suggested by the substitution methods. 
 
1) Self-Substitution: Consider byte 10011101 and let us 
(i) pick two bits in positions p1 and p2 such that p1 ÔÇπ p2, (ii) 
flip the bit in position p1, and (iii) swap its place with the bit 
in position p2‚ÄîTwo-Bit-One-Flip-Circular-Swap technique.  
 
It is clear that the pairs (p1=1, p2=7) and (p1=7, p2=1)  
create different instances for the byte.  Therefore, the order 
of p1 and p2 is important. The number of possible ways 
selecting a pair (p1, p2) from the byte is 7*8=56, which 
means a byte may be instantiated by 56 possible different 
ways using Two-Bit-One-Flip-Circular Swap technique.  
The technique name may be generalized as K-R-Bit-M-Flip-
Circular-Swap.  For the above example K=2 and M=1, as 
shown in Figure 1.  (We introduce the parameter R shortly.)  
 
One may pick 3-bits (K=3) to instantiate the byte.  Let 
us assume 3 bits randomly selected that are located in the 
positions p1, p2, and p3.  There are many ways that M-Flip-
Circular-Swap technique can be applied: 
a. (One-Flip-Circular-Swap) Flip one of the three bits and 
then make a circular swap among p1, p2, and p3.   
b. (Two-Flip-Circular-Swap) Flip two out of the three bits 
and then apply circular swapping. 
c. (Three-Flip-Circular-Swap) Flip all three bits and then 
apply circular swapping. 
The number of possible combinations grows to 5040.  
 
 
 
 
 
 
 
 
 
Figure 1. K-Bit-M-Flip-Circular-Swap Technique: (a) K=2 and M=1 and 
(b) K=8 and M=4  
 
Using K-R-Bit-M-Flip-Circular-Swap for all possible 
values of K (K=2 to 8) and M (M=1 to K-1) generates the 
total of (X=1,643,448) possible substitutes for a given byte.  
If either K or M is equal to zero then, the self-substitution 
has not been enforced and in this case X=1 (the byte itself).  
Now, we explain the role of parameter, R (where, R is a 
byte long).   
 
Let us refer to the case of K=2 and M=1 one more time 
that is able to facilitate the generation of 56 possible number 
of instantiations of a given byte using all the possible pairs 
of (p1=ÔÇ∑, p2=ÔÇ∑).  That is, the two positions of p1 and p2 could 
have any value from 1 to 8 as long as p1ÔÇπp2.  What if one is 
only interested in those instantiations resulting from the 
pairs of (p1=3, p2=ÔÇ∑), which by definition also includes 
instantiations resulting from the pairs of (p1=ÔÇ∑, p2=3).  The 
chosen value (bit) of interest for p1 is a value from 1 to 8 
that is expressed by setting the bit of interest in R.  The 
number of bits that are set to ‚Äú1‚Äù in R is always equal to M. 
For our example, R=‚Äú00000100‚Äù.   
42
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-605-7
CYBER 2017 : The Second International Conference on Cyber-Technologies and Cyber-Systems

 
The pairs represented by (p1=v, p2=ÔÇ∑) are the set of 
seven pairs of {(p1=v, p2=1), . . ., (p1=v, p2=8)}.  The seven 
pairs are named the primary set for the primary signature of 
(p1=v, p2=ÔÇ∑).  The (p1=*, p2=v), which is a tweaked version 
of (p1=ÔÇ∑, p2=v) is the Complementary signature of (p1=v, 
p2=ÔÇ∑) and stands for the other set of seven pairs {(p1=8, 
p2=v), . . ., (p1=1, p2=v)}.  These seven pairs make the 
complementary set for (p1=*, p2=v).  (Values of p1, in the 
complementary set, are in reverse order of values of p2 in 
the primary set.) 
 
The primary and complementary sets also referred to as 
the primary sub-pattern and complementary sub-pattern, 
respectively.  The two sub-patterns collectively make a 
pattern and (K=2, M=1, R=‚Äú00000100‚Äù) is the pattern‚Äôs 
profile. 
 
The profile of (K=4, M=3, R=‚Äú00001011‚Äù) means four 
bits are chosen from the byte out of which three bits (M=3) 
in positions 1, 2, and 4 are the positions of interest (p1=1, 
p2=2, p3=4.)  Therefore, the primary signature and the 
Complementary signatures are, respectively, defined as 
(p1=1, p2=2, p3=4, p4=ÔÇ∑) and (p1= *, p2=2, p3=4, p4=1).  It is 
clear that M cannot be equal to K, because, when M= K, the 
primary and complementary sets are the same and they have 
only one member.  
 
When none of the bits in R is set to ‚Äú1‚Äù, it means R has 
not been enforced.  In this case, we have one pattern.  
However, to apply Vaccine, we need to determine the 
primary and complementary sets for this pattern, which is 
provided by default value of R (i.e., R with its M least 
significant bits set to ‚Äú1‚Äù.) 
 
2) Mixed-Substitution:  In a nutshell, the instantiation 
of the given byte, c, and each key byte are done separately. 
One of the instantiated key bytes is selected as the key 
image and the final instance of c is generated by XORing 
the key image and the instantiated c.  The details are cited 
below. 
 
Application 
of 
self-substitution 
with 
masking 
parameters of (K, M, and R) on a given byte generates the 
primary and the complementary sub-patterns of (ùë¢ùëù
1 . . . ùë¢ùëù
ùëõ) 
and (ùë¢ùëê
ùëö . . . ùë¢ùëê
1).  The subscripts p and c stand for these two 
sub-patterns and there are n and m members in the p and c 
sub-patterns, respectively.  The key byte Bj is instantiated 
into another byte using the self-substitution with masking 
parameters of (Kj, Mj, and Rj, for j=1 to 4). Application of 
self-substitution on the individual four bytes of the key (B1 . 
. . B4) generates the primary and the complementary sub-
pattern for each byte as follows: 
(ùë¢ùëù
1ùêµ1 .  .  .  ùë¢ùëù
ùëõ1ùêµ1) and (ùë¢ùëê
ùëö1ùêµ1 .  .  .  ùë¢ùëê
1ùêµ1),  
(ùë¢ùëù
1ùêµ2 .  .  .  ùë¢ùëù
ùëõ2ùêµ2) and (ùë¢ùëê
ùëö2ùêµ2 .  .  .  ùë¢ùëê
1ùêµ2), 
(ùë¢ùëù
1ùêµ3 .  .  .  ùë¢ùëù
ùëõ3ùêµ3) and (ùë¢ùëê
ùëö3ùêµ3 .  .  .  ùë¢ùëê
1ùêµ3), and  
(ùë¢ùëù
1ùêµ4 .  .  .  ùë¢ùëù
ùëõ4ùêµ4) and (ùë¢ùëê
ùëö4ùêµ4 .  .  .  ùë¢ùëê
1ùêµ4). 
 
A byte, say c1, using the first member of the primary 
sub-pattern, ùë¢ùëù
1,  is instantiated to c1‚Äô.  The first byte of key, 
B1, using its first member of the primary sub-pattern, ùë¢ùëù
1ùêµ1,  
is instantiated to B1‚Äô.  The other three bytes are also 
instantiated into B2‚Äô, B3‚Äô, and B4‚Äô using their first member of 
the primary sub-patterns, ùë¢ùëù
1ùêµ2, ùë¢ùëù
1ùêµ3, ùëéùëõùëë ùë¢ùëù
1ùêµ4, respectively. 
The Hamming distance of HD(c‚Äô, Bj‚Äô), for j=1 to 4, are 
measured and B‚Äô=Argmax[HD(c‚Äô, Bj‚Äô), for j=1 to 4] is the 
key image. In the case that there are ties, the priority is 
given to the instantiated byte of B1, B2, B3, and B4 (and in 
that order.) The final substitution for c1 is:  
c1‚Äô‚Äô=(c1‚Äô ÔÉÖ B‚Äô) 
 
 
(1) 
 
The next byte, c2, within a given segment of ciphertext 
is instantiated to c2‚Äô using ùë¢ùëù
2,  and key bytes of B1, B2, B3, 
and B4 are instantiated to B1‚Äô, B2‚Äô, B3‚Äô, and B4‚Äô 
usingùë¢ùëù
2ùêµ1, ùë¢ùëù
2ùêµ2, ùë¢ùëù
2ùêµ3, ùëéùëõùëë ùë¢ùëù
2ùêµ4, respectively. 
   
B‚Äô=Argmax[HD(c‚Äô, Bj‚Äô), for j=1 to 4] and c2‚Äô‚Äô=(c2‚ÄôÔÉÖ 
B‚Äô).  The process continues until the segment of the 
ciphertext is exhausted. The bytes of the next sub-list and 
the key bytes are instantiated using the complementary sub-
patterns.   Therefore, the sub-patterns are alternatively used 
for consecutive segments of the ciphertext.  
 
Using the mixed substitution, the number of possible 
combinations for each key byte is equal to X and for the key 
of four bytes is X4 (>1.19*1031 combinations.)  Reader 
needs to be reminded that the four-byte key may be 
expanded to the length of N bytes for which the outcome of 
XOR is one of the XN+1 possible combinations.  For N=16 
(128-bit key) The XOR is one of the X17 possible 
combinations (>4.65*10105.)  
 
3) Patterns‚Äô Profile: Considering both self and mixed 
substitutions, the masking parameters grow to fifteen: (K, 
M, and R) for the instantiation of a byte of segment and (Kj, 
Mj, and Rj, for j=1 to 4) for instantiation of the four bytes of 
the key.  Therefore, a pattern profile includes the fifteen 
parameters, which are accommodated by a 96-bit long 
binary string as described below. 
 
Since the possible values for each of the parameters K 
and Kj is nine (0 through 8), the value of each parameter can 
be accommodated by 4 bits (the total of 20 bits).  The 
parameters M and Mj have eight possible values (1 through 
8) and each parameter can be accommodated by 3 bits (the 
total of 15 bits).  The parameters R and Rj need eight bits 
each (the total of 40 bits).  In addition, we use sixteen bits as 
the Flag bits and another five bits as the Preference bits.  
 
The flag bits represent a decimal number (ÔÅÑ) in the 
range of (0: 65,535).  Let us assume that the length of the 
ciphertext that is ready to be masked is Lct.  Three bytes of 
f1, f2, and f3 of the ciphertext are flagged which are in 
locations: ÔÅ§1= ÔÅ§, ÔÅ§2=ÔÉ´ Lct/2+ÔÅ§/2ÔÉª, and ÔÅ§3=Lct - ÔÅ§,  where, ÔÅ§ is 
calculated using formula (2) 
 
 
 
ÔÅ§={ ‚àÜ ùëÄùëúùëë ùêøùëêùë°,      ‚àÜ > ùêøùëêùë°
ùêøùëêùë°  ùëÄùëúùëë ‚àÜ,   ‚àÜ ÔÇ£ ùêøùëêùë°   
(2) 
The flagged bytes will not be masked during the vaccination 
process and they collectively make the native byte of 
F=(f1ÔÉÖf2ÔÉÖf3). Since the length of the ciphertext and the 
length of its masked version remain the same there is no 
need for including the length of the ciphertext in the profile.  
The question of why the flagged bytes are of interest will be 
answered shortly. 
 
The purpose of preference bits is to build a model 
which is influenced by both the key and flagged bytes.  The 
43
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-605-7
CYBER 2017 : The Second International Conference on Cyber-Technologies and Cyber-Systems

model is used to create variable length blocks and segments.  
To build the model, a desired byte number (z) of the key is 
identified by the four least significant bits of the preference 
bits.  That is, one can select any byte from a a maximum of 
16-byte long key.  (If a longer than 16-byte key is used, the 
number of bits for the preference bits needs to be increased.)  
The key is treated as circular and the two pairs of bytes of 
A1=(z+1||z) and A2=(z+2||z-1) are selected from key. A new 
pair of bytes of A3=A1ÔÉÖA2ÔÉÖ(F||F) is built.  If the most 
significant bit of the preference bits is set to zero then, 
model is A3; otherwise, the model is a1ÔÉÖa2, where, a1 and a2 
are the pair of bytes in A3. 
 
Let us assume that there are two similar ciphertexts of 
CT1 and CT2 and we are using the same key and the same 
profile to mask the two ciphertexts, separately, using 
Vaccine.  As long as one of the three flagged bytes in CT1 
and CT2 is different the native bytes and, therefore, the 
models of the two ciphertexts are different and so their 
masked versions. This is one of the major advantages of 
Vaccine. 
 
To summarize, the number of bits needed for the 
pattern profile is 96 bits (or 24 hex digits.)  Dissection of a 
pattern profile is shown in Figure 2.  The 24 hex digits 
representing the pattern profile along with eight hex digits 
representing the key may be sent to the receiver in advance 
or they may hide in the masked ciphertext itself:   
a. In a predefined location/locations, 
b. In location/locations determined by the internal 
representation of the key following some formula(s), or 
c. A mixture of (a) and (b).  
 
   
 
 
 
   
 
 
 
 
 
 
 
 
Figure 2. Dissection of the pattern‚Äôs Profile of Interest 
B.  Vaccine 
 
Vaccine is a variable-block cipher methodology 
capable of masking and unmasking a ciphertext. The details 
of masking and unmasking of Vaccine are presented in the 
following next two subsections.   
 
1)  Masking of the Ciphertext: Vaccine as a masking 
mechanism is able to mask the features of a ciphertext in the 
eye of a text miner.  Vaccine: (1) divides the ciphertext into 
random size blocks, (2) each block, in turn, is divided into a 
number of segments such that the length of each segment is 
random, and (3) every byte within each segment is 
randomly instantiated to another byte using self and mixed 
substitutions.  The masking process is presented shortly and 
it is encapsulated in algorithm Mask shown in Figure 3. 
 
The algorithm is made up of four sections.  In section 
one, (Step 1 of the algorithm) the profile is dissected to 
extract masking parameters and they, in turn, generate 
primary 
and 
complementary 
sub-patterns 
for 
five 
patterns:(ùëÉùëéùë°ùë°ùëíùëüùëõùëù
0 , ùëÉùëéùë°ùë°ùëíùëüùëõùëê
0), (ùëÉùëéùë°ùë°ùëíùëüùëõùëù
ùêµ1, ùëÉùëéùë°ùë°ùëíùëüùëõùëê
ùêµ1), 
(ùëÉùëéùë°ùë°ùëíùëüùëõùëù
ùêµ2, ùëÉùëéùë°ùë°ùëíùëüùëõùëê
ùêµ2),  (ùëÉùëéùë°ùë°ùëíùëüùëõùëù
ùêµ3,   ùëÉùëéùë°ùë°ùëíùëüùëõùëê
ùêµ3),  and 
(ùëÉùëéùë°ùë°ùëíùëüùëõùëù
ùêµ4
 , ùëÉùëéùë°ùë°ùëíùëüùëõùëê
ùêµ4) used for masking the chosen byte 
of the ciphertext and the four key bytes, respectively.  The 
array of pt with five elements keeps track of those primary 
and complementary sub-patterns of the five patterns that are 
in use.  The model is also extracted in this step. 
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 3. Algorithm Mask 
Algorithm Mask 
Input:  
A 32‚Äìbit key, a pattern‚Äôs profile of 96-bit, and a 
ciphertext, CT. 
Output: Delivering IC as the masking version of CT. 
Method: 
  Step1- //Dissection of the profile and initializations 
 
Dissection delivers primary and secondary sub-patterns of 
five 
patterns 
(ùëÉùëéùë°ùë°ùëíùëüùëõùëù
0, 
ùëÉùëéùë°ùë°ùëíùëüùëõùëê
0), 
(ùëÉùëéùë°ùë°ùëíùëüùëõùëù
ùêµ1, 
ùëÉùëéùë°ùë°ùëíùëüùëõùëê
ùêµ1),  (ùëÉùëéùë°ùë°ùëíùëüùëõùëù
ùêµ2, ùëÉùëéùë°ùë°ùëíùëüùëõùëê
ùêµ2),  (ùëÉùëéùë°ùë°ùëíùëüùëõùëù
ùêµ3, 
ùëÉùëéùë°ùë°ùëíùëüùëõùëê
ùêµ3),  and (ùëÉùëéùë°ùë°ùëíùëüùëõùëù
ùêµ4, ùëÉùëéùë°ùë°ùëíùëüùëõùëê
ùêµ4). 
ÔÅ´ ‚ÜêModel obtained by using Preference bits, Flag bits, 
and key;  
 
IC ‚Üê ‚Äú‚Äù; C ‚Üê CT; 
pt[5]‚Üê 0;//pt gives turn to the primary (pt[ÔÇ∑]=0) and 
complementary (pt[ÔÇ∑] =1) sub-patterns of the five 
patterns for initializing  the CurrentP [5];  
Step 2-Repeat until C is exhausted 
a- Get the set of decimal numbers from ÔÅ´ in ascending 
order: D ={d1, d2, . . . dy-1, dy}; 
 
Get the next random size block,  
 
ÔÅ¢n,=Substr(C, 0, dy); 
b- CL = 0; //Current location in C 
c- Repeat for i =1 to y-1  
 
//Divide ÔÅ¢n into y-1 segments; 
si = Substr(ÔÅ¢n, CL, di - CL); 
CL = CL+ di;  
CurrentP[m]=ùëÉùëéùë°ùë°ùëíùëüùëõùëùùë°
ùëö   //for m =0 to 4; 
d- Repeat for each byte, cj, in si 
    d1- If (cj is a flagged byte) Then continue; 
d2- If (CurrentP[0] is exhausted)  
 
Then CurrentP[0] = ùëÉùëéùë°ùë°ùëíùëüùëõùëùùë°
0 ;  
 
d3- cj‚Äô = Flip cj bits using CurrentP[0]; 
    d4- cj‚Äô = Circularly swap proper cj bits using 
CurrentP[0]; 
d5- œÉ = Select(cj‚Äô, CurentP[1],  
CurrentP[2],CurrentP[3],CurrentP[4]); 
d6- a = cj‚Äô ÔÉÖ œÉ; 
d7- IC‚ÜêIC || a; 
End;   
     pt[ÔÇ∑]++; pt[ÔÇ∑] ‚Üê pt[ÔÇ∑] mode 2;   
     End; 
     e- Remove block ÔÅ¢n from C; 
     f- Apply one-bit-left-rotation on ÔÅ´; 
End; 
End; 
Profile: (8800510043228408000021C0)16 
(10001000000000000101000100000000010000110010
001010000100000010000000000000000000001000011
1000000)2    
 
A 4-byte Key: (ABC9023D)16  
 
  10001    0000000000001010     0010    000   00000100      
 
Preference bits     Flag bits            K=2   M=1       R=3 
 
   0011   001     00010100      0000    000     00000000      
 
  K1=3   M1=2     R1 =3 & 5   K3=0   M3=1       R3=0        
 
  0010    000     00100000      0100    001    11000000      
 
 K2=2   M2=1      R2 = 6         K4=4   M4=2      R4=7 & 8   
44
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-605-7
CYBER 2017 : The Second International Conference on Cyber-Technologies and Cyber-Systems

 
The second section (Step 2.a of the algorithm) 
identifies a random size block prescribed by ÔÅ´‚Äîthe model. 
The identification process is done by creating y binary 
numbers using ÔÅ´.  The i-th binary number starts from the 
least significant bit of the ÔÅ´ and ends at the bit with the i-th 
value of ‚Äú1‚Äù in ÔÅ´.  The binary numbers are converted into 
decimal numbers and sorted in ascending order, {d1, d2, . . . 
dy-1, dy}.  The block, ÔÅ¢n=Substr(C, 0, dy), where C is initially 
a copy of the cipher text. 
 
The third section (Step 2.c of the algorithm) divides 
block ÔÅ¢n into a number of random size segments.  The size 
and the number of segments are dictated by ÔÅ´ internal 
representation.  Block ÔÅ¢n has y segments: { s0 . . .sy-1}.  
 
The segment si starts from the first byte after the 
segment si-1 (the location is preserved in variable CL) and 
contains Œªi=di+1 ‚Äì di bytes.  The number of segments and 
their lengths are not the same for different blocks.   
 
To get the next block of the ciphertext, the block ÔÅ¢n is 
removed from C (Step 2.e) and ÔÅ´ is changed by having a 
one-bit-left-rotation (Step 2.f).  Using the above process 
along with new ÔÅ´, the next block with a different size is 
identified.  This process continues until C is exhausted.   It 
is clear that the lengths of blocks are not necessarily the 
same.  In fact, the lengths of blocks are random.  It needs to 
be mentioned that length of the block ÔÅ¢i and ÔÅ¢i+8 are the 
same when ÔÅ´ is one byte long.  When ÔÅ´ is two bytes long, 
the length of the block ÔÅ¢i and ÔÅ¢i+16 are the same. And a block 
on average is 32,768 bytes long.  As a result, the ciphertext, 
on average, must be longer than 491,520 bytes before the 
blocks‚Äô lengths are repeated. 
  
 
 
 
 
 
 
 
 
 
Figure 4. Algorithm Select 
 
The fourth section (Step 2.d of the algorithm) delivers 
the masked version of the ciphertext, byte by byte, for a 
given segment.  Flagged bytes are not masked (Step 2.d1).  
If the number of bytes in the segment si is greater than the 
cardinality of the pattern then, the pattern repeats itself 
(Step 2.d2).  Each byte, cj, of the segments si (for i=1 to y-1) 
are masked by applying (i) the relevant member of the 
current sub-pattern on byte cj (Step 2.d3 and 2.d4), (ii) 
identifying the key image (Step 2.d5), by invoking the 
Algorithm Select (Figure 4), (iii) create cj‚Äô, the masked 
version of the cj, by XORing the outcome of process (i) and 
process (ii), (Step 2.d6), and (iv) concatenate the masked 
version of the cj, to string of IC which ultimately becomes 
the inoculated version of the inputted ciphertext  (Step 2.d7).   
 
2) Unmasking of the Ciphertext: For unmasking a 
masked ciphertext, those steps that were taken during the 
masking process are applied in reverse order.  Therefore, the 
Algorithm Mask with a minor change in step 2.d can be 
used for unmasking.  We show only the changes to Step d of 
Figure 3 in Figure 5.   
 
 
 
 
 
 
 
 
 
Figure 5.  The modified part of the Algorithm Mask 
IV. EMPIRICAL RESULTS 
 
To measure the effectiveness of the proposed Vaccine, 
we compare its performance with the performance of the 
well-established masking algorithms of CBC and CFB.  The 
behavior of Vaccine was observed using three separate 
profiles of simple, moderate, and complex.  These 
observations are named VACs, VACm, and VACc. 
 
Two plaintext templates of natural and synthetic were 
chosen and 100 plaintexts were generated for each template.  
Each plaintext following the first template was selected 
from a natural document made up of the lower and upper 
case alphabets and the 10 digits‚Äîtotal of 62 unique 
symbols.  Each plaintext following the second template was 
randomly synthesized using the10 symbols set of {A, b, C, 
L, x, y, 0, 4, 6, 9}.  The goal was to synthesize plaintexts 
with high occurrences of a small set of symbols.  Each 
plaintext created under both templates was 1K bytes long. 
 
For each plaintext, two ciphertexts of Ca and Cd were 
generated using Advanced Encryption System (AES-128) 
and 
Data 
Encryption 
Standard 
(DES) 
algorithms 
[12][13][14]. The masking approaches of CBC, CFB, 
VACs, VACm, and VACc were applied separately on Ca and 
Cd generating the masked ciphertexts of:  
 
  {ùê∂ùëé
ùëêùëèùëê, ùê∂ùëé
ùëêùëìùëè,  ùê∂ùëé
ùë£ùëéùëêùë†,  ùê∂ùëé
ùë£ùëéùëêùëö,  ùê∂ùëé
ùë£ùëéùëêùëê} and 
 
  {ùê∂ùëë
ùëêùëèùëê, ùê∂ùëë
ùëêùëìùëè,  ùê∂ùëë
ùë£ùëéùëêùë†,  ùê∂ùëë
ùë£ùëéùëêùëö,  ùê∂ùëë
ùë£ùëéùëêùëê}.  
 
   
When CFB applied on Ca and Cd the key lengths were 
64-bit and 128-bit, respectively, and IV chosen from a 
natural document.  (The least significant 64 bits of the 128-
bit key was used as the key when CFB was applied on Ca.  
The key used by VACs, VACm, and VACc was also 
borrowed from the least significant 32 bits of the 128-bit 
key used for CFB.) 
 
Let us consider the first set of masked ciphertexts 
 {ùê∂ùëé
ùëêùëèùëê, ùê∂ùëé
ùëêùëìùëè,  ùê∂ùëé
ùë£ùëéùëêùë†,  ùê∂ùëé
ùë£ùëéùëêùëö,  ùê∂ùëé
ùë£ùëéùëêùëê} generated from Ca.  The 
following steps are used to compare the effectiveness of the 
proposed Vaccine with CBC and CFB.  (The same steps are 
d- Repeat for each byte, cj‚Äô, in si 
d1- If (cj is a flagged byte) Then continue; 
d2- If (CurrentP[0] is exhausted)  Then CurrentP[0] = ùëÉùëéùë°ùë°ùëíùëüùëõùëùùë°
0 ;  
d3- œÉ = Select(cj‚Äô, CurentP[1], CurrentP[2], CurrentP[3], CurrentP[4]; 
d4- ÔÅ° = cj‚Äô ÔÉÖ œÉ; 
d5- ÔÅ° = Circularly swap bits of ÔÅ° using CurrentP[0]; 
d6- ÔÅ° = Flip a bits using CurrentP[0]; 
d7- UM‚ÜêUM||ÔÅ°; //UM is the unmasked ciphertext;  
End; 
 
 
Algorithm Select 
Input: A byte (c), Key, and four patterns for the four key bytes. 
Output: key image, k. 
Method: 
a. Repeat for (w = 1 to 4) 
If (CurrentP[w] is exhausted)  
Then CurrentP[w] = ùëÉùëéùë°ùë°ùëíùëüùëõùëùùë°
ùë§ ;  
End; 
b. h ‚Üê -1; 
c. Repeat for v= 1 to 4; 
i. cv ‚Üê An instantiated version of KeyBytev using 
related sub-pattern.  
ii. If HD(c, cv) >h //HD is Hamming distance function 
Then 
h = HD(c, cv); k = cv; 
   End; 
End; 
45
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-605-7
CYBER 2017 : The Second International Conference on Cyber-Technologies and Cyber-Systems

also followed to compare the effectiveness of the proposed 
Vaccine with CBC and CFB using the masked ciphertexts 
of {ùê∂ùëë
ùëêùëèùëê, ùê∂ùëë
ùëêùëìùëè,  ùê∂ùëë
ùë£ùëéùëêùë†,  ùê∂ùëë
ùë£ùëéùëêùëö,  ùê∂ùëë
ùë£ùëéùëêùëê}.) 
a. Get the list of unique symbols that the plaintext is made 
up of, List={ÔÅ≥1 . . . ÔÅ≥m }.  
b. Get the frequency of symbol ÔÅ≥i, for i = 1 to m, and 
calculate the average frequency of the symbols. 
c. Repeating the next two steps for every symbol, ÔÅ≥i, in the 
list. 
d. Identify the locations for all the occurrences of the 
symbol, ÔÅ≥i, in the plaintext, (‚Ñìi
1 . . . ‚Ñìi
n). 
e. Identify the bytes in the locations of (‚Ñìi
1 . . . ‚Ñìi
n) within 
the ùê∂ùëé
ÔÇ∑ and calculate the Hamming distance, hj, between 
the two bytes in location ‚Ñìj, for j=1 to n, in the plaintext 
and ùê∂ùëé
ÔÇ∑.  The overall average of Hamming distance for 
the symbol ÔÅ≥i is hÔÅ≥i =Average(h1 . . . hn),  
f. Concluding that the underline masking methodology 
with the highest average values of the Hamming 
distances have a superior performance. 
 
The outcome of applying the above steps on the 
ciphertexts of    {ùê∂ùëé
ùëêùëèùëê, ùê∂ùëé
ùëêùëìùëè,  ùê∂ùëé
ùë£ùëéùëêùë†,  ùê∂ùëé
ùë£ùëéùëêùëö,  ùê∂ùëé
ùë£ùëéùëêùëê} and  
 {ùê∂ùëë
ùëêùëèùëê, ùê∂ùëë
ùëêùëìùëè,  ùê∂ùëë
ùë£ùëéùëêùë†,  ùê∂ùëë
ùë£ùëéùëêùëö,  ùê∂ùëë
ùë£ùëéùëêùëê} are shown in Table 1.a 
and Table 1.b.  We have also used the system clock to 
calculate the average throughput (in millisecond) for the 
masking approaches of CBC, CFB, VACs, VACm, and 
VACc and reported in Tables 2.a and 2.b. 
TABLE I. AVERAGE OF HAMMING DISTANCES BETWEEN THE 
TWO 100 PLAINTEXTS OF 1K BYTE LONG (GENERATED 
BY TWO TEMPLATES) AND THEIR RELATED MASKED 
CIPHERTEXTS:  (A) ENCRYPTED BY AES AND (B) 
ENCRYPTED BY DES 
Tem.  
Avg. 
Symb. 
Freq. 
AES-128 
CBC 
CFB128 
VACs  
VACm  
VACc  
Dist. 
Dist. 
Dist. 
Dist. 
Dist. 
Syn. 
103 
3.568 
3.570 
4.415 
4.373 
4.411 
Natu. 
16.5 
3.569 
3.561 
4.423 
4.361 
4.411 
(a) 
 
 
 
Tem.  
Avg. 
Symb.
Freq. 
DES 
CBC 
CFB64 
VACs  
VACm  
VACc  
Dist. 
Dist. 
Dist. 
Dist. 
Dist. 
Syn. 
103 
3.527 
3.526 
4.182 
4.153 
4.223 
Natu. 
16.5 
3.513 
3.515 
4.176 
4.141 
4.221 
(b) 
 
 
 
In addition, a masking strength of ÔÅ≠ (0 < ÔÅ≠ < 1), is 
introduced that is defined as ÔÅ≠=Ninst / Nocc, where Ninst is the 
number of unique bytes in the masked ciphertext 
representing the instantiations of the Nocc occurrences of 
symbol ÔÅ≥i in the underlying plaintext of the masked 
ciphertext.  The masking strength for CBC, CFB, VACs, 
VACm, and VACc are presented in Tables 3.a and 3.b. 
V. CONCLUSIONS AND FUTURE RESEARCH 
 
The performance of the presented new cipher block 
approach, Vaccine, for masking and unmasking of 
ciphertexts seems superior to the performance of the well-
known masking approaches of CBC and CFB.  
TABLE II. THROUGHPUT AVERAGE IN MILISECOND FOR THE 
TWO 100 PLAINTEXTS OF 1K BYTE LONG (GENERATED 
BY TWO TEMPLATES):  (A) ENCRYPTED BY AES AND 
(B) ENCRYPTED BY DES  
Tem.  
Avg 
Symb.
Freq. 
AES-128 
CBC 
CFB128 
VACs  
VACm  
VACc  
TPut. 
TPut. 
TPut. 
TPut. 
TPut. 
Syn. 
103 
4545 
11111 
25000 
33334 
20000 
Natu. 
16.5 
12500 
10000 
16667 
20000 
12500 
(a) 
Tem.  
Avg 
Symb. 
Freq. 
DES 
CBC 
CFB64 
VACs  
VACm  
VACc  
TPut. 
TPut. 
TPut. 
TPut. 
TPut. 
Syn. 
103 
3846 
11111 
20000 
25000 
14286 
Natu. 
16.5 
10000 
10000 
14286 
20000 
11111 
(b) 
TABLE III. AVERAGE MASKING STRENGTH FOR THE TWO 100 
PLAINTEXTS OF 1K BYTE LONG (GENERATED BY TWO 
TEMPLATES): 
(A) 
ENCRYPTED 
BY 
AES 
AND 
(B) 
ENCRYPTED BY DES 
Tem.  
Avg. 
Symb. 
Freq. 
AES-128 
CBC 
CFB128 
VACs  
VACm  
VACc  
ÔÅ≠ÔÄ†
ÔÅ≠ 
ÔÅ≠ 
ÔÅ≠ 
ÔÅ≠ 
Syn. 
103 
0.506 
0.486 
0.451 
0.540 
0.571 
Natu. 
16.5 
0.882 
0.878 
0.845 
0.890 
0.889 
(a) 
 
Tem.  
Avg. 
Symb.
Freq. 
DES 
CBC 
CFB64 
VACs  
VACm  
VACc  
ÔÅ≠ÔÄ†
ÔÅ≠ 
ÔÅ≠ 
ÔÅ≠ 
ÔÅ≠ 
Syn. 
103 
0.501 
0.494 
0.490 
0.564 
0.570 
Natu. 
16.5 
0.878 
0.894 
0.880 
0.909 
0.893 
(b) 
 
 
 
The advantages of Vaccine over CBC and CFB are 
numerated as follows:    
a. The key and patterns‚Äô profile may hide in the masked 
ciphertext. 
b. The block size for Vaccine is not fixed and it is selected 
randomly.    
c. Each block is divided into segments of random size.   
d. The masking pattern changes from one byte to the next 
in a given segment. 
e. Masking a ciphertext using Vaccine demands mandatory 
changes in the ciphertext.  Therefore, the identity 
transformation could not be provided through the 
outcome of Vaccine. The simple proof is that the 
Hamming weight is modified. 
f. The results revealed that on average: 
i. The Hamming distance between masked and 
unmasked occurrences of a byte using Vaccine is 
0.72 bits higher than using CBC and CFB. 
ii. Vaccine throughput is 3.4 times and 1.8 times higher 
than throughput for CBC and CFB. 
iii. Vaccine masking strength is 1.5% and 1.8% higher 
than masking strength for CBC and CFB. 
46
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-605-7
CYBER 2017 : The Second International Conference on Cyber-Technologies and Cyber-Systems

iv. VACm masking strength is 3.6% and 3.7% higher 
than masking strength for CBC and CFB.  And VACc 
masking strength is 3.9% and 4.2% higher than 
masking strength for CBC and CFB.  
 
As the future research, building a new version of 
Vaccine is in progress to make the throughput and the 
masking strength of the methodology even higher.  In 
addition, the use of Vaccine in a parallel processing 
environment also will be investigated. In addition, a 
feasibility study for using Vaccine as an authentication 
method is in progress. 
REFERENCES 
 [1]  A. A. Rasheed, M. Cotter, B. Smith, D. Levan, and S. Phoha, 
‚ÄúDynamically Reconfigurable AES Cryptographic Core for 
Small, Power Limited Mobile Sensors", The 35th IEEE 
International Performance Computing and Communication 
Conference and Workshop, pp. 1-7, 2016. 
[2]    G. P. Saggese, A. Mazzeo, N. Mazzocca and A. G. M. 
Strollo, ‚ÄúAn FPGA-based performance analysis of the 
unrolling, tiling, and pipelining of the AES algorithm‚Äù, LNCS 
2778, pp. 292-302, 2003. 
[3]  N. Pramstaller and J. Wolkerstorfer, ‚ÄúA Universal and 
Efficient AES Co-processor for Field Programmable Logic 
Arrays‚Äù, Lecture Notes in Computer Science, Springer, 
Vol.3203, pp. 565-574, 2004. 
[4] B. Moeller. Security of CBC Cipher suites in SSL/TLS: 
Problems and Countermeasures. [Online]. Available from: 
https://www.openssl.org/~bodo/tls-cbc.txt 
[5] W. 
Stallings, 
‚ÄúCryptography 
and 
Network 
Security: 
Principles and Practice‚Äù, Pearson, 2014. 
[6] C. A. Henk and V. Tilborg, ‚ÄúFundamentals of Cryptology: ‚ÄúA 
Professional Reference and Interactive Tutorial‚Äù, Springer 
Science & Business Media, 2006.  
[7] N. Feruson, B. Schneier, and T. Kohno, ‚ÄúCryptography 
Engineering: Design Principles and Practical Applications‚Äù, 
Indianapolis: Wiley Publishing, Inc., pp. 63-64, 2010. 
[8] W. F. Ehrsam, C. H. W. Meyer, J. L. Smith, and L. W. 
Tuchman, "Message Verification and Transmission Error 
Detection by Block Chaining", US Patent 4074066, 1976. 
[9] C. Kaufman, R. Perlman, and M. Speciner, ‚ÄúNetwork 
Security‚Äù, 2nd ed., Upper Saddle River, NJ: Prentice Hall, 
p. 319, 2002. 
[10]  National 
Institute 
of 
Standards 
and 
Technology 
(NIST), Advanced 
Encryption 
Standard 
(AES), Federal 
Information 
Processing 
Standards 
Publications 
197 
(FIPS197), Nov. 2001. 
[11]  S. Vaudenay, ‚ÄúSecurity Flaws Induced by CBC Padding ‚Äî 
Applications to SSL, IPSEC, WTLS....‚Äù, Lecture Notes in 
Computer Science, Springer, vol. 2332, pp. 534-546, 2002. 
[12] H. Kuo-Tsang, C. Jung-Hui, and S. Sung-Shiou, "A Novel 
Structure with Dynamic Operation Mode for Symmetric-Key 
Block Ciphers",  International Journal of Network Security & 
Its Applications, Vol. 5, No. 1, p. 19, 2013. 
[13] H. Feistel, ‚ÄúCryptography and Computer Privacy", Scientific 
American, Vol. 228, No. 5, pp 15‚Äì23, 1973. 
[14]  F. Charot, and E. Yahya, and C. Wagner, ‚ÄúEfficient Modular-
Pipelined AES Implementation in Counter Mode on 
ALTERA FPGA‚Äù, (FPL 2003), Lisbon, Portugal, pp. 282-
291, 2003. 
 
 
47
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-605-7
CYBER 2017 : The Second International Conference on Cyber-Technologies and Cyber-Systems

