Abstract State Machines Mutation Operators
Jameleddine Hassine
Department of Information and Computer Science
King Fahd University of Petroleum and Minerals, Dhahran, Kingdom of Saudi Arabia
jhassine@kfupm.edu.sa
Abstract—Mutation testing is a well established fault-based
technique for assessing and improving the quality of test
suites. Mutation testing can be applied at different levels of
abstraction, e.g., the unit level, the integration level, and the
speciﬁcation level. Designing mutation operators represents
the cornerstone towards conducting effective mutation testing
and analysis. While mutation operators are well deﬁned for
a number of programming and speciﬁcation languages, to
the best of our knowledge, mutation operators have not been
deﬁned for the Abstract State Machines (ASM) formalism. In
this paper, we deﬁne and classify mutation operators for the
Abstract State Machines (ASM) formalism. The proposed ASM
mutation operators are illustrated using examples written in the
CoreASM language. Furthermore, we have developed a tool for
automatic generation of mutants from CoreASM speciﬁcations.
Keywords-Mutation testing; speciﬁcation; mutation operator;
Abstract State Machines (ASM); CoreASM.
I. INTRODUCTION
Mutation testing [1] is a well established fault-based
testing technique for assessing and improving the quality
of test suites. Mutation testing uses mutation operators to
introduce small changes, or mutations, into the software
artifact (i.e., source code or speciﬁcation) under test. A
mutant is produced by applying a single mutation operator,
and for each mutant a test is derived that distinguishes the
behaviors of the mutated and original artifact.
In a recent survey on the development of mutation testing,
Jia and Harman [2] have stated that more than 50% of
the mutation related publications have been applied to Java
[3], Fortran [4] and C [5]. Although mutation testing has
mostly been applied at the source code level, it has also been
applied at the speciﬁcation and design level [6][2]. Formal
speciﬁcation languages to which mutation testing has been
applied include Finite State Machines [7][8][9], Statecharts
[10], Petri Nets [11] and Estelle [12].
Fabbri et al. [7] have applied speciﬁcation mutation to val-
idate speciﬁcations based on Finite State Machines (FSM).
They have proposed 9 mutation operators, representing faults
related to the states (e.g., wrong-starting-state, state-extra,
etc.), transitions (e.g., event-missing, event-exchanged, etc.)
and outputs (e.g., output-missing, output-exchanged, etc.)
of an FSM. In a related work, Fabbri et al. [10] have
deﬁned mutation operators for Statecharts, an extension
of FSM formalism, while Batth et al. [13] have applied
mutation testing to Extended Finite State Machines (EFSM)
formalism.
Hierons and Merayo [9] have investigated the application
of mutation testing to Probabilistic (PFSMs) or stochastic
time (PSFSMs) Finite State Machines. The authors [9] have
deﬁned new mutation operators representing FSM faults
related to altering probabilities (PFSMs) or changing its
associated random variables (PSFSMs) (i.e., the time con-
sumed between the input being applied and the output being
received).
The widespread interest in model-based testing techniques
provides the major motivation of this research. We, in
particular, focus on investigating the applicability of fault-
based testing (vs. scenario-based testing) to Abstract State
Machines (ASM) [14] speciﬁcations. We aim at assessing
and further enhancing the fault-ﬁnding effectiveness of test
suites targeting ASM-based models.
While mutation operators are well deﬁned for a number
of FSM related paradigms such as EFSM, PFSM and Stat-
echarts, to the best of our knowledge mutation operators
have not been deﬁned for the Abstract State Machines [14]
paradigm.
This paper serves the following purposes:
• Provide a set of mutation operators for Abstract State
Machines [14] formalism.
• Present a classiﬁcation of the proposed mutation op-
erators into three categories: ASM domain operators,
ASM function update operators, and ASM transition
rules operators.
• Present a tool for generating and validating ASM
mutants.
The remainder of this paper is organized as follows. The
next section provides an overview of the Abstract State
Machines (ASM) [14] formalism. In Section III, we deﬁne
and classify a collection of mutation operators for ASM
paradigm. Section IV describes the ASM Mutation tool.
Finally, conclusions are drawn in Section V.
II. ABSTRACT STATE MACHINES
Abstract State Machines (ASM) [14] deﬁne a state-based
computational model, where computations (runs) are ﬁnite
or inﬁnite sequences of states {Si} obtained from a given
initial state S0 by repeatedly executing transitions δi:
436
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

S0
δ1
/ S1
δ2
/ S2
. . .
δn / Sn
An ASM A is deﬁned over a ﬁxed vocabulary V, a
ﬁnite collection of function names and relation names. Each
function name f has an arity (number of arguments that
the function takes). Function names can be static (i.e., ﬁxed
interpretation in each computation state of A) or dynamic
(i.e., can be altered by transitions ﬁred in a computation
step). Dynamic functions can be further classiﬁed into:
• Input functions that A can only read, which means
that these functions are determined entirely by the
environment of A. They are also called monitored.
• Controlled functions of A are those which are updated
by some of the rules of A and are never changed by
the environment.
• Output functions of A are functions which A can only
update but not read, whereas the environment can read
them (without updating them).
• Shared functions are functions which can be read and
updated by both A and the environment.
Static nullary (i.e., 0-ary) function names are called con-
stants while Dynamic nullary functions are called variables.
ASM n-ary functions have the following form: f: T1 x T2
x ...... Tn → T.
Given a vocabulary V, an ASM A is deﬁned by its
program P and a set of distinguished initial states S0. The
program P consists of transition rules and speciﬁes possible
state transitions of A in terms of ﬁnite sets of local function
updates on a given global state. Such transitions are atomic
actions. A transition rule that describes the modiﬁcation of
the functions from one state to the next has the following
form:
if Condition then <Updates> endif
where Updates is a set of function updates (containing only
variable free terms) of form: f(t1,t2,. . .,tn):= t which are
simultaneously executed when Condition (called also guard)
is true. In a given state, ﬁrst, all parameters ti, t are evaluated
to their values, vi, v, then the value of f(v1,. . .,vn) is updated
to v. Such pairs of a function name f, which is ﬁxed by the
signature, and an optional argument (v1,. . .,vn), which is
formed by a list of dynamic parameters value vi, are called
locations.
Example1: The following rule yields the update-set {(x,
2), (y(0), 1)}, if the current state of the ASM is {(x, 1),
(y(0), 2)}:
if
(x = 1)
then
x := y(0)
y(0) := x
In every state, all the rules which are applicable are
simultaneously applied. A set of ASM updates is called
consistent if it contains no pair of updates with the same
locations, i.e., no two elements (loc,v) and (loc,v’) with
v̸=v’. In the case of inconsistency, the computation does
not yield a next state.
Example2: The following update set {(x, 1), (y, 3), (x,
2)}, is inconsistent due to the conﬂicting updates for x:
x := 1
y := 3
x := 2
For a detailed description of Abstract State Machines, the
reader is invited to consult [15].
In what follows, we describe mutation operators for
Abstract State Machines. Although, we illustrate the appli-
cability of our approach using features and examples from
CoreASM [16], our proposed mutation operators can be
applied to any ASM-based language, thus maintaining the
discussion generic.
III. ABSTRACT STATE MACHINES MUTATION
OPERATORS
We use the following guiding principles, introduced in
[17], to formulate our mutation operators:
• Mutation categories should model potential faults.
• Only simple, ﬁrst order mutants should be generated.
• Only syntactically correct mutants should be generated.
There exist several aspects of an ASM speciﬁcation that
can be subject to faults. These aspects can be classiﬁed into
three categories of mutation operators:
1) ASM domain mutation operators.
2) ASM function update mutation operators.
3) ASM transition rules mutation operators.
Each category contains many mutation operators, one per a
fault class.
A. ASM Domain Mutation Operators
A domain (called also universe) consists of a set of
declarations that establish the ASM vocabulary. Each
declaration establishes the meaning of an identiﬁer within
its scope. For example, the following CoreASM [16] code
deﬁnes a new enumeration background PRODUCT having
three elements (i.e., Soda, Candy, and Chips) and three
functions selectedProduct, price, and packaging:
enum PRODUCT = {Soda, Candy, Chips}
function selectedProduct: → PRODUCT
function price: PRODUCT → NUMBER
function packaging: PRODUCT*PRODUCT → NUMBER
ASM domains/universes can be mutated by adding or
removing elements. Table I shows examples of the following
domain mutation operators:
• Extend Domain Operator (EDO): the domain is ex-
tended with a new element.
437
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

• Reduce Domain Operator (RDO): the domain is re-
duced by removing one element.
• Empty Domain Operator (EYDO): the domain is emp-
tied.
Table I
EXAMPLES OF ASM DOMAIN MUTATION OPERATORS FOR CoreASM
[16]
Mutation Operator
CoreASM Mutant S’
Extend Domain Operator
(EDO)
enum PRODUCT = {Soda, Candy,
Chips, Sandwich}.
Reduce Domain Operator
(RDO)
enum
PRODUCT
=
{Soda,
Candy}.
Empty Domain Operator
(EYDO)
enum PRODUCT = {}.
B. ASM Function Update Mutation Operators
A function update has the following form:
f(t1, t2, . . ., tn):= value
Depending on the type of operands, the traditional operators
[4] such as Absolute Value Insertion (ABS), Arithmetic
Operator Replacement (AOR), Logical Operator Replace-
ment (LOR), Statement Deletion (SDL), Scalar Variable
Replacement (SVR) etc., can be applied. In addition to these
traditional mutation operators, we deﬁne:
• Function Parameter Replacement (FPR): parameters
of a function are replaced by other parameters of a
compatible type.
• Function Parameter Permutation (FPP): parameters of
a function are exchanged.
Table II
EXAMPLES OF FUNCTION UPDATE MUTATION OPERATORS FOR
CoreASM [16]
Mutation
Operator
CoreASM Spec S
CoreASM Mutant
S’
AOR
x := a + b
x := a - b
ABS
x := a + b
x := a + abs(b)
LOR
y := m and n
y := m or n
SDL
x := a + b
skip
SVR
selectedProduct:=
Soda
selectedProduct:=
Candy
FPR
price(Soda):=70
price(Candy):=70
FPP
packaging(Soda,
Candy):= 1
packaging(Candy,
Soda):= 1
Table II describes the proposed function update mutation
operators.
C. ASM Transition Rules Mutation Operators
The transition relation is speciﬁed by guarded function
updates, called rules, describing the modiﬁcation of the
functions from one state to the next. An ASM state transition
is performed by ﬁring a set of rules in one step.
1) Conditional Rule Mutation Operators:: The general
schema of an ASM transition system appears as a set of
guarded rules:
if Cond then Rulethen else Ruleelse endif
where Cond, the guard, is a term representing a boolean
condition. Rulethen and Ruleelse are transition rules.
Many types of faults may occur on the guards of con-
ditional rules [18]. Some of these faults include Literal
Negation fault (LNF), Expression Negation fault (ENF),
Missing Literal fault (MLF), Associative Shift fault (ASF),
Operator Reference fault (ORF), Relational Operator fault
(ROF), Stuck at 0(true)/1(false) fault (STF). Table III il-
lustrates the mutation operators addressing the above fault
classes. Furthermore, we deﬁne three additional conditional
rule mutation operators:
• Then Rule Replacement Operator (TRRO): replaces the
rule Rulethen by another rule.
• Else Rule Replacement Operator (ERRO): replaces the
rule Ruleelse by another rule.
• Then Else Rule Permutation Operator (TERPEO): per-
mutes the Rulethen and the Ruleelse rules.
Table III
EXAMPLES OF CONDITIONAL RULE MUTATION OPERATORS FOR
CoreASM [16]
Mutation
Operator
CoreASM Spec S
CoreASM Mutant S’
LNO
if (a and b)
if (not a and b)
ENO
if (a and b)
if not (a and b)
MLO
if (a and b)
if (b)
ASO
if (a and (b or a))
if ((a and b) or a)
ORO
if (a and b)
if (a or b)
ROO
if (x >= c)
if (x <= c)
STO
if (a and b)
if (true)
TRRO
if a then R1 else R2
if a then R3 else R2
ERRO
if a then R1 else R2
if a then R1 else R3
TERPEO
if a then R1 else R2
if a then R2 else R1
2) Parallel and Sequence Rule Mutation Operators::
Parallel Constructor: If a set of ASM transition rules have
to be executed simultaneously, a parallel rule is used:
par Rule1 . . . Rulen endpar
The update generated by this rule is the union of all the
updates generated by Rule1 to Rulen.
Sequence Constructor: The sequence rule aims at exe-
cuting rules/function updates in sequence:
seq Rule1, . . ., Rulen
The resulting update set is a sequential composition of the
updates generated by Rule1 . . . Rulen.
We deﬁne the following mutation operators for both
Parallel and Sequence constructors:
• Add Rule Operator (ARO): adds a new rule to the
parallel/sequence of rules.
438
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

• Delete Rule Operator (DRO): deletes a rule from the
parallel/sequence of rules.
• Replace Rule Operator (RRO): replaces one of the rules
in the parallel/sequence by another rule.
• Permute Rule Operator (PRO): changes the order of the
parallel/sequence rules by permuting two rules.
Table IV
EXAMPLES OF THE PARALLEL/SEQUENCE RULE MUTATION
OPERATORS FOR CoreASM [16]
Mutation
Operator
CoreASM Spec S
CoreASM Mutant S’
ARO
seqblock R1 R2 endse-
qblock
seqblock R1 R2 R3
endseqblock
ARO
par R1 R2 endpar
par R1 R2 R3 endpar
DRO
seqblock R1 R2 R3
endseqblock
seqblock R1 R3 endse-
qblock
DRO
par R1 R2 R3 endpar
par R1 R3 endpar
RRO
seqblock R1 R2 endse-
qblock
seqblock R1 R3 endse-
qblock
RRO
par R1 R2 endpar
par R1 R3 endpar
PRO
seqblock R1 R2 endse-
qblock
seqblock R2 R1 endse-
qblock
PRO
par R1 R2 endpar
par R2 R1 endpar
SPEO
seqblock R1 R2 endse-
qblock
par R1 R2 endpar
SPEO
par R1 R2 endpar
seqblock R1 R2 endse-
qblock
In addition to these rules, we deﬁne the Sequence-Parallel
Exchange Operator (SPEO) to exchange a sequence rule
with a parallel rule and vice versa. Table IV illustrates the
Parallel/Sequence rule mutation operators.
It is worth noting that:
• Applying SPEO operator may result into mutants that
are syntactically correct but containing inconsistent
updates. Table V shows a simple coreASM sequence
rule and its corresponding mutant after applying SPEO
operator. The execution of the produced mutant leads
to an inconsistent update of variable a (i.e., the com-
putation of the rule does not yield a next state).
Table V
APPLYING SPEO OPERATOR THAT LEADS TO AN INCONSISTENT
UPDATE
Original Spec S
Mutant Spec S’
rule Main =
rule Main =
seqblock
par
a := a + 1
a := a + 1
a := b
a := b
endseqblock
endpar
• Applying SPEO operator may produce a mutant that
is equivalent to the original speciﬁcation. Indeed, such
a case may take place when the rules enclosed within
the parallel/sequence blocks do not interfere. Table VI
shows a speciﬁcations S and its mutant S’. Both speciﬁ-
cations are equivalents from an input/output perspective
since variables a and b are updated independently.
However, the original speciﬁcation S produces 2 states
(i.e., one a:= a + 1 and one for b := b +1) whereas
its mutant S’ produces only one single state (i.e., a:=
a +1 and b := b + 1 are executed in one single step).
Table VI
APPLYING SPEO OPERATOR PRODUCES A MUTANT THAT IS
EQUIVALENT TO THE ORIGINAL SPEC
Original Spec S
Mutant Spec S’
rule Main =
rule Main =
seqblock
par
a := a + 1
a := a + 1
b := b + 1
b := b + 1
endseqblock
endpar
3) Choose Rule Mutation Operators:: The choose rule
consists on selecting elements (non deterministically) from
speciﬁed domains which satisfy guards φ, then evaluates
Rule1. If no such elements exist, then evaluates Rule2.
choose x1 in D1, . . ., xn in Dn with φ (x1, . . ., xn) do
Ruledo ifnone Ruleifnone
The with and ifnone blocks are optional. The guard
φ may be a simple boolean expression of predicate logic
expressions.
To cover the choose rule, we deﬁne the following mutation
operators:
• Choose Domain Replacement Operator (CDRO): re-
places a variable domain with another compatible do-
main.
• Choose Guard Modiﬁcation Operator (CGMO): alters
the guard φ. In this paper, we consider simple boolean
expressions as guards. Predicate logic expressions such
as exists are left for future work.
• Choose DoRule Replacement Operator (CDoRO): re-
places the rule Ruledo by another rule.
• Choose IfNoneRule Replacement Operator (CIRO): re-
places the rule Ruleifnone by another rule.
• Choose Rule Exchange Operator (CREO): replaces the
rule Ruleifnone by another rule.
Table VII
EXAMPLE OF THE CHOOSE RULE MUTATION OPERATORS FOR
CoreASM [16]
Mutation
Operator
CoreASM Spec S
CoreASM Mutant S’
CDRO
choose x in Set1 with
(x >= 0)
choose x in Set2 with
(x >= 0)
CGMO
choose x in Set1 with
(x >= 0)
choose x in Set1 with
(x <= 0)
CDoRO
choose x in Set1 do
Rule1
choose x in Set1 do
Rule2
CIRO
choose x in Set1 do
Rule1 ifnone Rule2
choose x in Set1 do
Rule1 ifnone Rule3
CREO
choose x in Set1 do
Rule1 ifnone Rule2
choose x in Set1 do
Rule2 ifnone Rule1
439
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

4) Forall Rule Mutation Operators:: The synchronous
parallelism is expressed by a forall rule which has the
following form:
forall x1 in D1, . . ., xn in Dn with φ do Ruledo
where x1, . . ., xn are variables, D1, . . ., Dn are the domains
where xi take their value, φ is a boolean condition, Ruledo
is a transition rule containing occurrences of the variables
xi bound by the quantiﬁer.
We deﬁne the following mutation operators for the forall
rule that are quite similar to the ones of the choose rule :
• Forall Domain Replacement Operator (FDRO): re-
places a variable domain with another compatible do-
main.
• Forall Guard Modiﬁcation Operator (FGMO): alters
the guard φ using the set of operators introduced in
Table III.
• Forall DoRule Replacement Operator (FDoRO): re-
places the rule Ruledo by any other rule.
Table VIII
EXAMPLES OF THE FORALL RULE MUTATION OPERATORS FOR
CoreASM [16]
Mutation
Operator
CoreASM Spec S
CoreASM Mutant S’
FDRO
forall x in Set1 with
(x = 0) do R1
forall x in Set2 with
(x >= 0) do R1
FGMO
forall x in Set1 with
(x = 0) do R1
forall x in Set1 with
(x <= 0) do R1
FDoRO
forall x in Set1 do R1
forall x in Set1 do R2
In addition to the proposed forall rule mutation operators
illustrated in Table VIII, we deﬁne the Choose-Forall Ex-
change Operator (CFEO) to exchange a choose rule with a
forall rule and vice versa (See Table IX).
Table IX
EXAMPLES OF THE CHOOSE-FORALL EXCHANGE OPERATOR FOR
CoreASM [16]
Mutation
Operator
CoreASM Spec S
CoreASM Mutant S’
CFEO
forall x in Set1 do R1
choose x in Set1 do R1
CFEO
choose x in Set1 do R1
forall x in Set1 do R1
5) Let Rule:: The let rule assigns a value of a term t to
the variable x and then execute the rule Rule which contains
occurrences of the variable x. The syntax of a Let rule is:
let (x = t) in Rule endlet
We deﬁne the following mutation operators (see Table X):
• Let Variable Assignment Operator (LVAO): assigns a
different value to x, other than t, of a compatible type.
• Let Rule Replacement Operator (LRRO): replaces the
rule Rule by another rule that has occurrences of x.
• Let Rule Variable Replacement (LRVR): replaces the
variable x by another variable.
Table X
EXAMPLES OF THE LET RULE OPERATORS FOR CoreASM [16]
Mutation
Operator
CoreASM Spec S
CoreASM Mutant S’
LVAO
let x = 1 in R1
let x = 2 in R1
LRRO
let x = 1 in R1
let x = 1 in R2
LRVR
let x = 1 in R1
let y = 1 in R1
Other ASM rules such as Case rule, iterate rule, etc. are
not covered in this work due to the lack of space.
IV. ASM MUTANTS GENERATION
Figure 1 illustrates the ASM Mutation Tool user interface.
The user may select one or multiple operators from the three
operator categories. The produced mutants are then stored
in separate ﬁles and run using carma, a comprehensive
command-line to run CoreASM speciﬁcation, to check their
validity. Figure 2 shows an example of the output produced
from the execution of carma, from the command line, on a
syntactically incorrect speciﬁcation (i.e., the output shows
’Engine Error’ and the error location). Note that only 1
execution step is needed to detect syntax errors (i.e., carma
–steps 1 MySpec.casm).
Figure 2.
Checking the Validity of the Generated Mutant
It is worth noting that the mutation operator EDO (Extend
Domain Operator) requires manual deﬁnition of the added
element.
V. CONCLUSION AND FUTURE WORK
In this paper, we have introduced mutation operators for
Abstract State Machines (ASM) formalism. The proposed
set of mutation operators are classiﬁed into three main
categories: ASM domain operators, ASM function update
operators, and ASM transition rules operators. Mutants are
generated automatically and their syntax are checked for
correctness. As a future work, we are planning to conduct an
empirical evaluation of the designed operators and to assess
their effectiveness and the number of mutants they produce.
REFERENCES
[1] A. P. Mathur, Mutation Testing.
John Wiley & Sons, Inc.,
2002.
[2] Y. Jia and M. Harman, “An analysis and survey of the de-
velopment of mutation testing,” Software Engineering, IEEE
Transactions on, vol. 37, no. 5, pp. 649 –678, Sept.-Oct. 2011.
[3] Y.-S. Ma, J. Offutt, and Y. R. Kwon, “Mujava: an automated
class mutation system: Research articles,” Softw. Test. Verif.
Reliab., vol. 15, pp. 97–133, June 2005.
440
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Figure 1.
ASM Mutation Toolkit
[4] A. J. Offutt, VI and K. N. King, “A fortran 77 interpreter
for mutation analysis,” SIGPLAN Not., vol. 22, pp. 177–188,
July 1987.
[5] H. Agrawal, “Design of mutant operators for the C program-
ming language,” Software Engineering Research Center/Pur-
due University, Tech. Rep., 1989.
[6] P. E. Black, V. Okun, and Y. Yesha, “Mutation operators for
speciﬁcations,” in Proceedings of the 15th IEEE international
conference on Automated software engineering, ser. ASE ’00.
Washington, DC, USA: IEEE Computer Society, 2000, pp.
81–88.
[7] S. Pinto Ferraz Fabbri, M. Delamaro, J. Maldonado, and
P. Masiero, “Mutation analysis testing for ﬁnite state ma-
chines,” in Proceedings of the 5th International Symposium
on Software Reliability Engineering, November 1994, pp. 220
–229.
[8] J.-h. Li, G.-x. Dai, and H.-h. Li, “Mutation analysis for
testing ﬁnite state machines,” in Proceedings of the 2009
Second International Symposium on Electronic Commerce
and Security - Volume 01, ser. ISECS ’09.
Washington,
DC, USA: IEEE Computer Society, 2009, pp. 620–624.
[9] R. M. Hierons and M. G. Merayo, “Mutation testing from
probabilistic and stochastic ﬁnite state machines,” J. Syst.
Softw., vol. 82, pp. 1804–1818, November 2009.
[10] S. C. P. F. Fabbri, J. C. Maldonado, T. Sugeta, and P. C.
Masiero, “Mutation testing applied to validate speciﬁcations
based on statecharts,” in Proceedings of the 10th International
Symposium on Software Reliability Engineering, ser. ISSRE
’99.
Washington, DC, USA: IEEE Computer Society, 1999,
pp. 210–219.
[11] S. C. P. F. Fabbri, J. C. Maldonado, P. C. Masiero, M. E.
Delamaro, and E. Wong, “Mutation testing applied to validate
speciﬁcations based on petri nets,” in Proceedings of the IFIP
TC6 Eighth International Conference on Formal Description
Techniques VIII.
London, UK, UK: Chapman & Hall, Ltd.,
1996, pp. 329–337.
[12] S. D. R. S. De Souza, J. C. Maldonado, S. C. P. F. Fabbri,
and W. L. De Souza, “Mutation testing applied to estelle
speciﬁcations,” Software Quality Control, vol. 8, pp. 285–301,
December 1999.
[13] S. S. Batth, E. R. Vieira, A. Cavalli, and M. U. Uyar,
“Speciﬁcation of timed efsm fault models in sdl,” in Proceed-
ings of the 27th IFIP WG 6.1 international conference on
Formal Techniques for Networked and Distributed Systems,
ser. FORTE ’07.
Berlin, Heidelberg: Springer-Verlag, 2007,
pp. 50–65.
[14] Y. Gurevich, “Evolving Algebras 1993: Lipari Guide,” in
Speciﬁcation and Validation Methods, E. B¨orger, Ed. Oxford
University Press, 1995, pp. 9–36.
[15] E. B¨orger and R. F. Stark, Abstract State Machines: A Method
for High-Level System Design and Analysis.
Secaucus, NJ,
USA: Springer-Verlag New York, Inc., 2003.
[16] R. Farahbod, V. Gervasi, and U. Gl¨asser, “CoreASM: An Ex-
tensible ASM Execution Engine,” Fundamenta Informaticae,
vol. 77, pp. 71–103, January 2007.
[17] M. Woodward, “Errors in algebraic speciﬁcations and an
experimental mutation testing tool,” Software Engineering
Journal, vol. 8, no. 4, pp. 211–224, Jul 1993.
[18] M. F. Lau and Y. T. Yu, “An extended fault class hierar-
chy for speciﬁcation-based testing,” ACM Trans. Softw. Eng.
Methodol., vol. 14, pp. 247–276, July 2005.
441
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

