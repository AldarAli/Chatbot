111
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
FUZZBOMB : Fully-Autonomous Detection and Repair of Cyber Vulnerabilities
David J. Musliner, Scott E. Friedman, Michael Boldt, J. Benton, Max Schuchard, Peter Keller
Smart Information Flow Technologies (SIFT) Minneapolis, USA
{dmusliner,sfriedman,mboldt,jbenton,mschuchard,pkeller}@sift.net
Stephen McCamant
University of Minnesota, Minneapolis, USA
mccamant@cs.umn.edu
Abstract‚ÄîSIFT and the University of Minnesota teamed up to
create a fully autonomous Cyber Reasoning System to compete
in the DARPA Cyber Grand Challenge. Starting from our prior
work on autonomous cyber defense and symbolic analysis of
binary programs, we developed numerous new components to
create FUZZBOMB. In this paper, we outline several of the major
advances we developed for FUZZBOMB, including a content-
agnostic binary rewriting system called BINSURGEON. We then
review FUZZBOMB‚Äôs performance in the Ô¨Årst phase of the Cyber
Grand Challenge competition.
Keywords-autonomous cyber defense; symbolic analysis; protocol
learning; binary rewriting.
I. INTRODUCTION
In June 2014, DARPA funded seven teams to build au-
tonomous Cyber Reasoning Systems (CRSs) to compete in
the DARPA Cyber Grand Challenge (CGC). SIFT and the
University of Minnesota together formed the FUZZBOMB
team [1], building on our prior work on the FUZZBUSTER
cyber defense system [2], [3], [4] and the FuzzBALL symbolic
analysis tool [5], [6], [7].
SIFT‚Äôs FUZZBUSTER system was built to automatically
Ô¨Ånd Ô¨Çaws in software using symbolic analysis tools and fuzz
testing, reÔ¨Åne its understanding of the Ô¨Çaws using additional
testing, and then synthesize adaptations (e.g., input Ô¨Ålters
or source-code patches) to prevent future exploitation of
those Ô¨Çaws, while also preserving functionality. FUZZBUSTER
includes an extensible plug-in architecture for adding new
analysis and adaptation tools, along with a time-aware, utility-
based meta-control system that chooses which tools are used
on which applications during a mission [8]. Before the CGC
began, FUZZBUSTER had already automatically found and
shielded or repaired dozens of Ô¨Çaws in widely-used software
including Linux tools, web browsers, and web servers.
In separate research, Prof. Stephen McCamant at the Uni-
versity of Minnesota had been developing the FuzzBALL tool
to perform symbolic analysis of binary x86 code. FuzzBALL
combines static analysis and symbolic execution to Ô¨Ånd Ô¨Çaws
and proofs of vulnerability through heuristic-directed search
and constraint solving. On a standard suite of buffer overÔ¨Çow
vulnerabilities, FuzzBALL found inputs triggering all but one,
many with less than Ô¨Åve seconds of search [5].
Together, FUZZBUSTER and FuzzBALL provided the seeds
of a strategic reasoning framework and deep binary analysis
methods needed for our FUZZBOMB CRS. However, many
challenges still had to be addressed to form a fully functioning
and competitive CRS. In this paper, we outline several of
the major advances we developed for FUZZBOMB, includ-
ing a new content-agnostic binary rewriting system called
BINSURGEON. We discuss the technical advances that allow
BINSURGEON‚Äôs template-based rewriting of stripped binaries
to mitigate vulnerabilities. Finally, we review FUZZBOMB‚Äôs
performance in the qualifying round of the CGC competition,
and discuss lessons learned.
II. BACKGROUND
A. DARPA‚Äôs Cyber Grand Challenge
BrieÔ¨Çy, the CGC is designed to be a simpliÔ¨Åed form of
Capture the Flag game, in which DARPA supplies Challenge
Binaries (CBs) that nominally perform some server-like func-
tion, responding to client connections and engaging in some
behavioral protocol as the client and server communicate. The
CBs are run on a modiÔ¨Åed Linux operating system called
Decree, which provides a limited set of system calls. In the
competition, CBs are provided as binaries only (no source
code) and are undocumented, so the CRSs have no idea what
function they are supposed to perform. However, in some cases
a network packet capture (PCAP) Ô¨Åle is provided, giving noisy,
incomplete traces of normal non-faulting client/server interac-
tions (‚Äúpollers‚Äù). Each CB contains one or more vulnerability
that can be accessed by the client sending some inputs, leading
to a program crash. To win the game, a CRS must Ô¨Ånd the
vulnerability-triggering inputs (called Proofs of Vulnerability
(PoVs)) and also repair the binary so that the PoVs no longer
cause a crash, and all non-PoV poller behavior is preserved.
The complex scoring system rewards Ô¨Ånding PoVs, repairing
PoVs, and preserving poller behavior, and penalizes increases
in CB size and decreases in CB speed.
B. FUZZBUSTER
Since 2010, we have been developing FUZZBUSTER [9]
under DARPA‚Äôs CRASH program to use software analysis
and adaptation to defeat a wide variety of cyber-threats. By
coordinating the operation of automatic tools for software
analysis, test generation, vulnerability reÔ¨Ånement, and adap-
tation generation, FUZZBUSTER provides long-term immunity
against both observed attacks and novel (zero-day) cyber-
attacks.

112
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
	 
 
 

!! 

 
 


 

 
 
  
 
!! 
 ! 
 
 
 
	

Figure 1.
FUZZBUSTER reÔ¨Ånes both proactive and reactive fault exemplars into vulnerability proÔ¨Åles, then develops and deploys adaptations that remove
vulnerabilities.
FUZZBUSTER operates both reactively and proactively, as
illustrated in Figure 1. When an attacker deploys an exploit
and triggers a program fault (or other detected misbehavior),
FUZZBUSTER captures the operating environment and recent
program inputs into a reactive exemplar. Similarly, when
FUZZBUSTER‚Äôs own software analysis and fuzz-testing tools
proactively create a potential exploit, it is summarized in
a proactive exemplar. These exemplars are essentially tests
that indicate a (possible) vulnerability in the software, which
FUZZBUSTER must characterize and then shield from future
exploitation. For example, an exemplar could hold a particular
long input string that arrived immediately before an observed
program fault. Proactive exemplars based on program analysis
may be more informative: they can represent not just a single
faulting input, but a set of constraints that deÔ¨Åne vulnerability-
triggering inputs. Reactive exemplars pose a greater threat,
since they almost certainly indicate that an attacker has already
found a software Ô¨Çaw.
Starting from an exemplar, FUZZBUSTER uses its program
analysis tools and fuzz-testing tools to reÔ¨Åne its understanding
of the vulnerability, building a vulnerability proÔ¨Åle (VP).
For example, FUZZBUSTER can use concolic testing to Ô¨Ånd
that the long-string reactive exemplar is triggering a buffer
overÔ¨Çow, and the VP would capture this information. Or,
FUZZBUSTER can use delta-debugging and other fuzzing tools
to determine the minimal portion of the string that triggers the
fault. Similarly, constraint relaxation can generalize symbolic
analysis exemplars to Ô¨Ånd additional paths to a vulnerability.
At the same time, FUZZBUSTER tries to create software
adaptations that shield or repair the underlying vulnerability.
In the simplest case, FUZZBUSTER may choose to create a
Ô¨Ålter rule that blocks some or all of the exemplar input (i.e.,
stopping the same or similar attacks from working a second
time). This may not shield the full extent of the vulnerability
(or may be too broad, compromising normal operation), so
FUZZBUSTER will keep working to reÔ¨Åne the VP and develop
more effective adaptations. Even symbolic analysis may not
yield a minimal description of the inputs that can trigger
a vulnerability: there may be many vulnerable paths, only
some of which are summarized by a constraint description.
Over time, as FUZZBUSTER reÔ¨Ånes the VP and gains a better
understanding of the Ô¨Çaw, it may create more sophisticated and
effective adaptations, such as Ô¨Ålters that block strings based on
length not exact content, or actual software patches that repair
the buffer overÔ¨Çow Ô¨Çaw. As it creates and applies adaptations,
FUZZBUSTER can choose to re-evaluate previous adaptations,
keeping those that remain effective and replacing those that
have been superceded. FUZZBUSTER already has sophisticated
techniques for creating Ô¨Ålters that eliminate vulnerability-
triggering inputs, which can be used as network-layer Ô¨Ålters
or application wrappers.
As different adaptations are developed, FUZZBUSTER can
assess their performance against the set of tests it has been
accumulating for a particular application, determining how ef-
fectively each adaptation stops known faulting inputs and pre-
serves the functionality of known non-faulting test cases (ei-
ther observed in the wild or generated by FUZZBUSTER) [10]1.
For example, Figure 2 illustrates FUZZBUSTER‚Äôs performance
on two applications, showing how it Ô¨Ånds vulnerabilities
(indicated by faulting test cases, the solid red line) and creates
adaptations (patches) that try to Ô¨Åx those faults. The dotted
red line indicates the number of faulting test cases that no
longer cause a fault in the patched application. We refer to
the undesirable area between those red lines, during which
known vulnerabilities are still exploitable, as the exposure.
The blue lines show the performance of the original ap-
plication (solid blue) and patched application (dotted) on
the non-faulting test cases. In the Ô¨Årst example, Figure 2a,
FUZZBUSTER‚Äôs analysis of the detected Ô¨Çaw is perfect: its
Ô¨Årst patch Ô¨Åxes all the known faulting test cases and does
not degrade performance on the reference test cases. In the
second example, Figure 2b, FUZZBUSTER creates a series
of different patches and Ô¨Ålters to shield a large number of
different faulting inputs, and in the process, some of those
degrade the application‚Äôs performance on the non-faulting test
cases (i.e., a gap appears between the solid and dotted blue
lines). However, eventually FUZZBUSTER replaces the lesser
adaptations with highly reÔ¨Åned adaptations that restore all of
1We call this ‚Äúpoor man‚Äôs regression testing,‚Äù since it does not require any
manually-created regression tests.

113
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
 0
 5
 10
 15
 20
 25
 0
 20
 40
 60
 80
 100
 120
 140
 160
 180
# Faulting Test Cases
Time (s)
PATCH 1 (0, 7, 23)
Reference Test Cases
Reference Test Cases Preserved
Faulting Test Cases Fixed
Faulting Test Cases Found
 0
 10
 20
 30
 40
 50
 60
 70
 80
 90
 0
 100
 200
 300
 400
 500
 600
 700
 800
# Faulting Test Cases
Time (s)
PATCH 1 (6, 0, 30)
PATCH 2 (6, 0, 30)
PATCH 3 (6, 0, 30)
PATCH 4 (6, 1, 30)
PATCH 5 (6, 10, 30)
PATCH 6 (6, 10, 30)
PATCH 7 (6, 40, 30)
PATCH 8 (6, 40, 30)
PATCH 9 (6, 40, 30)
PATCH 10 (6, 62, 30)
PATCH 11 (6, 62, 30)
PATCH 12 (6, 78, 30)
Reference Test Cases
Reference Test Cases Preserved
Faulting Test Cases Fixed
Faulting Test Cases Found
(a)
(b)
Figure 2.
FUZZBUSTER works continuously to derive better adaptations, improving an application‚Äôs performance on faulting and non-faulting test cases.
the performance and still prevent exploitation of all the known
vulnerabilities.
While FUZZBUSTER already had the coordination infras-
tructure and representation/reasoning to manage exemplars,
VPs, and adaptations, many of the tools we had integrated
could not apply to the CGC because they do not operate
directly on binaries. To Ô¨Åll these gaps and support the full
spectrum of vulnerability detection, exploitation, and repair
needed for CGC, we integrated with UMN‚Äôs FuzzBALL and
also developed new components, as described in Section III.
C. FuzzBALL
FuzzBALL is a Ô¨Çexible engine for symbolic execution and
automatic program analysis, targeted speciÔ¨Åcally at binary
software. In the following paragraphs we brieÔ¨Çy describe
the concepts of symbolic execution and explain FuzzBALL‚Äôs
architecture, emphasizing its features aimed at binary code.
The basic principle of symbolic execution is to replace
certain concrete values in a program‚Äôs state with symbolic
variables. Typically, symbolic variables are used to represent
the inputs to a program or sub-function, and the symbolic
analysis results in an understanding of what inputs can lead
to different parts of a program. An interpreter executes the
program, accumulating symbolic expressions for the results of
computations that involve symbolic variables, and constraints
(in terms of those symbols) that describe which conditional
branches will occur. These symbolic expressions are valuable
because they can summarize the effect of many potential
concrete executions (i.e., many possible inputs). When a
symbolic expression is used in a control-Ô¨Çow instruction, we
call the formula that controls the target a branch condition. On
a complete program run, the conjunction of the conditions for
all the symbolic branches is the path condition. We can use
an SMT solver [11], [12] (such as STP [13] or Z3 [14]) on a
path condition to Ô¨Ånd a set of concrete input values that would
cause the corresponding path to be executed, or to determine
what other paths might be feasible.
Many symbolic execution tools operate on program source
code (e.g., KLEE, Crest), but FuzzBALL is differentiated
by its focus on symbolic execution of binary code. At its
Figure 3.
An overview of our FuzzBALL binary symbolic execution engine.
core, FuzzBALL is an interpreter for machine (e.g., x86)
instructions, but one in which the values in registers and
memory can be symbolic expressions rather than just con-
crete bit patterns. Figure 3 shows a graphical overview of
FuzzBALL‚Äôs architecture. As it explores possible executions
of a binary, FuzzBALL builds a decision tree data structure.
The decision tree is a binary tree in which each node represents
the occurrence of a symbolic branch on a particular execution
path, and a node has children labeled ‚Äúfalse‚Äù and ‚Äútrue‚Äù
representing the next symbolic branch that will occur in either
case. FuzzBALL uses the decision tree to ensure that each
path it explores is different, and that exploration stops if no
further paths are possible.
To factor out instruction-set complexity, FuzzBALL builds
on the BitBlaze Vine library [15] for binary code analysis,
which provides a convenient intermediate language (the ‚ÄúVine
IL‚Äù) for representing instruction behavior. Another complexity
that arises at the binary level is that because memory is
untyped, loads may not have the same size and alignment as
stores. For example, a location might be written with a 4-byte
store and then read back with a sequence of 1-byte loads.
FuzzBALL optimizes for the common case by representing
symbolic values in memory at the granularity with which they
were stored, if they are naturally aligned, using a tree structure.
But it will automatically insert bitwise operations to subdivide
or assemble values as needed.
We have used FuzzBALL on several CGC-relevant research
projects, which typically build on the basic FuzzBALL engine
by adding heuristics or other features specialized for a par-
ticular problem domain. Babi¬¥c et al. [5] combined dynamic

114
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
control-Ô¨Çow analysis, static memory access, and FuzzBALL
to Ô¨Ånd test cases for buffer overÔ¨Çow vulnerabilities in binaries,
using the results of static analysis to guide FuzzBALL‚Äôs search
toward potential vulnerabilities. Martignoni et al. [7] used
FuzzBALL to generate high-coverage test cases for CPU em-
ulators, illustrating how exhaustive exploration is feasible for
small but critical code sequences. Caselden et al. [6] combined
dynamic data-structure analysis and FuzzBALL to produce
proof-of-concept exploits for vulnerabilities that are reached
only after complex transformations of a program‚Äôs input, using
novel pruning and choice heuristics to efÔ¨Åciently Ô¨Ånd inverse
images of transformations such as data compression.
For FUZZBOMB and the CGC, we integrated FuzzBALL
with the FUZZBUSTER reasoning framework and signiÔ¨Åcantly
extended FuzzBALL‚Äôs program analysis capabilities.
III. NEW DEVELOPMENTS
A. Hierarchical Architecture
We designed FUZZBOMB to operate on our in-house cluster
of up to 20 Dell Poweredge C6100 blade chassis, each holding
eight Intel XEON Harpertown quad-core CPUs. To allocate
this rack of computers, we designed a hierarchical command-
and-control scheme in which different FUZZBOMB agents play
different roles. At the top of the hierarchy, several agents are
designated as ‚ÄúOptimus‚Äù, or leader agents. At any time, one is
the primary leader, known as Optimus Prime (OP). All of the
other Optimi are ‚Äúhot backups,‚Äù in case OP goes down for any
reason (hardware failure, software crash, network isolation).
All messages sent to OP are also sent to all of the other
Optimi, so that their knowledge is kept up to date at all times.
We enhanced our existing fault detection and leader election
protocol methods to ensure that an OP is active in the cluster
with very high reliability. Fault detection methods include
monitoring communication channels (sockets) for failure and
watchdog processes that send periodic messages to ensure
liveness. The Optimi are given unique integer identiÔ¨Åers,
and the next-in-order Optimus becomes Prime if the prior
OP is determined to have failed; handshake messages ensure
that the other Optimi agree on the new OP selection. We
usually conÔ¨Ågure FUZZBOMB with three Optimi, each run on
a different hardware chassis in the cluster.
Below OP, a set of ‚ÄúFUZZBOMB-Master‚Äù agents are des-
ignated, each to manage the reasoning about a single CB.
OP‚Äôs main job is allocating CBs to those Master agents and
giving them each additional resources (other FUZZBOMBS,
DVMs) to use to improve their score on a CB. A FUZZBOMB-
Master‚Äôs job is improve its score on its designated CB, using
its allocated computing resources in the best way possible
(whether that is analysis, rewriting, or testing/scoring). As
progress is made on each CB, the responsible FUZZBOMB-
Master will report that progress and the best-revised-CB-so-far
back to OP.
OP‚Äôs objective is to maximize the system‚Äôs overall score,
keeping in mind deadlines and other considerations. By design,
OP should dynamically re-allocate the reasoning assets to the
most challenging problems, to maximize the overall system‚Äôs
score. OP is also responsible for uploading FUZZBOMB‚Äôs Ô¨Ånal
best answers to the government-supplied response location.
B. FuzzBALL Improvements
FUZZBOMB uses an improved FuzzBALL symbolic execu-
tion engine in an approach that combines ideas from symbolic
execution and static analysis in order to Ô¨Ånd vulnerabilities in
binary programs. A static-style analysis identiÔ¨Åes parts of the
program that might contain a vulnerability. Then a symbolic
execution search seeks an execution path from the start of the
program to the possible vulnerability point that constitutes a
proof of vulnerability. Symbolic execution generates a number
of input constraint sets, each set representing a family of
related program execution paths. The symbolic execution
engine uses these constraint sets to determine the inputs to the
program that can reach the program vulnerability, offering a
proof-of-concept exploit. While exploring this space, the sym-
bolic execution engine will encounter many decision points
(such as conditional branches). Each of these decision points
branches off a new set of paths, leading to an exponentially
growing number of paths. Exploring this search space of
paths represents a signiÔ¨Åcant computational effort. Scaling
up the search in a way that mitigates this path explosion
poses a key challenge. To overcome this problem, we applied
parallelization techniques and heuristic search improvements,
as well as other algorithmic changes.
1) Heuristic Guidance: Because the space of program
executions is vast, even in the constraint-based representations
of symbolic reasoning, heuristic guidance is essential. For the
CGC, the key objective is to guide the search towards potential
vulnerabilities. FUZZBOMB identiÔ¨Åes potentially vulnerable
instruction sequences and uses abstraction heuristics to focus
the search towards those targets. Although a wide variety of
source-level coding mistakes can leave a program vulnerable,
these dangerous constructs are more uniform when viewed in
terms of the binary-level capability they give to an attacker.
For example, many types of source-code vulnerabilities create
binary code in which the destination of an indirect jump
instruction can be inÔ¨Çuenced by an attacker. The source-code
and compiler details about why such a controllable jump
arises are often irrelevant, and are not our focus. In particular,
FUZZBOMB does not try to decompile a binary back to a
source language, nor will it identify which particular source
code Ô¨Çaw describes a vulnerability. FUZZBOMB‚Äôs search guid-
ance strategies target just these end-result capabilities; e.g.,
searching for an indirect jump that can be controlled to lead
to attack code.
FUZZBOMB uses problem relaxation heuristics to reduce
the search space of possible executions, drawing on recent
advances in heuristic search techniques for directed symbolic
execution and ArtiÔ¨Åcial Intelligence (AI) planning. To search
through very large spaces, these techniques use rapid solutions
to relaxed or approximate versions of their real problems to
provide heuristic guidance. Over the last dozen years, research
on relaxation heuristics has produced immense improvements
in the scalability of AI planning and other techniques (e.g.,

115
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
[16], [17]). For example, Edelkamp et al. [16] report up to four
orders of magnitude reduction in nodes searched in model-
checking. Similarly, AI planning systems have gone from
producing plans with no more than 15 steps to plans with
hundreds of steps (representing many orders of magnitude
improvement in space searched). These techniques are only
now being applied to directed symbolic execution to help Ô¨Ånd
program paths to vulnerabilities (e.g., Ma et al. [18]).
For FUZZBOMB, the problem is to Ô¨Ånd a symbolic execu-
tion path through a program that leads to a vulnerability. One
key research challenge is Ô¨Ånding the best relaxation method
for symbolic execution domains. We developed an approach
using causal graph heuristics found in AI planning search [19]
to direct symbolic execution, in a manner similar to call-
chain backwards symbolic execution [18]. These heuristics use
factorization to generate a causal model of subproblems, then
‚Äúabstract away‚Äù interactions between the subproblems to create
a relaxed version of the problem that can be solved quickly
at each decision point during search. In symbolic execution,
solving the relaxed problem determines:
‚Ä¢ A reachability analysis to a vulnerability. If the relaxation
of the program indicates a vulnerability is unreachable
from a particular program decision point, then exploring
from that point is fruitless.
‚Ä¢ A distance estimate at each decision point, that lets
exploration proceed along an estimated shortest path.
To generate the relaxation heuristic, FUZZBOMB uses the
causal model present within data-Ô¨Çow and control-Ô¨Çow graph
(CFG) structures used in binary program analysis. For in-
stance, in a CFG, nodes represent blocks of code and edges
represent execution order. This provides a subproblem struc-
ture, allowing for bottom-up solving of each subproblem.
The FuzzBALL approach to hybrid symbolic execution and
static analysis needed many other improvements to work on
the CGC CBs. Our major developments have included:
‚Ä¢ Porting to Decree‚Äî We adapted FuzzBALL to handle
the unique CB format, including emulating the restricted
Decree system calls and handling the speciÔ¨Åc limitations
of the CB binary format.
‚Ä¢ Improving over-approximated CFG methods‚Äî Prior to
symbolic analysis, FuzzBALL requires the control Ô¨Çow
graph (CFG) of the target binary. Various existing meth-
ods are all imperfect at recovering CFGs, but some can
be combined. We developed a new CFG-recovery tool
that leverages prior work on recursive disassembly along
with an updated over-approximation method that Ô¨Ånds
all of the bit sequences in a binary representing valid
addresses/offsets within the binary and treats those as
possible jump targets. While this overapproximation is
extreme, FUZZBOMB uses heuristics to reduce the size
of the resulting CFGs.
‚Ä¢ Detecting input-controllable jumps‚Äî As FuzzBALL ex-
tends branch conditions forward through the possible pro-
gram executions, whenever it reaches a jump it formulates
an SMT query asking whether the CB inputs could force
the jump to 42 (i.e., an arbitrary address). If so, a likely
vulnerability has been identiÔ¨Åed.
‚Ä¢ Detecting null pointer dereferences, return address over-
writes, etc.‚Äî FuzzBALL now uses similar methods to
detect various other vulnerable behaviors.
‚Ä¢ Making incremental solver calls‚Äî We have enhanced
FuzzBALL‚Äôs SMT solver interface so that it can behave
incrementally. For example, after querying if a jump
target is input-controllable, it can retract that Ô¨Ånal part
of the SMT query and the SMT solver can retain some
information it derived during the prior solver call. Mi-
crosoft‚Äôs Z3 SMT solver is state of the art and supports
this type of incremental behavior.
‚Ä¢ Handling
SSE
Ô¨Çoating
point
(FP)‚Äî
The
original
FuzzBALL implementation used a slow, emulation-based
method to handle Ô¨Çoating point calculations, and it
could not handle the modern SSE FP instructions. We
have recently completed major extensions that allow
FuzzBALL to handle SSE FP instructions using Z3. We
have switched over to using Z3 by default, and are
collaborating with both the Z3 and MathSAT5 developers
to Ô¨Åx bugs in their solvers and improve their performance.
‚Ä¢ Implementing
veritesting‚Äî
David
Brumley‚Äôs
group
coined this term for a Ô¨Çexible combination of dynamic
symbolic execution (DSE) and static symbolic execution
(SSE) used to reason in bulk about blocks of code that
do not need DSE [20]. We completed our own Ô¨Årst
version of this capability, along with associated test cases
and SMT heuristic improvements. However, as noted in
Section VI, this improvement was not used during the
actual competition because its testing and validation was
not complete.
Symbolic execution can be expensive because it is com-
pletely precise; this precision ensures that the approach can
always create proofs of vulnerabilities. At the same time, it is
valuable to know about potentially dangerous constructs even
before we can prove they are exploitable. To that end, we
modiÔ¨Åed FuzzBALL to run as a hybrid of static analysis and
symbolic execution techniques.
C. Proofs of Vulnerability (PoVs)
We developed two ways of creating PoVs. First, when
FuzzBALL identiÔ¨Åes a vulnerability that can be triggered by
client inputs, it will have solved a set of constraints on the
symbolic input variables that describe a class of PoVs for that
vulnerability. Depending on the constraints, the PoV descrip-
tion may be more or less abstract (i.e., it may require very
concrete inputs or describe a broad space of inputs that will
trigger the vulnerability). For the concrete case, FUZZBOMB
has a mechanism to translate FuzzBALL‚Äôs constraints into the
XML format required for a PoV.
Second, if a CB is provided with a PCAP Ô¨Åle that illustrates
how it interacts with one or more pollers, FUZZBOMB uses
protocol reverse engineering techniques to derive an abstract
description of the acceptable protocols for a CB. FUZZBOMB
then feeds this protocol description into one or more fuzzing

116
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
tools, to try to develop input XML Ô¨Åles that trigger an
unknown vulnerability.
We initially developed a protocol reverse engineering tool
building on Antunes‚Äô ideas [21]. However, the techniques did
not scale well to the large numbers of pollers present in
the CGC example problems, and they are not robust to the
packet loss present in the provided packet captures. We then
developed a less elaborate protocol analysis tool which, while
not providing a full view of the protocol state machine, allows
FUZZBOMB to generate protocol sessions which are accepted
by the CBs. This tool uses a heuristic approach, based on
observations from prior work in the Ô¨Åeld [22], [23], [24],
to identify likely protocol command elements, Ô¨Åelds required
for data delivery to the CBs (e.g. message lengths and Ô¨Åeld
offsets), and message delimiters. Additionally, the protocol
inference tool also attempts to identify session cookies and
simple challenge/response exchanges that are required by the
protocol. SigniÔ¨Åcant effort was also required to process the
DARPA-provided PCAP Ô¨Åles because they contain unexpected
packet losses and non-TCP-compliant behavior.
IV. BINARY REWRITING
Here we describe background on binary rewriting and
related work to clarify the technical contribution of BINSUR-
GEON, FUZZBOMB‚Äôs binary rewriting subsystem.
A. Control Ô¨Çow graphs
BINSURGEON operates on a binary‚Äôs Control Flow Graph
(CFG) to modify the binary. For the purposes of BINSUR-
GEON, a CFG is comprised of assembly instructions grouped
into blocks with exactly one entry point and one exit point. At
the exit point of any block, the program either (a) transitions to
the entry point of the adjacent block in memory, (b) transitions
the entry point of another block via a control Ô¨Çow instruction
such as jumps or calls, or (c) terminates. These blocks and the
control Ô¨Çows between them comprises the nodes and edges,
respectively, of a directed‚Äî and often cyclic‚Äî graph.
The executable‚Äôs functions are subgraphs of the CFG, often
bounded by called blocks at the source(s) and return blocks
at the sink(s), but exceptions exist, e.g., due to uncalled (or
indirectly called) functions and functions that conclude with
program termination rather than return instructions. To account
for these exceptions, BINSURGEON infers function subgraphs
by searching forward from called blocks and searching back-
ward from return blocks, merging the intersecting block-sets,
and also using common compiler idioms to identify function
prologues and epilogues.
CFGs are recovered by disassembling the binary, which is
a potentially-unsound process, since it is undecidable whether
bytes in a stripped binary correspond to data or code [25], [26].
This means that a smaller rewrite to the CFG is better, all else
being equal, since it relies on less of the potentially-incorrect
subgraph of the CFG.
Figure 4 shows a small CFG snippet of a single function
‚ÄúOriginal Fn‚Äù rewritten by BINSURGEON to produce ‚ÄúPadded
Fn‚Äù and then ‚ÄúCookied Fn,‚Äù as we describe in more detail
func8048445/TRANSMIT
func8048465/RECEIVE
func8048437/_TERMINATE
func8048360
func80481a0
Blk 81 @ 0x80485c1 [5]
inc %edi
andl %ecx, (%edx)
orb (%eax), %al
Blk 80 @ 0x80485bc [5]
inc %ebp
pushl %edx
andb %al, 0x47(%ebp)
default
Blk 79 @ 0x80485aa [18]
insbb
imull $0x656d6f72, 0x64(%esi), %ebp
andl %ecx, (%edx)
orb (%eax), %al
orb (%edx), %cl
inc %ebp
inc %ecx
pushl %ebx
pushl %esp
default
Blk 78 @ 0x80485a6 [4]
popady
andb %dh, 0x61(%eax)
default
Blk 77 @ 0x80485a4 [2]
jnb 0x80485c6
default
Blk 76 @ 0x804859e [6]
andb %dh, 0x61(%eax,%ebp,2)
jz 0x80485cb
default
Blk 75 @ 0x8048589 [21]
popady
andb %dh, 0x61(%eax)
insbb
imull $0x656d6f72, 0x64(%esi), %ebp
orb (%edx), %cl
addb %cl, (%ecx)
orl %ebx, 0x65(%ecx)
jnb 0x80485ca
default
Blk 74 @ 0x8048585 [4]
outsbb
outsdl
jz 0x80485a9
default
Blk 73 @ 0x8048583 [2]
jnb 0x80485a5
default
Blk 72 @ 0x8048580 [3]
popady
jz 0x80485aa
jz
default
Blk 71 @ 0x804857e [2]
jz 0x80485e8
default
Blk 70 @ 0x804857c [2]
sub $0x20, %al
default
Blk 69 @ 0x8048564 [24]
imull $0x61702065, 0x6c(%edx), %esp
insbb
imull $0x656d6f72, 0x64(%esi), %ebp
cmpb (%eax), %ah
addb %cl, (%ecx)
orl %ecx, 0x6f(%esi)
jo 0x80485e1
default
Blk 68 @ 0x804855e [6]
popady
andb %dh, 0x6f(%eax)
jnb 0x80485d7
default
Blk 67 @ 0x804855c [2]
jb 0x804857e
jb
default
Blk 66 @ 0x8048557 [5]
andb %ah, 0x6e(%ebp)
jz 0x80485c1
jz
default
jnb
default
Blk 63 @ 0x8048353 [13]
data16 nop
data16 nop
data16 nop
data16 nop
data16 nop
data16 nop
nop
Blk 16 @ 0x8048360 [52]
pushl %ebp
mov %esp, %ebp
pushl %esi
sub $0x34, %esp
movl 0x10(%ebp), %eax
movl 0xc(%ebp), %ecx
movl 0x8(%ebp), %edx
movl %edx, -0xc(%ebp)
movl %ecx, -0x10(%ebp)
movl %eax, -0x14(%ebp)
movl $0x0, -0x18(%ebp)
movl $0x0, -0x1c(%ebp)
cmpl $0x0, -0x10(%ebp)
jnz 0x80483a0
default
Blk 62 @ 0x8048191 [15]
nopw %ax, %cs:(%eax,%eax,1)
Blk 61 @ 0x80481a0 [31]
pushl %ebp
mov %esp, %ebp
pushl %esi
sub $0x84, %esp
movl $0xffffffff, -0xc(%ebp)
movl $0x1, -0x14(%ebp)
movl $0x0, -0x10(%ebp)
default
Blk 32 @ 0x8048437 [14]
mov $0x1, %eax
pushl %ebx
movl 0x8(%esp), %ebx
int $0x80
popl %ebx
retl
calll
default
movl %edx, -0x10(%ebp)
calll 0x8048360
Blk 51 @ 0x8048445 [32]
mov $0x2, %eax
pushl %ebx
pushl %ecx
pushl %edx
pushl %esi
movl 0x14(%esp), %ebx
movl 0x18(%esp), %ecx
movl 0x1c(%esp), %edx
movl 0x20(%esp), %esi
int $0x80
popl %esi
popl %edx
popl %ecx
popl %ebx
retl
Blk 1 @ 0x8048465 [32]
mov $0x3, %eax
pushl %ebx
pushl %ecx
pushl %edx
pushl %esi
movl 0x14(%esp), %ebx
movl 0x18(%esp), %ecx
movl 0x1c(%esp), %edx
movl 0x20(%esp), %esi
int $0x80
popl %esi
popl %edx
popl %ecx
popl %ebx
retl
Blk 39 @ 0x804852c 
movl %ecx, (%esp)
retl
default
Blk 21 @ 0x8048394 [12]
movl $0x1, -0x8(%ebp)
jmp 0x8048423
default
Blk 29 @ 0x80483a0 [13]
cmpl $0x0, -0x14(%ebp)
jnz 0x80483b9
jnz
Blk 25 @ 0x8048423 [9]
movl -0x8(%ebp), %eax
add $0x34, %esp
popl %esi
popl %ebp
retl
jmp
Blk 17 @ 0x80483ad [12]
movl $0x2, -0x8(%ebp)
jmp 0x8048423
default
Blk 7 @ 0x80483b9 [5]
jmp 0x80483be
jnz
jmp
Blk 41 @ 0x80483be [12]
movl -0x18(%ebp), %eax
cmpl -0x14(%ebp), %eax
jnb 0x804841c
jmp
Blk 54 @ 0x80483ca [38]
lea -0x1c(%ebp), %eax
movl -0xc(%ebp), %ecx
movl -0x10(%ebp), %edx
addl -0x18(%ebp), %edx
movl -0x14(%ebp), %esi
subl -0x18(%ebp), %esi
movl %ecx, (%esp)
movl %edx, 0x4(%esp)
movl %esi, 0x8(%esp)
movl %eax, 0xc(%esp)
calll 0x8048445
default
Blk 4 @ 0x804841c [7]
movl $0x0, -0x8(%ebp)
jnb
calll
Blk 0 @ 0x80483f0 [16]
movl %eax, -0x20(%ebp)
cmpl $0x0, -0x20(%ebp)
jz 0x804840c
default
Blk 55 @ 0x8048400 [12]
movl $0x3, -0x8(%ebp)
jmp 0x8048423
default
Blk 34 @ 0x804840c [16]
movl -0x1c(%ebp), %eax
movl -0x18(%ebp), %ecx
add %eax, %ecx
movl %ecx, -0x18(%ebp)
jmp 0x80483be
jz
jmp
jmp
default
calll
Blk 52 @ 0x80480bb [3]
movl %eax, -0x14(%ebp)
default
Blk 26 @ 0x80480be [46]
mov $0x1, %eax
lea 0x8048550, %ecx
mov $0x25, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x25, 0x8(%esp)
movl %eax, -0x18(%ebp)
movl %edx, -0x1c(%ebp)
calll 0x8048360
default
calll
Blk 53 @ 0x80480ec [8]
movl %eax, -0x20(%ebp)
calll 0x80481a0
default
Blk 2 @ 0x80480f4 [16]
movl %eax, -0x8(%ebp)
cmpl $0xffffffff, -0x8(%ebp)
jnz 0x8048109
default
calll
Blk 40 @ 0x8048104 [5]
jmp 0x8048187
default
Blk 10 @ 0x8048109 [13]
cmpl $0x0, -0x8(%ebp)
jnz 0x804814c
jnz
Blk 30 @ 0x8048187 [10]
mov $0x0, %eax
add $0x48, %esp
popl %ebp
retl
jmp
Blk 18 @ 0x8048116 [46]
mov $0x1, %eax
lea 0x8048576, %ecx
mov $0x21, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x21, 0x8(%esp)
movl %eax, -0x24(%ebp)
movl %edx, -0x28(%ebp)
calll 0x8048360
default
Blk 57 @ 0x804814c [46]
mov $0x1, %eax
lea 0x8048598, %ecx
mov $0x1d, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x1d, 0x8(%esp)
movl %eax, -0x30(%ebp)
movl %edx, -0x34(%ebp)
calll 0x8048360
jnz
calll
Blk 46 @ 0x8048144 [8]
movl %eax, -0x2c(%ebp)
jmp 0x804817d
default
Blk 45 @ 0x804817d [5]
jmp 0x8048182
jmp
calll
Blk 44 @ 0x804817a [3]
movl %eax, -0x38(%ebp)
default
default
Blk 3 @ 0x8048182 [5]
jmp 0x80480be
jmp
jmp
Blk 36 @ 0x80481bf [13]
cmpl $0x40, -0x10(%ebp)
jnb 0x80481e4
default
Blk 27 @ 0x80481cc [24]
movl -0x10(%ebp), %eax
movb $0x0, -0x54(%ebp,%eax,1)
movl -0x10(%ebp), %eax
add $0x1, %eax
movl %eax, -0x10(%ebp)
jmp 0x80481bf
default
Blk 8 @ 0x80481e4 [50]
mov $0x0, %eax
mov $0x80, %ecx
lea -0x58(%ebp), %edx
lea -0x54(%ebp), %esi
movl $0x0, (%esp)
movl %esi, 0x4(%esp)
movl $0x80, 0x8(%esp)
movl %edx, 0xc(%esp)
movl %eax, -0x60(%ebp)
movl %ecx, -0x64(%ebp)
calll 0x8048465
jnb
jmp
calll
Blk 20 @ 0x8048216 [11]
cmp $0x0, %eax
jnz 0x804822e
default
Blk 49 @ 0x8048221 [13]
cmpl $0x0, -0x58(%ebp)
jnz 0x804823a
default
Blk 11 @ 0x804822e [12]
movl $0xffffffff, -0x8(%ebp)
jmp 0x8048347
jnz
default
Blk 9 @ 0x804823a [7]
movl $0x0, -0x10(%ebp)
jnz
Blk 15 @ 0x8048347 [12]
movl -0x8(%ebp), %eax
add $0x84, %esp
popl %esi
popl %ebp
retl
jmp
Blk 58 @ 0x8048241 [19]
movl -0x10(%ebp), %eax
movsxb -0x54(%ebp,%eax,1), %eax
cmp $0x0, %eax
jz 0x804826f
default
Blk 13 @ 0x8048254 [27]
movl -0xc(%ebp), %eax
add $0x1, %eax
movl %eax, -0xc(%ebp)
movl -0x10(%ebp), %eax
add $0x1, %eax
movl %eax, -0x10(%ebp)
jmp 0x8048241
default
Blk 5 @ 0x804826f [37]
mov $0x2, %eax
movl -0xc(%ebp), %ecx
movl %ecx, -0x5c(%ebp)
movl -0xc(%ebp), %ecx
movl %eax, -0x68(%ebp)
mov %ecx, %eax
cdq 
movl -0x68(%ebp), %ecx
idiv %ecx
cmp $0x1, %edx
jnz 0x804829f
jz
jmp
Blk 22 @ 0x8048294 [11]
movl -0x5c(%ebp), %eax
add $0xffffffff, %eax
movl %eax, -0x5c(%ebp)
default
Blk 19 @ 0x804829f [7]
movl $0x0, -0x10(%ebp)
jnz
default
Blk 47 @ 0x80482a6 [30]
mov $0x2, %eax
movl -0x10(%ebp), %ecx
movl -0x5c(%ebp), %edx
movl %eax, -0x6c(%ebp)
mov %edx, %eax
cdq 
movl -0x6c(%ebp), %esi
idiv %esi
cmp %eax, %ecx
jnle 0x8048301
default
Blk 24 @ 0x80482c4 [33]
movl -0x10(%ebp), %eax
movsxb -0x54(%ebp,%eax,1), %eax
movl -0xc(%ebp), %ecx
sub $0x1, %ecx
subl -0x10(%ebp), %ecx
movsxb -0x54(%ebp,%ecx,1), %ecx
cmp %ecx, %eax
jz 0x80482ec
default
Blk 28 @ 0x8048301 [15]
movsxb -0x54(%ebp), %eax
cmp $0x5e, %eax
jnz 0x8048341
jnle
Blk 23 @ 0x80482e5 [7]
movl $0x0, -0x14(%ebp)
default
Blk 60 @ 0x80482ec [5]
jmp 0x80482f1
jz
default
Blk 59 @ 0x80482f1 [16]
movl -0x10(%ebp), %eax
add $0x1, %eax
movl %eax, -0x10(%ebp)
jmp 0x80482a6
jmp
jmp
Blk 6 @ 0x8048310 [46]
mov $0x1, %eax
lea 0x80485b6, %ecx
mov $0xf, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0xf, 0x8(%esp)
movl %eax, -0x70(%ebp)
movl %edx, -0x74(%ebp)
calll 0x8048360
default
Blk 14 @ 0x8048341 [6]
movl -0x14(%ebp), %eax
movl %eax, -0x8(%ebp)
jnz
calll
Blk 38 @ 0x804833e [3]
movl %eax, -0x78(%ebp)
default
default
default
func8048465/RECEIVE
func8048437/_TER
func8048360
func80481a0
Blk 81 @ 0x80485c1 [5]
inc %edi
andl %ecx, (%edx)
orb (%eax), %al
Blk 80 @ 0x80485bc [5]
inc %ebp
pushl %edx
andb %al, 0x47(%ebp)
default
Blk 79 @ 0x80485aa [18]
insbb
imull $0x656d6f72, 0x64(%esi), %ebp
andl %ecx, (%edx)
orb (%eax), %al
orb (%edx), %cl
inc %ebp
inc %ecx
pushl %ebx
pushl %esp
default
Blk 78 @ 0x80485a6 [4]
popady
andb %dh, 0x61(%eax)
default
Blk 77 @ 0x80485a4 [2]
jnb 0x80485c6
default
Blk 76 @ 0x804859e [6]
andb %dh, 0x61(%eax,%ebp,2)
jz 0x80485cb
default
Blk 75 @ 0x8048589 [21]
popady
andb %dh, 0x61(%eax)
insbb
imull $0x656d6f72, 0x64(%esi), %ebp
orb (%edx), %cl
addb %cl, (%ecx)
orl %ebx, 0x65(%ecx)
jnb 0x80485ca
default
Blk 74 @ 0x8048585 [4]
outsbb
outsdl
jz 0x80485a9
default
Blk 73 @ 0x8048583 [2]
jnb 0x80485a5
default
Blk 72 @ 0x8048580 [3]
popady
jz 0x80485aa
jz
default
Blk 71 @ 0x804857e [2]
jz 0x80485e8
default
Blk 70 @ 0x804857c [2]
sub $0x20, %al
default
Blk 69 @ 0x8048564 [24]
imull $0x61702065, 0x6c(%edx), %esp
insbb
imull $0x656d6f72, 0x64(%esi), %ebp
cmpb (%eax), %ah
addb %cl, (%ecx)
orl %ecx, 0x6f(%esi)
jo 0x80485e1
default
Blk 68 @ 0x804855e [6]
popady
andb %dh, 0x6f(%eax)
jnb 0x80485d7
default
Blk 67 @ 0x804855c [2]
jb 0x804857e
jb
default
Blk 66 @ 0x8048557 [5]
andb %ah, 0x6e(%ebp)
jz 0x80485c1
jz
default
jnb
default
Blk 63 @ 0x8048353 [13]
data16 nop
data16 nop
data16 nop
data16 nop
data16 nop
data16 nop
nop
Blk 16 @ 0x8048360 [52]
pushl %ebp
mov %esp, %ebp
pushl %esi
sub $0x34, %esp
movl 0x10(%ebp), %eax
movl 0xc(%ebp), %ecx
movl 0x8(%ebp), %edx
movl %edx, -0xc(%ebp)
movl %ecx, -0x10(%ebp)
movl %eax, -0x14(%ebp)
movl $0x0, -0x18(%ebp)
movl $0x0, -0x1c(%ebp)
cmpl $0x0, -0x10(%ebp)
jnz 0x80483a0
default
Blk 62 @ 0x8048191 [15]
nopw %ax, %cs:(%eax,%eax,1)
Blk 61 @ 0x80481a0 [31]
pushl %ebp
mov %esp, %ebp
pushl %esi
sub $0x8c, %esp
movl $0xffffffff, -0x14(%ebp)
movl $0x1, -0x1c(%ebp)
movl $0x0, -0x18(%ebp)
default
Blk 32 @ 0x8048437 [14
mov $0x1, %eax
pushl %ebx
movl 0x8(%esp), %ebx
int $0x80
popl %ebx
retl
calll
default
movl $0x1f, 0x8(%esp)
movl %eax, -0xc(%ebp)
movl %edx, -0x10(%ebp)
calll 0x8048360
Blk 1 @ 0x8048465 [32]
mov $0x3, %eax
pushl %ebx
pushl %ecx
pushl %edx
pushl %esi
movl 0x14(%esp), %ebx
movl 0x18(%esp), %ecx
movl 0x1c(%esp), %edx
movl 0x20(%esp), %esi
int $0x80
popl %esi
popl %edx
popl %ecx
popl %ebx
retl
Blk 21 @ 0x8048394 [12]
movl $0x1, -0x8(%ebp)
jmp 0x8048423
default
Blk 29 @ 0x80483a0 [13]
cmpl $0x0, -0x14(%ebp)
jnz 0x80483b9
jnz
Blk 25 @ 0x8048423 [9]
movl -0x8(%ebp), %eax
add $0x34, %esp
popl %esi
popl %ebp
retl
jmp
Blk 17 @ 0x80483ad [12]
movl $0x2, -0x8(%ebp)
jmp 0x8048423
default
Blk 7 @ 0x80483b9 [5]
jmp 0x80483be
jnz
jmp
Blk 41 @ 0x80483be [12]
movl -0x18(%ebp), %eax
cmpl -0x14(%ebp), %eax
jnb 0x804841c
jmp
Blk 54 @ 0x80483ca [38]
lea -0x1c(%ebp), %eax
movl -0xc(%ebp), %ecx
movl -0x10(%ebp), %edx
addl -0x18(%ebp), %edx
movl -0x14(%ebp), %esi
subl -0x18(%ebp), %esi
movl %ecx, (%esp)
movl %edx, 0x4(%esp)
movl %esi, 0x8(%esp)
movl %eax, 0xc(%esp)
calll 0x8048445
default
Blk 4 @ 0x804841c [7]
movl $0x0, -0x8(%ebp)
jnb
Blk 0 @ 0x80483f0 [16]
movl %eax, -0x20(%ebp)
cmpl $0x0, -0x20(%ebp)
jz 0x804840c
default
Blk 55 @ 0x8048400 [12]
movl $0x3, -0x8(%ebp)
jmp 0x8048423
default
Blk 34 @ 0x804840c
movl -0x1c(%ebp), 
movl -0x18(%ebp), 
add %eax, %ecx
movl %ecx, -0x18(%
jmp 0x80483be
jz
jmp
jmp
default
calll
Blk 52 @ 0x80480bb [3]
movl %eax, -0x14(%ebp)
default
Blk 26 @ 0x80480be [46]
mov $0x1, %eax
lea 0x8048550, %ecx
mov $0x25, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x25, 0x8(%esp)
movl %eax, -0x18(%ebp)
movl %edx, -0x1c(%ebp)
calll 0x8048360
default
calll
Blk 53 @ 0x80480ec [8]
movl %eax, -0x20(%ebp)
calll 0x80481a0
default
Blk 2 @ 0x80480f4 [16]
movl %eax, -0x8(%ebp)
cmpl $0xffffffff, -0x8(%ebp)
jnz 0x8048109
default
calll
Blk 40 @ 0x8048104 [5]
jmp 0x8048187
default
Blk 10 @ 0x8048109 [13]
cmpl $0x0, -0x8(%ebp)
jnz 0x804814c
jnz
Blk 30 @ 0x8048187 [10]
mov $0x0, %eax
add $0x48, %esp
popl %ebp
retl
jmp
Blk 18 @ 0x8048116 [46]
mov $0x1, %eax
lea 0x8048576, %ecx
mov $0x21, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x21, 0x8(%esp)
movl %eax, -0x24(%ebp)
movl %edx, -0x28(%ebp)
calll 0x8048360
default
Blk 57 @ 0x804814c [46]
mov $0x1, %eax
lea 0x8048598, %ecx
mov $0x1d, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x1d, 0x8(%esp)
movl %eax, -0x30(%ebp)
movl %edx, -0x34(%ebp)
calll 0x8048360
jnz
calll
Blk 46 @ 0x8048144 [8]
movl %eax, -0x2c(%ebp)
jmp 0x804817d
default
Blk 45 @ 0x804817d [5]
jmp 0x8048182
jmp
calll
Blk 44 @ 0x804817a [3]
movl %eax, -0x38(%ebp)
default
default
Blk 3 @ 0x8048182 [5]
jmp 0x80480be
jmp
jmp
Blk 36 @ 0x80481bf [13]
cmpl $0x40, -0x18(%ebp)
nop 
nop 
nop 
jnb 0x80481e4
default
Blk 27 @ 0x80481cc [24]
movl -0x18(%ebp), %eax
movb $0x0, -0x5c(%ebp,%eax,1)
movl -0x18(%ebp), %eax
add $0x1, %eax
movl %eax, -0x18(%ebp)
jmp 0x80481bf
default
Blk 8 @ 0x80481e4 [50]
mov $0x0, %eax
mov $0x80, %ecx
lea -0x60(%ebp), %edx
lea -0x5c(%ebp), %esi
movl $0x0, (%esp)
movl %esi, 0x4(%esp)
movl $0x80, 0x8(%esp)
movl %edx, 0xc(%esp)
movl %eax, -0x68(%ebp)
movl %ecx, -0x6c(%ebp)
calll 0x8048465
jnb
jmp
calll
Blk 20 @ 0x8048216 [11]
cmp $0x0, %eax
jnz 0x804822e
default
Blk 49 @ 0x8048221 [13]
cmpl $0x0, -0x60(%ebp)
nop 
nop 
nop 
jnz 0x804823a
default
Blk 11 @ 0x804822e [12]
movl $0xffffffff, -0x10(%ebp)
jmp 0x8048347
jnz
default
Blk 9 @ 0x804823a [7]
movl $0x0, -0x18(%ebp)
jnz
Blk 15 @ 0x8048347 [12]
movl -0x10(%ebp), %eax
add $0x8c, %esp
popl %esi
popl %ebp
retl
jmp
Blk 58 @ 0x8048241 [19]
movl -0x18(%ebp), %eax
movsxb -0x5c(%ebp,%eax,1), %eax
cmp $0x0, %eax
jz 0x804826f
default
Blk 13 @ 0x8048254 [27]
movl -0x14(%ebp), %eax
add $0x1, %eax
movl %eax, -0x14(%ebp)
movl -0x18(%ebp), %eax
add $0x1, %eax
movl %eax, -0x18(%ebp)
jmp 0x8048241
default
Blk 5 @ 0x804826f [37]
mov $0x2, %eax
movl -0x14(%ebp), %ecx
movl %ecx, -0x64(%ebp)
movl -0x14(%ebp), %ecx
movl %eax, -0x70(%ebp)
mov %ecx, %eax
cdq 
movl -0x70(%ebp), %ecx
idiv %ecx
cmp $0x1, %edx
jnz 0x804829f
jz
jmp
Blk 22 @ 0x8048294 [11]
movl -0x64(%ebp), %eax
add $0xffffffff, %eax
movl %eax, -0x64(%ebp)
default
Blk 19 @ 0x804829f [7]
movl $0x0, -0x18(%ebp)
jnz
default
Blk 47 @ 0x80482a6 [30]
mov $0x2, %eax
movl -0x18(%ebp), %ecx
movl -0x64(%ebp), %edx
movl %eax, -0x74(%ebp)
mov %edx, %eax
cdq 
movl -0x74(%ebp), %esi
idiv %esi
cmp %eax, %ecx
jnle 0x8048301
default
Blk 24 @ 0x80482c4 [33]
movl -0x18(%ebp), %eax
movsxb -0x5c(%ebp,%eax,1), %eax
movl -0x14(%ebp), %ecx
sub $0x1, %ecx
subl -0x18(%ebp), %ecx
movsxb -0x5c(%ebp,%ecx,1), %ecx
cmp %ecx, %eax
jz 0x80482ec
default
Blk 28 @ 0x8048301 [15]
movsxb -0x5c(%ebp), %eax
cmp $0x5e, %eax
jnz 0x8048341
jnle
Blk 23 @ 0x80482e5 [7]
movl $0x0, -0x1c(%ebp)
default
Blk 60 @ 0x80482ec [5]
jmp 0x80482f1
jz
default
Blk 59 @ 0x80482f1 [16]
movl -0x18(%ebp), %eax
add $0x1, %eax
movl %eax, -0x18(%ebp)
jmp 0x80482a6
jmp
jmp
Blk 6 @ 0x8048310 [46]
mov $0x1, %eax
lea 0x80485b6, %ecx
mov $0xf, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0xf, 0x8(%esp)
movl %eax, -0x78(%ebp)
movl %edx, -0x7c(%ebp)
calll 0x8048360
default
Blk 14 @ 0x8048341 [6]
movl -0x1c(%ebp), %eax
movl %eax, -0x10(%ebp)
jnz
calll
Blk 38 @ 0x804833e [3]
movl %eax, -0x80(%ebp)
default
default
default
func8048080
func8048437/_TERMINATE
func8048465/RECEIVE
func8048360
func804611e
Blk 98 @ 0x80485c1 [5]
inc %edi
andl %ecx, (%edx)
orb (%eax), %al
Blk 97 @ 0x80485bc [5]
inc %ebp
pushl %edx
andb %al, 0x47(%ebp)
default
Blk 96 @ 0x80485aa [18]
insbb
imull $0x656d6f72, 0x64(%esi), %ebp
andl %ecx, (%edx)
orb (%eax), %al
orb (%edx), %cl
inc %ebp
inc %ecx
pushl %ebx
pushl %esp
default
Blk 95 @ 0x80485a6 [4]
popady
andb %dh, 0x61(%eax)
default
Blk 94 @ 0x80485a4 [2]
jnb 0x80485c6
default
Blk 93 @ 0x804859e [6]
andb %dh, 0x61(%eax,%ebp,2)
jz 0x80485cb
default
Blk 92 @ 0x8048589 [21]
popady
andb %dh, 0x61(%eax)
insbb
imull $0x656d6f72, 0x64(%esi), %ebp
orb (%edx), %cl
addb %cl, (%ecx)
orl %ebx, 0x65(%ecx)
jnb 0x80485ca
default
Blk 91 @ 0x8048585 [4]
outsbb
outsdl
jz 0x80485a9
default
Blk 90 @ 0x8048583 [2]
jnb 0x80485a5
default
Blk 89 @ 0x8048580 [3]
popady
jz 0x80485aa
jz
default
Blk 88 @ 0x804857e [2]
jz 0x80485e8
default
Blk 87 @ 0x804857c [2]
sub $0x20, %al
default
Blk 86 @ 0x8048564 [24]
imull $0x61702065, 0x6c(%edx), %esp
insbb
imull $0x656d6f72, 0x64(%esi), %ebp
cmpb (%eax), %ah
addb %cl, (%ecx)
orl %ecx, 0x6f(%esi)
jo 0x80485e1
default
Blk 85 @ 0x804855e [6]
popady
andb %dh, 0x6f(%eax)
jnb 0x80485d7
default
Blk 84 @ 0x804855c [2]
jb 0x804857e
jb
default
Blk 83 @ 0x8048557 [5]
andb %ah, 0x6e(%ebp)
jz 0x80485c1
jz
default
Blk 82 @ 0x804854e [9]
orb (%eax), %al
orl %edx, 0x6c(%eax)
popady
jnb 0x80485bc
jnb
default
Blk 51 @ 0x8048360
pushl %ebp
mov %esp, %ebp
pushl %esi
sub $0x34, %esp
movl 0x10(%ebp), %
movl 0xc(%ebp), %e
movl 0x8(%ebp), %e
movl %edx, -0xc(%e
movl %ecx, -0x10(%
movl %eax, -0x14(%
movl $0x0, -0x18(%
movl $0x0, -0x1c(%
cmpl $0x0, -0x10(%
jnz 0x80483a0
Blk 77 @ 0x8048191 [15]
nopw %ax, %cs:(%eax,%eax,1)
Blk 43 @ 0x80481a0 [5]
jmp 0x80481a5
default
Blk 3 @ 0x8048080 [59
pushl %ebp
mov %esp, %ebp
sub $0x48, %esp
mov $0x1, %eax
lea 0x8048530, %ecx
mov $0x1f, %edx
movl $0x0, -0x4(%ebp)
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x1f, 0x8(%esp)
movl %eax, -0xc(%ebp)
movl %edx, -0x10(%ebp
calll 0x8048360
Blk 59 @ 0x8048437 [14]
mov $0x1, %eax
pushl %ebx
movl 0x8(%esp), %ebx
int $0x80
popl %ebx
retl
calll
Blk 60 @ 0x80480bb [3
movl %eax, -0x14(%ebp
default
Blk 73 @ 0x80480be [46
mov $0x1, %eax
lea 0x8048550, %ecx
mov $0x25, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x25, 0x8(%esp)
movl %eax, -0x18(%ebp)
movl %edx, -0x1c(%ebp)
calll 0x8048360
default
Blk 25 @ 0x80480ec [8]
movl %eax, -0x20(%ebp)
calll 0x80481a0
default
Blk 38 @ 0x80480f4 [16]
movl %eax, -0x8(%ebp)
cmpl $0xffffffff, -0x8(%ebp)
jnz 0x8048109
default
calll
Blk 57 @ 0x8048104 [5]
jmp 0x8048187
default
Blk 23 @ 0x8048109 [13]
cmpl $0x0, -0x8(%ebp)
jnz 0x804814c
jnz
Blk 29 @ 0x8048187 [10]
mov $0x0, %eax
add $0x48, %esp
popl %ebp
retl
jmp
Blk 41 @ 0x8048116 [46]
mov $0x1, %eax
lea 0x8048576, %ecx
mov $0x21, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x21, 0x8(%esp)
movl %eax, -0x24(%ebp)
movl %edx, -0x28(%ebp)
calll 0x8048360
default
Blk 54 @ 0x804814c [46]
mov $0x1, %eax
lea 0x8048598, %ecx
mov $0x1d, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0x1d, 0x8(%esp)
movl %eax, -0x30(%ebp)
movl %edx, -0x34(%ebp)
calll 0x8048360
jnz
Blk 75 @ 0x8048144 [8]
movl %eax, -0x2c(%ebp)
jmp 0x804817d
default
Blk 21 @ 0x804817d [5]
jmp 0x8048182
jmp
Blk 61 @ 0x804817a [3]
movl %eax, -0x38(%ebp)
default
calll
default
Blk 22 @ 0x8048182 [5]
jmp 0x80480be
jmp
Blk 17 @ 0x8048465 [32]
mov $0x3, %eax
pushl %ebx
pushl %ecx
pushl %edx
pushl %esi
movl 0x14(%esp), %ebx
movl 0x18(%esp), %ecx
movl 0x1c(%esp), %edx
movl 0x20(%esp), %esi
int $0x80
popl %esi
popl %edx
popl %ecx
popl %ebx
retl
Blk 11 @ 0x804839
movl $0x1, -0x8(%e
jmp 0x8048423
default
Blk 24 @ 0x80483a0 [13]
cmpl $0x0, -0x14(%ebp)
jnz 0x80483b9
jnz
Blk 55 @ 0x8048423 [9]
movl -0x8(%ebp), %eax
add $0x34, %esp
popl %esi
popl %ebp
retl
Blk 14 @ 0x80483ad [12]
movl $0x2, -0x8(%ebp)
jmp 0x8048423
default
Blk 39 @ 0x80483b9 [5]
jmp 0x80483be
jnz
jmp
Blk 74 @ 0x80483be [12]
movl -0x18(%ebp), %eax
cmpl -0x14(%ebp), %eax
jnb 0x804841c
jmp
Blk 62 @ 0x80483ca [38]
lea -0x1c(%ebp), %eax
movl -0xc(%ebp), %ecx
movl -0x10(%ebp), %edx
addl -0x18(%ebp), %edx
movl -0x14(%ebp), %esi
subl -0x18(%ebp), %esi
movl %ecx, (%esp)
movl %edx, 0x4(%esp)
movl %esi, 0x8(%esp)
movl %eax, 0xc(%esp)
calll 0x8048445
default
Blk 44 @ 0x804841c [7]
movl $0x0, -0x8(%ebp)
jnb
Blk 12 @ 0x80483f0 
movl %eax, -0x20(%eb
cmpl $0x0, -0x20(%eb
jz 0x804840c
default
Blk 46 @ 0x8048400 
movl $0x3, -0x8(%ebp
jmp 0x8048423
default
Blk 45 @ 0x804840c [16]
movl -0x1c(%ebp), %eax
movl -0x18(%ebp), %ecx
add %eax, %ecx
movl %ecx, -0x18(%ebp)
jmp 0x80483be
jz
jmp
jmp
default
Blk 58 @ 0x804611e [5]
calll 0x8048437
calll
Blk 76 @ 0x8046123 [10]
popl %eax
cmp $0x0, %eax
jnz 0x804822e
default
Blk 53 @ 0x804612d [5]
jmp 0x8048221
default
Blk 28 @ 0x804822e [12]
movl $0xffffffff, -0x10(%ebp)
jmp 0x8048347
jnz
Blk 19 @ 0x8048221 [13]
cmpl $0x0, -0x60(%ebp)
nop 
nop 
nop 
jnz 0x804823a
jmp
Blk 70 @ 0x8046132 [46]
mov $0x1, %eax
lea 0x80485b6, %ecx
mov $0xf, %edx
movl $0x1, (%esp)
movl %ecx, 0x4(%esp)
movl $0xf, 0x8(%esp)
movl %eax, -0x78(%ebp)
movl %edx, -0x7c(%ebp)
calll 0x8048360
calll
Blk 64 @ 0x8046160 [2]
jmp 0x8046162
default
Blk 71 @ 0x8046162 [9]
pushl %eax
movl -0x8(%ebp), %eax
xor $0x16, %eax
jz 0x8046171
jmp
Blk 9 @ 0x804616b [6]
popl %eax
calll 0x8048437
default
Blk 65 @ 0x8046171 [9]
popl %eax
movl %eax, -0x80(%ebp)
jmp 0x8048341
jz
calll
default
Blk 8 @ 0x8048341 [6]
movl -0x1c(%ebp), %eax
movl %eax, -0x10(%ebp)
jmp
Blk 30 @ 0x804617a [19]
movl -0x10(%ebp), %eax
add $0x8c, %esp
popl %esi
pushl %eax
movl -0x8(%ebp), %eax
xor $0x16, %eax
jz 0x8046193
Blk 47 @ 0x804618d [6]
popl %eax
calll 0x8048437
default
Blk 18 @ 0x8046193 [3]
popl %eax
popl %ebp
retl
jz
calll
default
Blk 40 @ 0x80481a5 [22]
pushl %ebp
mov %esp, %ebp
movl $0x16, -0x8(%ebp)
pushl %esi
sub $0x8c, %esp
jmp 0x8048315
jmp
Blk 7 @ 0x8048315 [26]
movl $0xffffffff, -0x14(%ebp)
movl $0x1, -0x1c(%ebp)
movl $0x0, -0x18(%ebp)
jmp 0x80481bf
jmp
Blk 78 @ 0x80481bb [4]
nop
nop
nop
nop
Blk 35 @ 0x80481bf [13]
cmpl $0x40, -0x18(%ebp)
nop 
nop 
nop 
jnb 0x80481e4
default
Blk 56 @ 0x80481cc [24]
movl -0x18(%ebp), %eax
movb $0x0, -0x5c(%ebp,%eax,1)
movl -0x18(%ebp), %eax
add $0x1, %eax
movl %eax, -0x18(%ebp)
jmp 0x80481bf
default
Blk 16 @ 0x80481e4 [50]
mov $0x0, %eax
mov $0x80, %ecx
lea -0x60(%ebp), %edx
lea -0x5c(%ebp), %esi
movl $0x0, (%esp)
movl %esi, 0x4(%esp)
movl $0x80, 0x8(%esp)
movl %edx, 0xc(%esp)
movl %eax, -0x68(%ebp)
movl %ecx, -0x6c(%ebp)
calll 0x8048465
jnb
jmp
calll
Blk 52 @ 0x8048216 [5]
jmp 0x804832f
default
Blk 72 @ 0x804832f [13]
pushl %eax
movl -0x8(%ebp), %eax
xor $0x16, %eax
jz 0x8046123
jmp
Blk 79 @ 0x804821b [6]
nop
nop
nop
nop
nop
nop
default
default
Blk 2 @ 0x804823a [7]
movl $0x0, -0x18(%ebp)
jnz
Blk 69 @ 0x8048347 [5]
jmp 0x804617a
jmp
Blk 42 @ 0x8048241 [19]
movl -0x18(%ebp), %eax
movsxb -0x5c(%ebp,%eax,1), %eax
cmp $0x0, %eax
jz 0x804826f
default
Blk 5 @ 0x8048254 [27]
movl -0x14(%ebp), %eax
add $0x1, %eax
movl %eax, -0x14(%ebp)
movl -0x18(%ebp), %eax
add $0x1, %eax
movl %eax, -0x18(%ebp)
jmp 0x8048241
default
Blk 4 @ 0x804826f [37]
mov $0x2, %eax
movl -0x14(%ebp), %ecx
movl %ecx, -0x64(%ebp)
movl -0x14(%ebp), %ecx
movl %eax, -0x70(%ebp)
mov %ecx, %eax
cdq 
movl -0x70(%ebp), %ecx
idiv %ecx
cmp $0x1, %edx
jnz 0x804829f
jz
jmp
Blk 27 @ 0x8048294 [11]
movl -0x64(%ebp), %eax
add $0xffffffff, %eax
movl %eax, -0x64(%ebp)
default
Blk 67 @ 0x804829f [7]
movl $0x0, -0x18(%ebp)
jnz
default
Blk 6 @ 0x80482a6 [30]
mov $0x2, %eax
movl -0x18(%ebp), %ecx
movl -0x64(%ebp), %edx
movl %eax, -0x74(%ebp)
mov %edx, %eax
cdq 
movl -0x74(%ebp), %esi
idiv %esi
cmp %eax, %ecx
jnle 0x8048301
default
Blk 36 @ 0x80482c4 [33]
movl -0x18(%ebp), %eax
movsxb -0x5c(%ebp,%eax,1), %eax
movl -0x14(%ebp), %ecx
sub $0x1, %ecx
subl -0x18(%ebp), %ecx
movsxb -0x5c(%ebp,%ecx,1), %ecx
cmp %ecx, %eax
jz 0x80482ec
default
Blk 13 @ 0x8048301 [15]
movsxb -0x5c(%ebp), %eax
cmp $0x5e, %eax
jnz 0x8048341
jnle
Blk 1 @ 0x80482e5 [7]
movl $0x0, -0x1c(%ebp)
default
Blk 31 @ 0x80482ec [5]
jmp 0x80482f1
jz
default
Blk 26 @ 0x80482f1 [16]
movl -0x18(%ebp), %eax
add $0x1, %eax
movl %eax, -0x18(%ebp)
jmp 0x80482a6
jmp
jmp
Blk 33 @ 0x8048310 [5]
jmp 0x8046132
default
jnz
jmp
jmp
jz
Blk 34 @ 0x804833c [5]
jmp 0x804834c
default
Blk 0 @ 0x804834c [6]
popl %eax
jmp 0x804611e
jmp
default
jmp
jmp
Original Fn
Padded Fn
Cookied Fn
d
e
e
f
c
Legend:
hook/trampoline
remedy content
a
sub ESP bump
b
a
b
c
d
e
f
EBP offset bump
add ESP bump
cookie injection
post-call cookie check
ret-block cookie check
Figure 4.
BINSURGEON rewrites a function to (1) add stack padding
with space-preserving rewrites and (2) add a stack cookie with non-space-
preserving rewrites.

117
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
in the next section. Instruction blocks are rendered as lists
of instructions, with edges to subsequent blocks in the CFG.
The shaded graphs are CFG subgraphs showing different
revisions of the same function (original, padded, and cookied).
Each directed edge from a version to the next indicates a
single rewrite over the outlined blocks. The letter on each
edge indicates the type of rewrite. For instance, there is one
cookie injection (labeled ‚Äúd‚Äù) and two post-call cookie checks
(labeled ‚Äúe‚Äù) written into the cookied function.
B. Revising CFGs
We distinguish between two types of revisions to a CFG,
both of which are supported by BINSURGEON:
1) Space-conserving rewrites replace or remove instruc-
tions from the CFG without requiring additional space,
e.g., by reordering instructions or substituting an instruc-
tion for an instruction of equal byte-size.
2) Space-consuming rewrites modify the CFG in a way that
requires additional space, e.g., by adding instructions
to existing functions/blocks or addition new functions
altogether.
These rewrites have an important practical difference: space-
conserving rewrites will preserve the integrity of the un-
changed CFG; but space-consuming rewrites require instruc-
tions to be shifted or relocated entirely, which potentially
changes the size and byte representation of instructions (in-
cluding relative control Ô¨Çow instructions). Space-consuming
rewrites may thereby cause arbitrarily-large ripples in the
CFG, so they require special attention.
One technique for implementing space-consuming rewrites
is to write a trampoline, where a jmp instruction is
written over the existing instructions, and the overwritten
instructions‚Äî and others to be injected‚Äî are written to a
blank space in the binary, which is targeted by the Ô¨Årst jmp
and terminates in a jmp back to the existing control Ô¨Çow.
In Figure 4, solid outlines around rewritten blocks indicate
a space-conserving rewrite, and dashed outlines around rewrit-
ten blocks indicate space-consuming rewrites that required a
trampoline.
C. Related work in binary rewriting
Previous work has explored specialized binary rewriting
to harden or diversify binaries. For instance, some rewriters
perform targeted rewriting to inject single, specialized defenses
such as stack cookies in return blocks [27] or control Ô¨Çow
checks in return blocks or before indirect calls [28].
Many recent systems perform binary rewriting to increase
diversity. In-place code randomization (IPCR) performs space-
conserving rewrites to substitute and reorder instructions to
help prevent code reuse attacks [29]. Similarly, chronomor-
phic programs perform space-conserving rewrites‚Äî including
IPCR and block relocation‚Äî during their execution [30] to
diversify themselves against code reuse attacks and cyber-
reconnaissance (e.g., [31]). Other systems perform load-
time binary rewriting to diversify binaries with a modiÔ¨Åed
loader [26], [32]. These specialized rewriters locate blocks at
TABLE I
OUTLINE OF BINSURGEON‚ÄôS BINARY REWRITING PROCEDURE.
GIVEN: Set of insertions/deletions to the CFG.
Compute the scope of the rewrite:
‚Ä¢ SET affected blocks B = blocks that will change content.
‚Ä¢ SET frontier blocks F = B.
‚Ä¢ WHILE any block f ‚àà F is too small to hold a jmp instruction,
add f‚Äôs source block(s) to F and B; remove f from F.
Label the graph and rewrite it:
‚Ä¢ CLAIM all space presently occupied by B as freespace.
‚Ä¢ LABEL every block in B and every internal control Ô¨Çow
instruction accordingly.
‚Ä¢ HOOK control Ô¨Çow at the previous start addresses of all F by
writing labeled jmp instructions to their new labels.
‚Ä¢ REWRITE the labled graph in memory with the insertions and
deletions.
Inject the rewritten, labeled subgraph back into the binary:
‚Ä¢ ASSEMBLE instructions to estimate their size in the binary.
‚Ä¢ PACK instructions into freespaces.
‚Ä¢ TEST the packing job by assembling a custom linker script.
‚Äì IF we overÔ¨Çowed a freespace:
‚àó IF other freespaces are above jmp size, update instruc-
tion size(s) accordingly and GOTO: PACK.
‚àó ELSE return not-enough-space.
Repair BINSURGEON‚Äôs CFG model in memory:
‚Ä¢ REMOVE nodes corresponding to former blocks B and all
edges from those nodes.
‚Ä¢ ADD nodes and incident edges for newly-assembled blocks
BSIF T .
‚Ä¢ SPLIT blocks as necessary if new outward edges from BSIF T
fall between a block‚Äôs entry and exit points.
randomized locations in memory and then ensure the CFG is
intact.
Other methods exist for translating binaries into an interme-
diate representation (IR) (e.g., [33], [34]), and then rewriting
them back into machine code, e.g., for diversity or safety pur-
poses. In contrast to IR approaches, BINSURGEON rewrites the
CFG and assembly instructions directly, which avoids potential
IR translation errors and potential performance degradation
by making local, targeted changes. As we demonstrate in the
next section, the CFG and assembly instructions themselves
are expressive enough to write diverse templates for program
repair and defense.
Other tools such as DynInst2 automatically instrument the
binary, but they consume substantially higher disk space,
memory footprint, or performance overhead. For example,
DynInst‚Äôs instrumentation has been shown to increase runtime
overhead by 96% [35]; that performance penalty would have
led to zero scores in the CGC.
BINSURGEON‚Äôs rewrites are far less invasive and costly:
BINSURGEON adds no universal function call hooks or virtu-
alization, so the overhead of its modiÔ¨Åcations is only propor-
tional to the speciÔ¨Åc installed defenses/repairs.
2http://www.dyninst.org/

118
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
V. REPAIR AND DEFENSE WITH BINSURGEON
Here we overview BINSURGEON‚Äôs procedure for rewriting
stripped, third-party binaries to add or remove arbitrary con-
tent [36]. We then describe some binary rewriting templates
that BINSURGEON uses for program defense and repair as part
of FUZZBOMB.
FUZZBOMB‚Äôs binary rewriting algorithm is summarized in
Table I. The procedure is given a CFG and a set of insertions
and/or deletions to the CFG. The insertions and deletions are
speciÔ¨Åed relative to existing instructions in the CFG (e.g.,
insert instructions X before instruction y or delete instructions
Z). BINSURGEON does not use absolute addresses (e.g., insert
instructions X at address y) for insertions and deletions, since
making space-consuming changes could shift the addresses
of subsequent instructions, thereby invalidating other absolute
addresses.
BINSURGEON‚Äôs rewriting procedure Ô¨Årst identiÔ¨Åes affected
blocks that must be rewritten and relocated, as well as
frontier blocks that will connect the affected blocks to the
rest of the CFG. The affected blocks will be rewritten, and
if BINSURGEON overÔ¨Çows these blocks, it will utilize (or
append) remote freespace (i.e., available executable memory)
within the binary. BINSURGEON identiÔ¨Åes frontier blocks
iteratively, since not all blocks are large enough to support jmp
instructions (i.e., for a trampoline, described in Section IV-B).
The frontier blocks serve as trampoline jmp sites for the
affected blocks, which is the trampoline content.
After identifying affected and frontier blocks, BINSUR-
GEON labels these blocks from their absolute addresses by
injecting assembly labels before each block, and then it
rewrites all internal control Ô¨Çow edges (i.e., conditional or
unconditional jumps between affected blocks b1 ‚àà B and
b2 ‚àà B) to use these labels. BINSURGEON writes jmp
instructions at the former entry point of each frontier block to
build a compound trampoline into the labled affected blocks.
BINSURGEON does not explicitly write jmp instructions back
to the unmodiÔ¨Åed CFG; rather, it uses the existing control Ô¨Çow
instructions of the labled blocks, which will be reassembled
later in its procedure. It then rewrites the labeled, labled graph
with the given insertions and deletions.
BINSURGEON next injects the rewritten, labled graph
back into the binary, using the affected blocks‚Äô previous
locations‚Äî and other claimed/extended executable memory‚Äî
as freespace. This is a greedy, iterative process of instruction-
packing: BINSURGEON Ô¨Ånds the next freespace proximal to
the last freespace (since near jmp instructions require fewer
bytes) and writes as many instructions as possible, insofar as
it can also write a jmp instruction to the next freespace.
After packing its freespaces, BINSURGEON writes out a
custom linker script to assemble all of the desired instructions
at the desired addresses. This converts every instruction of the
labled CFG subgraph into the machine-executable, location-
speciÔ¨Åc opcodes. If the assembling and linking succeeds, BIN-
SURGEON writes the corresponding instruction bytes directly
into the binary and reports success.
TABLE II
REMEDIES IMPLEMENTED BY BINSURGEON FOR FUZZBOMB
Support remedies add utilites for defense & repair:
‚Ä¢ cleanup: substitutes instructions in the CFG with instructions
guaranteed to re-assemble.
‚Ä¢ add-text-section: appends a new executable section to
the binary by extending or adding a program header.
‚Ä¢ fn-inject: adds new function(s) to the binary.
‚Ä¢ fn-intercept: intercepts existing functions by rerouting
direct calls to new or existing functions.
‚Ä¢ add-data-space: adds space in the binary for static data
storage.
Repair remedies address known PoVs:
‚Ä¢ terminate: injects instruction(s) to terminate the program at
the PoV location.
‚Ä¢ o/w-terminate: overwrite existing instructions to terminate
the program at the PoV location.
‚Ä¢ null-ptr-check: test a register or memory address, and
terminate if zero.
‚Ä¢ stack-top-cookie: write a cookie value to the top of
the program stack. Check it at the PoV location; terminate if
overwritten.
‚Ä¢ heap-cookie: intercept malloc, write a cookie value after
each allocation. Check it at the PoV location; terminate if
overwritten.
‚Ä¢ bss-cookie: write cookie value(s) into the binary‚Äôs static data
segment. Check it at the PoV location; terminate if overwritten.
Repair & Defense addresses known/unknown vulns:
‚Ä¢ stack-pad: increase stack frame size; decrement all base
pointer offsets below a given threshold.
‚Ä¢ stack-cookie: write a constant to frame pointer between
local variables or before the return address. Check the cookie
upon return or after function calls; terminate if overwritten.
‚Ä¢ range-check: if a memory address (e.g., pointer or function
pointer) is not within a given range (e.g., text section), terminate.
‚Ä¢ receive-check: intercept input functions and terminate if
they will write to illegal memory ranges.
‚Ä¢ cfi: range-based control Ô¨Çow integrity on return addresses and
indirect call and jmp addresses.
In some cases, the assembled instructions may overÔ¨Çow
a freespace. This occurs when BINSURGEON underestimates
instruction sizes and thereby over-packs a freespace. In these
cases, BINSURGEON updates its size estimates and attempts
to re-pack in the remaining freespaces. Otherwise, if it has
no more freespace, BINSURGEON reports that it needs more
space.
Finally, BINSURGEON repairs its in-memory model of the
program CFG, since the insertions and deletions may well have
changed existing functions and blocks connectivity or added
new functions and blocks altogether.
BINSURGEON‚Äôs rewriting procedure is content agnostic,
which means its rewriting capability is decoupled from the
rewritten content. As a practical consideration, this allowed
us to develop BINSURGEON independently of the repair and
defense templates it deployed for FUZZBOMB.
A. Repairing & Defending Binaries
BINSURGEON uses rewriting templates‚Äî which we call
remedies‚Äî to harden and repair binaries. Figure 5 shows a

119
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
Stack Cookie 
Stack Pad 
Terminate 
O/W-Terminate 
Range-Check 
Add-Text-Section 
Cleanup 
Fn-Inject 
Heap Cookie 
Null-Ptr-Check 
Fn-Intercept 
Add-Data-Space 
Stack-Top Cookie 
BSS Cookie 
CFI 
Receive-Check 
Support functionality 
Repair 
Repair & Defense 
Supports 
Figure 5.
Remedies for templated binary rewriting, including support functionality, targeted repair templates, and defensive templates.
dependence graph of remedies, since some remedies depend
on others‚Äô functionality, and Table II lists a brief description of
each remedy. Each remedy takes one or more parameters (e.g.,
a vulnerable function or instruction) and produces a set of in-
struction insertions and deletions to use with BINSURGEON‚Äôs
rewriting procedure.
These speciÔ¨Åc remedies are designed to avoid compromised
states or terminate the program when a compromised state
exists. Intuitively, when the program is in a compromised
state‚Äî or in program states where compromise is imminent
and unavoidable‚Äî terminating the program safely is prefer-
able to relinquishing control to a cyberattack.
These remedies do not Ô¨Åx the underlying problems, such
as overÔ¨Çows or off-by-one errors; rather, they mitigate the
adverse, exploitable manifestations. Templated repair of the
underlying problems are the focus of some source-code repair
systems (e.g., [37]), which is evidence that we can also develop
BINSURGEON templates to Ô¨Åx underlying problems if they are
adequately described. Next, we describe some novel and/or
counter-intuitive remedies in additional depth.
The
simplest
remedies
are
terminate
and
o/w-terminate,
which
terminate
the
program
at
a
speciÔ¨Åed
location
in
the
CFG.
The
o/w-terminate
(overwrite)
remedy
does
this
without
Ô¨Årst
allocating
freespace, in case the binary cannot be properly extended.
The stack-pad and stack-cookie remedies are used
in succession to protect a function‚Äôs stack frame by (1) adding
padding to a stack frame before or between the local variables,
and (2) writing a cookie value within that padding, to Ô¨Çag an
overÔ¨Çow if it is overwritten. Figure 4 illustrates the injections
and deletions speciÔ¨Åed by these remedies as performed by
BINSURGEON: stack-pad (Figure 4, middle) revises the
setup and reset of the stack frame (Figure 4 [a] and [b],
respectively) and revises all references to the stack via the base
pointer (Figure 4[c]); and stack-cookie (Figure 4, right)
injects a cookie at the head of the function (Figure 4[d]), and
adds cookie checks after each function call (Figure 4[e]) and
at the return block (Figure 4[f]).
One of the most complex remedies used within FUZZBOMB
is the heap-cookie. This remedy template is comprised of
the following modiÔ¨Åcations:
1) Injecting functions that intercept memory management
functions, e.g., malloc and free, that allocate and
free an extra byte, respectively, and write a speciÔ¨Åc value
to the extra byte, and store the location of the byte within
an injected array.
2) Overwriting call instructions to malloc and free
to instead invoke the injected functions.
3) Inject a cookie-checking function that iteratively checks
the cookie array, and terminates if any have changed
value.
4) Inject a call to the cookie-checking function at the
location of the PoV.
In conjunction, these modiÔ¨Åcations to the CFG cause the
program to add an extra cookie-byte to each heap allocation
and then check these cookie-bytes where speciÔ¨Åed, terminating
if it senses an overwrite.
VI. RESULTS AND CONCLUSIONS
The Ô¨Årst year of CGC involved three opportunities to
assess FUZZBOMB‚Äôs performance: two practice Scored Events
(SE1 and SE2) and the CGC Qualifying Event (CQE), which
determined which competitors would continue to the second
year of competition. In SE1, DARPA released Ô¨Åfteen challenge
binaries, some of which had multiple vulnerabilities. At the
time, FUZZBOMB had only recently become operational on
our computing cluster, and it did not solve many of the prob-
lems. However, with access to the source of the SE1 examples
and many bug Ô¨Åxes, some months later we had improved
FUZZBOMB enough that it was able to Ô¨Ånd vulnerabilities
in four of the problems, including at least one undocumented

120
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
Ô¨Çaw. For each of those vulnerabilities, FUZZBOMB had a re-
pair that was able to stop the vulnerability from being attacked
while also preserving all of the functionality tested by up to
1000 provided test cases. FUZZBOMB also create defensive
rewrites for all of the other binaries. In SE2, DARPA provided
nine new challenge binaries in addition to the prior Ô¨Åfteen,
giving a total of twenty-four. Each problem was supplied
with either no PCAPs or a PCAP Ô¨Åle containing up to 1000
client/server interactions. At the time of SE2, FUZZBOMB
was only able to Ô¨Ånd two of the new vulnerabilities, but that
performance was enough to earn fourth place, when the SE1
problems were included in the ranking.
Our progress in improving the system was slowed by
major problems with the government-provided testing sys-
tem: running parallel tests interfered with each other, and
running batches of serialized tests could cause false nega-
tives, hiding vulnerabilities. This meant we had to run tests
one at a time, incurring major overhead and making test-
running a major bottleneck (especially when given 1000 tests
from PCAPs, or when FUZZBOMB created many tests itself).
We Ô¨Ånally resolved these issues by discarding the provided
testing tool and writing our own. Our tool supported safe
parallel testing and increased testing speeds by at least two
orders of magnitude. However, it took many weeks to come
to that conclusion. Several key analysis functions were not
completed, including handling challenge problems that had
multiple communicating binary programs, complete support
for SSE Ô¨Çoating point instructions, and veritesting. We also
were not able to build the ability to have the system re-allocate
compute nodes to different CBs or to different functions (DVM
vs. running FuzzBALL). By the time of the CQE, in June
2015, FUZZBOMB was only able to fully solve seven of the
twenty-four SE2 problems. If given the PoVs for the twenty-
four problems, the repair system was able to Ô¨Åx twelve CBs
perfectly, and the defense system earned additional points on
the remaining CBs.
For CQE, DARPA provided 131 all-new problems to the
twenty-eight teams who participated (out of 104 originally reg-
istered). Each problem was supplied with either no PCAPs or
a single client/server interaction. Unfortunately, this singleton
PCAP triggered an unanticipated corner case in FUZZBOMB‚Äôs
logic: the protocol analysis concluded that every element of the
single client/server interaction was a constant, so the extracted
protocol had no variables to fuzz. And the default fuzz-testing
patterns were not used because there was a protocol extracted.
Thus FUZZBOMB‚Äôs fuzzing was completely disabled for all
of the challenge problems. Also, because the re-allocation
functionality was not available, we had to pre-allocate the
number of DVMs vs. FuzzBALL symbolic search engines.
We chose to use 325 DVMs and only 156 FUZZBOMBS,
because testing had been such a bottleneck. However, since
there were almost no test cases provided in the PCAP Ô¨Åles and
fuzzing was disabled, FUZZBOMB had very few tests to run,
and the DVMs were largely idle. With most CBs having only a
single FuzzBALL search engine, there was little parallel search
activity, and FUZZBOMB only found vulnerabilities in 12 CBs
(some using prior SE2 PoVs). Of those, with the limited testing
available, repair was only able to perfectly Ô¨Åx six (as far as
our system could tell). Defense rewrote all of the remaining
problems.
When the Ô¨Ånal CQE scores were revealed, FUZZBOMB
came in tenth place and did not qualify to continue in the
competition (only the top seven teams qualiÔ¨Åed). In addition
to the singleton PCAP Ô¨Åles and other issues, we learned of
another ‚Äúcurveball‚Äù when the scores were released: among
the 131 test cases, there were 590 known vulnerabilities,
an average of more than 4.5 Ô¨Çaws per binary. In hindsight,
FUZZBOMB‚Äôs defensive system should have been much more
aggressive in adding blind checks, to try to capture some
points from all of those Ô¨Çaws. Our conservative rationale had
been that retaining performance was more important, but with
that many Ô¨Çaws per CB, the balance is changed. Even so,
defensive rewriting earned FUZZBOMB more points than its
active analysis and repair capability. This result supports our
notion that CGC-relevant Ô¨Çaws boil down to a small number of
patterns in binary, and can be addressed with a small number
of repair/defense strategies.
Fortunately, the story is not over for FUZZBOMB; we have
other customers who are interested in the technology, and we
are actively pursuing transition opportunities to more real-
world cyber defense applications.
ACKNOWLEDGMENTS
This work was supported by DARPA and Air Force Research
Laboratory under contract FA8750-14-C-0093. The views expressed
are those of the author(s) and do not reÔ¨Çect the ofÔ¨Åcial policy or
position of the Department of Defense or the U.S. Government.
REFERENCES
[1] D. J. Musliner, S. E. Friedman, M. Boldt, J. Benton, M. Schuchard et al.,
‚ÄúFuzzbomb: Autonomous cyber vulnerability detection and repair,‚Äù in
Proceedings INNOV 2015: The Fourth International Conference on
Communications, Computation, Networks and Technologies, 2015.
[2] D. J. Musliner, J. M. Rye, D. Thomsen, D. D. McDonald, M. H. Burstein
et al., ‚ÄúFuzzbuster: Towards adaptive immunity from cyber threats,‚Äù in
Proc. SASO-11 Awareness Workshop, October 2011.
[3] ‚Äî‚Äî, ‚ÄúFuzzbuster: A system for self-adaptive immunity from cyber
threats,‚Äù in Proc. Eighth Int‚Äôl Conf. on Autonomic and Autonomous
Systems, March 2012.
[4] D. J. Musliner, J. M. Rye, and T. Marble, ‚ÄúUsing concolic testing to
reÔ¨Åne vulnerability proÔ¨Åles in fuzzbuster.‚Äù in SASO-12: Adaptive Host
and Network Security Workshop at the Sixth IEEE Int‚Äôl Conf. on Self-
Adaptive and Self-Organizing Systems, September 2012.
[5] D. Babi¬¥c, L. Martignoni, S. McCamant, and D. Song, ‚ÄúStatically-
directed dynamic automated test generation,‚Äù in Proceedings of the
ACM/SIGSOFT International Symposium on Software Testing and
Analysis (ISSTA), Toronto, ON, Canada, July 2011.
[6] D. Caselden, A. Bazhanyuk, M. Payer, S. McCamant, and D. Song,
‚ÄúHI-CFG: Construction by binary analysis, and application to attack
polymorphism,‚Äù in ESORICS‚Äô13: European Symposium on Research in
Computer Security, London, UK, Sep. 2013.
[7] L. Martignoni, S. McCamant, P. Poosankam, D. Song, and P. Maniatis,
‚ÄúPath-exploration lifting: Hi-Ô¨Å tests for lo-Ô¨Å emulators,‚Äù in Proceedings
of the 17th International Conference on Architectural Support for
Programming Languages and Operating Systems (ASPLOS), London,
UK, Mar. 2012.
[8] D. J. Musliner, S. E. Friedman, J. M. Rye, and T. Marble, ‚ÄúMeta-control
for adaptive cybersecurity in FUZZBUSTER,‚Äù in Proc. IEEE Int‚Äôl Conf.
on Self-Adaptive and Self-Organizing Systems, September 2013.

121
International Journal on Advances in Security, vol 9 no 3 & 4, year 2016, http://www.iariajournals.org/security/
2016, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
[9] S. E. Friedman, D. J. Musliner, and J. M. Rye, ‚ÄúImproving automated
cybersecurity by generalizing faults and quantifying patch performance,‚Äù
International Journal on Advances in Security, vol. 7, no. 3-4, 2014, pp.
121‚Äì130.
[10] D. J. Musliner, S. E. Friedman, T. Marble, J. M. Rye, M. W. Boldt et al.,
‚ÄúSelf-adaptation metrics for active cybersecurity,‚Äù in Proc. Adaptive
Host and Network Security Workshop at the IEEE Int‚Äôl Conf. on Self-
Adaptive and Self-Organizing Systems, September 2013.
[11] S. Ranise and C. Tinelli, ‚ÄúThe SMT-LIB format: An initial proposal,‚Äù in
Pragmatics of Decision Procedures in Automated Reasoning (PDPAR),
Miami, FL, USA, Jun. 2003.
[12] R. Nieuwenhuis, A. Oliveras, and C. Tinelli, ‚ÄúSolving SAT and SAT
modulo theories: From an abstract davis‚Äìputnam‚Äìlogemann‚Äìloveland
procedure to DPLL(t),‚Äù J. ACM, vol. 53, no. 6, 2006, pp. 937‚Äì977.
[13] V. Ganesh and D. L. Dill, ‚ÄúA decision procedure for bit-vectors and
arrays,‚Äù in Computer Aided VeriÔ¨Åcation (CAV), Berlin, Germany, Jul.
2007.
[14] L. de Moura and N. Bj√∏rner, ‚ÄúZ3: An efÔ¨Åcient SMT solver,‚Äù in Tools
and Algorithms for the Construction and Analysis of Systems (TACAS),
ser. LNCS, vol. 4963.
Springer, Apr. 2008, pp. 337‚Äì340.
[15] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager et al., ‚ÄúBitBlaze: A
new approach to computer security via binary analysis,‚Äù in Proceedings
of the 4th International Conference on Information Systems Security.
Keynote invited paper., Hyderabad, India, Dec. 2008.
[16] S. Edelkamp, V. Schuppan, D. Bosnacki, A. Wijs, A. Fehnker et al.,
‚ÄúSurvey on directed model checking,‚Äù in Model Checking and ArtiÔ¨Åcial
Intelligence, 2008, pp. 65‚Äì89.
[17] J. Benton, A. J. Coles, and A. Coles, ‚ÄúTemporal planning with prefer-
ences and time-dependent continuous costs,‚Äù in International Conference
on Automated Planning and Scheduling, 2012.
[18] K.-K. Ma, K. Y. Phang, J. S. Foster, and M. Hicks, ‚ÄúDirected symbolic
execution,‚Äù in Static Analysis Symposium (SAS), Venice, Italy, Sep.
2011, pp. 95‚Äì111.
[19] M. Helmert, ‚ÄúThe fast downward planning system,‚Äù Journal of ArtiÔ¨Åcial
Intelligence Research, vol. 26, no. 1, 2006, pp. 191‚Äì246.
[20] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley, ‚ÄúEnhancing
symbolic execution with veritesting,‚Äù in Proceedings of the 36th
International Conference on Software Engineering, 2014, pp. 1083‚Äì
1094. [Online]. Available: http://doi.acm.org/10.1145/2568225.2568293
[21] J. Antunes, N. Neves, and P. Verssimo, ‚ÄúReverse engineering of pro-
tocols from network traces,‚Äù in Proc. 18th Working Conf. on Reverse
Engineering (WCRE), 2011.
[22] W. Cui, V. Paxson, N. Weaver, and R. H. Katz, ‚ÄúProtocol-independent
adaptive replay of application dialog.‚Äù in NDSS, 2006.
[23] W. Cui, J. Kannan, and H. Wang, ‚ÄúDiscoverer: Automatic protocol re-
verse engineering from network traces,‚Äù in Proceedings of 16th USENIX
Security Symposium on USENIX Security Symposium.
USENIX
Association, 2007, pp. 1‚Äì14.
[24] G. Wondracek, P. Comparetti, C. Kruegel, and E. Kirda, ‚ÄúAutomatic net-
work protocol analysis,‚Äù in 15th Symposium on Network and Distributed
System Security (NDSS), 2008.
[25] R. Wartell, Y. Zhou, K. W. Hamlen, M. Kantarcioglu, and B. Thurais-
ingham, ‚ÄúDifferentiating code from data in x86 binaries,‚Äù in Machine
Learning and Knowledge Discovery in Databases.
Springer, 2011, pp.
522‚Äì536.
[26] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin, ‚ÄúBinary stirring:
Self-randomizing instruction addresses of legacy x86 binary code,‚Äù in
Proceedings of the 2012 ACM conference on Computer and communi-
cations security.
ACM, 2012, pp. 157‚Äì168.
[27] A. Baratloo, N. Singh, T. K. Tsai et al., ‚ÄúTransparent run-time defense
against stack-smashing attacks.‚Äù in USENIX Annual Technical Confer-
ence, General Track, 2000, pp. 251‚Äì262.
[28] M. Zhang and R. Sekar, ‚ÄúControl Ô¨Çow integrity for cots binaries.‚Äù in
USENIX Security, 2013, pp. 337‚Äì352.
[29] V. Pappas, M. Polychronakis, and A. D. Keromytis, ‚ÄúSmashing the
gadgets: Hindering return-oriented programming using in-place code
randomization,‚Äù in Security and Privacy (SP), 2012 IEEE Symposium
on.
IEEE, 2012, pp. 601‚Äì615.
[30] S. E. Friedman, D. J. Musliner, and P. K. Keller, ‚ÄúChronomorphic
programs: Runtime diversity prevents exploits and reconnaissance,‚Äù
International Journal on Advances in Security, vol. 8, no. 3-4, 2015,
pp. 120‚Äì129.
[31] A. Bittau, A. Belay, A. Mashtizadeh, D. Mazieres, and D. Boneh,
‚ÄúHacking blind,‚Äù in Proceedings of the 35th IEEE Symposium on
Security and Privacy, 2014.
[32] A. Gupta, S. Kerr, M. S. Kirkpatrick, and E. Bertino, ‚ÄúMarlin: A
Ô¨Åne grained randomization approach to defend against rop attacks,‚Äù in
Network and System Security.
Springer, 2013, pp. 293‚Äì306.
[33] P. Anderson and M. Zarins, ‚ÄúThe codesurfer software understanding
platform,‚Äù in Program Comprehension, 2005. IWPC 2005. Proceedings.
13th International Workshop on.
IEEE, 2005, pp. 147‚Äì148.
[34] D. Brumley, I. Jager, T. Avgerinos, and E. J. Schwartz, ‚ÄúBap: a binary
analysis platform,‚Äù in Computer aided veriÔ¨Åcation.
Springer, 2011, pp.
463‚Äì469.
[35] M. A. Laurenzano, M. M. Tikir, L. Carrington, and A. Snavely, ‚ÄúPEBIL:
EfÔ¨Åcient static binary instrumentation for linux,‚Äù in Proc. IEEE Int‚Äôl
Symp. on Performance Analysis of Systems and Software, 2010.
[36] S. E. Friedman and D. J. Musliner, ‚ÄúAutomatically repairing stripped
executables with CFG microsurgery,‚Äù in Submitted to Adaptive Host and
Network Security Workshop at the IEEE Int‚Äôl Conf. on Self-Adaptive
and Self-Organizing Systems, 2015.
[37] D. Kim, J. Nam, J. Song, and S. Kim, ‚ÄúAutomatic patch generation
learned from human-written patches,‚Äù in Proceedings of the 2013
International Conference on Software Engineering.
IEEE Press, 2013,
pp. 802‚Äì811.

