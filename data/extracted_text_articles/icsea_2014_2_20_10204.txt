An MDE Approach for Reasoning About UML State
Machines Based on Constraint Logic Programming
Beatriz P´erez
Department of Mathematics and Computer Science,
University of La Rioja,
Logro˜no, Spain.
Email: beatriz.perez@unirioja.es
Abstract—Model Driven Engineering promotes models as pri-
mary artifacts in the software engineering development process.
Such models must conform to a metamodel and held associated
constraints which restrict their validity. The veriﬁcation of models
against such requirements becomes therefore a fundamental
activity to ensure the quality of a system. In this context, the
Uniﬁed Modeling Language (UML) constitutes one of the most
commonly used modeling languages to represent both static
and dynamic aspects of software systems. Nevertheless, while
the formalization and analysis of static models has motivated
a signiﬁcant number of proposals, it far exceeds the research
done on dynamic models, specially on UML state machines,
considered to be the mainstay to represent the dynamics of
a system. We have deﬁned a proposal to reason about UML
state machines based on Constraint Logic programming (CLP),
using Formula as model ﬁnding and design space exploration
tool. We show how to translate a UML state machine model
into a CLP program following a Meta–Object Facility (MOF)
like framework. Furthermore, we enhance our proposal by
giving support for the automatic translation of state machines
to Formula speciﬁcations, based on a Model Driven Engineering
(MDE) approach. The proposed framework can be used to reason
and validate UML state machine designs by generating valid
sets of execution state conﬁgurations and checking correctness
properties, using Formula as model exploration tool.
Keywords—UML state machines, OCL, Constraint Logic Pro-
gramming, reasoning, MDE
I.
INTRODUCTION
Model-Driven Engineering (MDE) has been promoted for
some time as a solution to handle the increased complexity
of software development. In the MDE paradigm, models
constitute the cornerstone components during the software de-
velopment process. Such models must conform to a metamodel
and held associated constraints which restrict their validity.
Effective veriﬁcation of models against such requirements
becomes therefore a fundamental activity to ensure the quality
of a system. In the context of MDE, the Uniﬁed Modeling
Language (UML) [1] has been widely accepted as the de-
facto standard object-oriented software modeling language. In
particular, UML is widely used in software design to specify
both the static and dynamic aspects of object oriented systems,
where UML Class Diagrams and UML State Machines are
considered to be the mainstay to represent the statics and
dynamics of a system, respectively.
As any other software artifact, software models may
contain design ﬂaws. Unfortunately, in some occasions such
possible design defects are not detected until the later imple-
mentation stages, thus increasing the cost of development [2],
[3]. This situation requires a wide adoption of formal methods
as well as of veriﬁcation and validation approaches. In this line,
there have been remarkable efforts to formalize UML seman-
tics, in order to address and solve the ambiguity, uncertainty
and underspeciﬁcation issues detected in UML semantics.
Nevertheless, while the formalization and analysis of static
models has motivated a signiﬁcant number of proposals [2],
[4], [5], [6], [7], [8], [9], [10], it far exceeds the research done
on dynamic models, specially on UML state machines or on
any other variant of Harel statecharts [11], [12]. In many of
such proposals, the formalization and analysis of UML artifacts
is accomplished carrying out a translation to another language
that preserves the semantics. The resulted translation can be
used to reason about the original model by checking predeﬁned
correctness properties about the original model [3].
In this paper, we extend the work we presented with I.
Porres in [10], [13], which proposes an overall framework to
reason about UML Class diagrams annotated with OCL, to
give also support to UML State Machines. In particular, in
this paper we propose a framework to reason about UML State
Machine models based on the Constraint Logic programming
(CLP) paradigm. As in [10], [13], we use Formula [14] as
model ﬁnding and design space exploration tool, which is
based on algebraic data types and CLP. More speciﬁcally, we
show how to translate a UML state machine model into a
CLP program following a Meta–Object Facility (MOF) like
framework. Once a UML state machine model is translated
into the Formula language, the Formula tool can be used,
for example, to prove the reachability of speciﬁc states of
the state machine or to check for consistency requirements of
the state machine deﬁnition. Furthermore, in order to provide
full support for the automatic translation of state machines
into Formula, we have included an additional menu option
in the Eclipse plugin we presented in [10], to easily and
automatically carry out such translation. Our framework can
be used to reason and validate UML state machine designs
by generating valid sets of execution state conﬁgurations and
checking correctness properties, using the model exploration
tool Formula. We illustrate the usefulness and effectiveness of
our approach by applying it to a particular case study.
The paper is structured as follows. Section II provides
a brief introduction to UML State Machines and presents a
simple case study we use throughout the paper. Section III
gives an overview of our proposal for the translation of UML
34
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

Region
In Maintenance
t1:
delivered
t0
Ordered
t3:
disabled
Ready for Use
t4:
withdrawn
t2:
enabled
Transition
Vertex
PseudoState
StateMachine
Event
Activity
+trigger
+region
+container
+container
+region
+subvertex
+transition
+effect
+source
+target
+outgoing
+incoming
+entry
+exit
+doActivity
0..1
0..1
0..1
0..1
0..1
0..1
0..1
0..1
*
*
*
1..*
1..*
1..*
1..*
0..1
0..1
0..1
1
1
Metamodel level
Model level
Intance level
+kind:PseudoStateKind
+kind:TransitionKind
TransitionKind
internal
locale
external
<<enumeration>>
PseudoStateKind
initial
deepHistory
ShallowHistory
join
fork
choice
entryPoint
exitPoint
terminate
<<enumeration>>
State
isComposite
isOrthogonal
isSimple
is SubmachineState
O
IM
t1
t0
t4
O
IM
RU
t1
t2
t3
t0
IM
t4
O
IM
RU
t1
t2
t0
t3
IM
RU
t2
t3
IM
t4
...
Figure 1: MOF model levels concerning UML State Machines applied to our case study.
state machines to Formula. Section IV explains the application
of our proposal, and illustrates the usefulness of our approach
by applying it to our case study. Related work is discussed in
Section V. Finally, Section VI contains our main conclusions.
II.
BACKGROUNDING AND CASE STUDY
In this section, we present general background information
of UML State Machines, together with the case study we use
throughout the paper. In particular, we illustrate UML State
Machines with the help of Fig. 1 in which we represent three
of the MOF model levels concerning UML State Machines,
applied to our case study: the Metamodel level, the Model level,
and the Instance level. In particular, we show an excerpt of the
UML State Machine metamodel (see the top side of Fig. 1),
and the speciﬁc state machine model of our case study (see
the center side of Fig. 1). This state machine model has been
extracted from [15], which we have slightly modiﬁed to cover
basic aspects of UML state machines for explanation purposes.
In particular, this state machine represents the basic states that
an object airplane can be in during the course of its life.
As we show in the excerpt of the UML State Machine
metamodel depicted on the top side of Fig. 1, a state machine
consists essentially of states, transitions and various other
types of vertexes named pseudostates [1]. Firstly, states denote
a situation of objects during which some condition holds.
There are three kinds of states: simple, composite or subma-
chine. Simple states are characterized by not having substates,
while composite states are divided into orthogonal composite
states, to model concurrent behaviors where several states are
active simultaneously, and simple composite states, to specify
that only one of their substates must be active. Submachine
states are used basically as a way to encapsulate states and
transitions so that they can be reused. In our case study, we
represent that, over the course of the life of an object plane, it
can take up three simple states: Ordered, In Maintenance, and
Ready for Use. The valid set of states that the object can be
active in, at a speciﬁc moment in time during the execution of
the state machine, is known as state conﬁguration.
On the other hand, a transition is the mechanism by which
an object leaves a state conﬁguration and changes to a new
state conﬁguration. A transition can be triggered by some
event. In our case study, if the event deliver occurs, and the
plane is the state Ordered, it changes to the state In Mainte-
nance, nothing happens if the plane is in any other state than
Ordered. Particularly, a transition is a directed relationship
between a source vertex and a target vertex, where these
vertexes can be either pseudostates or states. A pseudostate is
an abstraction used to connect multiple transitions into more
complex state transitions paths. There are several kinds of
pseudostates (such as initial, join and fork pseudostates). An
example of an initial pseudostate is shown in our case study of
Fig. 1 depicted by a ﬁlled circle, representing the creation of
the object plane. Additionally, composite states can have one
or more regions which are considered as simple containers of
a connected set of substates, pseudostates and transitions.
Finally, the sequence of state conﬁgurations an object can
go through during its lifetime is known as execution trace. For
example, on the bottom side of Fig. 1 we show three of the
execution traces a plane can be during its lifetime. For a more
complete explanation of state machines, we refer to [1].
III.
UML STATE MACHINES TO FORMULA TRANSLATION
Our proposal for reasoning about UML State Machines
has some similarities with the approach we presented in [10],
[13] for reasoning about UML Class Diagrams, but there
is a subtle and essential difference between them. In both
proposals we represent the corresponding UML metamodel
and model (related to Class Diagrams and State Machines,
respectively) in the Formula language, resulting a translation
that can be used for several purposes. For example, the resulted
Formula speciﬁcation can be used to rigorously reason about
the model’s design, by checking predeﬁned correctness prop-
erties about the original model such as the lack of redundant
constrains. Additionally, the Formula speciﬁcation can be used
to inspect the model, in order to search for conforming object
models and to choose those which better ﬁt the domain needs.
Nevertheless, while in [10], [13] we aimed at ﬁnding sets of
classes’ instances conforming the class diagram, in the case
35
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

1 [Unique(name ->type)]
2 primitive State ::= (name: String, type: stateType).
3 [Unique(name -> type)]
4 primitive Pseudostate ::= (name: String, type: pseudostateType).
5 Vertex ::= State + Pseudostate + ....
6 [Closed(src, dst)]
7 primitive Transition ::= (name: String, type: transitionKind, src: Vertex, dst: Vertex).
8 error_meta_undeclStates := Transition(_,_,State(x,y),_), fail State(x,y). ...
Metamodel
level
Legend
Formula
extension
Formula
instance of
Formula
inclusion (UML
instance of)
Formula data
types
Formula
instances
MetaLevel Domain
9   Final is State("final", simple)
10 ordered is State("Ordered", simple)
11 inMaintenance is State("InMaintenance", simple)
12 readyForUse is State("ReadyForUse", simple)
13 ini is Pseudostate("initial",initial)
14 tr0 is Transition("tr0",external,ini,ordered)
15 tr1 is Transition("tr1",external,ordered,inMaintenance)  ...
Model level
StateMachine Model
16 [Closed(type)][Unique(name -> type)]
17 primitive StateInstance ::=(name: String, type: State).
18 stateName := StateInstance(name, type), type.name!=name. ...
19 VertexInstance ::= StateInstance + PseudostateInstance.
20 [Closed(type,source,target)][Unique(name-> type)]
21 primitive TransitionInstance ::=(name: String, type: Transition,
source: VertexInstance, target: VertexInstance). ...
22//Formula expressions needed to create new configuration states ...
InstanceLevel Domain
Instances level
23 pIni is PseudostateInstance("initial",ini)
24 O is StateInstance("Ordered",ordered)
25 IM is StateInstance("InMaintenance",inMaintenance)
26 RU is StateInstance("ReadyForUse",readyForUse)
27  Final is StateInstance("final"Final)
28 t0 is TransitionInstance("tr0",tr0,pIni,O)
29 t1 is TransitionInstance("tr1",tr1,O,IM) ...
StateMachineInstances
Model
extends
of
of
includes
of
includes
30 Bound(14)
31 Trigger(0,_)
32 Trigger(1,_)
...
Execution Partial Model
Figure 2: Formula speciﬁcations deﬁned for the representation of our case study in Formula.
of UML State Machines we are interested in reasoning and
validating UML State Machine designs by generating possible
sets of state conﬁgurations, simulating valid execution traces.
As we propose in [10], [13], our approach for reasoning
about UML State Machines follows a MOF-like metamod-
eling approach. More speciﬁcally, our proposal deﬁnes ﬁve
different Formula units which are distributed along the MOF
Metamodel, Model and Instance levels [1]. In order to have
a better understanding of our proposal, in Fig. 2 we illustrate
the deﬁned Formula units, which are represented by means
of rectangles. Furthermore, associated to each Formula unit,
we have included, depicted by means of rhomboids, part of
the speciﬁc Formula expressions that would be deﬁned for
representing the state machine of our case study. Next, we
brieﬂy explain our proposal for the representation in Formula
of a speciﬁc UML state machine leaning on this ﬁgure.
A. Formula Data Types and Queries
Formula allows to represent a system by using three
different units: domains, models and partial models. Firstly, a
problem domain FD can be speciﬁed to formalize an abstrac-
tion of the problem that can be used by Formula to reason
about the design. This type of units allows to specify abstract
data types and a logic program describing properties of the
abstraction [14]. For this reason, we have decided to represent
the UML State Machine’s constructs by means of domains (see
MetaLevel and InstanceLevel domains in Fig. 2).
In particular, a Formula domain consists of abstract data
types, rules and queries. Firstly, abstract data types constitute
the key syntactic elements of Formula. They are deﬁned by
using the operator ::=, indicating on the right hand side their
properties by means of ﬁelds. Data types can be labeled in their
deﬁnition with the primitive keyword, deﬁning primitive
constructors. As an example, in line 7 of Fig. 2 we deﬁne the
Transition data type, which represents the Transition
element of the UML State Machine metamodel. In particular,
it deﬁnes several ﬁelds together with their types (such as
the ﬁelds src and dst of type Vertex, representing the
source and target vertexes of a transition, respectively). If
the primitive keyword is omitted, the data type deﬁnition
results in a derived constructor (see the deﬁnition of the type
Vertex in line 5, representing the Vertex element of the
UML metamodel). Data types are used as building blocks for
deﬁning Formula expressions (terms and predicates). Terms
are the basis for deﬁning predicates, which constitute the
basic units of data, used for deﬁning queries and rules. As an
example of the deﬁnition of a term, in line 8 of Fig. 2 we show
the term Transition(_,_,State(x,y),_), representing all
instances of the Transition term, where the third ﬁeld is
set to a ﬁxed property (State(x,y)). The other ﬁelds are
ﬁlled with a do not-care symbol (‘ ’), so that Formula will
ﬁnd valid assignments. In this way, this term represents any
transition whose source state is a speciﬁc state (State(x,y)).
Based on the deﬁned data types, rules and queries are
speciﬁed as logic program expressions, ensuring the remaining
constraints [14]. In particular, a rule behaves like a univer-
sally quantiﬁed implication, that is, whenever the relations
on the right hand side of a rule hold for some substitution
of the variables, then the left hand side holds for that same
substitution [12]. The main aim of rules is production; they
create new entries in the fact-base of Formula, populating
previous deﬁned types with facts representing the members
in the collection presented in the rule. Rules are speciﬁed by
means of the operator :-, indicating on the left–hand of the
expression a simple term and, on the right–hand, the list of
predicates specifying the rule (an example of a rule is shown
later in this section). On the other hand, a query, which is
constructed by means of the operator :=, corresponds to a
rule where left–hand side is a nullary construction [12]. A
query behaves like a propositional variable that is true if and
only if the right-hand side of the deﬁnition is true for some
substitution [12]. In particular, Formula deﬁnes in every do-
main the conforms standard query, where all constraints come
36
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

together and deﬁne how a valid instance of the domain have to
look like. Based on the existential quantiﬁcation semantics of
queries, we can use them to prove the existence of speciﬁc facts
in the model. Additionally, the universal quantiﬁcation can be
achieved by verifying the negation of a query representing the
opposite of the original predicate. For example, to ensure that
Transitions are not created as connections of undeclared
States, we ﬁrstly need to deﬁne a query representing the
existence of transitions verifying the opposite (see line 8 of
Fig. 2). With this query we are considering such incoherent
situation as a valid state. Thus, to verify that such situation is
not valid, we need to include the negation (‘!’) of the query
in the conforms query of the speciﬁc domain.
Taking this into account, the deﬁned domains contain (1)
speciﬁc data types, which allow us to represent facts and
generate reasoning instances of such types, and (2) queries,
which restrict the valid system states by specifying forbidden
states. Due to space reasons in this paper we mainly focus
on explaining the deﬁned data types. In particular, ﬁrstly we
have created the MetaLevel domain, which mainly deﬁnes a
primitive Formula data type for each meta model element
State, Pseudostate, and Transition, together with speciﬁc For-
mula queries representing UML State Machine metamodel
constraints (see lines 1 to 7 in Fig. 2). The deﬁnition of these
types allows the tool to create Formula instances representing
speciﬁc UML States, Transitions and Pseudostates at the
Model level (such as the speciﬁc state Ordered). We note that,
since the representation of the Metamodel level is the same
whatever state machine is considered, this Formula domain is
deﬁned once and used for each state machine. On the other
hand, to be able to represent the information generated during
the execution of a state machine (that is, the state conﬁgura-
tions which constitute the execution traces, together with the
representation of the triggered transitions), we have deﬁned
speciﬁc types included in a Formula domain InstanceLevel
(see Fig. 2), which deﬁnes types such as StateInstance or
TransitionInstance (see lines 16-17 and 20-21).
B. Formula Data Types’ Instances
Having deﬁned the Formula domains with the abstractions
of the problem, Formula gives the possibility of creating a
model FM as a ﬁnite set of data type instances built from
constructors deﬁned in the associated domain FD, and which
satisﬁes all the FD constraints [12]. In our particular case, we
have deﬁned two different Formula models. Firstly, we have
created the StateMachine model, which contains the instances
of the data types created in the MetaLevel domain, and which
represent the speciﬁc elements of a particular state machine
(see Fig. 2). For example, in line 10 of Fig. 2 we show
the deﬁnition of the element ordered, which corresponds
to a Formula instance of the constructor State deﬁned at
the Metamodel level. Secondly, we deﬁne the StateMachine-
Instances model, which contains the instances of the data
types deﬁned in the InstanceLevel domain. In particular, such
instances refer to the state and transition instances that Formula
would use as constructors of the execution traces of the speciﬁc
state machine. For example, in this Formula model we deﬁne
instances such as O (see line 24), which would represent
the fact that a speciﬁc airplane object has been in the state
“Ordered”. On the left hand of Fig. 3 we also show graphically
the overall instances we would deﬁne for the case study. Taking
t1
O
IM
RU
IM
RU
t1
t2
t3
t3
IM
RU
O
t2
t4
t3
t0
t0
t2
IM
t4
Figure 3: Instance elements and complete execution trace.
this into account, the StateMachine model conforms with the
MetaLevel domain, while the StateMachineInstances model
conforms with the InstanceLevel domain.
C. Logic Instructions to Simulate State Machines’ Execution
Up to now, we have established the bases to be able to
represent in Formula the UML State Machine metamodel,
speciﬁc state machines conforming with such metamodel, as
well as the concrete instances produced during the execution of
a state machine and which would constitute the state machine
execution traces. Nevertheless, the deﬁned Formula data types,
instances and queries are not enough to allow Formula to
reason about the state machine execution, that is, to take such
concrete elements and organize them into valid execution state
conﬁgurations. More speciﬁcally, in addition to such instances
(see the left hand of Fig. 3) and queries, we provide Formula
with speciﬁc data types and rules to instruct the tool in the way
to reason about such data, so that it is able to generate valid
execution traces (such as the one shown on the right hand of
Fig. 3). For this reason, we have completed our proposal by
deﬁning other two Formula speciﬁcation blocks.
Firstly, we need to indicate Formula the way in which it
has to generate a valid chain of active state conﬁgurations’
instances which will constitute the valid execution traces.
For this task, we have included in the InstanceLevel domain
the deﬁnition of a new data type called Trigger (see lines
from 3 to 5 in Fig. 4), in order to simulate the triggered
of a transition. For this reason, its deﬁnition includes a ﬁeld
t, referring the moment in which the triggered takes place, and
the associated TransitionInstance instance (see line 4).
We have included the Formula constraint [Closed(tr)] to
instruct Formula to apply a closed check to instances of
the TransitionInstance data type, that is, using only the
instances of such a type already created in the StateMachineIn-
stances model. Based on the Trigger type, we deﬁne the type
stateConfiguration to represent a state conﬁguration (see
line 7), and which has three ﬁelds: (1) t, which keeps track
in time of the sequence of state conﬁgurations, (2) v, which
refers to the speciﬁc active vertex, and (3) traT, which refers
to the speciﬁc transition (TransitionInstance instance)
which has been triggered to change to that state.
Additionally, in order to construct the chain of state
conﬁgurations as the transitions are triggered, we have
deﬁned a Formula rule (see line 9 in Fig. 4), in order to
create new entries of type stateConfiguration in the
fact-base of Formula. As we have described previously,
whenever the relations on the right hand side of a rule
hold for some substitution of the variables, then the left
hand side holds for that same substitution, and Formula
generates the new entry corresponding to the left hand
side. Taking this into account, given the current state
conﬁguration
stateConfiguration(t,src,traT)and
37
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

1 domain InstanceLevel extends MetaLevel {
2   ....
3   [Unique(t ->tr)][Closed(tr)]
4
primitive Trigger ::=(t: Natural, tr: TransitionInstance ).
5
triggerNumber:= tri1 is Trigger(t1,tr1), tri2 is Trigger(t2,tr2), t1!=t2,tr1=tr2.
6
primitive Bound::=(t: Natural).
7
stateConfiguration ::= (t: Natural, v: VertexInstance, traT: String).
8
stateConfiguration (0,ini, traT):- ini is PseudostateInstance ("initial",
Pseudostate("initial",initial)), traT="__".
9
stateConfiguration (tnext, dst,traTnext) :-
stateConfiguration (t, src,traT),
Trigger(t, TransitionInstance (tn,_,source,target)),
source.name=src.name,
target= dst, tnext=t+1,
Bound(end), t<end.
10  ...
11}
Figure 4: Generation of new state conﬁgurations.
the
triggered
of
a
transition
Trigger(t,
TransitionInstance(tn,_,source,target))
whose
source
vertex
corresponds
to
the
current
one
(source.name=src.name), Formula creates a new fact
stateConfiguration (tnext,dst,traTnext),
which
corresponds to the new state conﬁguration where the new
state dst is the target vertex of the triggered transition
(target=dst). The value of the time parameter tnext is
also incremented by 1 for the following state conﬁguration.
Another rule is created (see line 8 in Fig. 4) to get the initial
state conﬁguration fact. We also deﬁne the Bound type to
limit the number of transitions triggered during the state
machine execution (see Bound(end), t < end in line 9).
Secondly, we need to instruct Formula to ﬁnd valid as-
signments for the TransitionInstance appearances in the
Trigger elements of the rule in charge of creating new
stateConfiguration facts (see line 9 in Fig. 4). For these
types of tasks, Formula deﬁnes another type of Formula units,
called partial models FPM, in which specify individual con-
crete instances of the design-space or unknown parts thereof,
these latter corresponding to the parts of the model FM that
must be solved by the Formula tool [14]. For this reason, we
have deﬁned a partial model called Execution (see Fig. 2), in
which we include as many Trigger terms as necessary, and
which deﬁne a do not-care symbol (‘ ’) in the ﬁeld which
corresponds to the TransitionInstance instance, so that
Formula will ﬁnd valid transition assignments.
IV.
APPLICATION AND TOOL SUPPORT
In this section, we brieﬂy explain how to use our framework
in practice and apply it to our case study to illustrate its
usefulness. Finally, we give some remarks of our plug-in.
The ﬁrst step to apply our proposal is the translation
of the speciﬁc state machine we want to reason about into
the input speciﬁcation language of the Formula tool. Such
step is carried out by following the guidelines explained
in the previous section. Having translated the UML state
machine into the Formula language, the Formula ﬁnder can
be used for different reasoning purposes, such as to prove the
reachability of states or check the existence of consistency
requirements in the state machines’ deﬁnition. In particular,
such requirements are represented by means of the deﬁnition
of new Formula queries. Additionally, since the requirements
are deﬁned over the execution traces, such queries are included
in the conforms query of the InstanceLevel domain, for their
veriﬁcation. Finally, if the system holds such requirements, the
tool returns a state machine execution trace verifying all the
established constraints. Otherwise, Formula will have proven
that the model is unsatisﬁable, that is, not execution trace is
possible since some of the constraints become violated. In this
latter case, the inconsistencies detected could be taken into
account, for example, for the redeﬁnition of the state machine.
In the particular case of using our proposal to prove the
reachability of states, we can check whether there exists a
path which leads to a speciﬁc state conﬁguration. A speciﬁc
use in this line is to ﬁnd out whether the state machine has
a valid execution trace in which the object reaches a ﬁnal
status (that is, there is at least a execution path in which
a ﬁnal status is reached, which corresponds to a possible
existence property). As an example of application, we can test
whether the ﬁnal state in the state machine of our case study
(represented as stateConfiguration(_,sFinal,_)) can
be reached at some point. In this case, the following query
is deﬁned, which is included in the conforms query:
q1:= count(stateConfiguration(_,sFinal))=1. For-
mula takes as input the state machine speciﬁcation including
this query, and outputs a chain of state conﬁgurations proving
the reachability of the ﬁnal state. In particular, Formula returns
the following facts, which particularly correspond to the ﬁrst
execution trace depicted in the Instance level of Fig. 1:
stateConfiguration(0,pIni,‘‘_’’)
stateConfiguration(1,O,‘‘t0’’)
stateConfiguration(2,IM,‘‘t1’’)
stateConfiguration(3,Final,‘‘t4’’)
On the other hand, we can also check consistency re-
quirements of state machines’ deﬁnition. More speciﬁcally, we
refer to consistence from a structural perspective, referring to
properties that the model is expected to satisfy irrespective
of its semantic content. In particular, we can verify whether
the state machine exhibits a number of desired properties,
obtaining at the same time the corresponding execution traces
proving that the state machine holds such properties. For
example, we can check whether an air plane can be available
during its life time a speciﬁc number of times, obtaining
the corresponding trace of state conﬁgurations. In particu-
lar, this property is checked by deﬁning the query: q2:=
count(stateConfiguration(_,sRFU,_))=number.
As for as tooling support, we have taken our CD2Formula
plug-in presented in [10] to automatically translate speciﬁc
class diagrams into Formula and we have modiﬁed it giving
support for UML state machines. Finally, we have included
both functionalities in an only plug-in called UML2Formula.
Again, we have used MOFScript tool [16] which provides
support for customizable model–to–text transformations. We
use the UML 2.0 metamodel and the speciﬁc state machine
as the model which can be deﬁned using any UML 2.0
compliant tool that can create models in the XMI format
supported by EMF (for example, the UML2 Eclipse plug-
in [17] or a UML2 compliant graphical tool). As far as the
Formula units generation is concerned, we have deﬁned an
only set of MOFScript transformation scripts that generates
the different Formula units as stated in our proposal. The
deﬁned MOFScript transformations have been integrated into
the plug–in, allowing the automatic generation of the Formula
speciﬁcation by means of a menu option the plug–in provides.
Applying this menu option to a speciﬁc state machine, the
plug–in returns a .4ml extension ﬁle. Later, the speciﬁc query
38
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

properties to be checked have to be manually included in this
ﬁle, which Formula will use for reasoning about the model.
V.
DISCUSSION AND RELATED WORK
In the past decade, there are several works which have used
Constraint Logic Programming to formalize UML semantics,
being limited those which tackle UML State Machines or
on any other variant of Harel statecharts [11], [12], [18],
[19]. In particular, there have been some proposals which
aim at formalizing UML State machines which have followed
a MOF–like approach to a greater or lesser extent. More
speciﬁcally, authors in [11] focus on Hierarchical Finite State
Machines (HFSM), which are a simpliﬁed version of UML
State Machines, which consider more structural elements (such
as concurrent states and pseudostates). The difference between
both proposals, besides the different types of modeling lan-
guages, lies in the main goal. In particular, authors in [11] give
an approach to complete partially speciﬁed dynamic models.
More speciﬁcally, starting from a partial model constituted
by unlinked states and transitions, they are able to ﬁnd a
complete state model deﬁned from that partial model and
which conforms with the HFSM metamodel. In contrast, our
proposal aims at reasoning about speciﬁc state machines, not
arbitrary ones, that is the reason because it starts from a
complete speciﬁc state machine model instead of a partial one.
In [12], authors present a metamodeling framework based on
Formula and reason about typed graphs. In particular, they
give a metamodel-based approach for representing only the
MetaNode and the MetaEdge elements, at the Metamodel
level, and graph nodes and edges, at the Model level, and
ﬁnally reason about models. In particular, they apply their
proposal to the particular case of state diagrams (where states
are nodes and transitions are edges) in order to construct,
similarly to the proposal in [11], well–formed state diagrams.
In [19] where the author uses Alloy, a textual modelling
language based on ﬁrst-order relational logic, used in other
works for analyzing UML class diagrams [18], gives a proposal
to simulate states by specifying the notion of state on the model
level, in an Alloy model, while the transition between states
is given by the invocation to a UML operation.
VI.
CONCLUSION AND FUTURE WORK
In this paper, we present a framework to reason about UML
state machine models based on the CLP paradigm. The main
contribution of our work is the translation of a UML state
machine into a Constraint Satisfaction Problem following a
MOF–like framework. We enhance our approach by providing
an MDE-based implementation of our translation proposal,
based on our UML2Formula plug–in. Particularly, starting
from a UML state machine representing the dynamic structure
of a software system, our plug–in carries out the automatic
generation of the Formula speciﬁcation corresponding to such
UML model, by simply choosing a menu option the plug–
in provides. The proposed framework can be used to reason
and validate UML state machine designs by generating valid
sets of execution state conﬁgurations and checking correctness
properties, using the model exploration tool Formula.
Our proposal considers basic UML State Machine ele-
ments, but the support for other commonly used elements (such
as guards or composite states) constitutes a remaining work.
ACKNOWLEDGMENTS
This work has been partially supported by the University
of La Rioja (project PROFAI13/13).
REFERENCES
[1]
OMG,
“UML
2.4.1
Superstructure
Speciﬁcation,”
document
formal/2011-08-06, August, 2012. Available at: http://www.omg.org/.
Last visited on August 2014.
[2]
A. Cal`ı, D. Calvanese, G. D. Giacomo, and M. Lenzerini, “A Formal
Framework for Reasoning on UML Class Diagrams,” in Proc. of the
13th International Symposium on Foundations of Intelligent Systems
(ISMIS’02), ser. LNCS, vol. 2366.
Springer, June 2002, pp. 503–513,
ISBN:3-540-43785-1.
[3]
J. Cabot, R. Claris´o, and D. Riera, “Veriﬁcation of UML/OCL Class
Diagrams using Constraint Programming,” in Proc. of the 2008 IEEE
International Conference on Software Testing Veriﬁcation and Valida-
tion Workshop (ICSTW’08).
IEEE Computer Society, April 2008, pp.
73–80, ISBN: 978-0-7695-3388-9.
[4]
A. Queralt, A. Artale, D. Calvanese, and E. Teniente, “OCL-Lite:
Finite reasoning on UML/OCL conceptual schemas,” Data Knowl. Eng.,
vol. 73, pp. 1–22, 2012.
[5]
M. Balaban, A. Maraee, and A. Sturm, “Reasoning with UML Class
Diagrams: Relevance, Problems, and Solutions – a Survey,” March
2007, available online at: http://www.cs.bgu.ac.il/ mira/CDReasoning-
07.pdf. Last visited on August 2014.
[6]
M. Broy, M. V. Cengarle, H. Gr¨onniger, and B. Rumpe, “Considerations
and Rationale for a UML System Model,” in UML 2 Semantics and
Applications, K. Lano, Ed., 2009, pp. 43–60.
[7]
J. Osis and U. Donins, “Formalization of the UML Class Diagrams,”
in Evaluation of Novel Approaches to Software Engineering, ser. Com-
munications in Computer and Information Science.
Springer, 2010,
vol. 69, pp. 180–192, ISBN: 978-3-642-14818-7.
[8]
D. Berardi, A. Cali, D. Calvanese, and G. Di Giacomo, “Reasoning on
uml class diagrams,” Artiﬁcial Intelligence, vol. 168, pp. 70–118, 2005.
[9]
M. Gogolla, J. Bohling, and M. Richters, “Validating uml and ocl
models in use by automatic snapshot generation,” Software and System
Modeling, vol. 4, no. 4, pp. 386–398, 2005.
[10]
B. P´erez and I. Porres, “An Overall Framework for Reasoning About
UML/OCL Models Based on Constraint Logic Programming and
MDA,” Intern.Journal on Advances in SW, vol. 7, no. 1&2, pp. 370–
380, 2014.
[11]
S. Sen, B. Baudry, and D. Precup, “Partial Model Completion in
Model Driven Engineering using Constraint Logic Programming,” in
Proc. of the International Conference on Applications of Declarative
Programming and Knowledge Management (INAP’07), 2007, pp. –.
[12]
E. K. Jackson, T. Levendovszky, and D. Balasubramanian, “Automat-
ically reasoning about metamodeling,” Software & Systems Modeling,
pp. 1–15, february, 2013.
[13]
B. P´erez and I. Porres, “Reasoning About UML/OCL Models Using
Constraint Logic Programming and MDA,” in Proc. of the Eighth In-
ternational Conference on Software Engineering Advances (ICSEA’13),
October 2013, pp. 228–233, ISBN: 978-1-61208-304-9.
[14]
FORMULA - Modeling Foundations, Website: http://research.micro–
soft.com/en-us/projects/formula/. Last visited on August 2014.
[15]
H. Baumann, P. Grassle, and P. Baumann, UML 2. 0 in Action: A
Project-based Tutorial.
Packt Publishing, 2005.
[16]
MOFScript Home page, Website: http://www.eclipse.org/gmt/mofscript/.
Last visited on August 2014.
[17]
The Eclipse UML2 project, website: http://www.eclipse.org/modeling
/mdt/?project=uml2. Last visited on August 2014.
[18]
K. Anastasakis, B. Bordbar, G. Georg, and I. Ray, “UML2Alloy: A
Challenging Model Transformation,” in Proc. of the 10th International
Conference on Model Driven Engineering Languages and Systems
(MoDELS’07), ser. LNCS, vol. 4735.
Springer, 2007, pp. 436–450.
[19]
D. Jackson, “Automating ﬁrst-order relational logic,” SIGSOFT Softw.
Eng. Notes, vol. 25, no. 6, pp. 130–139, 2000.
39
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-367-4
ICSEA 2014 : The Ninth International Conference on Software Engineering Advances

