Reasoning about Domain Semantics over
Relations, Bags, Partial Relations and Partial Bags
Sebastian Link
Department of Computer Science
The University of Auckland
Auckland, New Zealand
s.link@auckland.ac.nz
Abstract—Quality database schemata must capture both the
structure and semantics of the domain of interest. Classes of
data dependencies have been studied extensively to model do-
main semantics. Traditionally, the theory of data dependencies
has been limited to relations. In practice, duplicate and partial
information are permitted to occur in database instances. These
features are supported to make data processing more efﬁcient.
We study the implication problem for an expressive class of
data dependencies over all data structures that arise from
the two features features. These include bags that permit
duplicate tuples, partial relations that permit null marker
occurrences, and partial bags that permit duplicate tuples
and null marker occurrences. The class of data dependencies
studied encompasses uniqueness constraints, functional and
multivalued dependencies. We establish axiomatizations and
sharp upper bounds for the worst-case time complexity of the
implication problem.
Keywords-Data models; Database design; Database seman-
tics; Decision problems; Mathematical logic.
I. INTRODUCTION
A database system manages a collection of persistent
information in a shared, reliable, effective and efﬁcient
way. Most commercial database systems are still founded
on the relational model of data [1]. Data administrators
utilize various classes C of ﬁrst-order formulae, called data
dependencies, to restrict the relations in the database to
those considered meaningful to the application domain at
hand. A central problem in logic, mathematics and computer
science is the implication problem of such classes C [2]. In
terms of data dependencies the problem is to decide whether
for an arbitrarily given set Σ ∪ {ϕ} of data dependencies
in C, Σ implies ϕ, i.e., whether every database instance
that satisﬁes all the elements of Σ also satisﬁes ϕ. For
databases speciﬁcally, solutions to the implication problem
are essential for their modeling and design [3], and can
advance many data processing tasks such as updates [4],
queries [5], security [6], maintenance [7], cleaning [8],
integration [9] and exchange [10]. According to [11] the
combined class of uniqueness constraints (UCs) and func-
tional dependencies (FDs) captures around two-thirds, and
the class of multivalued dependencies (MVDs) around one-
quarter of all uni-relational dependencies (those deﬁned over
a single relation schema) that arise in practice. In particular,
MVDs are frequently exhibited in database applications
[12], e.g., after de-normalization or in views [3]. The next
example illustrates how instances of the implication problem
arise naturally from table deﬁnitions in SQL [13], which has
been the industry standard for deﬁning and querying data for
the last three decades.
Example 1: Consider a table deﬁnition SUPPLIES with
column headers A(rticle), S(upplier), L(ocation) and C(ost).
The intention is to collect information about suppliers that
deliver articles from a location at a certain cost.
CREATE TABLE SUPPLIES (
Article CHAR[20],
Supplier VARCHAR NOT NULL,
Location VARCHAR NOT NULL,
Cost CHAR[8]);
Suppose the database management system enforces the
following set Σ of constraints: The FD A → S says that for
every article there is at most one supplier, the FD AL → C
says that the cost is determined by the article and the
location, and the MVD S ↠ L says that the locations are
determined by the supplier independently of the articles and
costs. Do the following semantically meaningful constraints
need to be enforced explicitly, or are they already enforced
implicitly by Σ: i) the UC u(AL), ii) the FD A → C, and
iii) the MVD A ↠ L?
SQL table deﬁnitions permit occurrences of duplicate
tuples and occurrences of a null marker in columns declared
NULL. While these two features are meant to make data
processing more efﬁcient, they do distinguish the 32 billion
US dollar market of SQL-based relational database systems
from Codd’s relational model of data. In this paper, we
investigate in detail the impact of these two features on
the implication problem of the combined class of UCs, FDs
and MVDs. In fact, we use these two features to study the
implication problem over the four resulting data structures:
relations, bags, partial relations and partial bags. Relations
are sets of total tuples. That is, all columns are NOT NULL
by default and duplicate tuples are not permitted to occur.
Example 2: Suppose we use relations to instantiate the
SQL table deﬁnition of Example 1. Then the constraints i),
1
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-185-4
DBKDA 2012 : The Fourth International Conference on Advances in Databases, Knowledge, and Data Applications

ii) and iii) are all enforced implicitly by Σ. In particular, the
FDs A → S and AL → C imply the FD AL → ALCS.
Since duplicate tuples are identiﬁed in sets of tuples, the
latter FD is equivalent to the uniqueness constraint u(AL).
Bags of tuples are more general than relations, i.e., sets of
tuples. In fact, relations are bags where no duplicate tuples
can occur, i.e., no two different tuples can occur that have
matching values on all attributes.
Example 3: Suppose we use bags of tuples to instantiate
the SQL table deﬁnition of Example 1. Then the seman-
tically meaningful constraints ii) and iii) are still enforced
implicitly by Σ. However, the uniqueness constraint u(AL)
is not enforced implicitly by Σ. Indeed, the bag
Article
Supplier
Location
Cost
Kiwi
Kiwifruitz
Tauranga
3
Kiwi
Kiwifruitz
Tauranga
3
satisﬁes Σ but violates u(AL).
Partial relations are sets of partial tuples t, i.e., t(A)
can carry a null marker occurrence on every attribute A.
Here, we adapt the most general interpretation of a null
marker, denoted by ni, i.e., the no information interpretation
[14], [15], [16]. In general it may happen that two different
tuples subsume one another. That is, there are two tuples
t and t′ such that for every attribute A it holds that
t′(A) = ni or t′(A) = t(A). We require partial relations
to be subsumption-free. This requirement is a natural gen-
eralization of relations which are duplicate-free, and is in
line with previous research [14], [15], [16]. Furthermore, in
SQL one can deﬁne any attribute A as NOT NULL. That is,
for every partial tuple t it must hold that t(A) ̸= ni. We
say that the set of attributes declared NOT NULL forms the
null-free subschema of the underlying schema.
Example 4: Suppose we use partial relations to instantiate
the SQL table deﬁnition of Example 1. The UC u(AL)
is implied by Σ since duplicate tuples are not allowed in
partial relations. For the semantically meaningful constraints
ii) and iii) it depends on the null-free subschema whether
they are enforced implicitly by Σ. If the null-free subschema
is {S, L}, then both ii) and iii) are implied by Σ. However,
if it is {A, L, C}, then the following partial relation
Article Supplier
Location
Cost
Kiwi
ni
Tauranga
3
Kiwi
ni
Gisborne
4
satisﬁes Σ, but violates the FD A → C and MVD A ↠ L.
Finally, partial bags are bags of partial tuples. In partic-
ular, partial bags may contain two tuples that subsume one
another. This includes the special case of duplicate tuples.
Example 5: Suppose we use partial bags to instantiate
our SQL table deﬁnition. Then the situation is similar to
Example 4, but the UC u(AL) is not implied by Σ.
Contributions. We establish ﬁnite axiomatizations for the
combined class of uniqueness constraints, functional and
multivalued dependencies over bags and partial bags. In
particular, the presence of duplicate (partial) tuples makes it
necessary to include the class of uniqueness constraints into
the combined class. That is, in the presence of duplicate
tuples, uniqueness constraints are no longer covered by
functional dependencies - in contrast to (partial) relations.
Our main proof arguments for the case of (partial) bags uses
a reduction to the case of (partial) relations, respectively. The
beneﬁt of these reductions is to pinpoint exactly which new
inference rules are required to gain completeness in each of
the cases. Our proof techniques also enable us to establish
sharp upper bounds on the worst-case time complexity of
the associated decision problems. In particular, the bounds
match the currently best known bound for the special case of
relations known from the literature. Our ﬁndings establish a
complete picture of how reasoning about domain semantics
in different data structures can be automated effectively
and efﬁciently. Our most general case addresses partial
bags, which are used to instantiate SQL table deﬁnitions
in practice. Our ﬁndings close the gap between existing
database theory and database practice. The class of data
dependencies studied is treated in most introductory text-
books on databases; unfortunately for the case of relations
only. Our results provide therefore new insight for students
and researchers on the impact of popular data structures
on the reasoning about domain semantics. Finally, note that
more expressive classes of data dependencies, such as join
dependencies, are not ﬁnitely axiomatizable [17].
Organization. We brieﬂy summarize related work in
Section II. The general data model of partial bag schemata
is introduced in Section III. The known special cases from
the literature are reviewed in Section IV. In Section V we
establish axiomatizations for the general case of partial bag
schemata. Our proof argument enables us to establish a sharp
upper bound on the worst-case time complexity in Section
VI. We comment on the applicability of our theories in
practice in Section VII. We conclude in Section VIII where
we also comment on future work.
II. RELATED WORK
Data dependencies can capture the semantics of the
domain of interest in the target database. Therefore, data
dependencies are essential to database design, and the main-
tenance of the database during its lifetime, and all major data
processing tasks, cf. [3], [18].
In the relational model, a UC u(X) over relation schema
R is satisﬁed by a relation if and only if the relation
satisﬁes the FD X → R. Hence, in this context it sufﬁces
to study the class of FDs and MVDs. Beeri, Fagin and
Howard established the ﬁrst axiomatization for FDs and
MVDs [19], [20], [21]. The associated implication problem
can be decided in time almost-linear in the input [22].
2
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-185-4
DBKDA 2012 : The Fourth International Conference on Advances in Databases, Knowledge, and Data Applications

One of the most important extensions of the relational
model [1] is partial information [23]. This is mainly due to
the high demand for the correct handling of such information
in real-world applications. While there are several possible
interpretations of a null marker, many of the previous work
on data dependencies is based on Zaniolo’s no information
interpretation [14], [15], [24], [16]. Atzeni and Morfuni
established an axiomatization for the class of FDs over
partial relations [14]. In particular, they did not permit
subsumption between partial tuples and did not consider
MVDs. K¨ohler and Link investigated UCs and FDs over
bags, but considered neither null markers nor MVDs [25].
Finally, Hartmann and Link established an axiomatization
for the class of FDs and MVDs over partial relations [26].
III. THE SQL DATA MODEL
In this section we introduce the general SQL data model,
which is based on partial bags. We utilize this general
model to deﬁne the remaining three cases of relations, partial
relations and bags as important special cases.
A. Structures and data structures
Let A = {A1, A2, . . .} be a (countably) inﬁnite set of
distinct symbols, called attributes. A partial bag schema
is a pair S = (S, nfs(S)) consisting of a ﬁnite non-empty
subset S of A, and a subset nfs(S) ⊆ S. Each attribute A is
associated with a countably inﬁnite domain dom(A), which
represents the possible values that can occur in the column A
represents. To encompass partial information every attribute
may have a null marker, denoted by ni ∈ dom(A). The
intention of ni is to mean no information. This interpre-
tation can therefore model non-existing as well as existing
but unknown information [14], [16], but it cannot distinguish
between the two - as is the exact case in SQL.
For attribute sets X and Y we may write XY for the set
union X ∪ Y . If X = {A1, . . . , Am}, then we may write
A1 · · · Am for X. In particular, we may write simply A to
represent the singleton {A}. A partial tuple over S is a
function t : S →
S
A∈S
dom(A) with t(A) ∈ dom(A) for
all A ∈ S, and t(A) ̸= ni for all A ∈ nfs(S). The null
marker occurrence t(A) = ni associated with an attribute
A in a partial tuple t means that no information is available
about the attribute A for the partial tuple t. For X ⊆ S let
t(X) denote the restriction of the partial tuple t over S to
X. A partial tuple t is said to be X-total, if for all A ∈ X
it holds that t(A) ̸= ni. Hence, every partial tuple over S
is nfs(S)-total. A partial bag over S is a ﬁnite multi-set of
partial tuples over S.
A bag schema is a partial bag schema (S, nfs(S)) where
nfs(S) = S. Here, we may simply write S instead of (S, S).
Consequently, all partial tuples t over a bag schema S are
S-total partial tuples, i.e., for all A ∈ S it holds that t(A) ̸=
ni. In this case, we may also speak of total tuples or just
tuples.
For two partial tuples t and t′ we say that t subsumes
t′, if for every attribute A it holds that t′(A) = ni or
t′(A) = t(A). A partial relation over (S, nfs(S)) is a partial
bag that is subsumption-free, i.e., there are no two different
partial tuples in the partial relation that subsume one another.
We call a partial bag schema (S, nfs(S)) a partial relation
schema if we restrict all partial bags over (S, nfs(S)) to be
partial relations.
Finally, a relation schema is a partial relation schema
(S, nfs(S)) where nfs(S) = S. Again, we may simply write
S instead of (S, S). Consequently, every partial relation over
a relation schema is a relation, i.e., a set of tuples.
Example 6: The
following
database
instance
over
(SUPPLIES,
nfs(SUPPLIES)),
where
nfs(SUPPLIES)
=
{Article, Location, Cost}, is a partial bag that is not a
partial relation.
Article
Supplier
Location Cost
Kiwi
Kiwifruitz Gisborne
4
Kiwi
ni
Gisborne
4
Indeed, the ﬁrst tuple subsumes the second tuple.
B. Semantics
In what follows we deﬁne the syntax and semantics
of uniqueness constraints, functional and multivalued de-
pendencies in the context of partial bags. We will brieﬂy
comment on the restrictions to the special cases of relations,
partial relations and bags.
Following the SQL standard a uniqueness constraint (UC)
over a partial bag schema S = (S, nfs(S)) is an expression
u(X) where X ⊆ S. A partial bag b over S is said to
satisfy the uniqueness constraint u(X) over S (|=b u(X))
if and only if for all partial tuples t, t′ ∈ b the following
holds: if t ̸= t′ and t and t′ are both X-total, then there is
some A ∈ X such that t(A) ̸= t′(A). Note that the notion
of a uniqueness constraint over bag and relation schemata
matches the well-known notion of a key.
Functional dependencies are important for the relational
[1] and other data models [27], [28], [29], [30], [31].
Generalizing notions by Lien [15], a functional dependency
(FD) over a partial bag schema S is a statement X → Y
where X, Y ⊆ S. The FD X → Y over S is satisﬁed by
a partial bag b over S (|=b X → Y ) if and only if for all
t, t′ ∈ b the following holds: if t and t′ are both X-total
and t(X) = t′(X), then t(Y ) = t′(Y ). We call X → Y
trivial whenever Y ⊆ X, and non-trivial otherwise. The
general FD deﬁnition is consistent with the no information
interpretation [14], [15]. For bag and relation schemata the
notion of a functional dependency reduces to that of the
standard deﬁnition of a functional dependency [18], and so
is a sound generalization. Note that any partial relation b
satisﬁes the FD X → S over S if and only if b satisﬁes the
UC u(X). This is invalid for bags and partial bags.
3
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-185-4
DBKDA 2012 : The Fourth International Conference on Advances in Databases, Knowledge, and Data Applications

Generalizing notions by Lien [15], a multivalued de-
pendency (MVD) over S is a statement X ↠ Y where
X, Y ⊆ S. The MVD X ↠ Y over S is satisﬁed by a
partial bag b over S, denoted by |=b X ↠ Y , if and only
if for all t, t′ ∈ b the following holds: if t and t′ are both
X-total and t(X) = t′(X), then there is some ¯t ∈ b such
that ¯t(XY ) = t(XY ) and ¯t(X(S − Y )) = t′(X(S − Y )).
We call X ↠ Y trivial whenever Y ⊆ X or XY = S,
and non-trivial otherwise. This MVD deﬁnition is consistent
with the no information interpretation [15]. For bag and
relation schemata the notion of an MVD reduces to that of
the standard deﬁnition of an MVD [32], and so is a sound
generalization.
Example 7: Consider
the
partial
bag
schema
(SUPPLIES, nfs(SUPPLIES))
where
nfs(SUPPLIES)
=
{Supplier, Location}. The partial relation
Article Supplier
Location
Cost
Kiwi
ni
Tauranga
3
Kiwi
ni
Gisborne
4
satisﬁes the UC u(AL), the FDs A → S and AL → C, and
the MVD S ↠ L. It violates the UC u(A), the FD A → C
and the MVD A ↠ L.
C. Semantic implication and syntactic inference
For a set Σ of constraints over some partial bag schema
S, we say that a partial bag b over S satisﬁes Σ (|=b Σ) if b
satisﬁes every σ ∈ Σ. If for some σ ∈ Σ, b does not satisfy
σ we say that b violates σ (and violates Σ) and write ̸|=b σ
(̸|=b Σ). In the general case of partial bags we are interested
in the combined class C of UCs, FDs and MVDs.
Constraints interact with one another. Let S be a partial
bag schema, and let Σ ∪ {ϕ} be a set of UCs, FDs and
MVDs over S. We say that Σ implies ϕ (Σ |= ϕ) if every
partial bag b over S that satisﬁes Σ also satisﬁes ϕ. If Σ
does not imply ϕ we may also write Σ ̸|= ϕ. For Σ we
let Σ∗ = {ϕ | Σ |= ϕ} be the semantic closure of Σ,
i.e., the set of all UCs, FDs and MVDs implied by Σ. In
order to determine the implied constraints we use a syntactic
approach by applying inference rules. These inference rules
have the form
premise
conclusion condition,
and inference rules without any premise are called axioms.
An inference rule is called sound, if whenever the set of
constraints in the premise of the rule are satisﬁed by some
partial bag over S and the constraints satisfy the conditions
of the rule, then the partial bag also satisﬁes the constraint
in the conclusion of the rule. We let Σ ⊢S ϕ denote the
inference of ϕ from Σ by S. That is, there is some sequence
γ = [σ1, . . . , σn] of constraints such that σn = ϕ and every
σi is an element of Σ or results from an application of an
inference rule in S to some elements in {σ1, . . . , σi−1}.
XY → Y
X → Y
XU → Y V
V ⊆U
(reﬂexivity, RF)
(FD augmentation, AF)
X → Y
Y → Z
X → Z
(transitivity, T ′
F )
X ↠ Y
X ↠ S − Y
X ↠ Y
XU ↠ Y V V ⊆ U
(S-complementation, CS
M)
(MVD augmentation, AM)
X ↠ Y
Y ↠ Z
X ↠ Z − Y
(pseudo-transitivity, T ′
M)
X → Y
X ↠ Y
X ↠ Y
Y → Z
X → Z − Y
(MVD implication, IFM) (mixed pseudo-transitivity, T ′
FM)
Table I
AXIOMATIZATION R OVER RELATION SCHEMA S
For a ﬁnite set Σ, let Σ+
S = {ϕ | Σ ⊢S ϕ} be its syntactic
closure under inferences by S. A set S of inference rules
is said to be sound (complete) for the implication of UCs,
FDs and MVDs if for every partial bag schema S and for
every set Σ of UCs, FDs and MVDs over S we have Σ+
S ⊆
Σ∗ (Σ∗ ⊆ Σ+
S). The (ﬁnite) set S is said to be a (ﬁnite)
axiomatization for the implication of UCs, FDs and MVDs
if S is both sound and complete.
IV. AXIOMATIZATIONS FOR RELATIONS AND PARTIAL
RELATIONS
In this section we brieﬂy review a well-known axiomati-
zation for the class of FDs and MVDs over relations. We
then review a recent axiomatization for the same class of
data dependencies over partial relations.
A. Relations
Beeri, Fagin, and Howard [19] established the ﬁrst ax-
iomatization for the class of FDs and MVDs over relations.
The axiomatization R of Table I is based on the (mixed)
pseudo-transitivity rules by Zaniolo [21].
The following example demonstrates the use of the in-
ference rules to infer some data dependencies implied over
relations. Firstly, it highlights how in the absence of partial
data, the transitivity rules can be applied soundly. Secondly,
it highlights how in the absence of duplicate tuples, FDs can
be used to infer uniqueness constraints.
Example 8: Consider the relation schema SUPPLIES and
the set Σ containing the FDs A → S, AL → C and the
MVD S ↠ L.
4
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-185-4
DBKDA 2012 : The Fourth International Conference on Advances in Databases, Knowledge, and Data Applications

XY → Y
X → Y Z
X → Y
(reﬂexivity, RF)
(decomposition, DF)
X → Y
X → Z
X → Y Z
(FD union, UF)
X ↠ Y
X ↠ S − Y
X ↠ Y
X ↠ Z
X ↠ Y Z
(S-complementation, CS
M)
(MVD union, UM)
X ↠ W
Y ↠ Z
X ↠ Z − W
Y ⊆X(W ∩S′)
(null pseudo-transitivity, TM)
X → Y
X ↠ Y
X ↠ W
Y → Z
X → Z − W
Y ⊆X(W ∩S′)
(MVD implication, IFM) (null mixed pseudo-transitivity, TFM)
Table II
AXIOMATIZATION pR OVER PARTIAL RELATION SCHEMA (S, S′)
An application of the MVD implication rule IFM to A →
S results in the MVD A ↠ S. We can apply the pseudo-
transitivity rule T ′
M to the MVDs A ↠ S and S ↠ L to
infer the MVD A ↠ L.
An application of the MVD augmentation rule AM to A ↠
L yields the MVD A ↠ AL. An application of the mixed
pseudo-transitivity rule T ′
FM to the MVD A ↠ AL and the
FD AL → C results in the FD A → C.
An application of the FD augmentation rule AF to A → S
yields the FD AC → SC, and an application of the same
rule to the FD AL → C yields the FD AL → AC. An
application of the transitivity rule T ′
F to the FDs AL → AC
and AC → SC results in the FD AL → SC. A ﬁnal
application of the FD augmentation rule AF to AL → SC
yields the FD AL → ACLS. Note that over a relation
schema R the FD X → R is satisﬁed by the same relations
as the UC u(AL). Thus, the last inference yields the UC
u(AL).
B. Partial relations
Over partial relations, Hartmann and Link recently es-
tablished the axiomatization pR for the class of FDs and
MVDs [26]. As Example 4 shows, the choice of a null-
free subschema has an impact on the data dependencies
implied. In particular, the presence of partial data requires
that the applicability of the (mixed) pseudo-transitivity rules
are suitably restricted.
The next example illustrates applications of the null
(mixed) pseudo-transitivity rules to infer implied data de-
pendencies. Note how changes in the null-free subschema
inﬂuence the applicability of these rules, cf. Example 4.
Example 9: Consider
the
partial
relation
schema
(SUPPLIES, {SL}) and the set Σ containing the FDs
A → S, AL → C and the MVD S ↠ L.
An application of the MVD implication rule IFM to A →
S results in the MVD A ↠ S. We can apply the null pseudo-
transitivity rule T ′
M to the MVDs A ↠ S and S ↠ L to infer
the MVD A ↠ L. Note that S ∈ nfs(SUPPLIES).
An application of the reﬂexivity axiom RF followed by an
application of the MVD implication rule IFM results in the
MVD A ↠ A. An application of the MVD union rule UM
to A ↠ A and A ↠ L results in the MVD A ↠ AL. An
application of the null mixed pseudo-transitivity rule TFM to
the MVD A ↠ AL and the FD AL → C results in the FD
A → C. Again, note here that L ∈ nfs(SUPPLIES).
V. AXIOMATIZATIONS FOR BAGS AND PARTIAL BAGS
In this section we establish the ﬁrst main results of this
article, i.e., ﬁnite axiomatizations for the combined class of
UCs, FDs, and MVDs over bags and over partial bags. We
prove the general case of partial bags in detail.
A. Partial bags
Let pB denote the set of inference rules in Table IV. We
ﬁrst establish the soundness of the rules in pB.
Lemma 1: The set pB of inference rules is sound.
Proof: The soundness of the rules in pR has been
established in previous work [26]. It remains to show the
soundness of the FD implication rule IUF and the null
pullback rule PUF.
For the soundness of the FD implication rule IUF assume
there is some partial bag b that violates the FD X → Y .
Then there must be two different tuples t, t′ ∈ b that are
X − total and t(X) = t′(X). Consequently, b also violates
the UC u(X).
For the soundness of the null pullback rule PUF assume
there is some partial bag b over S = (S, S′) that violates
the uniqueness constraint u(X). Then there must be two
different tuples t, t′ ∈ b that are X − total and t(X) =
t′(X). If b violates the FD X → Y , then we are done.
Otherwise, it follows that t(Y ) = t′(Y ). If Y ̸⊆ XS′, then
we are done. Otherwise, it follows that t and t′ are both
Y -total. Consequently, b violates the UC u(Y ).
For the completeness of pB we use the result that the
set pR forms an axiomatization for FDs and MVDs over
partial relations [26]. In fact, the completeness of pB follows
from that of pR and the following lemma. For a set Σ of
UCs, FDs, and MVDs over partial bag schema (S, nfs(S))
let Σ[FM] = {X → S | u(X) ∈ Σ} ∪ {X → Y | X → Y ∈
Σ} ∪ {X ↠ Y | X ↠ Y ∈ Σ}.
Lemma 2: Let Σ be a set of UCs, FDs and MVDs over
the partial bag schema (S, S′). Then the following hold:
1) Σ |= X → Y if and only if Σ[FM] |= X → Y ,
2) Σ |= X ↠ Y if and only if Σ[FM] |= X ↠ Y ,
5
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-185-4
DBKDA 2012 : The Fourth International Conference on Advances in Databases, Knowledge, and Data Applications

XS′
S − XS′
0 · · · 0
ni · · · ni
0 · · · 0
ni · · · ni
Table III
THE PARTIAL BAG bX
3) Σ |= u(X) if and only if Σ[FM] |= X → S and there
is some u(Z) ∈ Σ such that Z ⊆ XS′.
Proof: The if directions of 1) and 2) follows straight
from the soundness of the FD implication rule IUF. For the
only if direction of 2), for example, assume that there is a
partial bag b over S such that |=b Σ[FM] and ̸|=b X ↠ Y .
Then it follows from a result in [26] that there are two tuples
t, t′ ∈ b such that |={t,t′} Σ[FM] and ̸|={t,t′} X ↠ Y .
Consequently, t(X) = t′(X), and t, t′ are X-total, and for
some A ∈ S − X, t(A) ̸= t′(A). Suppose there is some
u(Z) ∈ Σ such that ̸|={t,t′} u(Z). Then t, t′ are Z-total and
t(Z) = t′(Z). However, |={t,t′} Z → S and thus t(S) =
t′(S), a contradiction. Consequently, |={t,t′} Σ and ̸|={t,t′}
X ↠ Y . The remaining direction of 1) is similar.
It remains to show 3). Suppose that Σ[FM] |= X → S and
there is some u(Z) ∈ Σ such that Z ⊆ XS′. Then it follows
that X → Z is implied by Σ[FM] due to the soundness of the
decomposition rule DF. The soundness of the null pullback
rule PUF allows us to derive the fact that u(X) is implied
by Σ. It remains to show the only if direction of 3).
From Σ |= u(X) we conclude Σ |= X → S by soundness
of the FD implication rule IUF. According to 1) it follows
that Σ[FM] |= X → S. It remains to show that there is some
u(Z) ∈ Σ such that Z ⊆ XS′. Assume to the contrary
that for all u(Z) ∈ Σ we have Z ̸⊆ XS′. Under this
assumption we will derive the contradiction that Σ ̸|= u(X)
by constructing a two-tuple partial bag bX that satisﬁes
Σ and violates u(X). Indeed, bX is the bag in Table III.
Clearly, it satisﬁes Σ[FM]. Moreover, under our current
assumption it is true that for every u(Z) ∈ Σ we have
Z∩(S−XS′) ̸= ∅. Thus, |=bX u(Z) for all u(Z) ∈ Σ. It also
follows that ̸|=bX u(X). Hence, Σ ̸|= u(X), a contradiction.
Consequently, our assumption must have been wrong and
there is some u(Z) ∈ Σ such that Z ⊆ XS′.
Theorem 1: The set pB of inference rules forms a ﬁnite
axiomatization for the implication of UCs, FDs and MVDs
over partial bags.
Proof: The soundness of pB was shown in Lemma 1.
We establish the completeness of pB by showing that for
an arbitrary partial bag schema S = (S, nfs(S)), and an
arbitrary set Σ ∪ {ϕ} of UCs, FDs and MVDs over S the
following holds: if Σ |= ϕ, then Σ ⊢pB ϕ. We consider two
cases. In case (1) ϕ denotes the FD X → Y or the MVD
X ↠ Y . Then we know by Lemma 2 that Σ[FM] |= ϕ holds.
From the completeness of pR for the implication of FDs and
XY → Y
X → Y Z
X → Y
(reﬂexivity, RF)
(decomposition, DF)
X → Y
X → Z
X → Y Z
(FD union, UF)
X ↠ Y
X ↠ S − Y
X ↠ Y
X ↠ Z
X ↠ Y Z
(S-complementation, CS
M)
(MVD union, UM)
X ↠ W
Y ↠ Z
X ↠ Z − W
Y ⊆X(W ∩S′)
(null pseudo-transitivity, TM)
u(X)
X → Y
X → Y
u(Y )
u(X)
Y ⊆XS′
(FD implication, IUF)
(null pullback, PUF)
X → Y
X ↠ Y
X ↠ W
Y → Z
X → Z − W
Y ⊆X(W ∩S′)
(MVD implication, IFM) (null mixed pseudo-transitivity, TFM)
Table IV
AXIOMATIZATION pB OVER PARTIAL BAG SCHEMA (S, S′)
MVDs over partial relations we conclude that Σ[FM] ⊢B ϕ.
Since pR ⊆ pB holds we know that Σ[FM] ⊢pB ϕ holds,
too. The FD implication rule IUF shows for all σ ∈ Σ[FM]
that Σ ⊢pB σ holds. Consequently, we have Σ ⊢pB ϕ. This
concludes case (1). In case (2) ϕ denotes the UC u(X). From
Σ |= u(X) we conclude by Lemma 2 that there is some
u(Z) ∈ Σ such that Z ⊆ XS′ holds. We also conclude
from Σ |= u(X) that Σ |= X → Z holds by soundness
of the FD implication rule IUF. From case (1) it follows
that Σ ⊢pB X → Z holds. A ﬁnal application of the null
pullback rule PUF shows that Σ ⊢pB ϕ holds.
B. Bags
The set B of inference rules in Table V forms a ﬁnite ax-
iomatization for the combined class of UCs, FDs, and MVDs
over bag schemata. The proofs necessary to establish this
axiomatization are similar to those we have just described in
detail for the case of partial bags. Indeed, the main argument
utilizes the fact that R forms an axiomatization for FDs and
MVDs over relations, and the restriction of Lemma 2 to bag
schemata. We omit the details. Finally, we would like to
emphasize the uniformity in generalizing the axiomatization
from partial relations to partial bags, and relations to bags.
It sufﬁces to add the FD implication rule IUF and, in case
of bags, the pullback rule P′
UF, and, in case of partial bags
the null pullback rule PUF, respectively.
6
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-185-4
DBKDA 2012 : The Fourth International Conference on Advances in Databases, Knowledge, and Data Applications

XY → Y
X → Y
XU → Y V
V ⊆U
(reﬂexivity, RF)
(FD augmentation, AF)
X → Y
Y → Z
X → Z
(transitivity, T ′
F )
X ↠ Y
X ↠ S − Y
X ↠ Y
XU ↠ Y V
V ⊆U
(S-complementation, CS
M)
(MVD augmentation, AM)
X ↠ Y
Y ↠ Z
X ↠ Z − Y
(pseudo-transitivity, T ′
M)
u(X)
X → Y
X → Y
u(Y )
u(X)
(FD implication, IUF)
(pullback, P′
UF)
X → Y
X ↠ Y
X ↠ Y
Y → Z
X → Z − Y
(MVD implication, IFM) (mixed pseudo-transitivity, T ′
FM)
Table V
AXIOMATIZATION B OVER BAG SCHEMA S
VI. SHARP UPPER BOUNDS FOR THE TIME COMPLEXITY
Lemma 2 also establishes an algorithmic characterization
of the associated implication problems. In fact, it sufﬁces
to compute the attribute set closure X∗
Σ[FM] := {A ∈
S | Σ[FM] ⊢pR X → A} and the dependency basis
DepBΣ[FM](X) of X with respect to Σ[FM] [26]. In par-
ticular, DepBΣ[FM](X) is the set of atoms for the Boolean
algebra (Dep(X), ⊆, ∪, ∩, (·)C
S, ∅, S) where Dep(X) = {Y ⊆
S | Σ[FM] ⊢pR X ↠ Y }. The size ||ϕ|| of ϕ is the total
number of attributes occurring in ϕ, and the size ||Σ|| of Σ
is the sum of ||σ|| over all elements σ ∈ Σ. For a set Σ
of FDs and MVDs let kΣ denote the number of MVDs in
Σ, pΣ denote the number of sets in the dependency basis
DepBΣ(X) of X with respect to Σ, ¯pΣ denote the number
of sets in DepBΣ(X) that have non-empty intersection with
the right-hand side of ϕ, and Σ[XS′] denote the set of FDs
and MVDs in Σ where the left-hand side is a subset of XS′.
The following result follows from Lemma 2 and the upper
time bound established by Galil for relational databases [22].
Theorem 2: Let ϕ denote either the UC u(X), the FD
X → Y , or the MVD X ↠ Y over the partial bag schema
S = (S, S′). The problem whether ϕ is implied by a set Σ
of UCs, FDs and MVDs over S can be decided in O(||Σ||+
min{kΣ[FM][XS′], log ¯pΣ[FM][XS′]} × ||Σ[FM][XS′]||) time.
The
bound
from
Theorem
2
becomes
O(||Σ|| +
min{kΣ[FM, log ¯pΣ[FM]}×||Σ[FM]||) time for bag schemata.
VII. APPLICABILITY OF THEORY IN PRACTICE
As mentioned in the introduction data dependencies are
essential in the design and maintenance of databases, and
useful for many data processing tasks. In database prac-
tice, e.g., in SQL database systems, partial and duplicate
information are allowed to occur. Partial information allows
users of the database system to enter information into the
database that is incomplete. The permission of duplicate
information is motivated by the costs of duplicate identi-
ﬁcation and removal. The applicability of the theory of data
dependencies in practice has been limited since partial and
duplicate information has been largely ignored in theory.
The current paper provides a summary of solutions to the
implication problem for the expressive class of uniqueness
constraints, functional and multivalued dependencies over
all data structures arising from the permission or prohibition
of partial and duplicate information. While the permission
of both features covers the general case of SQL databases,
many data engineers decide to specify at least a primary
key on their schemata, i.e., a set of attributes that are all
speciﬁed NOT NULL, and enforce uniqueness of tuples on
their projection. Thus, duplicate tuples are not allowed to
occur in database instances, which results in the usefulness
of our theory over partial relations. On the other hand, data
engineers may want to prohibit the occurrence of partial
information. This can be done by specifying all attributes
of the schema as NOT NULL. In this case, our theory over
bags is useful. Whenever the engineers decide to prohibit
partial and duplicate information by the methods above, the
theory over relations can be applied.
VIII. CONCLUSION AND FUTURE WORK
Quality database schemata must capture the structure and
semantics of their application domain. Database constraints
enforce the domain semantics within database systems.
They are therefore invaluable for database design and data
processing. Surprisingly, the existing theory of database
constraints has only addressed the idealized special case
where database instances are relations. In practice, e.g.,
SQL databases, duplicate tuples and partial information are
permitted to occur. In this article, a complete theory has
been established for reasoning about an expressive class of
database constraints over partial relations, bags and partial
bags. This closes the gap between theory and practice.
In future work it would be worthwhile to study many
application areas of database constraints, including database
normalization, query optimization, and data cleaning to
name a few. One may also study the implication problem
over different data structures, including trees and graphs, and
consider other classes of data dependencies, e.g., join and
inclusion dependencies. It is still an open problem whether
the implication problem of MVDs can be decided in linear
time. Finally, the study of Armstrong instances over different
data structures may also be rewarding [33], [34], [35].
7
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-185-4
DBKDA 2012 : The Fourth International Conference on Advances in Databases, Knowledge, and Data Applications

REFERENCES
[1] E. F. Codd, “A relational model of data for large shared data
banks,” Commun. ACM, vol. 13, no. 6, pp. 377–387, 1970.
[2] E. B¨orger, E. Gr¨adel, and Y. Gurevich, The classical decision
problem.
Heidelberg, Germany: Springer, 1997.
[3] S. Abiteboul, R. Hull, and V. Vianu, Foundations of
Databases.
Addison-Wesley, 1995.
[4] M. Arenas and L. Libkin, “An information-theoretic approach
to normal forms for relational and XML data,” J. ACM,
vol. 52, no. 2, pp. 246–283, 2005.
[5] A. Deutsch, L. Popa, and V. Tannen, “Query reformulation
with constraints,” SIGMOD Record, vol. 35, no. 1, pp. 65–73,
2006.
[6] J. Biskup, Security in computing systems.
Heidelberg,
Germany: Springer, 2009.
[7] A. Klug and R. Price, “Determining view dependencies using
tableaux,” ACM Trans. Database Syst., vol. 7, no. 3, pp. 361–
380, 1982.
[8] W. Fan, F. Geerts, X. Jia, and A. Kementsietsidis, “Condi-
tional functional dependencies for capturing data inconsis-
tencies,” ACM Trans. Database Syst., vol. 33, no. 2, 2008.
[9] A. Cali, D. Calvanese, G. De Giacomo, and M. Lenz-
erini, “Data integration under integrity constraints,” Inf. Syst.,
vol. 29, no. 2, pp. 147–163, 2004.
[10] R. Fagin, P. Kolaitis, R. Miller, and L. Popa, “Data exchange:
semantics and query answering,” Theor. Comput. Sci., vol.
336, no. 1, pp. 89–124, 2005.
[11] C. Delobel and M. Adiba, Relational database systems.
North Holland, 1985.
[12] M. Wu, “The practical need for fourth normal form,” in ACM
SIGCSE Conference, 1992, pp. 19–23.
[13] C. Date and H. Darwen, A guide to the SQL standard.
Reading, MA, USA: Addison-Wesley Professional, 1997.
[14] P. Atzeni and N. Morfuni, “Functional dependencies and
constraints on null values in database relations,” Information
and Control, vol. 70, no. 1, pp. 1–31, 1986.
[15] E. Lien, “On the equivalence of database models,” J. ACM,
vol. 29, no. 2, pp. 333–362, 1982.
[16] C. Zaniolo, “Database relations with null values,” J. Comput.
Syst. Sci., vol. 28, no. 1, pp. 142–166, 1984.
[17] S. Y. Petrov, “Finite axiomatization of languages for represen-
tation of system properties: Axiomatization of dependencies,”
Information Sciences, vol. 47, pp. 339–372, 1989.
[18] B. Thalheim, Dependencies in relational databases. Teubner,
1991.
[19] C. Beeri, R. Fagin, and J. H. Howard, “A complete axioma-
tization for fds and mvds in database relations,” in SIGMOD
Conference.
ACM, 1977, pp. 47–61.
[20] S. Hartmann and S. Link, “On a problem of Fagin concern-
ing multivalued dependencies in relational databases,” Theor.
Comput. Sci., vol. 353, no. 1-3, pp. 53–62, 2006.
[21] C. Zaniolo, “Mixed transitivity for functional and multival-
ued dependencies in database relations,” Inf. Process. Lett.,
vol. 10, no. 1, pp. 32–34, 1980.
[22] Z. Galil, “An almost linear-time algorithm for computing a
dependency basis in a relational database,” J. ACM, vol. 29,
no. 1, pp. 96–102, 1982.
[23] T. Imielinski and W. Lipski Jr., “Incomplete information in
relational databases,” J. ACM, vol. 31, no. 4, pp. 761–791,
1984.
[24] S. Link, “On the implication of multivalued dependencies in
partial database relations,” Int. J. Found. Comput. Sci., vol. 19,
no. 3, pp. 691–715, 2008.
[25] H. K¨ohler and S. Link, “Armstrong axioms and Boyce-Codd-
Heath normal form under bag semantics,” Inf. Process. Lett.,
vol. 110, no. 16, pp. 717–724, 2010.
[26] S. Hartmann and S. Link, “When data dependencies over SQL
tables meet the Logics of Paradox and S-3,” in Proceedings
of the 29th ACM SIGMOD-SIGACT-SIGART Symposium on
Principles of Database Systems (PoDS), 2010, pp. 317–326.
[27] M. Arenas and L. Libkin, “A normal form for XML docu-
ments,” ACM Trans. Database Syst., vol. 29, no. 1, pp. 195–
232, 2004.
[28] S. Hartmann, S. Link, and K.-D. Schewe, “Weak functional
dependencies in higher-order data models,” in FoIKS Confer-
ence, 2004, pp. 134–154.
[29] S. Hartmann and S. Link, “Efﬁcient reasoning about a robust
XML key fragment,” ACM Trans. Database Syst., vol. 34,
no. 2, 2009.
[30] ——, “Numerical constraints on XML data,” Inf. Comput.,
vol. 208, no. 5, pp. 521–544, 2010.
[31] M. Vincent, J. Liu, and C. Liu, “Strong FDs and their
application to normal forms in XML,” ACM Trans. Database
Syst., vol. 29, no. 3, pp. 445–462, 2004.
[32] R. Fagin, “Multivalued dependencies and a new normal form
for relational databases,” ACM Trans. Database Syst., vol. 2,
no. 3, pp. 262–278, 1977.
[33] ——, “Armstrong databases,” IBM Research Laboratory, San
Jose, California, USA, Tech. Rep. RJ3440(40926), 1982.
[34] S. Hartmann, M. Kirchberg, and S. Link, “Design by example
for SQL table deﬁnitions with functional dependencies,” The
VLDB Journal, doi: 10.1007/ s00778-011-0239-5,
2012.
[35] S. Hartmann, U. Leck, and S. Link, “On Codd families
of keys over incomplete relations,” The Computer Journal,
vol. 54, no. 7, pp. 1166–1180, 2011.
8
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-185-4
DBKDA 2012 : The Fourth International Conference on Advances in Databases, Knowledge, and Data Applications

