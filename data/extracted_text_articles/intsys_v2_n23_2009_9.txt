Run-Time Connector Synthesis for Autonomic
Systems of Systems
Radu Calinescu
Computing Laboratory, University of Oxford, UK
Radu.Calinescu@comlab.ox.ac.uk
Abstract—A key objective of autonomic computing is to re-
duce the cost and expertise required for the management of
complex IT systems. As a growing number of these systems
are implemented as hierarchies or federations of lower-level
systems, techniques that support the development of autonomic
systems of systems are required. This article introduces one such
technique, which involves the run-time synthesis of autonomic
system connectors. These connectors are speciﬁed by means of
a new type of autonomic computing policy termed a resource-
deﬁnition policy, and enable the dynamic realisation of collections
of collaborating autonomic systems, as envisaged by the original
vision of autonomic computing. We propose a framework for the
formal speciﬁcation of autonomic computing policies, and use
it to deﬁne the new policy type and to describe its application
to the development of autonomic system of systems. To validate
the approach, we present a sample data-centre application that
was built using connectors synthesised from resource-deﬁnition
policies.
Keywords—autonomic computing; systems of systems; auto-
nomic system connectors; model-driven development; automated
code generation.
I. INTRODUCTION
The original vision of autonomic computing was one of
self-managing systems comprising multiple inter-operating,
collaborating autonomic elements [2]. Like the components of
a biological system, these autonomic elements were envisaged
to contain well-differentiated resources and deliver services
to each other, to integrate seamlessly, and to work together
towards a global set of system-level objectives [2][3][4].
This view of self-managing systems as collections of col-
laborating autonomic elements is entirely consistent with the
way in which many of the most important computing systems
are designed, built and managed. Indeed, key computing
systems in areas ranging from transportation and healthcare
to aerospace and defence can no longer be implemented as
monolithic systems. Instead, the capabilities and functionality
that these systems are required to provide can only be achieved
through employing collections of collaborative, heterogeneous
and autonomously-operating systems [5][6].
Thus, the characteristics of the computing systems that
would beneﬁt most from self-managing capabilities, and the
vision behind the sustained research efforts in the area of
autonomic computing are well aligned. Nevertheless, the same
is hardly true about the outcome of these efforts: what the
overwhelming majority of the autonomic computing research
to date has produced is a collection of methods, tools and com-
ponents for the development of monolithic autonomic systems;
and exemplars of such systems. The few notable exceptions
(overviewed in Section II) are either high-level architectures
[7] that reﬁne the “collection-of-autonomic-elements” archi-
tecture from the seminal autonomic computing paper [2],
or domain-speciﬁc instances of this architecture that involve
pre-deﬁned interactions between small numbers of autonomic
element types [8][9][10][11].
What is needed to bridge this gap between vision and reality
is a generic technique for the development of systems com-
prising multiple autonomic elements. The technique should
support autonomic elements that can join and leave the system
dynamically, which have local objectives to achieve in addition
to the overall system objectives, and whose characteristics are
unknown at system design time.
This extended version of [1] presents such a generic tech-
nique for the development of autonomic systems of systems by
means of a new type of autonomic computing policy. The new
policy type is termed a resource-deﬁnition policy, and deﬁnes
the autonomic system connectors through which the autonomic
manager at the core of an autonomic system should expose the
system to its environment.
As illustrated in Figure 1, the implementation of resource-
deﬁnition policies requires that the reference autonomic com-
puting loop from [2] is augmented with a synthesise step. Like
in the reference architecture, an autonomic manager monitors
the system resources through sensors, uses its knowledge to
analyse their state and to plan changes in their conﬁgurable
parameters, and implements (or “executes”) these changes
through effectors. Additionally, the autonomic manager mod-
ule that implements the “synthesise” step has the role to
dynamically generate connectors that expose the underlying
system to its environment as requested by the user-speciﬁed
resource-deﬁnition policies. This new functionality supports
the ﬂexible, run-time integration of existing autonomic sys-
tems into hierarchical, collaborating or hybrid autonomic
systems of systems, as illustrated in Figure 2.
The main contributions of the article are:
1) A theoretical framework for the formal, uniﬁed speciﬁ-
cation and analysis of autonomic computing policies.
2) The introduction of resource-deﬁnition policies within
this framework.
3) A set of automated code generation techniques for the
run-time synthesis of autonomic system connectors as
web services, and an augmented version of the author’s
general-purpose autonomic manager [12][13] that uses
these techniques to support the new policy type.
376
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

Managed resources
Autonomic
manager
Manageability adaptors
sensors
eﬀectors
Monitor
Analyse
Synthesise
Plan
Knowledge
sensors
eﬀectors
Policies
Execute
connector
Fig. 1.
Policy-based autonomic computing system whose control loop is
augmented with a connector synthesis step.
Fig. 2.
Resource-deﬁnition policies support the run-time integration of
autonomic systems into autonomic systems of systems.
4) A case study that illustrates the use of resource-
deﬁnition policies to implement an autonomic data-
centre application.
The remainder of the article starts with an overview of
related work in Section II, followed by the description of
our framework for the speciﬁcation of autonomic computing
policies in Section III. Section IV provides a formal intro-
duction to resource-deﬁnition policies. Section V describes
the prototype implementation of an autonomic manager that
handles resource-deﬁnition policies. System-of-systems appli-
cation development using the new policy type is discussed
in Section VI. Finally, Section VII provides an overview of
the problem addressed by our research work and the solution
proposed in the article, a summary of the case study used to
validate this solution, and a list of future work directions.
II. RELATED WORK
The idea to integrate a set of autonomic systems into a
higher-level autonomic system is not new. Indeed, the seminal
paper of Kephart and Chess [2] envisaged autonomic elements
that “interact with other elements and with human program-
mers via their autonomic managers”. More recently, this vision
was adapted and extended successfully to speciﬁc application
domains including aerospace [7] and “beyond 3G” networking
[10]. However, these extensions represent work in progress.
The high-level architecture proposed in [7] is also char-
acterised by pre-deﬁned types of interactions between their
autonomic elements. Due to the statically implemented sensor-
effector interfaces of their autonomic elements, the potential
applications of this approach are limited to those pre-planned
when the autonomic elements are originally developed.
The ongoing research project whose agenda is described in
[10] will employ event services to enable ﬂexible interactions
among autonomic network management elements. When this
work will be completed, the functionality of the resulting
framework will resemble that of the autonomic system con-
nectors described in our article, but in the area of autonomic
networking.
The work described in [9] proposes the use of hierar-
chical systems of event-driven sensors for monitoring and
symptom recognition within autonomic systems. The use of
dedicated policies to dynamically conﬁgure an instance of
the architecture in [9] is somewhat similar to our use of
resource-deﬁnition policies. However, unlike our approach
that supports the automated, run-time synthesis of connectors
comprising a combination of autonomic computing sensors
and effectors, the framework in [9] focuses exclusively on
sensors, and requires manual coding for the implementation
of these sensors.
Fully-ﬂedged instances of the data-centre autonomic sys-
tems comprising a pair of collaborating autonomic elements
and a two-level hierarchy of autonomic elements are described
in [8] and [11], respectively. The two successful domain-
speciﬁc applications by research teams at IBM Research
demonstrate the beneﬁts of partitioning the autonomic func-
tionality of large computing systems among multiple auto-
nomic elements. However, the use of hard-coded autonomic
manager interfaces limits the inter-operation of the autonomic
elements of the applications in [8][11] to pre-deﬁned types
of interactions. Furthermore, the need to implement each of
these interfaces upfront requires a signiﬁcant amount of coding
effort, and does not scale well to autonomic systems of systems
comprising more than a few autonomic elements (the systems
in [8] and [11] comprise two and three autonomic managers,
respectively).
In contrast with all these approaches, the use of resource-
deﬁnition policies makes possible the automated, runtime
generation of the sensor-effector connectors of an autonomic
element. Thus, the main advantage of our novel approach
to implementing autonomic systems of systems resides in
its unique ability to support the development of unforeseen
applications by dynamically (re)deﬁning the interfaces of
existing autonomic systems. As an added beneﬁt, the use of
resource-deﬁnition policies eliminates completely the effort
and costs associated with the manual implementation of these
interfaces.
The architecture and functionality of the autonomic systems
377
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

of systems built using resource-deﬁnition policies resemble
those of intelligent multi-agent systems [14]. However, the
standard approaches used for the development of multi-agent
systems differ signiﬁcantly from the approach proposed in
this paper. Thus, the typical approach to multi-agent system
development [14] involves deﬁning and implementing the
agent interfaces statically, before the components of the system
are deployed. In contrast, our approach has the advantage
that these interfaces can ﬂexibly be deﬁned at runtime, thus
enabling the development of applications not envisaged until
after the components of the system are deployed.
A uniﬁed framework that interrelates three types of auto-
nomic computing policies was introduced in [15]. Based on
the concepts of state and action (i.e., state transition) adopted
from the ﬁeld of artiﬁcial intelligence, this framework makes
possible the effective high-level analysis of the relationships
among action, goal and utility-function policies for autonomic
computing. Our policy speciﬁcation framework differs essen-
tially from the one in [15], which it complements through
enabling the formal speciﬁcation and analysis of all these
policy types in terms of the knowledge employed by the
autonomic manager that implements them.
III. A FRAMEWORK FOR THE FORMAL SPECIFICATION OF
AUTONOMIC COMPUTING POLICIES
Before introducing the new type of policy, we will formally
deﬁne the knowledge module of the autonomic manager in
Figure 1. This knowledge is a tuple that models the n ≥ 1
resources of the system and their behaviour:
K = (R1, R2, . . . , Rn, f),
(1)
where Ri, 1 ≤ i ≤ n is a formal speciﬁcation for the ith
system resource, and f is a model of the known behaviour of
the system. Each resource speciﬁcation Ri represents a named
sequence of mi ≥ 1 resource parameters, i.e.,
Ri = (resIdi, Pi1, Pi2, . . . , Pimi), ∀1 ≤ i ≤ n,
(2)
where resIdi is an identiﬁer used to distinguish between
different types of resources. Finally, for each 1 ≤ i ≤ n,
1 ≤ j ≤ mi, the resource parameter Pij is a tuple
Pij = (paramIdij, ValueDomainij, typeij)
(3)
where paramIdij is a string-valued identiﬁer used to distin-
guish the different parameters of a resource; ValueDomainij
is the set of possible values for Pij; and typeij ∈ {ReadOnly,
ReadWrite} speciﬁes whether the autonomic manager can
only read or can both read and modify the value of the pa-
rameter. The parameters of each resource must have different
identiﬁers, i.e.,
∀1 ≤ i ≤ n • ∀1 ≤ j < k ≤ mi • paramIdij ̸= paramIdik
We further deﬁne the state space S of the system as the
Cartesian product of the value domains of all its ReadOnly
resource parameters, i.e.,
S =

1≤i≤n

1≤j≤mi
typeij=ReadOnly
ValueDomainij
(4)
Similarly, the conﬁguration space C of the system is deﬁned
as the Cartesian product of the value domains of all its
ReadWrite resource parameters, i.e.,
C =

1≤i≤n

1≤j≤mi
typeij=ReadWrite
ValueDomainij
(5)
With this notation, the behavioural model f from (1) is a
partial function1
f : S × C 7→ S
such that for any (s, c) ∈ domain(f), f(s, c) represents the
expected future state of the system if its current state is s ∈ S
and its conﬁguration is set to c ∈ C. Presenting classes of
behavioural models that can support the implementation of
different autonomic computing policies is beyond the scope
of this paper; for a description of such models see [12].
The standard types of autonomic policies described in
[15][11][16] can be deﬁned using this notation as follows:
1) An action policy speciﬁes how the system conﬁguration
should be changed when the system reaches certain
state/conﬁguration combinations:
paction : S × C 7→ C.
(6)
A graphical representation of an action policy is shown
in Figure 3a. Note that an action policy can be im-
plemented even when the autonomic manager has no
knowledge about the behaviour of the managed re-
sources, i.e., when domain(f) = ∅ in eq. (1).
2) A goal policy partitions the state/conﬁguration combi-
nations for the system into desirable and undesirable:
pgoal : S × C → {true, false},
(7)
with the autonomic manager requested to maintain the
system in an operation area for which pgoal is true.
Figure 3b shows a graphical representation of a goal
policy within the theoretical framework introduced in
this section.
3) A utility policy (Figure 3c) associates a value with
each state/conﬁguration combination, and the autonomic
manager should adjust the system conﬁguration such as
to maximise this value:
putility : S × C → R.
(8)
Example 1
To illustrate the application of the notation
introduced so far, consider the example of an autonomic data-
centre comprising a pool of nServers ≥ 0 servers that need to
be partitioned among the N ≥ 1 services that the data-centre
can provide. Assume that each such service has a priority
and is subjected to a variable workload. The knowledge (1)
for this system can be expressed as a tuple
K = (ServerPool, Service1, . . . , Servicen, f)
(9)
1A partial function on a set X is a function whose domain is a subset of
X. We use the symbol 7→ to denote partial functions.
378
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

state (S)
conﬁguration (C)
S × C
(s, c)
s
c
c′
state (S)
conﬁguration (C)
S × C
(s, c)
s
c
state (S)
conﬁguration (C)
S × C
(s, c)
s
c
a) action policy: speciﬁes new system conﬁgurations c′ ∈ C
for certain state-conﬁguration combinations (s, c) ∈ S × C
a) goal policy: speciﬁes area of the S × C state-conﬁguration
space where the system should be maintained at all times
(i.e., the shaded area)
c) utility policy: speciﬁes the utility of each state-conﬁguration
combination (s, c) ∈ S × C for the system—darker
shading indicates higher utility
Fig. 3.
Graphical representation of the standard types of autonomic
computing policies
where the models for the server pool and for a generic service
i, 1 ≤ i ≤ N are given by:
ServerPool = ("serverPool",
("nServers", N, ReadOnly),
("partition", NN, ReadWrite))
Servicei = ("service",
("priority", N+, ReadOnly),
("workload", N, ReadOnly))
(10)
The state and conﬁguration spaces of the system are S =
N × (N+ × N)N and C
= NN, respectively. For sim-
plicity, we will consider that the workload of a service
represents the minimum number of operational servers it
requires to achieve its service-level agreement. Sample ac-
tion, goal and utility policies for the system are speciﬁed
below by giving their values for a generic data-centre state
s = (n, p1, w1, p2, w2, . . . , pN, wN) ∈ S and conﬁguration
c = (n1, n2, . . . , nN) ∈ C:
paction(s, c) = (⌈αw1⌉, ⌈αw2⌉, . . . , ⌈αwN⌉)
(11)
pgoal(s, c) = ∀1 ≤ i ≤ N •
(ni >0 =⇒ (∀1≤j ≤N • pj >pi =⇒ nj =⌈αwj⌉)) ∧

ni = 0 =⇒
N
P
j = 1
pj ≥ pi
nj = n

(12)
putility(s, c)=









−∞,
if
N
P
i=1
ni >n
N
P
i = 1
wi > 0
piu(wi, ni) − ϵ
N
P
i=1
ni,
otherwise
(13)
We will describe these policies one at a time. First, the action
policy (11) prescribes that ⌈αwi⌉ servers are allocated to
service i, 1 ≤ i ≤ N at all times. Notice how a redundancy
factor α ∈ (1, 2) is used in a deliberately simplistic attempt to
increase the likelihood that at least wi servers will be available
for service i in the presence of server failures. Also, the policy
is (over)optimistically assuming that n ≥ PN
i=1⌈αwi⌉ at all
times.
The
goal
policy
(12)
speciﬁes
that
the
desirable
state/conﬁguration combinations of the data-centre are those
in which two conditions hold for each service i, 1 ≤ i ≤ N.
The ﬁrst of these conditions states that a service should be
allocated servers only if all services of higher priority have
already been allocated ⌈αwi⌉ servers. The second condition
states that a service should be allocated no server only if all
n available servers have been allocated to services of higher
or equal priority.
Finally, the utility policy requires that the value of the
expression in (13) is maximised. The value −∞ in this
expression is used to avoid the conﬁgurations in which more
servers than the n available are allocated to the services.
When this is not the case, the value of the policy is given
by the combination of two sums. The ﬁrst sum encodes the
utility u(wi, ni) of allocating ni servers to each service i with
wi > 0, weighted by the priority pi of the service. By setting
ϵ to a small positive value (i.e., 0 < ϵ ≪ 1), the second sum
ensures that from all server partitions that maximise the ﬁrst
sum, the one that uses the smallest number of servers is chosen
at all times. A sample function u is shown in Figure 4. More
realistic utility functions u and matching behavioural models
f from eq. (9) are described in [12].
IV. RESOURCE-DEFINITION POLICIES
A. Deﬁnition
Using R to denote the set of all resource models with the
form in (2), and E(S, C) to denote the set of all expressions
deﬁned on the Cartesian product S × C, we can now give the
generic form of a resource-deﬁnition policy as
pdef : S × C → R × E(S, C)q,
(14)
379
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

u : R+ × R+ → [0, 1]
u(w, n) =



0,
if n < (2 − α)w
n−(2−α)w
2(α−1)w ,
if (2 − α)w ≤ n ≤ αw
1,
if n > αw
α ∈ (1, 2)
u(w0, n)
0
1
w0
αw0
(2 − α)w0
n
Fig. 4.
Sample function u for Example 1—the graph shows u for a ﬁxed value of its ﬁrst argument, i.e., w = w0
where, for any (s, c) ∈ S × C,
pdef(s, c) = (R, E1, E2, . . . , Eq).
(15)
In this deﬁnition, R represents the resource that the autonomic
manager is required to synthesise, and the expressions E1, E2,
..., Eq specify how the autonomic manager will calculate the
values of the q ≥ 0 ReadOnly parameters of R as functions of
(s, c). Assuming that the value domain for the ith ReadOnly
parameter of R, 1 ≤ i ≤ q is ValueDomainsynth RO
i
, we have
Ei : S × C → ValueDomainsynth RO
i
.
(16)
Example 2
Consider again the autonomic data-centre from
Example 1. A sample resource-deﬁnition policy that comple-
ments the utility policy in (13) is given by
pdef(s, c) = (("dataCentre",
("id", String, ReadOnly)
("maxUtility", R, ReadOnly),
("utility", R, ReadOnly)),
"dataCentre A",
max
(x1,x2,...,xN)∈NN
P1≤i≤N
wi>0
piu(wi, xi),
P1≤i≤N
wi>0
piu(wi, ni))
(17)
This policy requests the autonomic manager to synthesise
a resource termed a "dataCentre". This resource com-
prises three ReadOnly parameters: id is a string-valued
identiﬁer with the constant value "dataCentre A", while
maxUtility and utility represent the maximum and actual
utility values associated with the autonomic data-centre when
it implements the utility policy (13). (The term ϵ PN
i=1 ni from
the policy deﬁnition is insigniﬁcant, and was not included
in (17) for simplicity.) Exposing the system through this
synthesised resource enables an external autonomic manager to
monitor how close the data-centre is to achieving its maximum
utility.
Note that the generic form of a resource-deﬁnition policy
(14)-(15) allows the policy to request the autonomic man-
ager to synthesise different types of resources for different
state/conﬁguration combinations of the system. While the pre-
liminary use cases that we have studied so far can be handled
using resource-deﬁnition policies in which the resource model
R from (15) is ﬁxed for all (s, c) ∈ S × C, we envisage that
this capability will be useful for more complex applications
of resource-deﬁnition policies.
B. Synthesised Resources with ReadWrite Parameters
In this section we explore the semantics and applications
of ReadWrite (i.e., conﬁgurable) parameters in synthesised
resources. These are parameters whose identiﬁers and value
domains are speciﬁed through a resource-deﬁnition policy, but
whose values are set by an external entity such as another
autonomic manager. Because these parameters do not corre-
spond to any element of the managed resources within the
autonomic system, the only way to ensure that they have an
inﬂuence on the autonomic system in Figure 1 as a whole is to
take them into account within the set of policies implemented
by the autonomic manager. This is achieved by redeﬁning
the state space S of the system. Thus, in the presence of
resource-deﬁnition policies requesting the synthesis of high-
level resources with a non-empty set of ReadWrite parame-
ters {P synth RW
1
, P synth RW
2
, . . . , P synth RW
r
}, the state space
deﬁnition (4) is replaced by:
S =


 
1≤i≤n

1≤j≤mi
typeij=ReadOnly
ValueDomainij


 ×


1≤i≤rValueDomainsynth RW
i

,
(18)
where ValueDomainsynth RW
i
represents the value domain of
the ith synthesised resource parameter P synth
i
, 1 ≤ i ≤ r.
Given that the synthesised sensors involve setting the value
of the connector parameters by the autonomic manager, the
conﬁguration space of the system can be redeﬁned in an
analogous way as:
C =


 
1≤i≤n

1≤j≤mi
typeij=ReadWrite
ValueDomainij


 ×


1≤i≤qValueDomainsynth RO
i

.
(19)
Figure 5 illustrates graphically the way in which a policy-
deﬁnition policy extends the state and conﬁguration spaces of
an autonomic system.
Example 3
Consider again our running example of an auto-
nomic data-centre. The resource-deﬁnition policy in (17) can
be extended to allow a peer data-centre (such as a data-centre
380
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

state (S)
conﬁguration (C)
S × C
(s, c)
s
c
V alueDomainsynth RO
i
×
1≤i≤q
V alueDomainsynth RW
i
×
1≤i≤r
Fig. 5.
Resource-deﬁnition policies extend the state and conﬁguration spaces
of an autonomic system with the value domains of the synthesised connectors.
running the same set of services within the same security
domain) to take advantage of any spare servers:
p′
def(s, c) = (("dataCentre",
("id", String, ReadOnly)
("maxUtility", R, ReadOnly),
("utility", R, ReadOnly)),
("nSpare", N, ReadOnly)),
("peerRequest", NN, ReadWrite)),
"dataCentre A",
max
(x1,x2,...,xN)∈NN
P1≤i≤N
wi>0
piu(wi, xi),
P1≤i≤N
wi>0
piu(wi, ni), n − PN
i=1 ni)
(20)
The synthesised resource has two new parameters: nSpare
represents the number of servers not allocated to any (local)
service; and peerRequest is a vector (nl
1, nl
2, . . . , nl
N) that a
remote data-centre can set to request that the local data-centre
assigns nl
i of its servers to service i, for all 1≤i≤N.
To illustrate how this is achieved, we will consider two
data-centres that each implements the policy in (20), and
which have access to each other’s "dataCentre" resource
as shown in the lower half of Figure 10. For simplicity, we
will further assume that the data-centres are responsible for
disjoint sets of services (i.e., there is no 1 ≤ i ≤ N such
that wi > 0 for both data-centres). To ensure that the two
data-centres collaborate, we need policies that specify how
each of them should set the peerRequestr parameter of its
peer, and how it should use its own peerRequestl parameter
(which is set by the other data-centre). The "dataCentre"
parameters have been annotated with l and r to distinguish
between identically named parameters belonging to the local
and remote data-centre, respectively. Before giving a util-
ity policy that ensures the collaboration of the two data-
centres, it is worth mentioning that the state of each has the
form s = (n, p1, w1, p2, w2, . . . , pN, wN, nr, nl
1, nl
2, . . . , nl
N)
(cf. (18)); and the system conﬁguration has the form c =
(n1, n2, . . . , nN, nr
1, nr
2, . . . , nr
N). The utility policy to use
alongside policy (20) is given below:
p′
utility(s, c) =
=























−∞,
if
N
P
i=1
ni >n ∨
N
P
i=1
nr
i >nr
N
P
i = 1
wi > 0
piu(wi, ni + nr
i ) − ϵ
N
P
i=1
ni−
−λ
N
P
i=1
nr
i + µ
N
P
i = 1
nl
i > 0
min

1, ni
nl
i

,
otherwise
(21)
where 0 < ϵ ≪ λ, µ ≪ 1 are user-speciﬁed constants. The
value −∞ is used to avoid the conﬁgurations in which more
servers than available (either locally or from the remote data-
centre) are allocated to the local services. The ﬁrst two sums
in the expression that handles all other scenarios are similar
to those from utility policy (13), except that ni + nr
i rather
than ni servers are being allocated to any local service i for
which wi >0. The term −λPN
i=1nr
i ensures that the optimal
utility is achieved with as few remote servers as possible, and
the term µP1≤i≤N
nl
i>0
min(1, ni
nl
i ) requests the policy engine to
allocate local servers to services for which nl
i >0. Observe that
the contribution of a term µ min(1, ni
nl
i ) to the overall utility
increases as ni grows from 0 to nl
i, and stays constant if ni
increases beyond nl
i. Together with the utility term −ϵPN
i=1ni,
this determines the policy engine to never allocate more than
the requested nl
i servers to service i. Small positive constants
are used for the weights ϵ, λ and µ so that the terms they
belong to are negligible compared to the ﬁrst utility term.
Further, choosing ϵ ≪ λ ensures that using a local server
decreases the utility less than using a remote one; and setting
ϵ ≪ µ ensures that allocating up to nl
i servers to a service i
at the request of the remote data-centre increases the system
utility.
Finally, note that because the requests for remote servers
and the allocation of such servers take place asynchronously,
there is a risk that the parameter values used in policy (21)
may be out of date.2 However, this is not a problem, as
the allocation of fewer or more remote servers than ideally
required is never decreasing the utility value for a data-
centre below the value achieved when the data-centre operates
in isolation. Additionally, local servers are never used for
remote services at the expense of the local services because
P1≤i≤N
wi>0
piu(wi, ni)
≫
µ P1≤i≤N
nl
i>0
min(1, ni/nl
i)) in the
utility expression.
V. PROTOTYPE IMPLEMENTATION
The policy engine (i.e., policy-based autonomic manager)
introduced by the author in [13] was extended with the
ability to handle the new type of autonomic computing policy.
Implemented as a model-driven, service-oriented architecture
with the characteristics presented in [12], the policy engine
2In practical scenarios that we investigated this happened very infrequently
relative to the time required to solve the linear optimisation problem (21)
automatically within the policy engine.
381
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

ManagedResource⟨⟩ :
System.Web.Services.WebService
ManagedResource⟨T1⟩
ManagedT1 :
ManagedResource⟨T2⟩
ManagedT2 :
ManagedResource⟨Tn⟩
ManagedTn :
Fig. 6.
Generic programming is used to implement the manageability adaptors for the system resources.
from [13] can manage IT resources whose model is sup-
plied to the engine in a runtime conﬁguration step. The
IT resource models described by eq. (1) are represented as
XML documents that are instances of a pre-deﬁned meta-
model encoded as an XML schema [12][13]. This choice was
motivated by the availability of numerous off-the-shelf tools
for the manipulation of XML documents and XML schemas—
a characteristic largely lacking for the other technologies we
considered. The policy engine is implemented as a .NET web
service. In its handling of IT resources whose characteristics
are unknown until runtime, the policy engine takes advantage
of object-oriented (OO) technology features including:
• polymorphism—the ability to use instances of derived
data types in place of instances of their base data types;
• reﬂection—an OO programming technique that allows the
runtime discovery and creation of objects based on their
metadata [17].
• generic programming—the ability to write code in terms
of data types unknown until runtime [18].
The manageability adaptors from Figure 1 are implemented
by the framework in [13] as web services that specialise a
generic, abstract web service ManagedResource⟨⟩. For each
type of resource in the system, a manageability adaptor is built
in two steps. First, a class (i.e., a data type) Ti is generated
from the resource model (2) that will be used to conﬁgure
the policy engine, ∀1 ≤ i ≤ n. Second, the manageability
adaptor ManagedTi for resources of type Ti is implemented
by specialising our generic ManagedResource⟨⟩ adaptor, i.e.,
ManagedTi : ManagedResource⟨Ti⟩. This process is illus-
trated in Figure 6 and described in detail in [13].
Adding support for the implementation of the resource-
deﬁnition policy in (14)–(15) required the extension of the
policy engine described above with the following functional-
ity:
1) The automated generation of a .NET class T for the
synthesised resource R from (15). This class is built by
including a ﬁeld and the associated getter/setter methods
for each parameter of R. The types of these ﬁelds are
given by the value domains of the resource parameters.
2) The automated creation of an instance of T. Reﬂection is
employed to create an instance of T for the lifespan of
the resource-deﬁnition policy. The ReadOnly ﬁelds of
this object are updated by the policy engine using the
expressions E1, E2, ..., Eq from eq. (16); the updates
are carried out whenever the object is accessed by an
external entity.
3) The automated generation of a manageability adaptor
web service ManagedT : ManagedResource⟨T⟩. The
web methods provided by this autonomic system con-
nector allow entities from outside the autonomic system
(e.g., external autonomic managers) to access the object
of type T maintained by the policy engine. The ﬁelds of
this object that correspond to ReadOnly parameters of
R can be read, and those corresponding to ReadWrite
parameters can be read and modiﬁed, respectively.
The .NET components generated in steps 1 and 3 are
deployed automatically, and made accessible through the
same Microsoft IIS instance as the policy engine. The
synthesised connector is available as soon as the engine
completes its handling of the resource-deﬁnition policy.
The URL of the connector has the same preﬁx as that of
the policy engine, and ends in “ManagedresID.asmx”,
where resID is the resource identiﬁer speciﬁed in the
resource-deﬁnition policy. For instance, if the policy engine
URL
is
http://www.abc.org/PolicyEngine.asmx,
the
synthesised
connector
for
a
resource
of
type
dataCentre
will
be
accessible
at
the
address
http://www.abc.org/ManagedDataCentre.asmx.
Example 4
Returning to our running example of an auto-
nomic data-centre, the class diagram in Figure 7 depicts the
manageability adaptors in place after policy (20) was supplied
to the policy engine. Thus, the ManagedServerPool and
ManagedService classes in this diagram represent the man-
ageability adaptors implemented manually for the ServerPool
and Service resources described in Example 1. The other
manageability adaptor derived from ManagedResource⟨⟩ (i.e.,
ManagedDataCentre) was synthesised automatically by the
policy engine as a result of handling the resource-deﬁnition
policy.
Also shown in the diagram are the classes used to represent
instances of the IT resources within the system—serverPool
and service for the original autonomic system, and data-
Centre for the resource synthesised from policy (20). Notice
the one-to-one mapping between the ﬁelds of these classes
and the parameters of their associated resources (described in
Examples 1 and 3).
VI. APPLICATION DEVELOPMENT
System-of-systems application development with resource-
deﬁnition policies involves supplying such policies to existing
382
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

resource synthesised from policy (18)
manually implemented manageability
service
priority : unsigned
workload : unsigned
serverPool
dataCentre
id : String
maxUtility : double
utility : double
nSpare: unsigned
peerRequest : unsigned[1..N]
adaptors
generic autonomic computing framework from [3]
ManagedResource⟨⟩ :
System.Web.Services.WebService
ManagedServerPool :
ManagedResource⟨service⟩
ManagedService :
ManagedDataCentre :
ManagedResource⟨dataCentre⟩
Fig. 7.
Class diagram for Example 4
synthesised
connectors
Fig. 8.
Hierarchical system-of-systems development with resource-deﬁnition
policies
autonomic systems whose autonomic managers support the
new policy type. Hierarchical systems of systems can be built
by setting a higher-level autonomic manager to monitor and/or
control subordinate autonomic systems through synthesised
connectors that abstract out the low-level details of the systems
they expose to the outside world. As illustrated in Figure 8,
the hierarchy of autonomic systems can comprise any number
of levels.
Alternatively, the original autonomic systems can be conﬁg-
ured to collaborate with each other by means of the synthesised
resource sensors and effectors. In this scenario, the sensors are
used to expose the global state of each system and the effectors
are employed to provide services to peer autonomic systems
as envisaged in the seminal paper of Kephart and Chess [2].
The approach is illustrated in Figure 9.
Hybrid applications comprising both types of interactions
mentioned above are also possible, as illustrated by the fol-
synthesised
connectors
Fig. 9.
Collaborating autonomic systems that inter-operate by means of
run-time synthesised connectors
lowing example.
Example 5
The policy engine from Section V was used
to simulate an autonomic system of systems comprising the
pair of autonomic data-centres described in Example 3, and a
top-level autonomic manager that monitors and summarises
their performance using a dashboard resource (Figure 10).
The policies implemented by the autonomic managers local
to each data-centre are policies (20)–(21) from Example 3.
The top-level autonomic manager implements a simple action
policy that periodically copies the values of the maxUtility
and utility parameters of the "dataCentre" resources syn-
thesised by the data-centres into the appropriate ReadWrite
parameters of the dashboard. For brevity, we do not give this
policy here; a sample action policy was presented earlier in
Example 1.
We used the data-centre resource simulators from [12], and
implemented the dashboard resource as an ASP.NET web
page provided with a manageability adaptor built manually
as described in Section V and in [13]. Separate series of
experiments for 20-day simulated time periods we run for
two scenarios. In the ﬁrst scenario, the data-centres were
kept operating in isolation, by blocking the mechanisms they
could use to discover each other. In the second scenario, the
383
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

autonomic data-centre
top-level
autonomic
manager
dashboard
service
service
service
service
autonomic data-centre
synthesised
"dataCentre"
resource
synthesised
"dataCentre"
resource
Fig. 10.
Autonomic system of systems
data-centres were allowed to discover each other, and thus
to collaborate through implementing policy (21). Figure 11
depicts typical snapshots of the dashboard for both scenarios
and for one of the data-centres; the same simulated service
workloads were used in both experiments shown. As expected
from the analysis in Example 3, the system achieves higher
utility when data-centre collaboration is enabled, thus allowing
data-centres to utilise each other’s spare servers.
VII. CONCLUSION AND FUTURE WORK
Many of today’s computing systems are built through the
integration of components that are systems in their own right:
they operate autonomously and follow local goals in addition
to contributing to the realisation of the global objectives of
the overall system. The research results presented in this
article enable the addition of self-managing capabilities to
this class of systems. This is achieved through the run-time
generation of autonomic system connectors that can be used
to dynamically assemble autonomic systems of systems out of
a set of individual autonomic systems.
We introduced a policy speciﬁcation framework for auto-
nomic computing, and used it to formally deﬁne the existing
types of autonomic computing policies from [15][11][16] and
a new type of policy that we termed a resource-deﬁnition pol-
icy. We described the semantics of resource-deﬁnition policies,
and explained how they can be used to dynamically generate
connectors that enable the integration of multiple autonomic
systems into autonomic systems of systems. This represents
a signiﬁcant step towards addressing a major challenge of
autonomic computing, namely the seamless integration of mul-
tiple autonomic elements into larger self-managing computing
systems [2].
Additionally, the article presented how resource-deﬁnition
policies can be implemented by augmenting the reference
autonomic computing loop with a connector synthesis step,
and described a prototype implementation of an autonomic
manager that comprises this additional step.
To validate the proposed approach to developing autonomic
systems of systems, we used the prototype autonomic manager
in a case study that was presented as a running example
in Sections III to VI. The case study involved the adaptive
allocation of data-centre servers to services with different
priorities and variable workloads. The system of systems
considered by our case study included a couple of simulated
autonomic data-centres that employed utility-function policies
to dynamically partition their physical servers among local
services. Within this autonomic system of systems, resource-
deﬁnition policies were used successfully to synthesise a
"dataCentre" resource fulﬁlling two distinct purposes:
1) Collaboration between the autonomic data-centres. Each
data-centre exposed its number of unused, spare servers
through a ReadOnly parameter of the synthesised re-
source, and the peer data-centre could set a ReadWrite
parameter of the same resource to request that some
of its services are run on these spare servers. The
effectiveness of the technique was demonstrated by the
improved utility achieved by the simulated data-centres
when this collaboration was enabled, compared to the
scenario when the data-centres operated in isolation
from each other.
384
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

Fig. 11.
Dashboard for isolated data-centre (top) and for identical data-centre operating as part of the autonomic system of systems from Figure 10 (bottom).
385
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

2) High-level
reporting
of
data-centre
utility.
Two
ReadOnly parameters of the synthesised resource were
used to reﬂect the instantaneous data-centre utility and
maximum (or ideal) utility attainable, respectively. A
top-level instance of the prototype autonomic manager
was employed to monitor this information and, through
suitable action policies, to forward it to a web-based
dashboard for real-time plotting.
The two uses of resource-deﬁnition policies show that both
federations of collaborative autonomic elements and hierar-
chical autonomic systems can be implemented successfully
using the tool-supported development technique proposed in
the article.
The work presented in the article is part of an ongoing
project aimed at devising novel approaches for the effective
development of autonomic systems and systems of systems.
Related future objectives of this project include extending the
policy speciﬁcation framework with techniques for the analysis
of policy properties such as state/conﬁguration space coverage
and conﬂict freeness, and applying resource-deﬁnition policies
to additional, real-world case studies from the area of data-
centre resource management.
ACKNOWLEDGEMENT
This work was partly supported by the UK EPSRC grant
EP/F001096/1.
REFERENCES
[1] R. Calinescu, “Resource-deﬁnition policies for autonomic computing,”
in Proceedings of the 5th International Conference on Autonomic and
Autonomous Systems (ICAS 2009), 2009, pp. 111–116.
[2] J. O. Kephart and D. M. Chess, “The vision of autonomic computing,”
IEEE Computer Journal, vol. 36, no. 1, pp. 41–50, January 2003.
[3] M. Huebscher and J. McCann, “A survey of autonomic computing—
degrees, models, and applications,” ACM Comput. Surv., vol. 40, no. 3,
pp. 1–28, 2008.
[4] M. Parashar and S. Hariri, Autonomic Computing: Concepts, Infrastruc-
ture & Applications.
CRC Press, 2006.
[5] Carnegie Mellon Software Engineering Institute, Ultra-Large-Scale
Systems. The Software Challenge of the Future.
Carnegie Mellon
University, 2006.
[6] G. Goth, “Ultralarge systems: Redeﬁning software engineering?” IEEE
Software, vol. 25, no. 3, pp. 91–94, May/June 2008.
[7] M. Hinchey et al., “Modeling for NASA autonomous nano-technology
swarm missions and model-driven autonomic computing,” in Proc. 21st
Intl. Conf. Advanced Networking and Applications, 2007, pp. 250–257.
[8] J. O. Kephart, H. Chan, R. Das, D. W. Levine, G. Tesauro, F. L. R.
III, and C. Lefurgy, “Coordinating multiple autonomic managers to
achieve speciﬁed power-performance tradeoffs,” in Proceedings Fourth
International Conference on Autonomic Computing (ICAC’07), 2007.
[9] J. Li, P. Martin, W. Powley, K. Wilson, and C. Craddock, “A sensor-
based approach to symptom recognition for autonomic systems,” in
Proceedings of the 5th International Conference on Autonomic and
Autonomous Systems (ICAS 2009), 2009, pp. 45–50.
[10] D. Raymer et al., “From autonomic computing to autonomic networking:
an architectural perspective,” in Proc. 5th IEEE Workshop on Engineer-
ing of Autonomic and Autonomous Systems, 2008, pp. 174–183.
[11] W. Walsh et al., “Utility functions in autonomic systems,” in Proc. 1st
Intl. Conf. Autonomic Computing, 2004, pp. 70–77.
[12] R. Calinescu, “General-purpose autonomic computing,” in Autonomic
Computing and Networking, M. Denko et al., Eds.
Springer, 2009, pp.
3–20.
[13] ——, “Implementation of a generic autonomic framework,” in Proc. 4th
Intl. Conf. Autonomic and Autonomous Systems, D. Greenwood et al.,
Eds., March 2008, pp. 124–129.
[14] M. Wooldridge, An Introduction to Multi-agent Systems.
J. Wiley and
Sons, 2002.
[15] J. O. Kephart and W. E. Walsh, “An artiﬁcial intelligence perspective
on autonomic computing policies,” in Proc. 5th IEEE Intl. Workshop on
Policies for Distributed Systems and Networks, 2004.
[16] S. White et al., “An architectural approach to autonomic computing,”
in Proc. 1st IEEE Intl. Conf. Autonomic Computing.
IEEE Computer
Society, 2004, pp. 2–9.
[17] J. M. Sobel and D. P. Friedman, “An introduction to reﬂection-oriented
programming,” in In Proceedings of Reﬂection96, 1996.
[18] R. Garcia et al., “A comparative study of language support for generic
programming,” ACM SIGPLAN Notices, vol. 38, no. 11, pp. 115–134,
November 2003.
386
International Journal on Advances in Intelligent Systems, vol 2 no 2&3, year 2009, http://www.iariajournals.org/intelligent_systems/

