A Practical Automated Transformation of Entity
Relationship Models to Relational Models
Gregor Grambow
Aalen University
Aalen, Germany
Email: gregor.grambow@hs-aalen.de
Simon Ruttmann
Aalen University
Aalen, Germany
Email: simon.ruttmann@studmail.htw-aalen.de
Abstract—Creating conceptual database schemata via Entity
Relationship (ER) diagrams is a prevalent way of modeling.
However, these models are not directly compatible with the
relational model used in SQL databases. Over the decades,
various theoretic approaches for transforming ER models to
relational models have been proposed. However, this did not
lead to the creation of editors capable of such transformations.
Modern editors either have no transformation facilities, or do
not use the ER model proposed by Peter Chen but rather
provide somehow enhanced database diagrams. Thus, conceptual
schemata have to be transformed manually to technical ones,
which is time consuming and error-prone. To counteract this,
we propose a transformation from ER models to relational ones
that focuses on practical applicability and operational semantics.
Further, the approach enables the original ER model as well as
prevalent extensions. To prove the applicability of this approach
we have created a graphical editor capable of flexibly modeling
ER diagrams and automatically transforming them to relational
models.
Index Terms—Entity Relationship; ER Model; Relational
Model; Database; Editor
I. INTRODUCTION
Entity Relationship (ER) modeling is a prevalent option
for semantic data modeling primarily applied to database
schemata. This way of modeling has been used since over
40 years. It was introduced in 1976 by Peter Chen [1] and
has been the focus of active research for decades. There has
been a myriad of extensions to the model, like the ECR model
[2], the ECR+ model [3], HERM [4], or the EER model [5].
Many of these extensions offer valuable additions to the basic
ER models. Some features have been adopted but many have
also been discarded. As a result of this, basic ER modeling
became prevalent but with a high number of different flavors.
The usage of generalization concepts, cardinality constraints
or the application of the n-ary relationships as proposed by
Peter Chen differs in many applications.
However, to be usable in a relational database, ER models
have to be converted to relational models. Manually executed,
this process can be tedious and error-prone. Thus, various
approaches for standardized transformations have been pro-
posed, like [2] [6] - [12]. Most of these approaches have two
major downsides: First, they often impose certain constraints
on the ER models and second, they remain rather theoretic.
In many cases, after presenting their approach, the authors
recommended them to be used by practitioners or in auto-
mated tools. Despite having a clear formalism, a practical
implementation was never achieved, often due to the lack
of operational semantics. On the other hand, there is a high
number of editor tools for ER models, contained in drawing
tools [13] - [16], in client software of databases [17] [18], or
in modeling tools like Enterprise Architect [19]. These editors
have two main issues: Each of them uses a different subset of
ER concepts, some are even closer to a relational or even UML
class diagram editor. In addition, the transformation aspect has
been ignored almost completely. Thus, semantic data modeling
for databases usually involves first drawing an ER diagram and
then manually transforming it to database tables, which can
be a source of numerous issues.
To counteract this, we propose an approach for automat-
ically transforming ER models to relational models. As op-
posed to prior approaches we do not focus on mathematical
definitions or calculus but rather on practical applicability and
operational semantics. Thereby, our approach can be easily
applied to editors in different programming languages. To
prove this applicability we have implemented a graphical ER
editor that is capable of this automatic transformation.
The rest of this paper is organized as follows: Section II
discusses related approaches, while Section III defines the
concrete style of ER diagram that is assumed as basis for the
transformation. Section IV provides an extensive description
of the transformation approach. After that, Section V shows
a practical evaluation of the proposed approach followed by
Section VI providing a conclusion as well as future directions.
II. RELATED WORK
In this section, we cover two types of related work: Sci-
entific approaches presented for transforming ER models into
relational models and practical ER editor tools.
In the scientific community, the case of transforming ER
models has been extensively discussed over the decades. Most
proposed approaches date back to the 1980s and 1990s. As
mentioned, one big issue concerning general applicability is
the high number of different ER variants. The basic variant
proposed by Peter Chen [1] includes n-ary relationships and
weak entities but no generalization concepts. Most of the
extensions [2] - [5] to that model focused on adding structures
for generalization. Due to that, many different transformation
approaches take different variants of the ER model as basis.
5
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-056-8
DBKDA 2023 : The Fifteenth International Conference on Advances in Databases, Knowledge, and Data Applications

Most attention was paid to the original version of the ER
model [6] - [9] and extended ER models with generalization
structures [2] [10] - [12]. All of them have in common that
they remain rather theoretic and do not consider operational
issues [20]. Further, to the best of our knowledge, none of
these approaches lead to the development of a prevalent ER
editor tool.
The fact that most research regarding that topic was car-
ried out decades ago lets us assume, that the transformation
approaches have been adopted and are now prevalent in
ER editors. Therefore, the second part of this section deals
with contemporary ER editors. However, before investigating
the transformation capabilities, another issue has to be dealt
with: There is a high number of ER editors that do not
use the ER model as proposed by Peter Chen. Many of
them focus on simplified binary relationships. In addition,
they do not cover the most prevalent extension to Chen’s
model: generalization. Such diagrams are often nearer to a
relational database diagram than to a real ER diagram. One
category featuring such diagrams is drawing tools like Lucid
Chart [13], Draw.io [14], or Visual Paradigm [15]. Some of
them even contain concepts like stored procedures or triggers
and can thus not be considered ER editors. Furthermore,
none of them provides a transformation approach. Another
category providing such diagrams is database client software,
e.g., from PostgreSQL [17] or MySQL [18]. These editors
provide visual modeling that can be directly used as database
tables. However, the diagrams are rather close to the relational
approach and not to Chen’s model. The number of editors
covering the latter is rather limited. One with a good set of
concepts is the Enterprise Architect [19], which covers most
elements considered prevalent in ER models as of today: n-ary
relationships, generalization, and multi-valued or composite
attributes. However, there is no transformation approach in
place. Only one editor features an ER model like proposed
by Chen and also a transformation approach: ERD+ [16].
But that editor only features a rather limited set of modeling
elements. It does not support n-ary relationships and the use of
generalization is rather restrictive. In addition, the translation
of weak types is only possible on the most trivial level. This
also applies to the translation of multi-valued and composite
attributes. The combination of attribute types is not supported
at all. In summary, it can be said that the tool can only be
used for simple, not extensive ER Models.
As ER modeling stays relevant, there are also contempo-
rary approaches dealing with this model. However, most of
these approaches don’t deal with transforming ER models
to relational ones. Examples include approaches for creating
ER models from text using natural language processing [21]-
[23] or applying ER modeling for creating specific models,
e.g., for ontologies [24], Kanban systems [25] or software
structures [26]. A small number of approaches deals with the
relational transformation, but they either provide only very
basic transformations with no practical application [27] or no
novel transformations at all [28].
All in all, it can be stated that the proposed transformation
approaches did not make it into applicable tools, mostly due to
the lack of coverage of operational issues. On the other hand,
modern editors seem to focus on simplified binary variants
that are closer to relational tables than to Chen’s ER model.
III. DEFINITION OF THE ER MODEL
As described in sections I and II, there is a number of vari-
ations of ER models. However, in order to develop algorithms
for transforming the ER model to the relational model, it is
mandatory that modeling capabilities are known. Due to this,
the ER model used in this work will be defined to ensure an
unambiguous transformation.
When defining the modeling capabilities, one goal is to
provide the modeler as much freedom as possible. The ER
model defined in this paper is heavily based on the model
presented by Kemper and Eickler [29]. This model includes the
most prevalent modeling components such as entities, n-ary
relations and attributes. It also contains existence-dependent
types and covers generalization in form of IsA-Structures.
The model is additionally extended by the attribute types
”Multi-valued attribute” and ”Compound attribute” according
to Vossen [30].
An entity is the most basic ER component, covered within
this paper. It does not have a direct connection with another
entity, must have at least one identifying attribute and may be
referenced by any number of attributes.
The relation is derived analogously to the entities from the
basic principles of the ER model. Within this work, n-ary
relations are supported. Every relation must connect at least
two entity types and may be referenced by any number of
attributes. To increase the modeling capabilities, the ER model
also allows reflexive relations from one entity to itself.
The third component commonly used in ER models are
attributes. In the context of this work, a distinction is made
between three types of attributes. Regular single-valued at-
tributes, multi-valued attributes and identifying attributes. To
extend the capabilities of the model, regular and multi-valued
attributes can be referenced by further regular and multi-
valued attributes. This means that each regular and multi-
valued attribute can act as a composite of other attributes.
The attributes that form a composite are called composite
attributes. Attributes, which are part of a composite attribute
are also implicitly given the possibility to act as an composite
attribute, which allows the multiple application of composition
and multi-valuedness. With the multiple application of multi-
valuedness and composition, complex attribute structures can
be formed. These structures can form cyclic dependencies
and ambiguities between attributes when they reference each
other directly or indirectly via further attributes. Nevertheless,
it must be guaranteed that each attribute can be uniquely
assigned to exactly one entity or relationship. Each attribute
can be assigned unambiguously to one entity or relationship if
there is a direct connection or exactly one path to an entity or
relationship via further attributes. The uniqueness requirement
implies that attribute structures must have the form of trees
with the corresponding entity or relation as root.
6
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-056-8
DBKDA 2023 : The Fifteenth International Conference on Advances in Databases, Knowledge, and Data Applications

The transformation presented in this paper also supports
existence-dependent types, which are also referred to as weak
types. Weak types depend on a parent type for identification.
In the ER model, this dependency is modeled by the use of
a relationship between the parent entity and the existence-
dependent entity, called a weak relation. It should be noted
that in this ER model, the parent does not have to be a strong
entity. Therefore it is possible that a parent entity is also a
weak entity, which in turn depends on another parent entity.
Due to this multiple application of existence dependence,
restrictions are required to uniquely assign a weak entity its
dependent type. These are conceptionally analogous to the
multiple application of the composition and multi-valuedness
of attributes.
The ER model and transformation also incorporates general-
ization. Overall, generalization can be divided into a number of
different types, characteristics, and constraints. In the context
of this paper, generalization in the ER model is implemented
exclusively by means of IsA structures, omitting the notation
and transfer of specific properties of generalization. IsA struc-
tures associate multiple entities with each other. Each entity
of the IsA structure acts as a subtype or supertype entity. An
IsA structure references exactly one supertype entity and any
number of subtype entities. The subtype entities of the IsA
structure inherit all attributes of the supertype entity.
When defining the rules for IsA structures, a multiple-
inheritance of the attributes of a supertype entity to a subtype
entity must be excluded. To avoid this, a restriction to tree-
structures, as with attributes, could be made but would be too
restrictive. Instead the restriction is made based on the three
following sets.
A) The ”subtype set” of an entity contains the entity itself
and all entities, which inherit from the entity.
B) The ”supertype set” of an entity includes the entity itself
and all other entities, which the entity inherits from.
C) The ”influenced type set” of an entity includes the sub-
type set and additionally for each entity in the subtype
set the supertype set.
The sets defined above on the basis of an expression of
several IsA structures are shown in Figure 1. The sets here
start from the entity highlighted in blue. The entity within the
area shown in red is part of the supertype set. The entities
within the green area shown are part of the subtype set. The
influenced type set contains all entities, which are highlighted
in purple.
If an entity is connected as a subtype of an IsA structure
the influenced type set of the entity must be disjoint with
the supertype set of the supertype of the IsA structure. In
contrast, when an entity is connected as the supertype of an
IsA structure, the influenced type set of all subtypes of the
IsA structure must be disjoint with the supertype set of the
entity.
Fig. 1. Subtype-, supertype and influenced type set
In summary, the ER model discussed in this paper is
extended by the following concepts:
• Multivalence of attributes
• Composition of attributes
• Reflexive, unary relationships
• N-ary relationships
• Existence dependency
• Generalization
IV. TRANSFORMATION
The implementable transformation of ER models is realized
in several steps, which are executed sequentially.
A) Creating a data model structure of ER diagrams
B) Transformation of attributes
C) Transformation of IsA structures
D) Transformation of weak types
E) Transformation of relationships
F) Cascading of primary keys for attributes
These steps will be explained in more detail below.
A. Structural data model of ER models
In order to execute algorithmic approaches for translating
the ER model into the relational model, a basic data model is
required on which they can operate.
Any ER diagram essentially consists of elements such as
entities, relationships, attributes, IsA structures, and associa-
tions between those elements. Therefore, the structure can be
expressed directly as a graph. Furthermore, information about
the cardinality between a relation and an entity can be stored
in the edges of the graph. In case of a IsA structure, the edges
also contain information about whether the connected node is
a supertype or subtype.
In Section III, it was explained that attributes are always
expressed in the form of trees. This makes it possible to further
restrict the graph. Since all entities and relationships can have
attributes, each of these elements acts as the root of a tree.
Each attribute in the ER model is therefore represented as a
node in the tree. The edges within the tree structure do not
hold any additional information.
7
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-056-8
DBKDA 2023 : The Fifteenth International Conference on Advances in Databases, Knowledge, and Data Applications

B. Transformation of attributes
The goal of this translation is to express any attribute struc-
ture by means of relations. From the previous subsection, it is
known that all attributes are held within a tree. Therefore, only
these trees have to be considered in this translation. If a tree
consisting exclusively of single-valued attributes is considered,
this can be solved trivially by creating a relation for the tree’s
root entity or relationship and adding each attribute, which is
a leaf of the tree to that relation. Algorithmically, this can
be done by traversing the tree in post-order and checking
whether the current node is a leaf. However, if a tree contains
multi-valued attributes, these cannot be added to the tree‘s root
relation as a relation expresses a fixed sized schema and multi-
valued attributes can take on any number of values. In this
case, a standalone relation must be created for that attribute
and a reference between it and the tree’s root relation has to be
created. In the case of composite attribute structures, attention
must be paid between which relations a reference is created.
It is important to note, that the referenced relation does not
necessarily have to be the tree’s root relation. As it is quite
possible that the relation of a multi-valued attribute references
a relation of another multi-valued attribute. The transformation
of composite attribute structures can be executed by creating
a relation for each attribute at the beginning. If the tree is
then traversed in post-order, and the current node represents
a multi-valued attribute a reference can be created between
the current node‘s relation and the node‘s parent relation. For
single-valued attributes, the relation can be merged with the
relation of its parent node. Within the merge, all attributes
and references of the child relation are transferred to the
relation of the parent node. This procedure can be extended
by skipping composite attributes, which consist of only one
additional multi-valued attribute.
Listing 1 shows the algorithm for translating attributes in
pseudo code. It is executed for each entity and each relation
in the ER graph. The algorithm is explained below.
Listing 1. Transformation of attributes
1
Function
T r a n s f o r m A t t r i b u t e T r e e
( Parent )
2
For Each
Child
in
TreeNode
/ / Execute
post −order
3
T r a n s f o r m A t t r i b u t e T r e e
( Child )
4
End For
5
I f
TreeNode
i s
Multivalued
A t t r i b u t e
Then
6
TreeNode . Table <− marked
7
End
I f
8
9
I f
TreeNode
i s
Leaf Then
/ / Recursion
r e s o l u t i o n
10
Return
11
End
I f
12
13
For Each
Child
in
TreeNode
14
I f
Child . Table
i s
marked Then
15
I f
TreeNode . Children . Size = 1 Then
16
/ / Handling
of ” forwarding ”
a t t r i b u t e s
17
MergeTable ( TreeNode . Table ,
Child . Table )
18
TreeNode . Table <− marked
19
Else
20
TreeNode . Table . References . Add ( Child . Table )
21
End
I f
22
Else
23
MergeTable ( TreeNode . Table ,
Child . Table )
24
End
I f
25
End For
26
End Function
27
28
Function
MergeTable ( ParentTable ,
ChildTable )
29
ParentTable . Columns . AddAll ( ChildTable . Columns )
30
ParentTable . References . AddAll ( ChildTable . References )
31
Delete
ChildTable
32
End Function
The initial situation of the algorithm, shown in Listing 1, is
that the ER graph has been created. In addition, a relation is
created for each attribute. As within this algorithm, relations
which correspond to a single-valued attribute are successively
unified. The relations which were created for multi-valued
attributes are preserved. For these relations only the above
mentioned references are created. In the shown algorithm the
postorder traversal takes place in the lines 2 to 4, as well as
9 to 11. For the handling of multi-valued attributes, these are
marked in each call in lines 5 to 7. This takes place before
the recursion resolution, in order to seize also multi-valued
attributes, which are leaves of the attribute tree. Otherwise,
those would not be marked and would be merged in the
following lines. In lines 13 to 25, each direct child attribute is
handled for an attribute. If it is a marked attribute, a reference
to the child attribute is created in line 20. In the special case
that the attribute has only one multi-valued attribute as a child,
lines 15 to 18 are executed and a ”skipping” takes place,
regardless of whether the current attribute is a multi-valued
or single-valued attribute. If, on the other hand, it is a single-
value attribute (line 23), the relation of the child attribute can
be resolved by merging it with the relation of the current
attribute. The merging itself is done by adding all columns
and references of the child table to the parent table (line 29
to 31).
Figure 2 illustrates this algorithmic process. The arrows
indicate, how the algorithm will process the attributes. The
cross next to the relations shows that these have been resolved.
The resolution takes place in the same call as the arrows shown
in the same color. The result is shown on the bottom right.
Note that the attribute value D consists here of many attribute
values F and one attribute value E. A direct reference between
the entity relation and the relation F could not represent this
situation. Also note that the attribute B is merged within the
algorithm. This is permissible because entity I is associated
with exactly one value for the attribute G.
Fig. 2. Transformation of complex attribute structures
To complete the translation of the attributes into the rela-
tional model, the references between the created relations must
8
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-056-8
DBKDA 2023 : The Fifteenth International Conference on Advances in Databases, Knowledge, and Data Applications

be mapped in the form of foreign key dependencies. For this
purpose, the remaining relations can be traversed in pre-order
and primary keys can be added to the relations. These also act
as foreign keys to the primary keys of the referenced relation.
The cascading of the foreign keys is not executed directly,
as it is only ensured that the root entity or relation contains
all primary keys due to its identifying attributes. However, as
new primary keys may be added if the entity is a weak entity
or part of an IsA structure the immediate execution could
lead to invalid references between the relations. Therefore the
execution of the cascading will take place at the end of the
whole transformation process as Step F.
C. Transformation of IsA-Structures
The transformation of IsA structures is realized by means of
foreign key dependencies between the subtypes and supertypes
of the IsA structure. It should be noted that the relations of
the entities must exist and the primary keys must be located
in them. Because of this, the transformation of the attributes
must take place before the transformation of IsA structures.
Each subtype of an IsA structure inherits all primary keys of
the supertype. In addition, these inherited primary keys refer to
the upper type as foreign keys. If entities are part of several IsA
structures, ”higher level” IsA structures have to be translated
first to ensure that entities at lower levels receive all primary
keys. To illustrate the translation order Figure 3 shows an
entity-relationship model on the left and the relational model
on the right. The red highlighted IsA structure can only be
translated after the blue and green IsA structures. The blue
one, on the other hand, only after the green one above it.
Fig. 3. Transformation order of IsA-Structures
Listing 2 shows the algorithm for transforming an IsA struc-
ture. Here, the processing order of the structures is maintained
by traversing all IsA structures up to N times, where N is the
number of IsA structures.
If the supertype of the selected IsA structure inherits from
further IsA structures, and these have not yet been translated,
the current pass is skipped (line 6 to 10). Specifically, line 6
determines all IsA structures that must already be transformed
in order to transform the current IsA structure. In Figure 3, this
corresponds to the green and blue highlighted IsA structure in
the case of the currently treated red IsA structure. Following
this, line 7 checks whether all have already been transformed.
If at least one IsA structure has not been transformed, the
current call is skipped. This also applies if the selected IsA
structure has already been translated (line 2 to 4). If the IsA
structure can be transformed in this call, the actual transfor-
mation takes place by creating the foreign key dependencies
in line 12 to 16.
Listing 2. Transformation of IsA-Structures
1
Function
TransformIsAStructure ( I s A S t r u c t )
2
I f
I s A S t r u c t
i s
transformed
Then
3
Return
4
End
I f
5
6
UpperLayerIsAs <− G e t I n h e r i t e d I s A s ( I s A S t r u c t . SuperType )
7
UnhandledUpperLayerIsAs <− UpperLayerIsAs
! transformed
8
I f
UnhandledUpperLayerIsAs
not
empty Then
9
Return
10
End
I f
11
12
For Each SubType
in
I s A S t r u c t . Subtypes
13
For Each PrimaryKey
in
SuperType
14
AddForeignKeyAsPrimaryKey ( Supertype ,
Subtype )
15
End For
16
End For
17
I s A S t r u c t <− isTransformed
18
End Function
D. Transformation of weak types
For the translation of weak types to the relational model,
it is a prerequisite that relations exist for all entities and
relationships and that all attributes are already contained in
them. Therefore, the transformation of attributes and IsA
structures must be performed beforehand. IsA structures must
be translated before, since a strong entity, on which a weak
entity depends, can receive further primary keys during the
translation of IsA-Structures.
Equivalent to the transformation of IsA-Structures, the
translation order has to be considered. The translation has
to start from weak entities, which have a connection to a
strong entity or an already translated weak entity by means
of a weak relationship. The relation of the weak relationship
always has to be merged with the relation of the dependent
entity. During the translation, the relation of the entity to be
translated keeps a reference to the strong or already translated
entity. This reference can then be used to create the foreign
key dependencies.
The translation process of an ER diagram is shown in
Figure 4. The figure starts immediately after the execution
of the algorithms for the translation of attributes and IsA
structures. The first rectangle shows an example ER model,
which is transformed over a series of steps. The second step
is the starting point of the algorithm, where all elements
occur as a relation, conditioned by the previously executed
attribute algorithm. The green highlighted elements represent
the weak relationships in the ER model, which are required to
be transformed. According to the mentioned translation order,
the elements to be translated are determined and transformed
in each step. In Figure 4, the blue elements are translated first,
followed by the red elements.
Algorithmically, the merging of relations and reference
creation from Figure 4 is shown in Listing 3. The compliance
with the order is done, analogous to the translation of IsA
9
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-056-8
DBKDA 2023 : The Fifteenth International Conference on Advances in Databases, Knowledge, and Data Applications

Fig. 4. Transformation of weak types
structures, by checking all weak entities up to N times, where
N equals the number of weak entities in the graph.
Listing 3. Transformation of weak types
1
Function
TransformWeakEntity ( WeakEnt )
2
I f
WeakEnt
i s
transformed
Then
3
Return
4
End
I f
5
6
WeakRelations <− GetConnectedWeakRelations ( WeakEnt )
7
For Each WeakRel
in
WeakRelations
8
9
OtherEnt <− GetOtherEntity ( WeakEnt ,
WeakRel )
10
I f
OtherEnt
i s
no
S t r o n g E n t i t y
or
11
i s
not
transformed
WeakEntity Then
12
Continue
13
End
I f
14
WeakEnt . Transformed <− t r u e
15
WeakEnt . References . Add ( O t h e r E n t i t y )
16
MergeTables ( WeakEnt ,
WeakRel )
17
Return
18
End For
19
End Function
In contrast to the IsA structure algorithm, the transformation
algorithm resolves all connected weak relationships (line 6)
and immediately tries to transform them (line 7 to 18). If weak
relationships are connected to a strong entity or an already
transformed weak entity (line 9 to 13), the current weak entity
can determine its existence-dependent type and therefore can
be transformed (line 15 to 16).
Note, that the cardinalities of the weak relationship are not
to be considered for the basic transformation, since these can
only be 1:1 and N:1 towards the identifying type. The given
algorithm realizes both functionalities by means of a foreign
key dependency.
E. Transformation of relationships
Transformation of regular relationships requires prior execu-
tion of all previous algorithms, since all relations for entities,
weak types and relationships require to have the complete
primary keys.
Generally, there are three cases to consider when translating.
If a relationship connects two entities and the cardinality is
N:M, the primary keys of the two entities are added to the
relation of the relationship. These then reference the primary
keys of the entity relations as foreign keys. The translation
of N-ary relations is done regardless of their cardinality. The
transformation of these is analogous to the translation of binary
N:M relations. In this case, the relation of the relationship
receives the primary keys of all connected entities. Each of this
primary keys refers to the primary key of the corresponding
entity in the form of a foreign key.
If the cardinality of the relationship is 1:N, the relationship
is resolved by merging the relation of the relationship with
the entities relation on the N side. In addition, this merged
relation receives all primary keys of the opposite entity as
normal attributes. These act as foreign keys on the opposite
entity. In the third case, the relationship cardinality is 1:1. The
translation is to be performed analogously to 1:N relationships,
and the entity that receives the foreign keys and relation
attributes must be specified for this purpose. Since this work,
the Min-Max notation is used, the optionality has to be
considered to avoid zero values. If one of the cardinalities
describes an optionality, the attributes of the relationship and
foreign keys are added to the entity on the other side. If both
or none of the cardinalities describe an optionality, then the
optionality is arbitrary.
Fig. 5. Transformation of relationships
Figure 5 shows the above cases. On the left side is the
ER model. On the right side is the relational model resulting
10
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-056-8
DBKDA 2023 : The Fifteenth International Conference on Advances in Databases, Knowledge, and Data Applications

from the translation of the ER model. The first box in Figure
5 shows the transformation of N:M relationships, while the
second displays a 1:N transformation. The last one shows the
transformation of an optional 1:1 relationship.
V. EVALUATION
Since the main focus of this paper is on practical appli-
cation, also a practical evaluation process was chosen. To
evaluate the algorithms given in this work a web application
has been developed and put into operation, which implements
all algorithms presented in this work. The application also
contains a graphical editor.
Within the editor the user is able to create extensive and
complex ER models, which are only restricted by a few limit-
ing rules, required to allow an unambiguous logical assignment
of the ER components. Based on the user-generated diagram,
the presented algorithms are used to transform the diagram
into a relational model without further user intervention.
To enforce correctly modeled ER diagrams, a validation
process was implemented. This validation mechanism is de-
signed in a user-friendly and proactive manner to ensure that
a user is able to model fast and easy. Therefore, the validation
offers maximum flexibility by only restricting actions which
would necessarily lead to a violation of a rule and therefore
lead into an mandatory reverse action. Utilizing the presented
algorithms and the validation procedure, the graphical editor
is able to translate any model that can be modeled with it into
the relational model. Furthermore, the editor visually presents
the created relational model to the user.
To increase the practical applicability, an SQL generator was
implemented within the application, which works on the basis
of the generated relational model and generates SQL schema
definitions. The generated SQL is in PostgreSQL dialect.
The graphical editor is shown in Figure 6. At first, a left
side bar can be seen. Elements on this bar can be dragged
into the drawing area to the right to create new elements. The
use of drag & drop is intended to make it possible to create
elements quickly and intuitively. The drawing area itself can
be expanded endlessly to the right and bottom. If an element
is selected, a side bar becomes visible on the right side, which
provides additional options. These are, for example, assigning
a name, deleting the element or creating a link to another
element. In the case of Figure 6, a relation was selected which
further enables the option to add new associations or edit the
cardinalities to existing entities.
To further enhance the practical applicability, a save and
load function has been implemented. Using this functionality
by clicking buttons on the right top of the editor, a model can
be saved in the form of a text file and at any time be loaded into
the editor. By using the button at the center bottom the model
can be transformed into the relational model, which will be,
without the need of any further user interaction, transformed
by the implemented algorithms and visually presented to the
user. Furthermore, it is possible to freely switch between the
conceptual and relational view using the tab bar in the upper
left. In order to generate SQL code from the relational model,
data types can be entered in the columns of the relational
model.
By means of these results, it is shown that the given
algorithms are implementable and are capable of performing
a transformation of ER models into relational models. We
have also conducted a preliminary evaluation regarding the
correctness of the transformation by testing the editor with a
predefined set of ER models containing different combinations
of modeling elements. The evaluation was successful as the
editor correctly transformed all supported concepts. A more
comprehensive evaluation will be part of our future work. To
enable a broader evaluation and application of the editor, we
made it available open source [31].
VI. CONCLUSION
Despite its age, ER modeling is still the most prevalent way
of creating conceptual data base schemata. Since its advent
in the 1970s, various extensions have been proposed. Due
to this, many different flavors are currently used in modern
editors. To be applicable as technical database schema, the
ER models have to be transformed into relational models. This
can be a complicated and error-prone task. Therefore, various
standardized transformation approaches have been proposed
over the decades. However, these approaches remained rather
theoretic and did not include operational semantics. Thus, no
tool support was established utilizing them and the transfor-
mation process remained manually to a large extend.
Despite this issue, modeling support for ER models was
achieved. To date, a high number of editors is available in
different flavors. There are diagram tools offering ER diagram
creation, database clients with ER schema creation options,
or other editors like UML editors incorporating database
modeling. While some of them only provide diagrams, others
enable the direct application to relational databases. However,
there is still no practical automated transformation of ER
diagrams to relational ones. Editors offering this do not enable
the modeling of real ER diagrams but rather enhanced DB
diagrams or omit important prevalent concepts like n-ary
relationships or generalization.
To tackle this issue, we proposed an approach for trans-
forming ER models to relational ones with a strong focus on
applicability and operational issues. The ER model incorpo-
rates the most prevalent and necessary concepts [29] as n-
ary relationships, multi-valued and composite attributes, or
generalization. All of these can be correctly transformed in
any meaningful combination enabling great flexibility for the
input models.
To prove the applicability of the proposed approach, we
have implemented a graphical ER editor capable of creating
diagrams containing all mentioned concepts as well as a an
automated transformation to relational models. As practical
applicability was our focus, we also added a validation mech-
anism to the editor that guarantees the creation of correct and
transformable ER models while providing the user as much
flexibility as possible and a good user experience. All in all
we have shown a transformation approach that can easily
11
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-056-8
DBKDA 2023 : The Fifteenth International Conference on Advances in Databases, Knowledge, and Data Applications

Fig. 6. ER Modeling Tool
be implemented in editors. This can aid future conceptual
database modeling, spare time, and reduce errors resulting
from manual transformation.
Our future work will focus on promoting the transformation
approach and the editor. At first we will carry out studies
investigating the correctness of the approach and the usability
of the editor. Further, we will add additional features to both of
them. This includes additional and optional concepts to the ER
models, like composition structures as well as other diagram
types and transformations.
REFERENCES
[1] P. Chen, ”The entity-relationship model—toward a unified view of data,”
ACM Trans. on DB Sys. vol. 1, no. 1, pp. 9-36, 1976.
[2] R. Elmasri and S.B. Navathe, Fundamentals of Database Systems.
Benjamin/Cummings, Redwood City, 1994.
[3] S. Spaccapietra and C. Parent, ”ERC + : an object based entity-
relationship approach,” Conceptual Modeling DBs and Case: An In-
tegrated View of Information Systems Development, John Wiley, 1992.
[4] B. Thalheim, ”Extending the entity-relationship model for a high level,
theory-based database design,” 1st Int. East West Database Workshop,
pp. 161-184, 1990.
[5] T.J. Teorey, ”Database Modeling and Design,” The Entity-Relationship
Approach, Morgan-Kaufmann, San Francisco, 1990.
[6] J. Makowsky, V. Markowitz, and N. Rotics, ”Entity-relationship con-
sistency for relational schemas,” Int. Conf. on Database Theory, pp.
306-322, 1986.
[7] A. D’Atri and D, Sacc`a, ”Equivalence and Mapping of Database
Schemes,” VLDB ’84, pp. 187–195, 1984.
[8] E. Wong and R. Katz, ”Logical design and schema conversion for
relational and DBTG databases,” Int. Conf. on ER Approach to Sys.
Analysis and Design, pp. 311-321, 1979.
[9] S. Jajodia, P.A. Ng, and F.N. Springsteel, ”The Problem of Equivalence
for Entity-Relationship Diagrams,” IEEE Trans. on SE vol. 9, no. 5, pp.
617 - 630, 1983.
[10] T. Teorey, D. Yang, and J. Fry, ”A logical design methodology for
relational databases using the extended entity-relationship model,” ACM
Computing Surveys (CSUR) vol. 18, no. 2, pp. 197–222, 1986.
[11] T. Ling, ”A Normal Form For Entity-Relationship Diagrams,” 4th Int.
Conf. on the ER approach, pp. 24-35, 1985.
[12] H. Sakai, ”Entity-relationship approach to the conceptual schema de-
sign,” SIGMOD ’80, pp. 1-8, 1980.
[13] Lucidchart.
Last
visited:
2023.01.24.
[Online].
Available:
https://www.lucidchart.com
[14] Draw.io.
Last
visited:
2023.01.24.
[Online].
Available:
https://app.diagrams.net/
[15] VisualParadigm.
Last
visited:
2023.01.24.
[Online].
Available:
https://online.visual-paradigm.com
[16] ERDPlus.
Last
visited:
2023.01.24.
[Online].
Available:
https://erdplus.com/
[17] pgAdmin.
Last
visited:
2023.01.24.
[Online].
Available:
https://www.pgadmin.org/
[18] MySQL Workbench. Last visited: 2023.01.24. [Online]. Available:
https://www.mysql.com/products/workbench/
[19] Enterprise Architect. Last visited: 2023.01.24. [Online]. Available:
https://www.sparxsystems.de/
[20] C. Fahrner and G. Vossen, ”A survey of database design transformations
based on the entity-relationship model,” Data and Knowledge Engineer-
ing vol. 15, no. 3, pp. 213–250, 1995.
[21] M. Kasra Habib, ”On the Automated Entity-Relationship and Schema
Design by Natural Language Processing,” Int. J. of Engineering and
Science vol. 8, no. 11, pp. 42–48, 2019.
[22] P. G. T. H. Kashmira and S. Sumathipala, ”Generating Entity Relation-
ship Diagram from Requirement Specification based on NLP,” 3rd Int.
Conf. on Information Technology Research, pp. 1-4, 2018.
[23] S. Ghosh, P. Mukherjee, B. Chakraborty, and R. Bashar, ”Automated
Generation of E-R Diagram from a Given Text in Natural Language,”
Int. Conf. on Machine Learning and Data Engineering, pp. 91-96, 2018.
[24] M. Ahsan Raza, M. Rahmah, S. Raza, A. Noraziah, and R. Abd. Hamid,
”A Methodology for Engineering Domain Ontology using Entity Rela-
tionship Model,” Int. J. of Advanced Computer Science and Applications
vol. 10, no. 8, pp. 326–332, 2019.
[25] K. ˇLachov´a and P. Trebuˇna, ”Modelling of Electronic Kanban System
by Using of Entity Relationship Diagrams,” Int. Scientific Journal about
Logistics vol. 6, no. 3, pp. 63–66, 2019.
[26] A. Ram´ırez-Noriega, Y. Mart´ınez-Ram´ırez, J. Ch´avez Liz´arraga, K.
V´azquez Niebla, J. Soto, ”A software tool to generate a Model-View-
Controller architecture based on the Entity-Relationship Model,” 8th
Int. Conf. in Software Engineering Research and Innovation, pp. 57-
63, 2020.
[27] Y. Liu, X. Zeng, K. Zhang, and Y. Zou, ”Transforming Entity-
Relationship Diagrams to Relational Schemas Using a Graph Grammar
Formalism,” IEEE Int. Conf. on Progress in Informatics and Computing,
pp. 327-331, 2018.
[28] L. Yang and L. Cao, ”The Effect of MySQL Workbench in Teaching
Entity-Relationship Diagram (ERD) to Relational Schema Mapping” Int.
J. Modern Education and Computer Science vol. 7, pp. 1–12, 2016.
[29] A. Kemper and A. Eickler, Datenbanksysteme. Eine Einf¨uhrung [En-
glish: DBMS. An Introduction] Oldenbourg, 2015.
[30] G. Vossen, Datenmodelle, Datenbanksprachen und Datenbankmanage-
mentsysteme [English: Data Models, Database Languages and DBMS]
5. Aufl. Oldenbourg, 2005.
[31] Editor Implementation. Last visited: 2023.01.24. [Online]. Available:
https://github.com/SimonRuttmann/ERModellingTool
12
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-056-8
DBKDA 2023 : The Fifteenth International Conference on Advances in Databases, Knowledge, and Data Applications

