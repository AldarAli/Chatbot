Towards Time-triggered Component-based System Models
Hela Guesmi, Belgacem Ben Hedia
CEA, LIST, PC 172
91191 Gif-sur-Yvette, France
Email: firstname.lastname@cea.fr
Simon Bliudze
EPFL IC IIF RiSD, Station 14
CH-1015 Lausanne, Switzerland
Email: simon.bliudze@epfl.ch
Saddek Bensalem, Jacques Combaz
Verimag,
38610 Gieres, France
Email: firstname.lastname@imag.fr
Abstract—In this paper, we propose a methodology for producing
correct-by-construction Time-Triggered (TT) physical model by
starting from a high-level model of the application software
in Behaviour, Interaction, Priority (BIP). BIP is a component-
based framework with formal semantics that rely on multi-party
interactions for synchronizing components. Commonly in TT
implementations, processes interact with each other through a
communication medium. Our methodology transforms, depend-
ing on a user-deﬁned task mapping, high-level BIP models where
communication between components is strongly synchronized,
into TT physical model that integrates a communication medium.
Thus, only inter-task communications and components partici-
pating in such interactions are concerned by the transformation
process. The transformation consists of: (1) breaking atomicity of
actions in components by replacing strong synchronizations with
asynchronous send/receive interactions, (2) inserting communica-
tion media that coordinate execution of inter-task interactions
according to a user-deﬁned task mapping, (3) extending the
model with an algorithm for handling conﬂicts between different
communication media and (4) instantiating task components and
adding local priority rules for handling conﬂicts between inter-
task and intra-task interactions. We also prove the correctness
of our transformation, which preserves safety properties.
Keywords–Anything;
Time-Triggered
paradigm;
correct-by-
construction; component-based design; model transformation; BIP
Framework.
I.
INTRODUCTION
A Time-Triggered (TT) system initiates all system activities
-task activation, message transmission, and message detection-
at predetermined points in time. Ideally, in a time-triggered
operating system there is only one interrupt signal: the ticks
generated by the local periodic clock. These statically deﬁned
activation instants enforce regularity and make TT systems
more predictable than Event-Triggered (ET) systems. This
approach is well-suited for hard real-time systems.
In [1] and [2], Kopetz presents an approach for real-time
system design based on the TT paradigm which comprises
three essential elements:
The global notion of time: It must be established by
a periodic clock synchronization in order to enable a TT
communication and computation,
The temporal control structure of each task: In a
sequence of computational or communication processes (called
tasks), the start of a task is triggered by the progression of
the global time, independently from the involved data of the
task. The worst-case execution time and thus the worst-case
termination instant are also assumed to be known a priori.
These statically predeﬁned start and worst-case termination
instants, deﬁne the temporal control structure of the task,
TT communication system: To isolate subsystems from
each other in a TT architecture, a special interface called
the temporal ﬁrewall has been designed. It consists in a
shared memory element for unidirectional exchange of in-
formation between sender/receiver tasks components. It’s the
responsibility of the TT communication system [3], [1] to
transport, with access to the global time, the information from
the sender ﬁrewall to the receiver ﬁrewall. The instants at
which information is delivered or received are a priori deﬁned
and known to all nodes. Furthermore, the TT communication
service/protocol avoids interference between concurrent read
and write operations on the memory elements.
Analysis and design of hard real-time systems often starts
with developing a high-level model of the system. Building
models allows designers to abstract away implementation
details and validate the model regarding a set of intended
requirements through different techniques such as formal ver-
iﬁcation, simulation, and testing. However, deriving a cor-
rect TT implementation from a high-level model is always
challenging, since adding TT implementation details involves
many subtleties that can potentially introduce errors to the
resulting system. Furthermore, in the context of hard real-
time systems (and time-triggered paradigm), services offered
by target operating systems should be taken into account in
the derived implementation.
Thus it is highly advantageous if designers can somehow
derive a model with implementation details in a systematic
and correct way from high-level models. We call such a
model physical model. It can be automatically translated to
the programming language speciﬁc to the target TT platform.
In this paper, we present a method for transforming high-
level models in BIP [4] into TT physical model that integrates
the three TT-paradigm properties mentioned above. The BIP
framework is used for constructing systems by superposition
of three layers: Behaviour, Interaction, and Priority. The Be-
haviour layer consists of a set of components represented by
automata or Petri nets extended by data and functions given
in C++. The interaction layer describes possible interactions
between atomic components. Interactions are sets of ports
allowing synchronizations between components. They are de-
ﬁned and graphically represented by connectors. The execution
of interactions may involve transfer of data between the
participating components. The third layer includes priorities
between interactions using mechanisms for conﬂict resolution.
In this work, we consider Real-Time BIP (RT-BIP) framework
[5], [6] where behaviour of components is represented by a
timed automaton [7].
We believe that the ﬁrst two properties of the TT paradigm
157
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

can be obtained straightforwardly from RT-BIP, and that the
main difﬁculty lies in representing tasks and inter-task com-
munication system in the physical model. To achieve this goal,
we introduced in this paper TT-BIP model, which combines
elements of both RT-BIP, Send/Receive BIP [8] (SR-BIP)
model and TT paradigm. It introduces additional structure
in order to model the TT communication system explicitly.
The TT communication system is modelled by introducing
dedicated atomic components. Depending on a user-deﬁned
task mapping, components in the system executing the same
task are grouped into composite components called tasks.
The latter can interact only through the atomic components
modelling the TT communication system. The TT-BIP model
draws on some of the ideas behind SR-BIP – the model used
for distributed implementation of untimed BIP systems [9] and
RT-BIP systems [10]. We also deﬁne transformation rules for
deriving a TT-BIP model from a high-level RT-BIP model and
a task mapping. We show that this transformation preserves
trace inclusion (i.e., safety properties).
The rest of this paper is structured as follows. In Section
II, we present the basic concepts related to our work; RT-
BIP and SR-BIP models. Section III formalizes the TT-BIP
architecture and describes the transformation. Experimental
results are presented in Section IV. Section V analyses related
work. And ﬁnally, we make concluding remarks in Section
VI. For lack of space, all correctness proofs appear in the
appendix.
II.
BACKGROUND CONCEPT: BIP FRAMEWORK
In this section, we ﬁrst provide the deﬁnition and the
semantics of RT-BIP. RT-BIP is a component framework for
constructing systems by superposing three layers of modelling:
Behaviour, Interaction, and priority. And then, we describe the
SR-BIP model. Before giving the deﬁnition and semantics of
an RT-BIP component, we ﬁrst ﬁx some notations.
A. Preliminary notations
1) Valuation function: Given a variable x, the domain of
x is the set D(x) of all values possibly taken by x. Given
a set of variables X, We denote by v(x) the corresponding
element of x ∈ D(x). A valuation of X is a function v :
X → S
x∈X D(x) associating with each variable x its value
v(x). Given a subset of variables X′ ⊆ X and a variable value
a ∈ D(x), we denote by v [X′ ← a] the valuation deﬁned by:
v[X′ ← a](x) =
a
if x ∈ X′
v(x)
otherwise.
(1)
We denote by V(X) = Q
x∈X D(X) the set of all possible
valuations of the variables in X.
2) Guards: Guards are boolean expressions used to specify
when actions of a system are enabled. A guard g is a predicate
on a set of variables X. Given valuation v ∈ V(X), we denote
by g(v) ∈ {False, True} the evaluation of g for v.
3) Clocks: We assume that time progress is measured by
clocks which are integer or real-valued variables increasing
synchronously. Each clock can be reset (i.e., set to 0) inde-
pendently of other clocks.
We denote by R+ the set of non-negative reals, and by N the
set of non-negative integers. Given a set of clocks C, let V(C)
be the set of all clock valuation functions vc : C → R+.
Given δ, such that δ ∈ R+, for all c ∈ C, we use c+δ as usual
notation for the valuation deﬁned by (vc + δ)(c) = vc(c) + δ.
4) Timing constraints: Timing constraints are guards over
the set of clocks C. They are used to specify when actions
of a system are enabled regarding system clocks. The basic
building blocks for timing constraints are comparisons; given
a set of clocks C, c ∈ C and a ∈ R+, comparison between
the valuation of c and a can be presented as c ∼ a where
∼∈ {≤, <, =, >, ≥}. Constraints are built using the following
grammar:
tc := True | False | c ∼ a | tc ∧ tc | tc ∨ tc | ¬tc
Notice that any guard tc can be written as:
tc :=
^
c∈C
lc ≤ c ≤ uc, where lc, uc ∈ R+∀c ∈ C
(2)
We denote by T C(C), the set of clock constraints deﬁned over
clocks of C.
5) Time progress conditions: Time progress conditions are
used to specify whether time can progress at a given state
of the system. They correspond to a special case of timing
constraint where ∼ is restricted to {≤} and operators ¬ and ∨
are disallowed. Formally, time progress conditions are deﬁned
by the following grammar:
tpc := True | False | c ∼ a | tc∧tc, where c ∈ C and a ∈ R+
Note that any time progress condition tpc can be written as:
tpc =
^
c∈C
c ≤ uc, where uc ∈ R+ ∪ {+∞}
(3)
B. Basic semantic model of RT-BIP
In RT-BIP, systems are built by composing atomic compo-
nents with interactions deﬁned using connectors.
A component in RT-BIP is essentially a timed automaton
[11] labelled by ports that represent the component’s interface
for communication with other components. Let P be a set of
ports. We assume that every port p ∈ P has an associated data
variable xp. This variable is used to exchange data with other
components, when interactions take place.
Deﬁnition 1: (Component). A component B is a tuple
B = (L, P, X, C, T, {tpcl}l∈L) where: L is a ﬁnite set of
control locations, P ⊆ P is a ﬁnite set of ports, called the
interface of B, X is a set of local variables. We denote the
set of variables associated to ports by XP ⊆ X and the set of
the rest of local variables by XB, such that X = XB ∪ XP ,
C is a ﬁnite set of clocks, T is a set of labelled transitions.
A transition τ ∈ T from a control location l to l′ is a tuple
τ = (l, p, gτ, fτ, R, l′) where :
• p is a port.
• gτ = gX∧tc is a boolean guard, which is a conjunction of a
predicate gX on local variables X and a timing constraint
tc over C. We say that a transition τ is enabled for the
valuation v ∈ V(X), when its guard gτ evaluates to True.
• fτ is a function that updates the set of variables on X
• R is the subset of clocks R ⊆ C, that are reset by the
transition τ.
For each place l ∈ L, tpcl is a time progress condition.
Deﬁnition 2: (Semantics of a component). The semantics
of a component B = (L, P, X, C, T, {tpcl}l∈L) is deﬁned as a
labelled transition system SB = (QB, PB, −→
B ), where: QB =
158
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

L × V(C) × V(X) is the set of states, PB = P ∪ R⩾0 is the
set of labels: ports or time delays, −→
B ⊂ QB × PB × QB is
the set of labelled transitions deﬁned as follows. Let (l, vc, vx)
and (l′, v′
c, v′
x) be two states, p ∈ P, and δ ∈ R⩾0 be a delay.
• Jump transitions: We have (l, vc, vx)
p−→
B
(l′, v′
c, v′
x) iff
there exists a transition τ = (l, p, gτ, fτ, R, l′) enabled for
(vc, vx) and v′
x = fτ(vx), and for all c ∈ r, v′
c(c) = 0.
• Delay transitions: We have (l, vc, vx)
δ−→
B (l, vc +δ, vx) iff
∀δ′ ∈ [0, δ], tpcl(vc + δ′) evaluates to True.
A
component
B
can
execute
a
transition
τ
=
(l, p, gτ, fτ, R, l′) from a state (l, vc, vx) if its timing constraint
is met by the valuation vc. The execution of τ corresponds to
moving from control location l to l′, updating variables and
resetting clocks of R. From state (l, vc, vx), B can also wait
for δ > 0 time units if the time progress condition tpcl stays
True. Waiting for δ time units increases all the clock values
by δ. Notice that the execution of transitions is instantaneous
and time elapses only on states.
The interaction model is speciﬁed by a set of interactions
γ ⊆ 2P . Interactions of γ can be enabled or disabled.
Deﬁnition 3: (Interaction). Let {Bi}n
i=1 be a set of com-
ponents as above. An interaction α between components
{Bi}n
i=1 is a quadruple (a, Xa, Ga, Fa), where: a ⊆ P con-
tains at most one port of every component, that is, | a∩Pi |⩽ 1,
for all i ∈ [1, n]. Xa = ∪p∈aXp is the set of variables available
to an interaction α. Ga is the set of boolean guards associated
to α. Fa is the set of the update functions associated to α and
deﬁned over Xa.
In the remainder of the paper, we may denote the interac-
tion (a, Xa, Ga, Fa) by its set of ports a. An interaction a is
enabled for a valuation va of Xa if and only if, for all i ∈ [1, n],
the port in a ∩ Pi is enabled in Bi and Ga(va) = True. That
is, an interaction is enabled if each port that is participating in
this interaction is enabled and the guard evaluates to True.
We denote by comp(a) the set of components that have
ports participating in a. comp(a) is formally deﬁned as:
comp(a) = {Bi|i ∈ [1, n], Pi ∩ a ̸= ∅}
(4)
Two interactions are conﬂicting at a given state of the system if
both are enabled, but it is not possible to execute both from that
state (i.e., the execution of one of them disables the other). In
fact the enabledness of interactions only indirectly depends on
the current state, through the enabledness of the participating
ports. In systems without priorities, two interactions a and b
may conﬂict only if they involve a shared component. In Figure
1a, the conﬂict comes from the fact that a and b involve two
ports p and q of the same component labelling two transitions
enabled from the same location. When reaching location, the
component can execute either transition labelled by p or the
one labelled by q but not both. This implies that when a and
b are enabled, only one of them should execute. Figure 1b
depicts a special case of conﬂict where interactions a and b
share a common port p. Update functions of a and b may
update variables exported by port p. This implies that when a
and b are enabled, only one of them should execute.
Deﬁnition 4: (Conﬂicting interactions).
Let γ(B1, ..., Bn) be a BIP model. We say that two
interactions a and b of γ are conﬂicting, iff, there exists an
l
p
q
p
a
q
b
(a)
p
a
b
(b)
Figure 1. Conﬂicting interactions
atomic component Bi ∈ comp(a) ∩ comp(b) that has two
transitions τa = (l, p, l′
1) and τb = (l, q, l′
2) from the same
control location l such that p ∈ a and q ∈ b. We denoted the
conﬂict between a and b by a#b. If a and b are not conﬂicting
we say that they are independent. The system is conﬂict-free
if all interactions are pairwise-independent.
Priorities are deﬁned in order to reduce non-determinism
in the system, that is, they are used to ﬁlter interactions among
the enabled ones.
Deﬁnition 5: (Priority in BIP).
Given a set γ of interactions deﬁned over a set of
components {B1, ..., Bn}, we deﬁne a priority as a relation
π ⊆ BQ×γ×γ, where B is the set of booleans and Q the set of
states, such that for all (C, a, a′) ∈ π, C depends only on data
variables that are associated with ports of interactions a or a′
and ∀q ∈ Q, πq = {(a, a′) ∈ γ×γ | C(q)∧(C, a, a′) ∈ π} is a
partial order. We say that a has less priority than a′ whenever
the predicate C holds.
The predicate C depends on the data variables exported by
the participants in some interactions, allowing the correspond-
ing priority rule to be dynamically enabled. A static priority
is expressed by having C = True for all (C, a, a′) ∈ π.
A composite component is built from a set of n components
{Bi
=
(Li, Pi, Xi, Ci, Ti, {tpcl}l∈Li)}n
i=1 such that their
respective sets of places, ports, clocks, and discrete variables
are pairwise disjoint; i.e., for any two i ̸= j from [1, n], we
have Li ∩Lj = ∅, Pi ∩Pj = ∅, Ci ∩Cj = ∅, and Xi ∩Xj = ∅.
Deﬁnition 6: (Composite Component with interactions).
Let γ be a set of interactions. We denote by B
def
=
γ(B1, ..., Bn) the composite component obtained by apply-
ing γ to the set of components {Bi}n
i=1. It is deﬁned by
the component B = (L, P, X, C, T, {tpcl}l∈L) as follows:
L = L1 × ... × Ln is the set of locations, P = Sn
i=1 Pi
is the set of ports, X = Sn
i=1 Xi is the set of variables,
C = Sn
i=1 Ci is the set of clocks, Let α = (a, Xa, Ga, Fa) ∈ γ
be an interaction. We denote Ia = i ∈ [1, n]|Bi ∈ comp(a).
A transition τ = (l, a, gτ, fτ, R, l′) from l = (l1, ..., ln) to
l′ = (l′
1, ..., l′
n) (l = l′ if i /∈ Ia) is in T if its projection
τi = (li, pi, gτi, fτi, Ri, l′
i) is a transition of Bi for all i ∈ Ia,
where gτ i and fτ i are such that :
• gτ = Ga ∧ V
i∈Ia
gτi,
• fτ = fτ1 ◦ ... ◦ fτn ◦ Fa where fτi is the identity function,
for i /∈ Ia (Notice that functions fτi modify disjoint sets
of variables, hence can be composed in any order),
• R = S
i=Ia Ri.
For a control location l = (l1, ..., ln) ∈ L, the time progress
condition is tpcl =
V
i∈[1,n]
tpcli.
159
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

Deﬁnition 7: (Composite Component with priorities). Let
Bγ = γ(B1, ..., Bn) be the composite component obtained
by applying γ to the set of components {Bi}n
i=1. And let
L be their set of locations and π the set of priority rules
πl for l ∈ L. We denote by Bπγ = πγ(B1, ..., Bn) the
composite component obtained by applying priorities to the
set of components Bγ: Given two interactions a, a′ ∈ γ,
with corresponding transitions τ γ = (l, a, gτ γ, fτ γ, Ra, l′) and
τ ′γ = (l, a′, gτ ′γ, fτ ′γ, ra′, l′′) in Bγ, such that ∃(C, a, a′) ∈ π
(i.e. a has less priority than a’ in the current location l), the
corresponding transitions in Bπγ are:
• τ πγ = (l, a, gτ πγ, fτ γ, Ra, l′), with gτ πγ = gτ γ ∧¬gτ ′γ ∧C,
• and τ ′πγ = (l, a′, gτ ′πγ, fτ ′γ, Ra′, l′′), with gτ ′πγ = gτ ′γ.
The execution of interactions, taking into account priority
rules and execution of local code of components are orches-
trated by a sequential scheduler. Conﬂicts that are not resolved
by priority rules are resolved by this scheduler; it randomly
chooses one of simultaneously enabled interactions.
Components that are not composite, i.e. speciﬁed directly
as LTS in the model, are called in the remainder of the article
atomic components.
C. SR-BIP model
The SR-BIP models are designed, for untimed [8], [12]
and timed [10] BIP, to automatically derive distributed im-
plementations. They are intended to be implementable us-
ing basic message-passing primitives. The execution of a
distributed process is a sequence of actions that are either
message emission, message reception or internal computa-
tion. Consequently the SR-BIP model includes three types of
ports: send-ports, receive-ports and unary-ports. Unary-ports
correspond to internal computation. They can only appear
in unary interactions, that is interactions involving only one
component. Send and receive ports appear only in message-
passing interactions (called send/receive interactions). Such
an interaction has no guard, and the update function copies
variables exported by the send-port to variables exported by
the receive-port. In a canonic message-passing environment,
each send action has a well-deﬁned recipient. Therefore, it is
required in SR-BIP models that each send-port participates in
exactly one send/receive interaction. The latter ensures that for
each send-port there is a unique corresponding receive-port.
An SR-BIP model is an RT-BIP model which contains
components glued by send/receive interactions. A send/receive
interaction is composed of one send-port and one or more
receive-ports depending on the data transfer direction.
Since concurrency and distribution introduced to RT-BIP
model can not be handled by sequential single scheduler,
SR-BIP model handles interactions in dedicated schedulers,
and resolves conﬂicts through conﬂict resolution protocol. It
complies with a 3-layer architecture consisting of:
1) Components layer: The bottom layer consists of atomic
components. Their interfaces are made of one send-port and
one or more receive-ports. Components share their lists of
enabled ports with the upper layer.
2) Schedulers: The second layer consists of a set of com-
ponents each hosting a set of interactions. Conﬂicts between
interactions included in the same component are resolved lo-
cally. And conﬂicts between interactions of different scheduler
components are resolved using the third layer.
3) Conﬂict Resolution Protocol (CRP): This layer im-
plements an algorithm based on the idea of message-count
technique presented in [13]. It consists on counting the number
of times that component participates in an interaction. Conﬂicts
are resolved by ensuring that each participating number is
used only once. Different implementations of the reservation
protocol are presented in [8].
III.
FROM HIGH-LEVEL RT-BIP TO TT PHYSICAL MODEL
In this section, we propose a generic framework for trans-
forming an RT-BIP model into a TT physical model. We ﬁrst
detail subtleties of this transformation with respect to RT-
BIP and SR-BIP. Then, we present the TT-BIP architecture
that addresses these subtleties. Finally, we describe how to
construct a correct TT-BIP model starting from a high-level
RT-BIP model.
A. Subtleties of the transformation
In sequential models, interactions are executed atomically
by a single scheduler. To the contrary, introducing TT settings
(mainly decomposition into tasks and assuming TT communi-
cation mechanism) to this model requires the implementation
to deal with more complex issues:
1) Decomposition into Tasks: Tasks (processes, threads,
etc.) are building blocks for TT applications. In Design phase,
designers have the choice to model a TT task using one or more
BIP components. Thus depending on the user task mapping,
tasks should appear in the derived physical model with respect
to the initial high-level model.
2) Strong synchronization in BIP interactions Vs. message-
passing: In order to respect TT communication setting, the
derived physical model should handle intertask communication
through dedicated RT-BIP component which stands for the
TT communication system. The challenge is to switch from
the high-level RT-BIP model, where multiparty synchronized
interaction is a primitive, to the TT model, where inter-task
communication is performed via a communication medium.
3) Resolving conﬂicts: In high-level RT-BIP model, con-
ﬂicts are handled by the single scheduler. TT communication
components in the derived model must ensure that execution
of conﬂicting interactions is mutually exclusive.
We address the ﬁrst issue, by initiating composite task
components that encompass atomic components mapped to
the same task. The second problem is addressed by breaking
the atomicity of execution of interactions, so that a task
can execute unobservable actions to notify TT communi-
cation component about their states, and then execute the
corresponding interaction. Communication between tasks and
TT communication component is send/receive interactions.
Resolving conﬂicts leads us to use solution proposed in SR-
BIP model, which consists in instantiating a BIP component
that implements the algorithm proposed in [13]. The latter
uses message counts to ensure synchronization and reduces the
conﬂict resolution problem to dining or drinking philosophers
[14].
B. TT-BIP Architecture
In this subsection, we present the TT-BIP architecture that
combines elements of RT-BIP, SR-BIP and the TT paradigm
to address previously mentioned issues. This architecture is
based on tasks (processes, threads, etc.) as one of its build-
ing blocks. A task can be mapped on one or more atomic
160
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

components. Inter-task communication is handled by dedicated
components called Time-Triggered Communication Compo-
nents (TTCC) standing for schedulers in RT-BIP and SR-BIP
models. Conﬂicts between different TTCC components, are
resolved through CRP components of SR-BIP model.
An RT-BIP model BT T complies with the TT-BIP architec-
ture if it consists of three basic entities: Tasks, TTCC and CRP
components, organized by the following abstract grammar:
TT-BIP-Model ::= Task+ . TTCC+ . CRP . S/R-connector+
Task
::= atomic-component+ .
atomic-talking-component+ . connectors+
TTCC
::= TTCCNC | TTCCC
Task 1
B0
B1
B2
a0
sr
sr
s
r
r
s
r
Task 2
B3
B4
a2
sr
sr
s
r
Task 3
B5
r
s
r
TTCCC
r
s
r
TTCCC
r
s
r
TTCCNC
r
s
r
CRP
r
s
s
r
s
s
Figure 2. TT-BIP model
Task components (resp. TTCC components) and TTCCs
(resp.
CRP
components)
communicate
with
each
other
through
message-passing,
i.e.,
send/receive
interactions.
This latter is a set of one send port and one or more
receive ports. Communication between components inside a
task are classic multi-party RT-BIP interactions (see. Figure 2).
Deﬁnition 8: We
say
that
BT T
=
πT T γT T (BT T
1
, ..., BT T
n ) is a TT-BIP model iff we can
partition the set of its interactions in two sets AI and AE
that are respectively sets of internal and external interactions,
corresponding to intra-task and inter-task interactions, such
that:
• Each interaction a ∈ AI, is a classic multi-party interaction
presented by classic RT-BIP connectors relating atomic
components inside one task component,
• Ports of Task, TTCC and CRP components can be parti-
tioned into three sets Pu, Ps and Pr that are respectively
the set of unary ports, send ports and receive ports. Each
interaction a ∈ AE, is either (1) a send/receive interaction
with a = s, r1, ..., rk, s ∈ Ps, r1, ..., rk ∈ Pr or, (2) a
unary interaction a = p with p ∈ Pu,
• The order of execution of transitions labelled by send or
receive-ports depends on the nature of component (task,
TTCC or CRP component). In task (resp. TTCC and
CRP) components, each one or two successive transition(s)
labelled by send-port(s) (rep. receive-ports) should be ac-
knowledged by a transition labelled by receive-port (resp.
send-port),
• If s is a port in Ps, then there exists one and only one
send/receive interaction a ∈ γT T with a = (s, r1, ..., rk)
and all ports r1, ..., rk are receive-ports. We say that
r1, ..., rk are receive-ports of s,
• If a = (s, r1, ..., rk) is a send/receive interaction in γT T
and s is enabled at some global state of BT T , then all its
receive-ports r1, ..., rk are also enabled at that state,
The speciﬁcity of each constituent element of the TT-BIP
architecture is detailed below.
1) Task components: A task component is a composite
component consisting of one or more atomic components
related to each other using connectors. Atomic components
within a task which export their send and receive ports to
the task interface are called atomic-talking-components (ATC).
These latter can only communicate with a TTCC components
(through the task component interface). TTCC component
interferes only in external interactions referring to inter-task
interactions AE. These external interactions are presented
locally (in the task component) by artefact interactions. We
denote the set of these artefact interactions by AEartefact. The
remaining components in a task, do not export their ports. They
can only participate in internal interactions AI (see Figure 3).
Task
B1
B2
a1
sr
sr
s
r
asartefact
arartefact
as
ar
Internal interaction: a1
External interactions: as and ar
Artefact interactions: asartefact
and arartefact
a1 > as, ar
L1
L3
L1
qs
p
Figure 3. Example of a task component
In task component, conﬂicts between internal and artefact
interactions can be resolved by local priority rules. In such
cases, execution of internal interactions are privileged to ex-
ternal ones, that is, internal interactions have more priority
than artefact ones (see. Figure 3). Through these priority rules,
all possible conﬂict cases are handled. If the conﬂict can be
resolved locally, the priority rule a ∈ AI > a′ ∈ Aartefact
can be used. Otherwise, the conﬂict will be handled by TTCC
and CRP components.
Each ATC component in the task component has one or
more send and receive ports and zero or more standard ports. It
contains in addition to observable states and transitions, some
partial states and unobservable transitions. An unobservable
transition always leads to a partial state. Transitions allowing
communication with the TTCC could be seen as a non atomic
transition. It starts ﬁrst by a non visible transition labelled by
the send port. It allows to send an offer ( i.e., information
about active ports) to TTCC component. This transition is
followed then by a visible transition labelled by the receive
port indicating the completion of the communication. These
two transitions are separated by a partial-state location standing
for a busy state of the component where it is waiting for a
notiﬁcation from the TTCC via the receive port (cf. Figure 4).
xr, gr
L1
⊥p
L2
s
r
s
xr, gr
r
xr
Figure 4. ATC Communication pattern
2) TTCC Component: Each TTCC component represents
one interaction a ∈ γ with a = (a, Ga, Fa), we denote
by n the number of components related to TTCC. It is
inspired from schedulers of the SR-BIP models implemented
for distributed implementations in BIP [9] and RT-BIP [10].
The TTCC component is designed to model the behaviour of
161
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

the communication system in the TT paradigm in order to
execute an interaction a. There are two different types of TTCC
components: conﬂicting and non-conﬂicting, denoted respec-
tively TTCCC and TTCCNC. TTCC component behaviour
is made of three steps; (1) the component reads variables and
guards from task components, (2) based on these received
guards and the guard of the interaction a, the TTCC component
takes a decision by either executing the interaction upon
synchronization (i.e., conjunction of read guards evaluates to
True) if a is a non-conﬂicting interaction or soliciting the
CRP component to ﬁnd out if the conﬂicting interaction a
can be executed and (3) ﬁnally it writes on appropriate task
components by sending a notiﬁcation. Figure 5a presents an
example of TTCCNC and Figure 5b presents an example of
TTCCC for n = 2.
wait
start
L1
L2
read
write
wait
p1
r
p2
r
p2
r
p1
r
G V g1
p
V g2
p
ps
F
Xl ∪ {(xi
p, gi
p)}i∈1..2
p1
r
x1
p, g1
p
p2
r
x2
p, g2
p
ps
x1
p, x2
p
(a) TTCCNC component, n=2
wait
start
L1
L2
read
try
write
wait
p1
r
p2
r
p1
r
p2
r
p2
r
p1
r
rsv
p1
r
p2
r
p1
r
p2
r
G V g1
p
V g2
p
fail
ps
F
ok
Xl ∪ {(xi
p, gi
p)}i∈1..2
p1
r
x1
p, g1
p
p2
r
x2
p, g2
p
ps
x1
p, x2
p
rsv
ok
fail
(b) TTCCC component, n=2
Figure 5. Conﬂicting and non conﬂicting TTCC components
The behaviour of the TTCC components is described as a
timed automata. It depends on whether the TTCC handling an
interaction a is conﬂicting (TTCCC) or not (TTCCNC).
The set of variables of TTCC can be partitioned into two
classes. The ﬁrst class consists in variables updated whenever
an offer from ATC components Bi participating in the interac-
tion a is received. They consist of the following: guard variable
gi
p and a local copy of the variables Xi
p for each port p involved
in the interaction a, a time progress condition variable tpci and
a participation number variable ni for each ATC component
Bi of tasks participating in a. The second class consists in
variables updated whenever interaction a is scheduled which
are: execution date variable texa, that stores the last execution
date of interaction a and, an execution date variable texi for
each component Bi participating in a.
In case of a non conﬂicting TTCC (TTCCNC), the set of
places contains the followings: For each ATC component Bi
within a task involved in the interaction a, we include waiting
places: wait and the set L⊥ with |L⊥| =
n−2
P
k=0
kQ
j=0
(n − j).
L⊥ locations present states where component is waiting for
reception of other tasks guards and variables. Each place l⊥ ∈
L⊥ that is reached by a transition receiving offer from Bi,
has a time progress condition deﬁned by the variable tpci.
We include a writing place write that allows notiﬁcation of
tasks (and then ATC components) participating in a. The time
progress condition of write is False. In case of a conﬂicting
TTCC (TTCCC), the set of states includes the same states of
a non conﬂicting TTCC, with an additional trying state trya.
The set of ports of a non conﬂicting TTCC consists of
the following: For each ATC component Bi within a task
involved in the interaction a,TTCC includes a receive-port pri,
to receive offers. Each port pri is associated with the variables
gi
p and Xi
p for each port p of Bi as well as the variable tpci
and ni of Bi. The set of ports of TTCC includes a send-port
ps, which exports the set of variables ∪Xp
p∈a
∪ {texi} where i
is the index of ATC component Bi that exports port p. TTCC
includes also a unary port a allowing the execution of the
interaction a. In case of a conﬂicting TTCC (TTCCC), the
set of ports includes the same ports of a non conﬂicting TTCC
except the unary one, with additional ports; rsva associated
with the set of variables ni of components Bi ∈ comp(a).
Transitions of a non conﬂicting TTCC are as following:
In order to receive data from task components; we include
for each {l, l′} ⊆ {{wait, read} ∪ L⊥} and each i ∈ [1..n]
a transition τreceivei = (l, pi
r, True, Identity, l′). This transi-
tion guard is default to True. In order to execute the interaction
a we include the Transition leading from state read to state
write , where τa = (read, pu, Ga
V(
nV
i=1
gi
p) ,Fa, write) where
pu is a unary port, Ga is a guard on variables of the set
Xl, and Fa is a function on Xl. To notify task components
after executing the interaction a, we include the transition
τwrite = (write, ps, True, Identity, wait).
In case of a conﬂicting TTCC (TTCCC), the set of transitions
includes in addition to transitions τreceive and τwrite of non
conﬂicting TTCC, the following transitions: To each place
l⊥ ∈ L⊥ reached by transition labelled by port pri we
include a loop transition τloopi = (l⊥, pi
r, True, Identity, l⊥).
Before executing interaction a, we include the transition
that will solicit the CRP component from the state read,
where τrsv = (read, rsv, True, Identity, try). We also in-
clude loop transitions on place read, allowing reception
from receive ports, such that for all i ∈ [1, n], τ ′
loopi =
(read, pi
r, True, identity, read). From try location, the ﬁrst
possible transition, depending on the response of the CRP
component, τok = (try, ok, Ga
V(
nV
i=1
gi
p), Fa, write), where
Ga is a guard on variables of the set Xl, and Fa is a function
on Xl. This transition will execute the interaction a. We
also include loop transitions on place try, allowing reception
from receive ports, such that for all i ∈ [1, n], τ ′′
loopi =
(try, pi
r, True, identity, try). The second possible transition
from state try is τfail = (try, fail, True, Identity, read), in
that case, a is not allowed to execute.
3) Conﬂict Resolution Protocol Component: The conﬂict
resolution protocol (CRP) accommodates the algorithm pro-
posed in [13]. It uses message counts to ensure synchroniza-
tion and reduces the conﬂict resolution problem to dining
or drinking philosophers [14]. Its main role is to check the
freshness of requests received for an interaction, that is, to
check that no conﬂicting interactions has been already executed
using the same request. In each request, an interaction sends
the participation numbers of its components, i.e., number of
interactions each ATC component has participated in. This en-
sures that two conﬂicting interactions cannot execute with the
same request. Mutual exclusion is ensured using participation
162
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

numbers. To this end, the conﬂict resolution protocol keeps
the last participation number Ni of each component Bi and
compares it with the participation number ni provided along
with the reservation request from TTCC components. If each
participation number from the request is greater than the one
recorded by the conﬂict resolution protocol (ni > Ni), the
interaction is then granted to execute and Ni is updated to ni.
Otherwise, the interaction execution is disallowed. Figure 6
presents the places, transitions, variables, guards and update
functions involved in handling an interaction a with two
participating components B1 and B2. Whenever a reservation
for executing a arrives, this token moves from place waita to
place receivea. From this place, if the guard of the transition
labelled by oka is Trueaccording to the current values of Ni
variable and freshly received ni variables, the transition can
take place. The transition labelled by faila is always possible.
waita
receivea
rsva
faila
n1 > N1
V n2 > N2
oka
N1 := n1
N2 := n2
rsva oka faila
n1
n2
N1 N2
Figure 6. Fragment of the CRP component
C.
From High-level RT-BIP model to TT-BIP model
In this section, we present the model transformation
from
a
RT-BIP
model
B
def
=
πγ(B1, ..., Bn)
into
an
equivalent
TT-BIP
model
BT T
=
πT T γT T (BT T
1
, ..., BT T
n , TTCC1, ..., TTCCm, CRP).
This transformation is parametrized by a user-deﬁned task
mapping which consists in associating to each task Tk a group
of atomic components of the model B. We denote by B the
set of atomic components of model B. We assume, we have
K ≤ n tasks and we denote by T = {Tk}k∈K the Task set,
such that T is a partition of B: where for all j, k ∈ K and j ̸=
k, Tj∩Tk = ∅. For all k ∈ K we have Tk = {Bi}i∈Ik, Ik ⊆ K
such that
∪
k∈KIk = K.
The transformation process is performed in two steps as
shown in Figure 7. First, an analysis phase allows deﬁnition of
set of components and connectors to be transformed depending
on the task mapping. Then, the RT-BIP model is transformed
into a TT-BIP model where only inter-task interactions are re-
placed by TTCC components and intra-task interactions remain
intact. Components mapped to the same task are gathered in
a composite task component.
We consider that the original RT-BIP model consists only
of atomic components and ﬂat connectors. Moreover, each
connector deﬁnes one and only one interaction. Indeed, these
assumptions do not impose any restrictions on the original
model, since we can apply the transformations ”Component
ﬂattening” and ”Connector ﬂattening” of previous research
work in [15].
Task mapping
RT-BIP model
Multiparty
interactions
and priorities
TT-BIP model
Tasks
TTCC
and CRP
analysis phase
Transformation
Figure 7. Transformation from RT-BIP to TT-BIP model
D. Analysis Phase
Starting from a high-level RT-BIP model and a user task
mapping, a TT-BIP model can be derived. Thus, we have ﬁrst
to identify internal and external interactions as well as ATC
components. Conﬂicts between external interactions are held
by CRP components. But conﬂicts between an internal and
external interactions should be also resolved. We distinguish
between three cases of a conﬂict between an internal and
external interaction; (1) conﬂict not resolved in the initial
model by a priority rule, (2) conﬂict initially resolved by a
static priority rule and (3) a conﬂict initially resolved by a
dynamic priority rule. These three cases should be taken into
account. In the ﬁrst case, the conﬂict can be resolved locally in
the task by imposing a priority rule that privileges the internal
interaction (see Figure 3). In the second case, the conﬂict is
already resolved and the initial priority rule is kept in the
derived model. In the third case, task component can’t resolve
the conﬂict locally, since it doesn’t have access to the global
state of the model and thus can’t evaluate the dynamic priority
rule. In that case, the internal conﬂicting interaction is exported
to be held by a dedicated TTCC. This interaction is thus being
an external interaction. And the conﬂict is being a conﬂict
between two external interactions. It can now be resolved by
the CRP component initially intended to handle such a conﬂict.
The algorithm of the analysis phase initialises sets of
internal, external and ATC components (A′
I, A′
E and B′AT C)
based on the task mapping. And then, it deﬁnes new sets (AI,
AE and BAT C) depending on conﬂicts between internal and
external interactions and existing priority rules related to this
conﬂict. These obtained sets are inputs for the transformation
process.
A′
I, A′
E and B′AT C sets are deﬁned depending on the user
task mapping as follows:
• External interactions: A′
E set is deﬁned as the set of
interactions in the participant components of which we can
ﬁnd at least two different atomic components belonging to
two different tasks.
Formally, A′
E = {a ∈ γ | ∃B1, B2 ∈ comp(a), T1, T2 ∈
T : B1 ∈ T1, B2 ∈ T2, T1 ̸= T2}.
• Internal interactions: A′
I set in deﬁned as the set of
interactions in the participant components of which we can
ﬁnd only atomic components belonging to the same task.
A′
I = γ \ A′
E.
• Atomic talking components: B′AT C set is initialised to
the set of atomic components in B that are concerned
by external interactions (i.e., are related to other atomic
components belonging to a different task). We deﬁne
B′AT C = {B ∈ B|A′
E ∩ PB ̸= ∅}, where PB is the port
set of the component B.
After deﬁning initial sets of internal interactions, external
interactions and ATC components, the ﬁnal sets AE, AI
and BAT C are deﬁned depending on existing priority rules
following Rule 1.
Rule 1: For each a ∈ A′
I, and, a′ ∈ A′
E such that ∃q ∈ Q,
(C(Q), a, a′) ∈ πQ, AE = A′
E ∪ {a}, AI = γ \ AE, BAT C =
{B ∈ B|AE ∩ PB ̸= ∅}.
E.
Transformation rules
Starting from an RT-BIP model B
def
=
πγ(B1, ..., Bn),
we ﬁrst apply a variation of the transformation from RT-BIP
163
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

to SR-BIP [8] which transforms original atomic components
deﬁned in the RT-BIP model by send/receive components,
handles initial interactions using schedulers and adds a conﬂict
resolution protocol component for conﬂict resolution. Then,
we instantiate components associated to the same task in one
composite task component following Rule 4.
In our case, we need to implement intertask communication
using dedicating components instead of BIP connectors. Thus,
we propose here to apply the send/receive transformation only
to the subset of components and connectors dedicated to inter-
task communication in the initial model. Thus, only ATC com-
ponents are transformed in send/receive atomic components
following Rule 2, and only inter-task connectors referring to
external interactions AE are replaced by TTCC components
and the CRP component following Rule 3.
1) ATC component transformation: Every atomic compo-
nent can deﬁne a set of local clocks. They can be reset at any
time and are involved in timing constraints and time progress
conditions. TTCC component makes use only of the common
time scale presented by a global clock Cgwhich is initialized
to 0 and is never reset, and measures the absolute time elapsed
since the system started executing.
Since TTCC receives timing constraints and time progress
conditions from different ATC components, it would be better
if these latter transforms their sent data using the global clock.
Therefore, we follow the approach of [6]: for each clock c of
an atomic component B, we introduce a variable ρc that stores
the absolute time of the last reset of c. This variable is updated
whenever the component executes a transition resetting clock
c. In fact, when the TTCC executes an interaction a, it stores its
execution date in a variable texa. The value of this variable is
then sent to participating components (during the notiﬁcation).
Each participating component executes then the corresponding
transition according to the received notiﬁcation, and updates
each variable ρc to texa if the transition resets clock c in the
original model. Notice that the value of c can be computed
from the current value of Cg and ρc by using the equality
c = Cg − ρc. Using ρc, any timing constraint tc involved in a
component B can be expressed using the clock Cg instead of
clocks C. We can transform tc as follows:
tc =
m
_
k=1
^
c∈C
lk
c ⩽ c ⩽ uk
c =
m
_
k=1
^
c∈C
lk
c + ρc ⩽ Cg ⩽ uk
c + ρc
(5)
Similarly, any time progress condition tpc involved in B
is transformed using the clock Cg as follows:
tpc =
_
c∈C
c ⩽ uc =
_
c∈C
Cg ⩽ uc + ρc
(6)
We
transform
then
an
ATC
component
BAT C
=
(L, P, X, C, T,
{tpcl}l∈L)
of
a
RT-
BIP
model
into
a
TT
ATC
component
BT T
=
(LT T , P T T , XT T , CT T , T T T ,{tpcT T
l
}l∈L)
that
is
capable
of communicating with TTCC component(s). We denote
by a the initial interaction between two or more ATC
components and by p the port of BAT C such that p ∈ a.
Instead
of
the
initial
connector
linking
these
atomic
components, communication is performed through added
TTCC
component. Thus, each atomic component will
be
connected
to
TTCC
component
using
send/receive
connectors.
Rule 2: In each ATC component BAT C ∈ BAT C, for each
port p ∈ P ∩AE, each transition labelled by the port p will be
duplicated in two transitions with an intermediate partial state
⊥p. A new added send-port ps and the port p (Receive port) are
the successive labels of the two new transitions. The transition
labelled by ps is an unobservable transition. Formally, BT T is
obtained from B as follows:
• LT T
=
L ∪ L⊥, where L⊥
=
{⊥l,p
|∃τ
=
(l, p, gτ, fτ, r, l′) ∈ T, a ∈ AE, p ∈ P ∩ a} ,
• P T T = P ∪ Ps, where Ps = {ps|p ∈ P ∩ AE},
• XT T = X ∪{gp}p∈P ∩AE ∪{nb, ρc, texa}, where nb is the
number of participation of BT T ,
• CT T = C, Cg ,
• T T T = T\{τp}p∈P ∩AE ∪ {τps, τ ′
p}p∈P ∩AE where p ∈
P ∩ AE, τp ∈ T and τps, τ ′
p ∈ T T T such that τp =
(l, p, gτp, fτp, l′), τps = (l, ps, True, gp = gτp, L⊥) and
τ ′
p = (L⊥, p, True, fτ ′p, l′). fτ ′p executes fτp and incre-
ments nb.
• For places L⊥, the time progress condition is tpcT T
L⊥ =
True.
We denote the set of transformed ATC components by
BAT C
T T .
Figure 8 illustrates this transformation for the cases of con-
ﬂicting and non conﬂicting interactions.
xp
L1
L2
p
gp
p xp
xp, gp, n, tex
L1
⊥p
L2
ps
p
ps
xp, gp, n
p
xp, tex
(a) Non conﬂicting interaction
xp, xq
L1
L2
L3
p
q
gq
gp
p xp
q xq
xp, gp, xq, gq, n, tex
L1
⊥p
⊥q
L2
L3
ps
qs
p
q
ps
xp, gp, n
p
xp, tex
qs
xq, gq, n
q
xq, tex
(b) Conﬂicting interaction
Figure 8. Atomic Component transformation
2) Connector transformation: Each connector presenting
an inter-task communication will be replaced by a TTCC
component as described by the following rule:
Rule 3: Let Ck be a connector deﬁning an external com-
munication between k components of different tasks which
handles an external interaction (a, Xa, Ga, Fa) ∈ AE. We
replace Ck by a TTCCk component and a set of corresponding
connectors, as follows::
• if a is a conﬂicting interaction (i.e., ∃a′ ∈ AE such that
a#a′), TTCCk is an instance of TTCCC components,
else TTCCk is an instance of TTCCNC component.
• In both cases, the set of local variables of TTCCk is
Xl = Xa ∪ {nb, tex}, and in the transition executing the
interaction a, we have the guard G = Ga
V(
kV
i=1
)gi
p and the
function F = Fa.
• k binary and one k+1−ary send/receive connectors are
instantiated to connect TTCC to ATC components,
• A CRP component is then instantiated and connected to
TTCCC components via three binary send/receive con-
nectors each.
164
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

3) Task component instantiation: Task components are
created according to the task mapping. Each transformed ATC
component exports its send and receive ports to the task
component interface. Each exported port will be referenced by
an artefact external interaction aartefact that presents locally
the external interaction involving the task. Conﬂicts between
internal and artefact interactions that are not initially resolved
by priority rules, are resolved by a static added rule that favours
the internal interaction.
Rule 4: For each task Tk = {Bi}i∈Ik ∈ T , we instantiate
a composite component T T T
k
where:
• The set of exported ports of T T T
k
is P T T
T
= (Ps ∩
S
BT T
i
∈T T T
k
∩BAT CT TPBT T
i
)∪(Pr∩
S
BT T
i
∈T T T
k
∩BAT CT TPBT T
i
),
• for each interaction a ∈ AI in conﬂict with an interaction
b ∈ AE, we add the priority rule π = (True, b, a).
In this section, we proposed TT-BIP architecture as a TT
physical model that allows inter-task interactions only through
a communication media (TTCC components) in order to com-
ply with the TT paradigm. We also deﬁned a transformation
process that derives correctly a TT-BIP model from a high-
level RT-BIP model. The obtained TT-BIP model is intended to
be translated into the language speciﬁc to target TT platform.
Since each operating system (OS) offers speciﬁc services
(communication, scheduling policy, etc.), it is advantageous
to deﬁne a mapping between these offered services and their
corresponding elements in the TT-BIP model. To be able to
do such a mapping, we consider the decomposition of the
TTCC component into an equivalent set of atomic components
each describing a step of its behaviour: components allowing
individual acquisition of offers, components to aggregate them,
and component executing the interaction. We believe that some
parts of TTCC subcomponents can be mapped into OS com-
munication services. Priorities in the TT-BIP model (including
added ones in task component) are priorities on interactions.
In simulation level they can be resolved by RT-BIP sequential
scheduler. In order to be handled in implementation, these
priority rules should be translated either into predicates on
transitions following [9], or, into priorities on tasks, which
could parametrize the scheduler of the target platform. This
adequation between subset of TTCC (resp. priority rules) and
OS communication services (resp. schedulers) will be the
object of a future publication.
IV.
CASE STUDY
In this section, we present a simple but representative case
study which consists in a Flight Simulator (FS) application.
We have ﬁrst modelled the FS application in RT-BIP starting
from FS Modelica model. Then, we applied manually the
transformation to derive the equivalent TT-BIP model. The
simulation of three models reveals that their outputs are similar.
The initial RT-BIP model, consists of a set of six com-
municating components (see. Figure 9): autopilot, ﬂy-by-wire,
route, servo, simulator and sensor. The autopilot models the
pilot commands in function of the ﬂight state. It has four main
functionalities: ﬂight state reception from sensor component,
execution of the route planner, execution of ﬂy-by-wire and
sending command to servo component. The route component
computes distance to current waypoint and change route to-
wards next waypoint if necessary. It operates in low frequency:
every 15 seconds. The ﬂy-by-wire component allows course
correction by setting roll attitude and ailerons and elevator. It
operates in high frequency: every 5 seconds. The servo refers
to the autopilot’s actuation on plane’s ﬂight control surfaces.
Servo component receives command from autopilot component
and transfers it to simulator component. The Flight simulator
simulates ﬂight dynamics computation of plane and wing tips
position based on received commands (i.e., new values of
roll, pitch and throttle). The sensor refers to the autopilot’s
perception of real world data. Sensor component receives data
about ﬂight state from simulator component and resend them
to the autopilot. The sensor can add some noise, delay, etc.,
to mimic realistic data acquisitions. But in our example, we
stand for copying the state computed by simulator component.
ﬂy
ﬂy
cfly = 5
ffly
resert(cfly)
ﬂy
route
route
croute = 15
froute
resert(croute)
route
Loop
start
o-c
i-s
ﬂy
route
i-s
o-c
r
start
s
o-c
i-c
i-c
o-c
c
start
s
r
state
computation
o-s
i-c
i-c
o-s
r
start
s
o-s
i-s
i-s
o-s
Figure 9. Initial Flightsim model
We apply the transformation and derive the TT-BIP model.
The chosen task mapping is as follows; the ﬁrst task com-
promises autopilot, route and ﬂy-by-wire components. Servo,
sim and sensor are each mapped on a different task. Thus,
only connectors route and ﬂy remain intact. Other connectors
are inter-task connectors. They are transformed in TTCC com-
ponents. The interactions connecting the autopilot component
to the sensor and servo components are conﬂicting in the
state ”loop” of the autopilot. Thus, instantiated TTCC for
these interactions are related to CRP component. Figure 10,
shows the obtained model. Behaviours of TTCC and CRP
components are not displayed for lack of space. Nonetheless,
since all TTCC components are connecting exactly two tasks,
their automata are strictly similar to those in Figure 5.
ﬂy
ﬂy
cfly = 5
ffly
resert(cfly)
ﬂy
route route
croute = 15
froute
resert(croute)
route
Autopilot
Task1
Loop
start
⊥is
⊥oc
psoc
psis
i-s
o-c
ﬂy
cfly = 5
route
croute = 15
i-s
o-c
psoc
psis
Servo
Task2
r
start
⊥oc
s
⊥ic
psoc
o-cmd
psic
i-cmd
i-c psic
o-c
psoc
Sim
Task3
c
start
s
⊥c
r
⊥s
Internal
state
computation
pss
o-state
psc
i-cmd
i-c
o-s
pss
psc
Sensor
Task4
r
start
⊥os
s
⊥is
psos
o-state
psis
i-state
i-s
o-s
psos
psis
TTCCC
TTCCC
TTCCNC
TTCCNC
CRP
rsv ok fail
rsv ok fail
Figure 10. Final Flightsim model
In order to be able to compare the functionality of two
models, we used BIP simulator that generates C++ code from
the initial and the obtained model. Simulation of two generated
codes, allowed us to visualize and compare the output signals.
A band shows the trajectories of left and right wingtips and
illustrates the roll movement that precedes the change in course
at each waypoint, while the plane progressively reaches its
desired altitude.
165
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

trajectoire
trajectoire au sol
-100
-50
0
50
100
150
200
250
300
350
-100
-50
0
50
100
150
200
250
300
350
400
-50
0
50
100
150
200
250
300
350
Figure 11. Trajectories of left and right wingtips
Figure 11 presents the simulation results of the ini-
tial and the derived models, for the waypoints (300,0,300),
(300,300,300), (0,300,300) and (0,0,300). Visual inspection
reveals that the output of the transformed model is strictly
similar to that of the original model.
V.
RELATED WORK
There have been a number of approaches exposing the
relevant features of the underlying architectures at high level
design tool.
Authors in [16] present a design framework based on
UML diagrams for applications running on Time-Triggered
Architecture (TTA). This approach doesn’t support earlier
architectural design phase and needs a backward mechanism
for the generated code veriﬁcation. It also doesn’t target
generic TT implementations since it assumes the underlying
TT protocol to be The Flexray standard.
Authors of [17] and [18] present a method to reduce the
gap between models used for timing analysis and for code gen-
eration. This method relies on AADL model transformations
in order to lower automatically the abstraction level of models.
However, this work did not rely on formal semantics.
Since BIP design ﬂow is unique due to its single semantic
framework used to support application modelling and to gener-
ate correct-by-construction code, many approaches tend to use
it to translate high level models into physical models including
architectural features. For instance, in [15], a distributed BIP
model is generated from a high level one. In [19], a method
is presented for generating a mixed hardware/software system
model for many-core platforms from an application software
and a mapping. These two approaches take advantages from
BIP framework but they do not address the TT paradigm.
To the best of our knowledge, our approach is the ﬁrst to
address the problem of deriving progressively a TT physical
model in a single host component-based language rooted in
well deﬁned semantics.
VI.
CONCLUSION
In this paper, we proposed a chain of transformations that
starts from an arbitrary abstract RT-BIP model, and a user-
deﬁned task mapping. The transformation process obtains a
model that suits the TT-BIP architecture and consists of: (1)
breaking atomicity of actions in ATC components by replac-
ing strong synchronizations with asynchronous send/receive
interactions, (2) inserting TTCC components that coordinate
execution of inter-task interactions according to a user-deﬁned
task mapping, (3) extending the model with an algorithm for
handling conﬂicts between TTCC and (4) adding local priority
rules in task components for handling conﬂicts between inter-
task and intra-task interactions. We have shown correctness of
the ﬁnal model by trace inclusion.
For future work, we plan to automate the transformation
process in RT-BIP modelling environment. Furthermore, we
are working on the tool allowing code generation for the
target TT platform, that depends on the offered communication
services of target operating system. For each speciﬁc target
operating system, it translates an adapted version of the model.
REFERENCES
[1]
H. Kopetz, “The time-triggered approach to real-time system design,”
Predictably Dependable Computing Systems. Springer, 1995.
[2]
——, “Time-triggered real-time computing,” Annual Reviews in Con-
trol, vol. 27, no. 1, 2003, pp. 3–13.
[3]
W. Elmenreich, G. Bauer, and H. Kopetz, “The time-triggered
paradigm,” in Proceedings of the Workshop on Time-Triggered and
Real-Time Communication, Manno, Switzerland, 2003.
[4]
BIP2 Documentation, July 2012.
[5]
T. Abdellatif, “Rigourous implementation of real-time systems,” Ph.D.
dissertation, UJF, 2012.
[6]
T. Abdellatif, J. Combaz, and J. Sifakis, “Model-based implementation
of real-time applications,” May 2010, pp. 229–238.
[7]
R. Alur and D. L. Dill, “A theory of timed automata,” Theoretical
computer science, vol. 126, no. 2, 1994, pp. 183–235.
[8]
B. Bonakdarpour, M. Bozga, M. Jaber, J. Quilbeuf, and J. Sifakis, “From
high-level component-based models to distributed implementations,” in
Proceedings of the tenth ACM international conference on Embedded
software.
ACM, 2010, pp. 209–218.
[9]
J. Quilbeuf, “Distributed implementations of component-based systems
with prioritized multiparty interactions. application to the bip frame-
work.” Ph.D. dissertation, Universit´e de Grenoble, 2013.
[10]
A. Triki, B. Bonakdarpour, J. Combaz, and S. Bensalem, “Auto-
mated conﬂict-free concurrent implementation of timed component-
based models,” in NASA Formal Methods.
Springer, 2015, pp. 359–
374.
[11]
R. Alur and D. L. Dill, “A theory of timed automata,” Theoretical
computer science, vol. 126, no. 2, 1994, pp. 183–235.
[12]
A. Basu, P. Bidinger, M. Bozga, and J. Sifakis, “Distributed semantics
and implementation for systems with interaction and priority,” in Formal
Techniques for Networked and Distributed Systems–FORTE 2008.
Springer, 2008, pp. 116–133.
[13]
R. Bagrodia, “Process synchronization: Design and performance evalu-
ation of distributed algorithms,” Software Engineering, IEEE Transac-
tions on, vol. 15, no. 9, 1989, pp. 1053–1065.
[14]
K. M. Chandy and J. Misra, “The drinking philosophers problem,” ACM
Transactions on Programming Languages and Systems (TOPLAS),
vol. 6, no. 4, 1984, pp. 632–646.
[15]
M. Bozga, M. Jaber, and J. Sifakis, “Source-to-source architecture trans-
formation for performance optimization in bip,” Industrial Informatics,
IEEE Transactions on, vol. 6, no. 4, 2010, pp. 708–718.
[16]
K. D. Nguyen, P. Thiagarajan, and W.-F. Wong, “A uml-based design
framework for time-triggered applications,” in Real-Time Systems Sym-
posium, 2007. RTSS 2007. 28th IEEE International.
IEEE, 2007, pp.
39–48.
[17]
E. Borde, S. Rahmoun, F. Cadoret, L. Pautet, F. Singhoff, and P. Dis-
saux, “Architecture models reﬁnement for ﬁne grain timing analysis of
embedded systems,” in Rapid System Prototyping (RSP), 2014 25th
IEEE International Symposium on.
IEEE, 2014, pp. 44–50.
[18]
F. Cadoret, E. Borde, S. Gardoll, and L. Pautet, “Design patterns for
rule-based reﬁnement of safety critical embedded systems models,”
in Engineering of Complex Computer Systems (ICECCS), 2012 17th
International Conference on.
IEEE, 2012, pp. 67–76.
[19]
P. Bourgos, “Rigorous design ﬂow for programming manycore plat-
forms,” Ph.D. dissertation, Grenoble, 2013.
[20]
R. Milner, Communication and Concurrency.
Hertfordshire, UK, UK:
Prentice Hall International (UK) Ltd., 1995.
166
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

APPENDIX
TRANSFORMATION CORRECTNESS PROOFS
In this section we prove the correctness of our TT-BIP
model. First, we show that the obtained model is indeed a TT-
BIP model. Second, in order to prove the correctness of our
transformation, we consider these two steps in transforming
a model B; the ﬁrst step that transforms ATC components
and inter-task connectors, and the second step that instantiates
composite task components with priorities. We denote by
BT T
SR the output model of the ﬁrst step and by BT T the
ﬁnal model after applying the second step. We show that B
weakly simulates BT T
SR. And ﬁnally, we prove trace inclusion
between BT T
SR and BT T , i.e., the second step of transformation
preserves safety property.
A. Compliance with TT-BIP model
We need to show that receive ports of BT T model will
unconditionally become enabled whenever one of the corre-
sponding send ports is enabled. Intuitively, this holds since
communications between tasks and TTCC components, and
between TTCC components and CRP component follow a re-
quest/acknowledgement pattern. Whenever a component sends
a request (via a send port) it enables the receive port to receive
acknowledgement.
In ATC components, we denote by l⊥ in LT T each place
allowing sending offer to TTCC component. Note that l⊥
precedes one ⊥p place when only one intertask interaction
is possible (e.g., the place L1 in the right part of Figure 8a).
It consists in all states allowing to send successive offers to
TTCC components in case of conﬂicting intertask interactions
(e.g., the places L1 and ⊥p in the right part of Figure 8b). l⊥
places are called busy locations. We denote by ⊥∗
p each ⊥p
place from which no offer could be sent (e.g., the place Lp in
the right part of Figure 8a and the place Lq in the right part
of Figure 8b). We denote by l places that are neither l⊥ nor
⊥∗
p places. In AC components, all places are denoted by l.
Lemma 1: Given an RT-BIP model B = πγ(B1, ..., Bn)
and a task mapping T = {T1, ..., Tk}, the model BT T =
πT T γT T (BT T
1
, ..., BT T
n , TTCC1, ..., TTCCm, CRP)
obtained
by
transformation
of
section
III-C
meets
the
properties of deﬁnition 8.
Proof:
The ﬁrst four constraints of Deﬁnition 8 are trivially met
by construction. We now prove that the ﬁfth constraint also
holds, i.e., whenever a send port is enabled, all its associated
receive ports are enabled as well.
• Between a task component BT T
i
and a TTCCNC
j
com-
ponent, for all interactions involving a component Bi, we
distinguish between four classes of states:
◦ The ﬁrst class contains all states between wait and Read
states of TTCCj where this latter is enabling all its
receive ports in all possible orders and BT T
i
is in a
busy location l⊥. This class presents waiting states.
From that class, the only enabled send-port involved
in an interaction with BT T
i
is the port psi of Bi. By
deﬁnition of the class, all associated receive ports are
also enabled, and the send/receive interaction can take
place to reach a state of the second class.
◦ In the second class, the component BT T
i
is in a place
⊥∗
p that is not a busy location, and the TTCC com-
ponent is in the Read place. From that conﬁguration,
there is no enabled send-port involved in an interaction
with BT T
i
. The next class of states is reached when the
TTCC executes a unary interaction a.
◦ In the third class, the TTCC component is in the place
write and BT T
i
component is still in ⊥∗
p place. The
send-port ps of TTCC is enabled. By deﬁnition of
the class, the corresponding receive-port is enabled
since component BT T
i
is in location ⊥∗
p. Thus the
send/receive interaction can take place either to reach
back the ﬁrst class of states or to reach the following
class.
◦ In the remaining class, the component BT T
i
is in place
l and TTCC component is in Wait place. From this
state only inta-task interactions could be enabled and no
communication with TTCC component can be planned
(no send-port is active).
• Between a task component BT T
i
and a TTCCC
j compo-
nent, for all interactions involving the interaction a which
is externally conﬂicting, we have almost the same four
classes as non conﬂicting TTCC. TTCCC
j refers to CRP
before executing a. It uses the current participation num-
ber of Bi for the execution of a and no other interaction is
granted using the same participation number. Thus, write
is the only active place, from which a notiﬁcation could
be sent to a component Bi.
• Between the TTCC component TTCCC
j and the conﬂict
resolution protocol CRP, we consider the places trya
in the component TTCCC
j , waita and treata in CRP
component. If TTCCC
j in not in trya place, and CRP in
in the waita place, only reservation request through port
rsva is enabled. When the rsva request is sent, the place
trya and treata become active. From this conﬁguration,
only send ports oka and faila are enabled in the CRP,
and the associated ports are also enabled in the TTCC
(from trya location).
This proof ensures that any component ready to perform
a transition labelled by a send-port will not be blocked by
waiting for the corresponding receive-ports.
B. Observational Equivalence between B and BT T
SR
We denote by B the initial model and by BT T
SR the resulting
model of the step 1 of the transformation.
We show that B and BT T
SR are observationally equivalent.
The deﬁnition of observational equivalence between two tran-
sition systems A = (QA, PA ∪ {β}, −→
A ) and B = (QB, PB ∪
{β}, −→
B ) is based on the usual deﬁnition of weak bisimilarity
[20], where β-transitions are considered unobservable.
Deﬁnition 9: (Weak Simulation A weak simulation over
A and B, denoted A ⊂ B, is a relation R ⊂ QA × QB, such
that: ∀(q, r) ∈ R, a ∈ P: qA
a→A q′ =⇒ ∃r′: (q′, r′) ∈ R ∧
r
β∗aβ∗
→
B r′ and ∀(q, r) ∈ R: q
β→A q′ =⇒ ∃r′: (q′, r′) ∈ R
∧ r
β∗
→B r′.
A weak bisimulation over A and B is a relation R such
that R and R−1 are both weak simulations. we say that A
and B are observationally equivalent and we write A ∼ B if
for each state of A there is a weakly bisimilar state of B and
conversely.
We consider the correspondence between actions of B and
BT T
SR as follows. To each interaction a ∈ γ of B, we associate
167
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

either the multi-party interaction aMP , the binary interaction
oka or the unary interaction a of BT T
SR, depending on whether a
is inta-task interaction, external conﬂicting or external and not
conﬂicting interaction. Other interactions of BT T
SR (send/receive
interactions) are unobservable and denoted by β.
We proceed as follow to complete the proof of observa-
tional equivalence. Among unobservable actions β, we distin-
guish between β1 actions, that are interactions between ATC
components and TTCC components, and β2 actions that are
interactions between TTCC components and CRP component
(namely the reserve and fail). We denote by qT T
SR a state of
BT T
SR and q a state of B. A state of BT T
SR from where no β1
action is possible is called a stable state, in the sense that any
β action from this state does not change the state of atomic
components.
Lemma 2: From any state qT T
SR, there exists a unique stable
state [qT T
SR] such that qT T
SR
β∗
1
→γT T [qSR
T T ]
Proof: The state [qT T
SR] exists since in AC component
no β transitions are possible and since each ATC component
BT T
SR i can either send one or successive offers, or receive a
notiﬁcation. Since two β1 transitions involving two different
components are independent (i.e., modify distinct variables and
places), the same ﬁnal state is reached independently of the
order of execution of β1 actions. Thus [qT T
SR] is unique.
The above lemma proves the existence of a well-deﬁned
stable state for any of the transient states reachable by the BT T
SR
model. The state [qT T
SR] veriﬁes the property qT T
SR
β∗
1
→γT T [qSR
T T ]
and [qT T
SR]
β∗
1
̸→γT T .
Lemma 3: At a stable state [qT T
SR], the BT T
SR model veriﬁes
the following properties:
• All ATC components are in non busy places ⊥∗
p or l.
• All other atomic components are in a non busy place l.
• All TTCC components are in receive places read,
• The clock Cg and all variables in ATC components have
the same value than their copies in the TTCC component.
Proof: The three ﬁrst points come from Lemma 1 that
guarantees possible execution of a send/receive interaction
if its send-port is enabled. Therefore no place write in the
TTCC components (respectively l⊥ in atomic components)
can be active at [qT T
SR], otherwise the answer ps of TTCC
(respectively the offer from l⊥ ) could occur. Furthermore,
since all offers have been sent, none of the TTCC components
can be in wait place. In each TTCCj, when read place
is active, the last executed transitions are either offers or a
fail message reception. The latter does not modify variables
in the TTCCj. For each variable x in the TTCCj, the last
modifying transitions are offers from the corresponding atomic
components Bi, which ensures that each variable in the TTCC
component has the same value as the corresponding ATC
component. The clock Cg has the same value in the atomic
components and the TTCC as it is never reset.
Lemma 4: When ATC component BT T
SR i is in a stable
state, we have ni > Ni
Proof: Where in a stable state, the ATC component is
either in place ⊥∗
p or l following Lemma 3. When ATC
component is in place ⊥∗
p all offers have been sent, thus
the participation numbers in TTCC corresponds to those in
components. Initially, for each ATC component Bi, Ni = 0
and ni = 1. By letting all components sending offers to
all TTCC components, we reach the ﬁrst stable state where
the property holds, since β1 actions do not modify the Ni
variables. The variables Ni in the CRP component are updated
upon execution of an oka transition, using values provided
by the TTCC, that are values from components according to
Lemma 3. Thus, in the unstable state reached immediately after
an oka transition, we have ni = Ni for each component BT T
SR i
participant in a. Then, the notiﬁcation transition increments
participation numbers in components so that in the next stable
state ni > Ni. For components B′
i not participating in a, by
induction on the number of okinteractions, we have n′
i > N ′
i.
Now when ATC component is in place l, only multiparty
interaction is possible with AC components. This interaction
involves only AC components, and thus has no effect on Ni,
it only increments ni. If a previous inter-task interaction has
been performed so at state l, we have ni > Ni. If no intertask
interaction has been performed before reaching place l, the
property holds since initially ni = 1 and Ni = 0, and since
each action from a state l increments ni.
Lemma 4 shows that the participation numbers propagate
in a correct manner. In particular, at any stable state the conﬂict
resolution protocol has only previously used values and TTCC
components have the freshest values, that are the same as in
ATC components. To prove the correctness of the step 1 of
our transformation, we exhibit a relation between the states Q
of the original model B = {B1, .., Bn} and the states QT T
SR of
ﬁnal model BT T
SR = {BT T
SR 1, .., BT T
SR n} and prove that it is an
observational equivalence.
We deﬁne the relation by assigning to each state qT T
SR ∈
QT T
SR an equivalent state equ(qT T
SR) ∈ Q by:
1) considering the unique stable state [qT T
SR] reachable by
doing β transitions.
2) considering the control location l⊥ and ⊥∗
p in BT T
SR i as
the control location l for Bi, in equ(qT T
SR). The control
location l in BT T
SR i are considered as the control location
l for Bi, in equ(qT T
SR). Lemma 3 ensures that it is a valid
control state for Bi.
3) taking the valuation of variables of BT T
SR i to a valuation
of variables in Bi, and
4) taking the valuation of original clock ci in Bi as the
valuation of gρci .
Theorem 1: BT T
SR ∼ BT T
Proof: We then deﬁne the equivalence R by taking:
R = {(qT T
SR, q) ∈ QT T
SR × Q|q = equ(qT T
SR)}
(7)
The three next assertions prove that R is a weak bisimula-
tion:
1) If (qT T
SR, q) ∈ R and qT T
SR
β→ rT T
SR then (rT T
SR, q) ∈ R.
2) If (qT T
SR, q) ∈ R and qT T
SR
σ→ rT T
SR then ∃r ∈ Q : qT T
SR
σ→ r
and (rT T
SR, r) ∈ R.
3) If (qT T
SR, q) ∈ R and q
σ→γ r, then ∃rT T
SR ∈ QT T
SR :
qT T
SR
β∗σ
→ γT T
SR rT T
SR and (rT T
SR, r) ∈ R.
The property 1) is a direct consequence of Lemma 2. If
qT T
SR
β
→γT T
SR rT T
SR, then β is either β1 action, thus by deﬁnition
[qT T
SR] = [rT T
SR], or β is β2 action which does not change the
state of the atomic components, thus [qT T
SR] = [rT T
SR]. Thus, we
168
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

have equ(qT T
SR) = equ(rT T
SR).
To prove property 2), we assume the action σ in BT T is
either an intra-task interaction (multi-party interaction) a, or
an inter-task interaction (corresponding to a unary or binary
interaction) or a delay step δ.
If a is an intra-task interaction, it is not concerned by the
transformation. That is q = equ(qT T
SR) and r = equ(rT T
SR).
If a is an inter-task interaction, it corresponds to executing
a transition labelled by a unary port a in TTCC component
handling a or a transition labelled by oka. These transitions
are enabled according to valuations of variables and clock Cg
in the TTCC handling a. If a is not externally conﬂicting,
by construction of the TTCC, the transition labelled by a has
the conjunction of guards gp sent by the ATCs of different
tasks for each p ∈ a. Thus the guard of this transition
is G = Ga
V( V
p∈a
gp), where gp
= gX
p
V tcp being the
conjunction of the boolean guard over variables, and timing
constraints. By lemma 3 these values are the same in atomic
talking components (ATC), and by extension in q = equ(qT T
SR).
Thus the guard of a evaluates to Trueat q = equ(qT T
SR). By con-
struction of ATC components, the guard gp = gX
p
V tcp sent
from l⊥ in BT T
SR i are boolean guards and timing constraints at
state l in Bi.
These timing constraints are expressed on clock Cg which
could be equivalently expressed on original clocks c involved
in the original timing constraints of Bi. The valuation of each
clock c involved in the timing constraint of a is computed from
the valuation of g − ρc where ρc is the last clock reset date
of c. Therefore, at state q the timing constraint of a expressed
on its original clocks are also met.
if a is externally conﬂicting, the transition labelled oka in
CRP is possible only if the transition rsva executes in the
TTCC component. This transition has the same guard and
timing constraint of transition labelled by a. Thus, if this
transition is possible in the TTCC component, then the guard
of a is met at q. Moreover, if transition labelled oka is
enabled, this means that for each component Bi involved in a,
ni > Ni. In particular, for each involved component Bi, the
offer corresponding to the number ni has not been consumed
yet. Thus, we conclude that in both cases, we have q
a→ r.
Finally, executing a in BT T
SR triggers the execution of the data
transfer function Fa, followed by the computation in ATC upon
reception of the response. Thus at [rT T
SR], the values in ATC
components are the same as in r, which yields (rT T
SR, r) ∈ R.
if a is a delay step, it corresponds by letting time progress
by δ in either busy locations l⊥ or in places between wait
and read of the TTCC components, corresponding to ATC
components Bi. Location l⊥i has the time progress condition
tpcli and states between wait and Read in TTCC has each the
time progress condition tpci sent from the ATC components
and corresponding to time progress condition of location li.
Thus, all these time progress conditions are not false, otherwise
the δ delay step would not be allowed.
By Lemma 3, the values involved in time progress condition
and sent from l⊥ in BT T
SR i are the values of time progress
condition at state li in Bi. These time progress conditions are
expressed on clock Cg which could be equivalently expressed
on original clocks c involved in the original time progress
conditions Bi. The valuation of each clock c involved in the
time progress condition of Bi is computed from the valuation
of g − ρc where ρc is the last clock reset date of c. If the time
progress condition tpci expressed on clock Cg allows the time
step δ in TTCC component, thus, δ is also allowed by the time
progress condition tpcli expressed on original clocks of Bi.
Therefore q
δ→ r. Executing δ has the same effect on clocks
in both models, therefore (rT T
SR, r) ∈ R.
To prove the property 3), we notice that if σ can be
executed in B at state q, then from an equivalent state qT T
SR,
one can reach the state [qT T
SR] ( by doing β1 actions) where the
clock Cg and data of ATC components have the same values
as those of q (Lemma 3). As previously, we distinguish the
cases where σ is an interaction a or a delay step δ.
If σ is an intra-task interaction a, then it is not concerned by the
transformation and remains intact in the obtained model. Thus
we have straightforwardly (qT T
SR, q) ∈ R and (rT T
SR, r) ∈ R.
If σ is an inter-task interaction a from q, then the timing
constraint and guard of a are True. From qT T
SR we reach
[qT T
SR] by doing β1 actions. Then, we execute all possible
fail interactions (that are β2 actions), to reach [q′T T
SR]. At
this state, if a is not conﬂicting, the interaction a is enabled,
else the sequence rsva oka can be executed since lemma 4
ensures that guard of oka is True. In both cases, the interaction
corresponding to a brings the system in state rT T
SR. From this
state, the response corresponding to ports of a are enabled,
and the next stable state [rT T
SR] is equivalent to r. Thus we
have qT T
SR
β∗
1
−→ [qT T
SR]
β∗
1
−→
fail [q′T T
SR]
a
−→ rT T
SR
β∗
1
−→ [rT T
SR] and
qT T
SR
β∗
1
−→ [qT T
SR]
β∗
1
−→
fail [q′T T
SR]
rsva,oka
−→
rT T
SR
β∗
1
−→ [rT T
SR]. Thus
(rT T
SR, r) ∈ R.
If σ is a delay step δ then from state [qT T
SR], time can progress
also by δ to reach state r′T T
SR. At this state, place read of
TTCC is active and having the tpci sent by [BT T
SR i] which is the
same as the time progress condition of Bi at q. From reached
state r′T T
SR we execute all possible fail interactions (that are
β2 actions), to reach rT T
SR.The time progress conditions are
equal to Falsein receive place in the CRP component. That is,
even if some β2 actions is possible from state r′T T
SR, no delay
is allowed at this state. Thus we have, qT T
SR
β∗
1
−→ [qT T
SR]
δ
−→
r′T T
SR
β2
−→ rT T
SR with (rT T
SR, r) ∈ R.
C. Trace inclusion between BT T
SR and BT T
We denote by BT T
SR the initial model and by BT T the
resulting model of the step 2 of the transformation.
The observational equivalence cannot be proven between
BT T
SR and the resulting BT T . In BT T model, conﬂicts between
internal and external interactions are resolved by adding local
priority rules in the task. Thus when interactions aI and aE
(respectively internal and external interactions) are possible,
always the internal one will be executed. This restriction
implies that the set of traces of the BT T model is a subset
of traces of BT T
SR model.
169
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

