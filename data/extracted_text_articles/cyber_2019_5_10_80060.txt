Reﬁnement Checker for Embedded Object Code Veriﬁcation
Mohana Asha Latha Dubasi∗, Sudarshan K. Srinivasan†, Sana Shuja‡, Zeyad A. Al-Odat†
∗Conﬁgurable IP and Chassis Group, Intel Corporation, Hillsboro, OR, USA
†Electrical and Computer Engineering, North Dakota State University, Fargo, ND, USA
‡Department of Electrical Engineering, COMSATS University, Islamabad, Pakistan
Emails: ∗dubasi.asha@gmail.com, †sudarshan.srinivasan@ndsu.edu, ‡sanashuja@comsats.edu.pk, †zeyad.alodat@ndsu.edu
Abstract—We present a formal veriﬁcation methodology that
automates the process to check for correctness of low-level real-
time interrupt-driven object code programs. Automation helps
in the veriﬁcation of large-scale programs. Our methodology is
based on the theory of Well-Founded Simulation (WFS) reﬁne-
ment, where both the formal speciﬁcation and implementation
are modeled as transition systems (TSs). WFS reﬁnement is used
as the notion of correctness and deﬁnes what it means for an
implementation TS to satisfy its speciﬁcation TS. WFS reﬁnement
has key features like stuttering and reﬁnement maps. Stuttering
aids in the abstraction of the state space of the implementation
TS. Reﬁnement map bridges the abstraction gap between the
two systems. The efﬁciency and scalability of the approach is
demonstrated on several device object code case studies.
Keywords–embedded devices; formal veriﬁcation; reﬁnement-
based veriﬁcation; veriﬁcation of object code, WFS reﬁnement.
I.
INTRODUCTION
Correctness of software used in safety-critical systems
continues to be a critical challenge. For example, between
the years 2005-2019, the U.S. Food and Drug Administration
(FDA) [1] issued 52 medical device Class-1 recalls due to
software issues. Class-1 recalls are applied when the use
of the device is determined to cause serious adverse health
consequences or death. It is now well-established that formal
veriﬁcation methods are a requirement to ensure software
safety.
Our domain of interest is the veriﬁcation of embedded
software, which is largely what is used in control of med-
ical devices, surgical robots, avionics equipment, etc. While
many formal veriﬁcation methods exist for reasoning about
higher-level [2]–[4] software models and source code, there
is currently a gap in the applicability of formal veriﬁcation
techniques that can efﬁciently scale and handle the low-
level complexity of object code, which is the low-level code
that is directly executed by the micro-controller embedded
in the device used to perform control and other functions.
It is deﬁnitely insufﬁcient to apply formal veriﬁcation only
to source code as there are many sources of errors in the
process of generating object code from source code that can
compromise the safety of object code. The problem domain
addressed in this work is the veriﬁcation of embedded object
code programs.
Typically, the objective of a formal veriﬁcation methodol-
ogy is to verify an implementation (the artifact to be veriﬁed,
here, object code) against a speciﬁcation (the artifact that
captures the requirements to be satisﬁed by the implemen-
tation). Previously, we have developed a formal veriﬁcation
methodology for object code veriﬁcation. The methodology
is based on the theory of Well Founded Simulation (WFS)
reﬁnement [5]. In the context of WFS reﬁnement, both the
implementation and speciﬁcation are modeled as Transition
Systems (TSs: a mathematical modeling framework for code
that is based on states of the program and transitions between
states). WFS reﬁnement essentially deﬁnes what it means for
an implementation TS to correctly implement a speciﬁcation
TS. It has been explained in [5] how the low-level code is
represented as an implementation TS and how it is the imple-
mentation of the high-level TS that acts as the speciﬁcation.
The methodology was demonstrated by manually gener-
ating the required proof obligations for checking WFS re-
ﬁnement. However, this is insufﬁcient for large programs. In
this paper, we address this gap by proposing an algorithm for
automatic WFS reﬁnement checking optimized for object code
veriﬁcation. This algorithm checks for safety based on WFS
reﬁnement. Safety informally means that if the implementation
makes progress, the result of that progress satisﬁes the spec-
iﬁcation requirements. The algorithm has been implemented
and the automated tool ﬂow has been applied to several object
code control programs to demonstrate the effectiveness of the
approach.
The rest of this paper is organized as follows. Related work
is given in Section II. An overview of WFS reﬁnement and
related concepts is presented in Section III. The algorithm
for safety veriﬁcation is presented in Section IV. Results and
conclusions are given in Sections V and VI, respectively.
II.
RELATED WORK
A large gap exists between high-level system models and
the low-level actual code (i.e., object-code), which is executed
on the embedded device. The number of states and transitions
in the high-level system models is typically less than 100,
whereas, in the low-level models the number of states and
transitions may be in the order of millions. Catching design
bugs early in the design cycle of the system-level models is
very useful. To bridge the gap between system-level models
and actual code, model-driven approaches are adopted. Here,
the high-level system models are represented as source code
which is developed using platform-independent synthesis tools.
The source code is then augmented with the device peripheral
information and then compiled and assembled to generate the
object code. During this process, numerous errors can creep
into the object code compromising its safety. Our work is
targeted at bridging the gap between the real-time high-level
models and real-time object code and also ensuring that the
object-code is safe.
There has been a lot of previous work in developing theory
and optimized techniques for reﬁnement based veriﬁcation. A
notion of reﬁnement based on stuttering trace containment to
verify the concurrent programs have been developed in [6]. A
reﬁnement-based testing method have been developed in [7],
which checks for the functional correctness of hardware and
81
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-743-6
CYBER 2019 : The Fourth International Conference on Cyber-Technologies and Cyber-Systems

low-level software. A characterization of stuttering bisimula-
tion has been proposed in [8], here, stuttering bisimulation
is a notion of correctness that deﬁnes what it means for two
transition systems to be equivalent. Stuttering is accounted for
in this work. An algorithm that checks equivalence between
two transition systems which accounts for stuttering has been
presented in [9]. Derrick et al. [10] have presented reﬁnement
checker for Z, which is a language that is used to express
computer programs. These computer programs are system-
level models. Gibson-Robinson et al. [11] have presented a
reﬁnement checker that check if one system is a reﬁnement
of the other, where both the systems are expressed as tran-
sition systems. This checker is used on software models like
concurrent systems. However, these do not consider real-time
interrupt-driven object code. In this work, we use WFS reﬁne-
ment which has a very nice property. The check is local, i.e., it
is sufﬁcient to reason about a single step of the implementation
and speciﬁcation. Since object code typically contains millions
of transitions, this property can be exploited by reasoning about
one transition at a time. This inturn reduces the veriﬁcation
burden. WFS reﬁnement has two features: reﬁnement-map and
stuttering. Stuttering helps in abstraction techniques on the TS
which reduces the state and path from exploding. Reﬁnement-
map bridges the gap between the system-level model and low-
level object-code.
Etessami [12] and Dax et al. [13] have proposed speciﬁca-
tion languages for expressing stuttering-invariant properties,
which are properties that do not distinguish behaviors of
systems that differ only due to stuttering. The properties are
veriﬁable using a model checker. Our work is complimentary
to their approach, in that our goal is to exploit stuttering
through abstractions to make veriﬁcation more efﬁcient and
scalable.
Shaukat et al. [14] have presented an abstraction technique
that helps to reduce the object code instructions statically. A
number of tools exists [3] [4] [15] to verify real-time high-level
models. UPPAAL-based tools like [16] [17] also exist. Al-
Qtiemat et al. [18] have presented a methodology to generate
the formal speciﬁcation models from natural language require-
ments. The speciﬁcation models, useful for reﬁnement veriﬁ-
cation, are expressed as transition systems. These reﬁnement
approaches for real-time systems are targeted at high-level
models and do not consider the use of reﬁnement-map and
stuttering. Since we incorporate reﬁnement-map and stuttering,
our approach is unique and applicable to the veriﬁcation of
low-level implementation such as object-code.
Jabeen et al. [19] have used the theory of reﬁnement for the
veriﬁcation of FPGA-based stepper motor control using proof
obligations. Manually developing proof obligations for real-
time interrupt driven object code is time consuming because
of the size of the instructions and may introduce human errors.
In contrast, we address the automation of reﬁnement-based
veriﬁcation.
The main goal of our work is veriﬁcation of real-time
object code against it’s real-time high-level model. The real-
time object code does not handle ﬂoating point numbers and C
code. The goal is achieved by employing symbolic simulation
on object code and this is a standard.
III.
BACKGROUND
WFS reﬁnement is a notion of correctness which describes
how an implementation system is correct with respect to its
speciﬁcation system. The speciﬁcation is a mathematical model
that describes the behavior of the system in high-level. Usually,
the systems that are to be veriﬁed are represented as transition
systems (TSs).
Deﬁnition 1. [20] A transition system (TS) M is a 3-tuple
⟨S, R, L⟩, where S is the set of states, L is a labeling function
that deﬁnes what is visible at each state and R is the transition
relation that deﬁnes the state transitions. T is left-total.
The formulation of the correctness properties and the com-
pleteness of the properties with respect to the input language
is shown in [20].
S0
S1
S2
S4
S8
S0 : 0000
S1 : 0001
S2 : 0010
S4 : 0100
S8 : 1000
Figure 1. Stepper motor control speciﬁcation TS
Stepper motor control is used as an example to describe
object code veriﬁcation using WFS reﬁnement. Stepper motors
are used in safety-critical applications which include medical
devices like infusion pump, robotics like surgical robots,
process control, etc. A stepper motor is a brushless DC electric
motor, which contains 4 or 6 leads. Discrete rotation of the
motor shaft is the result of current pulses that are applied to
the motor. A repeating sequence of values such as 0001, 0010,
0100, 1000, 0001, etc, to the leads, cause the motor to spin.
Software, that generates the above sequence, can be executed
on the microcontroller which is interfaced to the motor. Fig-
ure 1 shows the speciﬁcation TS (MS) for 4-lead stepper motor
control. The states are represented as S0, S1, S2, S4, S8. The
transition relation determines the direction of the shaft. The
labeling function gives the values of the leads, which determine
the state.
The implementation model for the stepper motor control
would be the object code. This is obtained by generating a
function for each instruction that describes the effect of the
instruction on the state of the microcontroller. The state of the
microcontroller is not as simple as the speciﬁcation states (as
shown in Figure 1), but consists of registers, ﬂags, and memory
of the microcontroller. The set of all such functions along with
the initial state of the microcontroller deﬁnes the TS model
of the implementation. The implementation model consists of
millions of transitions because of the various possible values
that the registers, ﬂags, memory and special registers of the
microcontroller can have during the execution of the object
82
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-743-6
CYBER 2019 : The Fourth International Conference on Cyber-Technologies and Cyber-Systems

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
Figure 2. Stepper motor control implementation TS
code program. A details description about the implementation
level can be found in [5]. An example of the implementation
of the stepper motor control is shown in Figure 2 for the
speciﬁcation in Figure 1.
A detailed description of the WFS reﬁnement is provided
in [20]. Below is the deﬁnition of WFS
Deﬁnition 2. [20] B ⊆ S ×S is a WFS on TS M = ⟨S, T, L⟩
iff:
(1) ⟨∀s, w ∈ S :: sBw
:: L(s) = L(w)⟩; and
(2) There exists functions, rankl : S × S × S → N,
rankt : S × S → W, such that ⟨W, ⋖⟩ is
well-founded, and ⟨∀s, u, w ∈ S :: sBw ∧ sTu
::
(a) ⟨∃v :: wTv ∧ uBv⟩∨
(b) (uBw∧rankt(u, w) ⋖ rankt(s, w)) ∨
(c) ⟨∃v :: wTv :: sBv ∧ rankl(v, s, u) < rankl(w, s, u)⟩⟩
Here, condition 1 states that for a WFS relation between s
and w, they have to have the same labels. In condition 2, case
(a) denotes the non-stuttering transition on the implementation
side, case (b) denotes the stuttering on the speciﬁcation side
and case (c) denotes stuttering on the implementation side.
Progress on the model is denoted by a non-stuttering transition
where the states have different labels. Whereas in the case of
stuttering transition the states have the same label. rankt and
rankl are rank functions (discussed later).
When the speciﬁcation and implementation systems are
modeled as TSs, a step in the speciﬁcation could correspond
to multiple steps in the implementation. Hence, stuttering
is a phenomenon where multiple but ﬁnite transitions of
implementation can match to the same speciﬁcation transition.
WFS reﬁnement has two key features: reﬁnement-map and
stuttering. Reﬁnement-map, r, is a function that, given an
implementation state, gives the corresponding speciﬁcation
state. A function like reﬁnement-map is needed to bridge the
abstraction gap between the implementation and speciﬁcation
systems.
The advantage of using WFS reﬁnement is that it is
sufﬁcient to reason about single steps of the implementation
and speciﬁcation to check for correctness and ﬁnd bugs. This
makes WFS reﬁnement applicable to deal with the complexity
of object code. To avoid deadlock situations, in stuttering
transitions, a witness function called rank is designed such
that it decreases with each transition. In deﬁnition 2, two
rank functions rankt and rankl corresponds to stuttering on
speciﬁcation and implementation side respectively.
Next is the deﬁnition of WFS reﬁnement.
Deﬁnition 3. [20] (WFS Reﬁnement) Let M = ⟨S, T, L⟩,
M ′ = ⟨S′, T ′, L′⟩, and r : S → S′. We say that M is a WFS
reﬁnement of M ′ with respect to reﬁnement-map r, written
M ⊑r M ′, if there exists a relation, B, such that ⟨∀s ∈ S ::
sBr(s)⟩ and B is a WFS on the TS ⟨S ⊎S′, T ⊎T ′, L⟩, where
L(s) = L′(s) for s an S′ state and L(s) = L′(r(s)) otherwise.
In the above deﬁnition, M and M ′ are the implemen-
tation and the speciﬁcation TS respectively and r is the
reﬁnement-map function. If stuttering on the speciﬁcation side
is not considered, the deﬁnition can be interpreted as every
implementation transition should either be a stuttering or a
non-stuttering transition. If it can be proved that an imple-
mentation TS is a WFS reﬁnement of a speciﬁcation TS,
then every behavior of the implementation is guaranteed to
match a behavior of the speciﬁcation. If the implementation
TS has a label that does not match to its speciﬁcation TS or
a transition that does not match in the speciﬁcation TS, then
these situations correspond to a bug in the implementation
model (here, M ̸⊑r M ′ ). If M is a WFS reﬁnement of M ′
then, a state in M cannot be related to more than one state
in M ′ (as the reﬁnement-map is a function which is used to
relate states of M to M ′).
From Figures 1 and 2, it is clear that the speciﬁcation and
the implementation do not have the same transition behavior.
The reﬁnement-map function for the stepper motor control
program projects the 4-bits in a register in the microcontroller
whose values controls the pins that are in turn connected to the
leads of the stepper motor. The implementation TS (MI) takes
several steps (or transitions) to match a single transition of the
speciﬁcation TS. Here, once a reﬁnement-map is constructed,
in WFS reﬁnement veriﬁcation the idea is to look at each
83
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-743-6
CYBER 2019 : The Fourth International Conference on Cyber-Technologies and Cyber-Systems

transition. For example, consider an implementation transition
⟨w, v⟩ where w, v belong to the set of implementation states.
The transition should capture one of the following options.
One option is that the implementation transition should match
to the same speciﬁcation state, i.e., r(w) = r(v) = s where
r() is the reﬁnement-map and s is a speciﬁcation state. This
option is called a stuttering implementation transition. The
second option is that the implementation transition should
match a speciﬁcation transition, i.e., r(w) = s and r(v) = u
where ⟨s, u⟩ is a transition in speciﬁcation. This option is
called a non-stuttering implementation transition. Using the
reﬁnement-map function on the implementation TS (Figure 2)
gives that states 1 - 2 translate to state S0 of the speciﬁcation
TS (Figure 1), states 3 -12 translate to S1, states 13 - 20 to
S2, states 21 - 23 to S4 and states 24 - 27 to S8. The non-
stuttering transition in implementation TS (MI) (Figure 2)
are shown with dashed arrows. For object code veriﬁcation,
stuttering rarely occurs on the speciﬁcation side as the imple-
mentation typically has millions of transitions when compared
to speciﬁcation. Hence, case (b) of deﬁnition 2 is ignored.
In Figure 2, it can be noticed that many paths in the imple-
mentation lead to a speciﬁc non-stuttering step. All these ﬁnite
paths are termed as stuttering segments. Stuttering segment π
of ⟨w, v⟩ [5] where ⟨w, v⟩ is a non-stuttering transition can
be described as a sequence of transitions in which ⟨w, v⟩ is
preceded by zero to many stuttering transition(s) and another
non-stuttering transition. The least length of a stuttering seg-
ment is one. This occurs when a non-stuttering step is preceded
by another non-stuttering step. The stuttering segment then
only consists of one transition, which is the non-stuttering step.
Also, a non-stuttering step can have many stuttering segments.
For the TS shown in Figure 2, the stuttering segments of
⟨10, 13⟩ are:
1)
{⟨2, 3⟩, ⟨3, 4⟩, ⟨4, 5⟩, ⟨5, 6⟩, ⟨6, 7⟩, ⟨7, 9⟩, ⟨9, 10⟩,
⟨10, 13⟩}
2)
{⟨2, 3⟩, ⟨3, 4⟩, ⟨4, 8⟩, ⟨8, 9⟩, ⟨9, 10⟩, ⟨10, 13⟩}
Object code contains millions of transitions, hence, apply-
ing suitable abstraction techniques on the stuttering segments
helps to deal with state explosion problem. This reduces the
veriﬁcation problem to analysis of stuttering segments.
IV.
AUTOMATED WFS REFINEMENT FOR OBJECT-CODE
This section presents a procedure for automating WFS
reﬁnement for object code veriﬁcation. According to deﬁni-
tion 2, a TS satisﬁes WFS when either one of two conditions
are satisﬁed by all transitions. Usually, in real-time object
code veriﬁcation, stuttering does not occur on the speciﬁcation
system. Hence, the reﬁnement-based correctness formula can
be reduced to,
⟨∀w ∈ object-code :: v = object-code-step(w) ∧ s = r(w)
∧ u = SPEC-step(s) ∧ ⟨s, u⟩ ∈ SPEC then
(i) r(v) = s (for stuttering transition) or
(ii) r(v) = u (for a non-stuttering transition) ⟩
(1)
Here, once a reﬁnement-map is constructed, in WFS re-
ﬁnement veriﬁcation the idea is to look at each transition. Let
⟨w, v⟩ be an implementation transition where w, v belong to
the set of implementation states. To satisfy the reﬁnement-
based correctness formula, the transition should capture one
of the options of being either a stuttering transition or a non-
stuttering transition. If the implementation transition shows a
behavior that is neither stuttering nor non-stuttering then it
indicates the presence of a bug in the implementation TS.
Typically object code (implementation TS (MI)) consists
of millions of transitions where a large portion of these
transitions are of stuttering in nature. Hence, abstraction based
on these stuttering transitions may be applied on the implemen-
tation TS (MI). Applying stuttering abstractions on the TS
makes the veriﬁcation process faster and much more efﬁcient.
1: procedure CHECKWFSREF(RI, RS, SS, r)
2:
RU ← NULL;
3:
for i ← 1 to |RI| do
4:
⟨w, v⟩ ← RI[i];
5:
s ← r(w);
6:
match ← FALSE;
7:
if s ∈ SS then
8:
if r(v) = r(w) then
9:
match ← TRUE;
10:
else
11:
for j ← 1 to |RS| do
12:
⟨s, u⟩ ← RS[j];
13:
if r(v) = u then
14:
match ← TRUE;
15:
break;
16:
if match = FALSE then
17:
RU ← RU ∪ ⟨w, v⟩;
18:
return RU;
Figure 3. Procedure for Checking WFS Reﬁnement
The algorithm in Figure 3 presents a procedure that
performs WFS reﬁnement checking on the abstracted object
code TS, which is the implementation TS. The inputs to the
procedure include a list of transitions of RI (implementation
TS), a list of transitions of RS (speciﬁcation TS), a set of
states of the speciﬁcation (SS) and the reﬁnement-map r.
RU is the counterexample set, which the procedure will
populate with implementation transitions that do not satisfy
the WFS reﬁnement correctness criteria (1). RU is initially
empty. The procedure iterates through each transition in RI.
The transitions of the implementation are of the form ⟨w, v⟩.
Variable ’s’ is assigned to be the value reﬁnement-map (w)
(line 5). Predicate match is used to keep track of whether the
implementation transition has found a matching speciﬁcation
transition, or is determined to be stuttering, or is neither.
A check is performed on ’s’ to see if it belongs to the set
of states of speciﬁcation (SS). If ’s’ does not belong to SS,
then the w state has no corresponding speciﬁcation state and
therefore points to an error and the transition is added to RU.
When ’s’ exists in SS, a check has to be performed on the
implementation transition to see if it is a stuttering transition or
a non-stuttering transition. In case the transition is a stuttering
transition, the predicate match is set to true and the proce-
dure proceeds to the next transition in the implementation.
84
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-743-6
CYBER 2019 : The Fourth International Conference on Cyber-Technologies and Cyber-Systems

If the transition is a non-stuttering transition, the procedure
iterates through the speciﬁcation transitions ⟨s, u⟩. If a u is
found such that r(v) is equal to u, then match is assigned
true. Once a match is found, the procedure exits iterating
through the speciﬁcation transitions and moves on to the next
implementation transition. If for a non-stuttering transition,
r(v) does not match with any u, then this points to an error
in the implementation and the corresponding implementation
transition is appended to RU. When all the transitions of the
implementation have been checked, the procedure ends by
returning the list RU (line 18).
The time complexity of this algorithm is O(|RI||RS|). The
outer for loop has length of RI passes. The if condition on line
7 has length of SS passes. The inner for loop has length of RS
passes. The complexity of the algorithm is |RI|∗(|SS|+|RS|).
Usually, the number of transitions of the speciﬁcation (|RS|)
is greater than equal to the number of states of speciﬁcation
(|SS|) depending on the application. Hence, the overall time
complexity is O(|RI||RS|).
V.
RESULTS
Case Study - 1: The effectiveness of the algorithm pre-
sented in this paper were demonstrated on 22 different object
code programs for stepper motor control. In this paper, three
sequences of stepper motor control that uses 4 leads are used
to develop the benchmarks. Double stepping sequence an be
described as ⟨0011⟩, ⟨0110⟩, ⟨1100⟩, ⟨1001⟩, ⟨0011⟩, so on.
Full stepping sequence an be described as ⟨0001⟩, ⟨0010⟩,
⟨0100⟩, ⟨1000⟩, ⟨0001⟩, so on. Half stepping sequence an be
described as ⟨0001⟩, ⟨0011⟩, ⟨0010⟩, ⟨0110⟩, ⟨0100⟩, ⟨1100⟩,
⟨1000⟩, ⟨1001⟩, ⟨0001⟩, so on.
The programs were developed to run on an ARM Cortex-
M3 based NXP LPC1768 [21] microcontroller. PORT 2 of the
LPC1768 was used to connect the leads of the stepper motor
using an electronic circuit. Repetitive Interrupt Timer (RIT)
was used to generate interrupts at regular intervals of time in
some of the benchmarks to implement the timing requirements
for stepper motor control.
Table I shows the veriﬁcation statistics for the benchmarks.
The benchmark name indicates the type of control used. ”Full”,
”Double”, and ”Half” indicate full stepping, double stepping,
and half stepping were used, respectively. ”RIT” indicates
that the interrupts were generated by Repetitive Interrupt
Timer (RIT) to implement the timing delays for the motor
control. ”noRIT” indicates that instead of the RIT timer, code
was to implement timing delays. ”clock” and ”anti” indicate
that the motor was controlled clockwise and anti-clockwise,
respectively. The table gives statistics for both correct and
buggy versions of the controllers. ”FuncBug” indicate that the
object code error was a functional error. Column 3 gives the
number of transitions of the object code TS. Column 4 gives
the number of transitions in the abstract TS (which is generated
by applying suitable abstraction techniques). Column 5 gives
the time taken to perform WFS reﬁnement.
Case Study - 2: The effectiveness of the algorithm presented
in this paper were also demonstrated on industrial example,
an infusion pump. An infusion pump is a medical device
that can give controlled dosage of medications, like opioids,
TABLE I. VERIFICATION STATISTICS
S.No
Object Code
# of Trans.
# of Trans. of
WFS Veriﬁ.
Benchmarks
of MM I
of Abstract MM a
Time
[million]
[millisec]
1
Full-RIT-clock
2.5
10
3
2
Full-RIT-anti
2.5
10
3
3
Double-RIT-clock
2.5
10
4
4
Double-RIT-anti
2.5
10
3
5
Half-RIT-clock
4.5
18
4
6
Half-RIT-anti
4.5
18
3
7
Full-noRIT-clock
82.5
10
3
8
Full-noRIT-anti
82.5
10
4
9
Double-noRIT-clock
82.5
10
4
10
Double-noRIT-anti
82.5
10
6
11
Half-noRIT-clock
148.5
18
3
12
Half-noRIT-anti
148.5
18
5
13
FuncBug-Full
-RIT-clock
2.5
10
5§
14
FuncBug-Full
-RIT-anti
2.5
10
3§
15
FuncBug-Double
-RIT-clock
2.5
10
4§
16
FuncBug-Double
-RIT-anti
2.5
10
4§
17
FuncBug-Half
-RIT-clock
4.5
18
5§
18
FuncBug-Half
-RIT-anti
4.5
18
3§
19
FuncBug-Full
-noRIT-clock
99
20
3§
20
FuncBug-Full
-noRIT-anti
99
20
3§
21
FuncBug-Double
-noRIT-clock
82.5
10
4§
22
FuncBug-Double
-noRIT-anti
82.5
10
3§
§ indicates the time taken to generate counterexample
insulin, etc, or nutrients into the patients’s circulatory system
intravenously.
The program was developed for Alaris Medley 8100 LVP
module infusion pump [22], [23] for our experiments. Pulse
width modulation technique is used by this pump to control
the dosage delivered. The pulse width modulation control code
was implemented for the Alaris pump on an ARM Cortex M3
based LPC 1768 micro-controller. The pump was interfaced
to the micro-controller so that our code can control the pump.
The formal speciﬁcations for the pump control software was
developed based on the requirements in [24].
TABLE II. VERIFICATION STATISTICS FOR INFUSION PUMP
CONTROLLER
S.No
Object Code
# of Trans. of
WFS Veriﬁ. Time [millisec]
Benchmarks
MM I [million]
of Abstract MM a
1
IPC
24.3
3
2
IPC-FuncBug1
20.25
2§
3
IPC-FuncBug2
24.3
7§
4
IPC-FuncBug3
27
5§
§ indicates the time taken to generate counterexample
Table II shows the veriﬁcation statistics for the infusion
pump control case study. The transition system of the pump’s
control code had about 24.3 million transitions. The table gives
statistics for both correct and buggy versions of the controller.
”FuncBug” indicate that the object code error was a functional
error. Column 3 gives the number of transitions of the object
code TS. Column 4 gives the time taken to perform WFS
85
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-743-6
CYBER 2019 : The Fourth International Conference on Cyber-Technologies and Cyber-Systems

reﬁnement.
The code is not small snippets, but a working infusion
pump setup where the code is used to run the infusion pump.
It has been demonstrated that our method works with control
code. In general, code can be arbitrarily large, we have not
explored the scalability of our approach to problems in the
order of 100K lines of code.
For case studies 1 and 2, the veriﬁcation experiments were
performed on an Intel Core i7 3.1 GHz processor with 8GB
memory. Using suitable abstraction on the stuttering segments,
the number of transitions in the implementation TS have been
reduced from hundred of millions to less than 50 transitions.
Because of this huge reduction in the size of the state space, it
took less than a second to perform WFS reﬁnement checking
on the abstracted TS.
VI.
CONCLUSION
The effectiveness of the reﬁnement checker has been
demonstrated from the veriﬁcation results. Applying suitable
abstraction on the stuttering segments reduces the number of
transitions in the implementation TS for all the benchmarks.
The reduced size of the implementation TS enables detecting
and correcting the errors very easily since the veriﬁcation tools
are often used multiple times in practice.
This paper presents only the safety veriﬁcation technique. It
is intended to extend this work further by including techniques
to detect deadlock errors. If the code is not making progress
with respect to the speciﬁcation, then such a behavior is known
as deadlock.
ACKNOWLEDGMENT
This publication was funded by a grant from the United
States Government and the generous support of the American
people through the United States Department of State and the
United States Agency for International Development (USAID)
under the Pakistan - U.S. Science & Technology Cooperation
Program. The contents do not necessarily reﬂect the views of
the United States Government.
REFERENCES
[1]
US Food and Drug Administration (FDA), “Medical device recalls,”
https://www.accessdata.fda.gov/scripts/cdrh/cfdocs/cfRES/res.cfm,
2019, last accessed: April 2019.
[2]
K. G. Larsen, P. Pettersson, and W. Yi, “Uppaal in a nutshell,” STTT,
vol. 1, no. 1-2, 1997, pp. 134–152.
[3]
M. Bozga and et al., “Kronos: A model-checking tool for real-time
systems (tool-presentation for ftrtft ’98),” in Formal Techniques in
Real-Time and Fault-Tolerant Systems, 5th International Symposium,
FTRTFT’98, Lyngby, Denmark, September 14-18, 1998, Proceedings,
ser. Lecture Notes in Computer Science, A. P. Ravn and H. Rischel,
Eds., vol. 1486.
Springer, 1998, pp. 298–302.
[4]
J. C. Godskesen, K. G. Larsen, and A. Skou, “Automatic veriﬁcation of
real-time systems using epsilon,” in Protocol Speciﬁcation, Testing and
Veriﬁcation XIV, Proceedings of the Fourteenth IFIP WG6.1 Interna-
tional Symposium on Protocol Speciﬁcation, Testing and Veriﬁcation,
Vancouver, BC, Canada, 1994, ser. IFIP Conference Proceedings, S. T.
Vuong and S. T. Chanson, Eds., vol. 1.
Chapman & Hall, 1994, pp.
323–330.
[5]
M. A. L. Dubasi, S. K. Srinivasan, and V. Wijayasekara, “Timed re-
ﬁnement for veriﬁcation of real-time object code programs,” in Veriﬁed
Software: Theories, Tools and Experiments - 6th International Confer-
ence, VSTTE 2014, Vienna, Austria, July 17-18, 2014, Revised Selected
Papers, ser. Lecture Notes in Computer Science, D. Giannakopoulou and
D. Kroening, Eds., vol. 8471.
Springer, 2014, pp. 252–269.
[6]
S. Ray and R. Sumners, “Speciﬁcation and veriﬁcation of concurrent
programs through reﬁnements,” J. Autom. Reasoning, vol. 51, no. 3,
2013, pp. 241–280.
[7]
M. Jain and P. Manolios, “An efﬁcient runtime validation framework
based on the theory of reﬁnement,” CoRR, vol. abs/1703.05317, 2017.
[8]
K. S. Namjoshi, “A simple characterization of stuttering bisimulation,”
in Foundations of Software Technology and Theoretical Computer
Science, 17th Conference, Kharagpur, India, December 18-20, 1997,
Proceedings, 1997, pp. 284–296.
[9]
J. F. Groote and A. Wijs, “An o(m\log n) algorithm for stuttering
equivalence and branching bisimulation,” in Tools and Algorithms
for the Construction and Analysis of Systems - 22nd International
Conference, TACAS 2016, Held as Part of the European Joint Con-
ferences on Theory and Practice of Software, ETAPS 2016, Eindhoven,
The Netherlands, April 2-8, 2016, Proceedings, ser. Lecture Notes
in Computer Science, M. Chechik and J. Raskin, Eds., vol. 9636.
Springer, 2016, pp. 607–624.
[10]
J. Derrick, S. North, and A. J. H. Simons, “Building a reﬁnement
checker for Z,” ser. EPTCS, J. Derrick, E. A. Boiten, and S. Reeves,
Eds., vol. 55, 2011, pp. 37–52.
[11]
T. Gibson-Robinson, P. J. Armstrong, A. Boulgakov, and A. W. Roscoe,
“FDR3: a parallel reﬁnement checker for CSP,” STTT, vol. 18, no. 2,
2016, pp. 149–167.
[12]
K. Etessami, “Stutter-invariant languages, omega-automata, and tempo-
ral logic,” in Computer Aided Veriﬁcation, 11th International Confer-
ence, CAV ’99, Trento, Italy, July 6-10, 1999, Proceedings, 1999, pp.
236–248.
[13]
C. Dax, F. Klaedtke, and S. Leue, “Speciﬁcation languages for stutter-
invariant regular properties,” in Automated Technology for Veriﬁcation
and Analysis, 7th International Symposium, ATVA 2009, Macao, China,
October 14-16, 2009. Proceedings, ser. Lecture Notes in Computer
Science, Z. Liu and A. P. Ravn, Eds., vol. 5799.
Springer, 2009,
pp. 244–254.
[14]
N. Shaukat, S. Shuja, S. K. Srinivasan, S. Jabeen, and M. A. L. Dubasi,
“Static stuttering abstraction for object code veriﬁcation,” in CYBER
2018, The Third International Conference on Cyber-Technologies and
Cyber-Systems, Athens, Greece.
IARIA, Nov 2018, pp. 102–106.
[15]
G. Behrmann, A. David, K. G. Larsen, P. Pettersson, and W. Yi,
“Developing UPPAAL over 15 years,” Softw., Pract. Exper., vol. 41,
no. 2, 2011, pp. 133–142.
[16]
A. David, K. G. Larsen, A. Legay, U. Nyman, and A. Wasowski, “Timed
I/O automata: a complete speciﬁcation theory for real-time systems,”
in Proceedings of the 13th ACM International Conference on Hybrid
Systems: Computation and Control, HSCC 2010, Stockholm, Sweden,
April 12-15, 2010, K. H. Johansson and W. Yi, Eds.
ACM, 2010, pp.
91–100.
[17]
A. Boudjadar, J. Bodeveix, and M. Filali, “Compositional reﬁnement for
real-time systems with priorities,” in 19th International Symposium on
Temporal Representation and Reasoning, TIME 2012, Leicester, United
Kingdom, September 12-14, 2012, B. C. Moszkowski, M. Reynolds,
and P. Terenziani, Eds.
IEEE Computer Society, 2012, pp. 57–64.
[18]
E. Al-Qtiemat, S. K. Srinivasan, M. A. L. Dubasi, and S. Shuja,
“A methodology for synthesizing formal speciﬁcation models from
requirements for reﬁnement-based object code veriﬁcation,” in CYBER
2018, The Third International Conference on Cyber-Technologies and
Cyber-Systems, Athens, Greece.
IARIA, Nov 2018, pp. 94–101.
[19]
S. Jabeen, S. K. Srinivasan, S. Shuja, and M. A. L. Dubasi, “A
formal veriﬁcation methodology for fpga-based stepper motor control,”
Embedded Systems Letters, vol. 7, no. 3, 2015, pp. 85–88.
[20]
P. Manolios, “Mechanical veriﬁcation of reactive systems,” Ph.D. dis-
sertation, University of Texas at Austin, 2001.
[21]
“Keil
cortex-m
evaluation
board
comparison,”
http://www.keil.com/arm/boards/cortexm.asp,
last
accessed:
April
2019.
86
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-743-6
CYBER 2019 : The Fourth International Conference on Cyber-Technologies and Cyber-Systems

[22]
CareFusion, Alaris PC Unit, Alaris Pump Module, Technical Service
Manual, CareFusion, 2010.
[23]
ALARIS Medical Systems, Inc., Directions for use. Pump Module, 8100
series, ALARIS Medical Systems, Inc., 2004.
[24]
Y. Zhang, R. Jetley, P. L. Jones, and et al., “Generic safety requirements
for developing safe insulin pump software,” Journal of Diabetes Science
and Technology, vol. 5, no. 6, 11 2011, pp. 1403–1419.
87
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-743-6
CYBER 2019 : The Fourth International Conference on Cyber-Technologies and Cyber-Systems

