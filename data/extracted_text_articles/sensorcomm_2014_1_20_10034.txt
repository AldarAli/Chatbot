A Novel ID Anonymity Preserving Scheme (ID-APS)
for Hierarchical Wireless Sensor Networks
Ahmed Al-Riyami, Ning Zhang and John Keane
School of Computer Science
The University of Manchester
Manchester, UK
Email:{ahmed.al-riyami,ning.zhang,john.keane}@manchester.ac.uk
Abstract—Node ID anonymity is a critical aspect of privacy in
Wireless Sensor Networks (WSNs). Exposing node IDs can help
adversaries to learn the underlying network infrastructure and to
mount more serious attacks, such as attacks on important nodes
(e.g., cluster heads). Therefore, providing ID anonymity should
be an integral part of the solution to secure WSNs, and should
not hinder other security properties such as accountability and
intrusion detection. However, the latter requires that communica-
tion nodes be identiﬁable globally in a dynamic WSN where there
is no ﬁxed infrastructure support. Achieving these contradicting
security properties effectively and efﬁciently is challenging. This
paper proposes a method, termed ID Anonymity Preserving
Scheme (ID-APS), to preserve node ID anonymity with a global
node identiﬁcation capability in hierarchical WSNs. Evaluation
results show that ID-APS achieves these properties at a lower level
of costs (computational, communication and memory overheads)
than comparable methods.
Keywords–Wireless Sensor Networks; privacy; ID anonymity;
pseudonym.
I.
INTRODUCTION
A critical aspect of privacy in Wireless Sensor Networks
(WSNs) is node ID anonymity. By knowing the IDs of the
nodes in a WSN, an adversary may obtain information about
the communication relationships among the nodes, and infer
the network topology which can help to launch successful
attacks on important nodes such as cluster heads. Inference
of network topology through analysis of node IDs is known
as ID analysis attack [1].
Passive adversaries launch ID analysis attacks by eaves-
dropping on network communications; they overhear messages
exchanged over wireless media and view source and desti-
nation IDs in the message headers. Active adversaries launch
ID analysis attacks through node compromise; they physically
capture a node and access data stored in its memory (e.g.,
clustering information), identifying the network topology.
Eavesdropping and node compromise attacks are hard to
thwart due to the nature of WSNs, e.g., open wireless media
and unattended nodes. Existing solutions address these attacks
by using dynamic pseudonyms [2]–[5]. These solutions assign
a unique pseudonym ID to each node in each transmission,
disguising the node’s real ID. However, there are a number
of issues with these solutions. The ﬁrst issue is that some
solutions, e.g., [3], [4], only consider anonymising node IDs in
unicast communications; communication among sensor nodes
involves broadcasts as well. If ID anonymity is only provided
in unicast communications, then an adversary may still be able
to identify nodes through broadcasts. The second issue is how
to reduce costs incurred in preserving ID anonymity. Take
pseudonym updating and synchronization as an example, some
solutions, e.g., [4], [5], require each pair of communication
nodes to use acknowledgments to convey and synchronise the
values of a set of pseudonym parameters after each packet
transmission between the pair. This raises two further issues.
One is that acknowledgments consume network bandwidth
and sensor node energy, and increase network trafﬁc levels
causing congestions and packet collisions. The second is
that acknowledgments are impractical for broadcast trafﬁc, as
the resulting acknowledgments will ﬂood the entire network.
However, if no mechanism exists to allow communicating
nodes to synchronise broadcast pseudonyms, a corrupt or
lost message could lead to unsynchronized parameter values
hindering further anonymous communication.
Further, preserving node ID anonymity should be accom-
panied by a secure node global identiﬁcation facility. This is
because the system will also provide other important security
properties, e.g., intrusion detection and node compromise
detection where a monitoring node needs to report suspicious
nodes to the base station. Providing node ID anonymity should
enable, rather than hinder, these properties.
This paper proposes a secure solution, the ID Anonymity
Preserving Scheme (ID-APS) for hierarchical WSNs. ID-APS
offers anonymity and efﬁciency improvements over the Cryp-
tographic Anonymity Scheme (CAS) [2], the most relevant
existing solution. It provides a trade-off between ID anonymity
level and computational costs, while minimising communica-
tion overheads and memory consumptions. Further, ID-APS
also provides an additional built-in functionality to support
controlled global node identiﬁability, i.e., each node in ID-
APS can be globally identiﬁed by authorised entities. Such
ﬂexibility makes ID-APS highly suitable for a wider range of
applications as compared with previous solutions.
The rest of the paper is structured as follows: related work
is discussed in Section II; the CAS scheme is described in
Section III; Section IV discusses how ID-APS improves CAS;
Section V presents design preliminaries; the ID-APS scheme
is described in Section VI; Section VII analyses the scheme
and ﬁnally, Section VIII concludes the paper.
II.
RELATED WORK
Misra and Xue [2] address anonymity through dynamic
pseudonyms in clustered WSNs. They proposed two anonymity
schemes, Simple (SAS) and Cryptographic (CAS). In SAS,
each node is assigned a randomly distributed set of pseudonym
sub-ranges selected from a large space. The node chooses a
different pseudonym to identify itself in each transmission.
SAS is efﬁcient as it does not involve complicated compu-
7
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

tations; however, it requires space to store the pseudonym
sub-ranges. CAS reduces the high memory usage of SAS by
generating pseudonyms on a per-message basis at run-time
by key hashing a sequence number and a pre-deﬁned seed
shared between communicating nodes. CAS is more efﬁcient
than SAS in terms of memory consumption but at the cost of
additional run-time computation. Nevertheless, if an adversary
compromises a node in CAS, the adversary may compute the
previous IDs of the node using the compromised secret key
and the current sequence number.
To protect past used pseudonyms against node compromis-
ing attacks, Ouyang et al. [3] proposed the Hashing based ID
Randomization (HIR) scheme. Similar to CAS, HIR uses a
keyed hash function to generate dynamic pseudonyms. Each
outgoing message is identiﬁed by a new pseudonym that is
generated by key hashing the pseudonym used in the previous
message. After each message transmission, the sender creates
a new pseudonym and deletes the old one. So, if an adversary
obtains the current pseudonym and the secret key, it is still
difﬁcult to derive the previous used pseudonyms because of
the one way property of the hash function. However, the
adversary can still compute the next pseudonym ID and hence
impersonate the compromised node to send future messages
once the key is captured. To resist such attacks on future
messages, the same authors proposed the Reverse Hashing ID
Randomization (RHIR) scheme. In RHIR, the one-way hash
chain is used in the reverse order, i.e., pseudonyms are assigned
backwards from the end of a pre-generated hash chain. This
method is more secure against impersonation attack, however,
RHIR consumes more memory to store the hash chain and
provides each node with a limited number of pseudonyms. In
addition, both HIR and RHIR only address anonymous unicast
communication not broadcast.
Another scheme to support node ID anonymity is the
Anonymous Path Routing (APR) scheme [4]. It hides node
IDs using dynamic pseudonyms and uses per-message keys
to encrypt each transmitted message. APR only provides
node ID anonymity for unicast. For broadcast, (e.g., when
a node broadcasts an anonymous path routing request), the
broadcasters’ IDs are exposed. Hence, an adversary can learn
a source node ID from broadcast messages.
Chen and Fang [5] proposed the Efﬁcient Anonymous
Communication (EAC) scheme. Unlike other solutions, EAC
supports both anonymous unicast and broadcast. Once a mes-
sage is sent, the sender and receiver generate the next message
pseudonym independently using a hash function. The hash
function input includes the current message pseudonym and a
parameter value shared between the two nodes. To synchronize
the unicast pseudonyms used by the two communicating nodes,
EAC uses anonymous acknowledgments. After receiving an ac-
knowledgment sent by the receiver, the sender updates the next
message pseudonym. However, this work does not mention
how local broadcast pseudonyms, which are used between a
sender and all its direct neighbours, are synchronised. Without
a broadcast pseudonym synchronization solution, the use of
anonymous broadcasting may not be practical in areas where
message loss and transmission errors are probable.
III.
THE CAS SCHEME
Pseudonyms in CAS are generated on a per-message basis
using a keyed hash function and a number of parameter
values. The parameters include keys, random seeds and mes-
sage sequence numbers. Each node maintains a pseudonym
table containing the parameter values for each other node
in its neighbourhood. Two phases are involved: during the
setup phase, nodes exchange and update the parameter values;
during the operational phase, they use the values to compute
and verify pseudonyms for anonymous unicast and broadcast
communications.
A unicast message from node u to the base station
via node v is composed as: Muv
=
SID
∥
RID
∥
EncryptedPayload ∥ sequv where SID is the end-to-end
mutual pseudonym, SID = Indexv ∥ HKBu(aBu ⊕ sequv)
and RID is the next-hop mutual pseudonym, RID
=
Indexv ∥ HKuv(auv ⊕ sequv), Indexv is the index used to
index node u’s parameter values in node v’s pseudonym table,
KBu and aBu are the hash pairwise key and the random seed
shared between node u and the base station, respectively, Kuv
and auv are the hash pairwise key and the random seed shared
between node u and node v, respectively and sequv is the
current message sequence number for mutual communication
between nodes u and v. When v receives message Muv, it
retrieves Indexv and searches its pseudonym table for a match.
If a match is found, node v uses the corresponding values of
Kuv and auv to compute HKuv(auv ⊕sequv). If the computed
value equals the received value, node v accepts the message,
otherwise it drops the message. When node v forwards the
message to the base station, it includes the received sequence
number sequv. When the message reaches the base station, the
base station computes HKBi(aBi ⊕ sequv) where i refers to
every node in the network. Then, it compares the computed
hash values with the hash value received in the message to
identify its original source.
A local broadcast from cluster head u to its neighbours is
composed as: Mu∗ = SID ∥ RID ∥ EncryptedPayload ∥
seqcu where SID and RID are both pseudonyms used to
identify the sender, u, SID = Sentinel ∥ HKcu(acu ⊕seqcu)
and RID = Sentinel ∥ HKcu(bcu ⊕ seqcu), where Sentinel
is a special character indicating that the broadcast is sent by
the cluster head, Kcu is the cluster key, acu and bcu are random
seeds shared between the cluster head and all other nodes in
the cluster and seqcu is the current message sequence number.
Upon receiving the broadcast, a cluster member node identiﬁes
the Sentinel to conﬁrm that the message is a broadcast from
the cluster head. The node then retrieves the parameter values
related to the cluster head from its own pseudonym table and
uses the values to compute new hash values HKcu(acu⊕seqcu)
and HKcu(bcu ⊕ seqcu). If the computed hash values match
with the received ones, then the node conﬁrms that the message
is from the respective cluster head.
IV.
PROPERTIES OF ID-APS
CAS can be improved on three fronts: (i) integrate global
node identiﬁability with ID anonymity, (ii) strengthen the
ID anonymity protection level, and (iii) reduce overheads in
achieving these properties. These improvements are accom-
plished using the following ideas:
-
For (i), this is achieved by a hybrid combination of
ﬁxed (static) and dynamic pseudonyms. Each node can be
globally identiﬁed using a ﬁxed pseudonym, while their
communications are carried out by using per-message
dynamic pseudonyms.
8
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

-
For (ii), two measures are used. The ﬁrst is to break any
association between a currently used pseudonym and the
pseudonyms used in the past. So, the use of a random
number attribute is introduced in dynamic pseudonym
generations. In this way, if the current pseudonym is
compromised, the previously used pseudonyms remain
safe. The second measure is to hide any patterns or
hints that may help adversaries to identify a particular
node or a node performing a particular function. For
example, CAS uses special characters (Sentinel) to
identify cluster heads in broadcasts. These sentinels may
be used to identify cluster heads as only cluster heads use
them. To hide any patterns, we use the same mechanism
(indexes) for unicasts and broadcasts and these indexes
are randomly picked by the node concerned during the
setup phase of the network. We also make the structure of
the broadcast pseudonyms identical to that of the unicast
pseudonyms, making it harder for an adversary to learn
any identiﬁable information in the network.
-
For (iii), inspired by [6], the sequence number (i.e.,
message counter) is divided into two parts: one part is
explicitly sent as part of the pseudonym in a message and
the other part is hidden from transmission (i.e., stored in
the node’s memory). In this way, the sender and receiver’s
counters do not need to be tightly synchronized. As long
as the number of consecutively lost messages does not
exceed a certain threshold, the receiver can still verify
the dynamic pseudonym, learn the message sender and
synchronise its counter value with the sequence value
received. This, along with the reduction in the number of
overhead bits each message has to carry, can lead to both
bandwidth and node battery savings.
V.
PRELIMINARIES
This section presents the system model, assumptions and
requirement speciﬁcations used in the design of ID-APS.
A. System Model
The WSN consists of a number of homogeneous resource-
constrained static sensors and a single resource-rich base
station (BS). All network links are assumed to be bidirectional.
The network is partitioned into a set of clusters, each with an
elected cluster head (CH). Sensor nodes periodically collect
measured data and locally aggregate the collected data within
each cluster before sending the aggregated data to the BS.
Communication modes in this setting include:
-
Broadcasts from the BS to all network nodes.
-
Unicasts between the BS and any other network node.
-
Broadcasts from a node to all its one-hop neighbours.
-
Broadcasts from the CH to all cluster member nodes.
-
Unicasts among nodes in the same cluster (or tier).
To maximise security, the principle of separation of duties
is adopted to establish cryptographic (i.e., symmetrical) keys.
In other words, different keys are used for different purposes
as follows:
-
Network key (kN): This is the network-wide key shared
between the BS and all nodes in the network. It is used
for securing messages broadcast by the BS.
-
Individual Key (kBi): Each node i shares a unique indi-
vidual key with the BS. The key is used to secure pairwise
unicasts between the node and the BS.
-
Pairwise Key (kij): Each node i shares a unique pairwise
key with each of its one-hop neighbours, j. This key is
used by node i to secure unicast messages to node j and
vice versa.
-
Broadcast Key (k∗
i ): Each node i shares a unique broad-
cast key with each of its one-hop neighbours. This key
is used to secure local broadcasts by node i to its
neighbours.
-
Cluster Broadcast Key (k⊙
i ): This key is shared by a CH
i and other member nodes in the cluster. It is used by the
CH to secure all local broadcasts to cluster members.
kN and kBi are generated by the BS and pre-loaded into
each node prior to its deployment. kij and k∗
i are established
using the Energy-efﬁcient Distributed Deterministic Key man-
agement scheme (EDDK) [7]. In addition to key establishment,
EDDK is also used for node discovery and periodic secure
updates of kij and k∗
i . k⊙
i is established by the CH. The CH
generates the key using a pseudorandom function and securely
unicasts it to every cluster member using the pairwise keys.
Adversaries try to identify the nodes and the communica-
tion relationships among them. To do this, they try to access all
available information by any means (passive or active attacks).
The notations used in this paper are summarised in Table I.
B. Assumptions
-
Each node i ∈ N has a unique identity, IDi.
-
The BS is always available, trustworthy and protected
against physical attacks.
-
The clocks of the BS and all the sensor nodes are
synchronized.
-
Broadcasts from the BS are done by using the µTesla
authenticated broadcast method [8].
-
Sensor nodes are able to obfuscate address ﬁelds in
their Medium Access Control (MAC) layer header. This
assumption is necessary to scope our work without losing
generality. A solution to prevent sensor nodes from
leaking their MAC level IDs is to use the dynamic
pseudonyms at the MAC level as well.
-
Each node i maintains a pseudonym table Ti. Ti stores
the attribute values associated with the BS and each of
the node’s neighbours as shown in Table II.
C. Design Requirement Speciﬁcations
(a) Node ID anonymity:
-
NIP-1: A passive adversary should be unable to learn the
identity of the source or destination of a unicast message.
-
NIP-2: A passive adversary should be unable to learn the
identity of the source of a broadcast.
-
NIP-3: An active adversary should be unable to learn
the identities of uncompromised nodes through eaves-
dropping on their unicast communication.
-
NIP-4: An active adversary should be unable to learn the
past identities of a compromised node.
(b) Node Global Identiﬁcation:
-
GLB-1: A sensor node should be able to globally identify
other network nodes without exposing the node IDs to an
eavesdropping adversary.
(c) Message Security:
-
MSE-1: All messages transmitted should be conﬁdential.
9
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

TABLE I.
ID-APS NOTATION
Notation
Deﬁnition
N
Set of all nodes in WSN where total number of nodes |N| = N.
Ti
The pseudonym table of node i.
Ni
Set of all nodes that have their details stored in Ti.
Ai
Subset of Ni which includes all nodes that node i is allowed to
communicate with based on node i’s role.
α
Secret only known by the BS.
β
Shared secret known by the BS and all network nodes.
HID
k
(.)
Keyed one-way hash function with output of lID bits long.
Hk(.)
Keyed one-way hash function with output of lH bits long.
⊕
Bitwise exclusive-or (XOR) operation.
IDB
Real identity of BS. All IDs are lID bits long.
IDi
Real identity of node i exclusively known to node i and BS.
ID
′
i
Fixed initial pseudonym assigned to node i.
ID
′′
i
Fixed operational pseudonym created for node i.
IDi→B
Dynamic pairwise pseudonym computed by node i; it is used in
unicast messages sent to BS.
IDi→j
Dynamic pairwise pseudonym computed by node i; it is used in
unicast messages sent to node j.
IDi→∗
Dynamic broadcast pseudonym computed by node i; it is used in
broadcast messages sent to neighbours.
kN
Network key shared by BS and all network nodes. All keys used are
lk bits long.
kBi
Individual key shared between node i and BS.
kij
Pairwise key shared between nodes i and j.
k∗
i
Broadcast key shared between node i and all its one-hop neighbours.
k⊙
i
Cluster broadcast key shared between a CH node i and all member
nodes in the cluster.
indi→j
Unicast index shared between nodes i and j. All indexes are li bits
long.
indi→∗
Broadcast index of node i shared between node i and its neighbours.
Hi→j
Pairwise hash value used for the construction of dynamic pseudonyms
in messages sent from node i to node j.
Hi→∗
Broadcast hash value used for the construction of dynamic
pseudonyms in messages broadcast by node i to its neighbours.
hi→j
Implicit counter of messages sent by node i to node j. hi→j is lh
bits long.
si→j
Explicit counter of messages sent by node i to node j. si→j is ls
bits long.
Ci→j
Unicast counter. This is the counter of messages sent by node i to
node j. It consists of two parts: the implicit counter, hi→j, and the
explicit counter, si→∗, ( i.e., Ci→j = hi→j ∥ si→j).
Ci→∗
Broadcast counter of node i. It is the counter of messages broadcast
by node i to its neighbours.
Ci→⊙
Cluster broadcast counter of node i. It is the counter of messages
broadcast by node i to other member nodes in the cluster.
ri→j
Random number generated by node i for the construction of dynamic
pseudonyms in messages sent from node i to node j. The random
number is lr bits long.
ri→∗
Random number generated by node i for the construction of dynamic
pseudonyms in messages broadcast from node i to its neighbours.
MAC
Message authentication code.
ST
Threshold value representing the number of lost messages that can be
tolerated by the WSN.
TABLE II.
THE PSEUDONYM TABLE (Ti) OF NODE i
BS
CH
Other neighbours
Fixed Pseudonym
ID
′′
B
ID
′′
j
ID
′′
u
ID
′′
v
. . .
Pairwise key (k)
kBi
kij
kiu
kiv
. . .
Broadcast key (k)
kN
k∗
j
k∗
u
k∗
v
. . .
Cluster broadcast key (k)
k⊙
j
Outbound unicast index (ind)
indi→B
indi→j
indi→u
indi→v
. . .
Outbound unicast counter (C)
Ci→B
Ci→j
Ci→u
Ci→v
. . .
Inbound unicast index (ind)
indB→i
indj→i
indu→i
indv→i
. . .
Inbound unicast counter (C)
CB→i
Cj→i
Cu→i
Cv→i
. . .
Broadcast index (ind)
indB→∗
indj→∗
indu→∗
indv→∗
. . .
Broadcast counter (C)
CB→∗
Cj→∗
Cu→∗
Cv→∗
. . .
Cluster broadcast counter (C)
Cj→⊙
-
MSE-2: The authenticity and integrity of a transmitted
message should be ensured.
-
MSE-3: A replay attack on a message should be de-
tectable.
(d) Minimizing Overhead Costs:
-
MOC-1: Minimize computational costs.
-
MOC-2: Minimize communication overheads.
-
MOC-3: Minimize memory requirements.
VI.
THE ID-APS SCHEME
This section provides an overview of the design of ID-APS
including different pseudonyms and protocols used.
A. Pseudonyms
As shown in Figure 1, ID-APS uses a hybrid combination
of ﬁxed (initial and operational) and dynamic (pairwise and
broadcast) pseudonyms. These pseudonyms are discussed in
more details below.
Fixed Pseudonyms 
Initial 
Dynamic Pseudonyms 
Node Real ID 
Network Initialization 
Network Operation 
𝑰𝑫𝒊
′ = 𝑯𝒌𝑵
𝑰𝑫(𝑰𝑫𝒊⨁ 𝜶) 
𝑰𝑫𝒊 
Operational 
𝑰𝑫𝒊
′′ = 𝑯𝒌𝑵
𝑰𝑫(𝑰𝑫𝒊
′⨁ 𝜷) 
Clustering 
Node Discovery 
Clustered Topology 
Broadcast 
𝑰𝑫𝒊→∗ = 𝒊𝒏𝒅𝒊→∗ ∥ 𝒔𝒊→∗ ∥ 𝒓𝒊→∗ ∥ 𝑯𝒊→∗ 
Pairwise 
𝑰𝑫𝒊→𝒋 = 𝒊𝒏𝒅𝒊→𝒋 ∥ 𝒔𝒊→𝒋 ∥ 𝒓𝒊→𝒋 ∥ 𝑯𝒊→𝒋 
𝑯𝒊→𝒋 = 𝑯𝒌𝒊𝒋(𝑰𝑫𝒊
′′⨁𝑰𝑫𝒋
′′⨁𝓒𝒊→𝒋⨁𝒓𝒊→𝒋) 
𝓒𝒊→𝒋 = 𝒉𝒊→𝒋 ∥ 𝒔𝒊→𝒋 
where 
𝑯𝒊→∗  = 𝑯𝒌𝒊
∗(𝑰𝑫𝒊
′′⨁𝓒𝒊→∗⨁𝒓𝒊→∗) 
𝓒𝒊→∗ = 𝒉𝒊→∗ ∥ 𝒔𝒊→∗ 
where 
… 
… 
… 
… 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
. 
Pseudonym Table (𝑻𝒊) 
Figure 1.
Pseudonym structure used in ID-APS.
(a) Fixed Pseudonyms
•
Initial pseudonym ID
′
i: A unique identiﬁer of the node
used during the initial node discovery and key establishment
phase. ID
′
i is computed by the BS as ID
′
i = HID
kN (IDi ⊕ α)
and loaded into each node before its deployment.
•
Operational pseudonym ID
′′
i : A unique global identiﬁer
of the node used after the initial phase. It is used when
the node should be identiﬁed by authorized entities. It is
also used to generate dynamic pseudonyms for the node.
The conﬁdentiality of this pseudonym is always protected in
transit. It is computed as ID
′′
i = HID
kN (ID
′
i ⊕ β).
(b) Dynamic Pseudonyms
•
Pairwise pseudonym IDi→j: This is a dynamically
generated pseudonym used as a per-message pseudonym
identifying both node i (as a sender) and j (as a receiver)
in each message ﬂowing from node i to j. Similarly,
node j will use IDj→i for its unicast to node i. Only
the intended recipient of the unicast can recognise this
pseudonym. The pairwise pseudonyms are used in all unicast
communications taking place after the initial phase. IDi→j
is constructed as IDi→j = indi→j ∥ si→j ∥ ri→j ∥ Hi→j
where
Hi→j
=
Hkij(ID
′′
i
⊕ ID
′′
j ⊕ Ci→j ⊕ ri→j),
Ci→j = hi→j ∥ si→j and,
10
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

-
indi→j is an outbound unicast index value shared be-
tween nodes i and j. It is also called the inbound unicast
index of node j for messages from node i. This value is
ﬁxed for the life-time of node i. It is used by node j (the
recipient) to verify the potential senders of a received
message. This veriﬁcation is designed to ﬁlter out any
unauthentic messages as soon as they are received, i.e.,
before more accurate and expensive veriﬁcations need to
be performed. A recipient only accepts a message if the
index value contained in the message matches with one
of those recorded in its pseudonym table. Node j will use
another index indj→i to send unicasts to node i. These
indexes are established as follows: assume that the length
of indi→j is li bits, node i picks indi→j at random from
the range of 2li values and sends it to node j encrypted
with the pairwise key. Node j does the same to establish
indj→i with node i.
-
Ci→j is used to generate sequence numbers to be car-
ried in messages from node i to node j. It is called
an outbound unicast counter by node i and inbound
unicast counter by node j. It consists of two parts: an
implicit counter hi→j and an explicit counter si→j, (i.e.,
Ci→j = hi→j ∥ si→j). The implicit counter hi→j is not
included in the pseudonym; rather it is one of the input
items used in generating the keyed hash value Hi→j.
The explicit counter si→j is explicitly transmitted as part
of the pseudonym. si→j increments with each message
transmission while hi→j increments each time si→j
reaches its maximum value, at which point si→j is set to
0. Ci→j is maintained by both nodes in their pseudonym
tables and its value is incremented by the sender after
each message transmission and by the receiver after each
message reception. Typically, the counters start from 0.
However, to increase the anonymity level, each node
establishes a random start to its counter value with the
receiver. The purpose for using this counter is two-fold:
(i) to ensure uniqueness of the pseudonyms carried in
each message; (ii) to assure the freshness of a received
messages (i.e., for detecting replayed messages).
-
ri→j is a random number generated by node i to break the
link between the pseudonyms used in different messages
sent from node i to j, i.e., to make it harder for an
adversary to compute node pseudonyms used previously
once the current pseudonym is compromised. ri→j is
regenerated before each message transmission and sent as
part of the pseudonym but not stored in the pseudonym
tables of the communicating nodes.
-
Hi→j is an outbound hash value carried as part of the
pseudonym in a unicast from node i to node j. It is used
by the sending node to (i) further obfuscate the identities
of the sender and receiver of the unicast; (ii) to ensure
the authenticity of the pseudonym. Upon reception, this
hash value will also be used by the recipient to verify the
pseudonym.
To generate a pairwise pseudonym, the source node ﬁrst
retrieves kij, indi→j and Ci→j from its pseudonym table,
picks a random number ri→j, computes Hi→j and constructs
IDi→j. The node then increments the counter value to make
it ready for the next message.
•
Broadcast
pseudonym
IDi→∗:
This
pseudonym
is
dynamically generated by node i for each message it
broadcasts to its neighbours. IDi→∗ can only be identiﬁed
by nodes that have node i in their pseudonym tables and are
located within the transmission range of node i. The generation
of a broadcast pseudonym is similar to that of a pairwise
pseudonym, except that a different set of attribute values are
used based on whether the node is broadcasting within its
own cluster or outside the cluster. If the node is broadcasting
within the cluster, then the node uses its broadcast index
indi→∗, cluster broadcast key k⊙
i
and cluster broadcast
counter Ci→⊙ to construct IDi→∗. The parameters, indi→∗,
k⊙
i
and Ci→⊙ are shared among all the nodes in the cluster
and maintained in each node’s pseudonym table. IDi→∗ is
constructed as IDi→∗ = indi→∗ ∥ si→⊙ ∥ ri→∗ ∥ Hi→∗
where Hi→∗ = Hk⊙
i (ID
′′
i ⊕ Ci→⊙ ⊕ ri→∗). However, if
the node is broadcasting outside its cluster, then it uses its
broadcast index indi→∗, broadcast key k∗
i
and broadcast
counter Ci→∗ to construct IDi→∗ where k∗
i and Ci→∗ are
shared among all the neighbouring nodes and maintained
in each node’s pseudonym table. IDi→∗ is constructed
as IDi→∗
= indi→∗
∥ si→∗
∥ ri→∗
∥ Hi→∗ where
Hi→∗ = Hk∗
i (ID
′′
i ⊕ Ci→∗ ⊕ ri→∗).
(c) Dynamic Pseudonym Veriﬁcation (DP-Ver)
When a message is received by a node, say j, the node
executes algorithm DP-Ver (Figure 2) to conﬁrm the validity
and authenticity of the pseudonym contained in the message.
DP-Ver consists of three veriﬁcations, DP-Ver.1, DP-Ver.2 and
DP-Ver.3. If the outcome of DP-Ver.1 is negative, node j will
discard the message, otherwise it performs DP-Ver.2. If the
outcome of DP-Ver.2 is positive, then the node conﬁrms the
validity of the received pseudonym, otherwise it performs DP-
Ver.3. Similarly, if the outcome of DP-Ver.3 is positive then
the node conﬁrms the validity of the pseudonym, otherwise,
it discards the message. The three veriﬁcations are detailed
below.
 
 
 
 
 
 
 
 DP-Ver.1  
 DP-Ver.2  
 DP-Ver.3 
Y 
N 
Y 
N 
Y 
N 
𝑰𝑫𝒓𝒆𝒄 
matchUni 
matchBro 
𝑰𝑫′′ 
𝐦𝐞𝐬𝐬𝐚𝐠𝐞 𝐭𝐲𝐩𝐞 
𝐤𝐞𝐲 
Discard  
message 
𝑰𝑫𝒓𝒆𝒄 
Figure 2.
DP-Ver algorithm.
•
DP-Ver.1 - Index Value Veriﬁcation: Used to verify the
received index value by searching for a match in the receiver’s
pseudonym table. DP-Ver.1 is a computationally cheap veriﬁ-
cation that is used to ﬁlter out unauthentic messages as soon
as possible. Node j maintains a set of nodes with which node
j is allowed to communicate, Aj where Aj ⊂ Nj. Each node
belongs to one cluster and is only allowed to communicate
with the nodes (CH and other members) in the same cluster.
Only the CH is allowed to communicate outside the cluster
with other CHs. Therefore, when node j receives a message,
it retrieves index indrec from the received message and checks
it against the index values of the nodes belonging to Aj. As
node j does not know whether the received message is a
unicast or broadcast, it has to check against the unicast and
broadcast indexes of all nodes in Aj. If matches are found
11
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

within Aj, then DP-Ver.1 returns two sets of potential senders,
one for the unicasts (matchUni) and the other for broadcasts
(matchBro). Otherwise, it returns empty sets, which means
that node j is not the intended recipient of the message or
the message is not authentic, in which case the node should
discard the message.
•
DP-Ver.2 - Keyed hash value veriﬁcation (no message
loss): Used to verify the keyed hash value where there are no
lost messages (i.e., the received explicit counter = the explicit
counter maintained in the receiver’s pseudonym table). If either
of the two sets, matchUni or matchBro is not empty, then
DP-Ver.2 is used to verify the received keyed hash value Hrec.
To do this, the algorithm veriﬁes the nodes in matchUni ﬁrst
and if the result is negative it continue verifying the nodes in
matchBro. For each ID
′′
i ∈ matchUni, node j retrieves kij
and Ci→j from Tj and checks if si→j = srec. If they are equal,
then node j computes H
′ = Hkij(ID
′′
i ⊕ID
′′
j ⊕Ci→j ⊕rrec)
and checks if H
′ = Hrec. If they are equal, this means that
node j is the intended recipient of the unicast message, the
message is fresh (not replayed), and it is sent by node i. Node
j then increments Ci→j, updates Tj with this incremented
value and terminates the algorithm returning the operational
pseudonym of the sender ID
′′
i , the type of the message (i.e.,
unicast) and the pairwise key. If the two keyed hash values are
not equal, the execution of the algorithm continues by verifying
the ID
′′s in matchBro. The veriﬁcation here is similar to
that for matchUni. If this veriﬁcation is negative, then node
j proceeds to execute DP-Ver.3.
•
DP-Ver.3 - Keyed hash value veriﬁcation (with message
loss): Used to verify the keyed hash value where there are
lost messages (i.e., the received explicit counter ̸= the explicit
counter maintained in the receiver’s pseudonym table). The
maximum number of lost messages that can be tolerated
equals to a threshold value, ST . The algorithm starts with
verifying the nodes belonging to matchUni. First, it retrieves
kij and Ci→j from Tj for each ID
′′
i ∈ matchUni, computes
SD = |si→j −srec| and checks if SD < ST . If true, then node
j increases Ci→j based on SD value, i.e., temporarily creates a
new counter CT emp = Ci→j+SD and uses CT emp to compute
H
′ = Hkij(ID
′′
i ⊕ ID
′′
j ⊕ CT emp ⊕ rrec). Then, it checks if
H
′ = Hrec. If they are equal, node j conﬁrms that it is the
intended recipient of the unicast message. It increases Ci→j
based on the computed number of lost messages and updates
Tj with this value, thus, synchronising the counter value with
the sender. Then, node j terminates the algorithm returning
the operational pseudonym of the sender ID
′′, the type of the
message (i.e., unicast) and the pairwise key. If H
′ ̸= Hrec,
then, node j continues verifying if the sender is one of the
ID
′′s in matchBro. If the outcome of this veriﬁcation is
negative, then node j discards the message.
B. Anonymous Communication Protocols
There are three communication protocols in ID-APS:
anonymous one-hop unicast (AOHU), anonymous multi-hop
unicast (AMHU) and anonymous local broadcast (ALBR).
(a) Anonymous one-hop unicast (AOHU)
This protocol consists of AOHU-Send and AOHU-Receive
procedures. A node i sends data to its one-hop neighbour,
node j, by executing AOHU-Send, for which node i generates
a pairwise pseudonym IDi→j, encrypts the data using kij,
generates a MAC of the pseudonym and the encrypted data,
and constructs a message mi→j = IDi→j ∥ Payloadi→j ∥
MACi→j where Payloadi→j is the encrypted data. Then,
node i sends mi→j to node j. Node j executes AOHU-Receive
to receives mi→j, for which it veriﬁes the pseudonym using
DP-Ver to ﬁnd the source of the message, veriﬁes the MAC
and decrypts the payload using kij.
(b) Anonymous multi-hop unicast (AMHU)
This protocol is built on AOHU. It consists of AMHU-
Send, AMHU-Forward and AMHU-Receive procedures. When
node i is to send data using a unicast to the BS multi-hops
away (e.g., through an intermediate node j), node i executes
AMHU-Send for which it generates an end-to-end pairwise
pseudonym IDi→B, encrypts the data using kBi and generates
a MAC of the pseudonym and the encrypted data. Next, node
i constructs a message mi→B = IDi→B ∥ Payloadi→B ∥
MACi→B. As the BS is not a direct neighbour of node i, node
i checks its routing table for the next hop (i.e., node j) in the
route to the BS. Next, node i uses the AOHU-Send procedure
to send a unicast, which wraps mi→B to the one-hop neighbour
j. Upon receiving the one-hop unicast message from node i,
node j executes AMHU-Forward to forward node i’s message
to the BS. First, it retrieves mi→B using the AOHU-Receive
procedure. Then, it checks its routing table for the next hop
(i.e., the BS). After that, it uses the AOHU-Send procedure to
forward node i’s message to the BS. When the BS receives the
one-hop unicast from node j, the BS executes AMHU-Receive
procedure to retrieve the data sent by node i. This is done by
executing AOHI-Receive ﬁrst to retrieve mi→B. After that, the
BS veriﬁes IDi→B using DP-Ver to ﬁnd the original source of
the message. Then, it veriﬁes the received MAC and decrypts
the payload using kBi to retrieve the data sent by node i.
(c) Anonymous local broadcast (ALBR)
This protocol consists of ALBR-Send and ALBR-Receive
procedures. When node i is to send a broadcast to its one-
hop neighbours, it executes the ALBR-Send procedure. In this
procedure, node i ﬁrst reads the respective broadcast key from
its memory, depending on whether it is broadcasting within
the cluster or outside it. Then, node i generates the broadcast
pseudonym IDi→∗, encrypts the data and generates a MAC of
the pseudonym and the encrypted data. Next, node i broadcasts
the message mi→∗ = IDi→∗ ∥ Payloadi→∗ ∥ MACi→∗
to the neighbours. Upon receiving the broadcast by a neigh-
bouring node j, node j executes ALBR-Receive for which it
veriﬁes the pseudonym using DP-Ver to ﬁnd the source of
the broadcast, veriﬁes the MAC and decrypts the payload to
retrieve the data sent by node i.
C. ID-APS in Action
There
are
three
phases
in
ID-APS:
sensor
node
initialization, network initialization and network operation.
(a) Sensor Node Initialization
Prior to deployment of the network, each sensor node is
initialized with speciﬁc parameter values and functions. For
each node i ∈ N, the BS generates the following parameter
values: IDi, ID
′
i, β, kN, kBi, indB→i, indi→B, indB→∗,
CB→i, Ci→B and CB→∗. The indexes and starting counter
values are picked at random for each node. The installed
12
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

functions are two keyed hash functions, HID
K (.), Hk(.) and
a pseudorandom function.
(b) Network Initialization
In this phase, nodes discover their neighbours, establish
pairwise and broadcast keys and perform clustering, preparing
for normal network operation. In the node discovery and key
establishment phase, the nodes use EDDK methods to discover
their neighbours, and establish broadcast and pairwise keys.
In this process, the nodes identify their neighbours using the
initial ﬁxed pseudonyms and populates a pseudonym table
that includes the initial ﬁxed pseudonym and the established
keys for each neighbour. The nodes also pick the indexes
(indi→∗, indi→j) and starting counter values (Ci→∗, Ci→j) at
random and exchange these values with their neighbours. Then,
each node generates an operational pseudonym for itself and
for each neighbour in the node’s pseudonym table and deletes
the initial pseudonyms. By the end of this process, each node
should have updated its pseudonym table and be ready for the
clustering process to be performed. During clustering, nodes
organise themselves into clusters and elect CHs. To ensure
that the clustering process is done in a secure and anonymous
way, we utilise the Private Cluster Head Election (PCHE) [9]
protocol. This protocol is designed to hide the identities of the
CHs from an adversary who can monitor the clustering process.
To further increase the protection level of the ID anonymity,
we use our ALBR protocol for all broadcast messages involved
in the PCHE. Upon completion of clustering, each node should
know if it is a CH or a cluster member. After that, the elected
CH in each cluster generates a cluster broadcast key and picks
a cluster broadcast counter at random and unicasts both values
to each member in its cluster. It is worth noting that the elected
CHs will also need to establish their routes to the BS. ID-APS
is independent of the routing mechanism; however, ID-APS
requires that each CH uses the dynamic pseudonyms when
sending the route request and route update messages. Once
clustering is complete and the routes to the BS established,
the nodes are ready to perform normal network operation.
(c) Network Operation
In this phase, the nodes start to carry out their normal
functional operations such as data collection and aggregation.
Cluster member nodes can only communicate with the CH and
other cluster members (intra-cluster communication). Commu-
nication outside the cluster (inter-cluster communication) is
carried out via the CH.
In intra-cluster communication, each node senses the phys-
ical phenomenon at a pre-deﬁned sampling period and sends
its reading to the CH. The CH waits for the readings to be
received from different cluster members before applying an
aggregation function to compute an aggregate value for the
readings. Intra-cluster communication can either be unicast or
broadcast among cluster members as follows:
-
Intra-cluster unicast is carried out using the AOHU pro-
tocol and the pairwise keys to secure the communication.
-
Intra-cluster broadcast is carried out using the ALBR
protocol and the cluster broadcast key to secure the
communication.
In inter-cluster communication, each CH forwards the
locally aggregated data within its cluster to the BS through
other CHs. CHs which are closer to the BS may collect the
aggregated data from other CHs that are further away and
aggregate the received data before sending them to the BS.
The inter-cluster communication encompasses the following:
-
Inter-cluster unicast between a CH and the BS is carried
out using the AOHU protocol if the CH is a direct
neighbour of the BS or the AMHU protocol if the CH
is multi-hops away from the BS. In both protocols the
pairwise keys are used to secure the communication.
-
Inter-cluster unicast among neighboring CHs is carried
out using the AOHU protocol and the pairwise keys to
secure the communication.
-
Inter-cluster broadcast from the BS is done through the
authenticated broadcast protocol µTesla [8].
VII.
ANALYSES AND EVALUATION
The effectiveness and efﬁciency of ID-APS are analysed
based on the parameter values presented in Table III.
TABLE III.
ID-APS EVALUATION PARAMETER VALUES
Sensor mote
CrossBow TelosB [10]
Block cipher
RC5 [11] (CBC mode)
Message authentication
CBC-MAC-RC5
Key length lk
8 bytes
ID length lID
8 bytes
Index length li
1 byte
Counter length (lh + ls)
(3+1) bytes
Pseudonym random number length lr
2 bytes
Pseudonym Hash value length lH
4 bytes
A. ID Anonymity
NIP-1: As described earlier, a single pairwise pseudonym
IDi→j = indi→j ∥ si→j ∥ ri→j ∥ Hi→j is used to identify
both the sender (node i) and the receiver (node j) of a unicast
message, where Hi→j = Hkij(ID
′′
i ⊕ ID
′′
j ⊕ Ci→j ⊕ ri→j).
It is hard for an adversary to gain any identity information
regarding the source or destination of the message from the
hash value. This is because (i) it is computationally hard to
reverse the hash value due to the one-way property of the
hash function and (ii) to compute a matching hash value,
the adversary needs to know the pairwise key that was used
in the computation, which is only known by the message
sender and receiver, and in addition, the adversary needs to
guess the correct values of ID
′′
i , ID
′′
j and hi→j to succeed.
The probability of guessing the correct values of all these
parameters is: (1/2lK+2lID+lh = 2−216), which is sufﬁciently
low if the values of lK, lID and lh are sufﬁciently large.
NIP-2: The analysis of NIP-2 follows that of NIP-1. The
hash value in a broadcast is computed as Hi→∗ = Hk∗
i (ID
′′
i ⊕
Ci→∗ ⊕ ri→∗). The probability of guessing the correct values
of k∗
i , ID
′′
i and hi→∗ is (1/2lK+lID+lh = 2−158).
NIP-3: For a neighbourhood of n nodes where an active
adversary is present, we analyse the impact on ID anonymity
when the adversary compromises m nodes where m ≤ n − 3.
Let us consider the worst case scenario when the adversary
compromises all the nodes except three nodes a, b and c
(i.e., there are n − 3 colluding nodes). The adversary may
learn ID
′′
a, ID
′′
b and ID
′′
c assuming that each of the non-
compromised nodes lies in the transmission range of at least
one compromised node. When node b for example sends a
13
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

unicast to node c, node b constructs the dynamic pseudonym
as IDb→c = indb→c ∥ sb→c ∥ rb→c ∥ Hb→c where,
Hb→c = Hkbc(ID
′′
b ⊕ ID
′′
c ⊕ Cb→c ⊕ rb→c). The additional
information available to the adversary through overhearing the
message is sb→c and rb→c. However, the adversary does not
know kbc and hb→c which are only known to nodes b and
c. Therefore, from the adversary’s point of view, each of the
three non-compromised nodes has equal probability to be the
sender or receiver of the message. To learn the exact sender
or receiver of the message, the adversary needs to guess the
values of kbc and hb→c and apply the keyed hash function to
get the correct Hb→c. The probability to get the correct hash
value is 1/2lK+lh = 2−88.
NIP-4: ID-APS uses a random number, r, to break the link
between different pseudonyms used by the same node for the
same destination. If a node i is compromised, the adversary
may obtain all the necessary items (i.e., crypto keys, indexes,
operational ﬁxed pseudonyms and counters) to compute node
i’s pseudonyms. Let us denote the current pseudonym of node
i in its unicast communication to node j as IDm
i→j. If IDm
i→j
is compromised, then to learn the pseudonym used in the
previous unicast message to node j, i.e., IDm−1
i→j , the adversary
has to decrement the current counter value and guess the
random number used in the previous message. As the length
of ri→j is lr bits, the probability of guessing the correct
random number used by the node in the previous message
is 1/2lr = 2−16. If higher anonymity is required, the length
of ri→j can be set to a higher value.
B. Degree of anonymity vs. computational costs analysis
The anonymity level of ID-APS is analysed and quantiﬁed
based on the concept of degree of anonymity [12]. The entropy
of a system is calculated after the attack and compared with the
maximum entropy of the system. This provides a measure of
information gained by the adversary after the attack. Assuming
a WSN with a total number of N nodes distributed uniformly
in a ﬁeld, if an eavesdropping adversary is present while a mes-
sage is being sent, then the only ﬁxed part of the pseudonym
that the adversary can identify a sender by is the index value.
However, this index value may also be used by several other
nodes while sending messages to their neighbours. As the
index values are picked at random, the probability of a node i
picking a certain index (inda) to identify itself as a sender to
one of its neighbours is 1/2li. Let the average size of |Ni| = n,
then the node will pick n indexes at random to identify itself
in unicast communications and another index for broadcast
communications. As broadcasts and unicasts messages have
similar structure, the total probability, Pinda, of a node using
index inda to identify itself in any message sent by the node
is given by (1).
Pinda = 1 −
2li − 1
2li
n+1
(1)
This also implies that approximately NPinda nodes in
the network will be using inda to identify themselves when
communicating with other nodes (assuming large network).
Through continuous monitoring of the index values appended
to messages exchanged in the network, the adversary may
assign certain probability to each node as being the sender
of an eavesdropped message. Let X be the discrete random
variable with probability mass function Pi = P(X = i), where
i represents a single sender in a set of potential senders, N. Let
us assume that, in the worst case scenario, the adversary is able
to identify all the nodes that are using inda as identiﬁer. So,
the adversary assigns a probability of (1/NPinda) to NPinda
nodes as being the senders of a message that has an index
value = inda and a probability of 0 to the rest of the nodes
in the network. The probability Pi is given by (2).
Pi =
(
1
NPinda
for NPinda nodes
0
for N (1 − Pinda) nodes
(2)
From [12], the entropy of the system after the attack is
computed as E(X) = − PN
i=1 Pilog2(Pi), hence:
E(X) = log2
  
1 −
2li − 1
2li
n+1!
N
!
(3)
The maximum entropy of the system EM is achieved when
the adversary assigns a probability Pi = 1/N to each node in
the network as being the sender of a message, i.e., EM =
log2(N). Hence, the degree of anonymity d is estimated as:
d = E(X)
EM
=
log2

1 −

2li−1
2li
n+1
N

log2(N)
(4)
We see that the degree of anonymity depends on three
parameters N, n and li. As N and n are ﬁxed values, then the
only parameter that can affect the anonymity of the nodes is
li. Figure 3 shows the impact of li for a WSN with N = 1000
and n = 100. It is clear from the ﬁgure that as li increases, the
degree of anonymity decreases. According to [12], to achieve
an acceptable level of anonymity, the degree of anonymity
should be greater than 0.8. Therefore, li should be selected as
(≤ 8 bits) in the above example.
0
5
10
15
20
0
0.2
0.4
0.6
0.8
1
Length of the index value in bits
Source degree of anonymity
Figure 3.
The impact of the length of the index value on the source degree
of anonymity for N=1000 and n=100.
Let us now analyse the computational costs of receiving a
message. Depending on the number of matches of the received
pseudonym with those contained in a receiver’s pseudonym
table, the receiver may need to execute more than one keyed
hash operation before successfully conﬁrming the validity of
the pseudonym. Suppose that each node i has an average size
of |Ai| = m. The value of m is directly proportional to the
size of the cluster. The pseudonym table of node i, Ti, includes
an inbound unicast index and a broadcast index for each node
in Ti. Therefore, when node i receives a message, it has to
14
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

ﬁnd a match within (2m) indexes in Ti. As described earlier,
the inbound unicast indexes and broadcast indexes are picked
at random during the node discovery and key establishment
phase. Based on this, there is a probability that more than one
index in Ti could match the index of the received dynamic
pseudonym. The probability of getting exactly r indexes in Ti
that matches the index of a received pseudonym (indrec) is
given by (5).
Pmatch(r) =
2m
r

(Pind)r(1 − Pind)2m−r
(5)
Figure 4 shows the probability Pmatch(r) against different
r values for m = 100 nodes and li = 8 bits. It can be seen from
the ﬁgure that the probability beyond 3 matches is very low.
In other words, in 99% of the cases, the pseudonym matches
occurs in less than 3 matches. Therefore, in 99% of the cases,
the veriﬁcation of a pseudonym involves less than 3 keyed
hash operations.
0
2
4
6
8
10
0
0.2
0.4
0.6
0.8
1
Number of matching indexes (r)
Probability of getting (r) matches
Figure 4.
The probability of getting exactly r indexes in Ti that matches
indrec for m = 100 and li = 8.
This computational cost may be further reduced by tuning
the parameter values in (5) as follows:
-
Reduce the size of the cluster and therefore the value of
m drops: This will result in a reduction in the list of
potential indexes. Figure 5 depicts the three cases where
m = 100, 50 and 10 nodes, respectively. As can be seen,
reducing the cluster size from 100 to 10 nodes reduces
the likelihood of matching indexes from 3 to 1 in 99%
of the cases.
-
Increase the size of the index: Figure 6 shows the
probability of getting r matches when li is set to 8, 10 and
12, respectively, where m = 100. As shown in the ﬁgure,
the probability Pmatch(r) drops when li increases from
8 to 12 bits. For li = 12, the receiver need to compute
less than 2 hash values in 99% of the time.
From the above we can see that by reducing the cluster size
and/or increasing the bit length of the index, we may reduce
the computational costs incurred as a result of anonymity pro-
tection. However, increasing the bit length of the index reduces
the degree of anonymity as illustrated by (4). Therefore, for
an acceptable level of anonymity, we may cut computational
costs by reducing the size of a cluster.
C. Performance Evaluation
In this section, the performance of ID-APS is evaluated in
terms of computation, communication and memory consump-
tion and compared to the performance of CAS and EAC.
0
2
4
6
8
10
0
0.2
0.4
0.6
0.8
1
Number of matching indexes (r)
Probability of getting (r) matches
 ← m=100
 ← m=50
 ← m=10
 
 
m=100
m=50
m=10
Figure 5.
The probability of getting exactly r indexes in Ti that matches
indrec for li = 8 and different m values.
0
1
2
3
4
5
0
0.2
0.4
0.6
0.8
1
Number of matching indexes (r)
Probability of getting (r) matches
 ← li=8
 ← li=10
 ← li=12
 
 
li=8
li=10
li=12
Figure 6.
The probability of getting exactly r indexes in Ti that matches
indrec for different li values and m = 100.
MOC-1: In ID-APS, each message construction prior to
transmission involves the following computational costs: one
random number generation, one dynamic pseudonym gen-
eration using keyed hash function, one payload encryption
and one MAC generation protecting the pseudonym and the
encrypted payload using a keyed hash function. Based on
the experiments with RC5 execution time for TelosB motes
[13], constructing a message in ID-APS with a maximum
payload size of 29 bytes, as suggested by TinyOS [14], takes
less than 20 ms. According to [8], sensor nodes support
a maximum throughput of twenty 30-bytes messages/s with
the microcontroller being idle for about 50% of the time.
Therefore, our scheme is able to anonymize the node IDs,
encrypt and generate a MAC for every message sent by the
sensor node. The computational costs of receiving the message
at the receiver side are comparable to that of the sender.
Table IV shows a comparison of computational costs with CAS
and EAC.
TABLE IV.
COMPUTATIONAL COSTS COMPARISON
Scheme
Sender
Receiver
Other
neighbours
CAS
One keyed hashing
operation
One keyed hashing
operation
One keyed
hashing operation
EAC
Two hashing operations
One hash operation
-
ID-APS
One random number
generation and one
keyed hashing operation
One keyed hashing
operation
-
As can be seen from Table IV, the computational costs of
ID-APS are comparable to that of EAC and better than CAS.
15
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

This is because with the optimization of li and cluster size in
ID-APS, there are negligible computational costs involved by
other nodes in the neighbourhood.
MOC-2: A pseudonym in ID-APS is 8 bytes in size and
it is used to identify both the sender and the receiver of a
message. Table V shows the comparison between the three
schemes in terms of message overheads. It can be seen that
ID-APS exhibits the least communication costs in comparison
with the CAS and EAC schemes. EAC has the highest message
overheads as the receiver in EAC is required to send an
acknowledgment to the sender to synchronise the pseudonym
parameters.
TABLE V.
MESSAGE OVERHEADS COMPARISON
Scheme
Sender
Receiver
Total
CAS
18-byte (ID+Index+Seq)
-
18-byte
EAC
32-byte (2 IDs)
20-byte (Ack)
52-byte
ID-APS
8-byte (ID)
-
8-byte
MOC-3: The memory requirements for the parameters
used in ID-APS are shown in Table VI in comparison with
CAS and EAC. In this table, n denotes the size of the node
neighbourhood. Figure 7 shows a comparison of memory
consumption between the three schemes for different n sizes.
TABLE VI.
MEMORY CONSUMPTION COMPARISON
Scheme
Parameters
Memory consumption
(byte)
CAS
Key size K = 8 bytes
Other parameters size P = 8 bytes
Index size I = 2 bytes
Sequence number size S = 8 bytes
2K + 3P + S +
n(2K + 2I + 3P + 2S)
EAC
Pseudonym size ID = 16 bytes
Key size K = 16 bytes
Other parameters size P = 16 bytes
Link direction size L = 0.25 byte
3ID + 2K + 2P +
n(3ID + 2K + 2P + L)
ID-APS
ID/pseudonym size ID = 8 bytes
Key size K = 8 bytes
Index size I = 1 byte
Counter size C = 4 bytes
3ID + 4K + 4I + 5C +
n(ID + 3K + 3I + 4C)
20
50
100
0
2
4
6
8
10
12
Number of neighbouring nodes (n)
Memory size (KB)
 
 
CAS
EAC
ID−APS
Figure 7.
Comparison of memory consumption for different n values.
There are two observations from Figure 7. The ﬁrst is that
the memory requirements of ID-APS can be easily accom-
modated in the sensor memory. This is because TelosB mote
has an architecture where the entire memory (48KB of ﬂash
memory, 10KB of RAM and 1MB of external EEPROM) is
accessible for code and data. The second observation is that
ID-APS consumes least memory space compared to the other
two schemes.
VIII.
CONCLUSION AND FUTURE WORK
This paper has presented the design and evaluation of a
novel ID anonymity scheme, ID-APS. The scheme is designed
to achieve a high level of ID anonymity with as less overhead
costs as possible in terms of computation, communication
and memory space. ID-APS provides ID anonymity in unicast
and broadcast communication against passive adversaries and
against attacks on past used pseudonyms by active adversaries.
Theoretical evaluation of the anonymity level provided by the
scheme has been carried out using the concept of the degree
of anonymity, and the scheme has also been compared with
two most relevant schemes in literature. The evaluation and
comparison results have shown that ID-APS achieves a good
level of ID anonymity protection with least level of overhead
costs in comparison with related solutions. However, with ID-
APS, if a node is compromised, the adversary may be able
to impersonate the node and compromise the privacy of other
nodes. Our future work will examine this issue in depth.
REFERENCES
[1]
X. Luo, X. Ji, and M.-S. Park, “Location privacy against trafﬁc
analysis attacks in wireless sensor networks,” in Information Science
and Applications (ICISA), 2010 International Conference on.
IEEE,
2010, pp. 1–6.
[2]
S. Misra and G. Xue, “Efﬁcient anonymity schemes for clustered
wireless sensor networks,” International Journal of Sensor Networks,
vol. 1, no. 1, 2006, pp. 50–63.
[3]
Y. Ouyang et al., “Providing anonymity in wireless sensor networks,”
in Pervasive Services, IEEE International Conference on.
IEEE, 2007,
pp. 145–148.
[4]
J.-P. Sheu, J.-R. Jiang, and C. Tu, “Anonymous path routing in wireless
sensor networks,” in Communications, 2008. ICC’08. IEEE Interna-
tional Conference on.
IEEE, 2008, pp. 2728–2734.
[5]
J. Chen, X. Du, and B. Fang, “An efﬁcient anonymous communication
protocol for wireless sensor networks,” Wireless Communications and
Mobile Computing, vol. 12, no. 14, 2012, pp. 1302–1312.
[6]
M. Gouda, Y.-r. Choi, and A. Arora, “Antireplay protocols for sensor
networks,” Handbook on Theoretical and Algorithmic Aspects of Sen-
sor, Ad Hoc Wireless, and Peer-to-Peer Networks,(ed. Jie Wu), CRC,
2005.
[7]
X. Zhang, J. He, and Q. Wei, “Eddk: energy-efﬁcient distributed
deterministic key management for wireless sensor networks,” EURASIP
Journal on Wireless Communications and Networking, vol. 2011, 2011,
p. 12.
[8]
A. Perrig, R. Szewczyk, J. Tygar, V. Wen, and D. E. Culler, “Spins:
Security protocols for sensor networks,” Wireless networks, vol. 8,
no. 5, 2002, pp. 521–534.
[9]
L. Butty´an and T. Holczer, “Private cluster head election in wireless sen-
sor networks,” in Mobile Adhoc and Sensor Systems, 2009. MASS’09.
IEEE 6th International Conference on.
IEEE, 2009, pp. 1048–1053.
[10]
Crossbow,
“Telosb
datasheet,”
April
2014.
[Online].
Available:
http://www.willow.co.uk/TelosB Datasheet.pdf
[11]
R. L. Rivest, “The rc5 encryption algorithm,” in Fast Software Encryp-
tion.
Springer, 1995, pp. 86–96.
[12]
C. Diaz, S. Seys, J. Claessens, and B. Preneel, “Towards measuring
anonymity,” in Privacy Enhancing Technologies.
Springer, 2003, pp.
54–68.
[13]
D. He et al., “An enhanced public key infrastructure to secure smart grid
wireless communication networks,” IEEE NETWORK, vol. 28, no. 1,
2014, pp. 10–16.
[14]
P. Levis et al., “Tinyos: An operating system for sensor networks,” in
Ambient intelligence.
Springer, 2005, pp. 115–148.
16
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-374-2
SENSORCOMM 2014 : The Eighth International Conference on Sensor Technologies and Applications

