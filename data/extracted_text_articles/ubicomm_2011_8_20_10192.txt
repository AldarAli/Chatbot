Fault Tolerant Execution of Transactional Composite Web Services: An Approach
Yudith Cardinale
Departamento de Computaci´on y Tecnolog´ıa de la Informaci´on
Universidad Sim´on Bol´ıvar
Caracas, Venezuela
Email: yudith@ldc.usb.ve
Marta Rukoz
LAMSADE, Universit´e Paris Dauphine
Universit´e Paris Ouest Nanterre La D´efense
Paris, France
Email: marta.rukoz@lamsade.dauphine.fr
Abstract—We propose an approach for efﬁcient, fault toler-
ant, and correct distributed execution of Transactional Com-
posite Web Services (TCWSS), based on Colored Petri-Net
(CPN) formalism. We extend a previous COMPOSER in order it
generates, besides a TCWS represented by a CPN, another CPN
representing the compensation order for backward recovery.
We present an EXECUTER, which ensures correct execution
ﬂow and backward recovery by following unfolding processes
of the CPNs. We present the formalization and algorithms of
the TCWS execution and compensation processes.
Keywords-Transactional Composite Web Services; Fault Toler-
ant Execution; Compensation; Backward Recovery.
I. INTRODUCTION
With the advent of Web 3.0, machines should contribute
to users needs, by searching for, organizing, and presenting
information from the Web which means, user can be fully
automated on the Internet. One of the major goals of
Web 3.0 is to make automatic and transparent to users the
Web Service (WS) selection and composition to form more
complex services. This process (executed by a COMPOSER)
is normally based on functional requirements (i.e., the set
of input attributes bounded in the query, and the set of
attributes that will be returned as output), QoS criteria (e.g.,
response time and price), and transactional properties (e.g.,
compensable or not), producing Transactional Composite
WSS (TCWSS). A TCWS is formed by many WSS and
we call these WSS as components of the TCWS (WSS
component). A TCWS should satisfy functional and trans-
actional properties required by the user [1], [2], and it can
be represented in a structure such as graph or Petri-Nets
indicating the control ﬂow and the WSS execution order.
In [2], we present such a COMPOSER. A brief description
of this COMPOSER is presented in section III.
The contribution of this paper is focussed in two as-
pects. First, we extend our previous COMPOSER in order
it automatically generates, besides the TCWS, another CPN
representing the compensation order for a backward recov-
ery process. Second, we specify an approach for efﬁcient
fault tolerant execution of TCWS; this approach is imple-
mented in an EXECUTER. In the EXECUTER approach, the
deployment of a TCWS will be carried on by following
unfolding algorithms of CPNs representing the TCWS and
its corresponding compensation ﬂow in case of failures. The
EXECUTER approach provides a correct and fault tolerant
execution of TCWSS by: (i) ensuring that sequential and
parallel WSS will be executed according the execution ﬂow
depicted by the TCWS; and (ii) in case of failures, leaving
the system in a consistent state by executing a backward
recovery with the CPN representing the compensation pro-
cess. We formalize the TCWS execution problem and the
backward recovery based on CPN properties. We also present
the execution and compensation algorithms.
II. WSS TRANSACTIONAL PROPERTIES
A transactional property of a WS allows to recover the
system in case of failures during the execution. In the related
literature (see survey [3]), the most used WS transactional
properties are the following. Let s be a WS: s is pivot (p),
if once s successfully completes, its effects remain forever
and cannot be semantically undone, if it fails, it has no
effect at all; s is compensatable (c), if it exists another
WS, s′, which can semantically undo the execution of s; s is
retriable (r), if s guarantees a successfully termination after
a ﬁnite number of invocations; the retriable property can be
combined with properties p and c deﬁning pivot retriable
(pr) and compensatable retriable (cr) WSS.
The Transactional Property (T P) of a Composite WS
(CWS) can be derived from the properties of its WSS
component and from their execution order (sequential or
parallel). El Haddad et al. [4] extended the previous de-
scribed transactional properties and adapted them to CWSS
in order to deﬁne TCWSS as follows. Let cs be a TCWS:
cs is atomic (⃗a), if once all its WSS component complete
successfully, their effect remains forever and cannot be
semantically undone, if one WS does not complete suc-
cessfully, all previously successful WSS component have
to be compensated; cs is compensatable (c), if all its WSS
component are compensatable; cs is retriable (r), if all its
WSS component are retriable; the retriable property can be
combined with properties ⃗a and c deﬁning atomic retriable
(⃗ar) and compensatable retriable (cr) TCWSS.
According to these deﬁnitions, a TCWS must be con-
structed in such a way that if, at run-time, one of its WS
component fails, then either it is retriable and can be invoked
again until success or a backward recovery is possible (i.e.,
158
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

all successfully executed WSS have to be compensated).
III. FAULT-TOLERANT TCWS COMPOSER
This section brieﬂy describes our COMPOSER [2] and the
proposed extension in order to consider backward recov-
ery. We formalize the WS composition problem by using
Colored Petri-Nets (CPN), where WS inputs and outputs
are represented by places and WSS with their transactional
properties are represented by colored transitions.
A user query Q is deﬁned in terms of functional conditions
expressed as input (IQ) and output (OQ) attributes belong-
ing to an ontology, QoS constraints expressed as weights
over criteria, and the required global transactional property
expressed as, T1 if T P of TCWS is in {⃗a,⃗ar} or T0 if T P
of TCWS is in {c, cr}. More formally:
Deﬁnition 1: Query. Let OntoA be the integrated ontology
(many ontologies could be used and integrated). A Query Q is a
4-tuple (IQ, OQ, WQ, TQ), where IQ = {i | i ∈ OntoA is an
input attribute}, VQ = { (i, Op, vi) | i ∈ IQ, Op is an operator
(Op ∈ {=, ∈}), and vi is a value whose domain depends on i
}, OQ = {o | o ∈ OntoA is an output attribute whose value
has to be produced by the system}, WQ = {(wi, qi) | wi ∈
[0, 1] with P
i wi = 1 and qi is a QoS criterion}, and TQ is
the required transactional property: TQ ∈ {T0, T1}. If TQ = T0,
the system guarantees that a semantic recovery can be done by the
user. If TQ = T1, the system does not guarantee the result can
be compensated. In both cases, if the execution is not successful,
no result is reﬂected to the system, i.e., nothing is changed on the
system.
The WSS Registry is represented by a Web Service
Dependence Net (W SDN) modeled as a CPN containing
all possible interactions among WSS. More formally.
Deﬁnition 2: WSDN. A WSDN is a 4-tuple (A, S, F, ξ),
where:
• A is a ﬁnite non-empty set of places, corresponding to
input and output attributes of the WSS in the registry
such that A ⊂ OntoA;
• S is a ﬁnite set of transitions corresponding to the set
of WSS in the registry;
• F : (A × S) ∪ (S × A) → {0, 1} is a ﬂow relation
indicating the presence (1) or the absence (0) of arcs be-
tween places and transitions deﬁned as follows: ∀s ∈ S,
(∃a ∈ A | F(a, s) = 1) ⇔ (a is an input place of s) and
∀s ∈ S, (∃a ∈ A | F(s, a) = 1) ⇔ (a is an output place
of s);
• ξ is a color function such that ξ : CA ∪ CS with:
CA : A → ΣA, is a color function such that ΣA =
{I,⃗a,⃗ar, c, cr} representing, for a ∈ A, either the T P
of the CWS that can produce it or the user input
(I), and CS : S → ΣS, is a color function such that
ΣS = {p, pr,⃗a,⃗ar, c, cr} representing the T P of s ∈ S.
The WS composition problem is solved by a Petri-Net
unfolding algorithm which embeds the QoS-driven selection
within the transactional service selection. To start the COM-
POSER unfolding algorithm, the W SDN is marked with to-
kens on places representing the input attributes (these marks
represent the initial marking). At the end, the unfolding
algorithm will deﬁne the CPN representing the composition
that satisﬁes the Query. The transactional property of the
resulting CWS is derived from the transactional properties of
its WSS component and the structure of the CPN. Thus, the
result of the composition process is a CPN corresponding to
a TCWS whose WSS component locally maximize the QoS
and globally satisfy the required functional and transactional
properties. Formally, we say:
Deﬁnition 3: CPN-T CW SQ. A CPN-T CW SQ is a 4-tuple
(A, S, F, ξ), where:
• A is a ﬁnite non-empty set of places, corresponding to input
and output attributes of WSS in the TCWS such that A ⊂
OntoA;
• S is a ﬁnite set of transitions corresponding to the set of WSS
in the TCWS;
• F
: (A × S) ∪ (S × A) → {0, 1} is a ﬂow relation
indicating the presence (1) or the absence (0) of arcs between
places and transitions deﬁned as follows: ∀s ∈ S, (∃a ∈ A
| F(a, s) = 1) ⇔ (a is an input place of s) and ∀s ∈ S,
(∃a ∈ A | F(s, a) = 1) ⇔ (a is an output place of
s); this relation establishes the input and output execution
dependencies among WSS component.
• ξ is a color function such that ξ: S → ΣS and ΣS =
{p, pr,⃗a,⃗ar, c, cr} represents the T P of s ∈ S (T P(s)).
For modeling TCWS backward recovery, our COMPOSER
can be easily extended in order it can generate a backward
CPN , that we called BRCPN-T CW SQ, associated to a CPN-
T CW SQ as follows:
Deﬁnition 4: BRCPN-T CW SQ. A BRCPN-T CW SQ, as-
sociated to a given CPN-T CW SQ=(A, S, F, ξ), is a 4-tuple
(A′, S′, F −1, ζ), where:
• A′ is a ﬁnite set of places corresponding to the CPN-
T CW SQ places such that: ∀a′ ∈ A′ ∃a ∈ A associated
to a′ and a′ has the same semantic of a.
• S′ is a ﬁnite set of transitions corresponding to the set of
compensation WSS in CPN-T CW SQ such that: ∀s ∈ S,
T P(s) ∈ {c, cr}, ∃s′ ∈ S′ which compensate s.
• F −1 : (A × S) ∪ (S × A) → {0, 1} is a ﬂow relation es-
tablishing the restoring order in a backward recovery deﬁned
as: ∀s′ ∈ S′ associated to s ∈ S, ∃a′ ∈ A′ associated to
a ∈ A | F −1(a′, s′) = 1 ⇔ F(s, a) = 1 and ∀s′ ∈ S′,
∃a′ ∈ A′ | F −1(s′, a′) = 1 ⇔ F(a, s) = 1.
• ζ is a color function such that ζ : S′ → Σ′
S and Σ′
S =
{I, R, E, C, A} represents the execution state of s ∈ S
associated to s′ ∈ S′ (I: initial, R: running, E: executed,
C: compensate, and A: abandoned).
The marking of a CPN-T CW SQ or BRCPN-T CW SQ
represents the current values of attributes that can be used
for some WSS component to be executed or control values
indicating the compensation ﬂow, respectively. A Marked
CPN denotes which transitions can be ﬁred.
Deﬁnition 5: Marked CPN. A marked CPN=(A, S, F, ξ) is a
pair (CPN,M), where M is a function which assigns tokens (values)
to places such that ∀a ∈ A, M(a) ∈ N.
According to CPN notation, we have that for each x ∈
(A∪S) of a CPN, (•x) = {y ∈ A∪S : F(y, x) = 1} is the set of
its predecessors, and (x•) = {y ∈ A ∪ S : F(x, y) = 1} is the
set of its successors. Now we can deﬁne ﬁreable transitions.
159
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Deﬁnition 6: Fireable CPN transition. A marking M en-
ables a transition s iff all its input places contain tokens such that
∀x ∈ (•s), ∧ M(x) ≥ card(•x).
Note that a transition is actually ﬁreable if on each input
place there are as many tokens as predecessor transitions
produce them. This condition and the fact CPN-T CW S is
acyclic, guaranty that a transition is ﬁreable only if all its
predecessor transitions have been ﬁred. Then, sequential
WSS execution is controlled by input and output depen-
dencies. If several transitions are ﬁreable, all of them are
ﬁred (i.e., the corresponding WSS are executed in paral-
lel). Hence, the sequential or parallel execution condition
affecting the global T P is ensured. Figure 1 illustrates this
deﬁnition. Note that ws3 needs two tokens in a3 to be
invoked; this data ﬂow dependency indicates that it has to be
executed in sequential order with ws1 and ws2, and can be
executed in parallel with ws4. Note that if ws2 and ws3 were
executed in parallel, it could be possible that ws3 ﬁnishes
successful and ws2 fails; in this case, the system can not be
recovery because T P(ws3) = pr do not allow compensation.
Figure 1.
Example of Fireable Transitions
In the BRCPN-T CW S, a transition color represents the
execution state of its corresponding compensable WS. A
compensation transition can be ﬁred only if the correspond-
ing WS is not being abandoned or compensated (Def. 7).
Deﬁnition 7: Fireable compensation transition. A marking
M enables a transition s′ iff all its input places contain tokens
such that ∀a′ ∈ (•s′), M(a′) ̸= 0 ∧ ζ(s′) ̸∈ {A, C}.
IV. EXECUTER: FAULT-TOLERANT EXECUTION
CONTROL
Once a CPN-T CW SQ and its corresponding BRCPN-
T CW SQ are generated by the COMPOSER, an EXECUTER
has to deploy the execution of the TCWS. The execution
control of a TCWS is guided by a unfolding algorithm
of its corresponding CPN-T CW SQ. To support backward
recovery, it is necessary to keep the trace of the execution
on the BRCPN-T CW SQ. To start the unfolding algorithm,
the CPN-T CW SQ is marked with the Initial Marking: an
initial token is added to places representing inputs of Q
(∀a ∈ (A ∩ IQ),M(a) = 1, ∀a ∈ (A − IQ), M(a) = 0) and the
state of all transitions in BRCPN-T CW SQ is set to initial
(∀s′ ∈ S′, ζ(s′) ← I). The ﬁring of a transition in CPN-
T CW SQ corresponds to the execution of a WS (or CWS),
let say s, which participates in the composition. While a
compensatable s is executing, the state of its corresponding
s′ in BRCPN-T CW SQ is set to running (ζ(s′) ← R). Then,
when s ﬁnishes, it is considered that the transition was
ﬁred, others transitions become ﬁreable, the state of its
corresponding s′ is set on executed (ζ(s′) ← E), and the
following ﬁring rules are applied.
Deﬁnition 8: CPN-T CW SQ Firing rules. The ﬁring of a
ﬁreable transition s for a marking M deﬁnes a new marking M ′,
such that: all tokens are deleted from its input places (∀x ∈ •s,
M(x) = 0), if the T P(s) ∈ {c, cr}, the state of its corresponding
s′ in BRCPN-T CW SQ is set to running (ζ(s′) ← R), and the
WS s is invoked. These actions are atomically executed. After
WS s ﬁnishes, tokens are added to its output places (∀x ∈ (s•),
M(x) = M(x) + 1), and the state of its corresponding s′ in
BRCPN-T CW SQ (if it exists) is set to executed (ζ(s′) ← E).
These actions are also atomically executed.
In case of failure of a WS s, depending on the T P(s),
the following actions could be executed:
• if T P(s) is retriable (pr, ⃗ar, cr), s is re-invoked until
it successfully ﬁnish (forward recovery);
• otherwise, a backward recovery is needed, i.e., all
executed WSS must be compensated in the inverse
order they were executed; for parallel executed WSS
the order does not matter.
In order to consider failures, the compensation control of
a CPN-T CW SQ is guided by a unfolding algorithm of its
associated BRCPN-T CW SQ. When a WS represented by a
transition s fails, the unfolding process over CPN-T CW SQ
is halted and a backward recovery is initiated with the
unfolding process over BRCPN-T CW SQ by marking it with
its Initial Marking: a token is added to places representing
inputs of BRCPN-T CW SQ (∀a′ ∈ A′ |
•a′ = ∅, M(a′) = 1),
tokens are added to places representing inputs of s (∀a ∈
•s,
M(a′) = card(•x), and other places has no tokens. Then,
ﬁreable compensation transitions deﬁned in Def. 7 and the
ﬁring rules deﬁned in Def. 9 guide the unfolding process of
BRCPN-T CW SQ.
Deﬁnition 9: BRCPN-T CW SQ Firing rules. The ﬁring of a
ﬁreable transition (see Def. 7) s′ for a marking M deﬁnes a new
marking M ′, such that:
• if ζ(s′) = I, ζ(s′) ← A (i.e., the corresponding s is
abandoned before its execution),
• if ζ(s′) = R, ζ(s′) ← C (in this case s′ is executed after s
ﬁnishes, then s is compensated),
• if ζ(s′) = E, ζ(s′) ← C (in this case s′ is executed, i.e., s
is compensated),
• tokens are deleted from its input places (∀x ∈ •s′, M(x) =
M(x) − 1) and tokens are added to its output places (∀x ∈
(s′•), M(x) = M(x) + 1),
We illustrate a backward recovery in Figure 2. The marked
CPN-T CW SQ depicted in Figure 2(a) is the state when ws4
fails, the unfolding of CPN-T CW SQ is halted, and the initial
marking on the corresponding BRCPN-T CW SQ is set to
start its unfolding process (see Figure 2(b)), after ws′
3 and
ws′
5 are ﬁred and ws7 is abandoned before its invocation, a
new marking is produced (see Figure 2(c)), in which ws′
1 and
160
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

ws′
2 are both ﬁreable and can be invoked in parallel. Note
that only compensatable transitions have their corresponding
compensation transitions in BRCPN-T CW SQ.
Figure 2.
Example of BRCPN-TCW SQ
V. EXECUTER APPROACH
In our approach, the execution of a TCWS is managed
by an EXECUTER, which in turn is a collection of soft-
ware components called EXECUTION ENGINE and ENGINE
THREADS. One ENGINE THREAD is assigned to each WS
in the TCWS. The EXECUTION ENGINE and its ENGINE
THREADS are in charge of initiating, controlling, and moni-
toring the execution, as well as collaborating with its peers to
deploy the TCWS execution. By distributing the responsibil-
ity of executing a TCWS across several ENGINE THREADS,
the logical model of our EXECUTER enables distributed ex-
ecution and it is independent of its implementation; i.e., this
model can be implemented in a distributed memory environ-
ment supported by message passing or in a shared memory
platform. EXECUTION ENGINE and ENGINE THREADS are
placed in different physical nodes from those where actual
WSS are placed. ENGINE THREADS remotely invoke the
actual WSS component. The EXECUTION ENGINE needs
to have access to the WSS Registry, which contains the
WSDL and OWLS documents. The knowledge required at
run-time by each ENGINE THREAD (e.g., WS semantic and
ontological descriptions, WSS predecessors and successors,
and execution ﬂow control) can be directly extracted from
the CPNs in a shared memory implementation or sent by
the EXECUTION ENGINE in a distributed implementation.
Typically, WSS are distinguished in atomic and composite
WSS. An atomic WS is one that solely invokes local oper-
ations that it consists of (e.g., WSDL and OWLS documents
deﬁne atomic WSS as collection of operations together
with abstract descriptions of the data being exchanged).
A composite WS is one that additionally accesses other
WSS or, in particular, invokes operations of other WSS.
Hereby, these additional involved WSS may be provided by
different organizations and were registered in the Registry
as a CWS (e.g., a WS-BPEL document deﬁnes CWSS by
describing interactions between business entities through
WS operations). In our case, we consider that transitions
in the CPN, representing the TCWS to be executed, could
be atomic WSS or CWSS (TCWSS in our case). Atomic
WSS have its corresponding WSDL and OWLS documents.
TCWSS can be encapsulated into an EXECUTER; in this
case the EXECUTION ENGINE has its corresponding WSDL
and OWLS documents. Hence, TCWSS may themselves be-
come a WS, making TCWS execution a recursive operation.
TCWS Execution and Backward Recovery
We present the four phases of the fault tolerant execution
algorithm by pointing out which components of the
EXECUTER are in charge of carrying on which task.
Algorithms 1, 2, and 3 describe in detail all phases.
Initial phase: Whenever an EXECUTION ENGINE receives
a CPN-T CW SQ and its corresponding BRCPN-T CW SQ
(see Def. 3 and Def. 4), it performs the following tasks: (i)
add two dummy transitions to CPN-T CW SQ: wsEEi, the
ﬁrst transition providing the inputs referenced in Q (IQ)
and wsEEf , the last transition consuming the outputs (OQ);
similar dummy transitions are added to BRCPN-T CW SQ
with inverse data ﬂow relation (ws′
EEi and ws′
EEf ); these
transitions are represented by the EXECUTION ENGINE
and have only control responsibilities to start the unfolding
process and know when it is ﬁnished; (ii) mark the CPN-
T CW SQ with the Initial Marking (i.e., add tokens to places
representing the attributes in IQ) and mark all transitions
in BRCPN-T CW SQ in initial state; (iii) start an ENGINE
THREAD responsible for each transition in CPN-T CW SQ,
except by wsEEi and wsEEf , indicating to each one its
predecessor and successor transitions as CPN-T CW SQ
indicates (for BRCPN-T CW SQ the relation is inverse)
and the corresponding WSDL and OWLS documents (they
describe the WS in terms of its inputs and outputs and
who is the compensation WS, if it is necessary); and
(iv) send values of attributes in IQ to ENGINE THREADS
representing successors of wsEEi. In Algorithm 1, lines 1
to 14 describe these steps.
WS Invocation phase: Once each ENGINE THREAD is
started, it retrieves the corresponding WSDL and OWLS
documents to extract information about the required inputs
and to construct the invocation. It waits its WS becomes
ﬁreable to invoke it (see Def. 6). Whenever an ENGINE
THREAD receives all the inputs needed it sets to running
the state of its corresponding transition in BRCPN-T CW SQ
161
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

and invokes its corresponding WS with its corresponding
inputs. When the WS ﬁnishes successfully, the ENGINE
THREAD changes to executed the state of its corresponding
transition in BRCPN-T CW SQ and sends values of WS
outputs to ENGINE THREADS representing successors of its
WS. If the WS fails during the execution, if T P(WS) is
retriable, the WS is re-invoked until it successfully ﬁnish;
otherwise the Compensation phase has to be executed. In
Algorithm 2, lines 1 to 7 describe this phase.
Compensation phase: This phase, carried out by both
EXECUTION ENGINE and ENGINE THREADS, is executed if
a failure occurs in order to leave the system in a consistent
state. The ENGINE THREAD responsible of the faulty WS
informs EXECUTION ENGINE about this failure with a
message compensate, marks the respective transition in
BRCPN-T CW SQ to compensate state and sends control
tokens to transitions successor of the compensation WS.
The EXECUTION ENGINE sends a message compensate to
all ENGINE THREADS, marks the BRCPN-T CW SQ with
the Initial Marking (i.e., adds tokens to places representing
inputs of BRCPN-T CW SQ and inputs of the faulty WS),
and sends control tokens to ENGINE THREADS representing
successors of ws′
EEf . Once the rest of ENGINE THREADS
receive the message compensate, they apply the ﬁring
rules in BRCPN-T CW SQ (see Def. 9). The compensation
process ﬁnishes when ws′
EEi becomes ﬁreable. Algorithm 3
describe these steps for both EXECUTION ENGINE and
ENGINE THREADS.
Final phase: This phase is carried out by both EXECUTION
ENGINE and ENGINE THREADS. If the TCWS was success-
fully executed (wsEEf becomes ﬁreable) the EXECUTION
ENGINE notiﬁes all ENGINE THREADS predecessors of
wsEEf by sending Finish message and returns the values
of attributes in OQ to user. When ENGINE THREADS
receive the Finish message, they backward this message
to its ENGINE THREAD predecessors and return. In case
compensation is needed, the EXECUTION ENGINE receives
a message compensate, the process of executing the TCWS
is stopped, and the compensation process is started by
sending a message compensate to all ENGINE THREADS.
If an ENGINE THREAD receives a message compensate, it
launches the compensation protocol. Algorithm 1 (lines 15-
18) and Algorithm 2 (lines 8- 10) describe this phase for
EXECUTION ENGINE and ENGINE THREADS respectively.
In order to guarantee the correct execution of our algo-
rithms, the following assumptions are made: i) the network
ensures that all packages are sent and received correctly;
ii) the EXECUTION ENGINE and ENGINE THREADS run
in a reliable server, they do not fail; and iii) the WSS
component can suffer silent or stop failures (WSS do not
response because they are not available or a crash occurred
in the platform); run-time failures caused by error in inputs
attributes and byzantine faults are not considered.
Algorithm 1: EXECUTION ENGINE Algorithm
Input: Q = (IQ, OQ, WQ, RQ), the user query – see Def. 1
Input: CPN-T CWSQ = (A, S, F, ξ), a CPN allowing the execution of a
TCWS– see Def. 3
Input: BRCPN-T CWSQ = (A′, S′, F −1, ζ), a CPN representing the
compensation ﬂow of TCWS– see Def. 4
Input: OWS: Ontology of WSS
Output: OVQ: List of values of o | o ∈ OQ
begin
Initial phase:
1
begin
Insert wsEEi in CPN-T CWSQ | ((wsEEi)• = IQ) ∧
2
((•wsEEi) = ∅);
Insert ws′
EEi in BRCPN-T CWSQ | (•ws′
EEi = {a′ ∈ A′
3
| (a′)• = ∅})∧ ((ws′
EEi)• = ∅);
Insert wsEEf in CPN-T CWSQ | ((wsEEf )• = ∅) ∧
4
((•wsEEf ) = OQ);
Insert ws′
EEf in BRCPN-T CWSQ | (•ws′
EEf = ∅) ∧
5
((ws′
EEf )• = {a′ ∈ A′ | •a′ = ∅});
∀a ∈ (A ∩ IQ), M(a) = 1 ∧ ∀a ∈ (A − IQ), M(a) = 0;
6
/* Mark the CPN-T CWSQ with the Initial Marking*/
∀s′ ∈ S′, ζ(s′) ← I;
7
/* state of all transitions in BRCPN-T CWSQ is set to initial */
repeat
8
Instantiate an ET WSws;
9
Send P redecessors ET WSws ←• (•ws);
10
Send Successors ET WSws ← (ws•)•;
11
Send WSDLws, OWLSws; /* Semantic web documents */
12
/* each ENGINE THREAD keep the part of CPN-T CWSQ
and BRCPN-T CWSQ which it concerns on*/
until ∀ws ∈ S | (ws ̸= wsEEi) ∧ (ws ̸= wsEEf ) ;
Send values of IQ to (wsEEi)•;
13
Execute Final phase;
14
end
Final phase:
15
begin
repeat
16
Wait Result from (•(•wsEEf ));
if message compensate is received then
Execute Compensation Phase /* this phase is shown in
Algorithm 3*/;
Exit Final phase;
else
Set values to OVQ;
until (∀o ∈ OQ, M(o) = card(•o) ;
/*o has a value an all transition predecessors have ﬁnished*/
Send F inish message to •(•wsEEf );
17
Return OVQ;
18
end
/*Send instructions are necessary if ENGINE THREADS are executed in a
distributed system, otherwise in a shared memory system, ENGINE
THREADS can access directly CPN-T CWSQ to obtain this
information*/
end
VI. RELATED WORK
There exist some recent works related to compensation
mechanism of CWSS based on Petri-Net formalism [5]–
[7]. The compensation process is represented by Paired
Petri-Nets demanding that all WSS component have to be
compensatable. Our approach considers other transactional
properties (e.g., pr, cr, ⃗ar) that also allow forward recovery
and the compensation Petri-Net can model only the part of
the TCWS that is compensable. Besides, in those works, the
Petri-Nets are manually generated and need to be veriﬁed,
while in our approach they are automatically generated.
Regarding the decentralized fault tolerant execution
model, we can distinct two kinds of distributed coordination
162
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Algorithm 2: ENGINE THREAD Algorithm
Input: P redecessors ET WSws, WS predecessors of ws
Input: Successors ET WSws, WS successors of ws
Input: WSDLws, OWLSws, semantic web documents
begin
Invocation phase:
1
begin
InputsNeeded ET WSws ←
getInputs(WSDLws, OWLSws);
repeat
Wait Result from (P redecessors ET WSws));
Set values to InputsNeeded ET WSws;
until ∀a ∈ InputsNeeded ET WSws, M(a) = card(•a) ;
2
/* a has a value and all transition predecessors have ﬁnished */
success ← false;
3
compensate ← false;
ζ(ws′) ← R;
4
repeat
Invoke ws;
if (ws fails) then
if T P (ws) ∈ {pr, ar, cr} then
Re-invoke ws;
5
else
compensate ← true;
else
Wait Result from ws;
ζ(ws′) ← E;
Remove tokens from inputs of ws;
Send Results to Successors ET WSws;
success ← true;
until (success) ∨ (compensate) ;
6
if compensate then
7
Send compensate to EXECUTION ENGINE;
ζ(ws′) ← C ;
Execute Compensation phase;/* backward recovery: this
phase is shown in Algorithm 3 */
else
Execute Final phase;
end
Final phase:
8
begin
Wait message;
9
if message is F inish then
Send F inish message to P redecessors ET WSws;
Return;
10
else
Execute Compensation phase;
end
/* In a shared memory system P redecessors ET WSws can be
accessed as •(•ws); Successors ET WSws as (ws•)•; and
InputsNeeded ET WSws as (•ws), because all ENGINE THREADS
share the CPN-T CWSQ and none send is necessary */
end
approach. In the ﬁrst one, nodes interact directly. In the
second one, they use a shared space for coordination. FENE-
CIA framework [8] introduces WS-SAGAS, a transaction
model based on arbitrary nesting, state, vitality degree, and
compensation concepts to specify fault tolerant CWS as
a hierarchy of recursively nested transactions. To ensure a
correct execution order, the execution control of the resulting
CWS is hierarchically delegated to distributed engines that
communicate in a peer-to-peer fashion. FACTS [1], is an-
other framework which extends the FENECIA transactional
model. When a fault occurs at run-time, it ﬁrst employs
appropriate exception handling strategies to repair it. If the
fault has been ﬁxed, the TCWS continues its execution.
Otherwise, it brings the TCWS back to a consistent termi-
nation state according to the termination protocol. In
[9]
Algorithm 3: Compensation Protocol
begin
EXECUTION ENGINE:
1
begin
∀a′ ∈ A′ |
•a′ = ∅, M(a′) = 1 ∧ ∀a ∈
•s, M(a′) = 1;
/* Mark the BRCPN-T CWSQ with the Initial Marking*/ Send
compensate to all ENGINE THREADS;
Send control values to •(•ws′
EEf );
Wait control values from ((ws′
EEi)•)•;
Return ERROR;
end
ENGINE THREADS:
2
begin
ws′ ← WS which compensates its WS;
if ζ(ws′) = A ∨ ζ(ws′) = C then
Send Control tokens to Successors ET WSws′;
else
InputsNeeded ET WSws′ ←
getInputs(WSDLws′ , OWLSws′);
repeat
Wait Control tokens from
P redecessors ET WSws′ ;
Set Control tokens to InputsNeeded ET WSws′ ;
until (∀a′ ∈ InputsNeeded ET WSws′, M(a′) ̸= ∅) ;
/* Wait its corresponding ws′ becomes ﬁreable: a′ has a
control value and all transition predecessors have ﬁnished*/
if ζ(ws′) = I then
ζ(ws′) ← A
if ζ(ws′) = R then
Wait ws ﬁnishes;
Invoke ws′;
ζ(ws′) ← C
;
if ζ(ws′) = E then
Invoke ws′;
ζ(ws′) ← C;
Send Control tokens to Successors ET WSws′;
Return /* ENGINE THREAD ﬁnishes */;
end
end
a fault handling and recovery CWSS, in a decentralized
orchestration approach that is based on continuation-passing
messaging, is presented. Nodes interpret such messages
and conduct the execution of services without consulting
a centralized engine. However, this coordination mechanism
implies a tight coupling of services in terms of spatial and
temporal composition. Nodes need to know explicitly which
other nodes they will potentially interact with, and when, to
be active at the same time. They are frameworks to support
users and developers to construct TCWS based on WS-
BPEL, then they are not transparent.
In [10], [11] engines based on a peer-to-peer application
architecture, wherein nodes are distributed across multiple
computer systems, are used. In these architectures the nodes
collaborate, in order to execute a CWS with every node exe-
cuting a part of it. In [10], the execution is controlled by the
component state and routing tables in each node containing
the precondition and postprocessing actions indicating which
components needs to be notiﬁed when a state is exited.
In [11], the authors introduce service invocation triggers, a
lightweight infrastructure that routes messages directly from
a producing service to a consuming one, where each service
invocation trigger corresponds to the invocation of a WS.
163
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Another series of works rely on a shared space to
exchange information between nodes of a decentralized
architecture, more speciﬁcally called a tuplespace. Using
tuplespace for coordination, the execution of a (part of a)
workﬂow within each node is triggered when tuples, match-
ing the templates registered by the respective nodes, are
present in the tuplespace. Thus, the templates a component
uses to consume tuples, together with the tuples it produces,
represent its coordination logic. In [12], [13] is presented
a coordination mechanism where the data is managed us-
ing tuplespace and the control is driven by asynchronous
messages exchanged between nodes. This message exchange
pattern for the control is derived from a Petri net model of
the workﬂow. In [14], an alternative approach is presented,
based on the chemical analogy. The proposed architecture is
composed by nodes communicating through a shared space
containing both control and data ﬂows, called the multiset.
The chemical paradigm is a programming style based on
the chemical metaphor. Molecules (data) are ﬂoating in
a chemical solution, and react according to reaction rules
(program) to produce new molecules (resulting data). As
this approach, in our approach the coordination mechanism
stores both control and data information independent of its
implementation (distributed or shared memory). However,
none of these works manage failures during the execution.
Facing our approach against all these works, we overcome
them because the execution control is distributed and inde-
pendent of the implementation (it can be implemented in dis-
tributed or shared memory platforms), it efﬁciently executes
TCWSS by invoking parallel WSS according the execution
order speciﬁed by the CPN, and it is totally transparent to
users and WS developers, i.e., user only provides its TCWS,
that was automatically generated by the COMPOSER and
no instrumentation/modiﬁcation/speciﬁcation is needed for
WSS participating in the TCWS. while most of these works
are based on WS-BPEL and/or some control is sitting closely
to WSS and have to be managed by programmers.
VII. CONCLUSIONS AND FUTURE WORK
In this paper, we have presented a fault tolerant execution
control mechanism for ensuring correct and fault tolerant
execution order of TCWSS. Our approach ensures that the
deployment of the TCWS will be carried on by following
unfolding algorithms of CPNs representing the TCWS and
the compensation process. We are currently working on
extending the approach with forward recovery based on WS
substitution. We are also implementing prototype systems
to test the performance of the approach in centralized
and decentralized platforms. Our intention is to compare
both implementations under different scenarios (different
characterizations of CPNs) and measure the impact of
compensation and substitution on QoS.
REFERENCES
[1] A. Liu, Q. Li, L. Huang, and M. Xiao, “FACTS: A Frame-
work for Fault Tolerant Composition of Transactional Web
Services,” IEEE Trans. on Services Computing, vol. 3, no. 1,
pp. 46–59, 2010.
[2] Y. Cardinale, J. El Haddad, M. Manouvrier, and M. Rukoz,
“CPN-TWS: A colored petri-net approach for transactional-
qos driven web service composition,” International Journal
of Web and Grid Services, vol. 7, no. 1, pp. 91–115, 2011.
[3] ——, Transactional-aware Web Service Composition: A Sur-
vey.
IGI Global - Advances in Knowledge Management
(AKM) Book Series, 2011, pp. 116–141.
[4] J. El Haddad, M. Manouvrier, and M. Rukoz, “TQoS: Trans-
actional and QoS-aware selection algorithm for automatic
Web service composition,” IEEE Trans. on Services Com-
puting, vol. 3, no. 1, pp. 73–85, 2010.
[5] Y. Wang, Y. Fan, and A. Jiang;, “A paired-net based com-
pensation mechanism for verifying Web composition transac-
tions,” in The 4th Int. Conf. on New Trends in Information
Science and Service Science, 2010.
[6] F. Rabbi, H. Wang, and W. MacCaull, “Compensable work-
ﬂow nets,” in Formal Methods and Software Engineering -
12th Int. Conf. on Formal Engineering Methods, ser. LNCS,
2010, vol. 6447, pp. 122–137.
[7] X. Mei, A. Jiang, S. Li, C. Huang, X. Zheng, and Y. Fan, “A
compensation paired net-based reﬁnement method for web
services composition,” Advances in Information Sciences and
Service Sciences, vol. 3, no. 4, May 2011.
[8] N. B. Lakhal, T. Kobayashi, and H. Yokota, “FENECIA: fail-
ure endurable nested-transaction based execution of compo
site Web services with incorporated state analysis,” VLDB
Journal, vol. 18, no. 1, pp. 1–56, 2009.
[9] W. Yu, “Fault handling and recovery in decentralized ser-
vices orchestration,” in The 12th International Conference on
Information Integration and Web-based Applications &#38;
Services, ser. iiWAS ’10.
ACM, 2010, pp. 98–105.
[10] D. M. Benatallah Boualem, Sheng Quan, “The self-serv
environment for web services composition,” IEEE Internet
Computing, pp. 40–48, 2003.
[11] W. Binder, I. Constantinescu, and B. Faltings, “Decentral-
ized orchestration of compositeweb services,” in The IEEE
International Conference on Web Services.
IEEE Computer
Society, 2006, pp. 869–876.
[12] D. Martin, D. Wutke, and F. Leymann, “Tuplespace middle-
ware for petri net-based workﬂow execution,” Int. J. Web Grid
Serv., vol. 6, pp. 35–57, March 2010.
[13] P. Buhler and J. M. Vidal, “Enacting BPEL4WS speciﬁed
workﬂows with multiagent systems,” in The Workshop on Web
Services and Agent-Based Engineering, 2004.
[14] H. Fernandez, T. Priol, and C. Tedeschi, “Decentralized
approach for execution of composite web services using the
chemical paradigm,” in IEEE Int. Conf. on Web Services,
2010, pp. 139–146.
164
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

