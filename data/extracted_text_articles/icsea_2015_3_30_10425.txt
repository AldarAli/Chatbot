Revisiting The Package-level Cohesion Approaches 
 
Waleed Albattah  
Information Technology Department 
Qassim University 
Qassim, Saudi Arabia 
e-mail: w.albattah@qu.edu.sa 
Suliman Alsuhibany 
Computer Science Department 
Qassim University 
Qassim, Saudi Arabia 
e-mail: salsuhibany@qu.edu.sa
 
 
Abstract—Software measurements play a critical role in 
assessing software properties. Cohesion is one of the software 
properties that are considered to have a relationship with 
software quality. Many cohesion metrics have been proposed 
by researchers to assess cohesion on different software 
abstractions, i.e., class-level and package-level. The proposed 
package-level cohesion metrics in the literature seem to differ 
in their assessment of cohesion. In this paper, we try to 
investigate this issue and establish whether cohesion has only 
one concept. The conclusion of this paper encourages further 
investigation and comparison between the existing package-
level cohesion metrics. 
Keywords—Cohesion; 
package; 
metric; 
measurement; 
software. 
I. 
INTRODUCTION 
With 
the 
increased 
importance 
of 
software 
measurements in assessing software properties, research 
works have produced and are continuing to produce new 
software measures. One specific type of measure is 
cohesion. Cohesion refers to the degree to which the 
elements of a specific component belong together [3].  
During software maintenance, developers spend at least 
50% of their time analysing and understanding software [2]. 
In object-oriented programming languages, e.g., Java, 
assembling only closely related classes into packages can 
improve software maintenance. Package cohesion metrics 
measure the coherence of a package amongst its elements 
that should be closely related. Cohesion is an internal 
attribute of software that affects its maintainability and 
reusability. Following the design principles [21], a high 
level of cohesion has as its goal to achieve software 
maintainability and promote its reusability [22][26]. 
Package-level cohesion research has received very little 
focus compared with research on other abstractions, e.g., 
class-level. When one examines the literature on package 
cohesion metrics, it is clear that there are significant 
differences in these metrics. Thus, the following natural 
question arises: do these metrics measure the same thing?  
This question will be addressed in this paper.  
The paper is organised as follows. In Section II, we 
present Package Cohesion Principles [21]. The existing 
approaches to package cohesion are presented in Section III. 
Section IV presents the general example for all the existing 
approaches. The conclusion and future work are given in 
Section V. 
II. 
PACKAGE COHESION PRINCIPLES 
R. C. Martin [21] has presented six principles for 
package design, which have since become well-known and 
well-accepted. The first three principles are for package 
cohesion and they help to allocate system classes to 
packages. This allocation can help to manage the software 
during its development. In our previous work [23], the three 
package cohesion principles of Martin [21] were discussed 
and they are introduced here briefly from [23]: 
1) The Reuse-Release Equivalence Principle (REP) 
 “The granule of reuse is the granule of release” 
This states that the reuse of the code should be the same 
size as the release one. If a person decides to reuse someone 
else’s code, he needs a guarantee that the support will 
continue and the release of new versions will be on the same 
original size. To ensure the reusability of the code, the author 
must organise the classes into reusable packages and then 
track them with the release. 
2) The Common Reuse Principle (CRP) 
“The classes in a package are reused together. If you reuse 
one of the classes in a package, you reuse them all” 
This principle tells us which classes should be grouped 
together. As it states, the classes that tend to be reused 
together should be in the same package. It is more likely for 
reusable classes to depend on each other, so classes are 
rarely reused in separation. CRP states that the classes of a 
package should be inseparable, which means that if a 
package depends on this package, it should depend on all of 
its classes and not on a number of them. In short, classes 
that are not tightly coupled to each other should not be kept 
in the same package. 
3) The Common Closure Principle (CCP) 
“The classes in a package should be closed together against 
the same kinds of changes. A change that affects a package 
affects all the classes in that package and no other 
packages” 
From the maintenance point of view, while the change is 
not avoidable, it should be controlled (minimised). If a 
change has been made on one package, there is no need to 
62
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

re-release or revalidate packages that do not depend on the 
changed package. The CCP states that the classes in the 
package should not have different reasons to change.  
While the previous two principles, REP and CRP, focus 
on 
reusability, 
the 
CCP 
focuses 
on 
the 
system 
maintainability. If a change is made on the code, it would be 
better to be on one package or on a few packages rather than 
being on many packages. The classes that are tightly related 
will change together. Hence, if they are kept in the same 
package, only one package or a small number of packages 
are going to be affected when a change happens. Also, the 
effort regarding revalidating and re-releasing of software 
will be minimised. 
 
III. 
THE EXISTING PACKAGE COHESION APPROACHES 
A number of cohesion approaches have been proposed on 
class and method levels [1][3]-[6]-[18]. In this section, we 
present some of the existing package-level cohesion 
approaches. A brief description is given for each. In the 
literature, Misic [19], Ponisio and Nierstrasz [22], Martin 
[21], Xu et al. [20], Zhou et al. [24], Abdeen et al. [25], and 
Albattah and Melton [23] have each proposed different 
methods to measure package cohesion. Each proposes a 
cohesion metric on the package level. A brief discussion for 
each approach is given next. 
A. Approach by Misic 
Misic [19] proposes a way to measure a functional 
cohesion. Since a number of approaches were focusing on 
cohesion as an internal structure issue, Misic claimed that 
cohesion could be also observed externally by focusing on its 
functional property regardless of the package’s internal 
structure. 
The approach measures the similarity of package objects 
(elements). The similarity between elements can be 
measured by looking at the external clients’ usage patterns. 
Method 
Misic defined write and read range concepts. The write 
range of an object O, W(O), refers to the set of objects 
(servers) used by this object (client). The read range of an 
object O, R(O), refers to the set of objects (clients) used by 
this object (server). 
Given a set of objects S, let R(S) be its client set (Read 
range), Sw the subset that IS? used to write its clients, and let 
Sw(x) be the part of that subset that IS? used to write the 
client x. Then, the coherence is given by the following 
formula: 
!
ψ(S)=
(#Sw(x)−1)
x∈R(S)
∑
(#S −1)
x∈R(S)
∑
 
 
(1) 
    where  
#S stands for the number of elements in S. 
The coherence measure proposed by Misic can be 
calculated internally or externally. For internal coherence, 
the summation in the numerator and denominator will be 
restricted only for clients inside the questioned set. Similarly, 
the summation will be restricted only for clients outside the 
questioned set to measure the external cohesion. 
B. Approach by Ponisio and Nierstrasz  
Ponisio and Nierstrasz [22] proposed a similar approach 
to measure package cohesion. The proposed contextual 
metric measures the cohesion based on the common use by 
clients. The approach idea is to propose the Common-Use 
(CU) metric that measures the package cohesion by taking 
into account the way that a package’s classes are accessed 
by other packages. 
Method 
CU measures the cohesion of package P by considering 
the use of its elements by the package clients. If all the 
clients use the same set of P’s elements, these elements share 
the same responsibilities of P, and then P is cohesive. 
Instead, if the clients use a different set of P’s elements, 
these elements have different responsibilities, and then P is 
not cohesive. 
There is a need for weight to differentiate between client 
packages. Not all clients have the same degree in assessing 
P’s cohesion. The weight reduces the influence of P’s 
cohesion from the promiscuous clients. 
Definition: “We define the weight of a (client) package 
Pclient as the inverse of the number of connections that Pclient 
has with other packages.” 
 
The definition of CU is given as follows: 
 “We define Common-Use (CU) as the sum of weighted 
pairs of classes from the interface of a package having a 
common client package (f), divided by the number of pairs 
that can be formed with all classes in the interface.” 
 
 
The value of CU is between 0, which represents that the 
interface classes of the package have disjoint responsibilities, 
and 1, which means that the interface classes of the package 
are used together. 
Common-Use (CU) measures cohesion in P by taking
into account the way client packages use the responsibilities
of P.
The intuition behind CU is that if all the clients use the
same set of classes in P, these classes contribute to the pur-
pose of P, and therefore P is cohesive. But if some clients
use a subset of classes in P and other clients use a disjoint
subset, then P apparently fulﬁls different, possibly unre-
lated responsibilities, which makes it not cohesive.
Figure 1 depicts both situations: in (a) some client pack-
ages access only class A and others access only class B,
indicating that P1 could be split, but in (b) every client ac-
cesses class A and class B, indicating that P2 should not be
split.
5.1
Distinguishing Packages:
the Need for a
Weight
Not every client contributes to P’s cohesion to the same
degree. For example, a package Pclient (see Figure 2(a))
that accesses every class in the system, including the classes
of P, does not tell us very much about P’s cohesion!
We ﬁnd therefore the need to differentiate client pack-
ages that indicate P’s cohesion from those that don’t. To
achieve this we introduce the notion of weight.
The weight contributes to lowering the cohesion of P
described by CU if the clients of P exhibit poor procedural
abstraction.
Deﬁnition 1 We deﬁne the weight of a (client) package
Pclient as the inverse of the number of connections that
Pclient has with other packages.
w(Pclient) =
1
fan in(Pclient) + fan out(Pclient)
The weight is intended to reduce the contribution to the
cohesion of P from clients that are very promiscuous in
their connections to packages of the system. In particular,
we do not want poorly-structured applications to “acciden-
tally” indicate that their packages are highly cohesive sim-
ply because everything accesses everything else!
If a client package P invokes common methods which
are implemented by classes everywhere in the system (e.g.
‘printOn:’), then the number of fan in and fan out dependen-
cies of this package will be high, which in turn diminishes
its weight and when P acts as client pointing out cohesion
of a provider Q, it reduces the CU value of Q.
P
dependenc
clients that
lack of co
(a) Problem
(b) Solu
P's
Figure
clients
weight
5.2
Deﬁn
Deﬁnition
weighted p
having a co
of pairs tha
Where
I
#P
C
f(a
we
Note tha
is undeﬁned
classes can
point of vie
CU resu
that the clas
responsibili
5
5
Common-Use (CU): Inferring Cohesion
from Reuse
Common-Use (CU) measures cohesion in P by taking
into account the way client packages use the responsibilities
of P.
The intuition behind CU is that if all the clients use the
same set of classes in P, these classes contribute to the pur-
pose of P, and therefore P is cohesive. But if some clients
use a subset of classes in P and other clients use a disjoint
subset, then P apparently fulﬁls different, possibly unre-
lated responsibilities, which makes it not cohesive.
Figure 1 depicts both situations: in (a) some client pack-
ages access only class A and others access only class B,
indicating that P1 could be split, but in (b) every client ac-
cesses class A and class B, indicating that P2 should not be
split.
5.1
Distinguishing Packages:
the Need for a
Weight
Not every client contributes to P’s cohesion to the same
degree. For example, a package Pclient (see Figure 2(a))
that accesses every class in the system, including the classes
of P, does not tell us very much about P’s cohesion!
We ﬁnd therefore the need to differentiate client pack-
ages that indicate P’s cohesion from those that don’t. To
achieve this we introduce the notion of weight.
The weight contributes to lowering the cohesion of P
described by CU if the clients of P exhibit poor procedural
abstraction.
Deﬁnition 1 We deﬁne the weight of a (client) package
Pclient as the inverse of the number of connections that
Pclient has with other packages.
w(Pclient) =
1
fan in(Pclient) + fan out(Pclient)
The weight is intended to reduce the contribution to the
cohesion of P from clients that are very promiscuous in
their connections to packages of the system. In particular,
we do not want poorly-structured applications to “acciden-
tally” indicate that their packages are highly cohesive sim-
ply because everything accesses everything else!
If a client package P invokes common methods which
are implemented by classes everywhere in the system (e.g.
‘printOn:’), then the number of fan in and fan out dependen-
cies of this package will be high, which in turn diminishes
its weight and when P acts as client pointing out cohesion
of a provider Q, it reduces the CU value of Q.
P
P
Client
Client
B
A
Client
Clients 
using  classes 
A and B
client
client
B
A
Pclient
P2
P's interface
dependencies of kind  inherits, state, class  
references, and message sends
The ubiquitous 
dependencies from 
Pclient obscure the 
dependencies form 
clients that indicate 
lack of cohesion
(a) Problem: Pclient indicating P cohesive when P is not
(b) Solution: measure the importance  of the clients accessing 
a pair of classes
P3
The weight of the 
clients of the pair A-
B determines the   
importance of the 
pair in adding 
towards cohesion
P's interface
Figure 2. Example of the effect of ubiquitous
clients in measuring cohesion (a) and the
weight of clients as a solution (b)
5.2
Deﬁning CU
Deﬁnition 2 We deﬁne Common-Use (CU) as the sum of
weighted pairs of classes from the interface of a package
having a common client package (f), divided by the number
of pairs that can be formed with all classes in the interface.
CU =
X
a,b2I
f(a, b) ⇤ weight(a, b)
#Pairs
Where
I
=
interface(P)
#Pairs
=
|I|⇥(|I|−1)
2
C
=
clients(a) \ clients(b)
f(a, b)
=
⇢ 1,
if C 6= ;
0,
otherwise
weight(a, b)
=
P
c2C
w(c)
|C|
Note that if #Pairs = 0 (i.e.,, if | I |= 0 or 1), then CU
is undeﬁned, since a package without at least two interface
classes can neither be cohesive nor not cohesive from the
point of view of its clients.
CU results in a number between 0 and 1, where 0 means
that the classes of the interface have disassociated (disjoint)
responsibilities, and a number close to 1 indicates that all
5
(2) 
(3) 
63
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

C. Approach by Martin 
Martin [21] presents a set of principles of object-
oriented package design. Three of these principles, package 
cohesion principles, try to help the software architect to 
organise classes over packages. These principles are: REP, 
CCP, and CRP, discussed earlier in Section II. The three 
principles aim to provide a high quality of package 
cohesion. 
Method 
Martin [21] proposed a number of simple package-level 
metrics. One of them is a relational cohesion of a package. 
The package cohesion metric is presented as an average 
number of internal relations per class. Regardless of the 
package external dependencies that are considered in other 
cohesion metrics, the metric measures the connectivity 
between package elements. This metric is quite simple to 
apply, and is given by:  
 
H=(R+1)/N  
where  
     H: package cohesion 
 
     R: number of internal relations 
 
     N: number of the package classes 
The extra “1” in the numerator prevents cohesion H 
from equalling zero when N=1. This metric gives all internal 
relations the same weight and disregards the external ones. 
It has been applied to a number of software projects and is 
widely accepted. 
D. Approach by Xu et al. 
Xu et al. [20] propose an approach to measuring the 
package cohesion in Ada95 object-oriented programming 
language. The proposed metric is based on dependence 
analysis between package entities. It is assumed that the 
package may have objects and sub-programs.  
Method 
The package dependence graph (PGDG) describes all 
types of dependencies: inter-object dependence graph 
(OOG), inter-subprogram dependence graph (PPG), and 
subprogram-object dependence graph (POG). The method 
measures package cohesion according to PGDG. It assumes 
that package PG has n objects and m subprograms, where n, 
m > 0.  
To present the measure in a unified model, a power for 
each object PW(O) is given: 
 
Xu et al. [20] claimed that, according to the definitions, it 
is easy to prove that the measure satisfies the four properties 
given by Briand et al. [3][27] to develop a good cohesion 
measure. 
However, an Ada package represents a logical grouping 
of declarations. The role of an Ada package is similar to the 
role of class in other languages, such as Java [24]. Thus, this 
package cohesion metric cannot be applied to the general 
example in the next section. An Ada package actually falls in 
the category of class-level cohesion metric. 
E. Approach by Zhou et al. 
Zhou et al. [24] proposed an approach to measuring 
package semantic cohesion called the Similar Context 
Cohesiveness (SCC). In this approach, the common context 
is used to assess the degree of relation between two 
components. SCC measures the inter- and intra-package 
dependencies that can reveal semantic cohesion between 
components. 
Method 
The proposed package cohesion measure SCC is based 
on the component context. The context of component c is 
composed of two sets: the components that depend on c and 
those that c depends on. The SCC metric is given by: 
 
where  
       m: number of components c in p 
  
 
CCS(c1,c2): denotes the similarity between the contexts of 
two components c1 and c2 , and is given by: 
CCS(c1, c2) = kRSS(c1, c2) + (1-k)DSS(c1, c2)  
k: represents the position’s importance 
RSS(c1, c2): similarity between SR(c1) and SR(c2) 
DSS(c1, c2): similarity between SD(c1) and SD(c2) 
 
 
F. Approach by Abdeen et al. 
The approach proposed by Abdeen et al. [25] is based on 
the Simulated Annealing technique. The approach aims to 
reduce package coupling and cycles by moving classes 
between packages. Two metrics have been defined for this 
purpose, coupling and cohesion metrics.  
Method 
The approach automatically reduces package coupling 
and cycles by moving classes between packages considering 
the existing class organisation and package structure. This 
approach can help maintainers to define: the maximum 
number of classes that can change their packages, the 
maximum number of classes that a package can contain, and 
°¯
°®
­
others
O
PG O
Cohesioin
O
O
Cohesion
1
 is a  type object
( ))
(
 is  a package object
)
(
 
where Cohesion (O) is the cohesion of O, PG (O) returns the 
package containing O. 
4. MEASURING PACKAGE COHESION 
According to the PGDG, this section will propose our method to 
measure the package cohesion. In the following discussions, we 
assume package PG contains n objects and m subprograms, where 
m, n t0. 
4.1 Measuring Inter-Object Cohesion 
Inter-object cohesion is about the tightness among objects in a 
g 
g 
relation, if CCS(c1, c2) does not equal 0. And they have a 
data relation, if Dep(c1, c2) equals to 1. Herein, Dep(c1, 
c2) is determined as follows: 
1
2
2
1
1
2
1
( ,
)
0
d
d
if
c
c
or c
c
Dep c c
else
­
⎯⎯→
⎯⎯→
= ®
¯
 
As in Figure 1, the component SCCMetric and 
RCMetric have a context relation. And the component 
DependenceGraph and Element have a data relation. 
Definition 4 The weighted interaction graph WIG 
of a package p is an undirected graph, WIG(p) = (V(p), 
E(p)) where V(p) is a set of components in p, and E(p) 
is a set of edges labeled with weights Wgt, i.e. 
E(p) = {(c1, c2) ∈ V(p) × V(p) | Wgt(c1, c2) > 0} 
where 
Wgt(c1, c2) = CCS(c1, c2) + Dep(c1, c2) 
Based on Definition 4, the higher the sum of the 
weights of WIG(p) is, the closer the components of p 
are tied. Thus, the measure, SCC (Similar Context 
Cohesiveness) is defined as the ratio of the sum of 
weights of WIG(p) to the number of all possible 
context and data relations of p. 
Definition 5 For a package p and V(p) = {c1, c2,…, cm}, 
we have 
(
,
)
( )
( ,
)
1
( )
(
1)
1
1
i
j
i
j
c c
E p
Wgt c c
if
m
SCC p
m m
if
m
∈
­
°°
>
= ®
−
°
=
°¯
¦
 
When m = 1, there is only one component in p. In 
this case, p is cohesive obviously. We thus set SCC(p) 
to 1. When m > 1, if each pair of components has no 
relation, SCC(p) = 0. And if the Wgt for each pair of 
components reaches the maximum value 2, SCC(p) = 
1. Thus, SCC(p) ∈ [0, 1]. 
In the context of SCC, we regard that for a cohesive 
package p, WIG(p) should be a connected graph and 
the weight for each edge should be no less than 0.5. 
According to graph theory, a connected graph with m 
nodes has no less than m – 1 edges. Thus, the 
 
 
 
 
SCC satis
which is pro
accepted tha
conform to th
Theorem
decrease whe
Proof  Le
c2
d
⎯⎯→ c1, w
(1) SR(c1) 
RSS(c1, ci) do
(2) SD(c2) 
DSS(c2, ci) do
(3) Dep(c
According
decrease whe
Theorem
relation betw
≤ Max(SCC(p
Proof  Ba
p1 and p2 if th
∀c1 ∈ p1
When com
components o
components o
If m1 = 1 a
SCC(p3)
If m1 = 1 
(
SCC p
Therefore,  
SCC(p3)
If m1 ≠ 1 a
(
SCC p
F
130
Besides, the computation of CCS(c1, c2) involves 
inter-package data dependence like CCS(SCCMetric, 
RCMetric). This shows that both intra- and inter- package 
data dependences contribute to the cohesion of a package. 
 
3.2. Measure definition 
According to the discussion in Section 3.1, the 
components have two kinds of relations: context and 
data. For two components c1 and c2, they have a context 
relation, if CCS(c1, c2) does not equal 0. And they have a 
data relation, if Dep(c1, c2) equals to 1. Herein, Dep(c1, 
c2) is determined as follows: 
1
2
2
1
1
2
1
( ,
)
0
d
d
if
c
c
or c
c
Dep c c
else
­
⎯⎯→
⎯⎯→
= ®
¯
 
As in Figure 1, the component SCCMetric and 
RCMetric have a context relation. And the component 
DependenceGraph and Element have a data relation. 
Definition 4 The weighted interaction graph WIG 
of a package p is an undirected graph, WIG(p) = (V(p), 
E(p)) where V(p) is a set of components in p, and E(p) 
is a set of edges labeled with weights Wgt, i.e. 
E(p) = {(c1, c2) ∈ V(p) × V(p) | Wgt(c1, c2) > 0} 
where 
Wgt(c1, c2) = CCS(c1, c2) + Dep(c1, c2) 
Based on Definition 4, the higher the sum of the 
weights of WIG(p) is, the closer the components of p 
are tied. Thus, the measure, SCC (Similar Context 
Cohesiveness) is defined as the ratio of the sum of 
weights of WIG(p) to the number of all possible 
context and data relations of p. 
Definition 5 For a package p and V(p) = {c1, c2,…, cm}, 
we have 
(
,
)
( )
( ,
)
1
( )
(
1)
1
1
i
j
i
j
c c
E p
Wgt c c
if
m
SCC p
m m
if
m
∈
­
°°
>
= ®
−
°
=
°¯
¦
 
When m = 1, there is only one component in p. In 
this case, p is cohesive obviously. We thus set SCC(p) 
to 1. When m > 1, if each pair of components has no 
relation, SCC(p) = 0. And if the Wgt for each pair of 
components reaches the maximum value 2, SCC(p) = 
1. Thus, SCC(p) ∈ [0, 1]. 
In the context of SCC, we regard that for a cohesive 
package p, WIG(p) should be a connected graph and 
the weight for each edge should be no less than 0.5. 
According to graph theory, a connected graph with m 
nodes has no less than m – 1 edges. Thus, the 
the
the
on 
gre
Co
 
 
 
 
 
 
 
 
wh
acc
con
dec
c2 ⎯
RS
DS
dec
rel
≤ M
p1 
W
com
com
Th
130
Besides, the computation of CCS(c1, c2) involves 
inter-package data dependence like CCS(SCCMetric, 
RCMetric). This shows that both intra- and inter- package 
data dependences contribute to the cohesion of a package. 
 
3.2. Measure definition 
According to the discussion in Section 3.1, the 
components have two kinds of relations: context and 
data. For two components c1 and c2, they have a context 
relation, if CCS(c1, c2) does not equal 0. And they have a 
data relation, if Dep(c1, c2) equals to 1. Herein, Dep(c1, 
c2) is determined as follows: 
1
2
2
1
1
2
1
( ,
)
0
d
d
if
c
c
or c
c
Dep c c
else
­
⎯⎯→
⎯⎯→
= ®
¯
 
As in Figure 1, the component SCCMetric and 
RCMetric have a context relation. And the component 
DependenceGraph and Element have a data relation. 
Definition 4 The weighted interaction graph WIG 
of a package p is an undirected graph, WIG(p) = (V(p), 
E(p)) where V(p) is a set of components in p, and E(p) 
is a set of edges labeled with weights Wgt, i.e. 
E(p) = {(c1, c2) ∈ V(p) × V(p) | Wgt(c1, c2) > 0} 
where 
Wgt(c1, c2) = CCS(c1, c2) + Dep(c1, c2) 
Based on Definition 4, the higher the sum of the 
weights of WIG(p) is, the closer the components of p 
are tied. Thus, the measure, SCC (Similar Context 
Cohesiveness) is defined as the ratio of the sum of 
weights of WIG(p) to the number of all possible 
context and data relations of p. 
Definition 5 For a package p and V(p) = {c1, c2,…, cm}, 
we have 
(
,
)
( )
( ,
)
1
( )
(
1)
1
1
i
j
i
j
c c
E p
Wgt c c
if
m
SCC p
m m
if
m
∈
­
°°
>
= ®
−
°
=
°¯
¦
 
When m = 1, there is only one component in p. In 
this case, p is cohesive obviously. We thus set SCC(p) 
to 1. When m > 1, if each pair of components has no 
relation, SCC(p) = 0. And if the Wgt for each pair of 
components reaches the maximum value 2, SCC(p) = 
1 Th
SCC( )
[0 1]
theoretical th
the threshold
Figure 2 s
on Definition
greater than 0
CohesionMet
 
 
 
 
 
 
 
 
SCC satis
which is pro
accepted that
conform to th
Theorem 
decrease whe
Proof  Le
c2
d
⎯⎯→ c1, w
(1) SR(c1) 
RSS(c1, ci) do
(2) SD(c2) 
DSS(c2, ci) do
(3) Dep(c1
According
decrease whe
Theorem 
relation betw
≤ Max(SCC(p
Proof  Ba
p1 and p2 if th
∀c1 ∈ p1
When com
components o
components o
If m1 = 1 a
SCC(p3)
If m1 = 1 a
( 3
SCC p
Th
f
F
components. The context of a component reflects the 
relationship between the component and the rest of the 
software. In real world, engineers always design or 
comprehend a component by means of the context 
where the component exists. The similar contexts of 
two components indicate that the components are 
related semantically to some degree. In the next 
section, we will discuss how to use the component 
context to evaluate the cohesion of a package. 
 
3. Similar context based package cohesion measure 
To properly evaluate the cohesiveness of a package, 
we should identify the coupling between components 
through their contexts. Therefore in this section, we 
first discuss the context of a component. Then, we 
propose a new package cohesion measure called SCC 
based on the component context. 
 
3.1. Component context 
In this paper, we regard that the context of a 
component c is composed of two parts: One is the 
components that c has data dependences on. Another is 
the components that have data dependences on c. For 
properly define the context, we give a formal definition of 
data dependence. 
Definition 1 A component c1 has a data dependence 
on another component c2, denoted by
d
⎯⎯→ , if c1 
references a function, a variable or a type defined in c2. 
A component c1 has an indirect data dependence on 
another component c2, denoted by c1
d +
⎯⎯→ c2, if (c1, 
c2) belong to the transitive closure of
d
⎯⎯→ . 
For instance in Figure 1, the component RCMetric 
has a data dependence on the component Element. 
Definition 2 For a component c, we have: 
SR(c) = {ci  | ci
d +
⎯⎯→ c} 
SD(c) = {ci  | c
d +
⎯⎯→ ci} 
Here, SR(c) is set of the components that have data 
dependences on c, which represents the components 
that may be affected when c is changed. SD(c) contains 
the components that c has data dependences on, which 
denotes the components whose changes may leads to 
the change of c. Then, the context of a component is 
defined as a tuple of SR and SD. 
Definition 3 For a component c, the context of c is 
(SR(c), SD(c)), denoted by CC(c). 
It is rational to infer that two components c1 and 
c2are related tightly if their contexts are similar. Since 
the context of a component is composed of SR and SD, 
the evaluation of the similarity between CC(c1) and 
CC(c2), denoted by CCS(c1, c2), need to allow for the 
 
(4) 
(5) 
64
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

the classes that should not change their packages and/or the 
packages that should not be changed. A set of measures is 
defined to determine and quantify the quality of a package. 
The number of package dependencies (|PD|) normalises 
these measures. 
The package cohesion metric is defined to be the direct 
dependencies between its classes. Hence, the cohesion of a 
package P is proportional to the number of its internal 
dependencies (|P Int.D |) according to the CCP Principle [19]. 
The cohesion quality is given as follows: 
 
where  
       |PD| is the number of all internal and external 
dependencies of classes in the package. 
G. Approach by Bauer and Trifu 
Bauer and Trifu [28] have proposed an approach, 
architecture-aware 
adaptive 
clustering, 
to 
produce 
meaningful decompositions in a system. They have 
evaluated their approach by defining two metrics: the 
average cohesion of a subsystem and the average coupling 
between subsystems.  
Method 
The 
approach 
was 
based 
on 
providing 
better 
understanding of the system. They tried to recover from the 
original decomposition and then impose an appropriate 
structure. The new structure aims to maximise subsystems 
cohesion. 
To 
evaluate 
the 
recovered 
subsystem 
decomposition, they performed a comparative study that is 
based on two criteria, accuracy and optimality. For 
accuracy, they compared the resulting decompositions with 
both the original package structure and the ideal Common 
Reuse Principle structure of [21]. For optimality, they used 
some optimality metrics to show whether the resulting 
decompositions have high cohesion and low coupling. To 
evaluate their approach, two metrics were defined: average 
cohesion of the subsystems and average coupling between 
the subsystems of a given decomposition. The average 
cohesion metric is given by: 
 
where   
  D: a composition 
noInternalEdges(Si): number of edges between 
classes in Si 
|D|*: number of subsystems except single-class 
subsystems in D 
Si: subsystem number i in D 
     |Si|: number of classes in subsystem Si 
H. Approach by Seng et al. 
The approach by Seng et al. [29] aims to develop 
existing object-oriented system decompositions by defining 
new decompositions with better metric values and fewer 
violations of design principles. They defined the problem as 
a search problem. The quality of the resulting subsystem 
decompositions is measured by the fitness function that 
combines software metrics and design heuristics. 
Method 
The fitness function consists of cohesion, coupling, 
complexity metrics, as well as cyclic dependencies and 
bottleneck heuristics. The value of each individual function 
is between 0 and 1, where the optimal value is 1. The 
cohesion of a system s is the summation of cohesion values 
for the individual subsystems in s. The cohesion for a 
subsystem si is measured by counting the number of different 
classes in si known by some class cj ⊂  si ,(#k(cj )), and 
dividing this by the square number of classes in si , (#c(si)). 
The resulting value can be normalised if divided by the 
number of subsystems (#s). 
 
I. Approach by Tagoug 
Tagoug [30] has proposed coupling and cohesion 
metrics on subjects, which are similar to packages. Each 
subject is a collection of classes. The approach aims to 
measure cohesion and coupling at the system level. The 
quality metric, which combines cohesion and coupling 
values, measures the decomposition’s quality as early as the 
analysis and design phases of the software development 
lifecycle.  
Method  
The two metrics measure the quality of object-oriented 
decomposition. The cohesion metric focuses on the 
interactions of components inside a subject, while the 
coupling metric focuses on the interactions of components 
among subjects. The cohesion of subject E is given by: 
!
C(E)=
Wij
j=i+1
n
∑
i=1
n−1
∑
Wmax *(n*(n−1)/2)
 
where 
   E: a set of classes of S. 
  Wij: the sum of the weights of links in Lij.  
  Lij: the set of all links between classes Pi and Pj.  
  Wmax = max {Wij} in system S 
p
deﬁne a set of measures that help us determine and quantify
the quality of a single package within a given modularization.
To normalize the value of those measures we use the number
of dependencies related to the considered package (|pD|)
with |pD| > 0.
Package Cohesion: we relate package cohesion to the
direct dependencies between its classes. In such a context,
we consider that the cohesion of a package p is proportional
to the number of internal dependencies within p (|pInt.D|).
This is done according to the Common Closure Principle
(CCP) [23]. We deﬁne the measure of package cohesion
quality similarly to that in [1] as follows:
CohesionQ(p) = |pInt.D|
|pD|
Package Coupling: we relate package coupling to
its efferent and afferent coupling (Ce, Ca) as deﬁned by
Martin in [24]. Package Ce is the number of packages that
this package depends upon (|pP ro.P |). Package Ca is the
number of packages that depend upon this package (|pCli.P |).
According to the common reuse principle, we deﬁne the
measure of package coupling quality using the number of
package providers and clients as follows:
CouplingQ(p) = 1 − |pP ro.P [pCli.P |
|pD|
Package Cyclic-Dependencies: for automatically detect-
ing packages that suffer from direct-cyclic dependencies
we deﬁne a simple measure that evaluates the quality of
package cyclic dependencies (CyclicDQ) using the number
of package cyclic dependencies:
CyclicDQ(p) = 1 −
|pCyc.D|
|pD|
Similarly we deﬁne another measure that evaluates package
cyclic connections quality (CyclicDQ) using the number of
package cyclic connections:
CyclicCQ(p) = 1 −
|pCyc.Con|
|pD|
105
105
the MoJo7 metric. The ideal CRP structure is the ideal
decomposition from the point of view of the Common
Reuse Principle [14]. In order to obtain this decom-
position, we applied our MMST algorithm on a set of
similarities that were computed using only the indirect
coupling. The MoJo metric counts the minimum num-
ber of basic operations (moves and joins) that must be
performed to transform one decomposition to another.
In essence, this metric shows how similar two decom-
positions are. It is clear, from the above mentioned de-
scription, that the lower the value of the MoJo metric,
the more similar the two decompositions. Similarity to
the original package structure means that subsystems
contain only semantically related classes. We base this
afﬁrmation on the assumption that the original pack-
age structure was designed to reﬂect groups of seman-
tically related classes.
Similarity to the ideal CRP
structure means that all the semantically related classes
are in a single subsystem because they are consistently
used together. In addition to these measurements, we
also rely on manual inspection of the decompositions
to prove that the architecture-aware adaptive clustering
produces more accurate decompositions than its non-
adaptive counterpart.
• Optimality. Most of the other clustering approaches
are evaluated using some sort of optimality metric
which shows that the resulting decompositions exhibit
desirable attributes of the subsystem: high internal co-
hesion and low external coupling. In our case, op-
timality is just a secondary criterion. We wanted to
prove that the superior accuracy of our approach is not
achieved at the expense of optimality. To evaluate our
approach based on this criterion, we have deﬁned two
metrics: average cohesion of the subsystems and av-
erage coupling between the subsystems of a given de-
composition. The formulas to compute these metrics
are given below:
avgCohesion(D) =
!
Si∈D
|Si|>1
noInternalEdges(Si)
|Si|2−|Si|
2
|D|∗
avgCoupling(D) =
!
Si,Sj ∈D
i<j
noExternalEdges(Si,Sj)
|Si|∗|Sj|
|D|2−|D|
2
where D is a decomposition, |D| is the number
of subsystems in decomposition D, Si is the ith
subsystem in D, |Si| is the number of classes in
7For a description of the MoJo metric, see [24].
subsystem Si, noInternalEdges(Si) is the number
of undirected edges between the classes of Si and
noExternalEdges(Si, Sj) is the number of undi-
rected edges between classes from Si and classes from
Sj. Note that when computing the average cohesion,
we do not consider single-class clusters as the inter-
nal cohesion of such clusters is undeﬁned. |D|∗ is the
number of subsystems that are not single-class subsys-
tems in decomposition D. Also, avgCoupling(D) is
not deﬁned for decompositions that contain a single
cluster.
Both the Accuracy and Optimality related measure-
ments were done for three different values of the closeness
factor given as a parameter to the MMST clustering algo-
rithm.
We have applied the above mentioned evaluation proce-
dure on two case studies: the Java AWT library and the SSH-
Tools project. The following subsection presents the results
obtained for the former.
3.1
The Java AWT Library
The Java AWT Library is a collection of classes for cre-
ating lightweight user interfaces and for painting graphics
and images. It is part of the standard Java platform. It is
structured into 14 relatively large packages.
Table 2 presents time and size measurements for the Java
AWT library.
From this table, we can clearly see that the only time and
memory consuming phase is the fact extraction phase. Still,
the size of the source model (38 MBytes) and the execution
time (under 5 minutes) are reasonable for a project so large
(more than 140,000 lines of code).
Next, table 3 presents the accuracy related measurements
for the Java AWT library. The accuracy and optimality ta-
ble headings contain the following abbreviations: Pack -
the original package structure, CRP - the ideal CRP struc-
ture, NA - the decomposition produced by the non-adaptive
clustering, and A - the decomposition produced by the
architecture-aware adaptive clustering.
The results clearly show that the architecture-aware
adaptive clustering produces more accurate decomposi-
tions than its non-adaptive counterpart.
In the case of
architecture-aware adaptive clustering, the values of the
MoJo metric, although lower than in the case of non-
adaptive clustering, are rather high for the comparison with
the original package structure. This is due to the differ-
ence in average cluster size. Our MMST tends to create
small clusters, while the original package structure contains
a small number of large clusters. The problem will be dis-
cussed in more detail later on in this section.
The manual inspection of the clusterings revealed some
very interesting results. We have compared only the cluster-
Proceedings of the Eighth European Conference on Software Maintenance and Reengineering (CSMR’04) 
1534-5351/04 $ 20.00 © 2004 IEEE 
ness.
ore the operators are designed to be non-destructive
erve a complete subsystem candidate as far as
e operators take care to produce only consistent
e decompositions, so we do not waste computa-
infeasible solutions.
over operator forms two children from two par-
choosing the parents, the operator selects a se-
ubsystem candidates in both parents (step 0)
y integrates them as new subsystem candidates
parent (step 1) and vice versa, thus forming
ldren consisting of both old and new subsystem
Old subsystem candidates which now contain
lasses are deleted (step 2), their non-duplicated
collected (step 3) and distributed over the re-
system candidates (step 4). In this step we con-
mber of dependencies between the classes that
stributed to new subsystem candidates. We al-
to those subsystem candidates which have the
nnections to the classes.
The process of the
erator is depicted in Figure 3, where we show
he two possible children is created.
&join mutation either divides a subsystem can-
two smaller subsystem candidates or joins two
andidates by unifying their classes. The oper-
subsystem candidate in such a way, that the
n two subsystem candidates occurs at a loosely
oint in the dependency graph.
Similarly, the
nnects two subsystem candidates with strong as-
ight.
on mutation deletes a subsystem candidate and
ts classes to other subsystem candidates, based
on weights. Elimination mutation is part of our
erator discussed above.
mutation tries to ﬁnd a new subsystem candi-
orphan, i.e. a subsystem candidate containing
class. Thus our approach naturally implements
doption technique [18]. Orphan adoption avoids
ystems candidates containing only a single class.
or simply moves the orphan to the subsystem
hat has the highest connectivity to the orphan.
tial population
ing block theory tells us, that the GA constructs
combining building blocks. But where do these
cks come from? As a general purpose search the
ed to ﬁnd building blocks over time [8].
But
sign a specialized GA for software decomposi-
n use domain knowledge to shortcut the search
blocks and speed up the convergence.
Thus
mal results of problem speciﬁc algorithms can
reate an initial population that might help the
proper building blocks fast [10].
starting populations, two competing properties
e. On the one hand the individuals should have
s, so good building blocks are already present in
on On the other hand the GA needs diversity
depending on the availability of existing decompositions:
• If a suitable decomposition is given (e.g. by the pack-
age structure of a Java system), we use it as the highly
ﬁt initial population.
• If no decomposition is available, we attempt to build
several suboptimal decompositions. Our approach is
based on a modiﬁcation of Kruskal’s algorithm for the
construction of minimum spanning trees (MST) on the
dependency graph [20]. We modify this greedy algo-
rithm by deﬁning a threshold for the uniﬁcation of
two subtrees of the MST. This results in a solution
that consists of a forest representing initial building
blocks of the decomposition. Using diﬀerent thresh-
olds, which are chosen randomly from a certain inter-
val, we can create a set of individuals representing the
highly ﬁt half of our initial population.
2.3
Fitness function
Our ﬁtness function fit(s) is a multi modal ﬁtness func-
tion.
Each of the individual functions calculates a value
between 0 and 1, where 1 is the optimal value. Such a multi
modal ﬁtness function can be easily mapped into a linear
ﬁtness function, by just adding up the weighted individual
values.
fit(s)
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
cohesion(s)
:
#s
%
i=1
#c(si)
%
j=1
#k(cj )
#c(si)2
#s
coupling(s)
:
1 −
#s
%
i=1
#rO(si)
#r
complexity(s)
:
#s
%
i=1
&
com(si) ∗ #c(si)
#c
'
cycles(s)
:
1 −
n
%
i=1
size(scc[i])k
#sk
bottlenecks(s)
:
1 −
#s
%
i=1
min(inDeg(si),outDeg(si))
#s∗maxDeg
Currently we are using standard coupling and cohesion
metrics as parts of our ﬁtness function [2].
To measure
the cohesion for a system s, we sum up the cohesion val-
ues for the individual subsystems in s. The cohesion for a
subsystem si is determined by counting the number of dif-
ferent classes inside si known by some class cj ∈ si (#k(cj))
and divide this by the square of the number of classes in si
(#c(si)). This value is then normalized by dividing it by
the number of subsystems (#s).
The coupling function is the sum of the coupling values for
each subsystem in s. The coupling value for one subsystem
si is calculated in the following way: at ﬁrst, we count the
number of dependency edges between classes inside si and
classes belonging to other subsystems sj (#rO(si)). This
number is divided by the overall number of dependency
edges (#r) in s.
The complexity function adds up the complexity values
com(si) of all subsystems si in s, normalized by the propor-
tion of classes #c(si) of s in s The complexity value com(s )
(6) 
(7) 
(8) 
(9) 
65
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

  n = |E|, n > 1 
 
The cohesion value is between 0, i.e., there are no links 
between classes, and 1, maximum links with maximum 
weight. The weights of links between classes of a subject 
are ordered in Table I based on the degree of association 
according to the object-oriented expert designers. 
 
TABLE I.  
WEIGHTS OF LINKS BETWEEN CLASSES. 
Links Type 
Weights (Wij) 
Whole Part Structure 
0.9 
Inheritance 
0.8 
Instance Connection 
0.7 
Message Connection 
0.6 
Conceptual Link 
0.5 
 
J. Approach by Albattah and Melton 
The approach by Albattah and Melton [23] is motivated 
by the package cohesion principles [21]. They proposed two 
different cohesion metrics to measure two different cohesion 
concepts or types based on Martin’s package cohesion 
principles in [21]. The first cohesion type, Common Reuse 
(CR), includes the factors that help in assessing CR 
cohesion. Similarly, the second cohesion type, Common 
Closure (CC), includes the factors that help in assessing CC 
cohesion. After each type of cohesion is measured by itself, 
the two values of CR and CC may be combined to one 
unified value of package cohesion, while still recognising 
the two types.  
Method 
The CR metric measures cohesion based only on the 
common reuse factors of the package. The elements of a 
package have different degrees of reachability. Reachability 
of a class in a package is the number of classes in the same 
package that can be reached directly or indirectly. The CR 
metric is defined as follows: 
“Let c ∈ C, and suppose there is an incoming relation to 
c from a class in a different package. Then c is called an in-
interface class. The cardinality of the intersection of the hub 
sets of all the in-interface classes in C divided by the 
number of classes in C is the CR of P ”. 
CR= |∩ In-interface class hub sets| / |C| 
where  
Hubness(c) = {d ∈ C: if there is a path c àd} 
       C: set of classes in package P 
   
             c and d: classes in C 
The CC metric considers the package dependencies on 
other packages as well as the internal dependencies between 
classes of the package. The classes of the package should 
depend on the same set of packages and, thus, they will have 
the same reasons for a change. The CC metric is defined as 
follows: 
“The cardinality of the intersection of the reachable sets 
divided by the cardinality of the union of the sets represents 
the CC of P ”. 
CC= ( |∩ Reachable Package sets | / |∪ Reachable Package sets | ) 
The combined cohesion CH is defined as follows: 
 
CH =
2 − D
2
 
 
D = (1−CR)2 +(1−CC)2  
 
IV. 
THE GENERAL EXAMPLE 
While we try to understand each of the previously 
presented approaches, we rely on our best understanding for 
each. One method of empirical investigation is to apply all 
the approaches on the same situation and compare the 
results. The approaches have been applied to measure the 
cohesion of P1 in Figure 1. The concern is to measure the 
cohesion of P1 only for the purpose of comparison between 
the approaches. If all the approaches rely on the same idea, 
their assessments of the cohesion of P1 will be alike. 
Otherwise, they probably rely on different concepts of 
package cohesion.  
In Figure 1, there are six packages and a number of 
classes in each package. The arrows represent the 
dependencies between classes within the same package, i.e., 
in P1, or between classes in different packages. The 
direction of the dependency is very important because it 
shows the depended-upon class. For example, C6 depends 
on C2 but not the opposite. In the figure, P1 has four classes 
that have incoming and outgoing dependencies. Using the 
presented approaches, we try to measure how cohesive are 
the classes of P1. It is worth mentioning that all the 
presented approaches consider the dependencies between 
classes to measure cohesion, but in different ways. Some 
approaches, such as Albattah and Melton [23], consider the 
direction of the dependencies. However, some other 
approaches, such as Martin [21], do not consider the 
direction of the dependencies. For this difference and other 
differences between the presented approaches, it is expected 
to find distinct cohesion assessment values for P1. 
Again, all calculations are made based on our own 
understanding of each approach. 
 
(10) 
(11) 
(12) 
(13) 
66
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

 
Figure 1. The general example. 
Table II presents the cohesion values of package P1 for 
the different approaches. 
TABLE II.  
COHESION VALUES OF THE PRESENTED APPROACHES. 
Although all the presented approaches have the same 
range of cohesion values except Martin’s approach [21], 
they end up with different cohesion values for the same 
package, i.e., P1 in Figure 1. For example, the approaches 
by Bauer and Trifu [28] and Tagoug [30] assess the 
cohesion of P1 as relatively high. In contrast, the approach 
by Albattah and Melton [23] assesses the cohesion of P1 as 
poor.  
This simple comparison raises a question about the 
theory behind these different approaches. The distinct 
evaluation results for the same package means that the 
presented approaches rely on different views of cohesion. 
These views can be noticed by investigating the presented 
approaches. We believe cohesion has different types or parts 
and some approaches focus only on one part. This can lead 
to misleading cohesion assessments. Cohesion has three 
different concepts that led to different approaches. The first 
concept considers cohesion as an internal property of a 
package that can be measured from inside the package only, 
such as the approach by Martin [21]. The second concept 
considers cohesion as a property that can be measured from 
outside the package, such as the approach by Ponisio and 
Nierstrasz [22]. The third concept considers cohesion to be 
measured from both inside and outside the package, such as 
the approach by Albattah and Melton [23].  
These three concepts represent three scopes where 
cohesion has been measured in the presented approaches. 
The scope of package cohesion can be used to classify the 
presented approaches. Table III presents this classification 
based on the scope of cohesion used in each approach, i.e., 
internal, external, or both. 
TABLE III.  
 CLASSIFICATION OF THE PRESENTED APPROACHES. 
Approach 
Method 
Scope of Cohesion 
Internal 
External 
Misic [19] 
External Objective 
 
✓ 
Ponisio and 
Nierstrasz [22] 
Common Use of 
the package 
 
✓ 
Martin [21] 
Relational 
Cohesion 
✓ 
 
Zhou et al. [24] 
Similar Context 
Cohesiveness 
✓ 
✓ 
Abdeen et al. 
[25] 
Dependency 
Analysis 
✓ 
 
Bauer and Trifu 
[28] 
Average Cohesion 
✓ 
 
Seng et al. [29] 
Dependency 
Analysis 
✓ 
 
Tagoug [30] 
Interactions inside 
the package 
✓ 
 
Albattah and 
Melton [23] 
Common Reuse & 
Common Closure 
✓ 
✓ 
 
The classification in Table III can reveal, somehow, the 
reason behind the diversity of package cohesion approaches 
that led to distinct results in Table II. Package cohesion has 
been viewed in different ways. It is worth saying that all the 
views may be right but they are different. This leads to the 
idea that there is more than one type of cohesion. The 
previous research works treated cohesion as one type or one 
concept, except for the research carried out by Albattah and 
Melton [23], and this was not accurate in our opinion.  
We support the idea of Albattah and Melton [23] that is 
presented in this paper about cohesion. They defined 
cohesion as an internal property of the package and it has 
two different types. The first type can be measured from 
outside the package and it represents how well the classes in 
Approach 
Cohesion 
Metric 
Value 
Min 
Max 
Misic [19] 
Ψ(S) 
0.33 
0 
1 
Ponisio and 
Nierstrasz [22] 
CU 
0.125 
0 
1 
Martin [21] 
H 
1.25 
> 0 
N(N-1)* 
Zhou et al. [24] 
SCC(p) 
0.36 
0 
1 
Abdeen et al. [25] 
CohesionQ(p) 
0.29 
0 
1 
Bauer and Trifu 
[28] 
avgCohesion(D) 
0.67 
0 
1 
Seng et al. [29] 
cohesion(s) 
0.25 
0 
1 
Tagoug [30] 
C(E) 
0.67 ** 
0 
1 
Albattah and 
Melton [23] 
CH 
0 
0 
1 
* N: number of classes in the package  
**Assuming that all the connections are instance connections with 0.7 
weights. 
67
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

the package cooperate to provide a service to classes outside 
the package. The second type measures how well the classes 
in the package are closed in using classes in other packages. 
This type represents the closure of the package’s classes 
against the same kind of changes, which is the same set of 
depended-upon packages. 
We believe cohesion is affected by internal and external 
factors and it should be treated based on this concept for 
accurate assessments. On the other hand, the generalised 
term of “cohesion” should not be used if the approach only 
relies on one consideration, i.e., internal or external. Terms 
such as “Common Closure Cohesion” and “Common Reuse 
Cohesion” can be used to describe the approach that relies 
on 
one 
consideration, 
i.e., 
internal 
and 
external, 
respectively. It is worth saying that Martin [21] has 
established a theory behind the internal and external factors 
by presenting the three package cohesion principles already 
discussed in Section II. Moreover, Martin’s cohesion 
principles have been used to distinguish between package 
cohesion types in our previous work, Albattah and Melton 
[23]. 
V. 
CONCLUSION AND FUTURE WORK 
In this paper, a preliminary research survey on package 
cohesion approaches is presented. The survey shows that 
there is a rich variety of package cohesion understanding, 
which has led to the production of different package 
cohesion metrics in which each of them is based on a 
specific view of cohesion. We believe that there are 
significant differences in these metrics.  Thus, the metrics of 
these approaches measure different things. The example 
given in the paper shows different values of cohesion and 
motivates us to classify the presented approaches. A 
preliminary classification reveals the reason behind the 
diversity of package cohesion approaches that led to distinct 
results in the given example. Obviously, the scope of 
cohesion is the foundation for this classification. We 
conclude that cohesion is more than one part and the term of 
“cohesion” should not be used unless the internal and 
external considerations are taken into account. Otherwise, 
terms such as “Common Closure Cohesion” and “Common 
Reuse Cohesion” can be used to describe the approach that 
relies on one consideration, i.e., internal and external, 
respectively. 
In future work, we plan to examine the role of package 
cohesion in predicting software maintainability and software 
reusability. 
REFERENCES 
 
[1] S. R. Chidamber and C. F. Kemerer, "A metrics suite for 
object oriented design." IEEE Transactions on Software 
Engineering, 20.6 (1994): 476-493. 
[2] V. Basili, "Evolving and packaging reading technologies." 
Journal of Systems and Software 38.1 (1997): 3-12. 
[3] L. Briand, J. Daly, and Jürgen Wüst, "A unified framework 
for cohesion measurement in object-oriented systems." 
Empirical Software Engineering 3.1 (1998): 65-117. 
[4] L. Briand, S. Morasca, and V. Basili, "Measuring and 
assessing maintainability at the end of high level design." 
Conference on Software Maintenance Proceedings, 1993. 
CSM-93 (pp. 88-87), IEEE, 1993. 
[5] B. Henderson-Sellers, L. Constantine, and I. Graham, 
"Coupling and cohesion (towards a valid metrics suite for 
object-oriented analysis and design)." Object Oriented 
Systems 3.3 (1996): 143-158. 
[6] S. Orlov and A. Vishnyakov, "Metric Suite Selection Methods 
for Software Development of Logistics and Transport 
Systems." Proceedings of the 11th International Conference 
"Reliability 
and 
Statistics 
in 
Transportation 
and 
Communication" (RelStat'11), 19-22 October 2011, Riga, 
Lativia, p.301-310. 
[7] J. Eder, G. Kappel, and M. Schrefl, "Coupling and cohesion 
in object-oriented systems." Technical Reprot, University of 
Klagenfurt, Austria (1994). 
[8] Y. Lee, B. Liang, S. Wu, and F. Wang, "Measuring the 
coupling and cohesion of an object-oriented program based on 
information flow." In Proc. International Conference on 
Software Quality, Maribor, Slovenia, 1995, (pp. 81-90). 
[9] G. Gui and P. Scott, "Coupling and cohesion measures for 
evaluation of component reusability." Proceedings of the 
2006 International workshop on Mining software repositories, 
2006, (pp. 18-21). ACM, 2006. 
[10] M. Hitz, and B. Montazeri, "Measuring coupling and 
cohesion in object-oriented systems." Proceedings of the 
International Symposium on Applied Corporate Computing. 
Vol. 50. 1995. 
[11] W. Li and S. Henry, "Maintenance metrics for the object 
oriented paradigm." Proceedings of First International 
Software Metrics Symposium, 1993, (pp. 52-60), IEEE, 1993. 
[12] S. Chidamber and C. Kemerer, “Towards a metrics suite for 
object oriented design.” Vol. 26. No. 11 , 1991, (pp. 197-211). 
ACM. 
[13] J. Bieman and Byung-Kyoo Kang, "Cohesion and reuse in an 
object-oriented 
system." 
ACM 
SIGSOFT 
Software 
Engineering Notes. Vol. 20. No. SI. ACM, 1995. 
[14] J. Bieman and Linda M. Ott, "Measuring functional 
cohesion." IEEE Transactions on Software Engineering, Vol. 
20, No. 8, (1994): (pp 644-657). 
[15] L. Etzkorn, S. Gholston, J. Fortune, C. Stein, D. Utley, P. 
Farrington, and G. Cox, "A comparison of cohesion metrics 
for object-oriented systems." Information and Software 
Technology Vol. 46, No. 10, (2004): (pp 677-687). 
[16] H. Chae, Y. Kwon, and Doo-Hwan Bae, "A cohesion measure 
for 
object-oriented 
classes." 
Software-Practice 
and 
Experience, Vol. 30, No.12,  (2000): (pp 1405-1432).  
[17] L. Ott, , J. Bieman, B. Kang, and B. Mehra, "Developing 
measures of class cohesion for object-oriented software." In 
Proc. Annual Oregon Workshop on Software Merics 
(AOWSM'95), vol. 11. 1995. 
[18] J. Bansiya, L. Etzkorn, C. Davis, and W. Li, "A class 
cohesion metric for object-oriented designs." Journal of 
Object-Oriented Programming, Vol. 11, No. 8, (1999): (pp 
47-52). 
[19] V. Misic, "Cohesion is structural, coherence is functional: 
Different views, different measures." Proceedings of the 
Seventh International Software Metrics Symposium, 2001, 
(pp. 135-144), METRICS. IEEE, 2001. 
[20] B. Xu, Z. Chen, and J. Zhao, "Measuring cohesion of 
packages in Ada95." ACM SIGAda Ada Letters, Vol. 24, 
No.1, (2004): (pp 62-67). 
68
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

[21] R. C. Martin, Agile software development: principles, 
patterns, and practices. Prentice Hall PTR, 2003. 
[22] L. Ponisio and O. Nierstrasz, “Using contextual information 
to assess package cohesion”, Technical Report No. IAM-06-
002, 2006, Institute of Applied Mathematics and Computer 
Sciences, University of Berne, 2006. 
[23] W. 
Albattah 
and 
A. 
Melton, 
“Package 
cohesion 
classification”, in: Software Engineering and Service Science 
(ICSESS), 2014 5th IEEE International Conference on, IEEE, 
2014, (pp. 1–8).  
[24] T. Zhou, B. Xu, L. Shi, Y. Zhou, and L. Chen, "Measuring 
package cohesion based on context." IEEE International 
Workshop in Semantic Computing and Systems, 2008. 
WSCS'08, (pp. 127-132), IEEE, 2008. 
[25] H. Abdeen, S. Ducasse, H. Sahraoui, and I. Alloui, 
"Automatic package coupling and cycle minimization." 16th 
Working Conference on Reverse Engineering, 2009, (pp. 103-
112), WCRE'09. IEEE, 2009. 
[26] T. Biggerstaff and A. Perlis, "Software reusability: vol. 1, 
concepts and models." (1989). 
[27] L. Briand, S. Morasca, and V. Basili, "Property-based 
software engineering measurement." IEEE Transactions on 
Software Engineering, Vol.22, No.1, (1996): (pp 68-86). 
[28] M. Bauer and M. Trifu, "Architecture-aware adaptive 
clustering of OO systems." Eighth European Conference on 
Software Maintenance and Reengineering Proceedings 2004, 
CSMR 2004, (pp. 3-14), IEEE, 2004. 
[29] O. Seng, M. Bauer, M. Biehl, and G. Pache, "Search-based 
improvement of subsystem decompositions." In Proceedings 
of the 7th annual conference on Genetic and evolutionary 
computation, 2005, (pp. 1045-1051), ACM, 2005. 
[30] N. Tagoug, "Object-oriented system decomposition quality.", 
7th IEEE International Symposium on High Assurance 
Systems Engineering Proceedings, 2002, (pp. 230-235), 
IEEE, 2002. 
 
69
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

