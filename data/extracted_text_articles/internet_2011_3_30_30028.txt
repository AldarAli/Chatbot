Class of Trustworthy Pseudo-Random Number Generators
Jacques M. Bahi∗, Jean-François Couchot∗, Christophe Guyeux∗and Qianxue Wang∗
∗University of Franche-Comte
Computer Science Laboratory LIFC, Belfort, France
Email:{jacques.bahi, jean-francois.couchot, christophe.guyeux, qianxue.wang}@univ-fcomte.fr
Abstract—With the widespread use of communication tech-
nologies, cryptosystems are therefore critical to guarantee se-
curity over open networks as the Internet. Pseudo-random
number generators (PRNGs) are fundamental in cryptosystems
and information hiding schemes. One of the existing chaos-based
PRNGs is using chaotic iterations schemes. In prior literature,
the iterate function is just the vectorial boolean negation. In
this paper, we propose a method using Graph with strongly
connected components as a selection criterion for chaotic iterate
function. In order to face the challenge of using the proposed
chaotic iterate functions in PRNG, these PRNGs are subjected
to a statistical battery of tests, which is the well-known NIST in
the area of cryptography.
Keywords-Internet security; Chaotic sequences; Statistical
tests; Discrete chaotic iterations.
I. INTRODUCTION
Chaos and its applications in the ﬁeld of secure commu-
nication have attracted a lot of attention in various domains
of science and engineering during the last two decades. The
desirable cryptographic properties of the chaotic maps such
as sensitivity to initial conditions and random behavior have
attracted the attention of researchers to develop new PRNG
with chaotic properties. Recently, many scholars have made
an effort to investigate chaotic PRNGs in order to promote
communication security [5] [10] [14]. One of the existing
chaos-based PRNGs is using chaotic iterations schemes.
A short overview of our recently proposed PRNGs based on
Chaotic Iterations are given hereafter. In Ref. [1], it is proven
that chaotic iterations (CIs), a suitable tool for fast computing
iterative algorithms, satisﬁes the topological chaotic property,
as it is deﬁned by Devaney [7]. The chaotic behavior of CIs
is exploited in [2], in order to obtain an unpredictable PRNG
that depends on two logistic maps. The resulted PRNG shows
better statistical properties than each individual component
alone. Additionally, various chaos properties have been es-
tablished. The advantage of having such chaotic dynamics
for PRNGs lies, among other things, in their unpredictability
character. These chaos properties, inherited from CIs, are not
possessed by the two inputted generators. We have shown that,
in addition of being chaotic, this generator can pass the NIST
battery of tests, widely considered as a comprehensive and
stringent battery of tests for cryptographic applications [13].
Then, in the papers [3], [4], we have achieved to improve the
speed of the former PRNG by replacing the two logistic maps:
we used two XORshifts in [3], and ISAAC with XORshift
in [4]. Additionally, we have shown that the ﬁrst generator
is able to pass DieHARD tests [11], whereas the second one
can pass TestU01 [9].
In spite of the fact that all these previous algorithms are
parametrized with the embed PRNG, they all iterate the same
function namely, the vectorial boolean negation later denoted
as ¬. It is then judicious to investigate whether other functions
may replace the ¬ function in the above approach. In the
positive case, the user should combine its own function and its
own PRNGs to provide a new PRNG instance. The approach
developed along these lines solves this issue by providing
a class of functions whose iterations are chaotic according
to Devaney and such that resulting PRNG success statistical
tests.
The rest of this paper is organized in the following way.
In the next section, some basic deﬁnitions concerning CIs are
recalled. Then, our family of generators based on discrete
CIs is presented in Section III with some improvements.
Next, Section IV gives a characterization of functions whose
iterations are chaotic. A practical note presents an algorithm
allowing to generate some instances of such functions. These
ones are then embedded in the algorithm presented in Sect. V
where we show why generator of Sect. III is not convenient
for them. In Section VI, various tests are passed with a goal
to decide whether all chaotic functions are convenient in a
PRNG context. The paper ends with a conclusion section
where our contribution is summarized and intended future
work is presented.
II. DISCRETE CHAOTIC ITERATIONS: RECALLS
Let us denote by Ja; bK the interval of integers: {a, a +
1, . . . , b}. A boolean system (BS) is a collection of n com-
ponents. Each component i ∈ J1; nK takes its value xi among
the domain B = {0, 1}. A conﬁguration of the system
at discrete time t (also called at iteration t) is the vector
xt = (xt
1, . . . , xt
n) ∈ Bn.
The dynamics of the system is described according to a
function f : Bn → Bn such that: f(x) = (f1(x), . . . , fn(x)).
Let be given a conﬁguration x. In what follows the con-
ﬁguration N(i, x) = (x1, . . . , xi, . . . , xn) is obtained by
switching the i−th component of x. Intuitively, x and N(i, x)
are neighbors. The discrete iterations of the f function are
represented by the so called graph of iterations.
Deﬁnition 1 (Graph of iterations) In the oriented graph of
iterations, vertices are conﬁgurations of Bn and there is an
arc labeled i from x to N(i, x) iff fi(x) is N(i, x) (we
consider 1-bit transitions).
In the sequel, the strategy S = (St)t∈N is the sequence of
the components that may be updated at time t, St denotes the
t−th term of the strategy S.
Let us now introduce two important notations. ∆ is the
discrete Boolean metric, deﬁned by ∆(x, y) = 0 ⇔ x = y,
and the function Ff is deﬁned for any given application f :
Bn → Bn by
Ff : J1; nK × Bn
→
Bn
(s, x)
7→

xj.∆(s, j) + fj(x).∆(s, j)

j∈J1;nK ,
72
INTERNET 2011 : The Third International Conference on Evolving Internet
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-141-0

where the point and the line above delta are multiplication and
negation respectively. With such a notation, conﬁgurations are
deﬁned for times t = 0, 1, 2, . . . by:
 x0 ∈ Bn and
xt+1 = Ff(St, xt)
(1)
Finally, iterations of (1) can be described by the following
system
 X0 = ((St)t∈N, x0) ∈ J1; nKN × Bn
Xk+1 = Gf(Xk),
(2)
such that
Gf

100
10000
100000
1000000
1000000
Speed up
10%
7.8 %
8.8 %
8.1%
9.5%
Table I: Speed up improvement from Algorithm [2]
speed up its global behavior. In such a context we take
a beneﬁt of this improvement. Table I compares these
two algorithms in terms of execution time with respect
to the number of generated elements. The improvement
is about 9%.
However as noticed in introduction, the whole (theoretical
and practical) approach is based on the negation function.
The following section studies whether other functions can
theoretically replace this one.
IV. CHARACTERIZING AND COMPUTING FUNCTIONS FOR
PRNG
This section presents other functions that theoretically
could replace the negation function ¬ in the previous algo-
rithms.
In this algorithm and from the graph point of view, iterating
the function Gf from a conﬁguration x0 and according to a
strategy (St)t∈N consists in traversing the directed iteration
graph Γ(f) from a vertex x0 following the edge labelled with
S0, S1, . . . Obviously, if some vertices cannot be reached from
other ones, their labels expressed as numbers cannot be output
by the generator. The Strongly connected component of Γ(f)
(i.e., when there is a path from each vertex to every other
one), denoted by SCC in the following [6], is then a necessary
condition for the function f. The following result shows this
condition is sufﬁcient to make iterations of Gf chaotic.
Theorem 1 (Theorem III.6, p. 91 in [8]) Let f be a func-
tion from Bn to Bn. Then Gf is chaotic according to Devaney
iff the graph Γ(f) is strongly connected.
Any function such that the graph Γ(f) is strongly connected
is then a candidate for being iterated in Gf for pseudo random
number generating. Thus, let us show how to compute a map
f with a strongly connected graph of iterations Γ(f).
We ﬁrst consider the negation function ¬. The iteration
graph Γ(¬) is obviously strongly connected: since each con-
ﬁguration (x1, . . . , xn) may reach one of its n neighbors,
there is then a bit by bit path from any (x1, . . . , xn) to any
(x′
1, . . . , x′
n). Let then Γ be a graph, initialized with Γ(¬),
the algorithm iteratively does the two following stages:
1) select randomly an edge of the current iteration graph
Γ and
2) check whether the current iteration graph without that
edge remains strongly connected (by a Tarjan algo-
rithm [15], for instance). In the positive case the edge
is removed from G,
until a rate r of removed edges is greater than a threshold
given by the user.
Formally, if r is close to 0% (i.e., few edges are removed),
there should remain about n × 2n edges (let us recall that 2n
is the amount of nodes). In the opposite case, if r is close to
100%, there are left about 2n edges. In all the cases, this step
returns the last graph Γ that is strongly connected. It is not
then obvious to return the function f whose iteration graph
is Γ.
Function f
f(x), for x in (0, 1, 2, . . . , 15)
Rate
¬
(15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0)
0%
a⃝
(15,14,13,12,11,10,9,8,7,6,7,4,3,2,1,0)
2.1%
b⃝
(14,15,13,12,11,10,9,8,7,6,5,4,3,2,1,0)
4.1%
c⃝
(15,14,13,12,11,10,9,8,7,7,5,12,3,0,1,0)
6.25%
d⃝
(14,15,13,12,9,10,11,0,7,2,5,4,3,6,1,8)
16.7%
e⃝
(11,2,13,12,11,14,9,8,7,14,5,4,1,2,1,9)
16.7%
f⃝
(13,10,15,12,3,14,9,8,6,7,4,5,11,2,1,0)
20.9%
g⃝
(13,7,13,10,11,10,1,10,7,14,4,4,2,2,1,0)
20.9%
h⃝
(7,12,14,12,11,4,1,13,4,4,15,6,8,3,15,2)
50%
i⃝
(12,0,6,4,14,15,7,15,11,1,14,2,7,4,7,9)
75%
Table II: Functions with SCC graph of iterations
However, such an approach suffers from generating many
functions with similar behavior due to the similarity of their
graph. More formally, let us recall the graph isomorphism
deﬁnition that resolves this issue. Two directed graphs Γ1
and Γ2 are isomorphic if there exists a permutation p from
the vertices of Γ1 to the vertices of Γ2 such that there is an
arc from vertex u to vertex v in Γ1 iff there is an arc from
vertex p(u) to vertex p(v) in Γ2.
Then, let f be a function, Γ(f) be its iteration graph, and p
be a permutation of vertices of Γ(f). Since p(Γ(f)) and Γ(f)
are isomorphic, then iterating f (i.e., traversing Γ(f)) from
the initial conﬁguration c amounts to iterating the function
whose iteration graph is p(Γ(f)) from the conﬁguration p(c).
Graph isomorphism being an equivalence relation, the sequel
only consider the quotient set of functions with this relation
over their graph. In other words, two functions are distinct if
and only if their iteration graph are not isomorphic.
Table II presents generated functions that have been ordered
by the rate of removed edges in their graph of iterations
compared to the iteration graph Γ(¬) of the boolean negation
function ¬.
For
instance
let
us
consider
the
function
g⃝
from
B4
to
B4
deﬁned
by
the
following
images:
[13, 7, 13, 10, 11, 10, 1, 10, 7, 14, 4, 4, 2, 2, 1, 0].
In
other
words, the image of 3 (0011) by g⃝ is 10 (1010): it is
obtained as the binary value of the fourth element in the
second list (namely 10). It is not hard to verify that Γ( d⃝)
is SCC. Next section gives practical evaluations of these
functions.
V. MODIFYING THE PRNG ALGORITHM
A coarse attempt could directly embed each function of
table II in the iterate_G function deﬁned in Algorithm 3. Let
us show the drawbacks of this approach on a more simpler
example.
Let us consider for instance n is two, the negation function
on B2, and the function f deﬁned by the list [1, 3, 0, 2]
(i.e., f(0, 0) = (0, 1), f(0, 1) = (1, 1), f(1, 0) = (0, 0), and
f(1, 1) = (1, 0)) whose iterations graphs are represented in
Fig. 1. The two graphs are strongly connected and thus the
vectorial negation function should theoretically be replaced
by the function f.
In the graph of iterations Γ(¬) (Fig. 1a), let us compute the
probability P t
¬(X) to reach the node X in t iterations from
the node 00. Let X0, X1, X2, X3 be the nodes 00, 01, 10
and 11. For i ∈ J0, 3K, P 1
¬(Xi), are respectively equal to 0.0,
0.5, 0.0, 0.5. In two iterations P 2
¬(Xi) are 0.5, 0.0, 0.5, 0.0.
It is obvious to establish that we have P 2t(Xi) = P 0(Xi)
74
INTERNET 2011 : The Third International Conference on Evolving Internet
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-141-0

0 0
0 1
1 0
1 1
(a) Negation
0 0
0 1
1 1
1 0
(b) (1, 3, 0, 2)
Figure 1: Graphs of Iterations
Name
Deviation
Suff. number of it.
a⃝
8.1%
167
b⃝
1%
105
c⃝
18%
58
d⃝
1%
22
e⃝
24%
19
f⃝
1%
14
g⃝
20%
6
h⃝
45.3%
7
i⃝
53.2%
14
Table III: Deviation with Uniform Distribution
and P 2t+1(Xi) = P 1(Xi) for any t ∈ N. Then in k or k + 1
iterations all these probabilities are equal to 0.25.
Let us apply a similar reasoning for the function f deﬁned
by [1, 3, 0, 2]. In its iterations graph Γ(f) (Fig. 1b), and with
Xi deﬁned as above, the probabilities P 1
f (Xi) to reach the
node Xi in one iteration from the node 00 are respectively
equal to 0.5, 0.5, 0.0, 0.0. Next, probabilities P 2
f (X) are 0.25,
0.5, 0.25, 0.0. Next, P 3
f (X) are 0.125, 0.375, 0.375, 0.125.
For each iteration, we compute the average deviation rate Rt
with 0.25 as follows.
Rt =
Σ3
i=0 | P t
f(Xi) − 0.25 |
4
.
The higher is this rate, the less the generator may uniformly
reach any Xi from 00. For this example, it is necessary to
iterate 14 times in order to observe a deviation from 0.25
less than 1%. A similar reasoning has been applied for all the
functions listed in Table II. The table III summarizes their
deviations with uniform distribution and gives the smallest
iterations number the smallest deviation has been obtained.
With that material we present in Algorithm 4 the method
that allows to take any chaotic function as the core of a pseudo
random number generator. Among the parameters, it takes the
number b of minimal iterations that have to be executed to
get a uniform like distribution. For our experiments b is set
with the value given in the third column of Table III.
Compared to the algorithm 2 parameters of this one are the
function f to embed and the smallest number of time steps
Gf is iterated. First, the number of iterations is either b or
b + 1 depending on the value of the XORshift output (if the
next value . Next, a loop that iterates Gf is executed.
In this example, n and b are equal to 4 for easy understand-
ing. The initial state of the system x0 can be seeded by the
decimal part of the current time. For example, the current
time in seconds since the Epoch is 1237632934.484088,
so t = 484088. x0 = t mod 16 in binary digits, then
x0 = 0100. m and S can now be computed from XORshift.
Input: a function f, an iteration number b, an initial
state x0 (n bits)
Output: a state x (n bits)
x ← x0;
k ← b + (XORshift() mod 2);
for i = 0, . . . , k − 1 do
s ← XORshift() mod n;
x ← Ff(s, x);
end
return x;
Algorithm 4: modiﬁed PRNG with various functions
Numbers
0
1
2
3
4
5
6
Successors
0
1
2
3
4
5
6
Occurrences
10
20
30
40
(a) Function e⃝
Numbers
0
1
2
3
4
5
6
Successors
0
1
2
3
4
5
6
Occurrences
10
20
30
40
(b) Function f⃝
Figure 2: Repartition of function outputs.
• f = [14,15,13,12,11,10,9,8,7,6,5,4,3,2,1,0]
• k = 4, 5, 4,...
• s = 2, 4, 2, 3, , 4, 1, 1, 4, 2, , 0, 2, 3, 1,...
Chaotic iterations are done with initial state x0, the mapping
function f, and strategy s1, s2...The result is presented in
Table IV. Let us recall that sequence k gives the states xt to
return: x4, x4+5, x4+5+4...Successive stages are detailed in
Table IV.
To illustrate the deviation, Figures 2a and 2b represent the
simulation outputs of 5120 executions with b equal to 40 for
e⃝ and f⃝ respectively. In these two ﬁgures, the point (x, y, z)
can be understood as follows. z is the number of times the
value x has been succedded by the value y in the considered
generator. These two ﬁgures explicitly conﬁrm that outputs
of functions f⃝ are more uniform that these of the function
e⃝. In the former each number x reaches about 20 times each
number y whereas in the latter, results vary from 10 to more
that 50.
75
INTERNET 2011 : The Third International Conference on Evolving Internet
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-141-0

k
4
5
4
s
2
4
2
3
4
1
1
4
2
0
2
3
1
f(4)
f(0)
f(0)
f(4)
f(6)
f(7)
f(15)
f(7)
f(7)
f(2)
f(0)
f(4)
f(6)
f
1
1
1
1
1
1
0
1
1
1
1
1
1
0
1
1
0
0
0
0
0
0
1
1
0
0
1
1
1
1
0
0
0
0
0
0
1
1
0
1
0
0
1
1
0
0
0
0
1
0
1
1
x0
x4
x9
x13
4
0
0
4
6
6
7
15
7
7
7
2
0
4
6
14
14
0
0
1−→ 1
1−→ 0
0
1−→ 1
1
1
2−→ 0
2−→ 1
1
2−→ 0
0
2−→ 1
1
0
3−→ 1
1
1
3−→ 0
3−→ 1
1
0
4−→ 0
0
4−→ 1
4−→ 0
0
0
Table IV: Application example
VI. EXPERIMENTS
A convincing way to prove the quality of the produced se-
quences is to confront them with the NIST (National Institute
of Standards and Technology) Statistical Test Suite SP 800-
22 [13]. This is a statistical package consisting of 15 tests that
focus on a variety of different types of non-randomness that
could occur in a (arbitrarily long) binary sequences produced
by a pseudo-random number generators.
For all 15 tests, the signiﬁcance level α was set to 1%. If
a p-value is greater than 0.01, the keystream is accepted as
random with a conﬁdence of 99%; otherwise, it is considered
as non-random. For each statistical test, a set of p-values is
produced from a set of sequences obtained by our generator
(i.e., 100 sequences are generated and tested, hence 100 p-
values are produced).
Empirical results can be interpreted in various ways. In
this paper, we check whether PT (P-values of p-values),
which arise via the application of a chi-square test, were all
higher than 0.0001. This means that all p-values are uniformly
distributed over (0, 1) interval as expected for an ideal random
number generator.
Table V shows PT of the sequences based on discrete
chaotic iterations using different “iteration” functions. If there
are at least two statistical values in a test, the test is marked
with an asterisk and the average value is computed to charac-
terize the statistical values. Here, NaN means a warning that
test is not applicable because of an insufﬁcient number of
cycles. Time (in seconds) is related to the duration needed by
each algorithm to generate a 108 bits long sequence. The test
has been conducted using the same computer and compiler
with the same optimization settings for both algorithms, in
order to make the test as fair as possible.
Firstly, the computational time in seconds has increased due
to the growth of the sufﬁcient iteration numbers, as precised
in Table III. For instance, the fastest generator is g⃝ since
each new number generation only requires 6 iterations. Next,
concerning the NIST tests results, best situations are given
by b⃝, d⃝ and f⃝. In the opposite, it can be observed that
among the 15 tests, less than 5 ones are a successful for other
functions. Thus, we can draw a conclusion that, b⃝, d⃝, and
f⃝ are qualiﬁed to be good PRNGs with chaotic property.
NIST tests results are not a surprise: b⃝, d⃝, and
f⃝ have
indeed a deviation less than 1% with the uniform distribution
as already precised in Table III. The rate of removed edge in
the graph Γ(¬) is then not a pertinent criteria compared to the
deviation with the uniform distribution property: the function
a⃝ whose graph Γ( a⃝) is Γ(¬) without the edge 1010 → 1000
(i.e., with only one edge less than Γ(¬)) has dramatic results
compared to the function f⃝ with many edges less.
Let us then try to give a characterization of convenient
function. Thanks to a comparison with the other functions, we
notice that b⃝, d⃝, and f⃝ are composed of all the elements of
J0; 15K. It means that b⃝, d⃝, and f⃝, and even the vectorial
boolean negation function are arrangements of J0; 2nK (n = 4
in this article) into a particular order.
VII. CONCLUSION
In this work, we ﬁrst have formalized the PRNG already
presented in a previous work. It results a new presentation
that has allowed to optimize some part and thus has led
to a more efﬁcient algorithm. But more fundamentally, this
PRNG closely follows iterations that have been proven to be
topological chaotic.
By considering a characterization of functions with topo-
logical chaotic behavior (namely those with a strongly con-
nected graph of iterations), we have computed a new class of
PRNG based on instances of such functions. These functions
have been randomly generated starting from the negation
function. Then an a posteriori analysis has checked whether
any number may be equiprobabilistically reached from any
other one.
The NIST statistical test has conﬁrmed that functions
without equiprobabilistical behavior are not good candidates
for being iterated in our PRNG. In the opposite, the other
ones have topological chaos property and success all the
NIST tests. To summarize the approach, all our previous
approaches were based on only one function (namely the
negation function) whereas we provide now a class of many
trustworthy PRNG.
Future work are mainly twofold. We will ﬁrstly study suf-
ﬁcient conditions to obtain functions with the two properties
of equiprobability and strongly connectivity of its graph of
iterations. With such a condition any user should choose
its own trustworthy PRNG. Dually, we will continue the
evaluation of randomness quality by checking other statistical
series like DieHard[11], TestU01 [9]...on newly generated
76
INTERNET 2011 : The Third International Conference on Evolving Internet
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-141-0

Method
a⃝
b⃝
c⃝
d⃝
e⃝
f⃝
g⃝
h⃝
i⃝
Frequency (Monobit) Test
0.00000
0.45593
0.00000
0.38382
0.00000
0.61630
0.00000
0.00000
0.00000
Frequency Test within a Block
0.00000
0.55442
0.00000
0.03517
0.00000
0.73991
0.00000
0.00000
0.00000
Cumulative Sums (Cusum) Test*
0.00000
0.56521
0.00000
0.19992
0.00000
0.70923
0.00000
0.00000
0.00000
Runs Test
0.00000
0.59554
0.00000
0.14532
0.00000
0.24928
0.00000
0.00000
0.00000
Test for the Longest Run of Ones in a Block
0.20226
0.17186
0.00000
0.38382
0.00000
0.40119
0.00000
0.00000
0.00000
Binary Matrix Rank Test
0.63711
0.69931
0.05194
0.16260
0.79813
0.03292
0.85138
0.12962
0.07571
Discrete Fourier Transform (Spectral) Test
0.00009
0.09657
0.00000
0.93571
0.00000
0.93571
0.00000
0.00000
0.00000
Non-overlapping Template Matching Test*
0.12009
0.52365
0.05426
0.50382
0.02628
0.50326
0.06479
0.00854
0.00927
Overlapping Template Matching Test
0.00000
0.73991
0.00000
0.55442
0.00000
0.45593
0.00000
0.00000
0.00000
Maurer’s “Universal Statistical” Test
0.00000
0.71974
0.00000
0.77918
0.00000
0.47498
0.00000
0.00000
0.00000
Approximate Entropy Test
0.00000
0.10252
0.00000
0.28966
0.00000
0.14532
0.00000
0.00000
0.00000
Random Excursions Test*
NaN
0.58707
NaN
0.41184
NaN
0.25174
NaN
NaN
NaN
Random Excursions Variant Test*
NaN
0.32978
NaN
0.57832
NaN
0.31028
NaN
NaN
NaN
Serial Test* (m=10)
0.11840
0.95107
0.01347
0.57271
0.00000
0.82837
0.00000
0.00000
0.00000
Linear Complexity Test
0.91141
0.43727
0.59554
0.43727
0.55442
0.43727
0.59554
0.69931
0.08558
Success
5/15
15/15
4/15
15/15
3/15
15/15
3/15
3/15
3/15
Computational time
66.0507
47.0466
32.6808
21.6940
20.5759
19.2052
16.4945
16.8846
19.0256
Table V: NIST SP 800-22 test results (PT )
functions.
REFERENCES
[1] J. M. Bahi and C. Guyeux.
Topological chaos and chaotic
iterations, application to hash functions. In WCCI’10, IEEE
World Congress on Computational Intelligence, pages 1–7,
Barcelona, Spain, July 2010. Best paper award.
[2] J. M. Bahi, C. Guyeux, and Q. Wang.
A novel pseudo-
random generator based on discrete chaotic iterations.
In
INTERNET’09, 1-st Int. Conf. on Evolving Internet, pages 71–
76, Cannes, France, August 2009.
[3] J. M. Bahi, C. Guyeux, and Q. Wang. Improving random num-
ber generators by chaotic iterations. application in data hiding.
In ICCASM 2010, Int. Conf. on Computer Application and
System Modeling, pages V13–643–V13–647, Taiyuan, China,
October 2010.
[4] J. M. Bahi, C. Guyeux, and Q. Wang.
A pseudo random
numbers generator based on chaotic iterations. application to
watermarking. In WISM 2010, Int. Conf. on Web Information
Systems and Mining, volume 6318 of LNCS, pages 202–211,
Sanya, China, October 2010.
[5] S. Behnia, A. Akhavan, A. Akhshani, and A. Samsudin.
A novel dynamic model of pseudo random number gener-
ator.
Journal of Computational and Applied Mathematics,
235(12):3455–3463, 2011.
[6] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein.
Introduction to Algorithms. MIT press, 3rd ed. edition, 2009.
[7] R. L. Devaney. An Introduction to Chaotic Dynamical Systems.
Redwood City: Addison-Wesley, 2nd edition, 1989.
[8] C. Guyeux. Le désordre des itérations chaotiques et leur utilité
en sécurité informatique. PhD thesis, Université de Franche-
Comté, 2010.
[9] P. L’Ecuyer and R. J. Simard. Testu01: A C library for empirical
testing of random number generators. ACM Trans. Math. Softw.,
33(4), 2007.
[10] N. Liu.
Pseudo-randomness and complexity of binary se-
quences generated by the chaotic system. Communications in
Nonlinear Science and Numerical Simulation, 16(2):761–768,
2011.
[11] G. Marsaglia.
Diehard: a battery of tests of randomness.
1414203, 1996.
[12] G. Marsaglia. Xorshift rngs. Journal of Statistical Software,
8(14):1–6, 2003.
[13] A. Rukhin, J. Soto, J. Nechvatal, M. Smid, E. Barker, S. Leigh,
M. Levenson, M. Vangel, D. Banks, A. Heckert, J. Dray, and
S. Vo. A Statistical Test Suite for Random and Pseudorandom
Number Generators for Cryptographic Applications. National
Institute of Standards and Technology, April 2010.
[14] Fuyan Sun and Shutang Liu.
Cryptographic pseudo-random
sequence from the spatial chaotic map.
Chaos, Solitons &
Fractals, 41(5):2216–2219, 2009.
[15] R. Tarjan. Depth-ﬁrst search and linear graph algorithms. SIAM
Journal on Computing, 1(2):146–160, 1972.
77
INTERNET 2011 : The Third International Conference on Evolving Internet
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-141-0

