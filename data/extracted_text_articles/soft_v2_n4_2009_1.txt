Design of a Decoupled Sensor Network Architecture
Based on Information Exchanges
Eli De Poorter
Ingrid Moerman
Piet Demeester
Ghent University - IBBT, Department of Information Technology (INTEC)
Gaston Crommenlaan 8, Bus 201, 9050 Ghent, Belgium
Email: eli.depoorter@intec.ugent.be
Abstract
Sensor networks are used for simple monitoring appli-
cations, but also for complex applications, such as wire-
less building automation or medical assistance.
Cur-
rent layered architectures do not support the dynamic and
heterogeneous nature of these networks. Therefore, we
present an alternative architecture that decouples protocol
logic and packet representation. Using this system, multi-
ple information exchanges are automatically combined in
a single packet. In addition, the system dynamically selects
the most optimal network protocols and supports system-
wide quality-of-service.
Thus, our architecture is bet-
ter suited for next-generation applications. We illustrate
our architecture with several code examples, and prove
that our architecture is much more scalable, in terms of
memory requirements, energy requirements and process-
ing overhead, than tradition system architectures.
Keywords: wireless sensor networks, sensornet architec-
ture; system architecture; QoS; energy efﬁciency; heterogene-
ity; protocol selection
1
Introduction
Sensor nodes are small and cheap devices that can mon-
itor their environment. They are equipped with a simple
radio to communicate with other sensor nodes. Due to their
low cost, many sensor nodes can be distributed over an area.
Over the last years, many wireless sensor networks (WSNs)
have been deployed to monitor nature and ofﬁce environ-
ments [2].
This article extends the paper ‘An Information Driven Sen-
sornet Architecture’ [1]. It adds illustrative code examples,
it elaborates on several design choices and it provides addi-
tional evaluation results.
Due to these successes, other application domains have
expressed a strong interest in using WSNs for more com-
plex tasks. More sophisticated applications, such as process
monitoring and control, wireless building automation, med-
ical monitoring, disaster intervention or asset tracking, also
beneﬁt greatly from the use of many cheap sensor devices.
However, the number of successful deployments of these
applications is far less [3].
These next-generation applications impose many net-
work requirements which are not found in traditional
WSNs.
• To provide sufﬁcient end-user support, a WSN must be
easy to update and maintain. Run-time addition of new
services and network protocols should be supported.
• WSNs will become heterogeneous [4], containing both
simple nodes (such as light switches) and more com-
plex nodes (such as heating controllers).
• Additionally, QoS requirements can no longer be ig-
nored [5]. Medical, security and surveillance applica-
tions require that each application has its own set of
speciﬁc QoS requirements.
• Since future applications will require even smaller
nodes, new ways have to be found to ensure that net-
work protocols have a very small memory footprint.
• Since most sensor nodes are battery powered, energy
efﬁciency remains very important.
At present, there is no architecture that supports all of
these challenges. As stated by Culler et. al: “the primary
factor currently limiting progress in sensornets is not any
speciﬁc technical challenge but is instead the lack of an
overall sensor network architecture” [6].
Therefore, in this paper, we present an information
driven architecture (‘IDRA’) for wireless sensor networks.
This framework is speciﬁcally designed to support next-
generation WSN applications.
It takes into account the
heterogeneity of the sensor nodes and supports energy-
efﬁciency and QoS at an architectural level. What’s more,
300
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

the proposed architecture can be made fully compatible
with existing legacy sensor networks.
The remainder of this paper is organized as follows. In
Section 2, we discuss the design philosophy behind our in-
formation driven system architecture. Section 3 clariﬁes
how such an information driven architecture can be imple-
mented. Next, in Section 4, we demonstrate how this archi-
tecture can be used to support energy efﬁciency, QoS, het-
erogeneity and legacy networks. In Section 5, we discusses
possible shortcomings of the architecture. We describe our
implementation experiences in Section 6 and evaluate the
performance of our system in Section 7. Next, in Section 8,
we compare the architecture with existing sensornet archi-
tectures. Finally, Section 9 concludes this paper.
2
What is an information driven architec-
ture?
The main responsibility of a network protocol is to en-
sure that information is relayed to the correct destination.
However, in practice, a network protocol has many respon-
sibilities that are not directly related with its main func-
tion. Each protocol layer must (i) deﬁne a message format
(including header and trailer ﬁelds), (ii) provide buffers to
temporarily store packets and (iii) gather information from
other nodes.
We argue that this approach is very inefﬁcient. It makes
no sense that every individual protocol layer has to bear
the burden of gathering information, providing buffers and
implementing header manipulations. Common sense indi-
cates that such functions, which are implemented multiple
times in the system, should be implemented in a shared li-
brary. Furthermore, the same information is often gathered
by multiple protocols, each time resulting in an additional
information exchange.
Therefore, we propose a system in which protocol design
is based on ‘information exchanges’. The role of a network
protocol is simpliﬁed to its 2 main tasks: sending informa-
tion and interacting with the relayed information. Packet
creation and buffer provisioning are delegated to the archi-
tecture. This way, network protocols are simpler and require
less memory.
3
Design of an information driven architec-
ture
In this section, we describe how such an information
driven architecture can be implemented. A conceptual rep-
resentation is given in Figure 1.
Activate 
protocol
Pluggable protocols
Send
Parameter
Receive
Parameter 
Hardware Abstraction Layer (HAL)
Parameter 
sending
System
Parameter 
dispatching
Protocol selector
Parameter
Parameter
Parameter flow
Packet flow
Configuration
Neighbor 
discovery
MAC
Parameter 
Extraction
Shared queue
Routing
Application
Register
protocol
Packet 
Creation
All interactions with packets happen through a packet façade. Thus, 
protocols do not require any knowledge about how the actual packet 
is constructed
...
Figure 1. In an information driven architecture,
protocols exchange information with the system,
and rely on the system to create and send pack-
ets.
3.1
Information exchanges
Network protocols often exchange information with a re-
mote node. Typical examples of exchanged information are:
• measured data values, such as the local temperature;
• status updates, such as the remaining battery capacity;
• or control information such as a route-request.
Using our information driven approach, network protocols
do not create a new packet to send these types of informa-
tion to a remote node. Instead, they rely on the system to
send and receive information.
To send information to a remote node, the protocol hands
over an information parameter to the system, together with
the required destination (Fig. 1, ‘Parameter sending’). The
system will create a new packet and ensures that the param-
eter is encapsulated into this packet.
To receive information from other nodes, network proto-
cols indicate to the system what type of parameters they are
interested in. Whenever a packet arrives at its ﬁnal desti-
nation, the system decapsulates the information parameters
and distributes them to the interested protocols (Fig. 1, ‘Pa-
rameter dispatching’).
301
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

The main advantages of transferring the creation of pack-
ets to the system are: (i) the system can ensure that redun-
dant control information is sent only once; (ii) protocols
are simpler since they do not need to implement memory
operations for manipulating header ﬁelds; and (iii) by com-
bining multiple information parameters into a single packet,
the number of required packets decreases drastically (Sec-
tion 4.1).
3.2
Shared queue
Traditional networks use a ‘store-and-process’ approach,
where each network protocol stores the packets in an inter-
nal queue before processing. Each protocol layer requires
these queues because packets may be passed up or down
faster than they can be processed. Thus, the total amount of
buffer memory increases linearly with the number of proto-
col layers.
In contrast, in the information driven architecture, in-
coming packets are stored in a system-wide queue (Fig. 1,
‘Shared queue’).
The system selects which packets are
ready for processing by a network protocol so that one-
after-another the protocols can process the packets.
The use of a shared, system-managed queue has several
advantages: (i) protocols are simpler and smaller since they
do not have to allocate queue memory; (ii) packets do not
need to be copied between protocols, resulting in less pro-
cessing overhead; (iii) since the queue occupation from all
protocols is averaged, less total queue memory is required;
and (iv) monitoring and managing the total number of pack-
ets in the system is simpler.
3.3
Packet fa¸cade
Traditional network protocols encapsulate packets in
header ﬁelds.
These header ﬁelds contain information
which can only be read by the protocol that created the
packet header.
In our information driven architecture, a
packet fac¸ade (Fig. 2) is responsible for packet creation.
The system uses the packet fac¸ade to create new, stan-
dardized packets. Information parameters are encapsulated
in the payload of the created packet and stored in the shared
queue.
Network protocols use the packet fac¸ade to interact with
relayed packets. Protocols add or retrieve packet attributes,
such as ‘source’, ‘destination’, ‘QoS ID’ or ‘time-to-live’.
These packet attributes fulﬁll the same role as traditional
header ﬁelds, but are more dynamic: they can be omit-
ted or added freely without redeﬁning the packet struc-
ture. Moreover, packet attributes have a system-wide sig-
niﬁcance: they can be inspected by the system or any other
protocol.
Activate 
protocol
Pluggable protocols
Send
Parameter
Receive
Parameter 
Hardware Abstraction Layer (HAL)
Parameter 
sending
System
Parameter 
dispatching
Protocol selector
Parameter
Parameter
Parameter flow
Packet flow
Configuration
Neighbor 
discovery
MAC
Parameter 
Extraction
Shared queue
Routing
Application
Register
protocol
Packet 
Creation
Through a packet façade, protocols interact with packets. Protocols 
do not require any knowledge about the actual packet construction.
MAC
Routing
...
Add / read
parameter
Packet 
façade
Select 
correct 
implemen-
tation
Network 
protocols
In an information driven a
protocols exchange inform
system, and rely on the
create and send pa
Figure 2. Through a packet fac¸ade, protocols in-
teract with packets. Protocols do not require any
knowledge about the actual packet construction.
The packet fac¸ade uses a separate ‘packet implementa-
tion’ module to convert the attributes of a packet into an ac-
tual radio packet. Thus, the system and the protocols do not
need to worry about the actual storage of the control infor-
mation associated with a packet. Developers can choose to
use one of the existing ‘packet implementation’ modules, or
provide their own (propriety) packet implementation. This
way, the packet type can be changed without any changes
to the system or the protocols: protocol logic and packet
representation are decoupled.
Using a separate packet fac¸ade has the following advan-
tages: (i) protocol development is simpliﬁed since there
is no need to deﬁne headers; (ii) packet attributes have a
system-wide signiﬁcance and can be inspected by any pro-
tocol or architecture; (iii) since protocols are not tied to a
speciﬁc packet implementation, the encompassing packet
type can easily be changed or optimized (e.g.: 6lowpan,
IEEE802.15.4 or a custom packet).
3.4
Pluggable protocols
The traditional OSI reference model [7] uses a non-
ﬂexible layered architecture: packets are sent to a prede-
termined protocol layer. In contrast, the information driven
architecture does not statically wire packets to a speciﬁc
protocol.
The system decides at run-time which proto-
cols should be selected to process incoming packets (Fig. 1,
‘Protocol selector’).
To be selected for packet processing, a protocol must
register itself by adding ﬁlters to the system. These ﬁlters
indicate for which packet types the protocol is optimized.
Through the packet fac¸ade, the system checks if the charac-
teristics of the arriving packets match any of the registered
ﬁlters, and selects the appropriate network protocols to pro-
cess the packet. When no ﬁlters match, a default routing or
MAC protocol is chosen.
This approach has the advantages that multiple, special-
ized network protocols can be combined in the same sys-
302
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

tem. For example, a routing protocol implements an efﬁ-
cient broadcast algorithm. It registers itself for all packets
that are broadcasted over the network. Another routing pro-
tocol delivers high QoS guarantees. It can add a ﬁlter to
indicate that it is optimized for routing voice packets.
‘Plugging’ in protocols, rather than statically wiring
them, has several advantages. (i) Since many applications
have diverse network requirements, the architecture is able
to dynamically change between different routing or MAC
protocols at run-time.
The optimal protocol is selected
by the system based on the network context or the packet
type [8]. (ii) Run-time insertion of protocols is supported.
(iii) Legacy systems can be supported (Section 4.4). More
system-speciﬁc implementation details can be found in Sec-
tion 6.
4
Exploiting the concept
Current system architectures are not designed to support
energy-efﬁciency, QoS, heterogeneity or legacy networks.
Traditionally, support for these advanced features is very
complex and requires major changes to the underlying sys-
tem architecture. The lack of architectural support for QoS
and heterogeneity is a major obstacle that hampers the de-
ployment of many next-generation applications for WSNs.
In the next sections, we demonstrate how these features
can easily be implemented at an architectural level in our
information driven system.
4.1
Energy eﬃciency
Since energy is scarce in sensor nodes, wireless sensor
networks aim to transmit as few packets as possible. To
this end, ‘measured data’ from different nodes can be com-
bined into a single packet by data-aggregation protocols [9].
This data-centric approach has several limitations: (i) data
aggregation is application dependent; (ii) aggregation pro-
tocols are often coupled to a speciﬁc routing protocol; (iii)
data aggregation is limited to the measured ‘data’, it does
not include other exchanged control messages; (iv) data that
originates from different applications can not be aggregated.
We claim that this approach should be broadened so that
all types of information exchanges are aggregated. Many
information exchanges between nodes are not very time-
sensitive, such as status information, remaining energy in-
formation, or low-priority routing information. As such, it
is reasonable to assume that some of these packets can be
delayed for a short amount of time before being sent. When
a protocol requests the sending of a parameter, the protocol
should also give an indication of the time-sensitivity of the
parameter.
The system collects the information parameters in the
waiting space of a central repository (Figure 3).
Delay-
tolerant parameters can remain in the waiting space for up
to a per-parameter predeﬁned period of time. Whenever
a packet is relayed through the node, all information pa-
rameters to the same ‘next hop’ or ‘destination’ address are
added to the packet. If no data has been relayed within the
allowed waiting time, the system generates a new packet
which combines all parameters that are destined for the
same node. Finally, when a packet reaches its ﬁnal destina-
tion, the system will distribute the encapsulated information
parameters to the interested protocols.
Architectural aggregation
Sh
d
Traditional system
Packet
Packet
IN
A
li
i
Packet
IN
ng
Subscribing
Application
Shared queue
stination)
priority
priority
Protocol 1
Packet 
Forwarding
Application
meter Sendin
Application
Subscribing 
Protocol 1
assifier (De
ting Space
Protocol k
…
Param
Subscribing 
Protocol k
Cla
Wai
Protocol k
Queue
(a)
(b)
Packet
OUT
Packet
OUT
(a)
(b)
Figure 3. Extending the data aggregation concept.
(a) Traditional architecture. (b) Architecture with
support for global aggregation.
For a more in-depth analysis, we refer to [10], where
it is shown that, ideally, the number of transmissions can
be lowered by a factor, equal to the number of information
parameters which can be combined in a single packet. In
contrast with traditional aggregation schemes [9, 11], this
approach is part of the architectural design. As a result, the
network developer can combine this approach with any type
of routing protocol, and information from all layers can be
aggregated, rather than just application data.
4.2
Architectural QoS
QoS guarantees are required by many medical, security,
critical monitoring and control applications. However, cur-
rent QoS research focuses mainly on one of the network lay-
ers and solves only a few of the application requirements.
As stated by Troubleyn et al. in [5], QoS should be sup-
ported in both the protocols and the architecture. Only then
can system-wide QoS be guaranteed.
The information driven architecture is very suited to sup-
port architectural QoS. Through the packet fac¸ade, the sys-
tem can read the QoS attributes of any relayed packet. Since
all packets are stored in a shared packet queue, the system
can monitor all available packets. This gives the system a
303
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

clear view on the expected delay of each packet. QoS can
be supported by giving precedence to packets with a higher
QoS level, or by intelligently dropping non-priority pack-
ets. To fulﬁll QoS requirements, a QoS protocol can put
the processing of low-priority packets on hold, even when
those packets are currently being processed by a protocol.
Finally, the architecture supports multiple protocols, so that
high-priority packets which require strict QoS guarantees
can be processed by specialized protocols.
4.3
Heterogeneity support
Applications such as process and asset monitoring, dis-
aster intervention and wireless building automation require
special devices (‘actuators’), which can interact with the en-
vironment [2, 4]. Thus, future sensor networks will consists
of nodes with strongly diverging capabilities.
In a layered architecture, every sensor node needs to sup-
port the same protocol stack. Since no protocols can be
omitted or added, the layered approach has limited support
for heterogeneity. When using an information driven archi-
tecture, packet attributes remain associated with a packet,
whether or not the protocol that added them is executed.
Thus, the system can choose to omit non-essential protocols
from nodes with little capabilities (Figure 4). The system
can also choose to execute different, more simple protocols
on lightweight nodes. These protocols can add their own
packet attributes or can reuse the packet attributes that were
added by previous protocols. This ﬂexibility ensures that
our architecture is suitable for both high capacity and low
capacity nodes.
Computing 
node
Basic modules
Advanced 
routing
Advanced 
transmission
Position 
discovery
Actuator
Basic modules
Advanced 
routing
Interest 
management
Advanced 
node
Basic modules
Advanced 
routing
Advanced 
transmission
Lightweight 
node
Basic modules
Interest cache
Data 
aggregation
Network 
Monitoring
Multi-interest
Mobility
Figure 4. Depending on their capabilities, the num-
ber of protocols can be varied
4.4
Legacy support
One of the main problems new architectures face, is that
they are not backwards compatible with existing infrastruc-
ture. Traditionally, the only solution is the installation of a
translation node through which all communication passes,
which results in a very inefﬁcient network use.
The information driven architecture allows legacy nodes
and IDRA nodes to communicate directly by supporting (i)
legacy packet types, and (ii) a legacy MAC protocol.
Legacy packets can be supported transparently for the
new protocols by providing the corresponding ‘packet im-
plementation’. This implementation should store the rele-
vant control parameters at the expected header locations of
the legacy packets.
The legacy MAC protocol can be ported to the new ar-
chitecture. By registering it as the optimal MAC protocol
for neighboring legacy nodes, the ‘protocol selector’ will
always select the correct MAC protocol to send packets to
the legacy nodes.
5
Disadvantages
In the next section, we discuss some possible disadvan-
tages of using an information driven architecture.
5.1
Protocol-deﬁned packets
In an information driven architecture, the system deﬁnes
how packets are constructed. In addition, messages deﬁned
by the radio, such as ACKs, are supported through the trans-
mission settings library.
However, some MAC protocols use custom-deﬁned
packet types (such as ‘strobes’) for their operation. Cur-
rently, the architecture does not allow network protocols to
send self-deﬁned packets. We feel that allowing this would
take away many advantages of the packet fac¸ade approach.
Asynchronous MAC protocols can still be implemented by
sending the same packet multiple times.
If further research indicates that support for protocol-
deﬁned packets is absolutely required, a library will be
added that allows a protocol to send and receive a self-
deﬁned packet. Of course, these self-deﬁned packets can
not proﬁt from many of the advantages of the information
driven approach (such as reuse of packet parameters, efﬁ-
cient combination of exchanged information, and the de-
coupling of protocol logic and packet representation).
5.2
Standardization
An information driven architecture strongly beneﬁts
from an approach that standardizes both the information pa-
rameters and the attributes that are associated with a packet.
304
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

An information parameter represents information that is
exchanged between protocols or applications on different
nodes. Information parameters are often of interest to sev-
eral protocols (for example: the remaining energy of neigh-
boring nodes). When an already existing, standardized in-
formation parameters is added to the waiting space of the
system, the corresponding value is updated. The informa-
tion parameter is sent only once, rather than once for every
interested protocol.
A packet attribute represents packet-associated informa-
tion that is required to route a packet to its destination. Typ-
ical examples are a ‘next hop’ or a ‘time-to-live’ attribute.
Standardizing control parameters ensures that they can be
read by all network protocols, and that the system is aware
of the properties of each packet.
6
Implementation
The presented information driven architecture (‘IDRA’)
has been implemented using the TinyOS [12] operating sys-
tem. Run-time addition of protocols is currently not sup-
ported, since TinyOS does not support dynamic code up-
dates.
6.1
Internal workﬂow
Figure 5 shows the internal workings of the architecture.
The shared queue is the central component of the architec-
ture. Each packet in the shared queue has an associated
packet status. Depending on the status of a packet, the fol-
lowing actions can be taken.
Pre-processing is executed once for each arriving packet.
During pre-processing, duplicate packets and packets
with a different next hop address are dropped. Also,
when the packet reaches its ﬁnal destination, the en-
capsulated information parameters are extracted and
distributed to the interested protocols.
Processing is executed next. The ‘Protocol selector’ mod-
ule analyzes the packet and selects the most optimal
network protocol based on the packet characteristics
(see Section 6.2).
Post-processing Packets that have been processed by the
network protocols are prepared for sending. Relevant
packet attributes (such as the sender address) are up-
dated. Also, if parameters to the same next hop ad-
dress or destination address are available, they are ag-
gregated to the packet.
Ready For Sending After post-processing, the packets re-
main in the shared queue until the MAC protocol or-
ders the system to send the packet.
6.2
Protocol sequence
When using a traditional layered architecture, arriving
packets must ﬁrst be stripped of their headers before they
can be processed. Therefore, packets go through the pro-
tocol stack twice: once from the bottom to the top to re-
move the packet headers, and a second time from the top to
bottom to actually process the packets. In the IDRA sys-
tem, network protocols can access any packet information
through the packet fac¸ade. Thus, there is no need to execute
each protocol layer twice.
There is no ﬁxed call sequence for the protocols since
multiple protocols can co-exist on the same node. Depend-
ing on the protocol ﬁlters (see Section 3.4), the most optimal
network protocol is selected. The algorithm for protocol se-
lection is very simple so that it can be implemented even on
lightweight nodes.
1. First, all interested monitoring protocols are executed.
A monitoring protocol is considered interested if at
least one of its ﬁlters match the current packet.
2. Afterwards, the most optimal routing protocol is exe-
cuted. This is the network protocol with most match-
ing ﬁlters (or, in the case of a tie, the ﬁrst protocol that
registered itself).
3. Finally, the most optimal MAC protocol is executed.
This is the network protocol with most matching ﬁlters
(or, in the case of a tie, the ﬁrst protocol that registered
itself).
The network protocols are always executed in the same
order. Once a protocol ﬁnishes processing a packet, it sig-
nals one of the following return values to the system:
SUCCESS The network protocol ﬁnished successfully; the
next protocol can be executed.
FAIL The network protocol can not process the packet; the
packet should be dropped from the shared queue.
EBUSY The network protocol is not yet ready to process
the packet; the protocol will be called again at a later
time.
6.3
System libraries
A vertical component is available to the architecture
(Fig. 5, ‘module interactions’). Through this component,
the following system provided libraries are available:
Information Exchange: through this interface, protocols
can distribute information parameters to other nodes
and receive information parameters from other nodes.
The system converts the information parameters into a
packet.
305
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

Activate 
protocol
Pluggable protocols
Send
Parameter
Receive
Parameter 
Hardware Abstraction Layer (HAL)
Parameter 
sending
System
Parameter 
dispatching
Protocol selector
Parameter
Parameter
Parameter flow
Packet flow
Configuration
Neighbor 
discovery
MAC
Shared queue
Routing
Application
Register
protocol
In an information driven architecture, 
protocols exchange information with the 
system, and rely on the system to 
create and send packets.
Module 
interactions
Settings
Settings
Information
Exchange
Destination 
Check
Duplicate 
Detection
Packet 
Creation
Parameter 
piggybacking
Parameter 
Extraction
Update 
Sender
System 
Settings
Transmission 
settings
Settings
Packet 
implementation
(6lowpan)
Packet 
Facades
Packet 
implementation
(802.15.4)
Packet 
implementation
(propriety)
Information
repository
Neighbor table
Profile 
database
Node and 
network 
information
Figure 5. The information driven architecture (‘IDRA’).
Packet Fac¸ade: the packet fac¸ade is used to interact with
system-created packets. Packet attributes can be added
or read.
Protocol Selection: protocols can add ﬁlters to this compo-
nent to indicate for which packet types the protocol is
optimized.
System Settings: through this interface, modules change or
read system settings, such as the node ID or the current
battery voltage.
Transmission Settings: through this interface,
protocols
manage the sending of packets. It has provisions for
(i) requesting how many packets from the shared queue
are ready to be send, (ii) ordering the system to send a
speciﬁc packet, and (iii) changing the radio settings.
6.4
Example code
In this section, we show how these libraries can be used
to create a new network protocol. A simple routing pro-
tocol for broadcast packets is shown in Table 1. First, the
network protocol registers itself as a routing protocol that is
optimized for broadcast packets. Whenever the system se-
lects this routing protocol for processing a packet, the net-
work protocol uses the packet fac¸ade to update the packet
attributes.
A second example is shown in Table 2 and demonstrates
the implementation of a simple MAC protocol. Through
the ‘Transmission Settings’ library , radio settings such as
the transmission power and channel can be changed. Even
though packets are send by the system, the MAC protocol
306
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

Module BroadcastRouting{
// 1. Declaration of variables
uint8 t moduleID=unique(“protocol”);
uint8 t ttl=0;
// 2. The protocol registers itself as a routing protocol suitable for broadcast packets
command error t Module.init(){
call ProtocolRegistration.addFilter(moduleID, ROUTING PROTOCOL,
DESTINATION, 2, EQUALS, BROADCAST ADDR);
return SUCCESS;
}
// 3. Executed when the protocol is selected for routing a broadcast packet
command void Module.processPacket(uint8 t moduleId, void* packet){
if(moduleId == moduleID){
// 3.1. Get the time-to-live of the packet
result=call PacketFacade.getPacketAttribute(packet, TIME TO LIVE, sizeof(ttl), (void*) &ttl);
// 3.2. If the time-to-live equals zero: drop the received packet.
if(ttl==0) signal Module.processPacketDone(moduleId, packet, FAIL);
// 3.3. Otherwise, update the time-to-live and broadcast the packet againa.
else{
ttl=ttl-1;
call PacketFacade.setPacketAttribute(packet, TIME TO LIVE, sizeof(ttl), (void*) &ttl);
signal Module.processPacketDone(moduleId, packet, SUCCESS);
}
}
}
}
aA more advanced implementation should also check for duplicate packets to prevent broadcast storms.
Table 1. Example code: a simple broadcast routing protocol.
remains in control of sleeping schemes and accurate timing
of the sending. The MAC protocol can request at any time
which packets are ready for sending and order the system to
send a speciﬁc packet.
7
Evaluation
In this section, we evaluate three key criteria of our ar-
chitecture: the memory footprint, the energy efﬁciency and
the processing overhead.
7.1
Memory footprint
The memory footprint of the different components of the
architecture is shown in Table 3. The entry ‘Other system
components‘ refers to the implementation of preprocessing
Component
ROM
RAM
Information exchanges (Section 3.1)
800
585
Shared queue (Section 3.2)
1330
2560
Packet fac¸ade (Section 3.3)
1402
6
Protocol selection (Section 3.4)
206
234
Radio support (HAL)
8892
322
Other system components
7606
1637
Total
20236
5344
Table 3. Memory footprint (in bytes) of the different
architectural components of the system.
and postprocessing functions, QoS provisions and a shared
neighbor table. The full architecture requires about 20kb
307
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

Module SimpleMAC{
// 1. Get a unique protocol ID
uint8 t moduleID=unique(“protocol”);
// 2. The protocol registers itself as a general purpose MAC protocol
command error t Module.init(){
call ProtocolRegistration.addFilter(moduleID, MAC PROTOCOL,
0, 0, 0, 0); // default protocol
call alarmClock.startPeriodic(200); // Every 200 msec, the protocol checks if packets are ready to be sent
return SUCCESS;
// 3. Regularly check if a packet is ready for sending
event void alarmClock.ﬁred(){
if(call TransmissionSettings.checkNumberOfPackets() > 0) {
call TransmissionSettings.sendPacket();
}
}
// 4. Inform the system that the packet can be removed from the shared queue
event void TransmissionSettings.sendPacketDone(uint32 t timestamp, error t result){
if(result==SUCCESS) call TransmissionSettings.removeLastSentPacket();
}
}
Table 2. Example code: a simple MAC protocol.
Protocol name
ROM
RAM
TOS2.1 MAC [12]
11528
320
SCP-MAC [13]
21372
1056
X-MAC [14]
19854
876
IDRA LPL MAC [15]
822
176
IDRA S-MAC [16]
1126
184
Table 4. Comparison of the memory requirements
(in bytes) of TinyOS MAC protocols with IDRA
MAC protocols.
ROM and 5 kB RAM memory, well under the memory limit
of most sensor nodes.
To demonstrate the feasibility of the IDRA architec-
ture, we implemented 2 MAC protocols (S-MAC [16] and
LPL [15]) and 2 routing protocols (Collection Tree Proto-
col [17] and DYMO [20]).
When using a layered architecture, the memory con-
sumption increases linearly with the number of network
protocols. In contrast, using the IDRA architecture requires
a signiﬁcant initial investment in terms of memory, even
without any network protocols. However, adding protocols
to the system requires signiﬁcantly less memory than when
Protocol name
ROM
RAM
CTP [17]
7234
1198
DYMO [18]
11404
482(+60 per route)
Lunar [19]
5000
1518
IDRA CTP [17]
712
130
IDRA DYMO [20]
5008
312(+18 per route)
Table 5. Comparison of the memory requirements
(in bytes) of TinyOS routing protocols with IDRA
routing protocols.
using a more traditional approach (Table 4 and 5). Due to
the system provided libraries for most typical operations,
the memory requirements of network protocols are reduced
by a factor 2 to 10. Thus, the greater initial memory cost of
our system is quickly offset.
7.2
Aggregation eﬃciency
An important feature of IDRA is the automatic combina-
tion and aggregation of information exchanges. In [10] an
ILP formulation is given for calculating required number of
packet transmissions for different protocols when using our
308
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

aggregation method.
The result is illustrated in Figure 6, where the number of
packet transmissions is shown for a variable number of pro-
tocols. All protocols regularly send information to a neigh-
boring node. Information exchanges for protocol i are sent
every (∆Ti) time units. The ﬁrst protocol has a protocol cy-
cle (∆T1) of ﬁve time units, each additional protocol has its
∆T increased by one.
1
2
3
4
5
0.2
0.3
0.4
0.5
0.6
0.7
0.8
Number of protocols
Packets per time unit
 
 
No aggregation
Acceptable delay = 1
Acceptable delay = 2
Acceptable delay = 3
Acceptable delay = 4
Figure 6. Required number of packets per time unit
when using global aggregation with multiple pro-
tocols (∆Ti = i + 4).
Figure 6 shows that, when using global aggregation,
adding new protocols does not signiﬁcantly increase the re-
quired number of packets. When the acceptable delay in-
creases, the number of packet required decreases. The min-
imal number of packets per time unit that needs to be sent
is one packet every ∆T1 time units, with ∆T1 the lowest
information interval. Thus, when the acceptable delays in-
creases, the average number of packets per time unit de-
crease, provided that the packet size is big enough to con-
tain the information from all the protocols. The maximum
reduction of transmissions is equal to the number of con-
trol packet types. To summarize, global-aggregation results
in more proﬁt when more parameters need to be exchanged
and when these parameters have no strict deadlines.
7.3
Processing overhead
A ﬁnal performance criteria is the processing overhead
of the system. System overhead is mainly caused by the
following operations:
Aggregation overhead Searching for parameters to com-
bine with routed packets results in additional process-
ing delay. This causes problems when high-priority
trafﬁc is delayed. Therefore, the QoS module has the
option to disable aggregation for high-priority packets.
Thus, additional delay will only be introduced for low-
priority trafﬁc.
Packet fac¸ade overhead Using a packet fac¸ade to associate
control parameters with a packet causes additional pro-
cessing delay. If all types of packet attributes are not
known in advance, they must be stored sequentially in
a header byte array. This type of packet implementa-
tion is not very efﬁcient, but can be used for any possi-
ble combination of packet attributes. When all packet
attributes are known in advance, they can be associ-
ated with a speciﬁc header location. In this case, the
packet fac¸ade can be implemented very efﬁciently us-
ing a simple switch statement.
Overhead for storing packets IDRA
requires
very
few
copy actions for processing packets: arriving packets
are stored once in the shared queue, and remain there
until processing is ﬁnished. This is much more ef-
ﬁcient than copying a packet once for each protocol
layer.
The total packet delay depends strongly on the complex-
ity of the used packet fac¸ade and the complexity of the net-
work protocols. However, even when using relatively net-
work protocols, such as the combination of an AODV rout-
ing protocol, an LPL-like MAC protocol and 6lowpan pack-
ets, the processing delay is less than 20 milliseconds on a
telosb [21] sensor node. This delay is well below the duty
cycle of most typical WSN MAC protocols.
8
Related work
In this section, we will compare our architecture with
other proposed architectures for WSNs.
8.1
A
Sensor
Network
Architecture
(SNA)
The sensor network architecture (SNA) [22] is based
on ‘functionality’: the authors analyzed thoroughly which
‘functions’ or ‘components’ are often executed by pro-
tocols.
They provided a modular MAC layer (called
‘SP’) [23] and a modular routing layer (called ‘NLA’) [6,
24]. A protocol designer can use these modules to ‘build’
a custom network protocol.
Additionally, a cross-layer
database is provided that shares components such as a mes-
sage pool (similar to the ‘shared queue’), a link estimation
and an extensible neighbor table.
The SNA has several similar goals as IDRA, but differs
in the following ways. (i) Rather than delegating tasks to a
central system, their goal is to enable the quick development
of protocol layers, using the provided components for each
309
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

layer. (ii) Protocols need to deﬁne their own headers, and
must encapsulate packets from higher layers. (iii) Dynamic
selection between protocols is not supported, and protocols
can not view or reuse each others packet attributes. (iv)
Limited support for energy-efﬁciency. Since their system
can not extract meaningful parameters from packets, they
combine full packets rather than only the relevant informa-
tion. Additionally, they can not aggregate information to
non-neighboring nodes. (v) Provisions for QoS or hetero-
geneity are not supported.
A similar component based MAC Layer Architecture
(MLA) [25] also includes power management. The mem-
ory footprints of SCP-MAC and X-MAC from table 4 are
calculated using the MLA architecture.
8.2
A declarative sensornet architecture
The declarative sensor network architecture [26, 27]
(DSN) aims to facilitate the programming of sensor nodes,
using a declarative language (called Snlog). This language
provides a high level of abstraction: protocols describe what
the code is doing but not how it is doing it. Algorithms are
implemented using predicates, tuples, facts and rules.
The compiler represents all this information as tables.
Rules are converted to dataﬂow plans using database oper-
ations (Join, Select, Aggregate and Project). Execution of
the dataﬂow plans is triggered by the associated predicates.
Finally, the intermediary operators are compiled into a nesC
program.
DSN is especially suited for recursive protocols, such as
tree construction (which requires only 7 lines of code). Ad-
ditionally, protocol interoperability can be supported using
database scheme matching techniques on the packets. How-
ever, the architecture currently has several disadvantages:
(i) complex data structures are not supported, (ii) total mem-
ory size increases (up to a factor 3) and (iii) no ﬁne grained
radio control is supported (which makes the language un-
suited for low-level MAC protocols).
8.3
Modular architectures
One of the limitations of a layered architecture is that it is
difﬁcult to incorporate new cross-layer services since inter-
faces are explicitly embedded in each layer. An alternative
is to completely discard the layered structure.
Instead of using protocol layers, all responsibilities of a
protocol layer are divided over separate modules [28] with a
well-deﬁned function. For example, a complex MAC layer
can be divided into a neighbor management module, a sleep
management module, a channel monitoring module and a
retransmission module.
To prevent a large number of dependencies between the
different modules, modules do not interact with each other
directly.
Instead, communications between modules go
through a cross-layer database repository [29].
The use of a modular architecture has several advan-
tages:
• Duplication of functionality is prevented;
• When developing a new network protocol, existing
modules can easily be reused;
• cross-layer information can be exchanged, supporting
the development of energy-efﬁcient protocols;
• Depending on the node capabilities or network condi-
tions, it is easy to add or adapt a single module;
In the design of our information driven architecture, no
assumptions are made on the use of layering, modular or hy-
brid approaches. For modular approaches, our ﬁlter based
protocol registration (Section 3.4) can be expanded to sup-
port dynamic call sequences [30]. Registering modules can
indicate in which sequence the modules should be executed.
Depending on the situation and packet type, the appropriate
call sequence can be initiated. Thus, our proposed informa-
tion driven architecture is easily adaptable to be compatible
with both the layered and the modular approach.
9
Summary
Wireless sensor networks are used for increasingly com-
plex applications, such as wireless building automation and
process and asset monitoring. These applications demand
more and more functionalities from the underlying sensor
network. They are often deployed on strongly heteroge-
neous nodes and require adaptive and reliable end-to-end
services. Such requirements cannot be supported at a proto-
col level but should be part of the overall sensornet architec-
ture. However, no architecture currently exists that supports
heterogeneity, easy protocol-integration and QoS as part of
its architectural design.
Therefore, in this paper, we proposed an information
driven sensornet architecture. This architecture is based on
the notion that protocols should be simpliﬁed to their two
main tasks: exchanging information and interacting with
the relayed information. By intelligently manipulating this
information, the system can support advanced network re-
quirements for next-generation sensornet applications.
More speciﬁcally, the information driven approach has
the following key advantages:
• by using a packet fac¸ade for packet interactions, pro-
tocol logic is decoupled from packet representation;
• rather than statically wiring protocols, protocols are
dynamically selected (based on protocol-provided ﬁl-
ters);
310
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

• by providing a shared, system-wide packet queue the
overall memory footprint is reduced and system-wide
QoS can be enforced;
• heterogeneity is promoted since protocols can be
added to a node according to its capabilities;
• and ﬁnally, by efﬁciently combining the information
exchanges, the number of transmitted packets can be
strongly reduced.
To demonstrate the feasibility of these concepts, we
implemented all techniques in a single architecture.
We
demonstrated that in our system, network protocols require
signiﬁcantly less memory (up to a factor 10), at the price
of a larger initial memory cost. In addition, the number
of packets per time unit can decrease up to a minimum of
1
∆Tx , with ∆Tx the lowest information interval. Finally, we
demonstrated that the additional processing time of our sys-
tem is far less than the sleeping delay in typical wireless
sensor networks.
To conclude this paper, we are convinced that future ap-
plications for WSNs will be very demanding on the network
in terms of ﬂexibility, reliability and adaptivity. In this pa-
per, we claimed that network requirements, such as support
for QoS, heterogeneity and energy-efﬁciency, should be part
of the architectural design, rather than being added as an
afterthought. As such, innovative architectural techniques
that support these requirements, like the ones proposed in
this paper, will be of great importance to the successful de-
velopment of next-generation sensornet architectures.
Acknowledgments
This research is funded by the Institute for the Promotion
of Innovation through Science and Technology in Flanders
(IWT-Vlaanderen) through a PhD. grant for E. De Poorter.
The author wishes to acknowledge the valuable feedback
of colleagues Pieter De Mil, Bart Jooris, Benoˆıt Latr´e,
Evy Troubleyn, Lieven Tytgat and partners from the IBBT-
DEUS project.
References
[1] Eli De Poorter, Ingrid Moerman, and Piet Demeester. An in-
formation driven sensornet architecture (best paper award).
In The Third International Conference on Sensor Technolo-
gies and Applications (sensorcomm 2009), Athens/Glyfada,
Greece, June June 18-23, 2009.
[2] I. Akyildiz and I. Kasimoglu. Wireless sensor and actor net-
works: Research challenges. Ad Hoc Networks Journal (El-
sevier), 2(4):351–367, October 2004.
[3] Carlos F. Garc´ıa-Hern´andez,
Pablo H. Ibarg¨uengoytia-
Gonz´alez, Joaqu´ın Garc´ıa-Hern´andez, and Jes´us A. P´erez-
D´ıaz. Wireless sensor networks and applications: a survey.
IJCSNS International Journal of Computer Science and Net-
work Security, VOL.7 No.3,, March 2007.
[4] M. Yarvis, N. Kushalnagar, H. Singh, A. Rangarajan, Y. Liu,
and S. Singh. Exploiting heterogeneity in sensor networks.
in Proceedings of the IEEE Infocom, 2005.
[5] Evy Troubleyn, Eli De Poorter, Ingrid Moerman, and Piet
Demeester. AMoQoSA: Adaptive Modular QoS Architec-
ture for Wireless Sensor Networks. SENSORCOMM 2008,
Cap Esterel, France, August 25-31, 2008.
[6] J. Polastre, J. Hui, P. Levis, J. Zhao, D. Culler, S. Shenker, ,
and I. Stoica. A unifying link abstraction for wireless sensor
networks. SenSys ’05, San Diego, CA, USA,, pages pp. 76–
89, Nov. 2005.
[7] Hubert Zimmermann.
OSI Reference Model — The ISO
Model of Architecture for Open Systems Interconnection.
IEEE Transactions on Communications, 28, no. 4:425 – 432,
April 1980.
[8] J. Hoebeke, I. Moerman, B. Dhoedt, and P. Demeester. To-
wards adaptive ad hoc network routing. International Jour-
nal of Wireless and Mobile Computing, vol. 1:pp. 1–8, 2005.
[9] R. Rajagopalan and P.K. Varshney. Data-aggregation tech-
niques in sensor networks: a survey. Communications Sur-
veys & Tutorials, IEEE, 8(4):48–63, Fourth Quarter 2006.
[10] Eli De Poorter, Stefan Bouckaert, Ingrid Moerman, and Piet
Demeester. Broadening the concept of aggregation in wire-
less sensor networks. SENSORCOMM 2008, Cap Esterel,
France, August 25-31, 2008.
[11] E. Fasolo, M. Rossi, and M. Widmer, J.and Zorzi. In-network
aggregation techniques for wireless sensor networks: a sur-
vey. Wireless Communications, IEEE [see also IEEE Per-
sonal Communications], 14(2):70–87, April 2007.
[12] Tinyos operating system. http://www.tinyos.net/.
[13] W. Ye, F. Silva, and J. Heidemann. Ultra-low duty cycle mac
with scheduled channel polling. pages 321–334, Boulder,
CO, November 2006.
[14] M. Buettner, G. Yee, E. Anderson, and R. Han. X-MAC:
A short preamble mac protocol for duty-cycledwireless net-
works. pages 307–320, Boulder, CO, November 2006.
[15] J. Hill and D. Culler. Mica: a wireless platform for deeply
embedded networks. IEEE Micro, 22(6):12–24, November
2002.
[16] W. Ye, J. Heidemann, and D. Estrin.
An energy-efﬁcient
MAC protocol for wireless sensor networks. In 21st Confer-
ence of the IEEE Computer and Communications Societies
(INFOCOM), volume 3, pages 1567–1576, June 2002.
[17] Collection
Tree
Protocol
(CTP)
for
tinyOS
2.x.,
december
2008.
http://www.tinyos.net/tinyos-
2.x/doc/html/tep123.html.
[18] Tymo source code repository. tymo: Dymo implementation
for tinyos, december 2008. http://tymo.sourceforge.net.
[19] LUNAR - Lightweight Underlay Network Ad hoc Routing,
december 2008. http://cn.cs.unibas.ch/projects/lunar/.
311
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

[20] Ian D. Chakeres and Charles E. Perkins. Dynamic manet on-
demand routing protocol (dymo). IETF Internet Draft, draft-
ietf-manet-dymo-12.txt, http://ianchak.com/dymo/draft-ietf-
manet-dymo-12.html, February 2008 (Work in Progress).
[21] Telosb reference datasheet. http://www.xbow.com/Products/-
productdetails.aspx?sid=252.
[22] Arsalan Tavakoli, Prabal Dutta, Jaein Jeong, Sukun Kim,
Jorge Ortiz, David Culler, Phillip Levis, and Scott Shenker.
A modular sensornet architecture: past, present, and future
directions. SIGBED Rev., 4(3):49–54, 2007.
[23] D. Culler, P. Dutta, C.T. Eee, R. Fonseca, J. Hui, P. Levis,
J. Polastre, S. Shenker, I. Stoica, G. Tolle, and J. Zhao. To-
wards a sensor network architecture: Lowering the waistline.
In In Proceedings of the Tenth Workshop on Hot Topics in
Operating Systems (HotOS X), 2005.
[24] C.T. Ee, R. Fonseca, S. Kim, D. Moon, A. Tavakoli,
D. Culler, S. Shenker, and I. Stoica.
A modular network
layer for sensornets. In the Proceedings of the 7th USENIX
Symposium on Operating Systems Design and Implementa-
tion (OSDI 2006), Seattle, WA, November 2006.
[25] Kevin Klues, Gregory Hackmann, Octav Chipara, and
Chenyang Lu. A component-based architecture for power-
efﬁcient media access control in wireless sensor networks.
In SenSys ’07: Proceedings of the 5th international confer-
ence on Embedded networked sensor systems, pages 59–72,
New York, NY, USA, 2007. ACM.
[26] Arsalan Tavakoli, David Chu, Joseph M. Hellerstein, Phillip
Levis, and Scott Shenker. A declarative sensornet architec-
ture. SIGBED Rev., 4(3):55–60, 2007.
[27] David Chu, Joseph M. Hellerstein, and Tsung te Lai. Opti-
mizing declarative sensornets. In SenSys ’08: Proceedings of
the 6th ACM conference on Embedded network sensor sys-
tems, pages 403–404, New York, NY, USA, 2008. ACM.
[28] Robert Braden, Ted Faber, and Mark Handley. From protocol
stack to protocol heap: role-based architecture. SIGCOMM
Comput. Commun. Rev., 33(1):17–22, 2003.
[29] Tommaso Melodia, Mehmet C. Vuran, and Dario Pompili.
The state of the art in cross-layer design for wireless sen-
sor networks. Wireless Syst./Network Architect., LNCS 3883,
page 78–92, 2006.
[30] Eli De Poorter, Benoˆıt Latr´e, Ingrid Moerman, and Piet De-
meester. Universal modular framework for sensor networks.
In International Workshop on Theoretical and Algorithmic
Aspects of Sensor and Ad-hoc Networks (WTASA’07), pages
pp 88 – 96, Miami, USA, June June 28-29, 2007.
312
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

