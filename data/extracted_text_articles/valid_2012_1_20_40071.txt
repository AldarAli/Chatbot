Cost-Aware Combinatorial Interaction Testing
Gulsen Demiroz and Cemal Yilmaz
Faculty of Engineering and Natural Sciences
Sabanci University, Istanbul 34956, Turkey
Email: {gulsend,cyilmaz}@sabanciuniv.edu
Abstract—The conﬁguration spaces of modern software sys-
tems are often too large to test exhaustively. Combinatorial
interaction testing approaches, such as covering arrays, sys-
tematically sample the conﬁguration space and test only the
selected conﬁgurations. Traditional t-way covering arrays aim
to cover all t-way combinations of option settings in a minimum
number of conﬁgurations. By doing so, they assume that the
testing cost of a conﬁguration is the same for all conﬁgurations.
In this work, we however argue that, in practice, the actual
testing cost may differ from one conﬁguration to another and
that accounting for these differences can improve the cost-
effectiveness of covering arrays. We ﬁrst introduce a novel
combinatorial object, called a cost-aware covering array. A
t-way cost-aware covering array is a t-way covering array
that minimizes a given cost function. We then provide a
framework for deﬁning the cost function. Finally, we present
an algorithm to compute cost-aware covering arrays for a
simple, yet important scenario, and empirically evaluate the
cost-effectiveness of the proposed approach. The results of
our empirical studies suggest that cost-aware covering arrays,
depending on the conﬁguration space model used, can greatly
reduce the actual cost of testing compared to traditional
covering arrays.
Keywords-Software quality assurance, combinatorial interac-
tion testing, covering arrays.
I. INTRODUCTION
The conﬁguration spaces of conﬁgurable software systems
are often too large to test exhaustively. The number of
possible conﬁgurations is often far beyond the available
resources to test the entire conﬁguration space in a timely
manner, e.g., for regression testing.
Combinatorial interaction testing (CIT) approaches take
as input a conﬁguration space model. The model includes
a set of conﬁguration options, each of which can take on a
small number of option settings. As not all conﬁgurations
may be valid, the model can also include some system-
wide inter-option constraints. In the context of this work,
an inter-option constraint is a constraint that implicitly or
explicitly invalidates some combinations of option settings.
In effect, the conﬁguration space model implicitly deﬁnes a
set of valid ways the software under test can be conﬁgured.
CIT approaches systematically sample the valid conﬁg-
uration space and test only the selected conﬁgurations.
The sampling is carried out by computing a combinatorial
object, called a covering array. Given a conﬁguration space
model, a t-way covering array is a set of conﬁgurations, in
which each possible combination of option settings for every
combination of t options appears at least once [6].
The basic justiﬁcation for covering arrays is that they can
cost-effectively exercise all system behaviors caused by the
settings of t or fewer options. The results of many empirical
studies strongly suggest that a majority of option-related
failures in practice are caused by the interactions among only
a small number of conﬁguration options and that traditional
t-way covering arrays, where t is much smaller than the
number of options, are an effective and efﬁcient way of
revealing such failures [2], [6], [9], [10].
Existing approaches construct a t-way covering array in
such a way that all valid t-way combinations of option
settings are covered by using a minimum number of conﬁg-
urations. By doing so, these approaches implicitly assume a
simple cost model where the cost of conﬁguring the system
under test is the same for all conﬁgurations.
In this work, we argue that this cost model is not always
valid in practice. First, we observe that the conﬁguration cost
often varies from one conﬁguration to other. For example, in
a study conducted on MySQL – a widely-used and highly-
conﬁgurable database management system, we observed that
the cost of conﬁguring the MySQL Community Server (a
core component of the system) with its default conﬁguration
took about 6 minutes on average (on an 8-core Intel Xeon
2.53GHz CPU with 32 GB of RAM, running CentOS 6.2
operating system). On the other hand, conﬁguring the system
with NDB cluster storage support – a feature that enables
clustering of in-memory databases, and with embedded
server support – a feature that makes it possible to run a
full-featured MySQL server inside a client application, took
about 9 minutes, as these features needed to be compiled
into the system. Therefore, in a covering array, reducing the
number of conﬁgurations that include these features, without
adversely affecting the coverage of option setting combina-
tions, can signiﬁcantly reduce the amount of time required
for testing. However, existing approaches do not take actual
testing costs into account when computing covering arrays.
Second, we observe that highly conﬁgurable systems often
have reusable components, which, once conﬁgured, can be
used in other conﬁgurations with no or very little additional
cost. One simple example is the presence of compile-time
9
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

o1  o2  o3
o4  o5  o6  o7
0   0   0    0   0   0   0
0   0   1
1   1   0   0
0   1   0
1   1   1   1
0   1   1
0   1   0   1
1   0   0    0   0   1   1
1   0   1
1   1   1   1
1   1   0
1   0   1   0
1   1   1
0   0   0   0
o1  o2  o3   o4  o5  o6  o7
0   0   0 
0   0   0   0
0   0   0
1   1   0   0
0   0   0
1   1   1   1
0   0   0
0   1   0   1
0   1   1 
0   0   1   1
1   0   1
1   1   1   1
1   0   1
1   0   1   0
1   1   0
0   0   0   0
o1  o2  o3
0   0   0
0   1   1
1   0   1
1   1   0 
- Options:
{o1,o2,o3}: {0,1}
- Constraints: 
<empty>
- Options:
{o1,o2,o3,o4,o5,o6,o7}: {0,1}
- Constraints: 
(o1=0  o2=0  o3=0)
(o1=0  o2=1  o3=1)
(o1=1  o2=0  o3=1)
(o1=1  o2=1  o3=0)
(a)
A 2-way cost-aware covering array
2-way covering array 
for options {o1,o2,o3}
A traditional 2-way covering array
(b)
(c)
Figure 1.
(a) A traditional 2-way covering array. (b,c) Illustrates our algorithm where (b) shows 2-way covering array for only compile-time options and
(c) shows 2-way cost-aware covering array.
and runtime conﬁguration options.
Compile-time options need to be set before the system
can be built. The system is then conﬁgured as a part of the
build process. Therefore, changing the setting of a compile-
time option requires a partial or a full rebuild of the system.
On the other hand, given a build of the system, runtime
options are set when the system is running and the system
is conﬁgured on the ﬂy. Note that a build of the system is
a reusable component. Once the system is built for a given
combination of compile-time option settings, the same build
can be used with different runtime conﬁgurations without
any additional cost; as long as the settings of compile-time
options stay the same, the same binaries can be reused.
However, runtime conﬁgurations are not reusable. Even for
the same build (i.e., the same compile-time conﬁguration)
they need to be reconﬁgured every time the program is
executed, unless the program state is saved for future use.
Figure 1(a) and 1(c) illustrate the effect of reusable
components on testing cost in a hypothetical scenario. In this
scenario, we have 7 conﬁguration options o1, . . . , o7, each
of which can take on a binary value (i.e., 0 or 1). The ﬁrst 3
options o1, o2, and o3 are compile-time options, whereas
the remaining options o4, o5, o6, and o7 are runtime
options. There are no system-wide inter-option constraints;
all option setting combinations are valid. Furthermore, the
system is to be tested with a 2-way covering array. Two
covering arrays are created for comparison.
The 2-way covering array presented in Figure 1(a) in-
cludes 8 unique combinations of compile-time option set-
tings, requiring to build the system 8 times. On the other
hand, the 2-way covering array presented in Figure 1(c)
requires to build the system only 4 times, as it includes
4 unique compile-time conﬁgurations. For example, once
the system is built for o1=0, o2=0, and o3=0, the same
binaries are reused without any additional cost for 3 more
conﬁgurations included in the covering array. Assuming that
the runtime conﬁguration cost is negligible compared to the
compile-time conﬁguration cost and that the compile-time
conﬁguration cost is the same for all conﬁgurations, the 2-
way covering array in Figure 1(c) tests all 2-way option
setting combinations at half of the cost compared to the 2-
way covering array in Figure 1(a).
To improve the cost-effectiveness of CIT approaches,
we introduce a novel combinatorial object, called a cost-
aware covering array. Given a traditional conﬁguration
space model augmented with a cost function and a value of t,
a t-way cost-aware covering array is a t-way covering array
that minimizes the cost function. We, furthermore, provide
an algorithm to compute cost-aware covering arrays for a
simple, yet frequently-faced scenario in practice. The results
of our empirical studies suggest that cost-aware covering
arrays, depending on the conﬁguration space model used,
can greatly reduce the actual cost of testing compared to
traditional covering arrays.
The remainder of the paper is organized as follows:
Section II discusses related work; Section III introduces
cost-aware covering arrays; Section IV presents an algorithm
to compute cost-aware covering array for a particular cost
model; Section V describes the empirical studies; Section VI
presents concluding remarks and directions for future work.
10
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

II. RELATED WORK
In this section, we provide background information on
traditional covering arrays and discuss related work.
Traditional CIT approaches take as input a conﬁguration
space model M=<O, V, Q>. The model includes a set
of conﬁguration options O={o1, o2, . . . , on}, their possible
values V ={V1, V2, . . . , Vn}, and some system-wide inter-
option constraints Q (if any). Each conﬁguration option oi
(1 ≤ i ≤ n) takes a value from a ﬁnite set of |Vi| distinct
values Vi = {vi1, vi2, . . . , vi|Vi|}.
Deﬁnition
1.
Given
a
conﬁguration
space
model
M=<O, V, Q>, a t-tuple ϕt={<oi1, vj1>, <oi2, vj2>,
. . ., <oit, vjt>} is a set of option-value tuples for a
combination of t distinct options, such that 1 ≤ t ≤ n,
1 ≤ i1 < i2 < . . . < it ≤ n, and vjp ∈ Vip for
p=1, 2, . . . , t.
Not all the t-tuples may be valid due to the constraints
Q. Let valid(ϕt, Q) be a deterministic function such that
valid(ϕt, Q) is true, if and only if, ϕt satisﬁes the constraint
Q. Otherwise, valid(ϕt, Q) is false. The set of all valid t-
tuples Φt under constraint Q is then deﬁned as: Φt={ϕt :
valid(ϕt, Q)}.
Deﬁnition
2.
Given
a
conﬁguration
space
model
M=<O, V, Q>,
a
valid
conﬁguration
c
is
a
valid
n-tuple, i.e., c ∈ Φn, where n = |O|.
Deﬁnition
3.
Given
a
conﬁguration
space
model
M=<O, V, Q>,
the
valid
conﬁguration
space
C
is
the set of all valid conﬁgurations, i.e., C={c : c ∈ Φn}.
Deﬁnition
4.
A
t-way
covering
array
CA(t, M=<O,V ,Q>) is a set of valid conﬁgurations,
in which each valid t-tuple appears at least once, i.e.,
CA(t, M=<O, V, Q>)={c1, c2, . . . , cN},
such
that
∀ ϕt ∈ Φt ∃ ci ⊇ ϕt, where ci ∈ C for i=1, 2, . . . , N.
The problem of generating covering arrays is NP-
hard [15]. Nie et al. classify the methods for generating
covering arrays into 4 main categories [15]: random search-
based methods [16], heuristic search-based methods [8], [4],
[7], [11], [4], [17], greedy methods [6], [9], [5], [19], [18],
[14], and mathematical methods [20], [13], [21], [12].
Random search-based methods employ a random selection
without replacement strategy [16]. Valid conﬁgurations are
randomly selected from the conﬁguration space in an itera-
tive fashion until all the required t-tuples have been covered
by the conﬁgurations selected.
Heuristic search-based methods, on the other hand, em-
ploy heuristic search techniques, such as hill climbing [8],
tabu search [4], and simulated annealing [7], or AI-based
search techniques, such as genetic algorithms [11] and ant
colony algorithms [17], to compute covering arrays. These
methods typically maintain a set of conﬁgurations at any
given time and iteratively apply a series of transformations
to the set until the set constitutes a t-way covering array.
Greedy algorithms also operate in an iterative manner [6],
[9], [5], [19], [18], [14]. At each iteration, among the sets of
conﬁgurations examined as candidates, the one that covers
the most previously uncovered t-tuples is included in the
covering array and the newly covered t-tuples are then
marked as covered. The iterations end when all the required
t-tuples have been covered.
Mathematical methods for constructing covering arrays
have also been studied [20], [13], [21]. Some mathematical
methods are based on recursive construction methods, which
build covering arrays for larger conﬁguration space models
(i.e., the ones with a larger number of conﬁguration options)
by using covering arrays built for smaller conﬁguration
space models (i.e., the ones with a smaller number of con-
ﬁgurations) [20], [13]. Other mathematical methods leverage
mathematical programming, such as integer programming, to
compute covering arrays [21].
Our approach differs from existing covering array gen-
erators in that we compute a t-way covering array that
minimizes a given cost function, rather than minimizing the
number of conﬁgurations required.
Furthermore, Bryce et al. introduce the concept of “soft
constraints” to mark option setting combinations that are
permitted, but undesirable to be included in a covering
array [3]. Although soft constraints could be used to avoid
costly combinations of options settings, thus to reduce
testing cost, using soft constraints for this purpose can be
considered to be an opportunistic approach. Our approach,
on the other hand, takes the task of reducing the cost as an
optimization criterion.
III. COST-AWARE COVERING ARRAYS
In our approach, we take as input a traditional conﬁgu-
ration space model augmented with a cost function cost(.).
Given a covering array ca, cost(ca) returns the expected
cost of testing ca.
Deﬁnition
5.
Given
a
conﬁguration
space
model
M=<O, V, Q, cost(.)>
and
a
value
of
t,
a
t-way
cost-aware covering array is a t-way covering array that
minimizes the function cost(.).
Deﬁning the cost function is not a trivial task. For
example, the cost of a given covering array may not simply
be the sum of the cost of the conﬁgurations in the array, as
some parts of a conﬁgured system can be reused by other
conﬁgurations with no or little additional cost. Therefore,
we present a framework for deﬁning the cost function.
Deﬁnition
6.
Given
a
conﬁguration
space
model
M=<O, V, Q>, a component class X={oi1, oi2, . . . , oik}
is a set of k distinct options, such that X ⊆ O.
11
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

Deﬁnition
7.
Given
a
component
class
X={oi1, oi2, . . . , oik}, a component x is a k-tuple of
the form {<oi1, vj1>, <oi2, vj2>, . . ., <oik, vjk>} for the
conﬁguration options included in X, where k=|X|.
We assume that the set of conﬁguration options O
are divided into p (1 ≤ p ≤ |O|) component classes
X1, X2, . . . , Xp, such that Xi ∩ Xj
= ∅ for i̸=j and
X1 ∪ . . . ∪ Xp = O. Consequently, a given conﬁguration
c is composed of p components x1, x2, . . . , xp, such that xi
is a component of component class Xi for i=1, . . . , p.
For example, in our running example depicted in Figure 1,
we have two component classes: X1={o1, o2, o3} and
X2={o4, o5, o6, o7}. X1 includes all the compile-time
options, whereas X2 includes all the runtime options.
We distinguish between two types of component classes:
reusable and non-reusable component classes.
Deﬁnition 8. A reusable component class Xr is a compo-
nent class whose components can be conﬁgured in isolation
and, once conﬁgured, they can be reused in other conﬁgu-
rations.
Deﬁnition 9. A non-reusable component class Xnr is a
component class whose components need to be conﬁgured
every time they are used.
Going back to our running example, we observe that X1
is a reusable component class, since, once the system is
built for a given compile-time conﬁguration, the resulting
binaries can be reused in other conﬁgurations with different
runtime conﬁgurations. On the other hand, X2 is a non-
reusable component class, since the runtime options need to
be conﬁgured every time the system is executed.
To determine the cost of a given covering array, we
assume two cost functions: cc(.) and lc(.). The function
cc(x) takes as input a component x (either a reusable or a
non-reusable component) and returns the conﬁguration cost
of x. For example, assuming that the reusable component
x represents a conﬁguration for a library, cc(x) is the
cost of compiling the library with the given conﬁguration.
The function lc(c), on the other hand, takes as input a
conﬁguration c and returns the cost of linking (i.e., gluing)
together the components appearing in the conﬁguration. For
example, assuming that a conﬁguration c is composed of
reusable components xr
1 and xr
2, each of which represents
a library, lc(c) is the cost of linking the two libraries after
they are compiled, i.e., after the cc(xr
1) and cc(xr
2) costs are
paid.
Deﬁnition 10. The cost of a conﬁguration c, which is
composed of components x1, x2, . . . , xp, is deﬁned as
(∑
1≤i≤p cc(xi)
)
+ lc(c)
However, in the presence of reusable components, the cost
of a given covering array is not the sum of the cost of the
conﬁgurations included in the array.
Deﬁnition 11. Given a covering array ca={c1, c2, . . . , cN},
let Ri and Si be the set of reusable and non-reusable compo-
nents in a conﬁguration ci, respectively, where 1 ≤ i ≤ N.
The cost of the covering array ca is then deﬁned as follows:
cost(ca)=∑
x∈∪
1≤i≤N Ri cc(x) +
∑
1≤i≤N
(
lc(ci) + ∑
x∈Si cc(x)
)
Furthermore, reusable components can form a hierarchy.
Deﬁnition 12. A reusable composite component is a com-
ponent, which is composed of reusable components and/or
other reusable composite components.
Reusable composite components are constructed by link-
ing the components appearing in the composite, once these
components are conﬁgured. Therefore, to account for com-
posite components, the lc(.) function should ensure that the
linking cost of the same reusable composite components is
paid only once.
IV. COMPUTING COST-AWARE COVERING ARRAYS FOR
A SIMPLE COST MODEL
We conjecture that all the methods that have so far been
used to compute traditional covering arrays, such as ran-
dom search-based methods, heuristic search-based methods,
greedy methods, and mathematical methods (Section II), can
also be used to construct cost-aware covering arrays, all
with their own pros and cons. In this work, however, we, as
a proof of concept, present an algorithm to compute cost-
aware covering arrays for a simple, yet important cost model.
In this cost model, the system under test has compile-time
and runtime options. For a given conﬁguration space model
of the system, we deﬁne two components Xr and Xnr. Xr
is a reusable component class, containing all the compile-
time options in the model, whereas Xnr is a non-reusable
component class, containing all the runtime options in the
model. We assume that (1) the cost of linking compile-time
and runtime conﬁgurations is negligible, i.e., lc(c)=0 for
all c, (2) the compile-time conﬁguration cost is the same
for all compile-time conﬁgurations, i.e., cc(xr)=a for some
constant a for all xr, and (3) the runtime conﬁguration cost
of the system is negligible, i.e., cc(xnr)=0 for all xnr.
Under this cost model, the cost of a covering array
ca={c1, c2, . . . , cN} is
cost(ca) = a × |
∪
1≤i≤N
Ri|,
(1)
where a is the constant cost of building the system, and
Ri is the set of compile-time components appearing in
conﬁguration ci (1 ≤ i ≤ N). In other words, under this
model the optimization criterion is to minimize the number
of times the system is built, while covering all t-tuples.
12
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

Although this cost model may seem to be overly con-
strained at a ﬁrst glance, since our goal is to demonstrate
the differences between the cost-effectiveness of traditional
and cost-aware covering arrays, rather than to compute cost-
aware covering arrays for any given cost function, we believe
that the cost model employed serves well to its purpose.
Furthermore, based on our feasibility studies conducted
on MySQL – a highly-conﬁgurable database management
system, and Apache – a highly-conﬁgurable HTTP server,
we argue that this simple cost model still has some practical
importance. For example, we observed that (1) both subject
applications have compile-time and runtime options, (2)
runtime conﬁguration cost for both subject applications is
negligible, (3) the cost of linking runtime conﬁgurations
with compile-time conﬁgurations is negligible. Although,
for both subject applications, compile-time conﬁguration
costs vary from one conﬁguration to another, since building
these systems from scratch is costly, reducing the number of
times they are built is still of practical value, e.g., building
the entire software suite that comes with the source code
distribution of our subject applications with the default
conﬁguration takes about 80 minutes for MySQL and 8
minutes for Apache, on average.
With all these in mind, Algorithm 1 presents our algo-
rithm. In this algorithm, we use traditional covering array
construction as a computational primitive. In particular, we
assume a generator ∏(t, M) that constructs a traditional t-
way covering array for the conﬁguration space model M.
Given a conﬁguration space model M and a value of
t, our algorithm operates as follows: (1) a traditional t-
way covering array Ω is generated for only the compile-
time options (line 1), (2) all the compile-time conﬁgurations
included in the newly computed array are expressed as
an inter-option constraint Q (line 3-5), (3) a traditional t-
way covering array Ψ satisfying Q, is generated for all the
conﬁguration options (line 6). The output Ψ (line 7) is a
t-way cost-aware covering array, aiming to minimize the
testing cost, i.e., aiming to minimize the number of times
the system is required to be built.
The rationale behind this algorithm is a simple one.
Assuming ∏(t, M) generates a traditional t-way covering
Ω for only the compile-time options with minimal num-
ber of conﬁgurations, Step (1) selects a minimal set of
compile-time conﬁgurations covering all t-way combinations
of option settings for the compile-time options. Step (2), by
expressing these compile-time conﬁgurations as constraints,
ensures that step (3) computes a traditional t-way cover-
ing array around these conﬁgurations without introducing
new compile-time conﬁgurations, minimizing the number of
compile-time conﬁgurations required, thus the testing cost.
If the traditional covering array generator ∏ produces a sub-
optimal solution, then so will our algorithm.
Figure 1(b) and (c) illustrate the algorithm in our running
example introduced in Section I. First, a traditional 2-way
Algorithm 1 Computes a t-way cost-aware covering
array
Input M=<O, V, ∅>: Conﬁguration space model
Input t: Covering array strength
Let M ′ be the conﬁguration space model for only the
compile-time options in M
1: Ω ← ∏(t, M ′)
2: Q ← ∅
3: for each c = {<oi1, vj1>, <oi2, vj2>, . . .} in Ω do
4:
Q ← Q ∨ {oi1 = vj1 ∧ oi2 = vj2 ∧ . . .}
5: end for
6: Ψ ← ∏(t, M=<O, V, Q>)
7: return Ψ
covering array is generated for the 3 compile-time options
o1, o2, and o3 (Figure 1b). The array has 4 compile-time
conﬁgurations. Second, these conﬁgurations are expressed
as a constraint so that no additional compile-time conﬁg-
urations can be selected (Figure 1c). Finally, a traditional
2-way covering array satisfying the constraint is generated
for all the options. The resulting cost-aware covering array
requires to build the system under test 4 times.
V. EXPERIMENTS
To evaluate the proposed approach, we conducted a set of
experiments.
A. Experimental Setup
To carry out the experiments, we ﬁrst implemented our
algorithm. In the implementation, we used a well-known and
widely-used covering array generator ACTS (v1.r9.3.2) [1].
We then determined a conﬁguration space model for a
hypothetical system and varied the model in a system-
atic and controlled manner to obtain other models. For
each conﬁguration space model obtained, we computed a
traditional t-way covering array and a t-way cost-aware
covering array, and compared their cost-effectiveness, i.e.,
compared the number of builds required by these arrays.
The constant cost we assume for each conﬁguration (build)
would vary for different systems but this does not affect our
cost comparisons.
All the experiments were performed on an 8-core Intel
Xeon 2.53 GHz CPU platform with 32 GB of RAM, running
CentOS 6.2 operating system.
B. Independent Variables
In particular we experimented with 3 independent vari-
ables:
• m: The number of compile-time options in the
conﬁguration space model. We experimented with
m=5, 6, . . . , 20.
13
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
0
10
20
30
40
50
60
70
80
90
100
Cost Improvements (3−way)
Number of compile−time options (m)
Cost Improvement %
m/n ratio=0.1
m/n ratio=0.2
m/n ratio=0.3
m/n ratio=0.4
m/n ratio=0.5
m/n ratio=0.6
m/n ratio=0.7
m/n ratio=0.8
m/n ratio=0.9
(a)
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
0
10
20
30
40
50
60
70
80
90
100
Cost Improvements (4−way)
Number of compile−time options (m)
Cost Improvement %
m/n ratio=0.1
m/n ratio=0.2
m/n ratio=0.3
m/n ratio=0.4
m/n ratio=0.5
m/n ratio=0.6
m/n ratio=0.7
m/n ratio=0.8
m/n ratio=0.9
(b)
Figure 2.
Cost Improvements in a) 3-way b) 4-way cost-aware covering arrays with different m.
• m/n: The ratio of compile-time options to the total
number of options in the conﬁguration space model,
where n is the total number of options and n − m is
the number of runtime options. We experimented with
m/n=0.1, 0.2, . . . , 0.9.
• t: The strength of the covering array. We experimented
with t=3, 4.
In all the conﬁguration space models, we, without losing
the generality, used binary options only. Given m and m/n
ratio, the respective conﬁguration space model is obtained
by adding binary runtime options to the model, such that
the requested m/n ratio is attained. Furthermore, we opted
not to experiment with t=2 because for the m and m/n
values used in the experiments, the sizes of the covering
arrays generated were similar to each other. This made it
difﬁcult to analyze the effect of our independent variables
on the cost-effectiveness of cost-aware covering arrays.
C. Evaluation Framework
To evaluate the cost-effectiveness of cost-aware covering
arrays and compare it to that of traditional covering arrays,
we counted the number of unique compile-time conﬁgura-
tions required by the arrays. That is, we counted the number
of times the system is required to be built. Note that this is
indeed the optimization criterion dictated by the cost model
our algorithm is designed for (Section IV).
When creating the traditional covering arrays, we conﬁg-
ured ACTS to create partially ﬁlled covering arrays. In a
partially ﬁlled covering array, some option settings are left
unset, indicating that, regardless of the actual settings used
for these, as long as they are valid settings for the respective
options, the array will still be a covering array. Once
a partially ﬁlled traditional covering array was obtained,
we followed a greedy approach to pick the best settings
for the unset options so that the number of compile-time
conﬁgurations is reduced as much as possible. Had we had
ACTS to create fully ﬁlled covering arrays, the unset options
would have been randomly set, which could have increased
the number of compile-time conﬁgurations required. There-
fore, the fully ﬁlled traditional covering arrays used in the
comparisons represent the best case scenario for the partially
ﬁlled covering arrays created by ACTS.
D. Data Analysis
Figure 2a-b present the results we obtained. In these
ﬁgures, the horizontal axis denotes the values of m (i.e., the
number of compile-time options) used in the experiments,
whereas the vertical axis depicts the percentage of cost
improvements (i.e., percentage of decrease in the number
of compile-time conﬁgurations required) provided by cost-
aware covering arrays over traditional covering arrays. Fig-
ure 2a is for t=3 and Figure 2b is for t=4.
We ﬁrst observed that the cost-effectiveness of cost-
aware covering arrays were better or the same (but never
worse) compared to that of traditional covering arrays. More
accurately, when t=3, the cost-effectiveness of cost-aware
covering arrays were better than that of traditional covering
arrays in 89% (128 out of 144) of the comparisons. In the
14
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

Table I
3-WAY AND 4-WAY COST IMPROVEMENT (%) AVERAGES FOR DIFFERENT M/N RATIOS.
m/n ratio
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
3-way
54.58
46.31
38.86
31.31
25.63
20.27
14.03
6.89
2.48
4-way
55.83
46.80
39.25
31.83
26.88
20.45
14.80
7.72
1.83
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
0
10
20
30
40
50
60
70
80
Cost Improvements (4−way)
m/n Ratio
Cost Improvement %
m=19
Figure 3.
Cost Improvements in 4-way cost-aware covering arrays with
different m/n ratio for m = 19.
remaining comparisons (i.e., 11% of the comparisons), the
cost-effectiveness of the arrays were the same. When t=4,
the cost-effectiveness of cost-aware covering arrays were
better in 94% and the same in 6% of the comparisons.
We then observed that actual cost improvements varied
depending on the m/n ratio used in the conﬁguration
space models. For a ﬁxed m, as the m/n ratio increased,
cost improvements tended to decrease. Table I presents the
cost improvement percentages. For example, when t=4 and
m=19, the cost-aware covering arrays, compared to the tra-
ditional covering arrays, reduced the cost by 59.24%, 52%,
38.89%, 32.1%, 29.17%, 22.99%, 17.72%, 12%, 5.71%
when m/n=0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, respec-
tively (Figure 3). Clearly, when m/n=1, regardless of the
value of m, as the conﬁguration space model will include
only compile-time options, there will be no difference be-
tween the cost-effectiveness of traditional and cost-aware
covering arrays.
For the values of m and m/n used, when the m/n
ratio was ﬁxed, the cost improvements tended to be stable
regardless of the value of m. On the other hand, when
m ≤ t, as the compile-time conﬁgurations will be tested
signiﬁcantly, there will be no difference between the cost-
effectiveness of traditional and cost-aware covering arrays.
Furthermore, comparing 4-way and 3-way cost-aware
covering arrays with traditional covering arrays, we observed
that 4-way cost-aware covering arrays tended to provide
slightly more cost improvements than 3-way cost-aware
covering arrays; as t was increased from 3 to 4, the cost
improvements over traditional covering arrays tended to
increase (Table I). For example, when m/n=0.1, the average
cost improvement provided by 3-way cost-aware covering
arrays was 54.58%, whereas 4-way cost-aware covering
arrays provided 55.83% cost improvement.
VI. CONCLUSION AND FUTURE WORK
In this paper, we ﬁrst introduced a novel combinatorial
object, called a cost-aware covering array. Unlike traditional
t-way covering arrays, which aim to minimize the number
of conﬁgurations required to cover all valid t-tuples, t-way
cost-aware covering arrays aim to cover all t-tuples in a set
of conﬁgurations, which minimizes a given cost function.
Given a set of conﬁgurations, the cost function computes
the actual cost of testing. Furthermore, since computing the
testing cost in conﬁguration spaces is a nontrivial task, espe-
cially in the presence of reusable components, we provided
a framework for deﬁning the cost function. Finally, we pre-
sented an algorithm to compute cost-aware covering arrays
for a particular cost scenario, and empirically evaluated the
cost-effectiveness of cost-aware covering arrays.
All empirical studies suffer from threats to their internal
and external validity. For this work, we were primarily
concerned with threats to external validity since they limit
our ability to generalize the results of our experiment to
industrial practice. One potential threat is that our algorithm
was designed for a particular cost scenario. However, the
cost scenario used in the paper, although simple, is of great
practical importance.
Another possible threat to external validity concerns the
representativeness of the conﬁguration space models used
in the experiments. Although we systematically varied the
models and evaluated the cost-effectiveness of the proposed
approach, i.e., a total of 288 different models were used (16
values of m × 9 values of m/n × 2 values of t), these
models are still one suite of models. A related issue is that
the conﬁguration space models used in the experiments did
not contain any inter-option constraints. While these issues
pose no theoretical problems (our algorithm can be modiﬁed
to account for constraints), we need to apply our approach
to more realistic conﬁguration space models in future work.
Despite these limitations, we believe our study supports
our basic hypotheses. We reached this conclusion by noting
that our studies showed that: (1) in practice, the testing cost
15
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

may not be the same for all conﬁgurations, (2) accounting for
the presence of reusable components, i.e., the components,
which, once conﬁgured, are reused in other conﬁgurations,
can reduce the testing cost, (3) minimizing the number of
conﬁgurations as is the case in traditional covering arrays
does not necessarily minimize the actual cost of testing,
and (4) the cost-aware covering arrays were generally more
cost-effective than the traditional covering arrays used in the
experiments.
We believe that this line of research is novel and in-
teresting, but much work remains to be done. We are
therefore continuing to develop new approaches that over-
come existing limitations and threats to external validity. In
particular, we are developing tools and algorithms that are
based on metaheuristic search techniques, such as simulated
annealing, to compute cost-aware covering arrays for any
given conﬁguration space model and for any cost function.
REFERENCES
[1] Advanced
Combinatorial
Testing
System
(ACTS),
2010.
http://csrc.nist.gov/groups/SNS/acts/documents/
comparison-report.html 10.23.2012.
[2] R. Brownlie, J. Prowse, and M. S. Phadke. Robust testing
of AT&T PMX/StarMAIL using OATS.
AT&T Technical
Journal, 71(3):41–7, 1992.
[3] R. C. Bryce and C. J. Colbourn.
Prioritized interaction
testing for pair-wise coverage with seeding and constraints.
Information and Software Technology, 48(10):960 – 970,
2006. Advances in Model-based Testing.
[4] R. C. Bryce and C. J. Colbourn. One-test-at-a-time heuristic
search for interaction test suites. In Proceedings of the 9th
annual conference on Genetic and evolutionary computation,
GECCO ’07, pages 1082–1089, New York, NY, USA, 2007.
ACM.
[5] R. C. Bryce and C. J. Colbourn.
A density-based greedy
algorithm for higher strength covering arrays.
Softw. Test.
Verif. Reliab., 19:37–53, March 2009.
[6] D. M. Cohen, S. R. Dalal, M. L. Fredman, and G. C.
Patton.
The AETG system: an approach to testing based
on combinatorial design.
IEEE Transactions on Software
Engineering, 23(7):437–44, 1997.
[7] M. B. Cohen, C. J. Colbourn, and A. C. H. Ling.
Aug-
menting simulated annealing to build interaction test suites.
In Proceedings of the 14th International Symposium on
Software Reliability Engineering, ISSRE ’03, pages 394–405,
Washington, DC, USA, 2003. IEEE Computer Society.
[8] M. B. Cohen, P. B. Gibbons, W. B. Mugridge, and C. J.
Colbourn. Constructing test suites for interaction testing. In
Proceedings of the 25th International Conference on Software
Engineering, ICSE ’03, pages 38–48, Washington, DC, USA,
2003. IEEE Computer Society.
[9] J. Czerwonka. Pairwise testing in the real world: Practical
extensions to test-case scenarios.
In Proc. of the 24th
Paciﬁc Northwest Software Quality Conference, pages 285–
294, 2006.
[10] S. R. Dalal, A. Jain, N. Karunanithi, J. M. Leaton, C. M. Lott,
G. C. Patton, and B. M. Horowitz. Model-based testing in
practice. In Proc. of the Int’l Conf. on Software Engineering,
pages 285–294, 1999.
[11] S. Ghazi and M. Ahmed. Pair-wise test coverage using genetic
algorithms. In Evolutionary Computation, 2003. CEC ’03.
The 2003 Congress on, volume 2, pages 1420–1424, Dec.
2003.
[12] A. Hartman. Software and hardware testing using combinato-
rial covering suites. In M. C. Golumbic and I. B.-A. Hartman,
editors, Graph Theory, Combinatorics and Algorithms, vol-
ume 34 of Operations Research/Computer Science Interfaces
Series, pages 237–266. Springer US, 2005.
[13] N. Kobayashi.
Design and evaluation of automatic test
generation strategies for functional testing of software. Osaka
University, Osaka, Japan, 2002.
[14] Y. Lei, R. Kacker, D. R. Kuhn, V. Okun, and J. Lawrence.
Ipog-ipog-d: efﬁcient test generation for multi-way com-
binatorial testing.
Softw. Test. Verif. Reliab., 18:125–148,
September 2008.
[15] C. Nie and H. Leung.
A survey of combinatorial testing.
ACM Comput. Surv., 43:11:1–11:29, February 2011.
[16] P. J. Schroeder, P. Bolaki, and V. Gopu.
Comparing the
fault detection effectiveness of n-way and random test suites.
In Proceedings of the 2004 International Symposium on
Empirical Software Engineering, pages 49–59, Washington,
DC, USA, 2004. IEEE Computer Society.
[17] T. Shiba, T. Tsuchiya, and T. Kikuno. Using artiﬁcial life
techniques to generate test cases for combinatorial testing.
In Proceedings of the 28th Annual International Computer
Software and Applications Conference - Volume 01, COMP-
SAC ’04, pages 72–77, Washington, DC, USA, 2004. IEEE
Computer Society.
[18] K.-C. Tai and Y. Lei.
A test generation strategy for pair-
wise testing. Software Engineering, IEEE Transactions on,
28(1):109 –111, Jan 2002.
[19] Y.-W. Tung and W. Aldiwan. Automating test case generation
for the new generation mission software system. In Aerospace
Conference Proceedings, 2000 IEEE, volume 1, pages 431 –
437 vol.1, 2000.
[20] A. W. Williams.
Determination of test conﬁgurations for
pair-wise interaction coverage. In Proceedings of the IFIP
TC6/WG6.1 13th International Conference on Testing Com-
municating Systems: Tools and Techniques, TestCom ’00,
pages 59–74, Deventer, The Netherlands, The Netherlands,
2000. Kluwer, B.V.
[21] A. W. Williams and R. L. Probert.
Formulation of the
interaction test coverage problem as an integer program. In
Proceedings of the IFIP 14th International Conference on
Testing Communicating Systems XIV, TestCom ’02, pages
283–298, Deventer, The Netherlands, The Netherlands, 2002.
Kluwer, B.V.
16
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

