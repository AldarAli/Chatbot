Methodology and Experience for Designing Safety-Related Systems in IEC 61508
Zhe Chen
College of Computer Science and Technology
Nanjing University of Aeronautics and Astronautics
29 Yudao Street, 210016 Nanjing, China
Email: zhechen@nuaa.edu.cn
Gilles Motet
LAAS-CNRS, INSA
Universit´e de Toulouse
135 Avenue de Rangueil, 31077 Toulouse, France
Email: gilles.motet@insa-toulouse.fr
Abstract—The international standard IEC 61508 provides a
generic process for electrical, electronic, or programmable elec-
tronic (E/E/PE) safety-related systems (SRS) to achieve an ac-
ceptable level of functional safety. This paper ﬁrst proposes the
concept of functional validity of SRS, based on our observation
on two important problems that occur in industrial practice,
i.e., the rightness of overall and allocated safety requirements
and the lack of technical methodologies for validating SRS.
Functional validity means whether the safety functions realized
by SRS can really prevent accidents and recover the system
from hazardous states, provided the expected safety integrity
level is reached. Then this paper proposes a generic technical
methodology to achieve the functional validity of SRS, and
summarizes industrial experiences in designing functionally
valid SRS. A concrete example is used to illustrate the proposed
methodology.
Keywords-safety-related system; IEC 61508; functional va-
lidity; veriﬁcation; model checking; formal method; SPIN
I. SAFETY-RELATED SYSTEMS AND FUNCTIONAL
VALIDITY
The international standard IEC 61508 [1][2][3] provides
a generic process for electrical, electronic, or programmable
electronic (E/E/PE) safety-related systems to achieve an
acceptable level of functional safety. The principles of IEC
61508 have been recognized as fundamental to modern
safety management [2], thus have gained a widespread
acceptance and been used in practice in many countries and
industry sectors [4].
Like other safety standards (e.g., DO-178B [5]), IEC
61508 gives recommendations on best practices such as
planning, documentation, veriﬁcation, safety assessment,
rather than concrete technical solutions. Thus, it is a generic
standard for the safety management throughout the life-
cycle, rather than a system development standard. More
sector-speciﬁc and application-speciﬁc standards can be de-
rived based on the standard, such as IEC 61511 for process
industry [6], IEC 62061 for machinery industry, IEC 61513
for nuclear plants, EN 50126 for European railway, and ISO
26262 for automotive safety.
As shown in Fig. 1, the ﬁrst premise of the standard is
that there is an equipment intended to provide a function,
and a system which controls it. The equipment is called
an Equipment Under Control (EUC). The Control System
(CS) may be integrated with or remote from the EUC.
A fundamental tenet of the standard is that, even if the
EUC and the CS are reliable, they are not necessarily safe.
This is true for numerous systems implementing hazardous
speciﬁcation. They may pose risks of misdirected energy
which result in accidents.
The second premise is that Safety-Related Systems (SRS)
are provided to implement the expected safety requirements,
which are speciﬁed to reduce the risks and achieve functional
safety for the EUC. The SRS may be placed within or
separated from the CS. In principle, their separation is
preferred.
EUC
Control
System
Safety-Related
System
Figure 1.
The Architecture of Systems with SRS
An SRS may comprise subsystems such as sensors, logic
controllers, communication channels connected to the CS,
and actuators. Usually, an SRS may receive two types of
input: the values of safety-related variables monitored by its
sensors, and the messages sent by the CS. Then the SRS
executes computation to decide whether the system is in a
safe state. According to the result, it may actualize safety
functions through two types of output: directly sending
commands to its actuators, or sending a message to the CS.
Let us consider two important problems that occur in
industrial practice.
The ﬁrst one questions the rightness of overall and
allocated safety requirements. According to IEC 61508,
safety requirements consist of two parts, safety functions and
associated safety integrity levels (SIL). The two elements
are of the same importance in practice, because the safety
functions determine the maximum theoretically possible risk
reduction [7]. However, the standard focuses more on the
realization of integrity requirements rather than function
requirements. As a result, the standard indicates only that
57
DEPEND 2011 : The Fourth International Conference on Dependability
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-149-6

the product is of a given reliable integrity, but not that it
implements the right safety requirements.
Second, the standard does not prescribe exactly how the
veriﬁcation of safety functions of an SRS could technically
be done. On one hand, the standard calls for avoiding faults
in the design phase, since the ALARP principle (As Low As
Reasonably Practicable) is adopted for determining tolera-
bility of risk. Indeed, systematic faults are often introduced
during the speciﬁcation and design phases. Unlike random
hardware failures, the likelihood of systematic failures can-
not easily be estimated. On the other hand, the standard only
recommends a process and a list of techniques and measures
during the design phase to avoid the introduction of system-
atic faults, such as computer-aided design, formal methods
(e.g., temporal logic), assertion programming, recovery (see
parts 2, 3 of [1]). The detailed use of these techniques is
left to the designer.
As a result, the problem of functional validity arises.
Functional validity means whether the safety functions
realized by SRS can really prevent accidents and recover
the system from hazardous states, provided the expected
safety integrity level is reached. People are searching for a
generic technical methodology to achieve functional validity.
In fact, with the introduction of SRS, it becomes much
harder to ensure the safety of the overall system, due to
complex interactions and the resulting huge state space.
Unlike the case of a single CS, human is no longer ca-
pable to analyze manually and clearly the behaviors of the
overall system. Therefore, we shall expect a computer-aided
method.
This paper proposes such a generic technical methodology
(or a framework) for designing functionally valid SRS. To
the best of our knowledge, we are the ﬁrst to consider
the technical solution to functional validity of SRS in the
literature. We focus on the systems that operate on demand
(i.e., discrete event). The methodology is based on computer-
aided design in association with automated veriﬁcation tools
(e.g., SPIN). In Section II, we present a concrete example
illustrating the application of the proposed methodology,
which is formally discussed in Section III. We discuss
related work in Section IV, then conclude in Section V.
II. EXAMPLE: CHEMICAL REACTOR
As an example, consider an accident occurred in a batch
chemical reactor in England [8][9]. Figure 2 shows the
design of the system. The computer, which served as a
control system, controlled the ﬂow of catalyst into the
reactor and the ﬂow of water for cooling off the reaction,
by manipulating the valves. Additionally, the computer re-
ceived sensor inputs indicating the status of the system. The
designers were told that if an abnormal signal occurred in
the plant, they were to leave all controlled variables as they
were and to sound an alarm.
On one occasion, the control system received an abnormal
signal indicating a low oil level in a gearbox, and reacted
as the functional requirements speciﬁed, that is, sounded an
alarm and maintained all the variables with their present
condition. Unfortunately, a catalyst had just been added into
the reactor, but the control system had not yet opened the
ﬂow of cooling water. As a result, the reactor overheated,
the relief valve lifted and the contents of the reactor were
discharged into the atmosphere.
We believe that an SRS could be used to avoid the
accident. Figure 3 shows the role of the SRS in the overall
system. It receives signals from additional sensors, and
communicates with the CS. The key issue is how to specify
and design the SRS and prove its functional validity, i.e.,
the SRS is really efﬁcient in the hazardous context. We
illustrate a methodology based on computer-aided design in
association with the SPIN model checker.
The SPIN (Simple Promela INterpreter) model checker
is an automated tool for verifying the correctness of asyn-
chronous distributed software models [10][11]. Systems and
correctness properties to be veriﬁed are both described
in Promela (Process Meta Language). SPIN also supports
Linear Temporal Logic (LTL) formulas, which are converted
into never claims written in Promela for veriﬁcation. Besides
a checker, SPIN can also operate as a simulator by executing
the model following one possible execution trace.
We will illustrate two main steps of the methodology:
modeling the CS, and modeling the SRS.
Modeling Control Systems. The ﬁrst step is to analyze
the behaviors of the CS by modeling it using Promela.
Listing 1 shows the model. The CS scans the status of the
reactor, and then manipulates the valves according to the
status.
Listing 1.
The Promela Program for Reactor Control System
1 # define
sa
( ( abnorm && ! c a t a ) | | ( abnorm && c a t a && water ) )
2 # define
fcon
s t a t u s == nocata
| |
s t a t u s == en cat a
3 mtype = {abnormal ,
nocata ,
encata ,
nowater ,
enwater };
4 mtype
s t a t u s
= nocata ;
/∗
s t a t u s
of
the
r e a c t o r
∗/
5
bool
c a t a
= f a l s e ;
/∗
whether
c a t a l y s t
flow
i s
open
∗/
6
bool
water
= f a l s e ;
/∗
whether
water
flow
i s
open
∗/
7
bool abnorm = f a l s e ;
/∗
whether
abnormal
s i g n a l
occured
∗/
8
9
/∗ random
s i m u l a t i o n
of
scanning
the
s t a t u s
∗/
10
i n l i n e
scan ( ) {
11
i f
12
: :
true −> s t a t u s
= abnormal ;
13
: :
c a t a
==
f a l s e −> s t a t u s
= nocata ;
14
: :
c a t a
== true
−> s t a t u s
= en cat a ;
15
: :
water ==
f a l s e −> s t a t u s
= nowater ;
16
: :
water == true
−> s t a t u s
= enwater ;
17
f i ;
18 }
19
20
/∗
p o s s i b l e
a c t i o n s
of
the
system
∗/
21
i n l i n e
opencata ( )
{ c a t a =true ;
p r i n t f ( ” open
c a t a −> ” ) ; }
22
i n l i n e
c l o s e c a t a ( ) { c a t a = f a l s e ; p r i n t f ( ” c l o s e
c a t a −> ” ) ;}
23
i n l i n e
openwater ( ) {water=true ;
p r i n t f ( ” open
water −> ” ) ;}
24
i n l i n e
c l o s e w a t e r ( ) {water= f a l s e ; p r i n t f ( ” c l o s e
water −>” ) ;}
25
i n l i n e
alarm ( ) { abnorm = true ;
p r i n t f ( ” alarm −> ” ) ; }
26
i n l i n e
ending ( ) { p r i n t f ( ” ending −> ” ) ; }
27
28
a c t i v e
proctype
c o n t r o l s y s t e m ( ) {
29
/∗ I n i t i a l
a c t i o n s
o m i t t e d ∗/
58
DEPEND 2011 : The Fourth International Conference on Dependability
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-149-6

Gearbox
Catalyst
Reactor
Cooling
Water
Control
System
Figure 2.
Reactor Control System
Gearbox
Catalyst
Reactor
Cooling
Water
Control
System
Safety-Related
System
Figure 3.
Reactor Control System with SRS
30 do
31
: :
scan ( ) ;
32
i f
33
: :
s t a t u s
== abnormal −> alarm ( ) ;
goto END;
34
: :
e l s e −> i f
35
: :
s t a t u s == nocata
&& c a t a == f a l s e −>opencata ( ) ;
36
: :
s t a t u s == encata
&& c a t a ==true −>c l o s e c a t a ( ) ;
37
: :
s t a t u s ==nowater && water == f a l s e −>openwater ( ) ;
38
: :
s t a t u s == enwater && water ==true −>c l o s e w a t e r ( ) ;
39
: :
e l s e −> skip ;
40
f i ;
41
f i ;
42 od ;
43 END:
ending ( ) ;
44
a s s e r t ( sa ) ;
45 }
Lines 1-2 deﬁne macros for specifying correctness prop-
erties.
Lines 3-7 deﬁne the variables. Note that status denotes
the detection of events (e.g., abnormal signal, no catalyst or
enough catalyst in the reactor), and controls the ﬂow of the
computation, while the other three variables save the state
information. Note that abnormal signal may be caused by
several events. For example, low oil level is one of these
events.
Lines 10-18 simulate the input events to the CS. In the
veriﬁcation mode, SPIN can only treat closed system without
users’ input. Therefore, the status of reactor is generated
in a random manner, i.e., the if statement (lines 11-17)
chooses randomly one of the alternative statements whose
condition holds. Note that this matches exactly what happens
in practice, since the status of the reactor is determined
nondeterministically by the reaction and the environment,
not the user.
Lines 21-26 deﬁne the primitive actions of the CS. To
obtain an efﬁcient model for veriﬁcation, the real codes for
manipulating physic equipments are replaced by printf
statements, which could be used for observing the execution
traces of the CS.
Lines 28-45 specify the model of the CS. The non-critical
codes (irrelevant to the concerned property, e.g., the code for
initiation) are omitted or simpliﬁed to produce an efﬁcient
model. In line 44, we check whether the system satisﬁes
the safety assertion sa (cf. line 1), which means when an
abnormal signal occurs, either the ﬂow of catalyst must be
closed, or the ﬂow of water must be also open if the ﬂow of
catalyst is open. The violation of this assertion may result
in the mentioned accident.
In order to see whether the model describes exactly
the behaviors of the CS, we run the model through the
simulation mode of SPIN. One of the outputs is as follows.
1 $ spin
r e a c t o r . pml
# Linux command
2
open
c a t a −> alarm −> ending −>
3
spin :
l i n e
44 ” r e a c t o r . pml” ,
Error :
a s s e r t i o n
v i o l a t e d
The execution trace shows that the alarm is sounded after
opening the ﬂow of catalyst, then the safety assertion is
violated. This trace characterizes exactly what happened in
the accident. It is worth noting that, due to the uncertainty
of the value of status (cf. lines 11-17), the assertion may
be satisﬁed in another run. This is the reason why the plant
had functioned well before the accident. As a result, in the
simulation mode, it is very possible that an existing fault
will not be detected after numerous runs.
To systematically check all the state space, we use the
veriﬁcation mode, which needs correctness properties spec-
ifying hazard-free situation.
One possibility is to use assertions, such as what we did
in line 44. Note that an assertion can only check the state
at a single position in the execution (i.e., line 44), not the
remainder positions. The SPIN checks the assertion in the
veriﬁcation mode as follows.
1 $ spin −a
r e a c t o r . pml
2 $ gcc pan . c
3 $
. / a . out
4
State−v e c t o r
16 byte ,
depth
reached
12 ,
e r r o r s :
1
5
21
s t a t e s ,
s t o r e d
6
0
s t a t e s ,
matched
7
21
t r a n s i t i o n s
(=
s t o r e d +matched )
After examing 21 states, SPIN detected the unsafe state. We
can simulate the counterexample by tracing simulation.
1 $ spin −t
r e a c t o r . pml
2
open
c a t a −> alarm −> ending −>
3
spin :
l i n e
44 ” r e a c t o r . pml” ,
Error :
a s s e r t i o n
v i o l a t e d
The result shows that the unsafe state can really be reached.
59
DEPEND 2011 : The Fourth International Conference on Dependability
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-149-6

Another alternative for specifying correctness property
is LTL formula. For this example, the formula is φ
def
=
G(cata → Fwater), where G means globally and F means
future [12]. It means whenever the ﬂow of catalyst is opened,
the system will have the chance to open the ﬂow of water
in the future. Of course, this is based on a reasonable
assumption that the status will eventually be nowater when
there is not enough water in the reactor (i.e., there is a
reliable sensor). This assumption is expressed by the fairness
condition GF!fcon. The SPIN checks the LTL formula in
the veriﬁcation mode as follows ([] denotes G, <> denotes
F).
1 $ spin −a −f
’ ! [ ] ( c a t a −> <>water )&&[]<>!fcon ’
r e a c t o r . pml
2 $ gcc pan . c
3 $
. / a . out −A −a # d i s a b l e
a s s e r t i o n ,
check
s t u t t e r −
i n v a r i a n t
4
State−v e c t o r
20 byte ,
depth
reached
29 ,
e r r o r s :
1
5
23
s t a t e s ,
s t o r e d
6
1
s t a t e s ,
matched
7
24
t r a n s i t i o n s
(=
s t o r e d +matched )
After examing 23 states, SPIN detected the unsafe state. We
can simulate the counterexample by tracing simulation.
1 $ spin −t
r e a c t o r . pml
2
open
c a t a −> alarm −> ending −>
3
spin :
t r a i l
ends
a f t e r
30
s t e p s
Since we have already known that the CS may cause a haz-
ardous state, we must make sure that the speciﬁed properties
can detect the hazardous state, or else the properties are
not right. Then we introduce an SRS to control potential
hazardous executions.
Modeling Safety-Related Systems. The second step is
to construct the model of the SRS. We reuse the established
model of the CS, and derive an accurate model describing
the behaviors of the SRS. Listing 2 shows the models.
The model of the SRS receives messages sent by the CS,
computes whether the system is safe, and sends a message
back to the CS.
Listing 2.
Reactor Control System with SRS in Promela
1 # define
sa
( ( abnorm && ! c a t a ) | | ( abnorm && c a t a && water ) )
2 # define
fcon
s t a t u s == nocata
| |
s t a t u s == encata
3 mtype = {abnormal ,
nocata ,
encata ,
nowater ,
enwater };
4 mtype
s t a t u s
= nocata ;
/∗
s t a t u s
of
the
r e a c t o r
∗/
5
bool
c a t a
= f a l s e ;
/∗
whether
c a t a l y s t
flow
i s
open ∗/
6
bool
water
= f a l s e ;
/∗
whether
water
flow
i s
open
∗/
7
bool abnorm = f a l s e ;
/∗
whether
abnormal
s i g n a l
occured ∗/
8
9
/∗ d e f i n e
s a f e t y −r e l a t e d
v a r i a b l e s ,
messages
s t r u c t u r e ∗/
10
typedef SRV { bool
water ; }
11
typedef MSG { bool
water ;
bool
abnorm ;
bool
res ; }
12 chan ch = [ 0 ]
of { MSG };
/∗
message
channel
∗/
13
14
/∗ random
s i m u l a t i o n
of
scanning
the
s t a t u s ∗/
15
i n l i n e
scan ( ) {
16
i f
17
: :
true −> s t a t u s
= abnormal ;
18
: :
c a t a
==
f a l s e −> s t a t u s
= nocata ;
19
: :
c a t a
== true
−> s t a t u s
= encata ;
20
: :
water ==
f a l s e −> s t a t u s
= nowater ;
21
: :
water == true
−> s t a t u s
= enwater ;
22
f i ;
23 }
24
25
/∗
p o s s i b l e
a c t i o n s
of
the
system
∗/
26
i n l i n e
opencata ( ) { c a t a =true ;
p r i n t f ( ” open
c a t a −> ” ) ;}
27
i n l i n e
c l o s e c a t a ( ) { c a t a = f a l s e ; p r i n t f ( ” c l o s e
cata−> ” ) ;}
28
i n l i n e
openwater ( )
29
{ water = true ;
c s
2 s r s ( ) ;
p r i n t f ( ” open
water −> ” ) ; }
30
i n l i n e
c l o s e w a t e r ( )
31
{ water = f a l s e ;
c s
2 s r s ( ) ;
p r i n t f ( ” c l o s e
water −> ” ) ;}
32
i n l i n e
alarm ( ) {abnorm=true ; c s
2 s r s ( ) ; p r i n t f ( ” alarm −>” ) ;}
33
i n l i n e
ending ( ) { p r i n t f ( ” ending −> ” ) ; }
34
i n l i n e
cs epro ( )
35
{ p r i n t f ( ” e r r o r
p r o c e s s i n g
( ” ) ;
36
p r i n t f ( ” water
opened ” ) ;
37
water = true ;
38
p r i n t f ( ” ) −> ” ) ; }
39
40
/∗
communication
between CS and SRS ∗/
41
i n l i n e
c s
2 s r s ( ) {
42
i f
43
: :
abnorm == true
−> msg .
abnorm = true ;
44
: :
abnorm ==
f a l s e −> msg .
abnorm = f a l s e ;
45
f i ;
46
i f
47
: :
water == true
−> msg .
water = true ;
48
: :
water ==
f a l s e −> msg .
water = f a l s e ;
49
f i ;
50 msg .
res = true ;
51
ch
! msg ;
52
ch ? msg ;
53
i f
54
: :
msg .
res ==
f a l s e −> cs epro ( ) ;
55
: :
e l s e −> skip ;
56
f i ;
57 }
58
59
a c t i v e
proctype
c o n t r o l s y s t e m ( ) {
60
/∗ I n i t i a l
a c t i o n s
o m i t t e d ∗/
61 MSG msg ;
62 do
63
: :
scan ( ) ;
64
i f
65
: :
s t a t u s
== abnormal −> alarm ( ) ;
goto END;
66
: :
e l s e −> i f
67
: :
s t a t u s == nocata
&& c a t a == f a l s e −>opencata ( ) ;
68
: :
s t a t u s == en ca ta
&& c a t a ==true
−>c l o s e c a t a ( ) ;
69
: :
s t a t u s ==nowater && water == f a l s e −>openwater ( ) ;
70
: :
s t a t u s == enwater && water ==true
−>c l o s e w a t e r ( ) ;
71
: :
e l s e −> skip ;
72
f i ;
73
f i ;
74 od ;
75 END:
ending ( ) ;
76
a s s e r t ( sa ) ;
77 }
78
79
/∗∗∗∗∗∗ The
Safety−r e l a t e d
System ∗∗∗∗∗∗/
80
/∗ random
s i m u l a t i o n
of
scanning
the
val ues
of
v a r i a b l e s ∗/
81
i n l i n e
s r s
s c a n ( ) {
82
i f
83
: :
srv .
water = true ;
84
: :
srv .
water = f a l s e ;
85
f i ;
86 }
87
88
/∗
compute
whether
the
system
i s
s a f e
∗/
89
i n l i n e
srs compute ( ) {
90
i f
91
: :
msg .
abnorm == true && msg .
water == f a l s e −>
92
msg .
res = f a l s e ;
93
: :
msg .
abnorm == true && srv .
water == f a l s e −>
94
msg .
res = f a l s e ;
95
: :
e l s e −> msg .
res = true ;
96
f i
97 }
98
99
a c t i v e
proctype
s r s ( ) {
100
/∗ I n i t i a l
a c t i o n s
o m i t t e d ∗/
101 MSG msg ;
102 SRV srv ;
103 do
104
: :
true −>
60
DEPEND 2011 : The Fourth International Conference on Dependability
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-149-6

105
endsrs :
ch ? msg ;
106
s r s
s c a n ( ) ;
107
srs compute ( ) ;
108
ch
! msg ;
109 od ;
110 }
Lines 10-11 deﬁne the inputs to the SRS. The type SRV
deﬁnes a set of safety-related variables, whose values could
be obtained from additional sensors outside the CS and
managed by the SRS. For this example, SRV monitors only
whether the water ﬂow is open. The type MSG deﬁnes the
structure of the messages communicated between the CS
and the SRS. Line 12 deﬁnes a rendezvous channel for the
message.
In lines 28-32, for each primitive action that modiﬁes
the values of the variables monitored by the SRS, the
communication between the CS and the SRS is inserted.
The communication module (lines 41-57) reads information
needed, and sends a message to the SRS, then receives a
response. The module analyzes the result in the returned
message. If it indicates an unsafe state, the system calls the
error processing module to recover from the hazardous state.
The error processing module (lines 34-38) uses the infor-
mation in the returned message to decide the actions. The
process could change the values of certain variables (e.g.,
line 37) after manipulating physic equipments (e.g., in line
36, printf statement abstracts the action of opening the
valve). Note that more information could be contained in the
returned message in more complex systems (i.e., not only
a boolean result), in order to provide sufﬁcient information
for the error processing module to analyze the current state.
Lines 99-110 deﬁne the model of the SRS. It waits
for the message sent by the CS, then scans the values
of the safety-related variables (lines 81-86), and computes
whether the system is safe using the message and the safety-
related variables (lines 89-97). Finally the SRS sends a
response to the CS. Note that the computation in srs_scan
and srs_compute could be different in various systems.
Embedded C code could be used to implement more com-
plex functions. Anyway, we use the same methodology and
framework.
In order to see whether the model characterizes exactly
the behaviors of the SRS, we run the model through the
simulation mode of SPIN. One of the outputs is as follows.
1
open
c a t a −> e r r o r
p r o c e s s i n g
(
water
opened
) −> alarm −>
ending −>
The execution trace shows that the safety assertion is not
violated, which is exactly what we expect to avoid the
mentioned accident.
Then we check the assertion in the veriﬁcation mode, and
no error is found.
1
State−v e c t o r
40 byte ,
depth
reached
208 ,
e r r o r s :
0
2
409
s t a t e s ,
s t o r e d
3
57
s t a t e s ,
matched
4
466
t r a n s i t i o n s
(=
s t o r e d +matched )
We may also check the LTL formula in the veriﬁcation
mode.
1
State−v e c t o r
44 byte ,
depth
reached
401 ,
e r r o r s :
0
2
707
s t a t e s ,
s t o r e d
(979
v i s i t e d )
3
658
s t a t e s ,
matched
4
1637
t r a n s i t i o n s
(=
v i s i t e d +matched )
Zero errors mean that the assertion holds and the LTL
property always holds in the execution, i.e., no unsafe
state could be reached. Therefore, we conclude that the
established model of the SRS can successfully avoid the
accident, i.e., a “functionally valid” SRS. Note that, if we
use another computation in srs_compute, the SRS may
be not functionally valid (e.g., always let msg._res be
true). That is the reason why we need such a methodology
to ensure functional validity.
It is worth noting that the combination of the CS and the
SRS has 707 states and 1637 transitions (more complex the
overall system, larger the state space). Human is not able to
analyze the correctness of such a complicated system. As
a result, computer-aided design may be the only choice for
developing functionally valid SRS.
III. METHODOLOGY FOR DESIGNING FUNCTIONALLY
VALID SRS
In this section, we propose the generic methodology for
designing functionally valid safety-related systems. As we
mentioned, the state space of the overall system including
the CS and the SRS is much larger than the one of a
single CS or a single SRS. As a result, manual analysis
and design of the SRS are never trustworthy and always
error-prone. This methodology uses computer-aided design
in association with automated veriﬁcation tools, thus can
improve our conﬁdence on the functional validity of the
design of SRS.
We try to list exhaustively all the key issues that we know
in the designing process, in order to guide the practice.
Due to the wide application of the standard and SRS, the
reader may encounter different situation in various projects
and industry sectors. Therefore, some necessary adaptations
should be made in detail for a speciﬁc project.
Generally, there are three steps for developing a function-
ally valid SRS: modeling the CS, modeling the SRS and
implementing the SRS. This paper focuses on the ﬁrst two
steps (i.e., the design process) which lead to a functionally
valid design of the SRS, although it is worth noting that
faults may be also introduced in the implementation process.
Modeling Control Systems. The ﬁrst step is to construct
the model of the CS. The results of this step are a Promela
program for the CS and the correctness properties. We list
some key issues as follows.
(1) The ﬁrst task is to derive accurate and efﬁcient
abstraction of the behaviors of the CS. The criteria for
judging the quality of the model are mainly accuracy and
efﬁciency. Accuracy means that the model behaves exactly
61
DEPEND 2011 : The Fourth International Conference on Dependability
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-149-6

like the real CS, while efﬁciency means that the model is
smart enough, e.g., the program should use as few variables,
statements and memory as possible. Some typical issues are
the following ones:
(a) Deﬁne variables, both for computation and checking.
Some variables are used for computation, that is, implement-
ing control ﬂow, behaviors and semantics of the system.
Some variables are used for representing the state of the
system, so they do not contribute to the functionality of the
system. They are only used in the correctness properties to
check the property of the indicated state.
It is worth noting that the size of variables must be
carefully deﬁned. The principle is “as small as possible”.
The model checker will produce a huge state space, of which
each state contains all the deﬁned variables. As a result,
the restriction from int to byte will save considerable
memory when checking.
(b) Simulate the random inputs to the CS. In the veriﬁca-
tion mode, the Promela model is a closed system. In other
words, it cannot receive users’ inputs. As a result, we must
generate the inputs in the program.
The best way is to generate the inputs randomly, i.e.,
nondeterministically choose one member from the set of all
possible values. The advantage of this method is that it can
simulate the uncertainty of the inputs, that is, we do not
know when a speciﬁc input will occur. For example, consider
the sensors’ signal which is determined by the environment.
(c) Simplify reasonably the computation of the CS. Due
to the size and complexity of the real system, an automated
model checker may not even be able to produce the result in
an acceptable instant. Obviously, the huge size contributes
to a huge number of states, and the complexity contributes
to a huge number of transitions. As a result, the size of the
state space may be much larger than the memory, then the
model checker will fail to accomplish the veriﬁcation.
One solution is to provide a more coarse abstraction of
the CS. That is, we omit some non-critical computations,
e.g., the initiation of the system. Furthermore, some manip-
ulations of physical equipments can be expressed with only
a printf statement, which does not increase the size of
the state space.
Another solution is to decompose the system into several
parts, and check these parts one by one. When checking one
single part, we make the assumption that the other parts are
correct. It is worth noting that the decomposition is relevant
to the properties to check. That is, we must put all the
functions relevant to a certain property into the same part,
when checking the property.
(d) Use embedded C codes if necessary. Due to the com-
plexity of embedded C codes and the lack of syntax check-
ing, they are mainly used for automated model extraction
in SPIN. However, the strong expressive power of C code
is anyway a tempting feature. Thus the recommendation is
made only “if necessary”.
(e) Simplify or eliminate the codes for controlling equip-
ments. Usually we assume that the codes for implementing
primitive manipulations are correct, e.g., opening the ﬂow
of water.
(2) The second task is to derive correctness properties,
i.e., assertions and LTL formulas.
(a) Assertions are used to check the property at a speciﬁc
position in the program. Obviously, the expressive power is
limited. Thus, if we want to check a property over all the
state space, we must use LTL formulas.
(b) LTL formulas are used to check all the states in
the system. Obviously, LTL formulas are more powerful.
However, it is also worth noting that LTL formulas can
considerably largen the state space. Thus we suggest to use
them only when assertions are not able to express a property.
(3) Some Experiences.
(a) Check the exactitude of the established model, by
using simulation mode. The printf statement can be used
to output information about the state of the CS. Simulating
the model for sufﬁcient many times can show whether the
model works as expected. Note that the criteria “sufﬁcient
many times” is due to the uncertainty of the inputs.
(b) Check the exactitude of the correctness properties, by
using veriﬁcation mode. If we aim at creating or modifying
an SRS for identiﬁed risks, we must make sure that the
correctness properties can detect the error caused by the
identiﬁed risks.
Modeling Safety-Related Systems. The second task is
to construct the model of the SRS. The results of this
step are a Promela program for the SRS and the codes for
communication and error processing in the modiﬁed model
of the CS. We list some key issues as follows.
(1) The premise is that we have the model of the CS
and reuse it, e.g., the results of the last step.
(2) The ﬁrst task is to derive accurate and efﬁcient
abstraction of the behaviors of the SRS. Some typical
issues are the following ones:
(a) Deﬁne the scope of input and output of the SRS. There
are two types of input: the message sent by the CS and the
values of safety-related variables sent by the sensors. The
SRS may use only one of the two types, or both of them.
There are two types of output: the message sent to the CS
and the direct manipulation of the equipment. Also, the SRS
may use only one of the two types, or both of them.
(b) Deﬁne safety-related variables. A safety-related vari-
able, which saves a value sent by sensors, is used to collect
additional information which is beyond the scope of the CS,
or to collect a speciﬁc piece of information in the scope
of the CS for increasing the reliability of the information.
Note that more safety-related variables means higher cost of
implementation.
(c) Choose the type of communication between the CS
and the SRS. The SPIN model checker supports two types of
communications: rendezvous and buffered communication.
62
DEPEND 2011 : The Fourth International Conference on Dependability
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-149-6

In order to process the demand from the CS to the SRS as
soon as possible, and also provide information from the SRS
to the CS to decide the next action, we usually choose the
rendezvous communication.
(d) Deﬁne the structure of message. This depends on the
information needed by the CS and the SRS. The values of
the variables monitored by the SRS should be sent from
the CS to the SRS. The message should also contain all
the necessary information needed by the CS to deal with
risks. In the simplest case, it is a Boolean result, indicating
the system is safe or not. However, generally, the CS need
more information to determine why the system is not safe,
then it can activate corresponding error processing functions.
(e) Deﬁne message channels. Usually, one channel is
enough for the communication between the CS and the SRS.
(f) Simulate the scanning of the values of safety-related
variables. It is similar to the case “simulate the random
inputs to the CS”. The random simulation express exactly
the fact that the values are nondeterministically decided by
the environment.
(g) Simplify reasonably the computation of the SRS.
(Similar to the case of the CS.)
(h) Use embedded C code if necessary. (Similar to the
case of the CS.)
(3) The second task is to deﬁne the position for the
communication between the CS and the SRS. Gener-
ally, the usual location is between the assignment of key
variables monitored by the SRS and the manipulation of
physical equipment. Therefore, the SRS can check whether
the system will be safe if the next manipulation is executed.
If no, the SRS can send a message to activate the error
processing functions.
(4) The third task is to deﬁne the function of error
processing. This step is different for different projects,
because it is based on the requirements of a speciﬁc system.
In fact, the correctness of error processing also plays an
important role in the correctness of the overall system and
the functional validity of the SRS.
(5) Some Experiences.
(a) Check the exactitude of the established model, by
using simulation mode. (Similar to the case of the CS.)
(b) Check the exactitude of the correctness properties,
by using veriﬁcation mode. We must make sure that the
overall system (including the CS and the SRS) is safe, i.e.,
satisﬁes the speciﬁed correctness properties. If we aim at
creating or modifying an SRS for identiﬁed risks, we must
make sure that the overall system can avoid the previously
detected errors, since the SRS component and additional
error processing functions have been added.
If errors are detected, we must check the design of the
SRS, and also the exactitude of the correctness properties
(because they may specify a semantics different from what
we expect).
Implement the SRS. We implement the SRS using the
established model and computation. Note that faults may
also occur at this step. Since numerous guidelines exist in
industrial sectors to handle this issue, the discussion on
reliable implementation is beyond the scope of this paper.
IV. RELATED WORK
The use of formal methods and model checking for
ensuring safety or proving the absence of certain hazards
is not new in the literature.
For example, Eriksson [13] showed how formal veriﬁ-
cation can be used in a retrospective safety case through
an example taken from railway signalling. This approach
can be used to demonstrate the safety of the safety-critical
systems in operation which were developed according to
old practises that would be regarded as unacceptable today.
In this application of formal methods, several particular
problems were discussed, such as uncertainty about the
original requirements and the required safety level of the
various system functions.
The ForMoSA project [14] developed an integrated ap-
proach for safety analysis of critical embedded systems. The
approach brings together the best of engineering practice,
formal methods and mathematics: traditional safety analysis,
temporal logics and veriﬁcation, and statistics and optimiza-
tion. These three orthogonal techniques cover three different
aspects of safety: fault tolerance, functional correctness and
quantitative analysis.
However, these works in the literature only focus on how
to ensuring safety, rather than the functional validity of
SRS in IEC 61508. Note that one key idea of the standard
is the separation of the CS and the SRS. Thus ensuring
the functional validity of SRS is different from the safety
issues of a single control system which are discussed in the
literature. Therefore, we are the ﬁrst to consider the technical
solution to functional validity of SRS in the literature.
Furthermore, our related papers [15][16] proposed the
theory of formal control systems, based on the traditional
automata theory. A formal control system consists of two
automata. The controlled automaton is monitored by the
controlling automaton to satisfy the given speciﬁcation. The
theory can be considered as the theoretical foundation of
the SRS. The interested reader is referred to [15][16], since
the theoretical aspect is beyond the scope of this industrial
practice-oriented paper.
V. CONCLUSION
This paper ﬁrst proposed the concept of functional validity
of SRS, based on our observation on two important problems
that occur in industrial practice, i.e., the rightness of overall
and allocated safety requirements and the lack of technical
methodologies for validating SRS.
Then this paper proposed a generic technical methodology
(or a framework) which is based on computer-aided design
63
DEPEND 2011 : The Fourth International Conference on Dependability
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-149-6

in association with automated veriﬁcation tools, for design-
ing functionally valid SRS. To the best of our knowledge, we
are the ﬁrst to consider the technical solution to functional
validity of SRS in the literature.
The case study provided a customized demonstration of
applying the methodology. The same methodology may
be used for other situations by taking into account only
some necessary adaptations, since it is a generic modeling
approach for designing functionally valid SRS.
There are also some limitations of the proposed approach.
First, the approach cannot completely eliminate design de-
fects. This is due to the fact that it is not possible to identify
all the safety requirements and correctness properties before
veriﬁcation. As a solution, we may use some sophisticated
methodologies discussed in the literature to analyze hazards
and their probabilities, e.g. fault tree analysis. Second, the
modeling process is generally manual. We may consider
how to automate the modeling process to decrease the time
required for validation. Third, like other model checking
techniques, the state explosion problem is also a challenge
for scaling up the approach. One possible solution is to
improve the model checking algorithm to reduce the state
space [17]. Another possible solution is to develop optimized
and customized model checker for verifying SRS.
ACKNOWLEDGMENT
This work was supported by the China Postdoctoral
Science Foundation and the National Natural Science Foun-
dation of China (60703033 and 61033002). The authors
are grateful to the anonymous referees for their detailed
comments and helpful suggestions.
REFERENCES
[1] IEC, IEC 61508, Functional Safety of Electrical/Electron-
ic/Programmable Electronic Safety-Related Systems.
Inter-
national Electrotechnical Commission, 1999.
[2] F. Redmill, “IEC 61508 - principles and use in the manage-
ment of safety,” Computing & Control Engineering Journal,
vol. 9, no. 5, pp. 205–213, 1998.
[3] S. Brown, “Overview of IEC 61508 - design of electrical/-
electronic/programmable electronic safety-related systems,”
Computing & Control Engineering Journal, vol. 11, no. 1,
pp. 6–12, 2000.
[4] R. Faller, “Project experience with IEC 61508 and its conse-
quences,” Safety Science, vol. 42, no. 5, pp. 405–422, 2004.
[5] D. S. Herrmann, Software Safety and Reliability: Techniques,
Approaches, and Standards of Key Industrial Sectors.
IEEE
Computer Society, 2000.
[6] H. Gall, “Functional safety IEC 61508 / IEC 61511 the
impact to certiﬁcation and the user,” in Proceedings of the
6th ACS/IEEE International Conference on Computer Systems
and Applications (AICCSA 2008).
IEEE, 2008, pp. 1027–
1031.
[7] D. Fowler and P. Bennett, “IEC 61508 - a suitable bases for
the certiﬁcation of safety-critical transport-infrastructure sys-
tems??” in Proceedings of the 19th International Conference
on Computer Safety, Reliability and Security (SAFECOMP
2000), ser. Lecture Notes in Computer Science, F. Koornneef
and M. van der Meulen, Eds., vol. 1943.
Springer, 2000,
pp. 250–263.
[8] T. Kletz, “Human problems with computer control,” Plant/-
Operations Progress, vol. 1, no. 4, 1982.
[9] N.
Leveson,
Safeware:
System
Safety
and
Computers.
Addison-Wesley, Reading, MA, 1995.
[10] G. J. Holzmann, “The model checker SPIN,” IEEE Transac-
tions on Software Engineering, vol. 23, no. 5, pp. 279–295,
1997.
[11] G. J. Holzmann, The SPIN Model Checker: Primer and
Reference Manual.
Addison-Wesley Professional, 2003.
[12] E. M. Clarke, O. Grumberg, and D. A. Peled, Model Check-
ing.
The MIT Press, 2000.
[13] L. henrik Eriksson, “Using formal methods in a retrospec-
tive safety case,” in Proceedings of the 23rd International
Conference on Computer Safety, Reliability and Security
(SAFECOMP 2004), ser. Lecture Notes in Computer Science,
vol. 3219.
Springer, 2004, pp. 31–44.
[14] F. Ortmeier, A. Thums, G. Schellhorn, and W. Reif, “Com-
bining formal methods and safety analysis - the formosa
approach,” in Integration of Software Speciﬁcation Techniques
for Applications in Engineering, ser. Lecture Notes in Com-
puter Science, vol. 3147.
Springer, 2004, pp. 474–493.
[15] Z. Chen and G. Motet, “Towards better support for the
evolution of safety requirements via the model monitoring
approach,” in Proceedings of the 32nd International Confer-
ence on Software Engineering (ICSE 2010).
ACM, 2010,
pp. 219–222.
[16] Z. Chen and G. Motet, “System safety requirements as control
structures,” in Proceedings of the 33rd Annual IEEE In-
ternational Computer Software and Applications Conference
(COMPSAC 2009). IEEE Computer Society, 2009, pp. 324–
331.
[17] Z. Chen and G. Motet, “Nevertrace claims for model check-
ing,” in Proceedings of the 17th International SPIN Workshop
on Model Checking of Software (SPIN 2010), ser. Lecture
Notes in Computer Science, vol. 6349.
Springer, 2010, pp.
162–179.
64
DEPEND 2011 : The Fourth International Conference on Dependability
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-149-6

