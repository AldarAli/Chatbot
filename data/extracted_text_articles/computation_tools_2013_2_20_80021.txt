Using an Expression Interpreter to Reason With
Partial Terms
Lev Naiman
Department of Computer Science
University of Toronto
Toronto, Canada
Email: naiman@cs.toronto.edu
Abstract —
Reﬁnements of programming speciﬁcations often
include partial terms and need to be handled using formal rules.
The idea of an expression interpreter over character strings is
presented as a candidate solution. The interpreter allows for
reasoning with partial terms without requiring a meta-logic or
a logic with more than two values. We show how the interpreter
can be used to create generic and compact laws, which also allow
simple reasoning about expressions syntactically. We argue that
it is simple to integrate the interpreter within existing theorem
provers.
Keywords
—
logic; partial-terms;expression interpreter;
theorem prover; two-valued logic
I. INTRODUCTION
In programming speciﬁcations and their reﬁnements we
commonly encounter partial terms. Partial terms are deﬁned as
expressions that fail to denote a value. A term t in a theory T
is partial if there are no laws in T that apply to t. An example
is where a function or an operator is applied to an argument
outside of its domain, such as 1/0. We also say that a formula e
is unclassiﬁed in theory T if it is neither classiﬁed as a theorem
or an anti-theorem. Such expressions are present in proofs
of programs due to the partial functions and operators that
are often used in speciﬁcations. Borrowing an example from
[1], we might implement the difference function as follows
(where the domain of diff is integers, and the assumed theory
is arithmetic and ﬁrst-order two-valued logic).
diff i j = if i = j then 0 else (diff i (j + 1)) + 1 ﬁ
(1)
We would like to prove
∀i, j : int · i ≥ j ⇒ (diff i j) = i − j
(2)
but when trying to simplify this expression instantiated with
1 and 2 respectively for i and j we get
1 ≥ 2
⇒
(diff 1 2) = 1 − 2
(3)
= F
⇒
(diff 1 2) = −1
and we cannot apply any laws at this point to simplify it
further. A law would allow simplifying the expression to true,
but it requires that both operands be boolean. The expression
diff 1 2 is a partial term because no laws apply to it. For this
reason we cannot use any law to conclude that (diff 1 2) = −1
is a boolean, even though it has the form X = Y . Tools
that reason with such expressions must be based on formal
rules in order to have conﬁdence in their proofs. We propose
a character-string interpreter to solve this problem.
The rest of the paper is organized as follows: in section II
we examine the existing approaches in the literature to cope
with partial terms. In section III we describe the background
theories we use to deﬁne the interpreter in IV. Section V
shows how the interpreter can be used to cope with partial
terms. Section VI describes other beneﬁts of the interpreter
when constructing theories. Section VII describes how we can
extend the deﬁnition of the interpreter to be more expressive.
II. CURRENT APPROACHES TO PARTIAL TERMS
One approach to resolve partial terms is to make all terms
denote. Formally this means that for each partial term such
as x/0, a law must exist saying which set of values that
expression is a member of. This set of values is assumed to
already be deﬁned in the logic, as opposed to newly created
values. In this case there could be a law deﬁned saying that
∀x : int · x/0 : int. This is the approach used in the
programming theory of [2]. Such laws do not explicitly say
what value a partial term is equal to, and this can cause certain
peculiar and possibly unwanted results such as 0/0 = 0 being
a theorem.
0
(4)
= 0 × (1/0)
= 1 × (0/0)
= 0/0
This approach can be slightly modiﬁed and the value of partial
terms can be ﬁxed. However, this might cause some unwanted
properties. In the case of division by zero a choice of 42 as
used in [3] cannot be allowed due to inconsistency.
In [4] the authors point out that underspeciﬁcation alone
may cause problems. If we allow domains of single elements
then these problems can go as far as inconsistency. The
semantic model of our interpreter uses underspeciﬁcation, but
not exclusively. In some cases, similarly to LPF, the interpreter
would leave some expressions unclassiﬁed. One way of ﬁnding
a model for partial functions in set theory is the standard
approach of mapping any unmapped element from the domain
to a special value, usually called ⊥ [5]. The denotational
semantics for a generic law for equality are extended with
37
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

TABLE I
THREE-VALUED BOOLEAN OPERATORS
T
F
⊥
¬
F
T
⊥
TT
TF
FT
FF
T⊥
⊥T
⊥F
F⊥
⊥⊥
∨
T
T
T
F
T
T
⊥
⊥
⊥
∧
T
F
F
F
⊥
⊥
F
F
⊥
this value, and in this particular model 7/0 = 5/0 would be a
theorem (assuming strict equality). However, a user of a logic
that includes the interpreter would not need to perform any
calculations that concern this extra value.
The logic of partial terms (LPT) [6], [7] is an example
of a logic that does not include the undeﬁned constant. It
does however include a deﬁnedness operator ↓. In this theory
the specialization law (∀x · A(x)) ⇒ A(v) requires that v
be deﬁned. The basic logic of partial terms (BPT) [8] is a
modiﬁcation of LPT, and relaxes the previous requirement
for some laws. It allows for reasoning with non-terminating
functional programs. Some logics such as [9] inlcude multiple
notions of equality to be used in calculations. This may
complicate the laws of quantiﬁers.
Another approach to deal with partial terms is a non-
classical logic such as LPF [3] with more than two values.
In these logics the truth table of boolean operators is usually
extended as in table I (where ⊥ represents an “undeﬁned”
value, and the column heads are both of the arguments to
the operator). In this logic the expression 0/0 = 1 would not
be classiﬁed to one of the boolean values, but would rather
be classiﬁed as ⊥. Undeﬁnedness is either resolved by the
boolean operators or is carried up the tree of the expression.
Some three valued logics have a distinct undeﬁned value for
each value domain, such as integers and booleans.
Three and more valued logics have varied useful applica-
tions. However, a drawback of using a logic with multiple
truth values is that certain useful boolean laws no longer hold.
This is particularly true of the law of the excluded middle,
∀x : bool · x ∨ ¬x, which in a three value logic can be
modiﬁed to ∀x : bool · x ∨ ¬x ∨ undefined(x). In the Logic
of Computable Functions (LCF) [10] there is a ⊥t value for
each type t, requiring the modiﬁcation of several laws. Another
issue of multiple valued logics is that not knowing the value
of an expression seems to be pushed one level up; attempting
to formalize these extra values will result in a semantic gap.
There are always expressions that must remain unclassiﬁed for
a theory to remain consistent.
A further method of dealing with partial terms is condi-
tional, or short-circuit operators [11]. This approach is similar
to those logics with three values, since it gives special treat-
ment to partial terms. Boolean operators have an analogous
syntax a cor b, a cand b, a cimp b, etc. In these expressions
if the ﬁrst value is undeﬁned, then the whole expression is
undeﬁned. These conditional operators are not commutative.
III. BACKGROUND THEORIES
We introduce two theories from [12] that we will use to
deﬁne the interpreter.
A. Bunch Theory
A bunch is a collection of objects. It is different from a
set, which is a collection of objects in a package. A bunch is
instead just those objects, and a bunch of a single element is
just the element itself. Every expression is a bunch, but not
all bunches are elementary. Here are two bunch operators.
A , B
A union B (5)
A : B
A in B, or A included in B (6)
Operators such as a comma, colon, and equality apply to whole
bunches, but some operators apply to their elements instead.
In other words, they distribute over bunch union. For example
1 + (4, 7)
(7)
= 1 + 4 , 1 + 7
= 5 , 8
Bunch distribution is similar to a cross-product in set theory.
B. String Theory
A string is an indexed collection of objects. It is different
from a list or ordered pair, which are indexed collections of
objects in a package. A string of a single item is just that item.
The simplest string is the empty string, called nil. Strings are
joined together, or concatenated with the semicolon operator
to form larger strings. This operator is associative but not
commutative. The string 0; 1 has zero as the ﬁrst item and
one as the second. For a natural number n and a string S,
n ∗ S means n copies of S. Let nat be the bunch of natural
numbers. The copies operator is deﬁned as follows.
0 ∗ S = nil
(8)
∀ n : nat · (n + 1) ∗ S = n ∗ S; S
(9)
Strings can be indexed, and their length can be obtained with
the length operator (↔).
Sn
S at index n (10)
↔ S
length of S (11)
A semicolon distributes over bunch union, as so does an
asterisk in its left operand. Some examples of the operators
deﬁned are
↔ (7; 1; 0) = 3
(12)
(7; 1; 0)0 = 7
1; (5, 17); 0 = (1; 5; 0), (1; 17; 0)
3 ∗ (0; 1) = 0; 1; 0; 1; 0; 1
(0, 1) ∗ (0; 1) = 0 ∗ (0; 1), 1 ∗ (0; 1) = nil, 0; 1
The preﬁx copies operator ∗S is deﬁned to mean nat ∗ S, or
informally the bunch of any number of copies of S. Finally,
38
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

we introduce characters, which we write with double quote
marks such as “a”, “b”, etc. To include the open and close
double-quote characters we escape them with a backslash:
“\“”. Strings that contain exclusively character strings are
sometimes abbreviated with a single pair of quotes: “abc” is
short for “a”; “b”; “c”. If the bunch of all characters is called
char, then the bunch of all two-character strings is char; char.
Bunch and string theory are used because they allow for
compact language deﬁnitions. For example, denoting the col-
lection of naturals greater than zero in set theory can be done
by writing {n : nat|n > 0}. In bunch theory it can be written
as nat + 1. We can of course deﬁne an addition operator
that distributes over the contents of a set, but the beneﬁt of
bunch theory (and analogously string theory) is that no such
duplication is necessary.
IV. DEFINING THE INTERPRETER
We would like a simple method to reason with partial terms
that introduces as few new operators as possible, and which
preserves the properties of existing operators. We would also
like to avoid a separate meta-language, and to do all reasoning
within a single logic. In the literature authors often use one
set of symbols for the meta-logic operators and another for
the object logic. We use character strings instead both for
clarity, and in the case where we wish to use the logic to
study itself. We take the idea of the character-string predicate
of Hehner [13], and we expand it to be a general interpreter
for any expression in our language. To maintain consistency
we exclude the interpreter itself from the interpreted language.
The interpreter, which we call I is an operator which applies to
character strings and produces an expression. The interpreter
can be thought of as unquoting a string. We ﬁrst deﬁne our
language as a bunch of character strings.
Let char be the bunch of all character symbols, let alpha
be the bunch of character symbols in the English alphabet,
and let digit be the bunch of digit character. We deﬁne our
language lang to be the following bunch of strings.
alpha; ∗alpha; ∗“′” = var
(13)
digit; ∗digit = num
binops = “ ∧ ”, “ ∨ ”, “ = ”, “ ⇒ ”, “ ⇐ ”, “; ”, “ − ”, “ ”
var, num, “T”, “F” : lang
“⟨”; var; “ : ”; lang; “ → ”; lang; “⟩” : lang
“(”; lang; “)” : lang
lang; binops; lang : lang
“¬”, “ − ”, “∀”, “∃”; lang : lang
“\“”; ∗char; “\”” : lang
Here we have deﬁned a language that includes boolean
algebra, numbers, logical quantiﬁers, functions, and strings.
The language is deﬁned similarly to how a grammar for a
language would be given. Function syntax is ⟨v : D → B⟩,
where the angle brackets denote the scope of the function, and
v is the introduced variable of type D. We treat quantiﬁers as
operators that apply to functions. The quantiﬁers ∃ and ∀ give
boolean results. When we use more standard notation such
as ∀v : domain · body we mean it as an abbreviation for
∀⟨v : D → B⟩.
The interpreter is intuitively similar to a program interpreter:
it turns passive data into active code. Our interpreter turns a
text that represents an expression into the expression itself. The
interpreter is deﬁned very closely to how lang was deﬁned.
The laws are as follows.
I“T” = T
(14)
I“F” = F
∀ s : (digit; ∗digit) · ∀ d : digit · I(s; d) = (Is) × 10 + (Id)
∀ dom, body : lang·
I(“⟨a : ”; dom; “ → ”; body; “⟩”) = ⟨a : Idom → Ibody⟩
∀ s : lang · I“(”; s; “)” = Is
∧
I(“¬”; “(”; s; “)”) = ¬(Is)
∧
I(“∀”; “(”; s; “)”) = ∀(Is)
∧
I(“∃”; “(”; s; “)”) = ∃(Is)
∧
I(“ − ”; “(”; s; “)”) = −(Is)
∀s, t : lang · I(“(”; s; “)”; “ ∧ ”; “(”; t; “)”) = (Is) ∧ (It)
∧
I(“(”; s; “)”; “ = ”; “(”; t; “)”) = (Is) = (It)
∧
I(“(”; s; “)”; “ ⇒ ”; “(”; t; “)”) = (Is) ⇒ (It) ∧
I(“(”; s; “)”; “ ⇐ ”; “(”; t; “)”) = (Is) ⇐ (It) ∧
I(“(”; s; “)”; “; ” ; “(”; t; “)”) = (Is); (It)
∧
I(“(”; s; “)”; “ − ”; “(”; t; “)”) = (Is) − (It)
∧
I(“(”; s; “)”; “ ”; “(”; t; “)”) = (Is) (It)
∀ s : ∗char · I(“\“”; s; “\””) = s
To save space we leave out the interpretation of each digit.
For scopes the introduced variable must be an identiﬁer, and
the expression Ia in that position would not satisfy this
requirement. We instead have a law for only the identiﬁer a,
and other identiﬁers can be obtained through an application
of a renaming law. We add character brackets to these laws in
order to avoid precedence issues.
Note that we deﬁned lang as a bunch of texts, and not the
expressions themselves. When these texts are interpreted, the
results are expressions or values in the language. The text “2”
is in lang, but not the value 2. The interpreter is similar to
a function of strings and distributes over bunch union. It is
of course possible to have a logical language to parallel the
texts in lang; all the expressions in the language which do
not contain I can then be denoted as I lang. In this paper
we leave out some operators from lang, such as the ones in
bunch theory.
The interpreter is similar to a traditional semantic valuation
function, with a few differences. First, the interpreter is a way
of encoding meta-logic within the logic itself; no extra meta-
logic is required. Second, the interpreter does not necessarily
map every string in the language to a value. Rather, we
later introduce generic laws that reason with such expressions
directly. Lastly, we will show how the interpreter can be
included in the interpreted language without inconsistency.
39
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

A. Variables
One signiﬁcant change that we allow in our logic is for
variables. The interpreter needs to refer to an inﬁnite collection
of strings that represent variables, and there is no simple
way to refer to all variables themselves. We would like the
interpretation of a string representing a variable to be the
variable that is represented:
I “a” = a
(15)
I “b” = b
. . .
We instead say that a variable with the name a is an abbre-
viation for I“a”, and similarly for all other variable names.
Although in our initial deﬁnition we excluded the interpreter
from the interpreted strings, we later show in VII how we can
extend our language to safely include the interpreter.
There is an important consequence of making variable
syntax more expressive: function application and variable
instantiation is no longer a decidable procedure in general.
This is because deciding whether two variable strings are
equal is now as difﬁcult as all of proving. However, this
does not pose a problem for the implementation of function
application along with the interpreter in a theorem prover. The
simple solution is that whenever we see an interpreter in the
body, we simply do not apply the function. We argue that
this rarely hinders the use of the interpreter, since users can
do all calculation in the sub-language that does not include
the interpreter, exactly as before. In the case where reasoning
with the interpreter is desired, standard proof obligations can
be generated and discharged.
We ﬁnish this section by noting that we could have simpli-
ﬁed the deﬁnition considerably if we had a fully parenthesized
preﬁx language. All operator interpretation could be com-
pressed to a single law, and some bracket characters removed.
V. RESOLVING PARTIAL TERMS WITH THE INTERPRETER
Our solution to reasoning with partial terms is neither at the
term or propositional level. We rather say that some operators,
such as equality or bunch inclusion are generic. For example,
here are two of the generic laws for equality.
∀a, b : lang · I (a; “ = ”; b) : bool
Boolean Equality (16)
∀a : I lang · a = a
Reﬂexivity (17)
The ﬁrst law says that any equality is a boolean expression,
similarly to the Excluded Fourth Law in LPF which implies an
equality is either true, false or undeﬁned [1]. The arguments
can be any expressions in the interpreted language. For a
simple formal example of the use of the law we continue with
the difference example.
(18)
F ⇒ diff 1 2 = −1
Bool Base Law
Type Checking Proof Obligation
(diff 1 2 = −1) : bool
Interpreter laws
= I“diff 1 2 = −1” : bool
String Assoc.
= I(“diff 1 2”; “ = ”; “ − 1”) : bool
Bool Equality
= T
= T
As we can see in the example, since the interpreter unquotes
expressions, using it in proofs is usually just the reverse
process.
A. Implementation
In general, implementing laws that use the interpreter in a
theorem prover is non-trivial. This is because it is difﬁcult to
determine if uniﬁcation alone is sufﬁcient to check if a law
applies. We deliberately wrote two equality laws differently to
illustrate a couple cases where this task can be made easy. If
the only place the interpreter appears in a law is the expression
I lang in the domain of a variable, it can be treated as a
generic type. Type checking can be done by scanning to
see that the interpreter does not appear in any instantiated
expression with a generic type. In the case of the second law,
instantiating the variables and parsing yields a valid expression
without any further computation.
VI. METALOGICAL REASONING WITHIN THE LOGIC
There are several beneﬁts of deﬁning the interpreter and
using it to create laws. One such beneﬁt is the creation
of generic laws, where type-checking for variables is not
necessary. The removal of type-checking is not only beneﬁcial
for simplicity, partiality, and efﬁciency, but some operators
are meant to be truly generic. For example, the left operand
of the set-membership operator (∈) can be any expression
in the language, and set brackets can be placed around any
expression. By including the interpreter in the logic these laws
are expressed with full formality. For sets, an example would
be
∀A, B : I lang · ({A} = {B}) = (A = B)
(19)
Another beneﬁt is compact laws. For example, we wish to
deﬁne a generic symmetry law for natural arithmetic in our
logic. If we had a preﬁx notation then we could have written
it like this.
∀f : (+, ×, =) · ∀a, b : nat· = (f a b)(f b a)
(20)
Using the interpreter we can create a law in a similar fashion
for non-preﬁx notation.
∀f : “ + ”, “ × ”, “ = ” · ∀a, b : lang·
(21)
I (a, b) : nat ⇒ I (a; f; b) = I (b; f; a)
40
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

This law can be made completely generic and include more
than arithmetic operators. It even becomes simpler to write.
∀f : “ + ”, “ × ”, “ ∧ ”, “ ∨ ”, “ = ” · ∀a, b : lang·
(22)
I (a; f; b) = I (b; f; a)
(23)
These sorts of laws allow us to capture an idea like
associativity or commutativity in a compact way, and can be
easily extended by concatenating to the operator text.
One of the most useful features of the interpreter is rea-
soning about the syntactic structure of an expression without
requiring a meta-logic. These laws include function application
and several programming laws. Some laws have caveats, such
as requiring that in some expressions certain variables or
operators do not appear. For example, there is a quantiﬁer
law for ∀ that says if the variable a does not appear free in
P.
(∀a : D · P) = P
(24)
We would like to formalize this caveat. It is straight forward to
write a program that checks variable or operator appearance
in a string (respecting scope). We formalize a speciﬁcation
of the “no free variable” requirement using the interpreter.
For simplicity, assume that variables are single characters, and
strings are not in the interpreted language. For a string P in
our language and a variable named a we specify
∃i : (0.. ↔ P) · Pi = “a”
∧
(25)
¬∃s, t, D, pre, post : ∗char·
(pre; “⟨a : ”; D; “ → ”; s; Pi; t; “⟩”; post) = P
∨ (pre; “⟨”; Pi; D; “ → ”; s; “⟩”; post) = P
This speciﬁcation says that a is free in P. The ﬁrst part says
that there is an index i in P at which a appears. The second
part says that a is not local. Let free denote this speciﬁcation
parameterized for an expression and a variable; free “a” P
says that a is free in P. The caveat for the quantiﬁer law is
formalized as
¬(free “a” P)
⇒
I (“∀a : ”; D; “ · ”; P) = I P
(26)
In a similar manner we can avoid including axiom schemas
in some theories and have just a single axiom. The notation
allows us to refer to all variables in an expression.
VII. INCLUDING THE INTERPRETER
So far we have excluded the interpreter itself from the
interpreted language to maintain consistency. G¨odel’s First
Incompleteness Theorem implies that we could never deﬁne
our interpreter to be both consistent and complete [14], [15].
Let the § symbol denote bunch comprehension, and be treated
as a quantiﬁer; when applied to a function it returns a bunch.
Then there are expressions such as {§x : I lang · ¬(x ∈ x)}
whose string representation we cannot interpret (interpreting
this expression in particular causes Russell’s paradox). A
simpler proof of G¨odel’s theorem by [13] shows why a
straight-forward inclusion of the interpreter is inconsistent.
However, as [13] also suggests, any logic can be completely
described by another. This point is intuitively manifested in the
fact that all expressions that cannot be interpreted include the
interpreter itself. In a sense, we relegate all issues of partiality
in our logic to involve only the interpreter.
However, we can weaken the restriction on the interpreter
being excluded from the language. The motivation for includ-
ing the interpreter is to reason about languages that allow
this sort of self reference. In practice, theorem provers such
Coq [16] allow reﬂection as a proving technique. We would
like to use the interpreter as a simple way of reasoning about
termination and consistency of deﬁnitions. The key insight is
that a mathematical function disregards computation time. The
domain xnat is the naturals extended with ∞. We can measure
computation time recursively by deﬁning the following timing
function.
T = ⟨s : lang → result r : xnat·
(27)
var f : (char → bool) := ⟨t : lang → “\“”; t; “\”” = s⟩·
if ∃f then r := 1 else
var f : (lang → bool) := ⟨t : lang → “¬”; t = s⟩·
if ∃f then r := 1 + T (§f) else
var f : (lang → lang → bool) :=
⟨t, t′ : lang → t; “ ∧ ”; t′ = s⟩·
if ∃f then r := 1 + T (§t : lang · ∃t′ : lang · ft t′)
+ T (§t′ : lang · ∃t : lang · ft t′) else
...
var f : (lang → bool) := ⟨t : lang → “I”; t = s⟩·
if ∃f then r := 1 + T (if §f : var ∧ I(§f) : lang
then I(§f) else §f ﬁ) else
r := ∞
ﬁ
⟩
This function is in a way parallel to how an interpretation
works, except that it counts time. The time in question is the
number of law applications needed to simplify an expression
to have no interpreter symbol in it. At each if-statement the
function checks for the occurrence of a certain piece of syntax,
and the vertical ellipsis would include a similar check for the
rest of the syntax. The special part of this function is when
we see the interpreter symbol. If the interpreter was applied
to a string representing a variable, and that variable’s value
is a string in the language, we recurse on its value. If the
interpreter is applied to any other expression, we recurse on
41
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

that expression’s string representation. For example, if we have
Q = “¬IQ”
(28)
then we calculate
T Q
(29)
= T “¬IQ”
= 1 + T “IQ”
= 1 + T Q
and therefore T Q = ∞ since T Q : xnat. For any string that
does not include the interpreter the time is linear; this can be
proven by structural induction over lang if we add an induction
axiom along with the construction axioms we deﬁned earlier.
We should only interpret an expression that includes the
interpreter if the execution time of the interpretation is ﬁnite. If
it is inﬁnite or cannot be determined, then there is a potential
for inconsistency had we decided to interpret it regardless. We
can add the interpreter to the interpreted language as follows:
∀s : lang · T s < ∞ ⇒ I“I\“”; s; “\”” = Is
(30)
This also implies that interpreting variables in their un-
abbreviated form is also safe. If we have s : var then:
T “I”; s
(31)
= 1 + T s
= 1 + 1
= 2
In general, proving a ﬁnite execution time is the halting
problem. When reasoning about logics it may be useful to
include the interpreter in the interpreted language. For many
practical purposes it can be left out.
VIII. PROOF OF CONSISTENCY
To prove the interpreter consistent we will ﬁnd a model in
set theory. Characters are implemented as natural numbers,
having
“0” = 0, . . . “9” = 9, “a” = 10, . . . “z” = 25, . . .
(32)
Strings are implemented as ordered pairs in the standard way.
a; b = {{a}, {a, b}}
(33)
The interpreter is a mapping from the set of all strings in our
language lang to the class of all sets. I ⊆ lang × Sets. It
is assumed that all other theories (functions, boolean algebra,
numbers) are implemented in set theory in the standard way.
For this reason partial functions might be implemented using
another special value that all remaining domain elements will
be mapped to. We will not delve into the implementation of
functions and other theories, since once they are implemented
in set theory, they are included in the class Sets.
We must prove that there exists a function I such that the
interpreter axioms are true. The recursion theorem will be used
to prove this [5]. The theorem states that given a set X, an
element a of X, and a function f : X → X there exists a
unique function F such that
F 0 = a
(34)
∀n : nat · F (n + 1) = f(F n)
(35)
Since I ⊆ lang × Sets it is necessary to ﬁrst ﬁnd a function
from lang to the naturals; this is an enumeration of the strings
in lang. Let charNum be the total number of characters in
char. Character string comparison for strings s, t is deﬁned
as
(s > t) = strNum(s) > strNum(t)
(36)
strNum = ⟨S : ∗char → if S = nil then 0
(37)
else S0 + charNum × S1..↔S ﬁ⟩
The enumeration function enum of strings in lang is deﬁned
as
enum = (g−1)
(38)
g = ⟨n : nat → if n = 0 then (MIN s : lang · s)
(39)
else (MIN s : (§t : lang · t > g(n − 1)) · s) ﬁ⟩
The function strNum assigns a unique number to each
string. Some character strings are not in lang, and we desire an
enumeration free from gaps. The function g assigns a unique
string in lang to each natural as follows: zero is mapped to
the ﬁrst string in the language, and each subsequent number is
mapped to the next smallest string. Since g is one-to-one, we
deﬁne enum as its inverse. We deﬁne function F for a given
state in the model with ﬁnite single-character variables as
F 0 = {0; 0}
(40)
...
F 9 = {9; 9} ∪ F 8
For all s : char let m = enum(“\“”; s; “\””) in
F m = {m; s} ∪ F (m − 1)
(41)
F (n + 1) = {(n + 1); (H (n + 1) (F n))} ∪ F n
(42)
(H is deﬁned below)
At each argument n function F is a mapping of all previous
numbers to their corresponding expressions, in addition to the
current one. The base elements are the variables, numbers and
strings. Function H constructs expressions using the operators
in our language from previous expressions. It is deﬁned as
42
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

follows.
H k I =
(43)
{S : Sets|∃n, m : dom(I) · g k = (g n); “ + ”; (g m)
∧ S = I n + I m} ∪
{S : Sets|∃n, m : dom(I) · g k = (g n); “ ∧ ”; (g m)
∧ S = I n ∧ I m} ∪
{S : Sets|∃n : dom(I) · g k = “¬”; (g n) ∧ S = ¬I n} ∪
...
Like the timing function, the vertical ellipsis represents a
similar treatment for other operators and is used to save space.
Since g is one-to-one, only a single set in this union will have
an element in it. In other words, each number is mapped to a
single expression (but not vice-versa). Finally, the interpreter
is implemented as follows.
I = ⟨s : lang → (F (enum s)) (enum s)⟩
(44)
IX. CONCLUSION
We have presented the formalism of an expression inter-
preter for the purpose of reasoning with partial terms. Our
technique requires no separate meta-logic, and we believe that
our encoding of expressions as character strings is simple
and transparent. The use of the interpreter allows proofs with
partial terms to proceed in a fully formal fashion classically;
that is, with just the standard boolean algebra. We show how
the interpreter can be used to create generic and compact laws,
which also allow syntactic reasoning about expressions. We
also argue that the incorporation of the interpreter in theorem
provers is simple, since the parsing that is required for its use
is an efﬁcient linear-time algorithm.
REFERENCES
[1] C. B. Jones and C. A. Middelburg, “A typed logic of partial functions
reconstructed classically,” ACTA, vol. 31, no. 5, pp. 399–430, 1994.
[2] C. C. Morgan, Programming from speciﬁcations, 2nd Edition.
Upper
Saddle River, NJ, USA: Prentice Hall, 1994.
[3] C. B. Jones, M. J. Lovert, and L. J. Steggles, “A semantic analysis
of logics that cope with partial terms,” in ABZ, ser. LNCS, J. Derrick,
J. A. Fitzgerald, S. Gnesi, S. Khurshid, M. Leuschel, S. Reeves, and
E. Riccobene, Eds., vol. 7316.
Springer, 2012, pp. 252–265.
[4] C. B. Jones, “Partial functions and logics: A warning,” IPL, vol. 54,
no. 2, pp. 65–67, 1995.
[5] W. Just and M. Weese, Discovering Modern Set Theory. I.
American
Mathematical Society, 1996, vol. 8.
[6] M. Beeson, Foundations of Constructive Mathematics.
New York, NY,
USA: Springer-Verlag, 1985.
[7] ——, “Lambda logic,” in Automated Reasoning: Second International
Joint Conference, IJCAR 2004.
Springer, 2004, pp. 4–8.
[8] R. F. St¨ark, “Why the constant ’undeﬁned’? logics of partial terms
for strict and non-strict functional programming languages,” J. Funct.
Program., vol. 8, no. 2, pp. 97–129, 1998.
[9] R. D. Gumb, “The lazy logic of partial terms,” JSYML, vol. 67, no. 3,
pp. 1065–1077, 2002.
[10] M. J. C. Gordon, R. Milner, and C. P. Wadsworth, Edinburgh LCF, ser.
Lecture Notes in Computer Science.
Springer, 1979, vol. 78.
[11] D. Gries, The Science of Programming.
New York: Springer-Verlang,
1981.
[12] E.
C.
R.
Hehner,
A
Practical
Theory
of
Program-
ming.
New
York:
Springer,
1993.
[Online].
Available:
http://www.cs.toronto.edu/ hehner/aPToP/
[13] ——, “Beautifying g¨odel,” pp. 163–172, 1990.
[14] K. G¨odel, “ ¨Uber formal unentscheidbare S¨atze der Principia Mathemat-
ica und verwandter Systeme,” Monatshefte f¨ur Mathematik und Physik,
vol. 38, no. 1, pp. 173–198, 1931.
[15] R. Zach, “Kurt g¨odel and computability theory,” in Logical Approaches
to Computational Barriers, ser. Lecture Notes in Computer Science,
A. Beckmann, U. Berger, B. L¨owe, and J. Tucker, Eds. Springer Berlin
Heidelberg, 2006, vol. 3988, pp. 575–583.
[16] T. C. D. Team, “The coq proof assistant reference manual,” 2009.
43
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

