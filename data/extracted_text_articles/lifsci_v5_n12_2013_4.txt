42
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
An Ambient Assisted Living Framework
with Automatic Self-Diagnosis
Christophe Jacquet,
Ahmed Mohamed
SUPELEC Systems Sciences
Gif-sur-Yvette, France
christophe.jacquet@supelec.fr
ahmed.mohamed@supelec.fr
Marie Mateos,
Bruno Jean-Bart
TRIALOG
Paris, France
marie.mateos@trialog.com
bruno.jean-bart@trialog.com
Pierre Bretault,
Indrawati Schnepp
ATEGO
Issy-les-Moulineaux, France
pierrebretault@neuf.fr
indrawati.schnepp@atego.com
Yacine Bellik
LIMSI-CNRS
Orsay, France
yacine.bellik@limsi.fr
Abstract—As the population in many countries is steadily
aging, allowing elderly people to stay longer at home is a
growing concern. Ambient Assisted Living (AAL) proposes
new techniques to help people remain autonomous, based on
ambient intelligence. We present an ontology-based framework
in which ontologies enable the expression of users’ preferences
in order to personalize the system behavior. They are also
used for the discovery and interconnection of devices, the
storage and retrieval of collected data and the transmission
of actions. Basing everything on ontologies allows the designer
to express the behavior of the system using high-level logic
rules. To render AAL systems as autonomous as possible,
devices that fail should be detected at runtime. For this
reason, the framework offers a diagnosis service that builds a
prediction model of the values detected by sensors. It is based
on information discovered opportunistically at run-time and
knowledge about physical laws. The framework monitors the
run-time behavior of the AAL system and uses the prediction
model to detect inconsistencies and hence faults. Therefore,
fault detection is totally dynamic and opportunistic; there are
no pre-deﬁned control loops. This paper describes an actual
implementation, with precise technological details, in order
to prove the feasibility of the technical choices, and provide
implementation ideas for future projects.
Keywords-Ambient Assisted Living (AAL); ambient intelli-
gence; ontologies; diagnosis; fault detection; reasoning.
I. INTRODUCTION
Due to the demographic change towards an aging pop-
ulation, society must ﬁnd ways to assist elderly people
to stay active at home longer. Currently, this support is
mainly provided by human caregivers, but in the future
technology is expected to play a more and more important
role both for elderly persons and caregivers. In Europe, a
roadmap has been deﬁned in the last years called Ambient
Assisting Living (AAL). A software platform for AAL was
described in our previous paper entitled An Ambient Assisted
Living Framework Supporting Personalization Based on
Ontologies [1]. This paper is an extended version of the
latter, which introduces improvements to the self-diagnostic
features of the framework.
AAL [2] is part of the larger ambient intelligence vi-
sion [3], in which information technology supports everyday
tasks in an unobtrusive way. The business context of AAL
is rich in terms of technology (from tele-health systems to
robotics) but also in terms of stakeholders (from service
providers to policy makers, including core technology or
platform developers).
The work presented here has been carried out within
the CBDP project (Context-Based Digital Personality) [4],
which aims at creating a framework for building various
kinds of ambient-intelligent applications, based around the
concept of Digital Personality for representing the prefer-
ences of users. Aside from AAL, several application do-
mains were considered, such as digital TV guides, assistants
for workers at a construction site, or marketing applica-
tion on mobile phones. Therefore, the CBDP framework
addresses a wide variety of requirements. However, in this
paper, we focus exclusively on the parts of the CBDP
framework relevant to AAL.
Our approach is entirely based on ontologies. Not only
are ontologies used to capture domain knowledge, but more
importantly they serve as the runtime mechanism that allows
the interconnection of devices, the exchange of data and the
execution of actions. The Digital Personality of the users is
stored in the ontology.
On top of that, a diagnosis process is able to construct a
model predicting the expected sensor readings at runtime, as
a function of requested actuator commands. Using this and
by observing actual sensor values found in the ontology, it
is able to monitor the run-time behavior of the system and
to detect unexpected patterns, that are probably caused by
failed devices (sensors and actuators).
The ontology is presented in Section II. Section III
describes the CBDP framework and gives implementation
details. Section IV focuses on diagnosis: it explains what
models are used, and how they are exploited. Section V
describes a typical AAL use case, and goes through its
complete realization. Section VI introduces some related
work, and compares our approach with published results.
Finally, Section VII gives directions for future work.

43
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
DateTimeDesciption
DayOfWeek
DurationDescription
TemporalEntity
TemporalUnit
TimeZone
Effect
EffectProperty
Formula
Device
Digital
personality
Location
Time
Diagnosis
Command
Device
State
StateValue
Digital Personality
Person
Location
Thing
Figure 1.
First level of the CBDP ontology.
II. AN ONTOLOGY FOR AAL APPLICATIONS
CBDP is built around an ontology: this section justiﬁes
this choice and describes the ontology used.
A. Why use ontologies?
AAL applications are trans-disciplinary by essence (for
instance, they can mix automatic control with modeling of
user behavior), therefore, the ability to reuse knowledge and
integrate several knowledge domains is particularly impor-
tant for them. Furthermore, the ﬁeld of AAL is very open
and changing, so it is not possible to base an AAL platform
on a ﬁxed set of features, on a ﬁxed set of data models:
extensibility is key. In addition, an AAL environment may
require the interoperation of software and hardware devices
from a variety of suppliers: there must be a standard way of
exchanging knowledge.
Ontologies are well-adapted to all these needs [5]: an
ontology framework provides a standard infrastructure for
sharing knowledge. In addition, semantic relationships such
as equivalence may be expressed between various knowledge
sources, thus permitting the easy integration of several
sources or domains. In addition, one can easily extend
an ontology to take into account new applications or new
devices. For these reasons, leading AAL projects such as
OASIS (Open architecture for Accessible Services Integra-
tion and Standardisation) have put a strong emphasis on
ontologies [6]. Being oriented toward personalization, CBDP
explicitly introduces an ontology module for modeling the
“Digital Personality” of the user.
B. Ontology used by CBDP
The ontology deﬁned for CBDP is built around the OWL
language [7], which is based on the Resource Description
Framework (RDF). RDF represents knowledge as a set of
triples or statements of the form {subject, predicate, object}.
It models different interrelated domains in a modular way,
so as to enable its easy adaptation to new applications.
In order to put into practice the aforementioned notion
of reusability, two of the domains are based on existing
ontologies. Figure 1 depicts the ﬁrst level of the ontology;
the main domains are as follows:
• Device: this part is based on the DogOnt [8] ontology
that has been simpliﬁed for our purpose, while keeping
the modeling axes (typology, functionality and state).
• Digital Personality: a class Person allows the repre-
sentation of a human being, and a Digital Personality
stores the person’s preferences in order to personalize
the services offered to him/her.
• Location: a location model is required because most of
the services offered in the AAL domain must know the
position of the user (in/out the house, in the bedroom/in
the kitchen, etc.) and of the devices (sensors and
actuators).
• Time: we import W3C’s existing Time Ontology [9]
without any change.
• Diagnosis: we introduce the concept of physical effect
(see Section IV below), to compute the expected result
of the action of an actuator onto a sensor.
The ontology is loosely coupled with the framework, so
to a great extent it may be changed without affecting it.
However, the basic feature of sending commands to actuators
rely on speciﬁc core classes and properties that may not be
changed; this part is depicted in Figure 2.
Device  
Functionality  
Command  
hasCommand  
hasFunctionality  
Figure 2. Ontology classes required for proper operation of the framework.
III. CBDP FRAMEWORK
This section describes the CBDP framework and how it
can be used to build AAL applications.
A. Architecture
The main goal of the CBDP Framework is to dynamically
handle ontology data and initiate actions when speciﬁed
conditions in the ontology are achieved. CBDP is written in
Java; it is based on OSGi (Open Services Gateway initiative
framework) [10], which allows one to build applications
ﬂexibly by combining bundles. In CBDP, an application is
composed of CBDP’s core bundles (the Context Reasoner
and the Sensor/Actuator Layer, described in Sections III-B
and
III-C, respectively) and application-speciﬁc bundles
(see Figure 3). In our case:
• AAL-speciﬁc application bundle: contains the rules that
deﬁne the intended application behavior, meant to assist
the user according to his/her needs.
• Zigbee Driver bundle: allows the exchange of data
between the physical devices (connected via a wireless
Zigbee network) and the CBDP Framework.

44
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
OSGI  Platform  
AAL  
Application  
Bundle  
S/A  Layer  
Rule  
Engine  
Zigbee  
Driver  
<<enrich>>  
<<enrich>>  
ContextReasoner  
CBDP  Framework  
  
  
  
AAL  ontology  
 
Ontology  in  memory  
Jena  set  of  rules  
Jena  set  of  rules  
Set  of  rules  
Sensors  
Actuators  
Figure 3.
Architecture of the CBDP framework.
B. Context Reasoner and Rules
The Context Reasoner is in charge of managing the infor-
mation coming from external components (AAL Application
or Zigbee Driver) by structuring them according to the
AAL ontology. Therefore, it provides methods to add new
information, retrieve stored information, and perform queries
about that information. Manipulation of the ontology is done
using the Jena library [11].
Another feature of the Context Reasoner is its rule engine.
Its purpose is to perform actions to help the user and
facilitate common tasks, based on a set of application-
speciﬁc rules (hence the rules are provided by the AAL
Application bundle). The rules are Horn clauses [12]: a rule
is composed of premises that determine the situations in
which the rule applies, and a conclusion, that basically adds
a new “fact” into the ontology, such as a new property value.
An example of such a rule is given in Section V-A below.
Rules are applied by Jena’s basic reasoning engine, using
forward chaining.
For performance reasons, the rule engine does not apply
all rules at each instant. The rules are applied only when
a change in the ontology matches a ﬁlter (i.e., happens
in a speciﬁc part of the class hierarchy). The ﬁlters are
application-speciﬁc; here they are deﬁned by the AAL
Application bundle. At ﬁrst one may use a “catch-all” ﬁlter;
performance can be improved later by reﬁning the ﬁlters.
C. Sensor/Actuator Layer
The Sensor/Actuator layer (S/A layer) connects the sen-
sors and actuators to the ontology. The communication is
two-way:
• Sensor data (sent through Zigbee) is stored in the
ontology. This allows one to perform semantic queries
and semantic reasoning over sensor data.
• A command request inserted in the ontology (using
a property called hasCommand) triggers the actual
emission of a command to the actuator.
All exchanges are deterministic. They are are triggered in
response to events. The module responsible for connecting
Table I
OSGI PROPERTY NAMES USED TO SPECIFY OWL TREES.
Sensor information
instance.id
URI identifying the sensor (String)
1) When referencing a dataProperty present in the ontology
data.property
Name of the “simple data” property (String)
data.property.value
Value (depends on property: Boolean, Double,
Integer, String...)
2) When referencing an objectProperty present in the ontology
object.property
Name of the “object” property (String)
object.property.range
Name of the class referenced by the property
(String)
the sensors to the Context Reasoner is based on the use of a
speciﬁc OSGi service called EventAdmin. A communication
protocol through OSGi events has been deﬁned in order to
allow the communication between the drivers and the S/A
layer. Section III-D describes this protocol.
D. Communication between sensors/actuators
and the ontology
This section deals with the protocol used to exchange on-
tology knowledge using OSGi events. An event is composed
of a topic and of a list of properties ({propertyName; prop-
ertyValue} pairs). We have deﬁned two kinds of events: 1) to
report sensor data, 2) to send commands to actuators. For
both kinds of events, the OSGi topic string is built according
to the pattern CBDP/AAL/deviceClass. CBDP and AAL
are invariant: they reference the general framework and our
application-speciﬁc ontology; deviceClass is the name
of the sensor class that sends data, or actuator class that is
to receive data. The remainder of this section gives details
on the actual contents (list of properties) of the events in
both cases.
1) Reporting sensor data: When sensor data is reported,
a sub-graph (actually a tree) must be created in the ontology.
An edge in this tree may be of two kinds: connecting an ob-
ject to a simple value such as an number (“dataProperty”), or
connecting an object to another object (“objectProperty”). A
convention using OSGi’s properties allows us to completely
describe the tree. At each node in the tree to be created, a
set of datatype and object properties may be speciﬁed. Each
edge of the tree is numbered using a simple convention: from
the top of the tree, each time an edge is followed, a dot and
the index of the edge under its parent node are appended
to the OSGi property name (see the examples in Figure 4).
This permits the description of each edge and each node to
be created. The basic property names (without trailing dots)
are given in Table I, and a complete example is given in
Figure 4. It represents an event stating that the light level is
500 lux in the kitchen at the date {Calendar value}.
2) Sending actuator commands: Sending a command to
an actuator is done using the following convention: a new

45
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
LightSensor  
͞>ŝŐŚƚ^ĞŶƐŽƌͺϭ͟  
Room  
LightInstensityState  
LightIntensityStateValue  
realIntValue  
(.1.1.1)  
500  
receivedAt  
(.1.1.2)  
inXSDDateTime  
(.1.1.2.1)  
{CalendarValue}  
Instant  
isIn  
    (.2)  
hasState  
(.1)  
hasStateValue  
(.1.1)  
roomId  
(.2.1)  
͞kitchen͟  
Event  to  send  to  the  S/A  layer  
  
topic  =  CBDP/AAL/LightSensor  
  
instance.id  =  LightSensor_1  
  
object.property.1  =  "hasState"  
object.property.range.1  =  "LightIntensityState"  
object.property.1.1  =  "hasStateValue"  
object.property.range.1.1  =  "LightIntensityStateValue"  
data.property͘ϭ͘ϭ͘ϭс͞realIntValue͟  
data.property.value.1.1.1  =  500  
object.property͘ϭ͘ϭ͘Ϯс͞receivedAt͟  
object.property.range͘ϭ͘ϭ͘Ϯс͟/ŶƐƚĂŶƚ͟  
data.property.1.1.2.1  =  "inXSDDateTime"  
data.property.value.1.1.2.1  =  {Calendar  value}  
  
object.property.2  =  ͞isIn͟  
object.property.range.2  =  ͞ZŽŽŵ͟  
data.property.2.1  =  ͞roomId͟  
data.property.value.2.1  =  ͞kitchen͟  
Figure 4.
Example of an event containing sensor data.
statement must be added in the ontology, with a relation
named “hasCommand” (see Figure 2 above). Such a state-
ment may be added by a reasoning rule, or by application
code calling the context manager.
When the S/A layer detects a new “hasCommand” state-
ment, it serializes the corresponding sub-tree of the ontology
graph into an OSGi event (using the same convention as
above) and sends it to the driver of the target actuator.
Figure 5 depicts the “turn light on” event graphically.
E. Deployment
The OSGi implementation used by CBDP is Apache
Felix. The use of Java and OSGi permits to deploy the
framework on a variety of platforms. We have conducted
tests on desktop PCs (under Windows and MacOS) and
on embedded systems (on a set-top-box running Linux
and on Aonix Perc) [13]. Perc is a Java virtual machine
for embedded systems that can be deployed on resource-
constrained targets while providing real-time and safety
guaranties. This demonstrates the adequacy of CBDP for its
target applications, user assistance in ambient environments,
i.e., in non computer-centric settings.
IV. DIAGNOSIS
Ultimately, the goal of any AAL application is to activate
some actuators, based on data provided by some sensors.
However, sensors and actuators may suffer failures. There-
fore, the system should check autonomously whether the
intended actions are performed correctly. This need for self-
diagnosis capabilities of ambient environments was outlined
as early as 2001 [3]. Here we focus only on the diagnosis
of hardware devices; we do not consider software bugs or
runtime failures.
A. Rationale
In software, mechanisms such as exceptions and error
codes report whether a procedure executes successfully or
not. Likewise, an actuator can provide a return code, but
generally this reﬂects only the way the orders are transmitted
to the actuator, not their actual execution. For instance, when
the system activates a light bulb, it receives an acknowledge-
ment that conﬁrms the switch-on of the electrical circuit, but
this does not necessarily mean that the bulb is really on (the
bulb may be damaged for instance). Therefore, a reliable
AAL application needs a way to assess at run-time the status
of its sensors and actuators.
To address the issue, the designer could apply classical
control theory to pre-determine closed control loops using
designated sensors. However, the particularity of ambient
systems is that physical resources, mainly sensors and
actuators, are not necessarily known at design time, but
are dynamically discovered at run-time. In consequence,
such control loops cannot be pre-determined; the diagnosis
strategy needs to be automatically determined at run-time.
We propose an approach in which the system relies
only on sensors already available, thereby not requiring
the addition of speciﬁc devices for diagnosis purposes. The
sensors that may be used to perform diagnosis are discovered
at run-time. When a sensor measures a physical parameter,
the system may deduce sensor/actuator “health” status by
comparing actual values with expected sensor values.
To achieve this, we propose a diagnosis framework in
which the characteristics of actuators and sensors, as well
as the physical effects involved, are precisely described. The
following paragraphs provide a high-level description of this
approach; refer to [14] for more details.

46
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
OnOffFunctionality_1 :OnOffFunctionality
LightActuator_1 :LightActuator
realStringValue
"on"
OnCommand_1 :OnCommand
hasFunctionality
hasCommand
Event sent by the S/A layer
topic = CBDP/AAL/LightActuator
instance.id = “LightActuator_1”
object.property.1 = "hasFunctionality"
object.property.range.1 = “OnOffFunctionality”
object.property.1.1 = "hasCommand"
object.property.range.1.1 = “OnCommand”
data.property.1.1.1 = “realStringValue”
data.property.value.1.1.1 = « on »
Figure 5.
Example of an event containing a command, to be transmitted
to an actuator.
Device
Sensor
Actuator
is-a
is-a
EffectProperty
Effect
Formula
produces
detects
describedBy
predicts
*
Figure 6.
The diagnosis framework adds to the general-purpose ontology
(gray part at the top) a few concepts to describe the effects and their
detectable properties.
B. Modeling physical effects
Effects are modeled in order to predict the physical
consequences of actions in an ambient environment. Each
effect is characterized by a set of properties: some deﬁne
the effect (at the source actuator, e.g., the light intensity
emitted by a light bulb), some are observable by a sensor
(e.g., the light intensity received by a light sensor).
Depending on the application’s needs, an effect can be
deﬁned at various levels of granularity. For instance, the
light emitted by a light bulb could be modeled either using
classical laws of physics for light propagation, or using a
simple boolean law (“if a light bulb is on in a room then
the light sensors that are in that room should detect light”).
The choice of the right level of granularity depends, among
other things, on the context of use, for instance assisted
living homes for blind persons may require a very detailed
deﬁnition of the model for the propagation of sound waves.
We consider that an effect can be described by some
mathematical formula, or set of formulae. For instance, the
propagation of light within a room may be modeled by the
following functions:
distance(A, B) =
p
(A.x − B.x)2 + (A.y − B.y)2 (1)
illum(A, B) =
A.flux
(distance(A, B))2
(2)
B.illuminance =
X
A∈LightActuators
illum(A, B)
(3)
The notation Obj.prop refers to property prop of object
Obj. In the formulae above, A and B stand for any ambient
objects modeled by the system. LightActuators is the set
of light actuators. Formula (1) deﬁnes a function, called
distance, that computes the planar distance between two
ambient objects A and B. In formula (2), illum(A, B) is the
luminous illuminance contributed by object A onto object
B. Formula (3) states that the total illuminance of object
B is the sum of the individual contributions of every light
actuator onto object B.
C. Using effects for linking actuators to sensors
As ambient systems are highly dynamic, one cannot
explicitly link related sensors and actuators. The concept of
effect allows for easy decoupling of devices, as illustrated
by Figure 6. An actuator class is linked to the effects it
may potentially produce. Similarly, a sensor class is linked
to at least one effect property. At a generic level, there is
a link between a given effect (e.g., emission of light) and
the corresponding detectable properties (e.g., illuminance)
through the predicts relation. A specialization of the abstract
level of Figure 6 is presented in Figure 7.
Device
Sensor
Actuator
is-a
is-a
Illuminance
Luminous Flux
(1)
produces
detects
predicts
LightSensor
LightActuator
is-a
is-a
describedBy
(2)
(3)
Figure 7.
Specialization of the abstract ontology level to account for
a speciﬁc effect: the emission of light. (1), (2) and (3) refer to the
corresponding formulae deﬁned in the text.

47
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Knowing the effects produced by any actuator in the
system, and knowing the effect properties sensed by any
sensor in the system, it is therefore possible to determine
and update at run-time the links between actual sensors and
actuators.
We construct a prediction model that constitutes an in-
stantiation of the effects for a given set of actuators and
sensors, in a given conﬁguration. The formulae are applied
to actual objects; the “iterative” expressions (such as the
capital-sigma notation used in formula (3)) are expanded
in accordance to existing objects. The prediction model is
updated each time a new object is introduced in the ambient
environment, and each time an object is removed. However,
for mere variations of property values, it is not necessary to
update the model; one only needs to compute the predicted
values again with the new property values.
D. Example: light sensors and actuators
Let us suppose that two light actuators la1 and la2, and
a light sensor ls1, are introduced in a room. The types of
devices and the instances are presented in Figure 8. Note
that initially there is absolutely no link between the actuator
and the sensors. The links will be deduced automatically
using available information.
Device
Sensor
Actuator
is-a
is-a
ls1
la1
instanceOf
instanceOf
LightSensor
LightActuator
is-a
is-a
la2
Links between 
instances to be 
deduced 
automatically
Figure 8.
Instances of sensors and actuators created for the example
situation, in which two light actuators and a light sensor are placed in a
room.
Using formula (3), and by simple rewriting rules, we can
successively deduce that:
ls1.illuminance =
illum(la1, ls1) + illum(la2, ls2)
(4)
Then:
ls1.illuminance =
la1.flux
(distance(la1, ls1))2 +
la2.flux
(distance(la2, ls1))2
(5)
And ﬁnally:
ls1.illuminance =
la1.flux
(la1.x − ls1.x)2 + (la1.y − ls1.y)2 +
la2.flux
(la2.x − ls1.x)2 + (la2.y − ls1.y)2
(6)
We obtain what we call a prediction model, here a formula
that depends only on object properties, and that can be used
at any time to predict the expected sensor readings. Once the
expected results have been determined, the system checks if
they are consistent with the actual readings.
V. EXPERIMENTATION
This section introduces a complete AAL scenario in which
the CBDP framework is able to automate tasks, it shows how
diagnosis is performed, and it describes the experiments.
A. Use case: automatic light switch
We propose an experimental scenario that takes place in
a bedroom. There is a controlled lamp, a light sensor and
a presence sensor. There is also a human-operated lamp
on a table, whose light level can be adjusted manually.
The system may not control the latter, but the position of
the adjustment knob, and hence the expected light level, is
known.
The purpose of the scenario is to help elderly people avoid
ﬁnding themselves lost in the dark. The expected system
behavior may be summarized by this rule: “if the ambient
light level is under a threshold (speciﬁed in the Digital
Personality of the user) and if the user is present in the
room, then the light must be turned on”. Although simple,
this scenario demonstrates all the aspects of the system:
sensor data gathering, reasoning, command of actuators and
diagnosis.
Figure 9 shows what input and output devices are used for
this experimentation. They are all Zigbee devices controlled
by the aforementioned Zigbee driver, which connects to the
CBDP platform through OSGi. Note that the light sensor
detects light emitted by both lamps, the controlled one and
the human-operated one.
Let us suppose that the illuminance in the room is 80
lux (due to the human-operated lamp being dimmed for
instance). Then, the user comes in. His Digital Personality
states that he does not like to be in a room where the
illuminance is under 100 lux. The system takes the following
steps:
1) The current illuminance (80 lux) has already been
detected and updated in the ontology. When the user
enters the bedroom, the presence sensor sends a noti-
ﬁcation to the driver through the Zigbee network. The
driver sends then an event to the framework and the
ontology is updated accordingly.

48
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
OSGI Platform
Light
Sensor
Motion
Sensor
Controlled Light
Actuator
⊕
⊕
⊕
⊕
Zigbee
Driver
Human-controlled
Light
Figure 9.
Input/output conﬁguration of the experimentation.
2) The framework detects that the value of a Pres-
enceSensor has changed in the ontology, so the rule
outlined in Figure 10 must be evaluated (cf. III-B).
Pseudo-natural language is used in Figure 10 for the
sake of simplicity; in practice, it is expressed in the
formal syntax speciﬁc to the Jena reasoning engine as
shown in Figure 11.
The reasoning engine reads the current light level, the
current presence status and the user preferences in
the ontology. The premises of the rule are true, so
the conclusion must be executed. To determine which
rules to apply, Jena uses a classical forward chaining
reasoning algorithm.
3) The rule causes a new statement to be added in the on-
tology: {LightActuator, hasCommand, “on”} (cf. III-C
and III-D). The hasCommand predicate is detected
by the Sensor/Actuator layer, and in consequence, the
framework sends an event to the driver asking for the
LightActuator to be turned on.
4) The driver commands the light actuator through the
Zigbee network. This actually turns the light on.
B. Diagnosis
At this point, the framework performs diagnosis so as to
determine if the action has been executed correctly. Both
LightActuators are “light effect” producers; the LightSensor
measures the “illuminance” value of “light effect”. They are
all described independently, The system deduces automati-
cally a prediction model that links them (see Section IV-C).
Here, the prediction model was built at system startup
since the objects did not move afterwards. The procedure
followed to obtain the prediction model and the eventual
IF a LightSensor value is <
{userPreference in the Digital Personality}
AND a PresenceSensor detects somebody
AND the LightSensor, the PresenceSensor
and a controllable LightActuator
are in the same room
THEN Turn the LightActuator on
Figure 10.
Example of rule (“turn the light on”) expressed in pseudo-
natural language.
[CMD_LIGHT_ON:
(?MS RDF:type AMI:PresenceSensor),
(?LS RDF:type AMI:LightSensor),
(?LA RDF:type AMI:ControlledLightActuator),
(?R RDF:type ?RT),
(?RT RDFS:subClassOf AMI:Room),
(?MS AMI:isIn ?R),
(?LS AMI:isIn ?R),
(?LA AMI:isIn ?R),
(?DP RDF:type AMI:AAL_DP),
(?DP AMI:isCurentDP ?curDP),
equal(?curDP,’true’),
(?DP AMI:low_AAL_LightThreshold ?LLT),
(?MS CORE:realStateStringValue ’personInside’),
(?LS AMI:realIntValue ?LMV),
lessThan(?LMV,?LLT),
(?F RDF:type AMI:OnOffFunctionality),
(?LA AMI:hasFunctionality ?F),
(?C RDF:type AMI:OnCommand)
-> (?F AMI:hasCommand ?C) ]
Figure 11. Example of rule (“turn the light on”) expressed in Jena’s syntax.
prediction model built have been described in Section IV-D.
The prediction model is Formula (6). All the system has
to do now is use this formula to calculate the expected
illuminance in the room. The steps go on like this:
5) Applying Formula (6) with the current values for all
object attribute yields 120 lux, which is the value
expected to be read by the light sensor.
6) The illuminance actually measured by the light sensor
is still 80 lux, so the system deduces that there is
a failure: either the actuator or the sensor is broken.
However, it may well be the case that there is another
light sensor in the room. In this situation, it will be
automatically discovered just like the ﬁrst one. If the
second light sensor reads the same value as the ﬁrst
one, then the faulty component is most probably the
light bulb. If conversely the second light sensor detects
an illuminance value close to the theoretical expected
value, then the ﬁrst light sensor is most probably
faulty.
7) The system ﬁnds it most probable that the bulb is burnt
out. An error notiﬁcation is generated so that the user
1) conﬁrms the cause the problem, and 2) possibly
to ﬁxes it (often, even an elderly person is capable
of replacing a light bulb). Therefore, a “negative”

49
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
diagnosis should generate an error notiﬁcation of some
sort asking the user to replace or to check the real state
of the light bulb (for a discussion on the acceptability
of notiﬁcations in a home environment, see for in-
stance [15]). The user’s feedback can be added as a
statement to the ontology, and can be useful for further
reasoning about the light bulb. We can imagine a case
in which the user’s feedback conﬁrms that the light
bulb is properly illuminated even though the system
says it is not; in that case, the system deduces that the
sensors are not functioning properly.
C. Implementation and Results
This experiment uses the standard CBDP framework,
with a bundle containing its speciﬁc rules. An interface
allows one to choose which user (characterized by their
digital personality) should be simulated (Figure 12). In a
real setting, there would be sensors to detect the particular
user: these could be a set of RFID tags and readers, or the
Ubisense system [16] for example.
Figure 12.
Selection of the digital personality of the user.
The experiment was conducted in two ways:
• using a simulator of the sensors, actuators and physical
environment,
• using physical devices in an actual room.
Figure 13 shows the interface of the simulation environ-
ment. The experimenters can act on the light level of the
human-controlled lamp, on the motion sensor, and they can
also introduce a defect in the controlled light bulb. Both
in simulation and in real conditions the system displays a
message with the current diagnosis (Figure 14). The tests
performed showed that the example runs as expected.
VI. RELATED WORK
Ontologies are often at the heart of ambient-intelligent
systems, and especially AAL systems, such as in OA-
SIS [6]. In 2003, CoBrA (Context Broker Architecture)
Figure 13.
Interface of the simulated environment. The user may act on
the human-controlled table lamp, as well as on the presence of motion. The
interface displays the current state of the system-controlled lamp.
was an ontology-based framework for ambient settings [17].
In 2004, SOUPA (Standard Ontology for Ubiquitous and
Pervasive Applications) [18] was one of the ﬁrst attempts to
deﬁne an application-agnostic ontology for ambient systems,
but it is speciﬁcally aimed at agent-based architectures.
More recently, Paganelli et al. [19] introduces a tele-health
platform, which is based on an ontology for describing con-
text and medical conditions. The SOPRANO project [20],
[21] deﬁnes a speciﬁc ontology that serves as a unifying
vocabulary between software components. In our work, the
ontology is speciﬁcally used to personalize the system; it
stores preferences, and contains application-speciﬁc mod-
ules. Moreover, we not only reason to infer new facts about
context as done in many platforms [22], but also to trigger
application-speciﬁc behavior, and to actually trigger actions,
i.e., send commands to actuators. This makes the framework
ﬂexible and allows the easy integration of additional services
such as the diagnosis framework described in Section IV.
Our choice of using the OSGi middleware was motivated

50
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 14.
Window showing the results of the diagnosis.
by previous successful attempts in the ﬁeld of ambient in-
telligence, such as in the AMIGO IST project [23]. CBDP’s
generalized reliance on ontologies makes the use of OSGi
very consistent with the rest of the framework.
Some works focus on ontologies for speciﬁc domains. For
instance, Hois [24] describes a well-grounded framework for
the description of spatial relationships and spatial reasoning.
This kind of contributions could be integrated into the CBDP
framework, due to the reusable nature of ontologies.
Sun [25] cites three challenges for AAL systems. Our
work is focused on technology, not on social aspects, so we
do not address the challenge of having people accept AAL
systems. However, we propose solutions to the two other
challenges: the dynamic availability of services is handled
by relying on an ontology-supported OSGi architecture; the
ontology is used for mapping the available services and
devices. For instance, relations between a sensor and an
actuator may be deduced automatically.
The detection of faults induced by incorrect adaptation
patterns in context-aware adaptive application has been
studied, and methods based on static analysis have been
proposed [26]. While it could be interesting to apply these
tools AAL systems, we have chosen to focus instead on the
detection on runtime failures due to unexpected hardware
faults. The two approaches are complementary: the former
deals with the correctness of adaptation patterns; the latter
deals with runtime breakdowns.
The need for self-diagnosis of systems at runtime has been
highlighted in the context of autonomic computing [27]. This
naturally applies to pervasive systems and ambient environ-
ments as well. A vast amount of work has been done to
diagnose sensors. For instance, Bourdenas [28] categorizes
the classes of faults at sensors, in term of erroneous readings,
and explains how to cope with them (self-healing). Indeed,
a faulty sensor may be identiﬁed by recognizing speciﬁc
patterns in its readings. Likewise, one can monitor processes
or computing devices by analyzing the messages they send
and their current state (running threads, memory and power
consumption, etc.) [29]. In contrast, realizing that an actuator
has become faulty is a different matter, that necessitates to
take into account the physical phenomena induced by this
actuator. This is where the framework presented here comes
into play.
VII. CONCLUSION AND FUTURE WORK
We have presented a complete framework that supports
the creation of AAL applications. This framework is based
on the use of an ontology at the core of the system.
This ontology contains application-speciﬁc knowledge and
stores user preferences (“Digital Personality”). Besides, it
handles all the run-time information ﬂows: it aggregates
sensor data, allows rules to be applied on this data so as
to generate commands, stores the commands, and provides
the commands to the actuators.
Using an ontology allows one to specify the behavior of
an AAL application in terms of easy-to-write logic rules.
These rules can rely on any piece of knowledge present in
the ontology, therefore, they are not limited in any way by
the core ontology that comes with the CBDP framework.
Such extensibility is made easy by the use of widespread
knowledge engineering standards, namely RDF/OWL.
The other signiﬁcant contribution of this paper is the
diagnosis framework that monitors the run-time behavior
of an AAL system by observing changes in the ontology.
Currently we take into account only the current state of the
system. In reality, the relevant measure might not be the
current absolute value of a physical parameter, but rather
its relative evolution. For instance, when light is switched
on, it may be most relevant to consider the relative increase
of the light level, as the absolute value may vary other time
without any action being taken (depending of the intensity of
the sun for instance). This prompts us to introduce dynamics
in the diagnosis framework. Likewise, some physical laws
may depend upon quantitative time (for instance, the effect
of a radiator in an initially chilly room is a slow increase of
temperature over time). This is currently being investigated.
We also plan to test such a system in real scale, for
example at the homes of elderly people. This will allow
us to reﬁne the rules that deﬁne the system behavior.
ACKNOWLEDGEMENT
This work has been performed within the CBDP project,
a project co-funded by the European Union. Europe is in-
volved in R´egion ˆIle-de-France with the European Regional
Development Fund.
REFERENCES
[1] C. Jacquet, M. Mateos, P. Bretault, B. Jean-Bart, I. Schnepp,
A. Mohamed, and Y. Bellik, “An Ambient Assisted Living
Framework Supporting Personalization Based on Ontologies,”
in AMBIENT 2012, the Second International Conference on
Ambient Computing, Applications, Services and Technologies.
IARIA, September 2012, pp. 12–18.

51
International Journal on Advances in Life Sciences, vol 5 no 1 & 2, year 2013, http://www.iariajournals.org/life_sciences/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[2] G. Van den Broek, F. Cavallo, L. Odetti, and C. Wehrmann,
“Ambient Assisted Living Roadmap,” AALIANCE, Tech.
Rep., 2009.
[3] K. Ducatel, M. Bogdanowicz, F. Scapolo, J. Leijten, and J.-
C. Burgelman, “Scenarios for ambient intelligence in 2010,”
European Commission, Tech. Rep., 2001.
[4] CBDP project description. Accessed on 26 February 2013.
[Online]. Available: http://projects.celtic-initiative.org/cbdp/
[5] N. Noy and D. McGuinness, “Ontology development 101: A
guide to creating your ﬁrst ontology,” Stanford University,
Tech. Rep., 2001.
[6] J. Bateman, A. Castro, I. Normann, O. Pera, L. Garcia, and
J.-M. Villaveces, “OASIS common hyper-ontological frame-
work (COF),” OASIS Project, Tech. Rep., 2009.
[7] G. Antoniou and F. van Harmelen, “Web ontology language:
OWL,” in Handbook on ontologies, S. Staab and R. Studer,
Eds.
Springer, 2009, pp. 91–110.
[8] D. Bonino and F. Corno, “DogOnt–ontology modeling for
intelligent domotic environments,” The Semantic Web-ISWC
2008, pp. 790–803, 2008.
[9] Jerry R. Hobbs and Feng Pan. (2006) Time Ontology
in OWL. Accessed on 18 July 2012. [Online]. Available:
http://www.w3.org/TR/owl-time/
[10] OSGi Alliance, OSGi service platform, release 3. IOS Press,
Inc., 2003.
[11] J. Carroll, I. Dickinson, C. Dollin, D. Reynolds, A. Seaborne,
and K. Wilkinson, “Jena: implementing the semantic web
recommendations,” in Proceedings of the 13th international
World Wide Web conference on Alternate track papers &
posters.
ACM, 2004, pp. 74–83.
[12] A. Chandra and D. Harel, “Horn clause queries and general-
izations,” The Journal of Logic Programming, vol. 2, no. 1,
pp. 1–15, 1985.
[13] Atego. Aonix PERC product description. Accessed on 20
February 2013. [Online]. Available: http://www.atego.com/
products/aonix-perc/
[14] A. Mohamed, C. Jacquet, and Y. Bellik, “A fault Detection
and Diagnosis Framework for Ambient Intelligent Systems,”
in Proceedings of the Ninth IEEE International Conference
on Ubiquitous Intelligence and Computing (IEEE UIC 2012).
IEEE, September 2012, pp. 394–401.
[15] M. Vastenburg, D. Keyson, and H. Ridder, “Considerate home
notiﬁcation systems: a ﬁeld study of acceptability of notiﬁ-
cations in the home,” Personal and Ubiquitous Computing,
vol. 12, no. 8, pp. 555–566, 2008.
[16] P. Steggles and S. Gschwind, “The ubisense smart space
platform,” in Adjunct Proceedings of the Third International
Conference on Pervasive Computing, vol. 191, 2005, pp. 73–
76.
[17] H. Chen, T. Finin, and A. Joshi, “An intelligent broker for
context-aware systems,” in Adjunct Proceedings of Ubicomp,
vol. 3, 2003, pp. 183–184.
[18] H. Chen, F. Perich, T. Finin, and A. Joshi, “SOUPA: standard
ontology for ubiquitous and pervasive applications,” in Mobile
and Ubiquitous Systems: Networking and Services (MOBIQ-
UITOUS), 2004.
IEEE, 2004, pp. 258–267.
[19] F. Paganelli and D. Giuli, “An Ontology-Based Context
Model for Home Health Monitoring and Alerting in Chronic
Patient Care Networks,” in Proceedings AINA 2007.
IEEE
Computer Society, 2007, pp. 838–845.
[20] M. Klein, A. Schmidt, and R. Lauer, “Ontology-centred
design of an ambient middleware for assisted living: The
case of SOPRANO,” in 30th Annual German Conference on
Artiﬁcial Intelligence (KI 2007), Osnabr¨uck, 2007.
[21] P. Wolf, A. Schmidt, and M. Klein, “SOPRANO-An ex-
tensible, open AAL platform for elderly people based on
semantical contracts,” in AITAmI, ECAI’08, 2008.
[22] A. Bikakis, T. Patkos, G. Antoniou, and D. Plexousakis, “A
survey of semantics-based approaches for context reasoning
in ambient intelligence,” Constructing Ambient Intelligence,
pp. 14–23, 2008.
[23] F. Ramparany, R. Poortinga, M. Stikic, J. Schmalenstroer,
and T. Prante, “An open context information management
infrastructure the ist-amigo project,” in Proceedings of IE
2007, the 3rd IET International Conference on Intelligent
Environments.
The IET, 2007, pp. 398–403.
[24] J. Hois, “Modularizing spatial ontologies for assisted living
systems,” in Proceedings of the 4th international conference
on Knowledge science, engineering and management, ser.
KSEM’10.
Springer-Verlag, 2010, pp. 424–435.
[25] H. Sun, V. De Florio, N. Gui, and C. Blondia, “Promises
and challenges of ambient assisted living systems,” in 2009
Sixth International Conference on Information Technology:
New Generations.
IEEE, 2009, pp. 1201–1207.
[26] M. Sama, D. S. Rosenblum, Z. Wang, and S. Elbaum,
“Model-based fault detection in context-aware adaptive ap-
plications,” in Proceedings of the 16th ACM SIGSOFT Inter-
national Symposium on Foundations of software engineering.
ACM, 2008, pp. 261–271.
[27] S. Dobson, R. Sterritt, P. Nixon, and M. Hinchey, “Fulﬁlling
the vision of autonomic computing,” Computer, vol. 43, no. 1,
pp. 35–41, 2010.
[28] T. Bourdenas, M. Sloman, and E. Lupu, “Self-healing for per-
vasive computing systems,” Architecting dependable systems
VII, pp. 1–25, 2010.
[29] M. Sharmin, S. Ahmed, and S. I. Ahamed, “Marks (middle-
ware adaptability for resource discovery, knowledge usability
and self-healing) for mobile devices of pervasive computing
environments,” in Information Technology: New Generations,
2006. ITNG 2006. Third International Conference on. IEEE,
2006, pp. 306–313.

