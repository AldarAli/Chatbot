Grouped Queries Indexing For Relational Database 
 
RadosÅ‚aw BoroÅ„ski 
Dept. of Electronics and Computer Science 
Koszalin University of Technology  
Koszalin, Poland 
radoslaw.boronski@tu.koszalin.pl 
Grzegorz Bocewicz 
Dept. of Electronics and Computer Science  
Koszalin University of Technology  
Koszalin, Poland 
bocewicz@ie.tu.koszalin.pl 
 
Robert WÃ³jcik 
Institute of Computer Engineering, Control and Robotics 
WrocÅ‚aw University of Technology 
WrocÅ‚aw, Poland 
robert.wojcik@pwr.wroc.pl 
 
Abstract-This paper discusses the problem of minimizing the 
response time for a given database workload by a proper 
choice of indexes. We propose to look at the database queries 
as a group and search for good indexes for the group instead of 
an individual query. We present condition for applying the 
concept of grouped queries index selection. Such condition is 
illustrated by three practical examples. 
Keywords-database;index;ISP;grouped queries;related queries 
I. 
 INTRODUCTION  
Getting database search result quickly is one of the 
crucial optimization problems in a relational database 
processing. The major strength of relational systems is their 
ease of use. Users interact with these systems in a natural 
way using nonprocedural languages that specify what data 
are required, but do not specify how to perform the 
operations to obtain those data [8]. Online Internet shops, 
analytics data processing or catalogue search are examples of 
structures where data search must be processed as quick as 
possible with minimal hardware resources involved. 
Common practice is to minimize the database search process 
at minimal cost. A database administrator (or a user) may 
redesign the physical hardware structure or reset the database 
engine parameters, or try to find suitable table indexes for a 
current query. Most vendors nowadays offer automated tools 
to adjust the physical design of a database as part of their 
products to reduce the DBMSâ€™s total cost of ownership [3]. 
As adding more CPUs or memory may not always be 
possible (i.e. limited budget) and maneuvering within 
hundreds of database parameter may lead to a temporary 
solution (wrong settings for other database queries), index 
optimization should be considered as being foremost.  
Indexes are optional data structures built on tables. 
Indexes can improve data retrieval performance by providing 
a direct access method instead of the default full table scan 
retrieval method [7]. In the simple case, each query can be 
answered either without using any index, in a given answer 
time or with using one built index, reducing answer time by 
a gain specified for every index usable for a query [14]. 
Hundreds of consecutive database queries together with large 
amount of data involved lead to a very complex 
combinatorial optimization problem. Two sample tables in a 
data warehouse of an international automobile factory 
contain over 1 billion records each (Fig. 1). Time needed to 
obtain result of both index-less tables joined together may be 
up to 45 minutes. Such delays are not acceptable for 
production environment processes. Indexes in such cases 
may reduce the response time of 50% (depending on which 
columns are used for the indexing). The classic index 
selection method focuses on a tree data structure, which 
could limit the search area as much as possible. Literature 
acknowledges us with such B-tree types as: 
ï‚· 
Sorted counted B-trees, with the ability to look 
items up either by key or by number, could be 
useful in database-like algorithms for query 
planning [5], 
ï‚· 
Balanced B*-tree that balances more neighboring 
internal nodes to keep the internal nodes more 
densely packed [12], 
ï‚· 
Counted B-trees with each pointer within the tree 
and the number of nodes in the subtree below that 
pointer [19]. 
The B-tree and its variants have been widely used in 
recent years as a data structure for storing large files of 
information, especially on secondary storage devices [11]. 
The guaranteed small (average) search, insertion, and 
deletion time for these structures makes them quite appealing 
for database applications.  
The topic of current interest in database design is the 
construction of databases that can be manipulated 
concurrently and correctly by several processes. In this 
paper, we discuss a simple variant of the B-tree (balanced 
B*-tree,  proposed by Wedekind [20] especially well-suited 
for use in a concurrent database system [15]. 
 
Figure 1.  Example of large number of rows for two data warehouse tables 
123
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-254-7
eKNOW 2013 : The Fifth International Conference on Information, Process, and Knowledge Management

While the selection of indexes structure have a very 
important role in the design of database management tools so 
far avoided interference in the structure of indexes at the 
stage of the database operation. In such situations more 
important is to ask a question â€œhow to choose a set of 
indexes for the selected query sets?â€. It turns out that the 
proper selection of indexes can bring significant benefits for 
the database query execution time. Typical approaches found 
in the literature mainly focus on the search indexes only for 
single column or single query [16], [10], [9], [17], [4]. In this 
paper, an approach associated with the search query indexes 
for groups called blocks is presented. 
In this case we will consider B-tree indexes. A B-tree 
index allows fast access to the records of a table whose 
attributes satisfy some equality or range conditions, and also 
enables sorted scans of the underlying table [18]. 
The rest of the paper is organized as follows: in Section 
II we describe a problem statement. In Section III, we briefly 
present classic index selection approach together with simple 
examples that will illustrate the subject. In Section IV, we 
demonstrate new method of grouped queries index selection 
and compare examples results with the classic approach. 
Section V and VI  present our conclusions and future works.  
II. 
PROBLEM STATEMENT  
Motivation for this work is to suggest an approach of 
multi-queried SQL block where sub-optimal or optimal 
solution is to be found that gives decision makers some 
leeway in their decisions. The main goal is to choose a subset 
of given indexes to be created in a database, so that the 
response time for a given database workload together with 
indexes used to process queries are minimal.  
The index selection problem has been discussed in the 
literature. Several standard approaches have been formulated 
for the optimal single-query and multi-query index selection. 
Some past studies have developed rudimentary on-line tools 
for index selection in relational databases, but the idea has 
received little attention until recently. In the past year, on-
line tuning came into the spotlight and more refined 
solutions was proposed. Although these techniques provide 
interesting insights into the problem of selecting indexes on-
line, they are not robust enough to be deployed in a real 
system [18]. The problem is known in a literature as Index 
Selection Problem (ISP) According to [8] it is NP-hard. Note 
that in practice the space limit in the ISP is soft, because 
databases usually grow, thus the space limit is specified in 
such way that a significant amount of storage space remains 
free [13]. 
In a real life scenario, for thousands database queries 
(Fig. 2) compromising hundreds of tables and thousands of 
columns, the search space is huge and grows exponentially 
with the size of the input workload.  
Considered case of Index Selection Problem can be 
defined in following way. 
 
Given is a set of tables: 
 
 
                , 
(1) 
 
described by a set of columns included in the tables: 
 
 
              ( )                     ( )  , 
(2) 
 
where:      is a  -th column of table   . 
Each column      corresponds to set of values  (    ) 
(tuples set) included in this column. 
 
 
Figure 2.  Example of number of database queries in a given day for a 
production data warehouse 
For set of tables   various queries    can be formulated 
(in SQL these are SELECT queries). These queries are put 
against the specified set of columns     . The result of 
query    is set as:  
 
 
    âˆ
        (    )
 , 
(3) 
 
where: âˆ
        
 
   
      is a cartesian product of 
sets        . 
For a given database    it is taken into account that    is a 
result of following function:  
 
 
      (     (  )) , 
(4) 
 
where:    is a subset of available indexes,   (  ) is set of 
operators available in database   of which relation 
describing query    is built. 
The time associated with the determination of the set   is 
depended on the DB database used (search algorithms, 
indexes structures) and adopted set of indexes    (  ) 
(where  (  ) - is a power set of   ). It is therefore assumed 
that the query execution time    in given database   , is 
determined by the function:  (       ). In short the value 
of execution time for query   , data base    and set of 
indexes   will be define as:   ( ).  
In the context of the so-defined parameters, a typical 
problem associated with the ISP responds to the question:  
 
What set of indexes    (  )  minimizes the query    
execution time:   ( )      ? 
124
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-254-7
eKNOW 2013 : The Fifth International Conference on Information, Process, and Knowledge Management

When a multi-component set of queries             is 
considered, question takes the form:  
 
What set of indexes    (  ) minimizes the queries block 
Q execution time: âˆ‘
      ( )
     ? 
III. 
CLASSIC INDEX SELECTION APPROACH 
Classic index selection approach focuses on individual 
query and tries to find good index or indexes set for tables in 
a single query in a given block. Such approach does not take 
into consideration queries in a block as a whole. By doing so, 
a database user may expose database to create excess number 
of indexes which could be redundant or not used for more 
than one query in an examined block. This could also result 
in utilizing too much disk space and time needed for the 
indexes creation. Finding good index group for a large 
database queriesâ€™ block was never an easy task to do and 
usually users and database administrators rely on their 
experience and good practice. In the commercial use one 
may find tools that support the index selection process, such 
as SQL Access Advisor (Fig. 3) [6], Toad, SQL Server 
Database Tuning Advisor [1]. 
Let us consider three examples where given is a group of 
three database queries             :  
  : SELECT * FROM   ,    WHERE      <      AND 
    =[const], 
  : SELECT * FROM   ,    WHERE      =     , 
  : SELECT * FROM    WHERE      > [const]. 
 
Interpretation of this type of queries (according to (4)) is as 
following:  
    searching for a set of triples:     (     )    
 (    )    (    )    (    )       
[     ] , 
set                    . 
    searching for a set of pairs:     (   )    
 (    )    (    )     , 
set               . 
   searching 
for 
a 
set:           (    )   
[     ] , 
set          . 
 
Tables   ,   ,    contain 1*106 records each. No indexes 
are built on either table:    . With the first test run, 
database returned following response times:   ( )      s, 
  ( )      s,   ( )     s respectively, resulting in full 
table scans for each  . Queries   ran on database Oracle 
11.2.0.1 installed on server with Redhat 6 operating system 
with 64GB memory and ASM used for disk storage. 
 
Figure 3.  Oracleâ€™s 10g2 SQL Access Advisor
125
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-254-7
eKNOW 2013 : The Fifth International Conference on Information, Process, and Knowledge Management

The classic approach requires treating every database 
query individually. Hence indexes are built:      and      on 
table   ;     ,      on table          on table   . This kind of 
indexes 
are 
represented 
by 
the 
set:    {{         } {    } {    } {    }}  containing four 
sets. Each element (set) of   contains the columns which are 
used to build the indexes. For example, the set {         } 
means that we have to build one index for columns          . 
The set of indexes   is built for three different tables, 
resulting in use of 2GB of additional disk space. With the 
second test run, database returned following response times: 
  ( )      s,   ( )      s,   ( )   s respectively. As 
the response time is better by approximately 10%, there is 
still unreasonable disk space used and time needed for 
creating 4 large indexes. Creating 4 indexes forced query 
optimizer to use them, and instead of decreasing    
execution time, it got increased. This is because optimizer 
decided to read      column index content first and because it 
couldnâ€™t find values for      column, it performed full table 
scan for table   . Examples shows that selected indexes may 
increase the query execution performance where in other 
cases may have the opposite effect. 
IV. 
GROUPED QUERIES APPROACH  
In this paper we focus on related queries group and 
because of this relation and the number of indexed columns. 
We take into account the search for a good index for the 
entire queriesâ€™ block. We propose a new approach by using 
multi-query SQL block selection. Such block consists tabular 
relations between queries, meaning that the number of tables 
columns used in previous query is present in other queries. 
The proposed approach could be an alternative to the classic 
index selection method, where one common index set could 
be found. Grouped queries approach has to be studied for its 
effectiveness and authenticity via a series of numerical tests. 
Furthermore, to compare the performance of the method 
commercial tools will have to be used and results compared. 
For previous examples, we suggested to create a pool of 
all columns taking part in all queries in a group and build 
sub-optimal indexes set for queried tables. Such task will 
involve creating the weighted list that will include all the 
index candidate query-related columns and their number of 
occurrence in the examined queries block: 
 
   ((       ) (      ) (      ) (      ) (      )). (5) 
 
Of course, only      column (marked by the box in (5)) is 
a query-related candidate column that could be used for the 
index creation. Nevertheless, other columns from remaining 
tables could also be revised. In that context, we suggest to 
create composite index for the same table    on columns      
and     :   {{         }} . By doing so, user not only 
speeds up block execution but also saves significant volume 
of disk space. With the third test run, database returned 
following response times:   ( )      s,   ( )      s, 
  ( )   s, respectively, decreasing total execution time of 
35% and saving disk space of 60%. This is due to the fact 
that only index is used or full table scan for non-indexed 
table resulting in smaller response times for    and   . 
Database optimizer does not need to perform an additional 
read operation (separate for index and if values not found 
and separate for a table). This proves that indexes should be 
selected with care. 
Determining the answers to a set of queries can be 
improved by creating some indexes. 
Classic 
index 
selection 
focuses on each query 
individually and final indexes set is a sum of indexes sub-
sets for each query. 
We show that groups of queries, one can get better 
indexes set if such group is treated as a whole. 
Grouped queries index search can only benefit and have 
an advantage over single query search, only if queries in the 
group satisfy the condition of mutual dependence. Queries 
  ,   ,   , from previous examples are dependent so below 
statement applies. Such dependency must be clearly defined. 
In the present case, the dependence set of queries   is 
determined by connectivity of hypergraph  ( ). 
Example of a hypergraph for considered queries   is 
presented on Fig. 4. 
 
Figure 4.  Hypergraph for considered set of queries   
In this type of graph vertices represent the columns used 
in queries  , edges connect those vertices which combined 
make table   (dashed line hyper edge) or related queries    
(solid line hyper edge). For example, hyper edge connecting 
vertices                represents relation with query   .  
 
It is assumed that the query set   is related if 
corresponding hypergraph  ( ) is consistent. 
 
In this context, the group queries indexes set creation can 
benefit compared to classic index selection only for related 
sets.  
As a counterexample, given is a group of three database 
queries       
    
    
  :  
ğ‘˜    
ğ‘˜    
ğ‘˜    
ğ‘˜    
ğ‘˜    
ğ‘„  
 
ğ‘„  
 
ğ‘„  
 
ğ‘‡  
 
ğ‘‡  
 
ğ‘‡  
 
Legend: 
 
ğ‘˜ğ‘– ğ‘— - vertex representing column ğ‘˜ğ‘– ğ‘— 
ğ‘˜ğ‘– ğ‘— 
ğ‘˜ğ‘– ğ‘› - columns: ğ‘˜ğ‘– ğ‘—, ğ‘˜ğ‘– ğ‘› belonging to table ğ‘‡ğ‘ 
-  
ğ‘‡ğ‘ 
 
ğ‘˜ğ‘– ğ‘— 
ğ‘˜ğ‘š ğ‘› 
ğ‘„ğ‘ 
 
- columns: ğ‘˜ğ‘– ğ‘— ğ‘˜ğ‘š ğ‘› connected by query ğ‘„ğ‘ 
-  
126
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-254-7
eKNOW 2013 : The Fifth International Conference on Information, Process, and Knowledge Management

 
  
 : SELECT * FROM   ,    WHERE      >     , 
  
 : SELECT * FROM   ,    WHERE      =     , 
  
 : SELECT * FROM    WHERE      > [const]. 
 
Example of a hypergraph for considered queries    is 
presented on Fig. 5. This kind of hypergraph presented is 
inconsistent. For this reason queries    are treated as the 
unrelated queries.  
Unrelated queries for index selection process means they 
cannot be treated as a group. In such cases best index set is a 
set determined for each query individually: 
 
 
   {{         } {    } {    } {    }}.  
(6) 
 
Figure 5.  Hypergraph for considered set of queries    
Weighted list for    that that includes all the index 
candidate columns: 
 
    ((       ) (      ) (      ) (      ) (      )) (7) 
 
One can notice there are no query-related candidate 
columns (single column occurrence) that could be used for 
the grouped queries index set creation. Each table    will 
have to be indexed separately for each individual query   . 
V. 
CONCLUSION 
Finding a good index or indexes set for a table is very 
important for every relational database processing not only 
from the performance point but also cost aspect. Indexes can 
be crucial for a relational database to process queries with 
reasonable efficiency, but the selection of the best indexes is 
very difficult. 
Presented examples shows that there is a need for 
finding an automatic index selection mechanism with 
grouped queries-oriented rather than a classic (single query) 
approach. Practice shows that index focus on grouped 
queries gives better results and enables user to save time 
needed for index creation. It also saves system hardware 
resources. In the examples we show that grouped queries 
indexes set are more effective than individual queries 
indexes because queries          satisfy the relation 
condition (Table 1). 
For 
the 
automatic 
index 
selection, 
the 
system 
continuously 
monitors 
queries 
block 
and 
gathers 
information on columns used in queries. The administrator 
(or user) can summon the automatic system at any time to 
be presented with the current index recommendation, or 
tune it to the queriesâ€™ block needs. The system also presents 
the user index set and allows user to choose best option. 
User decides whether to reject or accept proposed set. Due 
to index interactions, the user's decisions might affect other 
indexes in the configuration, so the recommendation would 
need to be regenerated, taking the user's constraints into 
account. 
In the presented examples we considered three situations 
of database queries block execution, one without indexes, 
one with classic separate queries indexing and one with 
grouped queries indexing. Examples showed that one should 
create grouped indexes only for related queries. In that 
context presented relationship may be treated as sufficient 
condition for the evaluation of grouped queries indexing. 
TABLE I.  
CLASSIC AND GROUPED QUERIES APPROACH FOR 
CORRELATED DATABASE QUERIES  
Database queries: 
 
  : SELECT * FROM   ,    
WHERE      <      AND 
    =[const]; 
 
  : SELECT * FROM   ,    
WHERE      =     ; 
 
  : SELECT * FROM    
WHERE      > [const]; 
Classic approach: 
 
CREATE INDEX k1_col1_idx 
ON   (    ); 
CREATE INDEX k1_col3_idx 
ON   (    ); 
CREATE INDEX k2_col1_idx 
ON   (    ); 
CREATE INDEX k2_col2_idx 
ON   (    ); 
CREATE INDEX k3_col2_idx 
ON   (    ); 
 
Grouped queries approach: 
 
CREATE INDEX 
k2_col1_col2_idx ON 
  (    ,     ); 
 
VI. 
FUTURE WORK 
Our current works  are focused on grouped queries index 
selection method with the use of genetic algorithm [2] that 
analyzes database queries, suggests indexesâ€™ structure and 
tracks indexes influence on the queriesâ€™ execution time. We 
work on the system that will be used in an attempt to find 
better indexes for a critical part of long-running database 
queries in testing and production database environment. 
ğ‘˜    
ğ‘˜    
ğ‘˜    
ğ‘˜    
ğ‘„ 
  
 
ğ‘„ 
  
 
ğ‘„ 
  
 
ğ‘‡  
ğ‘‡  
 
Legend: 
 
ğ‘˜ğ‘– ğ‘— - vertex representing column ğ‘˜ğ‘– ğ‘— 
ğ‘˜ğ‘– ğ‘— 
ğ‘˜ğ‘– ğ‘› - columns: ğ‘˜ğ‘– ğ‘— ğ‘˜ğ‘– ğ‘› belonging to table ğ‘‡ğ‘ 
-  
ğ‘‡ğ‘ 
 
ğ‘˜ğ‘– ğ‘— 
ğ‘˜ğ‘š ğ‘› 
ğ‘„ğ‘ 
 
- columns: ğ‘˜ğ‘– ğ‘— ğ‘˜ğ‘š ğ‘› connected by query ğ‘„ğ‘  
ğ‘‡  
 
ğ‘˜    
ğ‘‡  
 
127
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-254-7
eKNOW 2013 : The Fifth International Conference on Information, Process, and Knowledge Management

Recording queries with good indexes together with their 
total execution time is a starting point for broader searches 
in the future. Simple test presented in this article proves 
reasonableness of this method. The developed system is 
scalable: there is a potentiality of combining smaller 
queriesâ€™ blocks into larger series and finding better solution 
based on execution history. 
REFERENCES 
[1] S. Agrawal, S. Chaudhuri, L. Kollar, A. Marathe, V. 
Narasayya, and M. Syamala, â€œDatabase Tuning Advisor for 
Microsoft SQL Server 2005â€. In Proceedings of the 30th 
International Conference on Very Large Databases, 2004. 
[2] T. Back, â€œEvolutionary algorithms in theory and practice: 
evolution strategies, evolutionary programming, genetic 
algorithmsâ€, Oxford University Press Oxford, UK, 1996. 
[3] N. Bruno and S. Chaudhuri, â€œAutomatic physical database 
tuning: 
a 
relaxation-based 
approachâ€, 
SIGMOD 
'05 
Proceedings of the 2005 ACM SIGMOD international 
conference on Management of data, ACM New York, NY, 
USA, 2005, pp.227-238. 
[4] S. Chaudhuri and V. Narasayya, â€œAn efficient Cost-Driven 
Index Selection Tool for MS SQL Serverâ€, Very Large Data 
Bases Endowment Inc, 1997. 
[5] D. Comers, â€œThe Ubiquitous B-Treeâ€, Computing Surveys 11 
(2), doi:10.1145/356770.356776,  pp. 123â€“137. 
[6] B. Dageville, D. Das, K. Dias, K. Yagoub, M. Zait, and M. 
Ziauddin, â€œAutomatic SQL Tuning in Oracle 10gâ€. In 
Proceedings of the 30th International Conference on Very 
Large Databases, 2004. 
[7] C. Dawes, B. Bryla, J. Johnson, and M Weishan, â€œOCA 
Oracle 10g Administration Iâ€, Sybex, 2005, pp.173. 
[8] S. Finkelstein, M. Schkolnick, and P. Tiberio, â€œPhysical 
database design for relational databasesâ€, ACM Trans. 
Database Syst. 13(1), (1988), pp.91â€“128. 
[9] M. Frank and M. Omiecinski, â€œAdaptive and Automated 
Index Selection in RDBMSâ€, Proceedings of EDBT, 1992. 
[10] H. Gupta, V. Harinarayan, A. Rajaraman, and J. D. Ullman, 
â€Index Selection for OLAPâ€, In Proceedings of the 
Internatoinal Conference on Data Engineering, Birmingham, 
U.K., April 1997, p. 208-219. 
[11] D. Knuth, â€œThe Art of Computer Programmingâ€, vol. 3, 
Sorting and Searching. Addison- Wesley, Reading, Mass., 
1973. 
[12] D. Knuth, â€œSorting and Searching, The Art of Computer 
Programmingâ€, Volume 3 (Second ed.), Addison-Wesley. 
[13] P. KoÅ‚aczkowski and H. RybiÅ„ski, â€œAutomatic Index 
Selection in RDBMS by Exploring Query Execution Plan 
Spaceâ€, Studies in Computational Intelligence, vol. 223, 
Springer, 2009, pp.3-24 
[14] J. Kratica, I. Ljubic, and D. Tosic, â€œA Genetic Algorithm for 
the Index Selection Problemâ€, EvoWorkshops'03 Proceedings 
of the 2003 international conference on Applications of 
evolutionary computing, 2003. 
[15] P.L. Lehman, â€œEfficient locking for concurrent operations on 
B-treesâ€, ACM Transactions on Database Systems (TODS), 
Volume 6 Issue 4, Dec. 1981, pp.650-670. 
[16] Y. Maggie, L. Ip, L. V. Saxton, and Vijay V. Raghavan, â€On 
the Selection of an Optimal Set of Indexesâ€, IEEE 
Transactions on Software Engineering, 9(2), March 1983, 
p.135-143. 
[17] M. Schkolnick, â€œThe Optimal Selection of Indices for Filesâ€, 
Information Systems, V.1, 1975. 
[18] K. Schnaitter, â€œOn-line Index Selection for Physical Database 
Tuningâ€, ProQuest, UMI Dissertation Publishing, 2011. 
[19] S. Tatham, â€œCounted B-Treesâ€, 
http://www.chiark.greenend.org.uk/~sgtatham/algorithms/cbtr
ee.html, 11.02.2013. 
[20] H. Wedekind, â€œOn the selection of access paths in a data base 
system. In Data Base Managementâ€, J.W. Klimbie and K.L. 
Koffeman, Eds. North-Holland, Amsterdam, 1974, pp. 385-
397. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
128
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-254-7
eKNOW 2013 : The Fifth International Conference on Information, Process, and Knowledge Management

