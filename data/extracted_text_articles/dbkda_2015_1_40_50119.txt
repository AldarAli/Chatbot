Query-Based ℓ-Diversity
Chittaphone Phonharath
Nara Institute of Science
and Technology
Nara, Japan
Email: chittaphone-p@is.naist.jp
Ryunosuke Takayama, Kenji Hashimoto, Hiroyuki Seki
Nagoya University
Nagoya, Japan
Email: {k-hasimt,seki}@is.nagoya-u.ac.jp
Abstract—We propose a new privacy notion called query-based
ℓ-diversity. A database instance T is ℓ-diverse with respect to
given authorized queries if an attacker cannot narrow down the
number of possible values of the sensitive information to less
than ℓ by inference using the result of the authorized queries
on the instance T and the meaning of the queries. We provide
two approaches to deciding the query-based ℓ-diversity. In the
ﬁrst approach, a decision algorithm is given by using relational
operations, which can be directly implemented by a relational
database management system, e.g., Structured Query Language
(SQL). The second approach transforms a given input to a logical
formula and decides the problem by model counting using a
#SAT solver. We discuss the effectiveness and scalability of the
two approaches based on the experimental results.
Keywords–Database Privacy; Diversity; Inference Attack; Rela-
tional Databases.
I.
INTRODUCTION
Database security is one of the most important challenges
to minimize the leakage of the sensitive information over the
accesses or the data publishing, which have been growing
rapidly and more powerful. Access control is a traditional
mechanism for conﬁdentially restricting accesses to a database
made by a user by dividing the queries into authorized and
unauthorized ones, and restricting the portion of the data that
can be retrieved and updated by the user.
Inference attack is a malicious way to infer the sensitive
information protected by access control. An attack is con-
ducted by combining the result of authorized queries, the
code (the meaning) of the queries and other available external
information to obtain the candidate values of the sensitive
information, as shown in Example 1. Thus, we need an
appropriate quantitative notion of the security of a database
against inference attacks.
Example 1: Table I shows a database instance consisting of
six tuples. Assume that {Zipcode, Gender, Age} is the quasi-
identiﬁer and Diagnosis is the sensitive attribute. Assume that
query (1) extracts tuples of {Zipcode, Age} where “Age” ≤ 60
from Table I, as shown in Table II, and query (2) extracts tuples
of {Age, Diagnosis}, as shown in Table III. If we combine two
results of queries (1) and (2), we can obtain candidate set of
the type of “Diagnosis”, as shown in Table IV. This cannot
guarantee that this database instance is safe against inferencing.
As described in Related Work, there are well-known related
notions such as k-anonymity and ℓ-diversity. Intuitively, a
database is k-anonymous if for every individual x, there are
at least k different records (or tuples in the relational database
TABLE I. A SAMPLE INSTANCE.
Zipcode
Gender
Age
Diagnosis
123-4567
F
45
A
123-5235
F
44
B
123-4567
F
44
C
378-2102
M
65
A
378-2102
M
62
B
378-2102
F
65
A
TABLE II. A RESULT OF QUERY (1).
Zipcode
Age
123-4567
45
123-5235
44
123-4567
44
TABLE III. A RESULT OF QUERY (2).
Age
Diagnosis
45
A
44
B
44
C
TABLE IV. A RESULT OF QUERIES (1) AND (2).
Zipcode
Age
Diagnosis
123-4567
45
A
123-5235
44
B
123-5235
44
C
123-4567
44
B
123-4567
44
C
setting) which cannot be distinguished from the real record for
x. A database is ℓ-diverse if for every individual x, there are at
least ℓ different values of the sensitive information contained in
the records which cannot be distinguished from the real record
for x. Also, various methods are reported for transforming
a given database into a database satisfying k-anonymity or
ℓ-diversity. However, these notions do not take the effect of
access control for queries into consideration.
The goal of this study is to introduce a notion of the
security against inference attack by extending ℓ-diversity in
relational databases with access control for queries. More
speciﬁcally, we propose a new privacy notion called query-
based ℓ-diversity. A database instance T is ℓ-diverse with
respect to given authorized queries if an attacker cannot
narrow down the number of possible values of the sensitive
information for any individual to less than ℓ by inference based
on the result of the authorized queries on the instance T and
the queries themselves. We provide two approaches to deciding
the query-based ℓ-diversity. In the ﬁrst approach, a decision
algorithm is given by using relational operations, which can
15
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

be directly implemented by a relational database management
system, e.g., SQL. The second approach transforms a given
input to a logical formula and decides the problem by model
counting using a #SAT solver. We discuss the effectiveness and
scalability of the two approaches based on the experimental
results.
A. Related Work
The anonymization technique enforces the preservation of
privacy of personal data or sensitive information. General-
ization of the data is one of the well-known techniques for
anonymizing information accordingly with the domain gener-
alization hierarchy from which the quasi-identiﬁer value can be
generalized such as numeric values are generalized to intervals.
There are a few well-known notions for database privacy, k-
anonymity [11][13], ℓ-diversity [8] and t-closeness [7]. These
notions assume the following basic concepts on relational
databases. The set of attributes are divided into sensitive
and nonsensitive attributes. Also, a subset of the nonsensitive
attributes, called the quasi-identiﬁer, is assumed. The value of
the quasi-identiﬁer is potentially used to identify the tuple of
a target individual by linking the disclosed information with
external data.
k-anonymity A database instance satisﬁes k-anonymity if for
any value of the quasi-identiﬁer, there are k or more tuples
having that value of the quasi-identiﬁer. A maximal subset of
tuples having same values of the quasi-identiﬁer is called an
equivalence class. k-anonymity means that the cardinality of
each equivalence class is at least k. A transformation of a given
instance to another instance satisfying k-anonymity is called
a k-anonymization for the original instance. [13] proposed a
method for k-anonymization by hiding some information of
individuals by generalization and suppression. Generalization
replaces a value with less speciﬁc but semantically consistent
value. While suppression hides the data or does not release
the entire data. Various anonymization methods have been
reported using clustering, branch-and-bound search, and so
on [1][2]. k-anonymity is a simple notion and has been
frequently used. As discussed in [8], however, a k-anonymous
database may still have some issues because the database may
lack the diversity in the sensitive attributes. ℓ-diversity has been
proposed by [8] to overcome the weakness of k-anonymity.
Though [8] proposes a general deﬁnition of ℓ-diversity, we
just review a simple and frequently used one, called distinctive
non-recursive ℓ-diversity.
ℓ-diversity A database instance satisﬁes distinctive non-
recursive ℓ-diversity (or simply, ℓ-diversity) if for each equiva-
lence class, there are at least ℓ different values of the sensitive
attributes.
Example 2: As shown in Table I, all tuples have different
values of the quasi-identiﬁer and hence this database instance
does not satisfy k-anonymity for any k ≥ 2. Assume that in
this database instance, the lower four digits of the values of
“Zipcode” are hidden, the values of “Gender” is hidden and the
values of “Age” are generalized to the intervals of ten years.
Then we obtain the database instance shown in Table V. This
instance consists of two equivalence classes and the number
of tuples in each class is three. Hence, this instance satisﬁes 3-
anonymity and the above transformation is a 3-anonymization
for the original instance. Also, the ﬁrst class has three different
values of the sensitive attribute and the second class has two
TABLE V. A 3-ANONYMOUS AND 2-DIVERSE INSTANCE.
Zipcode
Gender
Age
Diagnosis
123-****
-
[40,49]
A
123-****
-
[40,49]
B
123-****
-
[40,49]
C
378-****
-
[60,69]
A
378-****
-
[60,69]
B
378-****
-
[60,69]
A
different values. Hence, the transformed instance satisﬁes 2-
diversity but does not satisfy ℓ-diversity for any ℓ ≥ 3.
k-secrecy A related but different quantitative notion on
database security is given in [5] based on access control on
queries. Assume that a database instance T of a schema R,
authorized queries q1, q2, . . . , qm and an unauthorized query
qU are given. An attacker knows R, q1, q2, . . . , qm, qU (the
meaning of the authorized and unauthorized queries) and
q1(T), . . . , qm(T) (the result of the authorized queries), but
he does not know T. The goal of the attacker is to obtain
qU(T), which is the result of the unauthorized query qU on
T. For a positive integer k, a database instance T is k-secret
with respect to R, q1, . . . , qm, qU if the attacker cannot narrow
down the number of the candidates of qU(T) to less than k.
T is ∞-secret if the candidates of qU(T) are inﬁnite. We
say that a database schema R is k-secret with respect to
q1, . . . , qm, qU if every database instance of R is k-secret.
[5] showed that k-secrecy is decidable for XML databases
where queries are given as tree transducers in a certain subclass
that can use relabeling and deletion. Also, [10] showed that
the problem for deciding whether a given XML schema is
k-secret is undecidable for any ﬁnite k while the problem
is decidable when k = ∞. Although [5] deals with XML
databases, the notion of k-secrecy is general enough for other
kinds of databases. More sophisticated notions have been also
proposed. For example, [3][9] proposed stronger notions where
the probability distribution of possible secrets does not change
after observing (authorized) information. The notion of query-
based ℓ-diversity proposed in this paper is a combination of
k-secrecy and ℓ-diversity in the relational database setting.
The organization of this paper is as follows. Section II
provides basic notions and notations on relational database that
will be used in the paper. We deﬁne the query-based ℓ-diversity
in Section III. In Section IV, a decision algorithm based on
relational operations as the ﬁrst approach is given. Section
V provides the second approach based on model counting.
Experimental results conducted on SQL for the ﬁrst approach
and using a #SAT solver sharpCDCL for the second approach
are shown in Section VI. We conclude the paper in Section
VII.
II.
MODELS
In this section, we introduce a simple relational database
model , which will be used in the rest of the paper. A relational
database instance (or simply a database) can be seen as a
table, of which columns are attributes. There are two types
of attributes, namely sensitive and nonsensitive attributes. The
values of sensitive attributes are considered as secret, that is,
the data owner keeps them conﬁdentially and restrictively and
protects them from unauthorized accesses.
Deﬁnition 1: A relational database schema (or simply a
schema) is a ﬁnite set of attributes. Let R = {A1, . . . , An} be
16
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

a schema. We assume that for each attribute Ai (1 ≤ i ≤ n), a
ﬁnite set of values, denoted by dom(Ai) is associated. A tuple
(or a record) over R is t = (d1, . . . , dn) where di ∈ dom(Ai)
for each 1 ≤ i ≤ n. Let t[Ai] = di, which is called the value of
attribute Ai in t. That is, t = (t[A1], . . . , t[An]). A relational
database instance (or simply an instance) of R is a ﬁnite set
of tuples over R. An instance is sometimes called a table. Let
I[R] denote the set of all instances of R.
Let R be a schema. We assume that R is divided into
two disjoint subsets, namely, Se and NSe, which are the set
of sensitive attributes and the set of nonsensitive attributes,
respectively. We furthermore assume that a subset Qi ⊆ NSe
of nonsensitive attributes is given as a quasi-identiﬁer of
R. We intend that the values of the quasi-identiﬁer can be
potentially used to identify the values of the sensitive attributes
by linking the attribute values of the quasi-identiﬁer with
external data sets.
We deﬁne projection, selection and join in the usual
way. Let R be a schema. For a subset of attributes α =
{Aj1, . . . , Ajm} ⊆ R and a tuple t over R, let πα(t) denote
the tuple (t[Aj1], . . . , t[Ajm]), which is called the projection of
t on α. Also, for an instance T ∈ I[R], let πα(T) = {πα(t) |
t ∈ T}. Let T1 ∈ I(R1) and T2 ∈ I(R2). For a ﬁltering
condition F, and an instance T, let σF (T) denote the set of
tuples in T that satisfy F. The natural join of T1 and T2 is the
instance obtained by “linking” every possible pair of tuples in
T1 and T2:
T1 ▷◁ T2 = {t over R1 ∪ R2 | for some u ∈ T1,
w ∈ T2, t[U] = u and t[W] = w}.
(1)
Since the natural join operator is associative and commutative,
we sometimes view the natural join as a polyadic operator and
write T1 ▷◁ .... ▷◁ Tm.
III.
PROPOSED FRAMEWORK
In order to provide the deﬁnitions, we need to introduce the
candidate set of instances of which results of queries are the
same as those of the real instance. For a given instance T and
queries q1, ..., qm, let cand(q1, ..., qm, T) be the set consisting
of all instances that give the same result as T with respect to
all queries q1, ..., qm:
cand(R, q1, ..., qm, T) = {T ′ ∈ I(R) | ∀i(1 ≤ i ≤ m) ·
qi(T) = qi(T ′)}.
(2)
Each T ′ ∈ cand(R, q1, ..., qm, T) is called a candidate in-
stance.
Let T be a database instance over schema R. T is query-
based ℓ-diverse if for each maximal subset of a candidate
instance of which tuples have the same quasi-identiﬁer, there
are ℓ or more different values of the sensitive attributes.
Suppose that the following information is available to
public: a database schema R, authorized queries q1, ..., qm,
quasi-identiﬁer Qi, sensitive attributes Se and a threshold ℓ
(a positive integer). Let T be an instance of R. An attacker
infers sensitive information by taking the natural join of the
results of the authorized queries q1, ..., qm on the instance T
to obtain the candidate set of sensitive information. We now
show three options for the deﬁnition of query-based ℓ-diversity
as follows.
Deﬁnition 2: An instance T ∈ I(R) is l-diverse (with
respect to R, Qi, Se, q1, ..., qm, T)
(Option 1)
if for every t ∈ πQi(T),
|{πSe(t′) |
∃T ′ ∈ cand(q1, ..., qm, T) ·
(πQi(t′) = t ∧ t′ ∈ T ′)}| ≥ l,
(3)
(Option 2)
if for every t ∈ πQi(T), there is an instance
T ′ ∈ cand(q1, ..., qm, T) such that
|{πSe(t′) | (πQi(t′) = t ∧ t′ ∈ T ′)}| ≥ l,
(4)
(Option 3)
if there is T ′ ∈ cand(q1, ..., qm, T) such that
for every t ∈ πQi(T),
|{πSe(t′) | (πQi(t′) = t ∧ t′ ∈ T ′)}| ≥ l.
(5)
By deﬁnition, (5) implies (4), and (4) implies (3).
A conjunctive query consists of projection, selection and
join. In our proposed framework, we assume self-join free
conjunctive queries.
Deﬁnition 3: A query q on R is monotonic if for any
T1, T2 ∈ I(R), T1 ⊆ T2 implies q(T1) ⊆ q(T2).
Lemma 1: Every conjunctive query is monotonic.
If we restrict the class of queries to self-join free con-
junctive queries, all the three deﬁnitions of ℓ-diversity become
equivalent as stated in the next theorem.
Theorem 1: If
we
assume
self-join
free
conjunctive
queries, then the three options in deﬁnitions 2 become equiv-
alent.
Proof: By the following properties 1 and 2.
Property 1: For any instances T1, T2 and a self-join free
conjunctive query q,
q(T1 ∪ T2) = q(T1) ∪ q(T2).
Proof: Let T1, T2 be instances and q be a self-join free
conjunctive query. By Lemma 1, q is monotonic and hence
q(T1 ∪ T2) ⊇ q(T1) ∪ q(T2) holds. Since q does not contain
self-join, q(T1 ∪ T2) ⊆ q(T1) ∪ q(T2) also holds.
Property 2: Let T be an instance and q1, . . . , qm be self-
join free conjunctive queries. The largest candidate set in
cand(q1, ..., qm, T) (with respect to set inclusion) is the union
of all instances in cand(q1, ..., qm, T).
Proof: Let Tc = S
T ′∈cand(q1,...,qm,T ) T ′. By Property 1,
qi(Tc)
=
[
T ′∈cand(q1,...,qm,T )
qi(T ′)
=
[
T ′∈cand(q1,...,qm,T )
qi(T)
=
qi(T) (1 ≤ i ≤ m).
Hence, Tc ∈ cand(q1, ..., qm, T). Apparently, Tc is the largest
set in cand(q1, ..., qm, T).
We deﬁne the query-based ℓ-diversity problem as follows:
Input
: A schema R, an instance T ∈ I(R), authorized
queries q1, ..., qm, quasi-identiﬁer Qi ⊆ R, sensi-
tive attributes Se ⊆ R, and a threshold ℓ ≥ 1.
Output
: T is query-based ℓ-diverse or not with respect
to R, Qi, Se, q1, ..., qm.
17
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

IV.
VERIFICATION BY RELATIONAL ALGEBRA
In this section, we describe our veriﬁcation algorithm that
solves the query-based ℓ-diversity problem. For simplicity,
we only focus on projection queries. The algorithm can be
extended to deal with join without self-join. However, selection
cannot be allowed. Also, we assume that the set of sensitive
attributes is not empty.
We assume that an attacker knows the domain of each
attribute in R, specially the domains of the sensitive attributes,
so that he can infer a candidate instance by adding values of
the sensitive attributes chosen from the domain even if (some
of) the sensitive attributes are missing in the result of queries
q1, ..., qm.
Our algorithm consists of four steps as follows:
1)
Obtain the candidate set of tuples T ′ by taking the
natural join of all results q1(T), ..., qm(T) as follows.
T ′ = q1(T) ▷◁ ... ▷◁ qm(T).
2)
Let Qi′ (⊆ Qi) be the set of quasi-identiﬁer that
exist in T ′. Compute the subset Tc of T ′ consisting
of tuples whose quasi-identiﬁer value belongs to the
original instance T.
Tc = T ′ ▷◁ πQi′(T).
3)
Divide
Tc
into
subsets
(equivalence
classes)
g1, . . . , gh such that
a)
πQi′(t) = πQi′(t′) for any t, t′ ∈ gi (1 ≤
i ≤ h) and
b)
πQi′(t) ̸= πQi′(t′) for any t ∈ gi (1 ≤ i ≤
h) and t′ ∈ gj (1 ≤ j ≤ h) with i ̸= j.
4)
Let mis Se be the set of sensitive attributes that
does not exist in T ′. With mis Se and the threshold
ℓ, decide whether T is ℓ-diverse by examining the
following necessary and sufﬁcient condition for ℓ-
diversity:
∀gi (1 ≤ i ≤ h),
|gi| ×
Y
a∈mis Se
| dom(a) |
≥ ℓ.
(6)
In the last step, the number of different sensitive values in
each equivalence class gi (1 ≤ i ≤ h) is computed by using
the domains of the missing sensitive attributes mis Se. If for
every equivalence class gi (1 ≤ i ≤ h), the left-hand side of
(6) is greater than or equal to the threshold ℓ, the algorithm
answers that the given input is ℓ-diverse. If there is at least
one equivalence class gi such that the left-hand side of (6) is
less than ℓ, the algorithm answers that the given input is not
ℓ-diverse.
V.
VERIFICATION BY MODEL COUNTING
In this section, we provide another method for deciding the
query-based ℓ-diversity. The method transforms a given input
of the problem to a logical formula, and decides the problem
by model counting using a #SAT solver. The advantage of this
method is that it can handle self-join free conjunctive queries,
consisting of projection, selection and join without self-join.
Henceforth, we assume queries in the class.
Before we explain our method, we give some deﬁnitions.
For a formula Ψ, let #models(Ψ) denote the number of
different models (assignments to variables that make Ψ true).
If a formula Ψ contains only variables in Σ, we call Ψ a Σ-
formula. For a Σ-formula Ψ and ∆ ⊆ Σ, let Ψ|∆ denote the
strongest ∆-formula implied by Ψ when considered as a Σ-
formula where A is stronger than B if and only if A ⇒ B
holds. We say that Ψ|∆ is the projection of Ψ onto ∆.
Assume that a schema R where n = |R|, an instance
T ∈ I(R), queries q1, . . . , qm on R, quasi-identiﬁes Qi ⊆ R,
sensitive attributes Se ⊆ R, and a threshold l are given.
For simplicity, suppose that Qi = {A1, . . . , Ak} ⊆ R, and
Se = {Ak+1, . . . , Am} ⊆ R where 1 ≤ k < m < n. The
summary of the method is as follows.
1)
Construct a logical formula Φ(x1, . . . , xn) such that
Φ(c1, . . . , cn) is satisﬁable
if and only if (c1, . . . , cn) ∈ Tc
(∗)
Note that φ(x1, . . . , xn) has free variables other than
x1, . . . , xn in general.
2)
Decide if for all tuple (c1, . . . , ck) ∈ πQi(T),
#models(Φp(xk+1, . . . , xn)|Xs) ≥ l.
where Xs = {xk+1, . . . , xm} and
Φp(xk+1, . . . , xn) = Φ(c1, . . . , ck, xk+1, . . . , xn).
1) Constructing Constraint: Let n = |R| and ni = |Ri|
where Ri is the output schema of qi (1 ≤ i ≤ m). To construct
a formula Φ(x1, . . . , xn) satisfying (∗), we ﬁrst construct
subformulas φqi and Oqi for 1 ≤ i ≤ m.
(1-i) For 1 ≤ i ≤ m, φqi represents the input-output relation
of the query qi. The formula φqi contains free variables
x1, . . . , xn, y1, . . . , yni and satisﬁes:
for any t = (c1, . . . , cn) and t′
i = (d1, . . . , dni),
φqi(c1, . . . , cn, d1, . . . , dni) is satisﬁable if and only
if qi({t}) ⊆ {t′}.
(Construction)
If q = T then
φq(x1, . . . , xn, y1, . . . , yn) =
n
^
i=1
(xi = yi).
projection: If q = πα(q′) where α = {Aj1, . . . , Ajn′ },
φq(x1, . . . , xnI, z1, . . . , zn′)
=
φq′(x1, . . . , xnI, y1, . . . , ynO) ∧
n′
^
i=1
(yji = zi).
selection: If q = σF (q′),
φq(x1, . . . , xnI, z1, . . . , znO)
=
φq′(x1, . . . , xnI, y1, . . . , ynO)
∧
 
PF (y1, . . . , ynO) ⇒
nO
^
i=1
(yi = zi)
!
.
where PF (y1, . . . , ynO) is a formula representing the ﬁltering
condition F of σF .
18
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

cross product: If q = q′ ∗ q′′,
φq(x1, . . . , xn′
I, x′
1, . . . , x′
n′′
I , z1, . . . , zn′
O+n′′
O)
=
φq′(x1, . . . , xn′
I, y1, . . . , yn′
O)
∧ φq′′(x′
1, . . . , x′
n′
I, y′
1, . . . , y′
n′′
O)
∧
n′
O
^
i=1
(yi = zi) ∧
n′′
O
^
i=1
(y′
i = zn′
O+i).
(1-ii) Oqi is deﬁned as
Oqi(y1, . . . , yni)
=
_
(d1,...,dni)∈qi(T )
((y1 = d1) ∧ · · · ∧ (yni = dni)).
(1-iii) Finally, Φ is deﬁned as
Φ(x1, . . . , xn)
=
m
^
i=1
(φqi(x1, . . . , xn, yi,1, . . . , yi,ni) ∧ Oqi(yi,1, . . . , yi,ni)).
Remember that in the algorithm of the previous sec-
tion, we introduce the subsets g1, . . . , gh, each of which
shares same values of the quasi-identiﬁer. For gj (1
≤
j
≤
h), let (cj
1, . . . , cj
k) be the values of the quasi-
identiﬁer shared by tuples in gj. Let Φj
p(xk+1, . . . , xn) =
Φ(cj
1, . . . , cj
k, xk+1, . . . , xn). By (∗), Φj
p(ck+1, . . . , cn) is sat-
isﬁable if and only if (cj
1, . . . , cj
k, ck+1, . . . , cn) ∈ gj. Fur-
thermore, Φj
p(xk+1, . . . , xn)|Xs is the strongest Xs-formula
implied by Φj
p(xk+1, . . . , xn). Hence, the number of assign-
ments to variables in Xs that make Φj
p(xk+1, . . . , xn)|Xs true
coincides with the number of different values of Se appearing
in tuples that belong to gj. Hence, we obtain the following
lemma.
Lemma 2: Let R be a schema, Qi, Se ⊆ R be the quasi-
quantiﬁer and sensitive attributes, respectively, q1, . . . , qm be
self-join free conjunctive queries on R and T ∈ I(R) be an
instance. Let g1, . . . , gh be the subsets of Tc, each of which
shares same values for the quasi-identiﬁer. For each j (1 ≤
j ≤ h), the number of different values of sensitive attributes
in gj is
#models(Φj
p(xk+1, . . . , xn)|Xs).
2) Counting Candidates: To count the different values of
sensitive attributes for each gj (1 ≤ j ≤ h), we transform
Φj
p(xk+1, . . . , xn) to an equivalent propositional formula Φj
cnf
in conjunctive normal form (CNF) by using Sugar [12]. Next,
for each t′ = (c1, . . . , ck) ∈ πQi(T), we construct a CNF
formula ψt′ that represents x1 = c1 ∧ · · · ∧ xk = ck, and
then count #models(Φj
cnf ∧ ψt′)|P (Xs), where P(Xs) is the
set of the propositional variables in Φj
cnf corresponding to
Xs in Φj
p(xk+1, . . . , xn). We use sharpCDCL [6], which is a
#SAT solver (an automatic tool for counting the models of
a given propositional formula). Among other #SAT solvers
that can count models, the advantage of sharpCDCL is that
it can automatically count #models(Ψ|∆) only by giving a
formula Ψ and a subset ∆ of propositional variables. If some
t′ ∈ πQi(T) such that #models(Φj
cnf ∧ ψt′)|P (Xs) < ℓ is
found, we say that T is not ℓ-diverse. Otherwise, T is ℓ-diverse.
VI.
EXPERIMENTS
A. Experimental Result of Relational Algebra
The purpose of the experiment was to investigate the
scalability of our approach.
1) Setup: Experiment were performed on a 3.33 GHz
Intel(R) Core(TM) i7 CPU with 6GB of RAM. The op-
erating system was Microsoft Windows 8.1 Enterprise, and
implementation was built and run in MySQL Workbench,
version 6.1. We used available dataset, Employees Sam-
ple Database [14], Copyright (C) 2007, 2008, MySQL AB,
version 1.0.6. The database contains about 300,000 tu-
ples with 2.8 million salary entries. In our experiment,
the schema consists of ten attributes, where ﬁve attributes
{Gender, DeptName, BirthDate, HireDate, FromDa-
te} were designated as the quasi-identiﬁer and the sensitive
attribute is {Salary}.
2) Datasets and Queries: The proposed algorithm was
implemented in MySQL and was performed on three instances
(datasets) with n = 37, 500, 75, 000, 150, 000, 300, 000 tuples.
Also, we prepared three queries, each of which is the projection
onto the following attributes:
q1 : {EmpNo, LastName, Gender}.
q2 : {EmpNo, Salary, HireDate}.
q3 : {DeptName}.
In the experiment, we used three sets of queries, namely,
QA = {q1, q2}, QB = {q3}, and QC = {q1, q2, q3}. For
example, for QA, the veriﬁcation algorithm took the natural
join of the results of q1 and q2 on each of the datasets in
Step 1. In Step 3, the algorithm constructed the table from the
candidate set Tc obtained in Step 2 by grouping tuples that
have same values of the quasi-identiﬁer. Lastly, in Step 4, the
algorithm tested ℓ-diversity (ℓ = 2 in the experiment).
TABLE VI. TOTAL TIME OF VERIFYING 2-DIVERSITY.
Dataset
Cases
Total time
q1, q2
7sec
37, 500
q3
4sec
q1, q2, q3
11sec
q1, q2
19sec
75, 000
q3
8sec
q1, q2, q3
31sec
q1, q2
1min 7sec
150, 000
q3
14sec
q1, q2, q3
1min 47sec
q1, q2
4min 8sec
300, 000
q3
26sec
q1, q2, q3
8min 48sec
Table VI shows the total running time of our algorithm.
For example, for QA and the dataset n = 37, 500, the total
running time is 7sec. Also the running time of each set
of queries, QA, QB and QC on the datasets of size n =
37, 500, 75, 000, 150, 000 and 300, 000. We can observe that
the decision algorithm is efﬁcient, in general, and also the
computation time depends on the size of the datasets.
B. Experimental Result of Model Counting
1) Setup: Experiment were performed on a 3.10 GHz
Intel(R) Core(TM) i5 CPU with 8GB of RAM. The operating
system was Ubantu 14.04. We performed the experiment on a
dataset, having 50,000 tuples.
19
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

2) Datasets and Queries: In the experiment, we used
two instances T1 and T2, having ten and eleven attributes,
respectively. Both of T1 and T2 have 5, 000 tuples. Actually,
T1 was obtained from T2 by projecting out one of the eleven
attributes. We conducted the experiment on the following two
settings:
D1:
a query σstate=Iwate(T1),
Qi = {ID, state} and Se = {Name}.
D2:
two queries ΠBirthY ear,BirthMonth(T2),
ΠBirthY ear,BirthMonth(σCarrier=SoftBank(T2)),
Qi = {ID, BirthMonth, Carrier}
and Se = {BirthY ear}.
The experimental results for these settings are shown in
Table VII where clauses and variables are those in the
transformed
CNF
formula,
projected
variables
are
the
variables corresponding to sensitive attributes, min count is
the minimum number of different values of sensitive attributes
among g1, . . . , gh. That is, D1 is ℓ-diverse if and only if
ℓ ≤ 50 and D2 is ℓ-diverse if and only if ℓ ≤ 42. Next, we
TABLE VII. PERFORMANCE OF MODEL COUNTING METHOD.
Projected
Clauses
Variables
variables
Min count
Time
D1
34, 271
14, 916
4, 961
50
6min 15sec
D2
22, 941
11, 121
96
42
2min 1sec
increased the number of tuples in T2 to 10, 000, 30, 000 and
50, 000 and examined the scalability of the proposed method
by using the setting D2. The result is shown in Table VIII.
In sharpCDCL, an upperbound U of the model counting
can be speciﬁed. That is, when sharpCDCL detects that the
current number of models reaches U, sharpCDCL terminates.
The computation times in Table VIII are those when this
upperbound is speciﬁed as U = 20. The transformation to a
TABLE VIII. SCALABILITY OF MODEL COUNTING METHOD.
Projected
Tuples
Clauses
Variables
variables
Time
5, 000
22, 941
11, 121
96
1min 58sec
10, 000
42, 334
20, 877
96
10min 2sec
30, 000
117, 557
58, 541
106
2hrs 28min 30sec
50, 000
187, 820
93, 633
106
8hrs 56min 8sec
CNF formula takes less than one second, and model counting
dominates the running time.
VII.
CONCLUSION
We have introduced query-based ℓ-diversity as a privacy
notion for a realistic database system that assumes access con-
trol for queries. This new notion inherits from ℓ-diversity of [8]
the quantitative notion for the diversity of sensitive attributes.
Also, the notion utilizes k-secrecy of [5] by taking attacker’s
inference on the authorized information into consideration.
We proposed two approaches to deciding whether a given
database instance satisﬁes query-based ℓ-diversity with respect
to given queries. The ﬁrst approach is based on relational
algebra computation that counts the candidate values of the
sensitive attributes. The second approach transforms a given
input to a logical formula and then decide the problem by
counting models of a formula by a #SAT solver. The ﬁrst
approach can directly be implemented by an existing relational
database system such as SQL, and the experimental results
show that this approach is fairly efﬁcient. The weakness is that
it cannot deal with selection queries. The second approach, on
the other hand, can deal with selection queries. However, the
model counting in a #SAT solver is generally time consuming
and we have not yet customized the solver to our problem and
hence, the performance is not good compared with the ﬁrst
approach.
Applying the proposed approach to other kind of databases
such as object-oriented or XML databases is left as a future
study.
REFERENCES
[1]
R. J. Bayardo and R. Agrawal, “Data Privacy Through Optimal k-
Anonymization,” the 10th International Conference on Database Theory
(ICDT), 2005, pp. 217-228.
[2]
J. W. Byun, A. Kamra, E. Bertino, and N. Li, “Efﬁcient k-Anonymization
Using Clustering Techniques,” the 12th International Conference on
Database Systems for Advanced Applications (DASFAA), 2007, pp. 188-
200.
[3]
A. Deutsch and Y. Papakonstantinou, “Privacy in Database Publishing,”
the 10th International Conference on Database Theory (ICDT), 2005, pp.
230-245.
[4]
B. C. M. Fung, K. Wang, R. Chen, and P. S. Yu, “Privacy-Preserving
Data Publishing: A Survey of Recent Developments,” ACM Computing
Surveys, vol. 42, 2010, pp. 14:1-53.
[5]
K. Hashimoto, K. Sakano, F. Takasuka, Y. Ishihara, and T. Fuji-
wara, “Veriﬁcation of the Security Against Inference Attacks on XML
Databases,” IEICE Transactions on Information and Systems, vol. E92-D,
2009, pp. 1022-1032.
[6]
V. Klebanov, N. Manthey, and C. Muise, “SAT-Based Analysis and
Quantiﬁcation of Information Flow in Programs,” 10th International
Conference on Quantitative Evaluation of Systems (QEST), 2013, pp.
177-192.
[7]
N. Li, T. Li and S. Venkatasubramanian, “t-Closeness: Privacy Beyond
k-Anonymity and l-Diversity, the 23rd IEEE International Conference
Data Engineering (ICDE), 2007, pp. 106-115.
[8]
A. Machanavajjhala, J. Gehrke, D. Kifer, and M. Venkitasubramaniam,
“l-Diversity: Privacy Beyond k-Anonymity,” 22nd International Confer-
ence on Data Engineering (ICDE), 2006, also in ACM Transactions on
Knowledge Discovery from Data (TKDD), 2007, vol. 1(3), 52 pages.
[9]
G. Miklau and D Suciu, “A Formal Analysis of Information Disclosure
in Data Exchange,” Journal of Computer and System Sciences, vol. 73,
2007, pp. 507-534.
[10]
C. Phonharath, K. Hashimoto, and H. Seki, “Deciding Schema k-
Secrecy for XML Databases,” IEICE Transactions on Information and
Systems, vol. E96-D, 2013, pp. 1268-1277.
[11]
P. Samarati, “Protecting Respondents’ Identities in Microdata Release,”
IEEE Transactions on Knowledge and Data Engineering, vol. 13, 2001,
pp. 1010-1027.
[12]
“A
SAT-Based
Constraint
Solver,”
URL:
http://bach.istc.kobe-
u.ac.jp/sugar/[accessed: 2015-01-23]
[13]
L. Sweeney, “k-Anonymity: A Model for Protecting Privacy,” Interna-
tional Journal on Uncertainty, Fuzziness and Knowledge-based Systems,
vol. 10, 2002, pp. 557-570.
[14]
F. Wang and C. Zaniolo, “Employees Sample Database,” 2008,
URL: https://launchpad.net/test-db/[accessed: 2014-11-13].
20
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

