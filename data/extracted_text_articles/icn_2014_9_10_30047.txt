PonderFlow: A Policy Speciﬁcation Language for Openﬂow Networks
Bruno Lopes Alcantara Batista
Universidade Estadual do Ceará (UECE)
bruno@larces.uece.br
Marcial P Fernandez
Universidade Estadual do Ceará (UECE)
marcial@larces.uece.br
Abstract—The OpenFlow architecture is a proposal from the
Clean Slate initiative to deﬁne a new Internet architecture where
network devices are simple, and the control plane and manage-
ment are performed on a centralized controller, called Openﬂow
controller. Each Openﬂow controller provides an Application
Programming Interface (API) that allows a researcher or a
network administrator to deﬁne the desired treatment to each
ﬂow inside controller. However, each Openﬂow controller has
its own standard API, requiring users to deﬁne the behavior of
each ﬂow in a programming or scripting language. It also makes
difﬁcult for the migration from one controller to another one, due
to the different APIs. This paper proposes the PonderFlow, an
extension of Ponder language to OpenFlow network policy speciﬁ-
cation. The PonderFlow extends the original Ponder speciﬁcation
language allowing to deﬁne an Openﬂow ﬂow rule abstractly,
independent of Openﬂow controller used. Some examples of
OpenFlow policy will be evaluated showing its syntax and the
grammar validation.
Keywords-Openﬂow; OpenFlow Controller; Policy-based Net-
work Management; Policy Deﬁnition Language
I.
INTRODUCTION
The OpenFlow architecture is a proposal of the Clean Slate
initiative to deﬁne an open protocol that sets up forward tables
in switches [1]. It is the basis of the Software Deﬁned Net-
work (SDN) architecture, where the network can be modiﬁed
dynamically by the user, and the control-plane is decoupled
from the data-plane. The OpenFlow proposal tries to use the
most basic abstraction layer of the switch to achieve better
performance. The OpenFlow protocol can set a condition-
action tuple on switches like forward, ﬁlter and also, count
packets from a speciﬁc ﬂow that match a condition.
The network management is performed by the OpenFlow
Controller maintaining the switches simple, only with the
packet forwarding function. This architecture provides several
beneﬁts: (1) OpenFlow controller can manage all ﬂow deci-
sions reducing the switch complexity; (2) A central controller
can see all networks and ﬂows, giving global and optimal
management of network provisioning; (3) OpenFlow switches
are relatively simple and reliable, since forward decisions are
deﬁned by a controller, rather than by a switch ﬁrmware.
However, as the number of switches increases in a computer
network and it becomes more complex to manage the switches
ﬂows, it is necessary to use a tool to help the network
administrator to manage the ﬂows in order to dynamically
modify the system behavior.
A policy-based tool can reduce the complexity inherent to
this kind of problem, providing a simple way to manage a
large network environment, where the behavior of the network
assets may change over time. Policy-Based Network Manager
(PBNM) is the technology that provides the tools for auto-
mated management of networks using policies to abstract the
behavior on the environment. The PBNM can help network
administrators to manage OpenFlow networks simply deﬁning
policies, where a policy is a set of rules that govern the
behavior of the system.
This paper presents the PonderFlow, an extension of Ponder
policy speciﬁcation language. Ponder is a declarative, object-
oriented language for specifying management and security
policy proposed by Damianou et al. [2]. The PonderFlow
provides the necessary resources to deﬁne or remove ﬂows,
grant privileges to a user, add or remove ﬂows (authorization
policy) and force a user or system to execute an action before
a particular event (obligation policy).
The rest of the paper is structured as follows. In Section
II, we present some related work about OpenFlow policy
speciﬁcation languages. Section III introduces the OpenFlow,
the Policy-Based Openﬂow Network Manager (PBONM) ar-
chitecture and introduces the Ponder speciﬁcation language.
In Section IV, we present the PonderFlow language, and its
respective grammar and validation. In Section V, we conclude
the paper and present some future works.
II.
RELATED WORK
Foster et al. [3] designed and implemented the Frenetic,
a set of Python’s libraries for network programming that
provides several high-level features for OpenFlow/NOX [4]
programming issues. Frenetic is based on functional reac-
tive programming, a paradigm in which programs manipu-
late streams of values, delivering the need to write event-
driven programs leading a uniﬁed architecture where programs
"see every packet" rather than processing trafﬁc indirectly
by manipulating switch-level rules. However, the network
administrator needs to use a programming language, Python
[5] in this case, to deﬁne the behavior of OpenFlow network.
Mattos et al. [6] propose an OpenFlow Management In-
frastructure (OMNI) for controlling and managing OpenFlow
networks and also for allowing the development of autonomous
applications for these networks. OMNI provides a web in-
terface with set of tools to manage and control the network,
and the network administrators interact through this interface.
The outputs of all OMNI applications are eXtensible Markup
204
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-318-6
ICN 2014 : The Thirteenth International Conference on Networks

Language (XML), simplifying the data interpretation by other
applications, agents or human operators. However, the network
administrator needs to use a programming language to call
any OMNI function using a web Application Programming
Interface (API) or access the web interface and proceed
manually.
Voellmy et al. proposed Procera [7], a controller archi-
tecture and high-level network control language that allow to
express policies in the OpenFlow controllers. Procera applies
the principles of functional reactive programming to provide
an expressive, declarative and extensible language. Users can
extend the language by adding new constructors.
The PonderFlow has similarities with Procera and Frenetic,
but our main goal is to create a policy speciﬁcation language
decoupled from the conventional programming languages, and
also, regardless of the OpenFlow controller used. The Ponder-
Flow language is an extension of Ponder language and can be
easily ported to another OpenFlow controller. As Ponder is a
well-known policy language, the validations is not necessary.
In this work, we used the Java language to implement the
parser and lexical analyses in Floodlight OpenFlow controller
[8]. This way, we want to achieve a level of independence from
the programming language and of the OpenFlow controllers.
This paper presents the PonderFlow, an extensible, declarative
language for policy’s deﬁnition in an OpenFlow network.
III.
OPENFLOW POLICY ARCHITECTURE
The OpenFlow architecture has several components: the
OpenFlow controller, one or many OpenFlow devices (switch),
and the OpenFlow protocol. This approach considers a central-
ized controller that conﬁgures all devices. Devices should be
kept simple in order to reach better forward performance and
leave the network control to the controller.
Figure 1.
The OpenFlow architecture [1]
The OpenFlow Controller is the centralized controller of an
OpenFlow network. It sets up all OpenFlow devices, maintains
topology information, and monitors the overall status of entire
network. The device is any capable OpenFlow device on a
network such as a switch, router or access point. Each device
maintains a Flow Table that indicates the processing applied
to any packet of a certain ﬂow. There are several OpenFlow
controllers available, e.g., FloodLight [8], NOX [4], POX [9],
and Trema [10].
The OpenFlow Protocol works as an interface between the
controller and the OpenFlow devices setting up the Flow Table.
The protocol should use a secure channel based on Transport
Layer Security (TLS). The controller updates the Flow Table
by adding and removing Flow Entries using the OpenFlow
Protocol. The Flow Table is a database that contains Flow
Entries associated with actions to command the switch to apply
some actions on a certain ﬂow. Some possible actions are:
forward, drop, and encapsulate.
Figure 2.
The OpenFlow Flow Entry [11]
Each device has a Flow Table with ﬂow entries as shown
in Figure 2. A Flow Entry has three parts: rule match ﬁelds,
an action and statistics ﬁelds and byte counters. The rule
match ﬁelds is used to deﬁne the match condition to a speciﬁc
ﬂow. action deﬁnes the action to be applied to an exact ﬂow,
and statistical ﬁelds are used to count the rule occurrence for
management purposes.
When a packet arrives to the OpenFlow Switch, it is
matched against ﬂow entries in the ﬂow table, and the action
will be triggered if the header ﬁeld is matched and then update
the counter. If the packet does not match any entry in the ﬂow
table, the packet will be sent to the controller over a secure
channel. Packets are matched against all ﬂow entries based
on a prioritization, where each ﬂow entry on ﬂow table has a
priority associated. Higher numbers have higher priorities.
A. Policy-Based Openﬂow Network Manager
The behavior of an OpenFlow network is deﬁned by ﬂow
table entries of the devices (e.g., switch) comprising the
network. These entries determine the action to be taken by
the device, which may authorize the entry of a package in the
device so that it can be forwarded to another device or host
or deny the packet in the device. However, some questions
arise naturally about: (1) How to create or manage OpenFlow
network with controllers currently present? (2) How to delegate
or revoke network permissions to a particular user? (3) How to
manage the switches ﬂows as the number of hosts and switches
increases?
Policy-Based Network Manager (PBNM) has emerged as
a promising paradigm for network operation and management,
and has the advantage to dynamically change the behavior of a
managed system according to the context requirements without
the need to modify the implementation of managed system
[12]. The general PBNM can be considered an adaptation of
the Internet Engineering Task Force (IETF) policy framework
to apply to the area of network provisioning and conﬁguration.
With PBNM the management network process can be sim-
pliﬁed through of centralization and business-logic abstractions
[12]. Centralization refers to the process of conﬁguring all
205
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-318-6
ICN 2014 : The Thirteenth International Conference on Networks

devices in a single-point (Policy Management Tool (PMT))
instead of reconﬁguring the device individually.
Policy
Repository
Policy-Based OpenFlow Network Management
Policy Management Tool (PMT)
Policy Decision Point (PDP)
Policy Enforcement Point (PEP)
OpenFlow Network Devices
User management Tool
Switch management Tool
Layer Management Tool
Authorization
Policy Parser
Policy Evaluation
Conflicts Checker
Policy Implementer
OpenFlow Controller
Figure 3.
The Policy-Based OpenFlow Network Manager architecture
In a previous work [13], we propose to use the PBNM
concepts in OpenFlow networks. PBONM was proposed, a
framework based on the IETF policy framework. Ponder lan-
guage was chosen as the standard policy speciﬁcation language
in the PBONM. The PBONM is depicted on Figure 3. The
architecture is divided in the following layers:
Policy Management Tool (PMT): it is a software layer that
manages the network users, switches and OpenFlow layers
providing the User Interface to enable these features. The
Ponder is used to specify the policies in this layer. The
Policy Repository (database) will store the policies and other
information about of the network.
Policy Decision Point (PDP): it is responsible to interpreting
the policies stored in the repository, checks the users’ autho-
rization (if the user has permission to add or remove a ﬂow in
speciﬁc switch), check policy conﬂicts on database and release
the policies to Policy Enforcement Point.
Policy Enforcement Point (PEP): it is responsible to execute
the conﬁguration of OpenFlow controller. When the policies
are interpreted, OpenFlow ﬂows are generated and forwarded
to the OpenFlow controller. So, the OpenFlow controller can
enforce these ﬂows on the network.
OpenFlow Network Devices: they are OpenFlow switches
controlled by an OpenFlow controller and conﬁgured by PEP.
Thus, the network administrator can specify network ﬂows
and the users’ permission through of a graphical tool using a
policy speciﬁcation language. These policies will be translated
to OpenFlow controller API calls and will be applied to the
network devices.
B. Ponder: Policy Speciﬁcation Language
Ponder is a declarative, object-oriented language for spec-
ifying security and management policy for distributed object
systems proposed by Damianou et al. [2]. The language is
ﬂexible, expressive and extensible to cover the wide range
of requirements implied by the current distributed systems
requirement and allows for the speciﬁcation of security policies
(role-based access control) and management policies (manage-
ment obligations) [14].
There are four building blocks supported on Ponder, which
are: (1) authorizations: what activities the subject can perform
on the set of target objects; (2) obligations: what activities a
manager or agent must perform on target objects; (3) refrains:
what actions a subject must not execute on target objects; (4)
delegation: granting privileges to grantees.
However, the Ponder language does not support the net-
work ﬂows abstraction. In contrast, OpenFlow architecture
works over the network ﬂows concept. To use Ponder in
PBONM, an extension to the language is needed, to support the
requirement inherent in the new environment. Thus, a network
administrator can deﬁne ﬂows in a network switch OpenFlow
clearly and concisely.
The advantage of using a policy language is that the
network administrator only needs to think in an abstract form,
how the OpenFlow network should work, without worrying
about the implementation details of a speciﬁc controller. Unlike
other ﬂow language’s deﬁnition, that requires the administrator
to use a programming language [3], [6], [7].
Ponder2 is a re-design of Ponder language and toolkit,
maintaining the concepts and the basic constructs [15]. In
contrast to the original Ponder, which was designed for general
network and systems management, Ponder2 was designed as
an extensible framework that can be used to conﬁgure more
complex services. It uses the PonderTalk, a high-level con-
ﬁguration and control language, and it permits user-extensible
Java objects. In our proposal, we prefer to use the original
Ponder language because the new functionality of Ponder2
is not necessary. We believe that the concise description of
Ponder is easier for a network administrator, unlike the more
extensible and complex PonderTalk description.
IV.
PONDERFLOW: OPENFLOW POLICY SPECIFICATION
LANGUAGE
Ponder is the policy language used to manage security
policies and access control. However, the Ponder language
is too vague to cover all types of manageable environments
[16]. PonderFlow is a policy deﬁnition language for Open-
Flow networks where your main objective is to specify ﬂows
transparently, independent of OpenFlow controller used in the
network. The PonderFlow extends the Ponder language [2] to
suit the ﬂow deﬁnition paradigm of OpenFlow environment.
Some of the Ponder’s building blocks were kept and others
were not used in favor of simplicity. Nevertheless, even keep-
ing some building blocks from the original Ponder language;
the philosophy behind these blocks was changed to suit the
paradigm of OpenFlow networks. Furthermore, it was added a
way to specify ﬂows through policies, making PonderFlow a
declarative scripting language. In this way, the new keyword
ﬂow is included to specify the ﬂow’s characteristics. In the
following subsections, the building blocks will be explained,
and we will show some examples to manage network ﬂows.
206
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-318-6
ICN 2014 : The Thirteenth International Conference on Networks

ANTLR framework [17] was used to generate the lexi-
cal analyzer and parser grammar in the Java programming
language, as well as to generate the images of Abstract
Syntax Tree (AST) tree of the building blocks deﬁned in the
PonderFlow.
A. Authorization Policies
The authorization policies deﬁne what the members within
a group (subject) may or may not do in the target objects.
Essentially, these policies deﬁne the level of access that users
possess to use an OpenFlow switches network.
A positive authorization policy deﬁnes the actions that
subjects are permitted to do on target objects. A negative
authorization policy speciﬁes the actions that subjects are not
allowed to do on target objects.
This building block is very similar to the original language
Ponder, but the focus of this building block in PonderFlow
context is in the access by the users in the switches that
comprise the OpenFlow network and OpenFlow controller
itself.
Listing 1.
PonderFlow Authorization Policy Sintax
1 i n s t
(
auth+
|
auth− )
policyName {
subject
[ < type_def >]
domain−scope−expression ;
3
ta rget
[ < type_def >]
domain−scope−expression ;
[
flow
[ < type_def >]
flow−expression ;
]
5
action
a c t i o n − l i s t ;
[ when c o n s t r a i n t − e x p r e s s i o n
|
constraint−flow−expression
] ;
7 }
The syntax of an authorization policy is shown in Listing 1.
Everything in bold is language keywords. Choices are enclosed
within round brackets ( ) separated by |. Names and variables
are represented within
< >. Optional elements are speciﬁed
with square brackets [ ]. The policy body is speciﬁed between
braces { }.
Constraints are optional in authorization policies and can
be speciﬁed to limit applicability of policies based on time or
attributes values to the objects on which the policy refers.
The elements of an authorization policy can be speciﬁed
in any order, and the policy name must begin with a letter and
contain letters, numbers and underscore in the rest of your
name.
The speciﬁcation of the subject and target may be option-
ally speciﬁed using an Uniform Resource Identiﬁer (URI) that
represent the domain of the subject or of the target. Moreover,
we can specify the subject type or the target type in the policy
deﬁnition.
Listing 2.
Positive authorization policy example
1 i n s t
auth+ switchPolicyOps {
subject <User >
/ NetworkAdmin ;
3
ta rget
<OFSwitch >
/ Nregion / s wi t ch e s ;
action
addFlow ( ) ,
removeFlow ( ) ,
enable ( ) ,
d i s a b l e ( ) ;
5 }
The Listing 2 shows an example of a positive authorization
policy that allows all network administrators to perform the
actions of adding ﬂows, remove ﬂows, enable and disable all
switches in Nregion. Note that this policy is applied to any
ﬂow, and it is similar to conventional Ponder authorization
policy. In Figure 4, we show the AST tree of a positive
authorization policy from Listing 2.
The language also provides the ability to deﬁne policy
types, enabling the reuse of policies by passing formal param-
eters in its deﬁnition. Several instances of the same type can
be created and adapted to the identical environment through
real values as arguments.
Listing 3.
Type deﬁnition policy sintax
1 type
(
auth+
|
auth− )
policyType
(
formalParameters ) {
a u t h o r i z a t i o n − p o l i c y − p a r t s
3 }
i n s t
(
auth+
|
auth− )
policyName = policyType (
a c t u a l P a r a m e t e r s
)
The authorization policy switchPolicyOps (from Listing 2)
can be speciﬁed as a type of the subject and target given as
parameters as shown in Listing 4.
Listing 4.
Type policy deﬁnition example
type
auth+ PolOpsT ( subject
s ,
ta rg et <OFSwitch > t ) {
2
action
load ( ) ,
remove ( ) ,
enable ( ) ,
d i s a b l e ( )
;
}
4 i n s t
auth+ admPolyOps=PolOpsT ( / NetworkAdmins ,
/ NregionA / s w i t c h e s ) ;
i n s t
auth+ rsrPolOps =PolOpsT (
/ Researchers ,
/ NregionB / s w i t c h e s ) ;
Furthermore, we can use the PonderFlow Authorization
Policies to deﬁne a ﬂow in the OpenFlow network. A ﬂow
is an OpenFlow network path between hosts, independent of
the switch quantity. Thus, network administrator does not need
to use a programming language like Java, Python or C++, to
directly manipulate the OpenFlow network behavior through
of the OpenFlow controller.
Listing 5.
Type policy deﬁnition example
1 flow−expression = on = <DPID>
,
|
s r c = <DPID>/ < switch_port >
,
3
|
s r c = <IP−ADDRESS>
,
|
s r c = <MAC_ADDRESS>
,
5
|
d s t = <DPID>/ < switch_port >
,
|
d s t = <IP−ADDRESS>
,
7
|
d s t = <MAC_ADDRESS>
,
|
by = <DPID> ;
To deﬁne a ﬂow, we need to use the keyword ﬂow in
the authorization policy statement. With this keyword, we can
deﬁne the characteristic of the ﬂow. Furthermore, it is possible
deﬁne a path restriction where the network administrator can
deﬁne where the ﬂow must pass.
The Listing 5 shows the grammar of ﬂow-expression,
where: DPID is the switch identiﬁcation, src and dst
are respectively the source device and destination device,
switch_port is the incoming packet switch port, IP-ADDRESS
is a valid IP address and MAC-ADDRESS is a valid MAC
address.
Listing 6.
A PonderFlow authorization policy
i n s t
auth+ flow01 {
2
subject <User >
/ Users / S t u d e n t s / John ;
ta rg et
<Switch > / Uece / Macc / Larces / Switches ;
4
flow <Flow> s r c =00:00:00:2C:AB:7C: 0 7 : 2A/2
,
d s t =00:00:00:47:5B:DD:3 F :1B/5
,
6
by
=00:00:00: C5 : FF : 2 1 : 7 F :3B ,
0 0 : 0 0 : 0 0 : 3 3 : 4 5 :AF:1C:8A ;
8
action
setFlow ( ) ;
when src−ip =192.168.0.21 ,
10
dst−ip =192.168.0.57 ,
dst−port =80;
12 }
207
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-318-6
ICN 2014 : The Thirteenth International Conference on Networks

Figure 4.
The AST tree for Listing 2 example
TABLE I.
OPENFLOW POLICY WILDCARDS
ingress-port
The switch port on which the packet is received
src-mac
The source mac address value
dst-mac
The destination mac address value
vlan-id
The VLAN identiﬁcation value
vlan-priority
The VLAN priority value
ether-type
The ethernet type value
tos-bits
The ToS bits value
protocol
The IP protocol number used in the protocol ﬁeld
src-ip
The source IP address value
dst-ip
The destination IP address value
src-port
The source protocol port value
dst-port
The destination protocol port value
The example in Listing 6 authorizes a ﬂow to user /User/S-
tudents/John (subject), on the switches of domain /Uece/-
Macc/Larces/Switches, set ﬂows (action) on the network to
establish a path starting from the switch with Datapath ID
(DPID) 00:00:00:2C:AB:7C:07:2A on the port 2 (src) and
ending in the switch with DPID 00:00:00:47:5B:DD:3F:1B
on
port
5
(dst),
passing
by
the
switches
with
DPID
00:00:00:C5:FF:21:7F:3B and 00:00:00:33:45:AF:1C:8A (by)
when the source IP address of the ﬂow is 192.168.0.21, the
destination IP address 192.168.0.57 and the protocol destina-
tion port is 80.
PonderFlow speciﬁes a set of default actions for ﬂow
deﬁnition, but the developers are free to add more actions to
the language. The default actions are listed in Table II. The
Listing 7 deﬁnes a policy which user Alice can set a ﬂow action
that changes the source IP address of the packet to 10.23.45.65
when the destination IP address is 10.23.45.123 on the switch
with DPID 00:00:00:4F:32:1D:56:9C.
Listing 7.
The ﬂow deﬁnition that change the source ip address
i n s t
auth+ flow02 {
2
subject <User >
Alice ;
ta rget
<Switch > 0 0 : 0 0 : 0 0 : 4 F : 3 2 : 1D: 5 6 : 9C;
4
action
s e t S r c I P ( ’ 1 0 . 2 3 . 4 5 . 6 5 ’ ) ;
when dst−ip = 1 0 . 2 3 . 4 5 . 1 2 3 ;
6 }
Furthermore, it is possible to deﬁne a policy to be applied
in a speciﬁc switch and not a path. This is desirable when the
network administrator wishes to add or remove a particular
ﬂow in a speciﬁc switch, in this way, the network administrator
changes the network behavior in a single point on the network.
TABLE II.
OPENFLOW ACTION FIELD
setFlow()
Set the ﬂow(s) in a speciﬁed path
delFlow()
Delete the ﬂow(s) in a speciﬁed path
setSrcIp(ip-address)
Set the source IP address of the packet
setDstIp(ip-address)
Set the destination IP address of the packet
setSrcMac(mac-address)
Set the source MAC address of the packet
setDstMac(mac-address)
Set the destination MAC address of the packet
setSrcPort(port)
Set the source port of the packet
setDstPort(port)
Set the destination port of the packet
setVlanId(integer)
Set the VLAN of the packet
setVlanPriority(integer)
Set the VLAN priority of the packet
B. Obligation Policies
Obligation policies allow to specify actions to be performed
by the network administrator or by the OpenFlow controller
when certain events occur in an OpenFlow network and
provide the ability to respond any change in circumstances.
These policies are event-triggered and deﬁne the activities
subjects (network administrator or OpenFlow controller) must
perform on objects within the target domain. Events can be
simple, e.g., an internal timer, or more complex, starting by
reading some kind of sensor, e.g., a network card stopped.
This building block is very similar to the original language
Ponder, but in the context of PonderFlow, including ﬂow
deﬁnition. This block sets an obligation for the network ad-
ministrator or the OpenFlow controller performs some action,
or simply is notiﬁed, when a particular event occurs.
Listing 8.
Obligation policy sintax
i n s t
oblig
policyName {
2
on
e v e n t − s p e c i f i c a t i o n
;
subject
[ < type_def >] domain−Scope−Expression
;
4
[
ta rg et
[ < type_def >] domain−Scope−Expression
;
]
do
o b l i g a t i o n − a c t i o n − l i s t
;
6
[
catch
e x c e p t i o n − s p e c i f i c a t i o n
;
]
[ when c o n s t r a i n t − E x p r e s s i o n
;
]
8 }
The syntax of obligation policies is shown in Listing 8. The
required event speciﬁcation follows the on keyword. The target
element is optional in obligation policies. The optional catch-
clause speciﬁes an exception that is performed if the actions
fail to execute, for some reason.
In Listing 9, the obligation policy is triggered when a
failure on adding a ﬂow occurs. The network administrator
208
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-318-6
ICN 2014 : The Thirteenth International Conference on Networks

Figure 5.
The AST tree for Listing 9 example
will be notiﬁed when this event occurs, and he will receive
the switch ID where it happened. Figure 5 shows the AST
tree of Listing 9.
Listing 9.
Obligation policy sintax
i n s t
oblig
flowAddFailure {
2
on flowAddFailure ( dpid )
;
subject <User > s =/ A d m i n i s t r a t o r s
;
4
ta rget <OFSwitch > t = / Nregion / Switches / sw01
;
do
n o t i f i c a t e ( s ,
t )
;
6 }
To perform an obligation policy, it is required that the user
has an authorization over the target. This can be speciﬁed
with an authorization policy. If there is no authorization
policy specifying who can perform a particular action, the
obligation policy will produce an exception error (depends on
the implementation), and the policy will not be applied in the
system.
V.
CONCLUSION AND FUTURE WORKS
The paper described the PonderFlow language, a new
policy speciﬁcation language for OpenFlow networks. With
this language, the network administrator does not need to know
a programming language, like Java, Python or C++, to specify
the policy of an OpenFlow network. The language building
blocks are simple and concise to deﬁne ﬂow policy. The
PonderFlow grammar was presented as well as some examples
of usage and their AST tree representation. The grammar
was tested using the ANTLR framework, which generates
the parser and the lexical analyser for the Java programming
language.
As a future work, we will extend the Ponder language
to use the OpenFlow 1.3 speciﬁcation. This work used the
OpenFlow 1.0 speciﬁcation for the PonderFlow because most
of the commercial switches support only this version. Another
point that should be studied is the treatment of policy’s
conﬂicts, where a network administrator can, by accident or
malpractice, declare two or more conﬂicting policies. It is
necessary to perform an assessment on all policies before
applying them on OpenFlow controller.
REFERENCES
[1]
N. McKeown, T. Anderson, H. Balakrishnan, G. Parulkar, L. Peterson,
J. Rexford, S. Shenker, and J. Turner, “OpenFlow: enabling innovation
in campus networks,” ACM SIGCOMM Computer Communication
Review, vol. 38, no. 2, 2008, pp. 69–74.
[2]
N. Damianou, N. Dulay, E. Lupu, and M. Sloman, “The ponder
policy speciﬁcation language,” in Proceedings of the International
Workshop on Policies for Distributed Systems and Networks (POLICY
’01).
London, UK, UK: Springer-Verlag, 2001, pp. 18–38. [Online].
Available: http://dl.acm.org/citation.cfm?id=646962.712108
[3]
N. Foster, R. Harrison, M. J. Freedman, C. Monsanto, J. Rexford,
A. Story, and D. Walker, “Frenetic: a network programming language,”
SIGPLAN Not., vol. 46, no. 9, Sep. 2011, pp. 279–291. [Online].
Available: http://doi.acm.org/10.1145/2034574.2034812
[4]
NOXRepo.org, “NOX Openﬂow Controller,” Last accessed, Aug. 2013.
[Online]. Available: http://www.noxrepo.org/nox/about-nox/
[5]
G. VanRossum and F. L. Drake, The Python Language Reference.
Python Software Foundation, 2010.
[6]
D. M. F. Mattos, N. C. Fern, V. T. D. Costa, L. P. Cardoso, M. Elias,
M. Campista, L. H. M. K. Costa, and O. C. M. B. Duarte, “Omni:
Openﬂow management infrastructure,” Paris, France, 2011.
[7]
A. Voellmy, H. Kim, and N. Feamster, “Procera: a language for
high-level reactive network control,” in Proceedings of the ﬁrst
workshop on Hot topics in software deﬁned networks, ser. HotSDN
’12.
New York, NY, USA: ACM, 2012, pp. 43–48. [Online].
Available: http://doi.acm.org/10.1145/2342441.2342451
[8]
D.
Erickson,
“Floodlight
Java
based
OpenFlow
Con-
troller,”
Last
accessed,
Aug.
2013.
[Online].
Available:
http://ﬂoodlight.openﬂowhub.org/
[9]
NOXRepo.org, “POX Openﬂow Controller,” Last accessed, Aug. 2013.
[Online]. Available: http://www.noxrepo.org/pox/about-pox/
[10]
NEC Corporation, “Trema Openﬂow Controller,” Last accessed, Aug.
2012. [Online]. Available: http://trema.github.com/trema/
[11]
B. Heller, “Openﬂow switch speciﬁcation, version 1.0.0,” Dec. 2009.
[Online].
Available:
www.openﬂowswitch.org/documents/openﬂow-
spec-v1.0.0.pdf
[12]
D. C. Verma, “Simplify network administration using policy-based
management,” IEEE Network, March/April 2002.
[13]
B. L. A. Batista, G. A. L. de Campos, and M. P. Fernandez, “A proposal
of policy based OpenFlow network management,” in 20th International
Conference on Telecommunications (ICT 2013), Casablanca, Morocco,
May 2013.
[14]
M. Sloman, “Policy driven management for distributed systems,” Jour-
nal of Network and Systems Management, vol. Vol.2, no. No 4, 1994.
[15]
K. Twidle, E. Lupu, N. Dulay, and M. Sloman, “Ponder2-a policy
environment for autonomous pervasive systems,” in Policies for Dis-
tributed Systems and Networks, 2008. POLICY 2008. IEEE Workshop
on.
IEEE, 2008, pp. 245–246.
[16]
T. Phan, J. Han, J.-G. Schneider, T. Ebringer, and T. Rogers, “A survey
of policy-based management approaches for service oriented system,”
19th Australian Conference on Software Engineering, 2008.
[17]
T. Parr, “ANTLR: ANother Tool for Language Recognition,” Last
accessed, Aug. 2013. [Online]. Available: http://www.antlr.org/
209
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-318-6
ICN 2014 : The Thirteenth International Conference on Networks

