Performance and Design Guidelines for PPETP, a
Peer-to-Peer Overlay Multicast Protocol for
Multimedia Streaming
Riccardo Bernardini, Roberto Cesco Fabbro, Roberto Rinaldo
DIEGM – Universit`a di Udine, Via delle Scienze 208, Udine, Italy
{riccardo.bernardini,roberto.cesco,roberto.rinaldo}@uniud.it
Abstract—One major issue in multimedia streaming over the
Internet is the large bandwidth that is required to serve good
quality content to a large audience. In this paper we describe
PPETP, a peer-to-peer protocol for efﬁcient multimedia streaming
to large user communities. The performance of the protocol (such
as the robustness of the protocol with respect to packet losses and
churn) are quantitatively analyzed and guidelines for designing
peer-to-peer streaming systems based on the described protocol
are given.
Keywords-Data transmission; multimedia streaming; overlay
multicast; peer-to-peer network; push networks
I. INTRODUCTION
A problem that is currently attracting attention in the
research community is the problem of streaming live content
to a large number of nodes. The main issue to be solved is due
to the amount of upload bandwidth required to the server that,
unless multicast is used, is equal to the bandwidth required by
a single viewer (some Mb/s for DVD quality) multiplied by
the number of viewers (that can be very large, for example, it
is reported that in 2009 the average number of viewers per F1
race was approximately 6·108). Multicast could be a possible
solution, but it has drawbacks too. For example, multicast
across different Autonomous System (AS) has several issues,
both technical and administrative ones.
An approach that recently attracted interest in the research
community is the use of peer-to-peer (P2P) solutions as
described in [2] to [15]. With the P2P approach each viewer
re-sends the received data to other users, implementing what
could be roughly deﬁned as an overlay multicast protocol
where each user is also a router. Ideally, if each user retrans-
mitted the video to another user, the server would just need
to “feed” a handful of nodes and the network would take care
of itself.
Unfortunately, the application of the P2P paradigm to multi-
media streaming has some difﬁculties. For example, depending
on the media type and quality, residential users could have
enough download bandwidth to receive the stream, but not
enough upload bandwidth to retransmit it. This problem is
known as the asymmetric bandwidth problem.
Another important issue with P2P networks of residential
nodes is due to the churn of the network, that is, the “turbu-
lence” induced by users joining and leaving the network at
random. In particular, if a user suddenly leaves the network,
other users could be left without data for a long time.
Moreover, P2P networks have several security issues [16].
Here we simply cite the stream poisoning attack where a node
sends incorrect packets that cause an incorrect decoding and
are propagated to the whole network by the P2P mechanism.
This article is the extension of [1] and describes the Peer-to-
Peer Epi-Transport Protocol (PPETP), a peer-to-peer protocol
developed at the University of Udine and hosted as part of the
project Corallo on SourceForge. While the description given
in [1] was more of a qualitative nature, describing the main
feature of PPETP, without going into quantitative details, this
paper aims to give a more analytical description of the feature
of PPETP, with the objective of giving guidelines for designing
networks based on PPETP. For the sake of completeness,
in this paper we brieﬂy summarize some results published
elsewhere, taking care of marking explicitly the parts taken
from other works.
This paper is organized as follows. Section III gives a
qualitative overview of PPETP and introduces some jargon;
Section IV introduces the concept of reduction procedure,
a key concept in PPETP; Section V analyzes some features
of PPETP that derives from the use of reduction functions;
Section VI analyzes the packet loss probability experienced by
the nodes in a PPETP network; Section VII gives some quan-
titative results about the robustness of PPETP against churn;
Section VIII gives some guidelines for designing networks
based on PPETP; Section IX presents the conclusions.
II. STATE OF THE ART
The ﬁrst P2P streaming networks had a tree structure,
inspired by IP multicast. For example, ZIGZAG [17], built a
multicast tree for media streaming at the application layer. This
structure is, however, quite weak, mainly because, differently
from IP-layer multicast, the P2P tree is built upon peers that
may join and leave at any time. This is a serious issue, since a
departing peer disconnects all its descendants from the source.
Multiple tree-based overlay architectures, such as Split-
Stream [10], CoopNet [18] and ChunkySpread [19], are
proposed to mitigate the issues in single-tree architectures.
Compared to architectures based on a single tree, architectures
based on multiple trees are more resilient to peer departures
159
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

and failures. In addition, they can more efﬁciently use the
uploading link capacity of each peer, since each peer works
as an interior node in at least one tree. However, they achieve
these beneﬁts at the cost of more complicated architectures
and media encoding methods.
Recently, many proposed P2P streaming networks, such
as CoolStreaming [20], AnySee [21], PRIME [22], and
DagStream [23] use mesh networks. In an unstructured mesh
network (e.g., PRIME, CoolStreaming) a peer connects with a
large number of randomly selected peers, with the purpose of
providing more neighbors and more diverse paths. In a struc-
tured mesh network peers are typically grouped into clusters,
in order to reduce the propagation delay of packets. However,
such a locality-aware network may suffer from the shared
bottleneck problem, where the media quality of all peers in
a cluster strongly depends on the available bandwidth at a
shared bottleneck. For these reasons, a locality-aware approach
constructs a mesh with some special structure in order to
achieve good network connectivity. Another approach used
in some P2P streaming systems is the use of rateless codes.
Examples of this approach are rStream [24] and ToroVerde
[25].
Most of the currently available P2P streaming systems are
mesh-based and employ ideas similar to the ones used in P2P
ﬁle sharing systems such as BitTorrent. In this type of P2P
streaming systems, the content is split into sections (called
chunks, so this type of systems is sometimes referred to as
chunked P2P systems). In a typical chunked system a node
queries and requests them content chunks. A serious issue in
chunk-based P2P systems is that they have very long start-up
times due to the fact that in order to use a chunk-based system
with live material, it is necessary to do some buffering.
III. OVERVIEW OF PPETP
The goal of this section is to give a brief overview of the
structure of PPETP and to introduce some PPETP jargon that
will be used in the following. For the sake of brevity, many
details will be omitted. A more detailed description can be
found in the Internet Draft [26].
PPETP can be considered as a multicast overlay protocol
based on a P2P approach that sends data and commands over
a non necessarily reliable protocol (e.g., UDP). The type of
multicast done over a PPETP network can be both Any Source
Multicast (ASM) or Source Speciﬁc Multicast (SSM); in this
paper we will consider, for the sake of concreteness, the SSM
case only, the adaptations for the ASM being obvious. In the
SSM case the origin of the content will be called origin server.
Since each node streams autonomously to other nodes, a
PPETP network can be considered a push network. If node A
receives data from node B, we will say that A is a lower peer
of B and that B is an upper peer of A (therefore, data ﬂows
from top to bottom). PPETP does not mandate any speciﬁc
network topology, the only constraint being that each node
has a minimum number of upper peers.
Fig. 1 shows an example of a possible PPETP network for
multimedia streaming with three upper peers per node. Each
Source
A
B
C
F
G
E
D
Figure 1.
Example of a PPETP network for multimedia streaming.
arrow represents a stream, each circle represents a node and the
node available upload bandwidth is represented by the circle
size. For example in Fig. 1, node A (an upper peer of C, D
and E) sends to C two different streams. Note also that the
source “feeds” directly nodes A and B by sending them three
different streams. Other examples of possible topologies for
a PPETP network are shown in Fig. 2. Note that not only
tree-structured networks are possible with PPETP.
Remark III.1 (What PPETP is not)
A P2P streaming system is a complex piece of software that
must take care of several things: transferring data, ﬁnding new
peers, tracking content and so on. We would like to emphasize
here that PPETP is designed to take care only of the efﬁcient
data distribution; other important aspects of the P2P streaming
application (e.g., building the network) are demanded to extra-
PPETP means. This is similar to what happens with TCP: the
standard speciﬁes how data is carried from a host to another,
but does not specify, for example, how one host ﬁnds the other,
this being handled by protocols such as DNS.
IV. DATA REDUCTION PROCEDURES
A key characteristic of PPETP is that, in order to solve the
asymmetric bandwidth problem, every node does not send to
its lower peers the whole content stream, but a reduced stream
that requires less bandwidth. The reduced stream is obtained
by processing each packet in the content stream with a suitable
reduction function.
Informally, a reduction function is a function that maps the
set of bit-strings (i.e., the set of packets) into itself, with the
property that the result is shorter (actually, R times shorter)
and that one can recover the original bit-string when at least
R reduced versions if the original bit-string are known.
We will represent mathematically packets as elements of
B def
= {0,1}∗, the set of all ﬁnite bit-strings. With this position,
reduction functions are represented by functions mapping
packets into packets, that is, B in B. In the following will
be convenient to have a notation that allows to represent
compactly a vector of reduction functions.
160
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

(a)
(b)
Figure 2.
Examples of network topologies compatible with PPETP (a) parallel trees and (b) onion skin. The dashed lines mark the stratum boundaries
Notation 1. Let B
def
= {0,1}∗ be the set of all ﬁnite bit-string,
let J be a ﬁnite set and let
R = { fa : B → B,a ∈ J}
(1)
a set of functions mapping bit-strings in bit-strings and in-
dexed by J. For every n-ple of indexes a = (a1,a2,··· ,an) ∈ Jn
we will denote with ga : B → Bn the function
ga(x)
def
= [fa1(x),..., faR(x)]
(2)
The key property of reduction functions is what we call R-
reconstruction property, that is, the possibility of recovering
a packet when at least R different reduced versions of it are
known. This idea is made precise in Deﬁnition 1.
Deﬁnition
1. Set R in (1) is said to satisfy the R-
reconstruction property if for every a ∈ JR the corresponding
function ga (deﬁned as in (2)) is injective.
We will say that the R-reconstruction property is satisﬁed
tightly by R if for every a ∈ JR−1 the corresponding function
ga is not injective.
If a set R satisﬁes tightly the R-reconstruction property we
will also say that R is a set of reduction functions.
In the following the elements of J used to index the
functions in R will be called reduction parameters.
Remark IV.1
As anticipated, Deﬁnition 1 is a formal way to say that if (1) is
a set of reduction functions, then it must be possible to recover
x ∈ B from the knowledge of any R-pla of reduced versions
fa1(x), . . . , faR(x). The condition of tight reconstruction helps
in avoiding pathological cases that satisfy the R-reconstruction
property but operates no reduction at all (e.g., when all the
functions in R are the identity function).
Since the idea of a set of reduction functions can seem
a bit abstract and it can not be clear if a set of reduction
functions exists at all, it is worth to give an example based
on Reed-Solomon codes and used in PPETP with the name of
Vandermonde reduction proﬁle [26].
Example IV.1
Let d > 0 be an integer and let F2d denote the Galois ﬁeld with
2d elements. Galois ﬁeld F2d will be used both as the reduction
parameters set J and for computation.
The function fc : B → B associated with reduction parameter
c ∈ F2d is computed as follows. Let x be the argument of fc, let
rc
def
=

1
c
c2
···
cR−1 
(3)
be the R-dimensional row vector in FR
2d whose components are
powers of c and let Cx be the R-row matrix with entries in F2d
by considering every d-ple of bits of x as an element of F2d (if
the number of bits of the packet is not an integer multiple of
dR, the packet is ﬁrst suitably padded, see [26] for details). The
value of fc(x) is
fc(x) = rcCx
(4)
(Note that in (4) we did a notational abuse, since the value of
fc(x) should be a bit-string, while the right hand side of (4) is
a vector of elements of F2d.)
In order to see that the set of functions fc is actually a set of
reduction functions with reduction factor R, observe that from
the knowledge of fc1(x), . . . , fcR(x) one can recover C by solving
the linear system


fc1(x)
fc2(x)
...
fcR(x)

 =


rc1
rc2
...
rcR

Cx =


1
c1
···
cR−1
1
1
c2
···
cR−1
2
...
...
...
1
cR
···
cR−1
R


|
{z
}
R
Cx
(5)
Since matrix R in (5) is a Vandermonde matrix, it is invertible
(and (5) has a solution) as soon as all the ck are different.
Remark IV.2
Although the approach in Example IV.1 is well known, many
other sets of reduction functions can be constructed; see, for
example, [27].
By exploiting the idea of reduction functions, nodes of a
PPETP network propagate the streamed data as follows
• At start-up
1) Each node chooses one or more reduction param-
eters a1, a2, .... Although the parameter(s) can
161
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

be imposed by an external network coordinator, if
the parameter space is large enough, the nodes can
choose them at random, simplifying the network
management. See Section V-B.
2) Contact Nup ≥ R upper peers. Each upper peer will
communicate to the node its reduction parameter
before starting streaming.
• For every content packet
1) Wait for at least R different reduced packets
2) After receiving at least R reduced packets, recover
the content packet
3) Move the content packet to the application level
4) Reduce the content packet using the chosen reduc-
tion parameters a1, a2, . .. .
5) Send the computed reduced packets to your lower
peers
Note that if, because of packet losses, the node receives less
than R reduced versions of the content packet, the node can
still help in propagating the information by forwarding to its
lower peers the reduced data received from the upper peers. We
call this (almost obvious) strategy fragment propagation and
it will be shown in the following that, despite of its simplicity,
it is important for system performance.
Remark IV.3
The strategy of fragment propagation can help in solving a
problem that is intrinsic to the P2P network of residential nodes.
If a residential node has the upload bandwidth smaller than
the content bandwidth, it introduces a “bandwidth debt” since
it cannot compensate the consumed download bandwidth with
an equal upload bandwidth. Such a debt must be covered by
other nodes such as super-nodes or by the origin server. Since
the bandwidth debt can be expected to grow linearly with the
number of residential nodes, this problem can challenge the
scalability of the P2P network.
The use of reduction functions and fragment propagation can
help in counteracting this problem. A residential node can act as
a “repeater” (maybe in exchange of some improved service) by
simply joining the network and contacting only one upper peer,
but accepting Nlow > 1 lower peers. Automatically, because of
the fragment propagation policy, it will forward to its lower peers
the packets received from the upper peer. The overall effect is
a “bandwidth gain” equal to Nlow −1 > 0 reduced streams that
compensates the debt of other nodes.
A. Data puncturing
In the case of high quality content (that requires a large
bandwidth) and a network with low upload bandwidth nodes,
it could happen that the required reduction factor R is too large
(the drawbacks of a too large reduction factor will become
clear in the following). In this case PPETP can reduce the
upload bandwidth by puncturing the stream of fragments.
Puncturing can be both probabilistic or deterministic. In the
former case, the packets to be sent are chosen randomly with
a given probability, in the latter case the packets are chosen
according to a pattern that is periodically repeated (e.g., send
only the even packets). For example, Fig. 3a shows a node
with ﬁve upper peers, where two peers (nodes C and D) apply
a 1:2 puncturing to the data stream, node C sending only even
packets and D only odd ones. It is clear that the scheme of
Fig. 3a is approximately equivalent to the scheme of Fig. 3b,
where the two puncturing nodes are “merged” in a “virtual”
no puncturing node.
V. PROPERTIES OF DATA REDUCTION
In this section we discuss few interesting properties due
to the use of data reduction schemes. It is interesting to
observe that the properties discussed in this and the following
sections do not depend on the actual functions fa, but only
on their property of being reduction functions. Therefore, the
properties discussed here hold not only for the Vandermonde
scheme of Example IV.1, but also for any other reduction
scheme that enjoys the R-reduction property.
A. Solution to the asymmetric bandwidth problem
This property is almost obvious, but it is included here for
the sake of completeness. Since the bit-string associated with
the size of the reduced packet is R smaller than the size of the
content packet, the bandwidth required by the reduced stream
is R times smaller. By choosing R large enough, even the nodes
with small upload bandwidth can contribute to propagating the
content.
B. Distributed assignment of the reduction function
A ﬁrst interesting property is that if the set of reduction
parameters J is large enough, each node can choose its
parameter at random, since the probability of having two
nodes with the same reduction parameter is negligible. This
simpliﬁes the assignation of the reduction parameters to the
nodes, since a central authority is not required.
Remark V.1
Note that there is no computational overhead in choosing |J|
large, since J represents the “pool” from which reduction
functions are chosen, that can be much larger than the number of
generated reduction packets. For example, in the PPETP specs
[26] |J| = 232 although R can be expected to be at most ≈ 20.
In order to be more quantitative, let S = |J| be the cardinality
of the reduction parameter set J, let Nup be the number of
upper peers of a given node and let ak be the reduction
parameter of the k-th upper peer, k = 1,...,Nup. The node is
able to recover the content stream if and only if there are least
R different values of ak. Fig. 4 shows the probability Pfail that
this does not happen as a function of S, the reduction factor R
and the ratio ρ = Nup/R (interpretable as a redundancy factor).
It is clear from Fig. 4 that one can achieve negligible Pfail by
using J of reasonable size and small redundancy factors. The
curves in Fig. 4 have been obtained by means of the numerical
procedure described in Appendix A where it is also shown that
Pfail goes to zero with Nup as
[(R−1)/S]Nup = [(R−1)/S]ρR
(6)
By means of standard analysis techniques, it is possible to
show that (6), as a function of R, has a single minimum at
R ≈ 1+S/e. Since S is typically very large (for example, S =
216 if F216 is used in the reduction scheme of Example IV.1),
162
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

(a)
(b)
Figure 3.
(a) Node N has ﬁve upper peers, with two upper peers (C and D) applying a puncturing 1:2. (b) Network equivalent to the network in (a) with a
“virtual” upper peer obtained by merging nodes C and D.
1
1.1
1.2
1.3
1.4
1.5
10
−12
10
−10
10
−8
10
−6
10
−4
10
−2
10
0
ρ=Nup /R
Pfail
S=28 ,   R=10
S=28 ,   R=20
S=28,   R=40
S=216, R=10
S=216, R=20
S=216, R=40
Figure 4. Probability Pfail of having less than R different reduction parameters
out of Nup vs. redundancy ratio ρ = Nup/R for different values of S = |J| and
R.
it follows that (6) decreases monotonically with R in every
case of practical interest. Moreover, since the minimum of (6)
is very low when S is large, it follows that, ﬁxed ρ, one can
make Pfail as small as desired by taking R large enough.
C. Robustness with respect to packet loss
The scheme is inherently robust with respect to packet
losses, typically due to peer departures and network conges-
tion. Actually, a node that contacts Nup > R upper peers will
be able to recover the transmitted data as long as not more
than Nup − R packets are lost. The effect of packet losses is
discussed in more detail in Section VI.
D. Robustness with respect to churn
An important problem in P2P streaming network is that a
node can leave at anytime, leaving its lower peers without
data. The fact that in a network made of residential users one
can expect a high churn is one of the reasons that support the
use of mesh-based chunky solutions. However, in PPETP the
same redundancy that protects against packet losses protects
also against the effect of churn. This is discussed in more
detail in Section VII.
E. Robustness to stream poisoning
As said above, a possible attack is the injection of “garbage
packets.” The use of reduction functions offers a simple way
to counteract such a threat. Actually, it sufﬁces to contact
Nup > R upper peers, use R reduced versions to recover the
original data and check that the result is coherent with the
remaining reduced packets. More precisely, let uk denote the
packet received by the k-th upper peer, let ak denote the
corresponding reduction parameter and let a = [a1,...,aR] and
suppose that at most Nup −R−1 packets uk can be corrupted.
In order to recover x safely, the node chooses R reduced
packets uk1, ..., ukR, recovers the content packet as x =
g−1
a (uk1,...,ukR) and checks the result by verifying that the
following equalities hold
ukℓ = fαkℓ(x),
ℓ = R+1,...,Nup
(7)
The following cases may happen
1) All the equalities (7) are veriﬁed. In this case x is
correctly recovered and every peer sent us a correct
packet.
2) Some of the equalities (7) are veriﬁed, but not all. In
this case x is still correctly recovered, but the peers
corresponding to the non veriﬁed equalities sent us a
corrupted packet.
3) All the equalities (7) are not satisﬁed. Since we supposed
that at most Nup − R − 1 packets uk can be corrupted,
this can happen only if we used a corrupted packet in
recovering x. In this case we can choose a different set
163
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

of uk and try to recover x again. If only one corrupted
packet is present, the expected number of trials before x
is recovered is Nup/(Nup −R). If the recovering of x has
already been attempted too many times, one can declare
the packet lost and let the application conceal the loss.
The procedure described above can be considered as a
generalization of the use of error correcting codes. However,
in this case data are not corrupted by a noisy channel, but
by a malicious attacker that could, in principle, send carefully
crafted data that cause the node to recover garbage data that
nevertheless passes the test above. Therefore, the question is:
can an attacker craft a corrupted packet ˆuk that produces a
wrong packet ˆx ̸= x that satisﬁes the test above? What about
a coordinated attack by A peers? We are going to show that if
Nup ≥ R+A, the system is immune from a coordinated attack
by A peers.
To be more precise, let x be the original content packet and
suppose a given node receives data from Nup > R peers. Let
uk = fak(x) be the reduced packet that the node should receive
from peer k and let ˆuk be the actual received packet. Since we
are supposing that no more than A peers will try a coordinated
attack, we know that there are at most A values of k such that
ˆuk ̸= uk.
The packet recovered by the node is ˆx = ga( ˆu1,..., ˆuR) and
the node accepts it if all the following equalities hold
faℓ(ˆx) = ˆuℓ,
ℓ = R+1,...,Nup.
(8)
We can say that the attack succeeds if ˆx ̸= x and the node
accepts ˆx. The following theorem shows that a coordinated
attack by A peers fails if Nup ≥ A+R.
Theorem 1. Let x ∈ B, let a1,...,aR+A ∈ J, and let uk =
fak(x), k = 1,...,R+A. Let ˆuk ∈ B, k = 1,...,R+A be such
that ˆuk ̸= uk for at most A values of k. Let a = [a1,...,aR] and
deﬁne
ˆx
def
= g−1
a ( ˆu1,..., ˆuR)
(9)
The following equalities hold
faℓ(ˆx) = ˆuℓ,
ℓ = R+1,...,R+A
(10)
if and only if x = ˆx.
Proof: As a ﬁrst step, we show that ˆx satisﬁes fak(ˆx) =
ˆuk for all the k = 1,...,R + A. Indeed, such an equality is
satisﬁed for k ≤ R because of deﬁnition (9) and it is satisﬁed
for k > R because of (10). By hypothesis, there are at least R
integers n1,n2,...,nR ∈ {1,...,R+A} such that unk = ˆunk. Let
a = [an1,...,anR] and observe that
ga(ˆx) = [fan1(ˆx),..., fanR (ˆx)]
= [ ˆun1,..., ˆunR] = [un1,...,unR]
= [ fan1(x),..., fanR (x)] = ga(x)
(11)
By Deﬁnition 1, (11) holds only if x = ˆx.
0
20
40
60
80
100
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
N
Jitter [normalized]
 
 
R=N   /5
up
R=N   /4
up
R=N   /2
up
R=(7/10) Nup
R=  (3/4) Nup
Figure 5.
Jitter as a function of N (peer delays distributed as Gaussian with
unit variance)
F. Jitter reduction
A nice side effect of the use of network coding in PPETP
is, as reported in [28], the reduction of the jitter observed
by the node. Intuitively, this happens because the time when
a content packet is recovered is the time necessary for the
arrival of the R fastest packets out of Nup. Fig. 5, taken from
[28], shows the theoretical prediction of the jitter (i.e., the
standard deviation of the reconstruction time), as a function
of R and Nup, when the delays are Gaussian with variance σ2.
The values on the vertical axis are measured in units of σ.
Note that the jitter decays as 1/pNup [29]. This behavior was
also veriﬁed experimentally [28].
G. Computational cost
It is convenient to analyze brieﬂy the cost of the com-
putation due to the reconstruction and reduction with the
Vandermonde proﬁle, in order to get an estimate of how that
cost depends on the design parameters (R, d and Nup).
Let Q be the size (in bits) of a content packet. If we
work with the Galois ﬁeld F2d, the matrix corresponding to
the packet will have Q/d entries organized in R rows and
Q/(dR) columns (for the sake of notational simplicity, we are
supposing that Q is an integer multiple of dR). Let C+(d) and
C×(d) be the “cost” associated with, respectively, a sum and
a product in F2d. As the unit of measure of the cost, we will
take the time required to do a 32-bit XOR that corresponds to
a sum in F232 and that is implemented with a single instruction
on modern microprocessors.
The reconstruction step requires a product between a R×R
matrix (the inverse of the Vandermonde matrix) and the
R × Q/(dR) matrix obtained by stacking the row vectors
corresponding to the reduced packets. Such a matrix product
requires
R·R·Q/(dR) = RQ/d
products
(12a)
R·(R−1)·Q/(dR) ≈ RQ/d
sums
(12b)
The reduction step requires the product of the 1×R reduction
vector by the R×Q/(dR) matrix corresponding to the content
164
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

packet. This requires
1·R·Q/(dR) = Q/d
products
(13a)
1·(R−1)·Q/(dR) ≈ Q/d
sums
(13b)
Therefore, the overall computational cost per a Q-bit packet
is
C+(d)+C×(d)
d
(1+R)Q = C(1+R)Q
(14)
where C = (C+(d)+C×(d))/d can be interpreted as a “com-
putational cost per bit” due to the operations on the Galois
ﬁeld. If B is the content bit-rate in bit/s, we need to process
a packet every Q/B seconds, so that we have a computational
load equivalent to
C(1+R)Q
Q/B
= C(1+R)B
32-bit XOR/s
(15)
Note that the computational cost grows linearly with the
reduction factor.
1) Cost of the operations in F2d: It is clear that the
term C = (C+(d)+C×(d))/d depends on the algorithm used
for implementing the Galois operations and on the speciﬁc
architecture. Nevertheless, in order to have a grasp on the
dependence of this term on d, we carried out few experiments.
We considered the following possible implementations for
a product in F2d
Long product
The product in F2d is done with an algorithm similar
to the integer product algorithm.
Logarithm table
If 2d is not too large (say, up to d = 16), one can
exploit the possibility of deﬁning a logarithm in F2d
and do the product using a “logarithm table.”
Pythagorean table
If d is quite small (say, up to d = 8), one can do
the product using a Pythagorean table that stores the
product for every possible pair of values.
Kronecker via Pythagorean table
If d is very small, (e.g., d = 4) one can use the
Pythagorean table approach to compute more than
one product at once. For example, if d = 4, a =
[a1,a2] ∈ F2
24 and b = [b1,b2] ∈ F2
24, one can compute
the Kronecker product a⊗b = [a1b1,a2b1,a1b2,a2b2]
by concatenating a1,a2,b1 and b2 and using the
resulting 16-bit index to access a look-up table with
the entries of a ⊗ b. The cost of this approach is
comparable with the cost of the Pythagorean table
approach, but it allows to compute four products at
once. An example of this approach can be seen in
Fig. 10.a (in assembler) and in Fig. 11 (in C) in
Appendix A.
We implemented (in Assembler, in order to avoid the inﬂuence
of compiler optimizations) the product algorithms described
above for d = 4,8,16 and 32. The source code (with the syntax
of the GNU assembler [30] of the implemented procedures is
reported in Appendix A, Fig. 10. The time required by those
Table I
APPROXIMATE RELATIVE COMPUTATIONAL COST C×(d) OF THE
PRODUCTS AND COST PER BIT C IN DIFFERENT GALOIS FIELD. THE
UNITARY RELATIVE COST IS A 32-BIT XOR.
Field
C×(d)
Cost per bit C
Memory
Notes
F24
0.5
1.5/4 = 0.375
128 K
Kronecker
F28
1
2/8 = 0.250
64 K
Pythagorean table
F216
3.5
4.5/16 = 0.281
256 K
Logarithm table
F232
20
21/32 = 0.656
0
Long product
procedure has been measured by means of the RDTSC (ReaD
Time Stamp Counter), an instruction of x86 processors that
allows to obtain the value of the Time Stamp Counter, a 64-
bit register increased at each clock cycle. [31]. Note that the
programs in Fig. 10 do not include, for the sake of space,
side-code such as parameter handling code. The complete set
of sources is available, upon request, from the author.
The results of such measurements can be seen in Table I
that shows the relative complexity of the product in F2d and
the corresponding “cost per bit” C for some values of d, where
the computational cost is measured, as anticipated, relatively to
the computational cost of a 32-bit XOR. It is worth observing
that the overall cost per bit does not change much with the
size of the Galois ﬁeld, with the most expensive ﬁeld being
F232.
Remark V.2
It is worth observing that the algorithms chosen for the exper-
iments and the representation used for the elements of F2d are
not the only possible. The choice of the “best” representation
of elements of F2d and of the “best” algorithms can be done
only once the architecture has been chosen since, especially with
procedures as short as the ones presented here, details such as
the internal structure of the processor, memory alignment, cache,
and maybe others can play a non-negligible role. Therefore, the
complexity ﬁgures given in this section should be taken only as
planning ﬁgures.
H. Information obfuscation
The reduction procedure described in Example IV.1 has
some similarity with the secret sharing technique of Shamir
[32]. This suggests that one could use it to add some protection
to the transmitted content. In order to simplify the discussion,
we need a new deﬁnition.
Deﬁnition 2. We will say that a reduction scheme with
reduction factor R achieves k-secrecy if, given
• A positive integer K
• Any k-ple of K-dimensional row vectors (representing
reduced packets) uc1, ..., uck ∈ FK
2d
• Any content packet C with R rows and K columns,
it is possible to ﬁnd R−k reduced packets uck+1 ucR ∈ FK
2d so
that the content packet recovered from the whole set of reduced
packets uc1, ..., ucR is C.
Deﬁnition 2 formalizes the idea that, if k-secrecy is
achieved, an opponent that gets to know no more than k
reduced packets, cannot deduce anything about the original
content packet since any content packet can give rise to (“is
165
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

compatible with”) the sequence of eavesdropped packets uc1,
. . . , uck. Note that the reduction scheme in Example IV.1 does
not achieve even 1-secrecy since, given any reduced packet,
there are many content packets that are not compatible with
it.
We want to show how the scheme in Example IV.1 can be
modiﬁed to obtain 1-secrecy. Let K be the number of columns
of C and let ηt ∈ FK
2d a random row vector whose entries are
iid and uniformly distributed over F2d. Use η to extend C to
obtain
bC def
=

C
η

(16)
Now reduce matrix (16) using, of course, a reduction vector
with R+1 columns, that is,
ˆu = [1,c,...,cR]bC = rcC+cRη
(17)
Suppose now that an eavesdropper gets to know the reduced
version ˆu; we claim that the eavesdropper cannot deduce
anything about C. The reason is that for every choice of C
one can ﬁnd η such that (17) is satisﬁed, indeed
η = c−R(ˆu−rcC)
(18)
where c−R makes sense since c is a non-null element of F2d.
We have achieved 1-secrecy. It is easy to prove that k-secrecy
can be achieved by extending C with a k-row random matrix.
Remark V.3
Although this technique seems to be speciﬁc for the Vander-
monde reduction procedure, it can be extended to a more general
case, as shown in [27], where it is also shown that a slightly
stronger form of k-secrecy is achieved, that is, that the mutual
information [33] between the content packet C and the reduced
value ˆu is zero.
The advantage of this technique with respect to usual
cryptography is that it does not require any key distribution,
the drawbacks are an increased bandwidth (the reduced packets
have the same dimension, but now a node must receive at
least R + k reduced packets instead of R) and the fact that
an adversary that can get all the needed reduced packets can
recover the content. If those drawbacks are compensated by
the simpliﬁcation due to the fact that no key distribution is
necessary, depends on the applicative context.
VI. PACKET LOSS PROBABILITY
The current version of PPETP runs over UDP that, as well
known, is an unreliable protocol. This means that a fragment
sent to a lower peer could not reach its destination. It is
clear that the probability that a given peer reconstructs a
packet is a complex function of the packet loss probability and
network structure. It is also clear that it is important to have
an estimate, as precise as possible, of the overall packet loss
probability experienced by a node. In this section we present
some preliminary results about this topic.
A. Network model
A PPETP network can be represented by a Direct Acyclic
Graph (DAG) where edges link each node to its lower peers,
and where the server(s) is (are), clearly, the node(s) that do not
have any upper peer. For the sake of notational simplicity, we
will suppose that every link is an erasure channel that drops
packets with probability Pℓ.
We associate with each node n of the network the random
variable Wn deﬁned by the following experiment. We let the
server(s) send to the network a single content packet, and we
let Wn ∈ {0,1,...,Nup} be the number of fragments received
by node n. From the knowledge of the statistical properties of
Wn, it is possible to determine several values of interest. For
example, the packet loss probability Peq seen by the application
can be computed as Peq = P[Wn < R].
As explained in paragraph IV, a node sends reduced packets
to its lower peers if it receives at least T reduced packets,
where T = 1 if fragment propagation is employed and T = R
otherwise. If node n received at least T reduced packets (i.e.,
if Wn ≥ T) we will say that the node is active or in ﬁring state.
We will deﬁne the random variable Fn to be equal to 1 if node
n is in ﬁring state and 0 otherwise.
1) Network topology: A difﬁculty in studying the behaviour
of the abstract P2P system considered here is that the statistical
properties of Wn depend on the network topology, a character-
istic that it is not easily captured by a small set of parameters.
In order to simplify the study, it is convenient to put some
constraint on the topology.
A useful constraint that nevertheless is general enough to
describe practical networks is the hypothesis of limited spread.
Let n be a node of the network, consider the lengths of the
paths joining n with the server (since the network is a DAG
there is a ﬁnite number of paths joining n with the server)
and deﬁne d(n) and D(n) ≥ d(n) as the minimum and the
maximum of these lengths. Value D(n) will be called the
depth of node n, and difference D(n) − d(n) will be called
the spread of n. The network will be said to have ∆-limited
spread if D(n) − d(n) ≤ ∆ for every node n. The hypothesis
of limited spread is quite natural and it is expected that this
type of networks will be the natural outcome of the tentative
of maximizing locality.
In this paper, we consider a special case of limited spread
networks, namely, stratiﬁed networks; we use the term strat-
iﬁed to avoid confusion with the term layered possibly used
in other contexts. In a stratiﬁed network, the nodes can be
partitioned into sets (strata) LK, K ∈ N, such that all the
upper peers of a node in LK belong to LK−1. It is easy to
verify that a network is stratiﬁed if and only if it has 0-
limited spread and that the stratum index coincides with the
node depth. Fig. 2 shows few examples of stratiﬁed networks,
namely a tree network, a network made of parallel trees and
an “onion skin” network. (Onion skin networks are interesting
because the ratio of non-streaming nodes goes to zero when
the network size goes to inﬁnity.)
166
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

B. Notation
In this section we will consider Markov chains with a ﬁnite
alphabet. We will use → to denote a one-step reachability
relation, that is, we will write a → b if the chain can transition
from a to b in one step. We will use a →n b if there is a path of
length n from a to b and a →∗ b if there is a path of any length
from a to b. If the Markov chain is homogeneous, we will use
the shorthand P(a → b1 → b2 → ···bN) to denote P[sn+N =
bN,...,sn+1 = b1|sn = a]. Note that this notation factorizes,
that is, P(a → b → c) = P(a → b)P(b → c).
1) Notation for stratiﬁed networks: We will denote with
LK the number of nodes in stratum K. The n-th node in
stratum K, n = 0,...,LK − 1, will be named as (K,n). The
set of upper peers of (K,n) will be represented by the vector
uK,n ∈ {0,1}LK−1 whose m-th component is 1 if (K −1,m) is
an upper peer of (K,n) and zero otherwise.
We will collect all the random variables WK,n and FK,n,
relative to nodes of stratum K, in two vectors WK and FK
deﬁned as
[WK]n = WK,n
;
[FK]n = FK,n
(19)
Note that FK ∈ {0,1}LK. It will prove useful to have a special
notation for some states in {0,1}LK. More precisely, we will
deﬁne the empty state as φ = [0,0,...,0] (no node in active
state), the full state as Ω = [1,1,...,1] (every node in active
state) and, for every k ∈ {0,...,LK − 1}, the k-th singleton
state, ek as [ek]n = δk,n (only the k-th node is active).
C. Equivalent loss probability
Consider a node (K,n) in stratum K and consider the
following experiment: the origin server sends a content packet
over the network and we check if node (K,n) recovers the
content packet or not. Our goal is to obtain a bound to the
equivalent loss probability Peq, that is, the probability that the
node does not recover the packet. It will be more convenient,
from a notation point of view, to bound the probability of the
complementary event 1−Peq.
Property 1. The following bound holds
1−Peq ≥ ηλ ∑K
n=1 Ln
(20)
where
η
=
P[B(Nup,PT) ≥ R]
(21a)
λ
=
P[B(Nup,PT) ≥ T]
(21b)
and B(Nup,PT) in (21) is a binomial random variable with
Nup trials and success probability PT.
The proof of Property 1 is given in Appendix B.
Remark VI.1
Note that if fragment propagation is employed, T = 1 and (21b)
can be written as
λ = 1−PNup
ℓ
(22)
Bound (20) decays exponentially with the number of peers
in the network (∑K−1
n=1 Ln is the number of peers in the strata
above stratum K), so it would seem not a very good bound.
However, note that since the empty state φ is absorbing (that is,
when a stratum reaches φ every successive strata will remain
in φ), a well-known results on Markov chains implies that the
probability of the empty state goes to 1 when the number of
strata goes to inﬁnity, so that the probability of reconstruction
must converge to zero. Therefore, any lower bound of such a
probability must converge to zero, too.
It is worth considering a simple numerical example, in order
to understand better bound (20) and the difference between
using or not fragment propagation. Suppose, for the sake of
this example, that Pℓ = 0.1, that every node has Nup = 10 upper
peers, that the reduction factor is R = 6 and that every stratum
has L = 100 nodes.
If fragment propagation is employed, according to (22)
λ = 1−PNup
ℓ
= 1−10−10
(23)
Suppose we want to ﬁnd M = ∑K−1
n=1 Ln such that term λ M
becomes equal to 0.999. It is
M =
log10 0.999
log10(1−10−10) = −4·10−4
−4·10−11 = 107
(24)
that corresponds to 105 strata if every stratum has 100 nodes.
That is, although the bound (20) goes to zero when the network
size goes to inﬁnity, the decay is slow enough to be negligible
for all but very large networks.
If no fragment propagation is employed, the value of λ is
λ = P[B(10,0.9) ≥ 5] ≈ 1−1.410−4
(25)
Note that without fragment propagation, the term λ M becomes
smaller than 0.999 already with M = 7. Although (20) is only
a lower bound, it suggests that convergence to the empty state
can be very fast if fragment propagation is not used.
It is also worth observing that while the value of λ without
fragment propagation depends on the redundancy ρ = Nup/R
(we had to use ρ = 2 in (25) in order to get a fairly large value
for λ), the value of λ without fragment propagation depends
only on Nup and we can obtain values of λ very close to 1
even with ρ small.
D. Repeated fragments
Note that in the proof of Property 1 it was implicitly
assumed that the fragments received by the node were all
different and one could wonder how much this hypothesis is
true in a real case. This section is devoted to the discussion
of this hypothesis.
First observe that, according to the results of Section V-B,
we can safely assume that the reduction parameters chosen by
the upper peers of a given node are different one another as
soon as the number |J| of reduction parameters is large enough.
Moreover, if the network is not too large we can assume that
the reduction parameters chosen by all the the ancestors of a
given node are different.
Therefore, if the number of reduction parameters is suf-
ﬁciently large with respect to the network size, if a node
receives the same fragment twice, both fragments must have
been originated by a single node. This happens, for example,
167
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 6.
Example of a duplicated fragment event: both nodes B and C
receive only the fragment from A and forward it to node N.
in the case of the diamond shown in Fig. 6 where node A
sends a fragment to nodes B and C, both upper peers of N.
If both B and C receives less than R fragments, it is possible
that they both send to N the fragment received from A. Note
that if Nup and R are suitably chosen, the probability that this
happens is very small since it is necessary (but not sufﬁcient)
that both B and C cannot recover the corresponding content
packet.
Since the problem of having an estimate of the event of
duplicated fragment is still open, we decided to validate the
effect of the hypothesis of no duplicated fragment by carrying
out some simulations reported in Section VI-E.
E. Experimental results
We carried out some simulations in order to verify the
theoretical results above and to asset the importance of the
hypothesis of no duplicated fragment in a real case. For every
choice of parameters Pℓ, R, Nup we generated 20 random
networks with 15 nodes per stratum, each node with Nup upper
peers. Over each network we sent 1000 content packets and
measured the probability (averaged over all the networks) that
a node of a given stratum is able to recover the content packet.
We carried out the simulations both with and without the
fragment propagation policy. For each fragment we tracked
its reduction parameter, therefore taking into account in the
simulation the event of duplicated fragments. When a node is
not able to recover the content packet, it selects one of the
received fragments at random and forwards that to the lower
peers.
According to the theoretical results described in Sec-
tion VI-C we make the following predictions
• In the case with fragment propagation, with PNup
ℓ
small,
we expect Peq approximately equal to the loss probability
experienced when protecting packets sent over a channel
with erasure probability Pℓ using a (Nup,R) code, practi-
cally independent on the stratum number.
• In the case without fragment propagation we expect a Peq
that converges very rapidly to 1.
Fig. 7 shows, on a logarithmic scale, the probability of
packet recovery 1 − Peq as a function of the stratum number
for the cases Pℓ = 0.2, Nup = 13, redundancy factor R equal
10-4
10-3
10-2
10-1
100
5
5.5
6
6.5
7
7.5
8
8.5
9
Figure 8.
Comparison between the measured Peq and the theoretical
prediction for Pℓ = 0.3, Nup = 13 and R ∈ {6,7,8,9}.
to 7 (ﬁrst row), 8 (second row) and 9 (third row), with and
without fragment propagation (left and right hand column,
respectively). Observe that the probability remains approxi-
mately constant for all the cases with fragment propagation,
while it decreases rapidly when fragment propagation is not
employed. Note the reduced stratum range for ﬁgures Fig. 7b2
and Fig. 7c2; if we used the same range of the other ﬁgures,
the curve would have looked like a vertical line. Note also
that although in the case of Fig. 7a2 the probability does not
decay as fast as in the other two ﬁgures of the same column,
the decay is perceptible, while it is practically invisible in
the three ﬁgures of the ﬁrst column, relative to the fragment
propagation case.
Fig. 8 compares the measured equivalent packet loss proba-
bility Peq (averaged over all the strata) in the case of fragment
propagation with the probability of not receiving at least
R ∈ {6,7,8,9} packets out of Nup = 13 with a loss probability
equal to Pℓ = 0.3. The match between theory and experiment is
very good, the relatively large disagreement for R = 6 is due to
the fact that the number of iterations (1000×20) is relatively
small with respect to the expected value of Peq (≈ 10−3).
VII. ROBUSTNESS AGAINST CHURN
An important problem in P2P streaming network is that a
node can leave at any time, leaving its lower peers without
data. The “turbulence” in the network induced by the random
leaving of peers is called churn. Protecting a P2P streaming
system from the effect of churn is a major goal in P2P
system design. The effect of churn on PPETP was originally
analyzed in [34]. In this section after recalling, for the sake of
completeness, some results from [34], we simplify the results
of [34] by giving some bounds that can make the design of a
PPETP network easier.
Consider a network where each node is supposed to have
Nup upper peers and let H(t) ∈ {0,...,Nup} denote the actual
number of upper peers of a given node at time t. Note that H(t)
168
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

0
200
400
600
800
1000
1200
−0.5
−0.45
−0.4
−0.35
−0.3
−0.25
−0.2
−0.15
−0.1
−0.05
0
Stratum
log10(1−Peq)
0
200
400
600
800
1000
1200
−0.5
−0.45
−0.4
−0.35
−0.3
−0.25
−0.2
−0.15
−0.1
−0.05
0
Stratum
log10(1−Peq)
(a1)
(a2)
0
200
400
600
800
1000
1200
−0.5
−0.45
−0.4
−0.35
−0.3
−0.25
−0.2
−0.15
−0.1
−0.05
0
Stratum
log10(1−Peq)
0
20
40
60
80
100
−5
−4.5
−4
−3.5
−3
−2.5
−2
−1.5
−1
−0.5
0
Stratum
log10(1−Peq)
(b1)
(b2)
0
200
400
600
800
1000
1200
−0.7
−0.6
−0.5
−0.4
−0.3
−0.2
−0.1
0
Stratum
log10(1−Peq)
0
2
4
6
8
10
12
−5
−4.5
−4
−3.5
−3
−2.5
−2
−1.5
−1
−0.5
0
Stratum
log10(1−Peq)
(c1)
(c2)
Figure 7.
Probability of content packet recovery as function of the stratum number. All the plots are relative to Pℓ = 0.2 and Nup = 13. (a1) R = 7, with
fragment propagation; (a2) R = 7, without fragment propagation; (a1) R = 8, with fragment propagation; (b2) R = 8, without fragment propagation; (a1) R = 9,
with fragment propagation; (c2) R = 9, without fragment propagation. Plots (b2) and (c2) have a reduced range on the x axis since otherwise the plot would
have looked as a vertical line.
169
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

can be smaller than Nup, for example, after some upper peer
leaves. Note that if H(t) < R the node cannot receive enough
reduced packets to recover the content. We will call this event
an underﬂow event and we will denote its probability as Punder.
In [34] probability Punder is computed as a function of R
and Nup supposing that
1) The search of a new peer requires a time that can
be described by an exponential random variable, with
appropriate parameter λ. The average 1/λ is typically
in the order of a few seconds or fraction of seconds.
2) The time a peer remains connected can be described by
an appropriate distribution. with average 1/µ. Typical
values of 1/µ are in the order of at least several minutes.
Note that we do not suppose the distribution exponential
since some results in [7] show that distributions other
than exponential model can be more appropriate.
According to [34], Punder can be written as
Punder = P[H(t) < R] = ∑R−1
n=0
γn
n!
∑
Nup
n=0
γn
n!
(26)
where γ = λ/µ. Note that in a typical case one can expect γ
to be quite large, at least of the order of few hundreds, even
thousands.
The formula above, albeit exact, can be inconvenient to use
for design purposes. In the following we are going to give an
upper bound to probability (26) that holds for large values of
γ and depends on γ, R and Nup in a more intuitive way. The
upper bound we are going to present is not in [34] and it is
published here for the ﬁrst time. We will need the following
lemma that allows us to upper bound the sums in (26) with a
single term as soon as γ is large enough.
Lemma 1. For every M ∈ N and γ > 2(M −1) the following
inequalities hold
γM
M! <
M
∑
n=0
γn
n! < 2γM
M!
(27)
Proof: The following equality is well-known
M
∑
n=0
γn
n! = eγ Γ(M +1,γ)
M!
(28)
where Γ(M +1,γ) is the incomplete gamma function. In [35]
it is shown that for a > 1, B > 1 and x > (a−1)B/(B−1) the
following inequalities hold
xa−1e−x < Γ(a,x) < Bxa−1e−x
(29)
Using inequalities (29) in (28) with a = M + 1, B = 2 and
x = γ > (a−1)B/(B−1) = 2M, it follows
eγ(γMe−γ)
M!
< eγ Γ(M +1,γ)
M!
< eγ(2γMe−γ)
M!
(30)
From (30) the thesis follows.
We will give the upper bound in the speciﬁc case of Nup ≤
2R. The more general case is not much more difﬁcult, but it
gives rise to more complex expressions that partially spoil the
0
5
10
15
20
−35
−30
−25
−20
−15
−10
−5
0
R
log10(Punder)
γ=500
 
 
ρ=1.5
ρ=1.05
Figure 9.
Upper bound to the underﬂow probability Punder for γ = 500, and
ρ = 1.05 (the upper curve) and ρ = 1.5 (the lower curve).
simpliﬁcation introduced by the upper bound. Note that the
hypothesis Nup ≤ 2R is quite reasonable since it seems very
unlikely to have the necessity of a number of upper peers that
is more than twice the minimum.
Property 2. If Nup ≤ 2R and γ > 2(R−1), then the underﬂow
probability Punder can be upper bounded as
Punder ≤ 2
Nup
γ
Nup−R+1
(31)
Proof: From Lemma 1 with M = R − 1, it follows that
when γ > 2(R−1),
Punder = ∑R−1
n=0(γn/n!)
∑
Nup
n=0(γn/n!)
≤ ∑R−1
n=0(γn/n!)
γNup/Nup!
≤ 2γR−1/(R−1)!
γNup/Nup!
(32)
By observing that
γR−1/(R−1)!
γNup/Nup!
= γR−Nup−1R···Nup
≤ γR−Nup−1NNup−R+1
up
=
Nup
γ
Nup−R+1
(33)
the thesis follows.
Note that since in a practical case γ will be of the order of
many hundreds, while Nup is expected to be at most around
ten, from Property 2 one can deduce that one can make Punder
very small with a small number of excess peers Nup −R. Fig. 9
show two bounds for γ = 500, and ρ = 1.05 (the upper curve)
and ρ = 1.5 (the lower curve).
VIII. DESIGN GUIDELINES
The procedure for designing a PPETP network depends,
of course, on the speciﬁc application and the corresponding
ﬁgures of merit of interest. In this section we give some
guidelines that can be useful in designing a PPETP network in
170
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

what can be expected to be a fairly common setup. Of course
all the characteristics considered so far (e.g., robustness to
packet loss, jitter, computational complexity, efﬁciency, ...)
are interrelated one another and the trade-off between them
will depend on the speciﬁc application.
We will suppose to have an estimate of the values Pℓ
(the loss probability over a single link), 1/λ (the average
time a peer remains connected, see Section VII), 1/µ (the
average time required to ﬁnd a new peer, see Section VII), the
content bandwidth B and the minimum upload bandwidth Umin
available at the nodes. We also have some quality of service
constraints, such as a maximum underﬂow probability Punder
(see Section VII) and a maximum packet loss probability at
the application level Peq (see Section VI). Finally, we desire to
keep ρ = Nup/R as small as possible, since the overall required
bandwidth grows linearly with ρ. The parameters that we need
to determine are the Galois ﬁeld F2d, the reduction factor R
and the redundancy ρ (or, equivalently, the number of upper
nodes Nup = ρR).
An obvious constraint on R is given by the fact that, if data
puncturing is not employed, it must be R ≥ ⌈B/Umin⌉, where
⌈x⌉ denotes the smallest integer not smaller than x.
Observe that the minimum value admissible for ρ is ﬁxed
by R and Pℓ since ρ must be such that the probability of
receiving at least R fragments out of ρR is not smaller than
1−Peq. Note that for small values of Peq, ρ cannot be smaller
than 1/Pℓ and that it gets closer to that optimal value as R
grows. Therefore, in order to minimize ρ, it is convenient to
choose a large value for R.
Using a large R has other advantages, too. For example, both
the probability Punder of the underﬂow event (see Section VII)
and the the probability Pfail of having less than R different
reduction parameters (see Section V-B) decrease with R. More-
over, for a ﬁxed value of ρ, also the jitter (see Section V-F)
and the decay of recovery probability 1−Peq (see Section VI)
improve with R since Nup = ρR. The only drawback of a large
value of R is, according to (15), an increased computational
complexity.
Summarizing, we can give the following guidelines for the
choice of ρ and R
• Choose, tentatively, d = 32 since the increase in compu-
tational complexity is not huge (see Table I) and it helps
in keeping Pfail small.
• Choose R as large as possible, at least large enough to
satisfy the constraint R ≥ ⌈B/Umin⌉.
• Choose ρ so the the probability of receiving at least R
fragments out of ρR is not smaller than 1−Peq.
• Verify that, with the given choices of ρ and R, the
constraints on Pfail and Punder are satisﬁed. If they are
not, choose a larger R. Note that even if we increase
R, we can keep the same ρ since it will satisfy the Peq
constraint even if R is increased. Alternatively, if R cannot
be increased because of the computational complexity,
one can increase ρ.
• Verify that the computational complexity for the chosen d
and R is acceptable. If it is not, one can lower it by using
# Input
: cl and dl
# Output : al and ah
movb %cl, %dh
shll #1, %edx
movw tbl_4(%edx), %ax
# Input
: cl and dl
# Output : al
movb %cl, %dh
movb tbl_8(%edx), %al
(a)
(b)
# Input
: cx, dx
# Output : ax
# compute log(%ecx)
movl %ecx, %eax
orw
%ax, %ax
jz
done
shl
#1, %eax
movw log_16(%eax), %cx
# compute log(%edx)
movl %edx, %eax
orw
%ax, %ax
jz
done
shl
#1, %eax
movw log_16(%eax), %dx
# Compute the sum of
# the logs mod 2**16-1
addw %dx, %cx
jnc no_mod_needed
incw %cx
no_mod_needed:
shll #1, %ecx
movw exp_16(%ecx), %ax
done:
# Input
: ecx, edx
# Output : eax
carry_mask=0x8299
# Init the result
movl #0, %eax
orl
%edx, %edx
jz
done
main_loop:
# If the LSB of
# edx is 1, xor
# ecx with the result
test #0x0001, %edx
jz
skip_xor
xorl %ecx, %eax
skip_xor:
# Shift left cx
shl #1, %ecx
jnc no_reduction
xor carry_mask, %ecx
no_reduction:
# Shift right dx
shr #1, %edx
jnz
main_loop
done:
(c)
(d)
Figure 10.
The product algorithms used in the velocity tests. (a) Algorithm
for F24. (b) Algorithm for F28. (c) Algorithm for F216. (d) Algorithm for F232.
a different value for d (e.g., d = 16) or reiterating the
design procedure with a smaller R. If R was already equal
to the minimum value ⌈B/Umin⌉, one can try to employ
data puncturing for the nodes with smallest bandwidth.
IX. CONCLUSIONS AND FUTURE WORK
This article has described PPETP, an overlay multicast
protocol that allows for efﬁcient data propagation even when
some nodes have limited resources. A quantitative analysis of
some ﬁgures of merit of PPETP and some design guidelines
have been presented.
A. Acknowledgments
PPETP is partially funded by Italian Ministry PRIN project
Arachne.
APPENDIX
A. Computation of Pfail
Our goal is to compute Pfail(Nup,R,S), that is the probability
that after Nup drawing from an alphabet with S elements we
have less than R different values. This experiment can be
represented by the ﬁnite state system shown in Fig. 12. Each
state is labeled with the number of different symbols extracted
171
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

uint16_t table[65536];
/* Filled at init time */
void F16_mult(byte b,
byte in_1,
byte in_2,
byte *out_1, byte *out_2)
{
/* Make the 16-bit index to access the table
* as follows
*
*
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*
|
r_2
|
r_1
|
b
|
*
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*
MSB
LSB
*/
uint16 index
= in_2 << 12 + in_1 << 8 + b;
uint16 out_pair = table[index];
*v_1 = out_pair & 0xff;
/* LS bits */
*v_2 = out_pair >> 8;
/* MS bits */
}
Figure 11.
Pseudo-C code to compute with a single table access products
out_1 = in_1*b and out_2 = in_2*b, where in_1 and in_2 rep-
resent elements of F16 and b, out_1 and out_2 vectors in F2
16.
R−1
1
0
2
end
1
1−1/S
1/S
1−2/S
1−(R−2)/S
1−(R−1)/S
1
(R−1)/S
2/S
Figure 12.
Markov chain used to compute the curves of Fig. 4.
so far and the system starts from state 0. The system goes in
the state marked with “end” when R or more different symbols
have been extracted. It is easy to see that Pfail(Nup,R,S) =
1−P[s(Nup) = end], where s(n) is the state after n extractions.
This probability can be easily obtained from PNup, where P is
the transition matrix of Fig. 12. By writing explicitly P it is
easy to check that the limn→∞ P[s(n) = end] = 1 and that the
largest eigenvalue of P less than 1 is (R − 1)/S. Therefore,
Pfail(n,R,S) converges to zero as [(R−1)/S]n.
B. Proof of Property 1
In order to proof Property 1 we need the following lemma.
Lemma 2. For every K ≥ 1, the probability that stratum K is
in full state is bounded as follows
P[FK = Ω] ≥ λ ∑K
n=1 Ln
(34)
where λ is as in (21).
Proof: We proceed by induction. For K = 1 the event
F1 = Ω holds if every node of the ﬁrst stratum receives at
least T fragments. Since the upper peers of the nodes of
the ﬁrst stratum are origin servers, the number of fragments
received by a node is a binomial variable with Nup tentatives
and success probability PT, that is, the probability that a given
node of the ﬁrst stratum is in ﬁring state is λ. Since all the
links from stratum 0 to stratum 1 are independent one another,
P[F1 = Ω] = λ L1
(35)
that is (34) with the equality sign.
Suppose now that bound (34) holds for K −1 and prove it
for K > 1. It is
P[FK = Ω] =
∑
u∈{0,1}LK−1
P[FK = Ω|FK−1 = u]P[FK−1 = u]
≥ P[FK = Ω|FK−1 = Ω]P[FK−1 = Ω]
≥ P[FK = Ω|FK−1 = Ω]λ ∑K−1
n=1 Ln
(36)
where the last inequality follows from the inductive hypothe-
sis.
In order to compute P[FK = Ω|FK−1 = Ω] observe that if
all the nodes in stratum K −1 are in ﬁring state, a reasoning
similar to the one used to derive (35) holds and one obtains
P[FK = Ω|FK−1 = Ω] = λ LK
(37)
Using (37) in (36) gives the thesis.
REFERENCES
[1] R. Bernardini, R. C. Fabbro, and R. Rinaldo, “Ppetp: A peer-to-
peer overlay multicast protocol for multimedia streaming,” in Proc. of
CONTENT 2011, (Rome), Sept. 2011. Best paper award.
[2] E. Adar and B. A. Huberman, “Free riding on Gnutella,” First Monday,
vol. 5, October 2000.
[3] Y. Chawathe, S. Ratnasamy, L. Breslau, N. Lanham, and S. Shenker,
“Making gnutella-like p2p systems scalable,” in Proceedings of the 2003
conference on Applications, technologies, architectures, and protocols
for computer communications, SIGCOMM ’03, (New York, NY, USA),
pp. 407–418, ACM, 2003.
[4] V. Fodor and G. D´an, “Resilience in live peer-to-peer streaming,” IEEE
Communications Magazine, vol. 45, pp. 116–123, June 2007.
[5] V. Padmanabhan, H. Wang, P. Chou, and K. Sripanidkulchai, “Distribut-
ing streaming media content using cooperative networking,” in Proc. of
NOSSDAV 2002, (Miami, Florida, USA), ACM, May 2002.
[6] M. Piatek, T. Isdal, T. Anderson, A. Krishnamurthy, and A. Venkatara-
mani, “Do incentives build robustness in BitTorrent?,” in Proceedings
of 4th USENIX Symposium on Networked Systems Design & Implemen-
tation (NSDI 2007), (Cambridge, MA), USENIX, April 2007.
[7] D. Stutzbach and R. Rejaie, “Understanding churn in peer-to-peer
networks,” in Proceedings of the 6th ACM SIGCOMM conference on In-
ternet measurement, (Rio de Janeriro, Brazil), pp. 189–202, SIGCOMM,
2006.
[8] M. Wang and B. Li, “R2: Random push with random network coding
in live peer-to-peer streaming,” IEEE Journal on Selected Areas in
Communications, vol. 25, pp. 1655–1666, December 2007.
[9] S. Ratnasamy, P. Francis, M. Handley, R. Karp, and S. Shenker, “A
scalable content-addressable network,” in IN PROC. ACM SIGCOMM
2001, pp. 161–172, 2001.
[10] M. Castro, P. Druschel, A. Kermarrec, A. Nandi, A. Rowstron, and
A. Singh, “Splitstream: High-bandwidth multicast in cooperative envi-
ronments,” in 19th ACM Symposium on Operating Systems Principles,
2003, 2003.
[11] S. Marti and H. Garcia-molina, “Taxonomy of trust: Categorizing p2p
reputation systems,” Computer Networks, vol. 50, pp. 472–484, 2006.
[12] S. Iyer, A. Rowstron, and P. Druschel, “Squirrel: A decentralized peer-to-
peer web cache,” in 12th ACM Symposium on Principles of Distributed
Computing (PODC 2002), pp. 1–10, July 2002.
[13] Y. Yue, C. Lin, and Z. Tan, “Analyzing the performance and fairness
of bittorrent-like networks using a general ﬂuid model,” Computer
Communications, vol. 29, no. 18, pp. 3946 – 3956, 2006.
[14] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and H. Balakrishnan,
“Chord: A scalable peer-to-peer lookup service for internet applications,”
SIGCOMM Comput. Commun. Rev., vol. 31, pp. 149–160, August 2001.
[15] A. Rowstron and P. Druschel, “Pastry: Scalable, decentralized object
location and routing for large-scale peer-to-peer systems,” in IFIP/ACM
International Conference on Distributed Systems Platforms (Middle-
ware), pp. 329–350, Nov. 2001.
172
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[16] X. Hei, Y. Liu, and K. W. Ross, “IPTV over P2P streaming networks:
The mesh-pull approach,” IEEE Communications Magazine, vol. 46,
pp. 86–92, Feb. 2008.
[17] D. A. Tran, K. A. Hua, and T. Do, “Zigzag: An efﬁcient peer-to-peer
scheme for media streaming,” in Proceedings of IEEE INFOCOM, (San
Francisco, CA), 2003.
[18] V. Padmanabhan, H. Wang, and P. Chou, “Supporting heterogeneity and
congestion control in peer-to-peer multicast streaming,” in Proceedings
of IPTPS, (San Diego, CA), Feb. 2004.
[19] X. Liao, H. Jin, Y. Liu, L. Ni, and D. Deng, “Chunkyspread: Hetero-
geneous unstructured tree-based peer to peer multicast,” in Proceedings
of IEEE International Conference on Computer Communications, IEEE
Computer Society, Apr. 2006.
[20] X. Zhang, J. Liuy, B. Liz, and P. Yum, “CoolStreaming/DONet: a data-
driven overlay network for efﬁcient live media streaming,” in Proceed-
ings of IEEE International Conference on Computer Communications,
IEEE Computer Society, Mar. 2005.
[21] L. X., J. H., L. Y., N. L., and D. D., “AnySee: Peer-to-Peer live
streaming,” in Proc. INFOCOM 2006, pp. 1–10, 2006.
[22] N. Magharei and R. Rejaie, “Prime: peer-to-peer receiver-driven mesh-
based streaming,” in Proceedings of IEEE International Conference on
Computer Communications, (Alaska), May 2007.
[23] J. Liang and K. Nahrstedt, “Dagstream: locality aware and failure
resilient peer-to-peer streaming,” in Proceedings of MMCN, Jan. 2006.
[24] C. Wu and B. Li, “rStream: resilient and optimal peer-to-peer streaming
with rateless codes,” T-par, pp. 77–92, Jan. 2008.
[25] A. Magnetto, R. Gaeta, M. Grangetto, and M. Sereno, “P2p streaming
with lt codes: a prototype experimentation,” in Proc. ACM Multimedia
2010, pp. 7–12, Oct. 2010.
[26] R.
Bernardini,
R.
C.
Fabbro,
and
R.
Ri-
naldo,
“Peer-to-peer
epi-transport
protocol.”
http://tools.ietf.org/html/draft-bernardini-ppetp,
Jan. 2011. Internet Draft, work in progress.
[27] R. Bernardini, R. C. Fabbro, and R. Rinaldo, “Group based reduction
schemes for streaming applications,” ISRN Communications and Net-
working, vol. 2011, 2011. Article ID 898254, doi:10.5402/2011/898254.
[28] R. Bernardini, R. C. Fabbro, and R. Rinaldo, “Peer-to-peer streaming
based on network coding improves packet jitter,” in Proc. of ACM
Multimedia 2010, (Florence, Italy), Oct. 2010.
[29] H. A. David, Order Statistics 2nd edition. Wiley-Interscience, 1981.
[30] http://www.gnu.org/software/binutils.
[31] Intel Corporation, Intel R
⃝ 64 and IA-32 Architectures Software Devel-
oper’s Manual. No. 253669-033US, December 2009.
[32] A. Shamir, “How to share a secret,” Commun. ACM, vol. 22, pp. 612–
613, November 1979.
[33] T. M. Cover and J. A. Thomas, Information theory. New York: Wiley,
1991.
[34] R. Bernardini, R. Rinaldo, and A. Vitali, “A reliable chunkless peer-to-
peer architecture for multimedia streaming,” in Proc. Data Compr. Conf.,
(Snowbird, Utah), pp. 242–251, Brandeis University, IEEE Computer
Society, Mar. 2008.
[35] P. Natalini and B. Palumbo, “Inequalities for the incomplete gamma
function,” Math. Inequal. Appl. 3, no. 1, pp. 69–77, 2000.
173
International Journal on Advances in Networks and Services, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/networks_and_services/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

