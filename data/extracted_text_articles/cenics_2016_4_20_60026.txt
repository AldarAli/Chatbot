A High-Speed Programmable Network Intrusion Detection System
Based on a Multi-Byte Transition NFA
Tomoaki Hashimoto, Shin’ichi Wakabayashi∗, Shinobu Nagayama†, Masato Inagi, Ryohei Koishi, Hiroki Takaguchi
Graduate School of Information Sciences, Hiroshima City University,
Hiroshima 731-3194, Japan
email: {∗wakaba, †s naga}@hiroshima-cu.ac.jp
Abstract—To improve the network security, when a virus
pattern is updated, an arbitrary updated pattern should be
quickly set in a network intrusion detection system (NIDS).
This type of NIDS is called “programmable.” However, present
programmable NIDSs could hardly be applied to a high-speed
network with more than 10 Gbps of network transmission
speed due to the limitation of clock frequency of the circuit.
To overcome this speed limitation, this paper proposes a
programmable NIDS based on a multi-byte transition non-
deterministic ﬁnite automaton (NFA). The proposed NIDS is
implemented on an FPGA to evaluate its performance. The
FPGA implementation results show that the proposed NIDS
can achieve more than 10 Gbps of throughput.
Keywords-Regular expression matching; non-deterministic ﬁ-
nite automaton; programmable hardware; network intrusion
detection system; FPGA.
I. INTRODUCTION
Network intrusion detection systems (NIDSs) that can de-
tect network attacks such as computer viruses and worms in
real time have become indispensable nowadays to maintain
network security. To detect suspicious data patterns included
in packets, NIDSs perform regular expression matching [14]
between packet payloads and data patterns predeﬁned as
regular expressions. Since regular expression matching is
a time-consuming task, NIDSs tend to be bottleneck in
network transmission. In addition, since regular expression
patterns are frequently updated, NIDSs tend to be security
holes until pattern updating is completed. Thus, 1) fast
regular expression matching and 2) quick pattern updating
are major requirements for NIDSs.
Software NIDSs that perform regular expression matching
by a software program are popular. The Snort system [19] is
well-known as an open source software NIDS, and its regular
expression patterns are available at the website. Software
NIDSs can update regular expression patterns quickly, but
speed of regular expression matching is slow. Although var-
ious algorithms [1][3][6][7][12][14][18][21][25] have been
proposed to perform regular expression matching faster,
their software implementation is difﬁcult to achieve enough
performance to catch up with the speed of latest Gigabit
Ethernet with more than 10Gbps.
On
the
other
hand,
hardware
NIDSs
that
perform
regular
expression
matching
with
FPGAs
[4][8][10][13][15][16][17][23][24]
can
perform
regular expression matching much faster, but they require
long time for pattern updating because regular expression
patterns are embedded as hardware circuits. To update
patterns in such pattern-speciﬁc circuits, a sequence of
FPGA design and implementation processes (i.e., generating
HDL code, logic synthesis, place and route, etc.) should be
performed again. It is well known that those FPGA design
processes require a fairly long time, sometimes, a few
hours. Since this time is longer than update interval [2], it
is hard to keep NIDSs up to date.
To overcome this problem due to architecture of NIDSs,
programmable NIDSs [5][11][20][22] that perform regular
expression matching with pattern-independent circuits have
been proposed as the third approach. The programmable
NIDSs can update patterns more quickly because regular ex-
pression patterns are stored in registers. In addition, the pro-
grammable NIDSs can perform regular expression matching
much faster than software NIDSs. However, since size of
programmable NIDSs is larger than that of pattern-speciﬁc
NIDSs, we use a programmable NIDS with pattern-speciﬁc
ones, as hybrid NIDSs. In hybrid NIDSs, a pattern-speciﬁc
NIDS performs regular expression matching for all patterns
currently registered in the NIDS, while the programmable
NIDS performs regular expression matching for only new
patterns. In this way, we can compensate the defect of
programmable NIDS in terms of hardware size. However,
since throughput of the existing programmable NIDSs is
at most a few Gbps, faster programmable NIDSs are still
required to achieve more than 10 Gbps of throughput.
The existing programmable NIDSs process one byte of
packet payload per one clock, and their throughput has been
improved mainly by increasing clock frequency of circuits.
But, there is a limitation to increase of clock frequency.
Thus, this paper proposes a method to improve throughput
of a programmable NIDS by processing k bytes per one
clock. We design such a high-speed programmable NIDS
using a k-byte transition non-deterministic ﬁnite automaton
(NFA) that is converted from a one-byte transition NFA.
Although a similar method has been proposed by Yama-
gaki et al. [23], their method is targeted to their hardware
NIDS, and thus, the capability of quick pattern updating
45
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-496-1
CENICS 2016 : The Ninth International Conference on Advances in Circuits, Electronics and Micro-electronics

is not considered. Therefore, we propose an architecture of
a programmable NIDS considering quick pattern updating.
As far as we know, a programmable NIDS based on k-byte
transition NFA has not been proposed so far.
The rest of this paper is organized as follows: Section II
brieﬂy deﬁnes regular expressions and NFAs. Section III
introduces k-byte transition NFAs. Section IV presents ar-
chitecture of a programmable NIDS based on k-byte transi-
tion NFAs. Its FPGA implementation results are shown in
Section V. Section VI concludes the paper.
II. PRELIMINARIES
A. Regular Expressions
In NIDSs, suspicious data patterns to be found are de-
scribed by not only simple strings, but also regular ex-
pressions [9]. This is because its acceptance algorithm is
simple, and it has practically enough expression power [13].
A set of strings represented by regular expression is called
a regular set or regular language. Regular expressions and
their regular sets are recursively deﬁned as follows:
Deﬁnition 1: Let Σ be a ﬁnite set of characters: Σ =
{a1,a2,...,an}, called the alphabet, R and S be regular
expressions on Σ, and L(R) and L(S) be regular sets denoted
by R and S, respectively. Then,
1) /0 is a regular expression denoting the regular set /0.
2) ε is a regular expression denoting the regular set {ε}
(the null character).
3) A character ai ∈ Σ is a regular expression denoting the
regular set {ai}.
4) An alternation R | S is a regular expression denoting
the regular set L(R)∪L(S).
5) A concatenation R·S is a regular expression denoting
the regular set {rs|r ∈ L(R),s ∈ L(S)}. R1 = R and
Rm = R·Rm−1 for m ≥ 2. Usually, ‘·’ is omitted.
6) A Kleene closure R∗ is a regular expression ε | R |
R2 | ... denoting the regular set {ε} ∪ L(R) ∪ L(R2) ∪
..., where L(R),L(R2),... are regular sets denoted by
R,R2,..., respectively.
Only expressions obtained by considering the above 1) to
3) as constants, and applying the above operations 4) to 6)
ﬁnite times are regular expressions on Σ.
For simplicity of expressions, this paper introduces the
following operation as well:
7) A dot . denotes the set L(.) = Σ∪{ε} (don’t care).
B. Non-Deterministic Finite Automaton
Deﬁnition 2: A
non-deterministic
ﬁnite
automaton
(NFA) [9] is deﬁned by a 5-tuple (Q,Σ,δ,q0,F), where
Q is a ﬁnite set of states, Σ is the alphabet, δ is a state
transition function δ : Q×(Σ∪{ε}) → 2Q, 2Q is the power
set of Q, q0 ∈ Q is an initial state, and F ⊆ Q is a set of
accepting states. When δ : Q×Σ → 2Q, it is called an ε-free
NFA. In the following, an NFA means an ε-free NFA, unless
otherwise stated.
0q
1q
a
3q
4q
2q
b
c
c
b
d
(a) NFA for preﬁx matching.
0q
1q
a
3q
4q
2q
b
c
c
b
d
.
(b) NFA for inﬁx matching.
Figure 1.
NFAs for regular expression a(cc | bd ∗b).
An arbitrary regular expression R can be converted into an
NFA that accepts its regular language L(R). Usually, NFAs
are represented as directed graphs. Since directed graphs
can be represented by adjacency matrices, NFAs can also
be represented by adjacency matrices as follows:
Example 1: Figure 1(a) shows an NFA for the regular
expression a(cc | bd ∗b). In this NFA, q0 is the initial state,
and q4 is the accepting state. By considering this NFA as a
directed graph, the NFA can be represented by the following
adjacency matrix M:
M =






/0
a
/0
/0
/0
/0
/0
b
c
/0
/0
/0
d
/0
b
/0
/0
/0
/0
c
/0
/0
/0
/0
/0






In this matrix, an element in i-th row and j-th column of M
denotes a set of transition characters from qi to q j. When no
state transition is deﬁned, /0 is entered as the corresponding
element.
C. Regular Expression Matching Based on NFAs
Regular expression matching performed in NIDSs is often
formulated as follows:
Problem 1: Given a regular expression R and a text T,
detect if T has a string in L(R) as a substring.
Regular expression matching can be performed by iterat-
ing state transitions on an NFA for R according to characters
in T. If a substring in T can cause state transitions from the
initial state q0 to an accepting state in F, then it is in L(R)
(i.e., a matching is achieved). Otherwise, the substring is not
in L(R) (i.e., matching failed).
Although the NFA in Figure 1(a) is equivalent to the
regular expression a(cc | bd ∗ b), the NFA in Figure 1(b)
is used in NIDSs to solve Problem 1. This is because the
NFA can discard unmatched preﬁx characters by the state
transition by the don’t care character at q0. In the following,
we focus on this type of NFAs.
Regular expression matching hardware based on NFAs
realizes the above behavior on a circuit. Since in an NFA,
multiple states can be active, state transitions from ac-
tive states caused by a character are computed in paral-
lel in hardware. Existing programmable NIDSs based on
NFAs [5][11][20][22] compute all state transitions caused
by a character in a clock.
46
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-496-1
CENICS 2016 : The Ninth International Conference on Advances in Circuits, Electronics and Micro-electronics

III. MULTI-BYTE TRANSITION NFAS
The alphabet Σ, on which regular expressions and NFAs
are deﬁned, usually consists of one-byte (8-bit) characters.
Since existing programmable NIDSs based on NFAs com-
pute all state transitions for a character in a clock, network
transmission speed s that the NIDSs can be applied is s = 8 f
bits per second, where f is clock frequency of the NIDSs.
Thus, network transmission speed s has been increased by
increasing clock frequency f of circuits so far. However,
there is a limitation to increase of clock frequency, and thus,
it is difﬁcult to achieve 10 Gbps of network transmission
speed in this way.
To overcome the problem, we introduce multi-byte tran-
sition NFAs [23] to design of programmable NIDSs.
A. Deﬁnition of Multi-Byte Transition NFAs
Whereas ordinary NFAs require a one-byte character
for state transitions, multi-byte transition NFAs require a
multi-byte character. To obtain multi-byte transition NFAs
that accept the same regular sets as regular expressions R
deﬁned on one-byte characters, we generate k-byte transition
NFAs, in which state transitions are caused by k one-byte
characters, from one-byte transition NFAs for R. Thus, this
paper deﬁnes multi-byte transition NFAs as follows:
Deﬁnition 3: Let
a
one-byte
transition
NFA
be
(Q,Σ,δ,q0,F). Then, a multi-byte (k-byte) transition
NFA equivalent to it is deﬁned by (Qk,Σk′,δk,q0,Fk).
Fk = F ∪F′ where F′ is a set of additional accepting states.
Qk = F′ ∪ Q′ where Q′ ⊆ Q. Σk′ = Σk ∪ Sk−1
i=1 Σi × {ε}k−i,
where products of sets are Cartesian products. And,
δk : Qk ×Σk′ → 2Qk.
Since k-byte transition NFAs take in k one-byte characters
at a time, null characters ε can be input at the end of a text
when length of the text is not a multiple of k. Thus, in this
deﬁnition, ε is added to Σk′. And, for the same reason, F′
is added. The next subsection shows how to produce such
k-byte transition NFAs.
B. Conversion into Multi-Byte Transition NFA
We can generate k-byte transition NFAs of Deﬁnition 3
by converting k state transitions (a path of length k) on one-
byte transition NFAs into a state transition (a path of length
1). Such path conversions can be achieved by considering
NFAs as directed graphs, and raising adjacency matrices of
NFAs to the k-th power [23]. In the following, we introduce
the conversion method brieﬂy. For more details, see [23].
Given an adjacency matrix M of a one-byte transition
NFA, at ﬁrst, add a symbol ω to diagonal elements of M
that are associated with accepting states. The symbol ω
corresponds to ε in Deﬁnition 3. Let M(1) be the obtained
matrix. Then, obtain M(k) by raising M(1) to the k-th power
using the matrix multiplication deﬁned in the following:
Deﬁnition 4: Since all elements of M(1) can be consid-
ered as regular expressions, multiplications and additions
on ordinary scalar matrix multiplication are computed as
0q
1q
.a
3q
4q
2q
bd
ac
c.
b.
dd
..
f(1)
q
ab
bb, cc
db
Figure 2.
2-byte transition NFA equivalent to the NFA in Figure 1(b).
concatenation · and alternation |, respectively, except for the
following cases:
• Multiplication with /0 results in /0.
• .×E = .E and E ×. = /0, where E is a regular expression
for an element.
• ω×E = /0 and E ×ω = Eω.
After the matrix multiplications, apply the following opera-
tions to M(k) to obtain an adjacency matrix M(k)
a
of a k-byte
transition NFA.
1) Add
k − 1
columns
for
new
accepting
states
q f(1),q f(2),...,q f(k−1), and redeﬁne strings including
i ω’s as state transitions to the new accepting state
q f(i). Note that no row is added because there is no
state transition from the new accepting states.
2) Replace ω with the don’t care character. Although ω
can be replaced with ε, the don’t care character is
preferred because it makes hardware implementation
simpler.
And, ﬁnally, eliminate states without incoming state tran-
sition, except for the initial state, to obtain an irredundant
k-byte transition NFA.
Example 2: M(2)
a
for the NFA in Figure 1(b) is as follows:
M(2)
= M(1) ×M(1)
=






.
a
/0
/0
/0
/0
/0
b
c
/0
/0
/0
d
/0
b
/0
/0
/0
/0
c
/0
/0
/0
/0
ω












.
a
/0
/0
/0
/0
/0
b
c
/0
/0
/0
d
/0
b
/0
/0
/0
/0
c
/0
/0
/0
/0
ω






=






..
.a
ab
ac
/0
/0
/0
bd
/0
bb | cc
/0
/0
dd
/0
db | bω
/0
/0
/0
/0
cω
/0
/0
/0
/0
/0






M(2)
a
=






..
.a
ab
ac
/0
/0
/0
/0
bd
/0
bb | cc
/0
/0
/0
dd
/0
db
b.
/0
/0
/0
/0
/0
c.
/0
/0
/0
/0
/0
/0






Figure 2 shows a 2-byte transition NFA for M(2)
a
47
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-496-1
CENICS 2016 : The Ninth International Conference on Advances in Circuits, Electronics and Micro-electronics

0q
1q
.a
4q
2q
bd
acc.
b.
dd
..
f(1)
q
ab
bb, cc
db
Figure 3.
2-byte STNFA equivalent to the NFA in Figure 1(b).
C. Multi-Byte String Transition NFAs
A string transition NFA (STNFA) [20][22] is an exten-
sion of an NFA, and it causes state transitions by a string,
not a character. By eliminating states connected linearly in
an ordinary NFA, and connecting between its beginning
state and ending state directly as a string transition, an
STNFA is obtained. The STNFA obtained by this simple
way is equivalent to the original NFA, and has fewer states
resulting in a smaller circuit. Since many concatenations are
used in regular expression patterns for NIDSs [19], linearly
connected states often appear. Thus, this simple conversion
method is effective to reduce circuit size [20][22].
We apply the same method to multi-byte transition NFAs
to generate multi-byte STNFAs with fewer states. In Fig-
ure 2, the states q0, q3, and q f(1) are linearly connected.
By eliminating q3 and connecting q0 and q f(1) directly, we
obtain a 2-byte STNFA in Figure 3.
IV. PROGRAMMABLE NIDS BASED ON MULTI-BYTE
STRING TRANSITION NFAS
This section presents architecture of our programmable
NIDS based on multi-byte STNFAs. To realize both fast
regular expression matching and quick pattern updating with
a compact circuit, the proposed NIDS is designed taking
advantages of multi-byte STNFAs shown in Section III.
A. Overall Architecture of Our Programmable NIDS
Since overall architecture of our NIDS follows architec-
ture of the NIDS shown in [20], this subsection shows only
an overview of its architecture. For more details, see [20].
Figure 4 shows overall architecture of the proposed pro-
grammable NIDS. It has a two-dimensional array structure,
consisting of two parts: a matching array (MA) and a
feedback array (FA). The MA performs string matching
needed to trigger state transitions on an STNFA. The FA
is a programmable interconnection network to activate next
states according to state transitions triggered by the MA.
B. Matching Array Based on k-Byte String Transition NFAs
The MA is constructed by arranging string matching
units (SMUs), shown in Figure 5, in a row. Eash state
transition in an STNFA is assigned to an SMU. An SMU is
constructed as a one-dimensional array of simple processing
Maching Array
...
...
...
...
A character
of text
Accept
Feedback
Array
Eout 1
Eout 2
Eout m
...
Fin m
Fin 2
Fin 1
...
Initial
Figure 4.
Overall architecture of programmable NIDS [20].
...
Character
Fin
Ein
Eout
 CC 1 
Pattern bus
1
Fin
Ein
Eout
 CC 2 
Fin
Ein
Eout
 CC n 
Feedback
To feedback
array
To another
SMU
Figure 5.
Architecture of string matching unit (SMU) [20].
units, called comparison cells (CCs), shown in Figure 6.
Each CC performs one-character matching for a k-byte
character fed synchronously with the clock, and transmits
its matching result to the right neighbor CC via Eout.
By performing one-character matching sequentially using
the pipelined CCs, an SMU performs string matching. When
an input string matches with a string pattern stored in an
SMU, the SMU outputs an enable signal to the FA to
trigger state transitions. Then, by transmitting triggered state
transitions (the enable signal) to Fin of appropriate SMUs via
the FA, next states are activated, since CCs perform one-
character matching only when an enable signal is fed via
Ein or Fin. Using the pattern bus, we can program which
CC receives an enable signal from, Ein or Fin, to the register
connected to the selector.
CCs perform one-character matching using character
matching tables, shown in Figure 7, that are new components
proposed in this paper. An input k-byte character is divided
into each byte, and is fed to addresses of k RAMs in parallel.
Word width of a RAM is 1 bit, and it stores 0 or 1. If a byte
x given as an address matches with the i-th byte of a k-byte
Character
Fin
Ein
Pattern
Character
Matching
Tables
Eout
SEL
FF
AND
register
Figure 6.
Architecture of comparison cell (CC).
48
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-496-1
CENICS 2016 : The Ninth International Conference on Advances in Circuits, Electronics and Micro-electronics

k-byte text character
RAM 1
k-bit pattern
AND
RAM k
...
1st byte
2nd byte
k-th byte
1st bit 2nd bit
k-th bit
...
...
...
(256 bits)
RAM 2
(256 bits)
(256 bits)
Figure 7.
Architecture of character matching tables.
Accept
Eout 1
Eout m
...
Fin m
Fin 1
...
Initial
FF
OR
FF
FF
FF
Eout 2
...
Fin 2
FF
OR
FF
FF
FF
...
FF
OR
FF
FF
FF
...
FF
OR
FF
FF
FF
Figure 8.
Architecture of feedback array.
pattern character, RAMi[x] stores 1. Otherwise, RAMi[x]
stores 0. If the i-th byte of a pattern character is a don’t
care character, RAMi stores 1 for all addresses. Contents of
RAMs can be rewritten using the pattern bus.
C. Feedback Array Based on k-Byte String Transition NFAs
The FA is a programmable interconnection network to
transmit enable signals fed from the MA to appropriate
SMUs. Figure 8 shows its architecture. By setting appropri-
ate bits to the FFs, like crossbar switches, we can program
arbitrarily connections. When an FF stores 1, a vertical line
and a horizontal line are connected. Otherwise, lines are
disconnected.
Since the proposed NIDS based on k-byte STNFA takes in
k one-byte characters at a time, network transmission speed
s that the NIDS can be applied is improved to s = 8k f bps.
V. EXPERIMENTAL RESULTS
To experimentally evaluate performance of the proposed
programmable NIDS, we used the following ﬁve regular
expressions randomly chosen from rules of the SNORT [19]:
R1: /level/(0|1|2|3|4|5|6|7|8|9)+/(exec|conﬁgure)
R2: cookies\s+Monster\s+server\s+engine
R3: template\s∗=\s∗{$
R4: fn=..(/ |\)
R5: (((\x0bdyndns|\x02yi)\x03org)|((\x07dynserv|\x04mo
oo)\x03com))
where \s denotes a blank character, + is a regular expression
operator that means R+ = R·R∗, \x followed by a two-digit
hexadecimal number denotes an ASCII code, and the others
are treated as one-byte characters in the alphabet Σ.
A. Results for Multi-Byte Transition NFAs
Table I shows the numbers of states and state transitions in
a k-byte transition NFA for each regular expression, where
columns of k = 1 show results of existing method [20].
From this table, we can see that the numbers of states and
state transitions increase as the value of k increases. This is
because new accepting states are added, and the number of
characters in an alphabet increases as k increases.
By converting into STNFAs, they can be reduced. Since
the number of state transitions corresponds to the number of
SMUs in the proposed NIDS, we can reduce the circuit size
by using STNFAs. When k = 8, the number of state transi-
tions is not reduced so much by STNFAs. This is because
an 8-byte character consists of 8 one-byte characters, and it
already forms a string.
B. FPGA Implementation Results
We designed programmable NIDSs based on the above
k-byte STNFAs by setting design parameters as follows:
the number of CCs n = 5 and the number of SMUs
m = 10,50,100,150,200. Since the SNORT rules use 7-
bit ASCII characters as one-byte characters, we designed
each character matching table in Figure 7 as a 128-bit
RAM that is implemented with 2 LUTs in an FPGA. The
designed NIDSs were implemented with the Xilinx Virtex-
7 XC7VX485T-2FFG1761 FPGA using the Xilinx Vivado
Design Suite 2014.2 as a synthesis tool. Table II shows
the FPGA implementation results and network transmission
speed the proposed NIDSs can achieve.
When k = 1, 10 SMUs (m = 10) are required in order to
realize any rule of the ﬁve, since the maximum number of
state transitions in an STNFA is 8, as shown in Table I.
Although the NIDS with m = 10 achieves 429 MHz of
operating frequency, its transmission speed is 3.4 Gbps. This
corresponds to performance of the existing programmable
NIDS [20]. When k = 2 and 4, m = 50 and 100 are required,
respectively. The NIDSs with m = 50 and 100 still do not
reach 10 Gbps, even though they achieve higher speed than
the existing one. When k = 8, m = 150 is required, but the
NIDS can achieve more than 10 Gbps. Even if there is a
regular expression that requires m = 200, the NIDS with
m = 200 can achieve more than 10 Gbps when k = 8.
49
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-496-1
CENICS 2016 : The Ninth International Conference on Advances in Circuits, Electronics and Micro-electronics

TABLE I. NUMBERS OF STATES AND STATE TRANSITIONS IN A k-BYTE TRANSITION NFA.
Rules
Number of states
Number of state transitions
Character transition NFAs
String transition NFAs
Character transition NFAs
String transition NFAs
k = 1
k = 2
k = 4
k = 8
k = 1
k = 2
k = 4
k = 8
k = 1
k = 2
k = 4
k = 8
k = 1
k = 2
k = 4
k = 8
R1
22
23
25
29
4
7
13
26
24
38
40
88
6
12
28
85
R2
29
30
32
36
5
12
26
36
32
39
62
144
8
21
56
144
R3
12
13
15
19
4
17
11
19
14
19
39
147
6
13
35
147
R4
7
8
10
14
3
5
9
14
8
10
14
22
4
7
13
22
R5
29
30
32
36
4
7
13
17
32
36
44
60
7
7
25
41
TABLE II. FPGA IMPLEMENTATION RESULTS OF THE PROPOSED NIDSS.
m
Total number of LUTs
Operating frequency [MHz]
Transmission speed [Gbps]
k = 1
k = 2
k = 4
k = 8
k = 1
k = 2
k = 4
k = 8
k = 1
k = 2
k = 4
k = 8
10
291
332
662
1,083
429
383
399
405
3.4
6.1
12.8
25.9
50
2,192
2,443
3,743
6,093
351
353
353
312
2.8
5.6
11.3
20.0
100
6,449
6,850
9,550
14,150
297
297
276
255
2.4
4.8
8.8
16.3
150
12,379
14,931
16,957
24,225
241
242
209
212
1.9
3.9
6.7
13.6
200
20,445
22,203
29,429
38,989
216
197
178
182
1.7
3.2
5.7
11.6
*The underlined numbers are results of NIDSs required in order to realize any rule of the ﬁve.
In this way, larger k requires larger m (more SMUs),
and thus, degrades operating frequency because of longer
critical paths in the feedback array. However, it can improve
transmission speed signiﬁcantly since the positive effect due
to parallelization by k is larger than its negative effect.
VI. CONCLUSION AND COMMENTS
This paper proposed a programmable NIDS based on a
multi-byte STNFA. By using multi-byte STNFAs, the pro-
posed NIDS achieved more than 10 Gbps of network trans-
mission speed that is difﬁcult for existing programmable
NIDSs to achieve. Thus, the proposed NIDS can avoid
bottleneck even in latest Gigabit network. Since in the
proposed NIDS, regular expression patterns can be set by
just rewriting contents of memories and registers, the NIDS
achieves both fast regular expression matching and quick
pattern updating.
In the current design, increasing the number of SMUs
makes critical paths in the feedback array longer, resulting
in degradation of operating frequency. Thus, improving
architecture of the feedback array is one of our future works.
We will also study how to minimize the number of state
transitions in order to reduce hardware cost.
ACKNOWLEDGMENTS
This research is partly supported by the JSPS Grant-in-
Aid for Scientiﬁc Research (C), (No. 26330691), 2015.
REFERENCES
[1] J. Aoe, Computer Algorithms: String Pattern Matching Strategies,
IEEE Computer Society Press, 1994.
[2] AV-TEST - The Independent IT-Security Institutie, http://www.av-
test.org/.
[3] M. Becchi and P. Crowley, “An improved algorithm to accelerate reg-
ular expression evaluation,“ Proc. of the 3rd ACM/IEEE Symposium
on Architecture for networking and communications systems, Dec.
2007, pp. 145–154.
[4] J. Bispo, I. Sourdis, J. M. P. Cardoso, and S. Vassiliadis, “Regular
expression matching for reconﬁgurable packet inspection,” Proc. 2006
IEEE International Conference on Field Programmable Technology,
2006, pp. 119–126.
[5] J. Divyasree, H. Rajashekar, and K. Varghese, “Dynamically reconﬁg-
urable regular expression matching architecture,” Proc. International
Conference on Application-Speciﬁc Systems, Architectures and Pro-
cessors (ASAP 2008), July 2008, pp. 120–125.
[6] D. Ficara, et al., “An improved DFA for fast regular expression
matching,“ ACM SIGCOMM Computer Communication Review,
Vol. 38, No. 5, Oct. 2008, pp. 31–40.
[7] D. Ficara, et al., “Differential encoding of DFAs for fast regu-
lar expression matching,“ IEEE/ACM Transactions on Networking,
Vol. 19, No. 3, June 2011, pp. 683–694.
[8] T. Ganegedara, Y.E. Yang, and V. K. Prasanna, “Automation frame-
work for large-scale regular expression matching on FPGA,“ Proc.
2010 IEEE International Conference on Field Programmable Logic
and Applications, 2010, pp. 50–55.
[9] J. E. Hopcroft, J. D. Ullman, and R. Motwani, Introduction to
Automata, Theory, Languages and Computation, Second Edition,
Addison-Wesley, 2000.
[10] B. L. Hutchings, R. Franklin, and D. Cover, “Assisting network
intrusion detection with reconﬁgurable hardware,” Proc. 10th An-
nual IEEE Symposium on Field-Programmable Custom Computing
Machines, 2002, pp. 111–120.
[11] Y. Kaneta, S. Yoshizawa, S. Minato, H. Arimura, and Y. Miyanaga,
“Dynamic reconﬁgurable bit-parallel architecture for large-scale reg-
ular expression matching,” Proc. 2010 IEEE International Conference
on Field Programmable Technology, Dec. 2010, pp. 21–28.
[12] S. Kumar, S. Dharmapurikar, F. Yu, P. Crowley, and J. Turner,
“Algorithms to accelerate multiple regular expressions matching for
deep packet inspection,” Proc. SIGCOMM’06, 2006, pp. 339–350.
[13] A. Mitra, W. Najjar, and L. Bhuyan, “Compiling PCRE to FPGA
for accelerating SNORT IDS,” Proc. 2007 ACM/IEEE Symposium
on Architecture for Networking and Communications Systems, Dec.
2007, pp. 127–136.
[14] G. Navarro and M. Rafﬁnot, Flexible Pattern Matching in Strings,
Cambridge University Press, 2002.
[15] H. C. Roan, W. J. Hwang, and C. T. Dan Lo, “Shift-or circuit for
efﬁcient network intrusion detection pattern matching,” Proc. Inter-
national Conference on Field Programmable Logic and Applications,
2006, pp. 785–790.
[16] Y. SangKyun and L. KyuHee, “Optimization of regular expression
pattern matching circuit using at-most two-hot encoding on FPGA,“
Proc. 2010 IEEE International Conference on Field Programmable
Logic and Applications, Sept. 2010, pp. 40–43.
[17] R. Sidhu and V. K. Prasanna, “Fast regular expression matching
using FPGAs,” Proc. 2001 IEEE International Symposium on Field-
Programmable Custom Computing Machines, 2001, pp. 227–238.
[18] R. Smith, C. Estan, S. Jha, and S. Kong, “Deﬂating the big bang: fast
and scalable deep packet inspection with extended ﬁnite automata,”
Proc. SIGCOMM’08, 2008, pp. 207–218.
[19] Sourceﬁre Inc., “SNORT network intrusion detection system,”
http://www.snort.org/.
50
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-496-1
CENICS 2016 : The Ninth International Conference on Advances in Circuits, Electronics and Micro-electronics

[20] H. Takaguchi, Y. Wakaba, S. Wakabayashi, S. Nagayama, and
M. Inagi, “An NFA-based programmable regular expression matching
engine highly suitable for FPGA implementation,” 18th Workshop on
Synthesis and System Integration of Mixed Information Technologies
(SASIMI’13), 2013, pp. 231–236.
[21] K. Thompson, “Programming technique: regular expression search
algorithm,” Communications of the ACM, Vol. 11, No. 6, June 1968,
pp. 419–422.
[22] Y. Wakaba, M. Inagi, S. Wakabayashi, and S. Nagayama, “An
efﬁcient hardware matching engine for regular expression with nested
Kleene operators,“ Proc. 2011 IEEE International Conference on
Field Programmable Logic and Applications, 2011, pp. 157–161.
[23] N. Yamagaki, R. Sidhu, and S. Kamiya, “High-speed regular expres-
sion matching engine using multi-character NFA,” Proc. International
Conference on Field Programmable Logic and Applications, Aug.
2008, pp. 131–136.
[24] Y.-H. E. Yang and V. Prasanna, “Automatic construction of large-
scalce regular expression matching engines on FPGA,” Proc. 2008
International Conference on Reconﬁgurable Computing and FPGAs,
2008, pp. 73–78.
[25] Y.-H. E. Yang and V. K. Prasanna, “Space-time trade off in regular
expression matching with semi-deterministic ﬁnite automata,” Proc.
IEEE INFOCOM 2011, April 2011, pp. 1853–1861.
51
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-496-1
CENICS 2016 : The Ninth International Conference on Advances in Circuits, Electronics and Micro-electronics

