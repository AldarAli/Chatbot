Modular Veriﬁcation of Inter-enterprise Business Processes
Kais Klai
LIPN, CNRS UMR 7030
Universit´e Paris 13
99 avenue Jean-Baptiste Cl´ement
F-93430 Villetaneuse, France
Email: kais.klai@lipn.univ-paris13.fr
Hanen Ochi
LIPN, CNRS UMR 7030
Universit´e Paris 13
99 avenue Jean-Baptiste Cl´ement
F-93430 Villetaneuse, France
Email: hanen.ochi@lipn.univ-paris13.fr
Abstract— In this paper, we propose to adapt the Sym-
bolic Observation Graphs (SOG) based approach in order to
abstract, to compose and to check Inter-Enterprise Business
Processes (IEBP). Each component (local process) is repre-
sented by a SOG where only the collaboration actions of the
process are visible while its local behavior and its private
structure are hidden. The entire IEBP is then abstracted by
the composition of the components’ abstractions (i.e., their
SOGs). The main result of this paper is to demonstrate that
the composition of the SOGs is deadlock free if and only if the
original IEBP is deadlock free. We implemented our adaptation
of the SOG construction and compared our abstraction and
modular veriﬁcation approach with the Operating Guidelines
technique. The obtained results strengthen our belief that the
SOGs are suitable to abstract and compose business processes
especially when these are loosely coupled.
Keywords-Process
composition;
abstraction;
veriﬁcation;
deadlock-freeness.
I. INTRODUCTION
Recently, the trend in software architecture is to build
Inter-Enterprise Business Processes (IEBP) modularly: Each
process is designed separately and then the whole IEBP is
obtained by composition. Even if such a modular approach is
intuitive and facilitates the design problem, it poses two main
problems: First, it is necessary to ﬁnd an abstraction of the
process that respect the privacy of the underlying enterprise
(by hiring its internal organisation) and, at the same time,
that supply enough information allowing to decide whether
the collaboration with some partner is possible or not (safe
or not). The second problem is that the correct behavior
of each business process of the IEBP taken alone does not
guarantee a correct behavior of the composed IEBP (i.e.,
properties are not preserved by composition). Thus, based
on the abstraction of two (or more) processes, we shoud be
able to say whether the composed process has the desired
behavior or not (in our case, is deadlock free or not).
Proving correctness of the (unknown) composed process
is strongly related to the model checking problem of a
system model. Among others, the symbolic observation
graph [5] based approach has proven to be very helpful
for efﬁcient model checking in general. Since it is heavily
based on abstraction techniques and thus hides detailed
information about system components that are not relevant
for the correctness decision, it is promising to transfer this
concept to the problem rised in this paper.
A SOG is a graph whose construction is guided by
a subset of observed actions. The nodes of a SOG are
aggregates hiding a set of states which are connected with
non observed actions. The arcs of a SOG are exclusively
labeled with observed actions.
The work presented in this paper is in line with those
presented in [1] and [2]: How to adapt the SOG’s structure
in order to abstract and to compose business processes. Such
an adaptation is achieved by attaching to each aggregate
a (locally computed) sufﬁcient and necessary information
for detecting deadlocks that are possibly caused by the
composition. The main contribution of this paper is to design
a symbolic algorithm (based on sets operations) allowing
an efﬁcient computation of this information. This allowed
to strengthen the conviction that SOGs represent a suitable
abstraction since it respects the consraints mentioned above.
Indeed, by observing only the collaborative activities of
a process, publishing the corresponding SOG allows to
hide its internal strcuture. The analysis power of the SOGs
allows, in addition, to check the correctness of a composite
process. The composition of SOGs is immediately suitable
for synchronously composed processes. However, we can
consider asynchronous composition as described in [1],
[2]. The key idea is, when combining two processes, to
involve a third process, representing the interface, into the
composition stage. Such a component consists of buffers
and the corresponding sending and receiving actions. Taken
separately, this component is an inﬁnite state system in the
general case. However, since the whole IEBP is supposed to
have ﬁnitely many states, only its reachable part is visited
during an on-the-ﬂy composition with both processes.
This paper is organized as follows: Section II presents
some preliminary notions on WF-nets and labeled transition
systems. Section III recalls the symbolic observation graphs
and their application on business processes. Composition of
SOGs and checking the deadlock freeness on the obtained
synchronised product is the issue of Section IV. Section V is
devoted to the implementation of our approach in addition to
155
Copyright (c) IARIA, 2012.     ISBN: 978-1-61208-181-6
eKNOW 2012 : The Fourth International Conference on Information, Process, and Knowledge Management

experimental results. In Section VI, we discuss some related
works and compare our technique to existing ones. Finally,
Section VII concludes the paper and presents some aspects
of the future work.
II. PRELIMINARIES
The technique presented in this paper applies to various
kinds of process models that can map to labeled transition
systems, e.g., Petri nets and, in particular, WorkFlow Petri
nets (WF-nets) [11]. Since other modeling languages, which
are more frequently used in practice, map to Petri nets, our
approach is relevant for a very broad class of modeling lan-
guages. Applying our technique does not mean to construct
labeled transition systems explicitly. Instead, abstractions of
labeled transition systems are directly constructed from the
original process models.
Deﬁnition 1 (Labeled Transition System):
A Labeled Transition System (LTS for short ) is a 5 −
tuple < Γ,Act,→,I,F > where :
- Γ is a finite set of states;
- Act is a finite set of actions;
- →⊆ Γ×Act ×Γ is a transition relation;
- I ⊆ Γ is a set of initial states;
- F ⊆ Γ is a set of final states.
In this paper, we restrain the set of states Γ to those that
are reachable from the initial state. Moreover, we assume
that a ﬁnal state f is terminal (it has no successor) and that
the set of actions Act is partionned into two disjoint subsets
Obs (observed actions) and UnObs (unobserved actions).
Below, we present some useful notations:
• For s,s′ ∈ Γ and a ∈ Act, we denote by s
a
−→s′ that
(s,a,s′) ∈→.
• If σ = a1a2 ···an is a sequence of actions, σ denotes
the set of actions occurring in σ, while |σ| denotes
the length of σ. s σ
−→s′ denotes that ∃s1,s2,···sn−1 ∈
Γ: s a1
−→s1
a2
−→···sn−1
an
−→s′.
• The set Enable(s) denotes the set of actions a such that
s
a
−→s′ for some state s′. For a set of states S, Enable(S)
denotes S
s∈SEnable(s).
• π = s0
a1
−→s1
a2
−→··· is used to denote a path of a LTS.
• s ̸→, for s ∈ (Γ\F), denotes that s is a dead state, i.e.,
Enable(s) = /0.
• Sat(s) = {s′ | s σ
−→s′ ∧σ ⊆ UnObs} is the set of states
that are reachable from a state s by unobserved actions
only. For S ⊆ Γ, Sat(S) = S
s∈S Sat(s).
• s ̸⇒, for s ∈ Γ, denotes that either no ﬁnal state in
F is reachable from s, or no state of Sat(s) enables
an observed action, i.e., Enable(Sat(s)) ∩ Obs = /0.
Conversely, s ⇒ denotes ¬(s ̸⇒).
• A ﬁnite path C = s1
σ
−→sn is said to be a cycle if sn = s1
and |σ| ≥ 1.
If σ ⊆ UnObs then C is said to be a livelock. If, in
addition, s1 ̸⇒ then C is called a strong livelock (a
terminal cycle). Otherwise it is called a weak livelock.
If s ̸⇒ for s ∈ (Γ\F), only a dead state or a strong livelock
are reachable from s. In this paper we assume that a strong
livelock behavior is equivalent to a deadlock. These two
behaviors are not distinguished and both are called deadlock.
Consequently, if we want to check whether a given state s
is a dead state or not, we need to check wether the predicate
s ̸⇒ holds or not. We say that we are interested in the
observed behavior of s: (1) could s lead to the ﬁring of
some observed transitions in the future? (2) could s lead
to a ﬁnal state in the future? For this purpose, a virtual
observed action, called term, is added to the observed actions
Obs, it mentions that the system terminates proprely. The
Observed behavior, namely λ, is then deﬁned as a particular
mapping applied to the set of states of a LTS as follows:
Deﬁnition 2 (Observed behavior mapping):
Let T = ⟨Γ,Obs∪UnObs,→,I,F⟩ be a LTS. We deﬁne:
1) λT : Γ → 2Obs
λT (s) =





(Enable(Sat(s))∩Obs)∪{term}
if F ∩Sat(s) ̸= /0
(Enable(Sat(s))∩Obs) otherwise
2) λ∩
T : 2Γ → 2Obs
λ∩
T (S) = T
s∈S λT (s)
3) λ⊆
T : 2Γ → 22Obs
λ⊆
T (S) = {λ∩
T (Q) | /0 ⊂ Q ⊆ S}
4) λmin
T
: 2Γ → 22Obs
λmin
T (S) = {X ∈ λ⊆
T (S) |̸ ∃Y ∈ λ⊆
T (S) :
Y ⊂ (X \
{term})}
Informally, for each state s of a LTS T , (1) the observed
behavior of s, λT (s), stands for the set of observed actions
which can be executed from s, possibly via a sequence of
unobserved actions. In addition, term is a member of λT (s) if
and only if a ﬁnal state is reachable from s using unobserved
actions only. (2) The observed behavior λ∩
T associated with
a set of states S is the intersection of the observed behaviors
of its elements. It contains the set of observed actions that
are possible from each state of S. (3) λ⊆
T (S) is a set of sets
of observed actions such that each is the result of λ∩
T applied
to a nonempty subset Q of S. (4) Finally, λmin
T (S) contains
the minimal subsets of λ⊆
T (S) w.r.t. the inclusion relation
not concerning the term action. For instance, if there exist
two states s,s′ ∈ S such that λ(s) = /0 and λ(s′) = {term},
then both subsets would appear as elements of λmin
T (S). This
allows to distinguish whether a dead state or a ﬁnal state is
reached in S (in this case both kinds of state are reachable).
Thanks to the observed behavior, the deadlock freeness of
a LTS can be reduced to check whether there exists a state
s such that λT (s) contains the empty set. Similarly, a ﬁnal
state is reachable from a given state s iff term belongs to its
observed behavior.
156
Copyright (c) IARIA, 2012.     ISBN: 978-1-61208-181-6
eKNOW 2012 : The Fourth International Conference on Information, Process, and Knowledge Management

Running example :
We use an example of two business processes (taken from
[9]), the trip reservation and the costumer, to illustrate the
problem raised in this work. Figure 1(a) illustrates the WF-
net associated with the trip reservation’s process while Fig-
ure1(b) illustrates the WF-net associated with a costumer’s
process. The corresponding LTSs contain 13 nodes and 36
edges, and 4 nodes and 4 edges, respectively. We choosed
such two examples in order to illustrate how SOG-based
approach depends on the number of observed actions. In
fact, the ﬁrst contains a big proportion of unboserved actions
(17/21), while, in the second all actions are observed. The
two processes can collaborate (using dashed transitions) in
order to form an IEBP.
p0
p1
p2
p3
p4
p5
p6
p7
p8
p9
p10
p11
p12
p13
p14
p15
p16
p17
p18
p19
getinit
checkcc
t1
t2
re ject
confirmrec
flightre
hotelres
t3
t4
t5
t6
t7
t8
t9
t10
accept
buildtrip
scheduletrip
billcc
account
(a) WF-net of trip reservation
p′
0
p′
1
p′
2
p′
3
getinit
reject
accept
scheduletrip
(b) WF-net of customer
Figure 1.
The WF-nets of a trip reservation and a costumer
III. SOG : SYMBOLIC OBSERVATION GRAPH
In this section, we recall the formal deﬁnition of a SOG
associated with a LTS. We ﬁrst deﬁne what is an aggregate:
a node of the SOG. Compared to the ﬁrst deﬁnition of
SOGs (see [5]), the aggregates are here completed with the
observed behavior of the hidden states. We will establish
that this is the sufﬁcient and necessary information allow-
ing to detect possible deadlock states that can appear by
composition. Recall that the deadlock freeness property is
not preserved by composition: two deadlock free processes
could lead, after composition, to a composite process with
a dead state.
Deﬁnition 3 (aggregate):
Let T = ⟨Γ,Act,→,s0,F⟩ be a labeled transition system
with Act = Obs∪UnObs. An aggregate is a couple a = ⟨S,λ⟩
deﬁned as follows:
1) S is a nonempty subset of Γ s.t. s ∈ S ⇒ Sat(s) ⊆ S;
2) λ = λmin
T (S).
Informally, an aggregate a is deﬁned as a couple (S,λ)
where a.S is its set of states (connected with unobserved ac-
tions) and a.λ its observed behavior. The observed behavior
associated with an aggregate a can help to know whether
a contains a dead state (/0 ∈ a.λ) as well as whether a ﬁnal
state belongs to a (∃S′ ⊆ a.λ s.t. term ∈ S′). In Section V,
we propose a symbolic (set-based) algorithm allowing to
efﬁciently compute the observed behavior of an aggregate.
Deﬁnition 4 (Symbolic Observation Graph):
A
symbolic
observation
graph
SOG(T )
associated
with a LTS T = ⟨Γ,Obs∪UnObs,→,I,F⟩ is a LTS
⟨A,Act′,→′,I′,F′⟩ such that:
1) A is a ﬁnite set of aggregates s.t.:
a) There is an aggregate a0 ∈ A s.t. a0.S = Sat(I);
b) For each a ∈ A and for each o ∈ Obs the set {s′ ̸∈
a.S | ∃s ∈ a.S,s
o
−→s′} is not empty if and only if
it is a pairwise disjoint union of nonempty sets
S1 ...Sk and for i = 1...k, there is an aggregate
ai ∈ A s.t. ai.S = Sat(Si) and (a,o,ai) ∈→′;
c) For each aggregate a ∈ A, the a.λ attribute is
computed following Deﬁnition 3;
2) Act′ = Obs;
3) →′⊆ Γ′ ×Act′ ×Γ′ is the transition relation, obtained
by applying 1b;
4) I′ = {a0} (s.t. a0.S = Sat({I});
5) F′ = {a ∈ Γ′ | ∃Q ∈ a.λ;term ∈ Q}.
Point 1b of Deﬁnition 4 deserves explanation: Given an
aggregate a and an observed action o, the set of successors
obtained by ﬁring o from states of a.S is partioned in disjoint
subsets. For each of these subsets, there exists an aggregate
in the SOG obtained by saturation on the states of the subset.
For each such an aggregate a′ there exists an arc from a to
a′ labeled with o. Thus, the SOG is non deterministic: an
aggregate could have two successors by the same observed
transition.
The construction of a SOG following the deﬁnition can
be started by the initial aggregate a0, then the SOG will
be updated iteratively by adding new aggregates as long as
the condition (1.b) is satisﬁed. Clearly, this construction is
157
Copyright (c) IARIA, 2012.     ISBN: 978-1-61208-181-6
eKNOW 2012 : The Fourth International Conference on Information, Process, and Knowledge Management

not unique. One can take advantage of such a ﬂexibility
in order to obtain smaller aggregates (in terms of number
of states). Even if the obtained SOG would have more
aggregates in this case, it would consume less time and
memory. This deﬁnition generalises the one given in [1],
while the construction algorithm given in [5] is an example
of implementation where the obtained graph is deterministic.
Notice that, once the SOG is built, the set of states of each
aggregate has not to still be stored in memory any more. The
unique useful information is the observed behavior annoting
each node. A SOG is said to be deadlock free if none of
its nodes admits the empty set as a member of its observed
behavior.
The following proposition establishes that checking dead-
lock freeness of a SOG is equivalent to check deadlock
freeness on the associated process (represented by its LTS)
Proposition 1: Let W be a business process, let T =
⟨Γ,Act = Obs∪UnObs,→,I,F⟩ be the labeled transition
system of W and let G be a SOG of T . Then, W is deadlock
free if and only if G is deadlock free.
A0
λ : {{getinit}
A2
λ : {{term}}
A3
λ : {{term}}
A1
λ : {{reject}{accept}{scheduletrip}}
getinit
scheduletrip
re ject
accept
(a) A SOG of trip reservation
A′
0
λ : {{getinit}}
A′
3
λ : {{term}}
A′
2
λ : {{scheduletrip}}
scheduletrip
A′
1
λ : {{re ject}{accept}}
getinit
accept
reject
(b) A SOG of customer
Figure 2.
Two SOGs of the running example models
Figure 2 shows the two SOGs associated with the WF-
nets of Figure 1. Figure 2(a) illustrates the SOG of the
reservation trip model while Figure 2(b) shows the SOG
of the customer model. We note that the two SOGs are
deadlock-free: None of the aggregates of each SOG contains
a deadlock state. We recall that the reachabilty graphs of the
trip reservation and the customer models contain 13 nodes
and 36 edges, and 4 nodes and 4 edges, respectively. It is
clear, through this example, that bigger is the number of
observed actions, smaller is the size of the obtained SOG.
Especially, when all the actions of the service are observed,
the SOG is isomorphic to the reachabilty graph.
IV. COMPOSITION OF SOGS
In this section, we tackle the main idea of this paper:
Given two (ore more) business processes (each ignoring
internal details about the other), how to check that their
composition is deadlock free? We showed in the previous
section that the SOG can represent a good abstraction of
business processes on which the deadlock freeness property
can be checked. Here, we prove that they can also be used
in a compositional way: The composition of two SOGs can
be useful to check the correctness of the composition of the
underlying processes.
We propose to build the synchronized product of two (or
more) SOGs so that the obtained graph remains a SOG.
Now, the difﬁculty is to compute the observed behavior of
the synchronized product SOG. In fact, the states abstracted
by an aggregate are hidden (actually, they do not exist in
memory any more, once the SOG is built) and directly
computing their observed behavior is not possible. Thus,
given two aggregates a1 and a2 belonging to two different
SOGs, we propose to deduce the observed behavior of the
product aggregate, a = a1 ×a2, from those of a1 and a2.
Deﬁnition 5 (aggregate product):
Let Ti = ⟨Γi,Obsi ∪UnObsi,→i,Ii,Fi⟩,i = 1,2 be two LTSs.
Let ai = ⟨Si,λi⟩ be two aggregates of two associated SOGs.
The product aggregate a = ⟨S,λ⟩, denoted by = a1 ×a2, is
deﬁned by:
• a.S = a1.S×a2.S;
• a.λ = {(x ∩ y) ∪ (x ∩ (Obs1 \ Obs2)) ∪ (y ∩ (Obs2 \
Obs1)) | x ∈ a1.λ, y ∈ a2.λ}.
Notice that the term action is supposed to be shared by both
LTSs. Intuitively, an observed action is possible from a state
s = (s1,s2) in a = a1 ×a2 if it is observed in T1 and T2 and
possible from both states s1 and s2, or it is observed only
in T1 (resp. T2) and possible from s1 (resp. s2).
Deﬁnition 6 (SOG synchronized product):
Let Ti = ⟨Γi,Obsi,→i,Ii,Fi⟩,i = 1,2 be two SOGs. The
synchronized product of T1 and T2, denoted by T1 ×T2 is
the SOG ⟨Γ,Obs,→,I,F⟩ where:
1) Γ = Γ1 ×Γ2;
2) Obs = Obs1 ∪Obs2;
3) → is the transition relation, deﬁned by:
∀(a1,a2) ∈ Γ′ : (a1,a2)
o
−→(a′
1,a′
2) ⇔



a1
o
−→1a′
1 ∧a2
o
−→2a′
2
if o ∈ Obs1 ∩Obs2
a1
o
−→1a′
1 ∧a2 = a′
2
if o ∈ Obs1 \Obs2
a1 = a′
1 ∧a2
o
−→2a′
2
if o ∈ Obs2 \Obs1
4) I = I1 ×I2;
5) F = F1 ×F2.
Note: The set of aggregates Γ′ is reduced to the states that
are reachable from the initial aggregate.
The following proposition establishes that the syncronized
product of two SOGs is a SOG. This result combined with
Proposition 1 allows to reduce the deadlock freeness veri-
ﬁcation of an IEBP to the veriﬁcation of the synchronized
158
Copyright (c) IARIA, 2012.     ISBN: 978-1-61208-181-6
eKNOW 2012 : The Fourth International Conference on Information, Process, and Knowledge Management

product of the SOGs derived from its components.
Proposition 2: Let Wi, for i ∈ {1,2}, be two business pro-
cesses, whose IEBP is W , and let Ti be their corresponding
LTSs. Let Gi be a SOG associated with Ti with respect to the
set of observed actions Obsi, and let G be the synchronized
product of Gi. Then G is a SOG of the W ’s LTS with respect
to Obs1 ∪Obs2.
A0A′
0
λ : {{getinit}
A3A′
2
λ : {{∅}}
A3A′
3
λ : {{term}}
A1A′
1
λ : {{accept}{reject}}
getinit
accept
reject
(a) the SOG synchronized product
Figure 3.
the SOG synchronized product
Figure 3 illustrates the SOG obtained by synchronizing
the SOGs of Figure 2. We note that it contains a deadlock
aggregate A3A′
2 although A3 and A′
2 are deadlock-free. In
fact, {term}∩{scheduletrip} = /0.
V. IMPLEMENTATION AND EXPERIMENTAL RESULT
A. Implementation
The construction of the original version of SOG has been
already implemented in [5] and a model checker of Linear
Temporal Logic formulae based on SOGs was proposed
in [6]. In this work, we adapted the existing tool to the
context of composition of business processes. Thus, the
main task was to adapt the construction of the SOG so
that the observed behavior [2] is computed for each new
aggregate. A direct implementation of the observed behavior
of a given aggregate (following Deﬁnition 3) implies to
consider each state belonging to the aggregate separately.
This would considerably decrease the efﬁciency of the
approach. In fact, each aggregate is encoded with a BDD
and all the operations manipulating the aggregates should
be based on set operations. Therefore, we have implemented
an algorithm (see Algorithm 1) for the computation of the
observed behavior that is exclusively based on set operations
applied to the states of a given aggregate.
The input of Algorithm 1 are an aggregate A, the set of
observed transitions Obs, the set of unobserved transitions
UnObs and the ﬁnal set of states F. It computes the observed
behavior associated with the aggregate A (i.e., A.λ).
We use a map (called R) whose elements are couples of
sets of events and sets of states (line 1). Each element (O,S)
satisﬁes the following: each state of S enables each transition
of O. This map is progressively updated so that, at the end
of the algorithm, the set of its keys (the ﬁrst element of
Algorithm 1 Computing the Observed Behavior
Require: AgregateA,Obs,UnObs,SetofstatesF
Ensure: A.λ
1: Map < Set of events,Set of states > R
2: if F ∩A.S ̸= /0 then
3:
insert ({term},Pred(F,A.S,UnObs))inR
4: end if
5: for o ∈ Obs do
6:
if Enable(A.S,o) ̸= /0 then
7:
insert ({o},Enable(A.S,o)) in R
8:
end if
9: end for
10: for (O,S) ∈ R do
11:
for (O′,S′) ∈ R do
12:
if S = S′ then
13:
(O,S) ← (O∪O′,S)
14:
remove (O′,S′) from R
15:
end if
16:
end for
17: end for
18: λ ← Set of keys of R
19: Set of statesE ← /0
20: for t ∈ (Obs∪UnObs) do
21:
E ← E ∪Enable(S,t)
22: end for
23: if E ̸= S then
24:
λ ← λ∪{/0}
25: else
26:
if (PreIm∗(Enable(A.S,Obs) ∪ (F ∩ A.S),UnObs) ̸=
A.S) then
27:
λ ← λ∪{/0}
28:
end if
29: end if
30: return λ
the couples) form the observed behavior of the aggregagte
A (line 18). The ﬁrst step of the algorithm (lines 2 − 4)
consists in: (1) checking whether a ﬁnal state belongs to
A.S, (2) if it is the case creating a new couple ({term},S)
where S is the set of the immediate predecessors of the ﬁnal
states present in A. The latter task is performed by using the
PreIm() function. The second step of the algorithm (lines
5 − 9) allows to ﬁll the map R with couples of the form
({o},S) where o is an observed action and S the subset
of states of A enabeling o. Once the map R is ﬁlled, it is
analysed in the third part of the algorithm (lines 10 − 17).
The idea is to look between elements of R those having the
same enabling sets of states (the second component of each
couple). For each pair (O,S) and (O′,S) in R the ﬁrst couple
is updated by adding O′ to O while the second is removed
from the map. Indeed, states in S enable each action in O
or in O′ and should be associated with the set O∪O′.
The ﬁnal part of the algorithm (lines 19−29) is dedicated
159
Copyright (c) IARIA, 2012.     ISBN: 978-1-61208-181-6
eKNOW 2012 : The Fourth International Conference on Information, Process, and Knowledge Management

Model
Places
Trans
Obs
RG
OG
SOG
States
Edges
States
Edges
time(s)
States
Edges
time(s)
C
18
11
4
26
66
12
20
<1
5
4
<1
SC
15
9
4
11
11
9
11
<1
7
7
<1
OS
15
8
8
10
10
12
17
<1
10
10
<1
R
38
33
17
28
33
369
14 e2
<1
17
17
<1
Ph5
36
16
10
417
10 e2
14 e2
34 e2
16
297
721
8
Ph6
43
19
12
14 e2
46 e2
61 e2
17 e3
245
991
28 e2
42
Ph7
50
22
14
52 e2
19 e3
26 e2
88 e3
42 e2
33 e2
11 e3
162
Ph10
71
31
20
23 e5
23 e4
-
-
-
12 e4
58 e4
15 e2
Ph10
71
31
4
23 e5
23 e4
-
-
-
21
50
15
Table I
EXPERIMENTAL RESULTS: OG VS. SOG
to the analysis of the deadlock states inside the aggregate A.
If a deadlock state is found in A.S then the empty set is added
to λ. A terminal state is detected (lines 19−24) when the set
of states enabling some transition (observed or not) is not
equal to the whole set A.S. In order to detect strong livelocks
(terminal cycles), we iterate on the PreIm() function in order
to compute all the states in A.S that possibly lead either
to a state in Enable(A.S,Obs) (i.e., a state enabling some
observed action), or to a ﬁnal state. If the result is not equal
to A.S then there is a terminal cycle in A and the empty set
should belong to A.λ (line 26−27).
In addition to the implementation of the observed be-
haviour algorithm, we integrated new functionnalities to
allow the abstraction and the composition of business pro-
cesses: Given a WF-net description of one or more business
processes, it is possible to check the deadlock freeness
property on the ﬂy by building the correspondig SOG. The
user can choose to stop the construction of the SOG as soon
as a deadlock state is reached, or not. In the last case a
textual description of the whole SOG is supplied.
B. Experimental results
We used our implementation in order to build the SOG
associated with several business processes from different
domains. We do not describe these models here because
of lack of place but we give their WF-net models’ size
(in terms of number of places and transitions) as well as
the size of their reachability state graphe RG (in terms of
number of nodes and arcs) in Table I. These models were
also supplied to Wendy ([10]), a tool to analyse interacting
open nets. One of the fonctionalities of Wendy is to build
the Operating Guideline [3], an annotated automata, in order
to abstract a model and to check compatibility between two
models (i.e., whether two models can collaborate safely).
The corresponding results are illustrate in Table I (column
OG)
The obtained results show clearly that SOGs-based ap-
proach outperforms than the operating guidelines-based one.
The SOG is always (at least for the tested examples) smaller
than the operating guideline graph and its construction faster.
It is interesting to notice that the size of the operating
guideline can be greater than the size of the reachability
graph. For instance, this is the case of the online shop
model (OS). The corresponding SOG is isomorphic to the
reachability graph since all the transitions are observed.
The SOG-based approach is especially efﬁcient for loosely
coupled models (with a few number of observed actions).
This can be easily noticed if we look to the two last lines of
Table I: at line 8 the 10 philosophers model is obtained by
composition of 10 models (each represents one philosopher).
Each philosopher contains two observed transitions (those
allowing to pick up the forks) and the total number of
observed transitions is 20 over 31. In the last line, however,
this model is obtained by composing only two models,
each representing ﬁve philosophers and contains 2 observed
transitions (thus 4 observed transitions over 31). In this case
the size of the SOG is negligible comparing to the ﬁrst case.
In both cases Wendy is not able to supply the result because
of the explosion of the corresponding state space.
VI. RELATED WORK
The importance of dealing with business processes on one
hand and business process composition on the other hand is
reﬂected in the literature by several publications. Below, we
discuss some related approaches.
The public-to-private approach introduced by W. van der
Aalst in [12] consists of three steps. Firstly, the organizations
involved agree on a common and sound public workﬂow,
which serves as a contract between these organizations.
Secondly, each task of the public workﬂow is mapped onto
one of the domains (i.e., organization). Each domain is
responsible for a part of the public workﬂow, referred to its
public part. Thirdly, each domain can now make use of its
autonomy to create a private workﬂow. To satisfy the correct-
ness of the overall inter-organizational workﬂow, however,
each domain may only choose a private workﬂow which
is a subclass of its public part [13]. The public-to-private
approach allows to the local processes to be decoupled as
much as possible and to have some degree of understanding
about the nature of the interaction between the processes of
160
Copyright (c) IARIA, 2012.     ISBN: 978-1-61208-181-6
eKNOW 2012 : The Fourth International Conference on Information, Process, and Knowledge Management

the different business partners. A problem to be encountered
by this approach is conﬁdentiality that prevents a complete
view of local workﬂow. Indeed, to check the deadlock
property, one needs the model of the global workﬂow. This
model however is often not available for inter-organizational
workﬂows since organizations are not willing to disclose
their workﬂows ( e.g., for privacy reasons). Therefore, our
technique that abstracts local workﬂows using SOGs is well
suited to verify properties and preserve organization privacy.
In [7], a formal model for services called service au-
tomota is deﬁned by P. Massuthe and K. Schmidt. Based
on this representation, the authors combine all the well-
interactions between a service and its determinitic partners
on an annotated automaton called Operating Guideline. This
automaton characterizes all services wich interact properly
with the corresponding service. This approach of abstraction
was extended to composition of web services by P. Massuthe
and K. Wolf in [8], allowing publishers on the web to
maintain privacy of the services and to present only the
essential behavior information for matching. Authors give a
matching algorithm that can be applied between an operating
guideline and a web service model and check whether the
matching is possible or not.
Another approach for workﬂow matchmaking was pro-
posed by A. Martens in [9]. It assumes that two workﬂows
match if they are equivalent. To reach this end, the author
introduces the notion of communication graph c-graph and
usability graph (u-graph). If the u-graph of a workﬂow is
isomorphic to the c-graph of another workﬂow, then the two
workﬂows are considered equivalent.
In conclusion, to the best of our knowledge, none of
the existing approaches combine symbolic (using BDDs)
abstraction and modular veriﬁcation to check the correctness
of inter-organizational processes. They always deal with
an explicite representation of the system’s behavior, which
accentuate the state space explosion problem.
VII. CONCLUSION
The main emphasis of this paper is on composition of
business processes using symbolic observation graphs: How
can we compose extended SOGs such that the resulting SOG
is still small but represents the behavior of the IEBP in an
appropriate way? We addressed the problem of checking
correctness of IEBPs compositionally. We established that
and how symbolic observation graphs can be extended and
efﬁciently used for that purpose. We implemented the pre-
sented approach and compared the obtained results against
the operating guidelines approach. The obtained results
conﬁrms our belief that the SOG is a suitable abstraction
of business processes that offers, in addition, interesting
analysis capabilities.
Our future work will be on studying other correction
criteria (e.g., soundness) by depicting the necessar local
information (like we did wit the observed behavior) to be
stored (within each aggregate) so that the desired property
can be checked on the composition of the obtained SOGs.
We also plan to extend our approach to deal with resources.
REFERENCES
[1] K. Klai, S. Tata and J. Desel Symbolic Abstraction and Dead-
lock Freeness Veriﬁcation of Inter-Enterprise Processes, In
Proceedings of the 29th International Conference On Business
Process Management, Ulm, Germany, September 2009, 294–
309, Springer-Verlag.
[2] K. Klai, S. Tata and J. Desel Symbolic Abstraction and
Deadlock-Freeness Veriﬁcation of Inter-Enterprise Processes,
In Journal of Data & Knowledge Engeneering (DKE), 2011.
[3] N. Lohmann, P. Massuthe and K. Wolf Operating Guidelines
for Finite-State Services, In Proceedings of Petri nets’07,
Siedlce, Poland, June 25-29, 2007, 321-341, Springer-Verlag,
Berlin, Heidelberg
[4] J. Koehlerand B. Srivastava Web Service Composition: Current
Solutions and Open Problems, ICAPS 2003 Workshop on
Planning for Web Services, pages 28 - 35.
[5] S. Haddad, JM. Ili´e and K. Klai Design and Evaluation of a
Symbolic and Abstraction-based Model Checker, In Proceed-
ings of Automated Technology for Veriﬁcation and Analysis:
Second International Conference, ATVA 2004, Taipei, Taiwan,
October 31-November 3, 2004,198–210, Springer LNCS 3299
[6] K. Klai and D. Poitrenaud MC-SOG: An LTL Model Checker
Based on Symbolic Observation Graphs, In Proceedings of
Petri Nets’08, Xian, China 2008, 288–306, Springer LNCS,
5062
[7] P. Massuthe and K. Schmidt Operating Guidelines for Services,
In Proceedings of 12. Workshop ”Algorithmen und Werkzeuge
fr Petrinetze” September, 2005, 78–83
[8] P. Massuthe and K. Wolf An Algorithm for Matching Nonde-
terministic Services with Operating Guidelines, International
Journal of Business Process Integration and Management 2007,
Vol. 2, 81 - 90
[9] A. Martens Usability of web services, In Proceedings of the
Fourth international conference on Web information systems
engineering workshops, 2003, Roma, Italy, 182–190, IEEE
Computer Society
[10] N. Lohmann and D. Weinberg Wendy: A Tool to Synthesize
Partners for Services, In Proceedings of Petri Nets’ 10, Braga,
Portugal, June, 2010, 297-307
[11] W. Van der Aalst The Application of Petri Nets to Workﬂow
Management, In Journal of Circuits, Systems, and Computers
1998, 21-66
[12] W. van der Aalst Loosely Coupled Interorganizational Work-
ﬂows: Modeling and Analyzing Workﬂows Crossing Organiza-
tional Boundaries, In Journal of Information and Management,
2000, 67-75
[13] W.
van der Aalst and M.
Weske,The P2P Approach to
Interorganizational Workﬂows, In Proceedings of the 13th
International Conference on Advanced Information Systems
Engineering, 2001, 140-156
161
Copyright (c) IARIA, 2012.     ISBN: 978-1-61208-181-6
eKNOW 2012 : The Fourth International Conference on Information, Process, and Knowledge Management

