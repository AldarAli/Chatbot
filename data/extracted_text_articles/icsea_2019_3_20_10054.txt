From a Subset of LTL Formula to B¨uchi Automata
Bilal Kanso
Lebanese University
Faculty of sciences (V), Computer Science Department
Email: bilal_kanso@hotmail.com
Ali Kansou
Lebanese University
Faculty of sciences (V), Computer Science Department
Email: ali.kansou@gmail.com
Abstract—We present a fragment of Linear Temporal Logic (LTL)
together with an polynomial translation of formula from this
LTL fragment into equivalent B¨uchi automata. The translation
is completely implemented based on Java Pluging Framework in
GOAL Tool as a plugin. The implementation is mainly based
on pre-proven theorems such that the transformation works
very efﬁciently. In particular, it runs in polynomial space in
terms of the length of the given formula. The main application
of this transformation could be in model checking area which
consists in obtaining a B¨uchi automaton that is equivalent to the
software system speciﬁcation and another one that is equivalent
to the negation of the property. The intersection of the two
B¨uchi automata is empty if the model satisﬁes the property.
Furthermore, the experiments are performed with three sets of
LTL formula, which is commonly used in the literature and the
result shows that our proposed LTL fragment covers most of
them.
Keywords–Linear Temporal Logic; B¨uchi automata; Model
checking; Compositional modeling.
I.
INTRODUCTION
The Linear Temporal Logic (LTL) [1] becomes increas-
ingly one of the most important formalisms to model system
properties which are widely used in different areas such as
model checking [2][3], testing [4][5], reasoning event in time,
etc. It is equivalent to ﬁrst-order logic over ﬁnite and inﬁnite
words. It is well-known that model checking and satisﬁability
for LTL are PSPACE-complete and in most all cases the model
checking problem is equivalent to a satisﬁability-checking
problem. This justiﬁes why the satisﬁability problem for LTL
and its fragments has received so much attention. By way
of illustration, model checking based on LTL formalism is
PSPACE-hard [6][7]. This complexity arises from the transla-
tion step of the negation of a property (described as a LTL
formulæ) into B¨uchi automata. Indeed, the B¨uchi automaton
of a property is constructed in exponential space in the length
of this property. This makes veriﬁcation methods hard or
even impossible to be implemented in practice and makes
the scalability of the LTL model checking limited, which
commonly referred to as the state explosion problem [8].
The question we handled is there some LTL fragments
that are feasible in practice. In this paper, we contribute to
ﬁnding a subset of LTL properties that can be converted
polynomially into B¨uchi automata. A fragment called, FLTL
Logic, is deﬁned and how formula in this fragment can be
transformed into B¨uchi automata whose the state space size
is linear is shown. This fragment is identiﬁed by looking
for natural subclasses of LTL formula for which complexity
decreases and by deep understanding of what makes the
converting into B¨uchi automata PSPACE-complete. Thanks to
the structure of our fragment FLTL formulæ, the proposed
algorithm can be compositional in the sense that the target
B¨uchi automaton associated to a given formulæ is obtained
by developing a sub-automaton for each sub-formulæ of the
principal formulæ. Hence, the basic idea for developing the
ﬁnal automaton for a FLTL formulæ ϕ is that ϕ can be
recursively decomposed into a set of sub-formula, arriving at
sub-formula that can be completely handled. Composition is
then used for assembling different sub-automaton and then
forming larger ones. Such a composition can be seen as an
operation taking sub-automata for sub-formula, as well as the
FLTL operator to provide a new more complex automaton.
Furthermore, we showed by experiments that the fragment
coverage average is 65.531% which is acceptable and slightly
high and the use of such fragments seems promising. The
experiments are based on three common sets of LTL formula
widely used in the literature. For each set, we identify the
formula which can be described in the extension and generate
its equivalent automata using the proposed algorithm.
The rest of this article is organized as follows: Section II
brieﬂy describes B¨uchi automata. In Section III, we describe
our fragment of LTL logic and the reasons to choose it. In
Section IV, we present for each formulæ in our fragment
LTL, its equivalent B¨uchi automata. Section V shows the
ﬁnal algorithm that generates to any formulæ in our fragment
an equivalent B¨uchi automaton. Section VI represents the
experiments we conducted to compute the coverage average of
our LTL fragment. Section VII presents the related work and
Section VIII presents the conclusion and some future works.
II.
B ¨UCHI AUTOMATA
A B¨uchi automaton is variant of non-deterministic ﬁnite-
state automata on inﬁnite inputs [9]-[10]. A word is accepted
if the automaton goes through some designated ”accept” states
inﬁnitely often while reading it. Formally, a B¨uchi automaton
is deﬁned by a 5-tuple A = (S, s0, F, Σ, δ) where S is a ﬁnite
set of states, s0 ∈ S is the initial state, Σ is a non-empty set of
atomic propositions, F ⊆ S is a ﬁnite set of accepting states
and δ : S × Σ −→ 2S is a transition function. A run of A on
σ = σ(0)σ(1)σ(2) · · · ∈ Σω is an inﬁnite sequence of states
s0s1s2 · · · ∈ Sω starting with the initial state s0 of A such that
∀i, i ≥ 0, si+1 ∈ δ(si, σ(i)). A run s0s1s2 . . . is accepting by
an automaton A if A goes through accepting states (i.e ∈ F)
inﬁnitely often while reading it. The accepted language of a
B¨uchi automaton A, denoted by, Lω(A) is then deﬁned by
Lω(A) = {σ ∈ Σω | there is an accepting run for σ in A}.
The union of two B¨uchi automata A1 and A2 is formally
deﬁned as follows:
61
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

Deﬁnition 1 (Buchi automata union): Let
A1
=
(S1, s10, F1, Σ, δ1) and A2
=
(S2, s20, F2, Σ, δ2) be two
B¨uchi automata. The union A1 ∪ A2 of A1 and A2 is the
B¨uchi automaton A = (S, s0, F, Σ, δ) deﬁned as follows:
•
S = S1 ∪ S2 ∪ {s0}
•
s0 ∈ S is the initial state
•
F = F1 ∪ F2
•
the transition relation δ is deﬁned as follows:
δ(s, p) =





δ1(s, p) if s ∈ S1
δ2(s, p) if s ∈ S2
δ1(s10, p) ∪ δ2(s20, p) if s is the initial
state s0
In Deﬁnition 1, we add a new initial (nonaccept) state snew
to the union set of states of both A1 and A2and the transitions
snew
p
−→ s if and only if s0
A1
p
−→ s and snew
p
−→ s if
and only if s0
A2
p
−→ s to the union set of transitions of both
A1 and A2.
The construction of the intersection automaton works a little
differently from the ﬁnite state automata case. One needs to
check whether both sets of accepting states are visited inﬁnitely
often. Consider two runs r1 and r2 and a word σ where r1
goes through an accept state after σ(0), σ(2), . . . and r2 enters
accept state after σ(0)σ(3) . . . . Thus, there is no guarantee that
r1 and r2 will enter accept states simultaneously. To overcome
this problem, we need to identify the accept states of the
intersection of the two automata. To do so, we create two
copies of the intersected state space. In the ﬁrst copy, we check
for occurrence of the ﬁrst acceptance set. In the second copy,
we check for occurrence of the second acceptance set. When
a run enters a ﬁnal state in the ﬁrst copy, we wait for that
run also enters in an accept state in the second copy. When
this is encountered, we switch back to the ﬁrst copy and so
on. We repeat jumping back and forth between the two copies
whenever we ﬁnd an accepting state.
Deﬁnition 2 (Buchi automata intersection): Let
A1
=
(S1, s10, F1, Σ, δ1) and A2
=
(S2, s20, F2, Σ, δ2) be two
B¨uchi automata. The intersection A1 ∩A2 of A1 and A2 is the
B¨uchi automaton A = (S, s0, F, Σ, δ) deﬁned as follows:
•
S = S1 × S2 × {1, 2}
•
s0 = (s10, s20, 1)
•
F = S1 × F2 × {2}
•
The transition function δ is deﬁned as follows:
δ((s1, s′
1, 1), p) =







(s2, s′
2, 1) if s2 ∈ δ1(s1, p),
s′
2 ∈ δ2(s2, p) and s1 ̸∈ F1
(s2, s′
2, 2) if s2 ∈ δ1(s1, p),
s′
2 ∈ δ2(s2, p) and s1 ∈ F1
δ((s1, s′
1, 2), p) =









(s2, s′
2, 2) if s2 ∈ δ1(s1, p),
s′
2 ∈ δ2(s2, p) and s′
1 ̸∈ F2
(s2, s′
2, 1) if s2 ∈ δ1(s1, p),
s′
2 ∈ δ2(s2, p) and s′
1 ∈ F2
Theorem 1: Let ψ = ϕ1∨ϕ2 (resp. ψ = ϕ1∧ϕ2) be a LTL
formulæ and Aϕi be the B¨uchi automaton equivalent to ϕi for
i = 1, 2. Let Aψ be the LTL automaton built according to
Deﬁnition 1 (resp. Deﬁnition 2). Then, Words(ψ) = Lω(Aψ)
(See Proof in Appendix)
III.
FLAT LTL LOGIC
In this section, we introduce our subset of LTL logic that
we call FLTL Logic. This fragment will be used to express
temporal properties and then translate them into B¨uchi au-
tomata in linear size. The syntax of our FLTL logic adds
to usual boolean propositional operators ¬ (negation) and ∧
(conjunction), some modal operators that describe how the
behavior changes with time. Next: Xϕ requires that the formula
ϕ be true in the next state. Until: ϕ1 U ϕ2 requires that the
formula ϕ1 be true until the formula ϕ2 is true, which is
required to happen. Eventually: ♦ϕ requires that the formula
ϕ be true at some point in the future (starting from the
present) and it is equivalent to ♦ϕ ≡ true U ϕ. Always:
□ϕ requires that the formula ϕ be true at every point in the
future (including the present). Release: ϕ1 R ϕ2 requires that
its second argument ϕ2 always be true, a requirement that is
released as soon as its ﬁrst argument ϕ1 becomes true. It is
equivalent to ϕ1 R ϕ2 ≡ ¬(¬ϕ1 U ¬ϕ2).
A. Our fragment LTL logic
Deﬁnition 3 (FLTL formulæ): The set of FLTL formulæ
Lf is given by the following grammar:
ϕ:=Θ |□Θ |Θ U ϕ |ϕ R Θ |Xϕ |¬∆ |ϕ1 ∧ ϕ2 |ϕ1 ∨ ϕ2
where
Θ
is
a
propositional
formula
deﬁned
by:
Θ:=true |p |¬Θ |Θ1 ∧ Θ2
and ∆ is the formula deﬁned
by:
∆:=∆ U Θ |Θ R ∆ |Xϕ |¬∆ with p ∈ Σ.
For the sake of brevity and the lack of space, we only
discuss here why the fragment Θ U ϕ is included within our
LTL fragment to the detriment of both formula ϕ1 U ϕ2 and
ϕ1 U Θ. It is well-known the size of an B¨uchi automaton A that
recognizes the complement language Lω(A) of the language
accepted Lω(A) by an automaton A is exponential [11], [12].
Suppose we have separately built an automaton A1 for ϕ1 and
an automaton A2 for ϕ2, and let us then try to compositionally
obtain the resulting automaton A for ϕ. According to the until
operator’s semantics, it is required that ϕ holds at the current
moment, if there is some future moment for which ϕ2 holds
and ϕ1 holds at all moments until that future moment. That
means constructing the automaton for ϕ = ϕ1 U ϕ2 ﬁrstly
requires constructing of the intersection of A1 and A2. As
stated previously, computing A2 is exponential and therefore,
constructing the B¨uchi automaton for ϕ U ϕ2 is exponential.
To avoid this kind of formula, we choose the formulæ Θ U ϕ
to be a part of our LTL subset where the construction of the
B¨uchi automaton associated to it, does not need to complement
any B¨uchi automaton.
B. Positive Normal Form (FPNF)
As LTL formula, FLTL formula can be transformed into
the so-called Positive Normal form (FPNF). This form is
characterized by the fact that negations only occur adjacent to
atomic propositions. All negation symbols of the given LTL
formula have to be pushed inwards over the temporal operators.
Deﬁnition 4 (FPNF): The set of FLTL Positive Normal
Form (FPNF) formulæ LF P NF is given by the following
grammar:
ϕ:=true |p |¬p |ϕ1 ∧ ϕ2 |ϕ1 ∨ ϕ2 |□Θ |Θ U ϕ |ϕ R Θ |Xϕ
62
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

Each formulæ ϕ ∈ Lf, can be transformed into a for-
mulæ ϕ′ ∈ LF P NF . This is done by pushing negations inside,
near to atomic propositions. To do this, we use the following
transformation rules:
¬true ⇝ false, ¬¬ϕ ⇝ ϕ, ¬(ϕ1 ∧ ϕ2) ⇝ ¬ϕ1 ∨ ¬ϕ2, ¬Xϕ ⇝
X¬ϕ, ¬(ϕ U Θ) ⇝ ¬ϕ R ¬Θ, ¬(Θ R ϕ) ⇝ ¬Θ U ¬ϕ.
Theorem 2: For any FLTL formulæ ϕ ∈ Lf, there exists
an equivalent LTL formula ϕ′ ∈ LF P NF |ϕ′| = O(|ϕ|).
C. Semantics
The semantics of FLTL formulæ is deﬁned over inﬁnite
sequences σ : N −→ 2Σ (2Σ is the power set of Σ).
In other words, a model is an inﬁnite sequence A0A1 . . .
of subsets of Σ. The function σ, called interpretation func-
tion, describes how the truth of atomic propositions changes
as time progresses. For every sequence σ, we write σ =
(σ(0), . . . , σ(n), . . . ). Thus, σ(i) denotes the state at index
i and σ(i : j) the part of σ containing the sequence of states
between i and j. σ(i...) = AiAi+1Ai+2 . . . denotes the sufﬁx
of a sequence σ = A0A1A2 · · · ∈ (2Σ)ω starting in the (i+1)st
symbol Ai where ω denotes inﬁnity. We also write σ(i) |= ϕ
to denote that ”ϕ is true at time instant i in the model σ”. This
notion is deﬁned inductively, according to the structure of ϕ.
The FLTL formula are interpreted over inﬁnite sequences of
states σ : N −→ 2Σ as follows:
Deﬁnition 5 (Semantics of FLTL): Let σ : N −→ 2Σ be
an interpretation function and ϕ ∈ LF LT L. σ satisﬁes ϕ,
noted σ |= ϕ,is inductively deﬁned over the construction of ϕ
as follows:
•
ϕ = true, then σ |= true
•
if ϕ = p, then σ |= p iff p ∈ σ(0)
•
if ϕ = Xϕ′, then σ |= Xϕ′ iff σ(1) |= ϕ′
•
if ϕ = □Θ, then σ |= □Θ iff ∀i ≥ 0, σ(i) |= Θ
•
if ϕ = Θ U ϕ , then σ |= Θ U ϕ iff ∃i, i ≥
0, σ(i, . . . ) |= ϕ and ∀j, 0 ≤ j < i, σ(j...) |= Θ
•
if ϕ = ϕ R Θ , then σ |= ϕ R Θ iff ∃i, i ≥
0, σ(i, . . . ) |= ϕ and ∀j, j ≥ 0, σ(j...) |= Θ or ∃i, i ≥
0 (σ(i...) |= ϕ ∧ ∀k, k ≤ i, σ(k...) |= Θ)
•
if ϕ = ¬ϕ′ , then σ |= ¬ϕ′ iff σ ̸|= ϕ′
•
Propositional connectives are handled as usual
The semantics of a FLTL formulæ can be also seen as the
language Words(ϕ) that contains all inﬁnite words over the set
of atomic propositions (i.e. alphabet) 2Σ that satisfy ϕ. Thus,
the language Words(ϕ) for a FLTL formulæ ϕ is formally
deﬁned by Words(ϕ) = {σ ∈ (2Σ)ω | σ |= ϕ}.
Proposition 1: Two FLTL formula ϕ1 and ϕ2 are equiva-
lent, denoted ϕ1 ≡ ϕ2, if Words(ϕ1) =Words(ϕ2).
IV.
CONSTRUCTION OF B ¨UCHI AUTOMATA FOR FLTL
LOGIC
In the sequel, we explain for each subformulæ in our
fragment LTL logic how its equivalent B¨uchi automaton can
be obtained.
A. B¨uchi automata for Θ formula
The B¨uchi automaton associated to a propositional for-
mulæ Θ is obtained by creating two states s0 and s1 and two
transitions tr1 and tr2. s0 is the only initial state while s1 is
the only ﬁnal state. tr1 is the transition from s0 to s1 labeling
with Θ while the transition tr2 is a loop labeled with true over
the state s2.
Deﬁnition 6 (Θ automaton): Let Θ be a propositional for-
mulæ. The automaton AΘ = (SΘ, s0
Θ, FΘ, Σ, δΘ) associated
to Θ is deﬁned as follows:
•
SΘ = {s0, s1}, s0
Θ = s0, FΘ = {s1}
•
The transition function δ is deﬁned as follows:
δΘ(s0, Θ) = {s1} and δΘ(s1, true) = {s1}
B. B¨uchi automata for Θ U ϕ formula
The automaton associated to Θ U ϕ is obtained by adding
a new initial (nonaccept) state snew to the state set of Aϕ, a
loop over the added state snew labeled with the propositional
formula Θ and transitions snew
p
−→
s if and only if and
only if s0
p
−→
s with s0 is the initial state of Aϕ. All
other transitions of Aϕ, as well as the accept states, remain
unchanged. snew is the single initial state automaton, is not
accept, and has no incoming transitions except the loop one.
Deﬁnition 7 (Θ U ϕ automaton): Let Θ be a proposi-
tional formula and ϕ be an LTL ﬂat formulæ. Let Aϕ =
(Sϕ, s0
ϕ, Fϕ, Σ, δϕ) be the automaton associated to ϕ. The au-
tomaton Aψ = (Sψ, s0
ψ, Fψ, Σ, δψ) associated to ψ = Θ U ϕ
is deﬁned as follows:
•
Sψ = {snew} ∪ Sϕ
•
s0
ψ = snew, Fψ = Fϕ
•
The transition function δψ is deﬁned as follows:
δψ(s, p) =











δϕ(s, p) if s ∈ Sϕ (Aϕ transitions)
δϕ(s0
ϕ, p) if s = snew
(Connection initial state to Aϕ)
{snew} if s = snew and p = Θ
(Loop over the new initial state)
Example 1: Figure 1 illustrates the composition deﬁnition
of Θ U ϕ. Figure 1a shows the B¨uchi automaton associated
to (♦b) R c. To construct the B¨uchi automaton associated to
(a U (♦b R c)), we add a new state snew that we consider as
initial state. Then, for each transition outgoing from snew with
label l and goes to state s, we add a transition from snew to
the state s with a label l. Finally, we then add a loop labeled
with the atomic proposition a over the added state.
Theorem 3: Let ψ = Θ U ϕ, Aϕ be the B¨uchi automaton
equivalent to ϕ and Aψ be the automaton built according to
Deﬁnition 7. Then, Words(ψ) = Lω(Aψ).
C. B¨uchi automata for Xϕ formula
The automaton associated to Xϕ is obtained by adding two
new states snew (neither initial state or accept state) and sinit
(considered as the initial state) to the state set of Aϕ with
the following two transitions (1) add for any transition in Aϕ
which starts from the initial state s0 to a state s, a transition
from snew to s; (2) add a transition from the initial state sinit to
the snew labeled with true. All other transitions of Aϕ remain
63
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

s0
s1
s2
s3
b ∧ c
¬b ∧ c
¬b ∧ c
true
¬b ∧ c
b ∧ c
¬b ∧ c
¬b
b
(a) (♦b) R c
snew
s0
s1
s2
s3
b ∧ c
¬b ∧ c
¬b ∧ c
a
b ∧ c
¬b ∧ c
¬b ∧ c
true
¬b ∧ c
b ∧ c
¬b ∧ c
¬b
b
(b) a U (♦b R c)
Figure 1. Example of composition: Θ U ϕ
unchanged and ﬁnal states of Aϕ become accept ones of Aψ
and initial state of Aψ become the state sinit.
Deﬁnition 8 (Xϕ automaton): Let ϕ be an Flat LTL for-
mulæ. Let Aϕ = (Sϕ, s0
ϕ, Fϕ, Σ, δϕ) be the automaton equiv-
alent to ϕ. The automaton Aψ = (Sψ, s0
ψ, Fψ, Σ, δψ) equiva-
lent to ψ = Xϕ is deﬁned as follows:
•
Sψ = Sϕ ∪ {snew, sinit}
•
s0
ψ = sinit, Fψ = Fϕ
•
The transition function δ is deﬁned as follows:
δψ(s, p) =













δϕ(s, p) if s ∈ Sϕ (Aϕ transitions)
δϕ(s0
ϕ, p) if s = snew
(Connection snew to initial state of Aϕ)
{snew} if s = sinit and p = true
(Connection sinit to snew)
Example 2: Figure 2 illustrates the deﬁnition of Xϕ. Fig-
ure 2a shows the B¨uchi automaton associated to the for-
mulæ a U (Xb R c). To construct the B¨uchi automaton
equivalent to X(a U (Xb R c)), we add a new state snew and
for each transition tr starting from the initial state s0
ϕ to a state
s, a transition from snew to s with the same label. Finally, we
add the state sinit that we consider as initial and we connect
sinit to snew with a transition labeled with the true label.
Theorem 4: Let ψ = Xϕ, Aϕ be the B¨uchi automaton
equivalent to ϕ and Aψ be the LTL automaton built according
to Deﬁnition 8. Then, Words(Xϕ) = Lω(Aψ).
D. B¨uchi automata for ϕ R Θ formula
The formulæ ϕ R Θ informally means that Θ is true until
ϕ becomes true, or Θ is true forever. Thus, the construction of
a B¨uchi automaton for ϕ R Θ can be done by construction the
B¨uchi automaton associated to the fact that Θ is true until ϕ
s0
s1
s2
a
¬b ∧ c
c
true
b
(a) a U (Xb R c)
s0
snew
sinit
s1
s2
a
¬b ∧ c
c
true
a
c
b
true
(b) X(a U (Xb R c))
Figure 2. Example of composition: Xϕ formula
becomes true and the construction of a B¨uchi automaton asso-
ciated to the fact that Θ is true forever. Finally, make the union
between the two constructed B¨uchi automata. Consequently, to
build the B¨uchi automaton for ϕ R Θ, we need to add two new
states si and sf to the set of states of the automaton Aϕ. si
becomes the single initial state of the resulting automaton and
sf is added to set of ﬁnal states of the resulting automaton.
The following transitions are added to the set of transitions of
the resulting automaton:
•
Transitions si
p∧Θ
−→
s if and only if and only if
s0
p
−→ s where s0 is the initial state of Aϕ.
•
A loop over the added state si labeled with the
propositional formula Θ
•
A loop over the added state sf labeled with the
propositional formula Θ
•
A transition si
Θ
−→ sf
All other transitions of Aϕ, as well as the accept states, remain
unchanged.
Deﬁnition 9 (ϕ R Θ automaton): Let Θ be a proposi-
tional formula and ϕ be an LTL ﬂat formulæ. Let Aϕ =
(Sϕ, s0
ϕ, Fϕ, Σ, δϕ) be the automaton associated to ϕ. The au-
tomaton Aψ = (Sψ, s0
ψ, Fψ, Σ, δψ) associated to ψ = ϕ R Θ
is deﬁned as follows:
•
Sψ = {si, sf} ∪ Sϕ
•
s0
ψ = si, Fψ = Fϕ ∪ {sf}
•
The transition function δ is deﬁned as follows:
δψ(s, p) =























δϕ(s, p) if s ∈ Sϕ (Aϕ transitions)
δϕ(s0
ϕ, p′) if s = si and p = Θ ∧ p′
(Connection si to initial state of Aϕ)
{si, sf} if s = si and p = Θ
(Loop over si or connection si to sf)
{sf} if s = sf and p = Θ
(Loop over sf)
Example 3: Figure 3 illustrates the composition deﬁnition
of ϕ R Θ. Figure 3a shows the B¨uchi automaton associated
to the formulæ c U ♦b. To construct the B¨uchi automaton
associated to the LTL formulæ ((c U ♦b) R a), we add a
state si that we consider as the only initial state and a state sf
that we consider as a ﬁnal state. We add a loop labeled with
the atomic proposition a over the two added states. Finally, for
each transition outgoing from the initial state of the automaton
ϕ with label l and goes to state s, we add a transition from
the added state si to the state s with a label l ∧a. We also add
a transition labeled with a from the state si to the state sf.
64
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

s0
s2
s1
b
¬b
c
true
¬b
b
(a) c U ♦b
si
sf
s0
s2
s1
b
¬b
c
true
¬b
b
b ∧ a
c ∧ a
b ∧ a
a
a
a
(b) (c U ♦b) R a
Figure 3. Example of composition: ϕ R Θ
Theorem 5: Let ψ = ϕ R Θ, Aϕ be the B¨uchi automaton
equivalent to ϕ and Aψ be the LTL automaton built according
to Deﬁnition 9. Then, Words(ϕ R Θ) = Lω(Aψ).
E. B¨uchi for □Θ formula
The B¨uchi automaton associated to formulæ □Θ is ob-
tained by creating one state s0 and a loop over s0 labeling
with Θ.
Deﬁnition 10 (□ϕ automaton): Let Θ be an propositional
formulæ. The automaton associated to □Θ is deﬁned as
A□Θ = ({s0}, s0, {s0}, Prop, δ□Θ) where δ□Θ is deﬁned as
follows: δ□Θ(s0, Θ) = {s0}
V.
OUR ALGORITHM AND ITS IMPLEMENTATION
Our algorithm to build B¨uchi automata from FLTL formula
is compositional in the sense that the ﬁnal B¨uchi automaton
is obtained by developing a sub-automaton for each sub-
formulæ of the principal formulæ . Hence, the basic idea
for developing the ﬁnal automaton for a FLTL formulæ ϕ
is to explore the formulæ ϕ in a preorder traversal. That is
to say, we visit the root operator of ϕ ﬁrst, then recursively
do a preorder traversal of the left sub-formula, followed by a
recursive preorder traversal of the right formulæ . Algorithm 1
allows us to build a B¨uchi automaton for a positive FLTL
formula ϕ and uses the following ﬁve functions:
•
BuchiProp(Θ): takes as input a propositional formula
Θ and returns the automaton as deﬁned in Deﬁnition
6 (Section IV);
•
BuchiNext(BA): takes as input an B¨uchi automaton
BA and returns a B¨uchi automaton deﬁned according
to Deﬁnition 8 (Section IV);
•
BuchiEventuelly(BA): takes as input an B¨uchi au-
tomaton BA and returns a B¨uchi automaton deﬁned
according to Deﬁnition 7 (Section IV);
•
BuchiBinary(op, BAl, BAr): that takes as input ∧ or
∨ operator and two B¨uchi automata BAl and BAr
and returns a B¨uchi automaton deﬁned according to
deﬁnitions of ∧ and ∨ given in Section II;
•
BuchiUntil(Θ, BA): that takes as input a propositional
formula Θ and a B¨uchi automaton BA and returns the
automaton as deﬁned in Deﬁnition 7 (Section IV);
•
BuchiRelease(Θ, BA) that takes as input a proposi-
tional formula Θ and a B¨uchi automaton BA and
returns the automaton as deﬁned in Deﬁnition 9 (Sec-
tion IV).
•
BuchiAlways(Θ): takes as input a propositional for-
mula Θ and returns the automaton as deﬁned in
Deﬁnition 10 (Section IV);
Algorithm
1:
Generating
B¨uchi
automata:
GenerateBA(ϕ) for a FLTL formula
Name : GenerateBA
Input: a positive FLTL formulæ ϕ
Output: a B¨uchi automaton A;
if ϕ
instance of U then
return BuchiUntil(Left (ϕ),
GenerateBA (right (ϕ)));
else if ϕ
instance of R then
return BuchiRelease (right (ϕ),
GenerateBA (Left (ϕ)));
else if ϕ
instance of X then
return BuchiNext(GenerateBA (right
(ϕ)));
else if ϕ
instance of □ then
return BuchiAlways(ϕ);
else if ϕ
instance of ♦ then
return
BuchiEventuelly(GenerateBA (right
(ϕ)));
else if (ϕ
instance of ∨) or (ϕ
instance of
∧) then
if isPropositionnal (Left (ϕ)) and
isPropositionnal (right (ϕ) then
return BuchiProp (ϕ) ;
else if isPropositionnal (Left (ϕ)) then
return BuchiBinary (BuchiProp(Left
(ϕ)),GenerateBA (right (ϕ)) ;
else if isPropositionnal (right (ϕ)) then
return BuchiBinary (GenerateBA (Left
(ϕ),BuchiProp (right (ϕ))) ;
else
return BuchiBinary (BuchiProp(Left
(ϕ)),BuchiProp (right (ϕ))) ;
The proposed translation algorithm is very efﬁcient where
we can translate any FLTL formula ϕ of length n in time O(n)
with O(n) states. The trick is to eliminate from our translation
each step that could be exponential. As B¨uchi automata
complementation is exponential [11][12], our transformation
prohibit the use of complement B¨uchi automata operation and
requires to use only LTL formula with negation pushed to
atomic propsitions.
Theorem 6: For any FLTL formulæ ϕ ∈ Lf, there exists
an B¨uchi automaton Aϕ with |Aϕ| = O(|ϕ|) and if Aψ
is the B¨uchi automaton generated by Algorithm 1, then:
Words(ψ) = Lω(Aψ).
We implemented our algorithm within the Graphical Tool
for Omega-Automata and Logics (GOAL) tool that is an
adequate graphical tool for deﬁning and manipulating common
variants of omega-automata, in particular B¨uchi automata, and
temporal logic formula [13]. GOAL supports the translation
of temporal formula such as Quantiﬁed Propositional Tem-
poral Logic (QPTL) into B¨uchi automata where many well-
known translation algorithms are implemented. It also provides
language equivalence between two B¨uchi automata, automata
65
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

TABLE I. BENCHMARK FORMULA FOUND IN [14]
Formula
∈ LF LT L
p U (q U □r)
yes
p U (q ∧ X(r U s))
yes
p U (q ∧ X(r ∧ (♦(s ∧X(♦( t ∧ X(♦(u ∧ X♦v))))))))
yes
♦(p ∧ X□q)
yes
♦(p ∧ X(q ∧ X♦r))
yes
♦(q ∧ X(p U r ))
yes
(♦□q) ∨ (♦□p)
yes
♦(p ∧ X♦(q ∧ X♦(r ∧ X♦s)))
yes
□♦p ∧ □♦q ∧ □♦r ∧ □♦s ∧ □♦t
yes
(p U q U r) ∨ (q U r U p) ∨ (r U p U q)
yes
□(p → (q U (□r ∨ □s)))
no
□(p → (q U r ))
no
complementation, automata union, automata intersection and
emptiness algorithms. It has extensions covering common
translation algorithms (e.g., LTL2BA [8], Tableau algorithm,
LTL2AUT, etc.). As the recent implementation of GOAL is
based on the Java Plugin Framework, it can be properly
extended by new plug-ins, providing new functionalities that
are loaded at run-time. We implemented our composition algo-
rithm within an independent plug-in. The automata generated
by our algorithm are simpliﬁed by several simpliﬁcation meth-
ods (e.g., simulation, Delayed simulation, Faired simulation,
reducing unreachable/dead states) by taking advantage from
GOAL tool which implements all these methods.
VI.
COVERAGE AVERAGE OF FLTL FRAGMENT
In this section, we present the experiments that we con-
ducted to show the coverage average of our fragment FLTL
formula. Three sets LTL formula which commonly considered
in the literature are performed. The experiments on the one
hand, emphasis the performance of our implementation algo-
rithm and, on the other, demonstrates that a wide range of
LTL formula can be covered by our approach and translating
polynomially and properly using our GOAL plug-in. The
process we applied for each formula ϕ in our experiments
can be summarized as follows:
1)
Checking whether ϕ belongs to FLTL fragment by
building the ﬁnite syntax tree of ϕ.
2)
Using the well-known algorithm LTL2BA to generate
a B¨uchi automaton equivalent to ϕ (called A1)
3)
Using our GOAL plugin to generate the B¨uchi au-
tomaton A2 according to rules deﬁned in our algo-
rithm (i.e., Algorithm 1)
4)
Runing the GOAL B¨uchi automata equivalence to
check the equivalence between A1 and A2.
The ﬁrst set contains 12 formula and can be found in [14].
The experiments for this set show that only two formula do
not belong to our grammar as shown in Table I. The coverage
average for this set is then 83.334%.
The second set contains 27 formula and can be found
in [15][16]. The results show that the FLTL fragment fails to
express only 11 formula as shown in Table II. The coverage
average for this set is then 59.259%.
The third set contains 50 formula and can be found in [17].
Indeed, the authors in [17] have proposed a pattern-based
approach which uses speciﬁcation patterns that, at a higher
abstraction level, capture recurring temporal properties. The
main idea is that a temporal property is a combination of one
pattern and one scope. A scope is the part of the system
TABLE II. BENCHMARK FORMULA FOUND IN [15][16]
Formula
∈
Formula
∈
p U q
yes
¬ □(p → X(q R r))
yes
p U (q U r)
yes
¬ (□♦p ∨ ♦□q)
yes
¬ (p U (q U r))
no
♦p ∧ ♦¬ p
yes
□♦p → □♦q
yes
(□(q ∨ □♦p) ∧ □(r ∨ □♦¬p)) ∨ □q ∨ □r
no
¬ (♦♦p ↔♦p)
yes
(□(q ∨ ♦□p) ∧ □(r ∨ ♦□¬p)) ∨ □q ∨ □r
no
¬ (□♦p → □♦q)
yes
¬ ((□(q ∨ □♦p) ∧ □(r ∨ □♦¬p)) ∨ □q ∨ □r)
yes
¬ (□♦p ↔ □♦q)
yes
¬((□(q ∨ ♦□p) ∧ □(r ∨ ♦□¬p)) ∨ □q ∨ □r)
yes
p R (p ∨ q)
yes
□(q ∨ X□p) ∧ □(r ∨ X□¬ p))
no
(Xp U Xq) ∨ ¬ X(p U q)
yes
□(q ∨ (Xp ∧ X¬ p))
no
(Xp U q) ∨ ¬ X(p U (p ∧ q))
yes
(p U p) ∨ (q U p)
yes
□(p → ♦q) ∧ ((Xp U q) ∨ ¬ X(p U (p ∧ q)))no
♦p U □q
no
□(p → ♦q) ∧ ((Xp U Xq) ∨ ¬ X(p U p))
no
□p U q
no
□(p → ♦q)
no
□(♦p ∧ ♦q)
yes
(Xq ∧ r) R X( ((s U p) R r) U (s R r))
no
TABLE III. COVERAGE DWYER’S PATTERNS/SCOPES BY OUR LTL
FRAGMENT
Scope/Pattern
Globally
Before r
After q
Between q
After q
and r
until r
Absence
yes
yes
yes
yes
yes
Universality
yes
yes
yes
yes
no
Existence
no
no
yes
yes
yes
Precedence
yes
yes
yes
no
yes
Response
yes
yes
no
no
no
s, t precedes p
yes
yes
yes
no
no
p precedes s, t
yes
yes
yes
no
no
p responds s t
no
yes
no
no
no
s, t responds p
no
yes
no
no
no
s, t without z responds to pno
yes
no
no
no
execution path over which a pattern holds. For more details
about patterns and scopes can be found in [17]. They proved
that the patterns dramatically simplify the speciﬁcation of
temporal properties, with a fairly complete coverage where
they collected hundreds of speciﬁcations and they observed
that 92% of them fall into this small set of patterns/scopes.
A translational semantics have been proposed to Dwyer’s
properties by mapping each pattern/scope combination to a
corresponding LTL formula. As Dwyer’s and al. propose 5
scopes and 10 patterns, the total number of involved LTL
formula is then 50. The results of the comparison are given in
Table III and show that our LTL fragment covers 27 formula
from 50 formula associating by Dwyer to scopes/patterns. The
coverage average for this set is then 54%.
The covering average of each set is accepted and slightly
high. This shows that our fragment covers more than 65.531%,
which is considered very good enough due to the importance
of LTL formalism in modeling area. Such a result could be
a promising direction to explore LTL-based model checking
techniques in which system properties are ﬁrst expressed in
LTL formula then converted into B¨uchi automata.
VII.
RELATED WORK
Translation from LTL formula to B¨uchi automata has been
extensively studied in the literature. Authors in [1][18] con-
structed B¨uchi automata whoses states are sets of subformula
of the considered LTL formula. This translation is of order
2O(n) where n is the length of the LTL formula in input. [19]
proposed to build B¨uchi automata by a bottom-up traversal
through the syntax tree of the considered LTL formula. This
translation has been proved in order of 2O(nlog(n)). [20]
presented an efﬁcient translation by means of alternating ω-
automata. The translation from LTL formula to alternating ω
automata is linear in terms of the length of the considered
LTL formula, but the translation of the resulting alternating ω-
automaton to the target B¨uchi automata is exponential. [21]-
66
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

[22] proposed on-the-ﬂy translation of so-called generalized
B¨uchi automata (B¨uchi automata with multiple acceptance
conditions) which then linearly converted into B¨uchi automata.
There are several fragments of LTL that have been pro-
posed in the literature. [3] has proved that converting any
formula in which the only allowed modality is the until
operator U or the only allowed modality is X or ♦ to
B¨uchi automata is PSPACE. The formula that uses only the
♦ operator is coNP-Complete. The formula that uses only
the X operator is coNP-Complete [23]. The formula that uses
only the ♦ operator in the form □♦ is co-NPComplete [24].
In [23], the authors used the term Flat LTL to express formula
that use the
U operator whose the left-hand side does not
contain any temporal combinator, but the right-side can contain
only formula with the U operator (or its negation). Translation
from this fragement to B¨uchi automata has been proved
NP-Complete. Several simple cases with a lower worst-case
complexity are handled in [23][24].
VIII.
CONCLUSION AND FUTURE WORK
This paper presented a compositional algorithm for gener-
ating B¨uchi automata from a fragment of LTL logic. First, we
proposed the grammar of this fragment and then built for each
formulæ ϕ, its equivalent B¨uchi automata. Second, we showed
theoretically how to compositionnally build from B¨uchi au-
tomata associated to each sub-formulæ, the B¨uchi automaton
of the target formulæ. Third, we implemented our approach
in GOAL tool as a plugin and showed the complexity and the
correctness of our B¨uchi automata generation method. Fourth,
we demonstrated the interest of our method by computing
coverage average of the fragment FLTL using three sets of
well-known LTL formulas as benchmarks.
Several research lines can be continued from the present
work. First, some temporal operators such as always, precedes
or since are not considered in this paper, as an immediate
perspective, we will study how to include these operators in
our LTL fragment. Second, it will be interesting to study
whether our fragment LTL is minimalist and whether there
is possibility to more expand it by identifying what makes it
smallest. A good direction for this point is to study whether
there is a subset of Dwyer’s pattern/scope from which all other
patterns/scopes can be deduced. Third, it would be interesting
to connect the proposed language to usual model checking
tools.
ACKNOWLEDGMENT
This project has been jointly funded with the support of the
National Council for Scientiﬁc Research in Lebanon CNRS-L
and Lebanese University.
REFERENCES
[1]
O. Lichtenstein and A. Pnueli, “Checking that ﬁnite state concurrent
programs satisfy their linear speciﬁcation,” in Proceedings of the 12th
ACM SIGACT-SIGPLAN Symposium on Principles of Programming
Languages.
New York, NY, USA: ACM, 1985, pp. 97–107.
[2]
C. Baier and J. Katoen, Principles of Model Checking (Representation
and Mind Series).
The MIT Press, 2008.
[3]
A. Sistla and E. Clarke, “The complexity of propositional linear
temporal logics,” J. ACM, vol. 32, no. 3, july 1985, pp. 733–749.
[4]
R. Hierons and al., “Using formal speciﬁcations to support testing,”
ACM Comput. Surv., vol. 41, February 2009, pp. 9:1–9:76.
[5]
S. Gnesi, D. Latella, M. Massink, V. Moruzzi, and I. Pisa, “Formal test-
case generation for UML statecharts,” in Proc. 9th IEEE Int. Conf. on
Engineering of Complex Computer Systems.
IEEE Computer Society,
2004, pp. 75–84.
[6]
E. Clarke, O. Grumberg, and K. Hamaguchi, “Another look at LTL
model checking,” in Formal methods in system design.
Springer-
Verlag, 1994, pp. 415–427.
[7]
M. Vardi, “Branching vs. linear time: Final showdown,” in Proceedings
of the 7th International Conference on Tools and Algorithms for the
Construction and Analysis of Systems.
London: Springer, 2001, pp.
1–22.
[8]
P. Gastin and D. Oddoux, “Fast LTL to B¨uchi automata translation,” in
Proceedings of the 13th International Conference on Computer Aided
Veriﬁcation (CAV’01), ser. LNCS, vol. 2102.
Paris, France: Springer,
jully 2001, pp. 53–65.
[9]
V. King, O. Kupferman, and M. Vardi, On the Complexity of Parity
Word Automata.
Springer Berlin Heidelberg, 2001, pp. 276–286.
[10]
E. A. Emerson, “Handbook of theoretical computer science (vol. b),”
J. van Leeuwen, Ed.
Cambridge, MA, USA: MIT Press, 1990, ch.
Temporal and Modal Logic, pp. 995–1072.
[11]
S. Safra, “On the complexity of omega-automata,” in 29th Annual
Symposium on Foundations of Computer Science, White Plains, New
York, USA, 24-26 October 1988, 1988, pp. 319–327.
[12]
A. Sistla, M. Vardi, and P. Wolper, “The complementation problem
for b¨uchi automata with applications to temporal logic,” in Automata,
Languages and Programming.
Springer Berlin Heidelberg, 1985, pp.
465–474.
[13]
Y.-K. Tsay, Y.-F. Chen, M.-H. Tsai, K.-N. Wu, and W.-C. Chan,
“Goal: A graphical tool for manipulating b¨uchi automata and temporal
formulae,” in Tools and Algorithms for the Construction and Analysis
of Systems.
Springer Berlin Heidelberg, 2007, pp. 466–471.
[14]
K. E. and G. Holzmann, “Optimizing B¨uchi automata.” Springer, 2000,
pp. 153–167.
[15]
M. Daniele, F. Giunchiglia, and M. Vardi, “Improved automata gener-
ation for linear temporal logic,” in In 11th International Conference on
Computer Aided Veriﬁcation, ser. CAV ’99.
London, UK: Springer,
1999, pp. 249–260.
[16]
F. Somenzi and R. Bloem, “Efﬁcient b¨uchi automata from ltl formulae,”
in Computer Aided Veriﬁcation, E. A. Emerson and A. P. Sistla, Eds.
Berlin, Heidelberg: Springer, 2000, pp. 248–263.
[17]
M. Dwyer, G. Avrunin, and J. Corbett, “Patterns in property speciﬁ-
cations for ﬁnite-state veriﬁcation,” in Proceedings of the 21st Interna-
tional Conference on Software Programming, 1999, pp. 411–420.
[18]
P. Wolper, “On the relation of programs and computations to models
of temporal logic,” in Temporal Logic in Speciﬁcation, B. Banieqbal,
H. Barringer, and A. Pnueli, Eds.
Springer Berlin Heidelberg, 1989,
pp. 75–123.
[19]
G. G. de Jong, “An automata theoretic approach to temporal logic,” in
Computer Aided Veriﬁcation, K. G. Larsen and A. Skou, Eds.
Berlin,
Heidelberg: Springer Berlin Heidelberg, 1992, pp. 477–487.
[20]
M. Y. Vardi, An automata-theoretic approach to linear temporal logic.
Berlin, Heidelberg: Springer, 1996, pp. 238–266.
[21]
J.-M. Couvreur, “On-the-ﬂy veriﬁcation of linear temporal logic,” in
FM’99 — Formal Methods, J. M. Wing, J. Woodcock, and J. Davies,
Eds.
Springer, 1999, pp. 253–271.
[22]
S. Schwoon and J. Esparza, “A note on on-the-ﬂy veriﬁcation algo-
rithms,” in Tools and Algorithms for the Construction and Analysis
of Systems, N. Halbwachs and L. D. Zuck, Eds.
Springer Berlin
Heidelberg, 2005, pp. 174–190.
[23]
S. Demri and P. Schnoebelen, “The complexity of propositional linear
temporal logics in simple cases,” Information and Computation, vol.
174, no. 1, 2002, pp. 84 – 103.
[24]
E. A. Emerson and C.-L. Lei, “Modalities for model checking: branch-
ing time logic strikes back,” Science of Computer Programming, vol. 8,
no. 3, 1987, pp. 275 – 306.
67
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

