The Random Gate Principle
Sheagan John
Department of Mathematics
The University of the West Indies
Mona, Kingston 7, Jamaica
Email: sheagan.john@mymona.uwi.edu
Curtis Busby-Earle
Department of Computing
The University of the West Indies
Mona, Kingston 7, Jamaica
curtis.busbyearle@uwimona.edu.jm
Abstract---We present the main theoretical ideas be-
hind a proposed symmetric key algorithm. We show that
it can be fairly easily constructed from mathematical
pseudo-random parameters and known secure crypto-
graphic functions. We describe how time intervals can be
used to establish our algorithm for encryption purposes.
We will briefly discuss the decryption of messages passed
through the algorithm.
Keywords-algorithm; encryption; gate; symmetric
I. INTRODUCTION
There exists a plethora of encryption cryptosystems
and algorithms of varying security. The 3DES [1] and
AES [2] algorithms are well known examples of such
symmetric key methods. In this paper, we give the
theoretical construction for a symmetric key algorithm
which we call the Random Gate Principle (RGP). A
schematic overlay of the basic nature of the system is
shown in Fig 1.
The Random Gate Principle is a symmetric key
algorithm which relies fundamentally on the properties
of wide ranging time intervals in order to ensure
cryptographic security. The RGP, though unrelated
to the public-key system underlying the concept of
Merkle's puzzles [3], is influenced by them. While
Merkle's puzzles use a large number of messages to
hide a particular one, the RGP conceals this message
through inserting "garbage" of arbitrary length within
the original message itself. The algorithm separates
a plaintext message into blocks of predetermined bit
lengths and feeds each of these individual blocks
through a set of logical gates, which allow passage
of a given block after a randomly determined time
period. In this way, during the period between the
passage of successive blocks, a string of bits can be
inserted, where the insertion length varies according
to the time interval. As a result, the original message
is hidden within a longer garbled one which is then
further encrypted using two internally generated keys.
The final output from the procedure has the property
that no attacker can determine the length of the original
message from that of the encrypted one, or from the
length of time taken for encryption.
The main idea with regards to proposing the RGP is
the ability to combine low complexity cryptosystems
to create a secure encryption algorithm. The remainder
of this paper is organized as follows. In Section II
we provide an outline of the encryption procedure,
in Section III some bounds related to the message
length are calculated, in Section IV we give an example
of some simple attacks against the algorithm, and in
Section V the method of decryption is outlined.
Throughout the paper it is to be understood that the
output of all deterministic functions changes with the
master key used for the encryption process.
II. OUTLINE OF ENCRYPTION
A particular gate of the RGP is denoted by ak or
bk as shown in Fig 1. The gates are mathematical
constructs, essentially consisting of functions which
either have a defined image for a given input or do
not. These functions have a predetermined and static
set of parameters which describe their restricted ranges
and as such the set of valid inputs. The most important
criterion is that no two gates may ever both consider
the same input as valid. Each gate also contains a
check function and this will be discussed in relation
to Ain and Aout. The total number of gates, N, may
be some predetermined value which is known by both
the sender and receiver of the encrypted message.
Alternatively, this value may vary accordingly with the
output from some deterministic function known to both
parties.
The space Aout contains a check function and two
pseudo-random number generators (PRGs) which we
shall denote as PRG1 and PRG2. We denote by Ain,
the representation of a space for implementation of
three main functions.
The first function separates the initial plaintext mes-
sage of length L into individual blocks each of length
L
N with the ability to pad a string of zeroes to the last
piece until it is of exact length
L
N . Each block then
undergoes a left circular shift, where the number of bit
positions shifted is equal to the block's position within
Ain. This shift is to prevent the blocks of a random
37
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-427-5
SECURWARE 2015 : The Ninth International Conference on Emerging Security Information, Systems and Technologies

Ain
a1
a2
a3
ak
aN
......
......
Aout
Bin
b1
b2
b3
bk
bN
......
......
Bout
Fig. 1. A schematic presentation of the RGP gates.
message from exhibiting exceptional structure within
the "garbage" surrounding them.
The first permuted
L
N block is prepended with the
16-bit representation of 1 and likewise each subsequent
block till the last is prepended with that of the 16-bit
representation of N. This concatenation will be de-
noted by m|| L
N where m is m'th integer.
The second function H(X) takes each block of
the form m|| L
N , in order, and maps it to a gate ak.
This is not based on the parameters which govern the
distinct valid inputs for ak but rather on a conditional
statement which assigns the prepended 16-bit value
to a local variable within ak if and only if a certain
condition is met. In order for the choice of gate to be
indistinguishable from random it is thus needed that
the output of H(X) also be indistinguishable from
random. As an example, suppose that the Yarrow-160
[4] protocol is implemented within H(X) in order to
generate a random number, the last 32 bits of which
are evaluated mod(N + 1). If the result is zero, a new
number is generated and evaluated, otherwise the block
m|| L
N is sent to the gate which has the number which is
equal to the H(X) output. In this manner the mapping
H(X) : Ain −→ ak is independent of the message
itself.
The third function is a check function which takes
as input a number and outputs either 0, 1 or ⊥(null).
A gate, in order that only the blocks of the original
message pass through it, does not assign a value to the
local variable until the block is mapped directly to it
from H(X). Once the block is accepted, a single, static
256 bit number unique to each gate is relayed to the
Ain check function. If this number matches the stored
value associated with that gate, the check function
outputs 0 and no new strings are fed into the H(X)
function. Simultaneously, a unique but static 256 bit
number is sent from the gate to the check function of
Aout, which outputs 1, thus initiating the two pseudo-
random generators within Aout.
Each output of PRG1 is a 32-bit number sent to
and evaluated by all gates. The PRGs output cycle is
attached to a counter which increases with every output
and beginning with a value of 1 the counter value c
increases to a value of N at which point the counter
resets to 1. PRG2 outputs a 16-bit number between
1 and N inclusive and prepends this number r to the
output of the first PRG. The gate which receives this
concatenated string as input and considers it valid, uses
its check function to compare the r value to the value
of the number m present in the m|| L
N block from
H(X). If the gate contains no information or the m
value present is not equal to r, the check function will
output 0 and upon receiving a zero value the check
function within Aout outputs ⊥ forcing PRG2 to output
0 until the counter value c has reseted to 1. At this point
PRG2 will again output a valid non-zero number and
prepends this to a new output from PRG1 which the
accepting gate again checks for equality to m.
If the two values are equal the check function of the
gate outputs a single, unique, static 256 bit number
to Aout which causes the check function of Aout
to output 0 and terminate the loop for both PRGs.
Simultaneously a unique 256 bit number is sent to the
check function of Ain which outputs 1, enabling a new
block to be fed into H(X). As soon as the m value is
checked to be equal to r the gate passes the reference
value of its local variable to an array in Aout and is
dereferenced in order for the variable to take a new
value.
A. Bit Insertion
The data in Aout is sent through a one way route to
Bin (see Fig 1) where the configuration of Bin is the
same as that of Ain. Because of this, the complexity of
implementation may be simplified by using the same
38
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-427-5
SECURWARE 2015 : The Ninth International Conference on Emerging Security Information, Systems and Technologies

Bout
I1(X)
Storage
E(X)
Fig. 2. The encryption process in stages.
set of functions and conditions within the gates for
each pair, ak and bk. In fact the symmetry of the two
halves can be made exact by using Yarrow-160 for both
sets of two PRGs (PRG1, PRG2) and (PRG3, PRG4)
present in Aout and Bout.
We denote by I1(X) the insertion function contain-
ing a one bit PRG linked to two counters. The blocks
leaving Bout are once again in the form of L
N , having
had the prepended 16-bit representation of m removed.
Upon leaving, the first counter analyzes the constant
data stream one bit at a time looking for an null space.
Thus, upon finding the end of the first block, the
counter increments from 0 to 1 while the PRG inserts
a bit into each null space and does so until the counter
detects the beginning of the second block. Since the
PRG is only activated by the presence of an null space
it will not replace any part of the original message.
When each new block is detected, the counter increases
and the PRG begins insertion once more. This cycle
continues until the counter reaches N and resets, thus
deactivating the PRG. The second counter records the
number of bits (B1, B2, . . . , BN−1) inserted by I1(X)
during each cycle.
The entire string is stored in a dynamic array called
Storage which holds each incoming bit in sequence.
The insertion length values are similarly stored in
separate arrays. Two functions are contained within
Storage.
D(X) takes as input the values (B1, B2, . . . , BN−1)
and outputs (C0, . . . , CN−1).
An insertion function, I2(X) uses a PRG- such
as the Yarrow-160- to generate multiple outputs of
random bits. These outputs are concatenated until they
exceed the length of some value based on the N − 1
insertion lengths. For example, a naive value may be
given by
V1 =
B1 + B2 + · · · + BN−1
|Bi − Bj|

(1)
where the choice of i and j depends on the master key.
At this point the concatenated string has all rightmost
bits removed until it is of the exact length as V1. The
shortened concatenation is prepended to the garbage
filled message . An similar procedure is followed for
a second set of outputs of final length V2, which is
appended instead.
In the construction below, we denote the following:
P, Q are large prime numbers which are known be-
forehand by both parties; αi ̸= ji are numbers ranging
from 1 to N − 1.
C0 = P(Bj1)Q
(2)
C1 ≡ Bα1(modBj1)
(3)
C2 ≡ Bα2(modBj2) + C1
(4)
...
CN−1 ≡ BαN−1(modBjN−1) + CN−2
(5)
Since each αi, ji is unique then each of the insertion
bit values is used twice; once as a modular base and
once as the number being reduced. The function D(X)
is deterministic, in that the sequence of pairs (αi, ji) is
fixed regardless of the message being encrypted. This
means that the value Bj1 = Bk (1 ≤ k ≤ N − 1) for
a fixed value of k. The importance of the equations
given above is shown in Section V, with regards to
decryption.
B. Keys and Authentication Codes
At this point the garbled message string and the set
of values C0, C1, . . . , CN−1 are transfered to arrays in
the space denoted by E(X). This space contains an ex-
clusive bitwise addition function and two deterministic
functions, E1(X) and E2(X). The deterministic func-
tions may be of varying mathematical complexity or
may even be physically determined such as described
in [6]. We do require that they be difficult to invert.
The purpose of E2(X) is to output two strings of
128 bits in length where the first output is prepended
to the data and a second output is appended to the
data. The first output of E2(X) may be determined
by the length of the garbage filled message. The
second output is determined using the value of the first
output and thus by association would also be dependent
on message length. The reliance on message length
for generating input values for E2(X) underlines the
importance of widely varying lengths of inserted bits.
Given a large range of possibilities, and since it
is likely that any change in the first output will
affect the second we can use these pairs as message
authentication codes (MAC) [9]. See Section IV for
more detail on this procedure.
We wish that an active attacker who either deletes
bits from the encrypted message or inserts bits will,
through tampering with message length, almost cer-
tainly invalidate one or both E2(X) outputs upon
decryption. This is a useful implementation due to
the simplicity of verification and given that MAC
39
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-427-5
SECURWARE 2015 : The Ninth International Conference on Emerging Security Information, Systems and Technologies

authentication has been proven to be very secure [7].
To rigourously prove the claim of invalidation of
E2(X) outputs would require a detailed explanation of
how E2(X) works. Due to constraints on the amount
of material which can be presented, we have decided
to discuss this in future work.
Unfortunately we do not obtain non-repudiation [8]
nor defend against an active attacker who does not
change message length. This last concern can be some-
what countered by structuring E2(X) to depend not
entirely on message length but on some other unique
property such as a combination of message length and
number of 0's contained in the message.
Two fixed length keys are outputted by E1(X) given
the Bj1 value mentioned above as its input.
As an example, take a set of 512 bit keys, where
the bitwise XOR function applies the first 512 bit key
to the first 512 bits of the data. The next 512 bits
of data (if more than 512 bits remains) is similarly
XORed by the same key until all data is encrypted.
This newly encrypted message is again XORed, but
with the second key. It is after this procedure that the
MACs are concatenated to the message.
III. MESSAGE LENGTH BOUNDS
In this section we must stress that the very nature
of the randomness of the gate mechanism only allows
for the calculation of expected values for most of the
bounds. In particular there is no true upper bound as
a gate may theoretically never be opened. In fact it is
of great importance that the number of gates is small
enough so as to allow a high expectation that every
gate will open within some reasonable time span.
All the values obtained assume perfectly random
behaviour. In practice there will likely be some small
bias for particular gates.
Let us begin by calculating the lower bounds of
time interval between exactly two consecutive blocks
of form m|| L
N . The denotation L is the length of
the original plaintext, and ¯L is the total length after
insertions.
The lower bound can be found exactly, where
P(X → ak) describes the probability of a block being
sent to a given gate. Here, X represents a plaintext
block. Assuming the Yarrow-160 protocol is indistin-
guishable from true random, then P(X → ak) will be
1
N whilst the time (th) to execute is constant regardless
of the chosen gate. The probability P(X → Aout)
is
1
N 2 since the probabilities that the non-empty gate
accepts the 32-bit number generated PRG2 and the
correct output from PRG1 is prepended both have
probability
1
N . Assuming that both PRGs output the
correct values then the time taken is just the constant
tg(o) which is the time taken to open the gate and is
a measure of the time taken for one complete cycle of
the mechanism process described above. At this point
the second block trails the first by a value of tg(o) +th
but if the first block fails to pass through the second
set of gates in one try then the second block will join
it in Bin. Furthermore, if the second passes through
immediately then the time interval remains tg(o) + th.
In fact this true for any two blocks for which the first
block takes longer to pass through the second set of
gates than the second block takes to pass through the
first set of gates. It should also be noted that the time
taken to send data from Aout to Bin is assumed to be
negligible compared to tg(o)+th thus this value is what
the lower bound is expressed as between consecutive
message blocks.
The upper bound occurs when the time interval
between two consecutive message blocks is greatest.
This will occur when the first block passes through
both sets of gates immediately whilst the second takes
all tries. Using the probabilities above, we can show
that the time taken for first block to pass from, Ain to
Bout is equivalent to
T1 = 2(tg(o) + th)
(6)
The time taken for the second block to pass from Ain
to Aout is
T2a = (th + (N 3 − N)tg(r) + tg(o))
(7)
where tg(r) represents the time taken for the gate to
receive and reject r.
Since the probability P(X → Aout) is
1
N 2 this
means that there will be (N 2 − 1) attempts where
PRG2 is forced to output 0 until the counter resets.
Each counter cycle takes time Ntg(r) and thus for all
incorrect attempts the total time is
(N 2 − 1) ∗ Ntg(r)
(8)
with the single correct attempt being of time tg(o). By
the same argument the time
T2b = (th + (N 3 − N)tg(r) + tg(o))
(9)
which is the time taken for the second block to pass
from Bin to Bout is the probabilistic upper bound.
Therefore the total time interval is established as
2(th + (N 3 − N)tg(r) + tg(o)) − 2(th + tg(o)) (10)
assuming a perfectly random mechanism.
The effect of this time interval is to allow the one
bit PRG within the insertion function to insert zeros
and ones between two consecutive blocks. If the PRG
performs an insertion every tins then the number of
bits inserted between the two blocks has bounds given
by equation (11).
40
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-427-5
SECURWARE 2015 : The Ninth International Conference on Emerging Security Information, Systems and Technologies

tg(o) + th
tins
≤ n(Bits)
≤
2[th+tg(r)(N3−N)+tg(o)] − 2(tg(o)+th)
tins
=
2(N3−N)tg(r)
tins
(11)
This upper bound, however, is true only for the first
two blocks after which the bound is represented by that
of equation (12).
tg(o) + th
tins
≤ n(Bits)
≤
(th+(N3−N)tg(r)+tg(o)) − 2(tg(o)+th)
tins
=
tg(r)(N3−N) − (tg(o)+th)
tins
(12)
This wide ranging insertion length is meant to ensure
that accurate prediction of the final length is extremely
difficult. The probability of an inserted string being of
a given possible length is
1
N 2 and that of each N − 1
insertion all having a particular length such that the
sum of the lengths of all inserted strings is a given
value can be approximated.
The probability of a message of original length L
being mapped into that of maximum or minimum
length; max(¯L), min(¯L) is
1
N 2 ∗ N N−1
(13)
since there is only one way of summing to either the
maximum or minimum possible final length.
The probability P(L →
¯L) where the insertion
length is non(max, min) increases with N and is
largest for a total insertion length corresponding to N
gate rechecks. We will determine the least number of
repeats of the same message that may be processed
before the output lengths are forced to match.
This can be solved exactly by considering the weak
partition, wp(N)N−1, of N into N − 1 non-negative
integers.
wp(N)N−1 =
1
(N − 2)!
N−2
Y
i=1
(N + i)
(14)
P(L → ¯L) = wp(N)N−1
N 2 ∗ N N−1
(15)
Thus the number of repeated cycles of the same mes-
sage must be no more than this absolute smallest value
for mandatory correlation for any message length.
The more numerous the gates, the larger this value
becomes. At N = 16 this value is
P(L → ¯L) = wp(16)15
162 ∗ 1615 ∼=
1
240.89
(16)
and this represents the total insertion length most likely
to be present. An equal total length, however does not
indicate that the sequence of insertion lengths is the
same, as the probability of a given inserted length is
still
1
N 2 .
The last bound of importance is that of message
length to number of gates. Since the security is based
on random insertion length, the original message length
must be at least N-bits. The upper bound of message
length is determined by the security of encrypting a
string of zeros, as will be shown in the next section.
IV. SIMPLE ATTACKS
We illustrate a chosen-plaintext attack. Consider an
attacker who knows that the MAC lengths are 128 bits.
We show the method by which an attacker can break
the security in the shortest possible time with only this
knowledge.
Assume the attacker sends a string of zeroes through
the RGP to be encrypted. The garbled message has
been XORed by two 512 bit keys, as in Fig. 3. Note
that the circular shift on each block of zeroes does not
affect it at all.
We let the length of 1st Division, denoted by C,
be arbitrarily long and thus the last 512 − V1 bits of
the XORed keys will always be XORed with zeros.
Knowing the combined length of the first MAC and
B is 128 + V1 bits, the attacker assumes C is XORed
with some 512 − V1 bit portion of the keys. The
attacker knows that the encrypted 512 − V1 bits they
are searching are in fact the keys themselves but does
not know what V1 is, and will not know even if the
length of C is exactly 512 bits. This is because the
beginning V1 bits of the first 512 bit encrypted portion
are different than the first V1 bits of the subsequent
portion and thus no repeating pattern yet emerges. As
C exceeds 512 bits the sequence of the further bits
exactly repeats that of the aforementioned 512 − V1
bits. At C = 1024 − V1 bits the entire repetition is
shown and the attacker can determine what the XOR
value of the last 512 − V1 bits of the two keys is.
This gained information is enough to determine which
portions of the ciphertext are simply a long string of
zeroes. The same method can be used if C is just a
string of ones.
For complete security of any message encrypted
with a key of length K it is thus recommended that the
message be no longer than KN bits in length where
N is the number of gates. This is easily remedied
by forcing an initial message to be split into pieces
and each piece fed into Ain in sequence, where new
keys are generated each time. Another, less simple
countermeasure is to construct E1(X) such that key
length is dynamic and the keys may have differ-
ing lengths. Under these two improvements, chosen-
41
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-427-5
SECURWARE 2015 : The Ninth International Conference on Emerging Security Information, Systems and Technologies

|
512 bit key 2
|
512 bit key 2
| . . . . . . . . . . . . . . . |
⊕
⊕
|
512 bit key 1
|
512 bit key 1
| . . . . . . . . . . . . . . . |
⊕
⊕
|
128 bits
|
V1 bits
|
1st Division
| . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
128 bits
|
MAC
B
C
D
MAC
Fig. 3. Ciphertext output for an arbitrary message.
plaintext attack is not enough to break security. This
is since the MAC, the value of V1, the two keys,
and the garbage inserted, constantly change with each
encryption, even with the same plaintext used multiple
times.
We will now allow the same attacker to record the
time intervals between several different length message
inputs and their encrypted outputs. We must show that
such a timing attack is insufficient to determine with
non-negligible probability which encrypted message
the attacker is viewing. The attacker is given the power
to submit an arbitrary length string of zeros or string of
ones, both of which have length less than or equal to
KN. The attacker then outputs the probability that the
encrypted message is that of the zeros. The probability
will be
1
2 + ε where the value of ε must be non-
negligible for the algorithm to be considered secure.
One way to accomplish this is by forcing all en-
crypted messages to remain in the system until a
minimal time
2(N 3 − N)tg(r) ∗ (N − 1) ∗ α
(17)
has elapsed, where α may be arbitrarily large. Though,
theoretically, a message portion may take an infinite
amount of time to pass through the gates, by choosing
a large value for α the majority of message encryption
times can be standardized. Such an α would depend on
the number of gates and would be determined experi-
mentally. The obvious downside to this approach is the
artificially long encryption time for some messages.
A. MAC and Key Integrity
With regards to an attack on message integrity we
consider an attacker attempting an existential forgery
under a chosen-plaintext attack. Also the attacker
wants to be able to create a message which has the
same pair of MACs as a valid message.
Suppose that the attacker intercepts an encrypted
message and attempts to use the same MACs on an
arbitrary plaintext of his choosing. As was shown in
Section III, even with only sixteen gates, the number
of messages that must be encrypted to guaranteed mes-
sage length collision is large. Even then, the probability
that the number of 0's occurring is the same in both
cases is unlikely. Given that the E2(X) outputs depend
on these two factors, a breach of integrity reduces to
finding a collision for E2(X). It is thus extremely
important that E2(X) be sensitive to even very minor
changes in its inputs as well as possessing a large range
of outputs. Taking into consideration a birthday attack,
the number of random messages an attacker must send
before being guaranteed a collision pair for both MACs
is
264 · 264 = 2128
This assumes that there is no exploitable bias in the
construction of E2(X).
Similarly, trying to force decryption of an arbitrary
message with an externally generated message authen-
tication code is an undertaking by brute force.
Assuming the bounds of message length for se-
curity against pattern recognition are adhered to and
the function E1(X) which generates the keys is not
known, then any simple attack on the message through
key integrity which does not rely on exploiting some
unforeseen weakness in the E1(X) function will be a
brute force attack on the key length.
V. MESSAGE RECOVERY
Consider a fully encrypted message which has
been sent to a recipient along with the values,
C0, C1, . . . , CN−1. The intended recipient must pos-
sess knowledge of various portions of the encryption
process. Namely, the number of gates, the values of the
prime pair P, Q as well as the sequence of pairs (αi, ji)
(see Section II.A) must all be shared knowledge. It
is given that the recipient's RGP decryption algorithm
contains exact replicas of E1(X), E2(X), the circular
shift function, and the deterministic sub-function of
I2(X) which calculates the values V1 and V2.
Firstly, the value Bj1 is recovered from C0 by
dividing by P and then applying Fermat's Little The-
orem using Q. Once Bj1 is found it is used as input
for E1(X) and thus the key pair is generated. The
ciphertext is XORed, initially with the second secret
key, and then with the first. We will assume, as
42
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-427-5
SECURWARE 2015 : The Ninth International Conference on Emerging Security Information, Systems and Technologies

proposed in Section II.B, that E2(X) takes as its input
a combination of ciphertext length and number of 0's
occurring. It is thus easy to determine both of these
values, and consequently, to verify the validity of the
MACs. If the MACs are valid then the ciphertext may
now be "ungarbled" in order to extract the original
data; otherwise it is discarded.
Recovering the plaintext is accomplished by using
Bj1 and the values C1, . . . , CN−1 given by equations
(3) to (5) to obtain B1, . . . , BN−1. For this procedure
it is vital that the sequence of pairs (αi, ji) be known.
Once each of the values B1, . . . , BN−1 is obtained,
it is simple to remove all inserted bits . Now, the
beginning of the ungarbled message is prepended by
the first output of I2(X),so we proceed by removing
the V1-bits. Likewise, the appended V2-bits is similarly
removed. Reversing the circular shift on each block,
concatenating the remaining data, and removing the
padded zeroes from the final block recovers the origi-
nal plaintext.
VI. A SIMPLIFIED EXAMPLE
We now give an example of encryption of some
sample messages using a method based on a significant
simplification of the RGP algorithm. We thank Ritesh
Reddy for writing the code which implements this
encryption.
Number of Blocks: 10
Plaintext Length:
24
Ciphertext Length: 30
Original Plaintext: Hello My Name is
Ritesh!
Encrypted:æ⌞ ­°a0\⌞d¥Êür}næÛ”‹‹‹ñ¬õËËË
Decrypted: Hello My Name is Ritesh!
Number of Blocks: 4
Plaintext Length:
21
Ciphertext Length: 24
Original Plaintext: NSA NSA NSA SECRET!!!
Encrypted: õúèÇõúcBpucBvhfuhw×××444
Decrypted: NSA NSA NSA SECRET!!!
VII. CONCLUSIONS
In addition to the specific issues noted in previous
sections, as an immediate concern, we aim to practi-
cally ascertain the relative performance and safety of
the RGP versus some of the commonly used crypto-
graphic methods. At the time of writing this paper, this
analysis is only preliminary due to lack of a complete
working model of the RGP. We also plan to investigate
the robustness of the algorithm with regards to accurate
decryption when the initial message is comparatively
long and to determining how the ciphertext length
varies with the number of gates.
References
[1] http://csrc.nist.gov/publications/nist-
pubs/800-67-Rev1/SP-800-67-Rev1.pdf (Accessed on July 10,
2015)
[2] http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf (Ac-
cessed on July 10, 2015)
[3] R. C. Merkle, "Secure communications over insecure channels,
" Communications of the ACM, Vol. 21, Issue 4, pp. 294-299,
1978.
[4] B. Schneier, J. Kelsey, N. Ferguson, "Yarrow-160: Notes on the
design and analysis of the Yarrow cryptographic pseudorandom
number generator, " SAC '99 Proceedings of the 6th Annual
International Workshop on Selected Areas in Cryptography, pp.
13-33, 1999.
[5] G. Hanaoka, J. Shikata, Y. Zheng and H. Imai, “Uncondition-
ally secure digital signature schemes admitting transferability,
" ASIACRYPT, LNCS, vol. 1976, pp.130-142, 2000.
[6] R. Pappu, B. Recht, J. Taylor, and N. Gershenfeld, "Physical
one-way functions, " Science, vol. 297, pp. 2026-2030, 2002.
[DOI:10.1126/science.1074376]
[7] G. Hanaoka, J. Shikata, Y. Zheng and H. Imai, “Uncondition-
ally secure digital signature schemes admitting transferability,
" ASIACRYPT, LNCS, vol. 1976, pp.130-142, 2000.
[8] F. Oggier, H. Fathi, "An authentication code against pollution
attacks in network coding, " IEEE/ACM Transactions on
Networking, 2009. [DOI:10.1109/TNET.2011.2126592]
[9] A. S. Aiyer, L. Alvisi, R. A. Bazzi and A. Clement, "Matrix
signatures: From MACs to digital signatures in distributed sys-
tems, " Distributed Computing, 22nd International Symposium,
DISC 2008, Arcachon, France, September 22-24, 2008.
43
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-427-5
SECURWARE 2015 : The Ninth International Conference on Emerging Security Information, Systems and Technologies

