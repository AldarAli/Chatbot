Developing an ESL Design Flow and Integrating Design Space Exploration
for Embedded Systems
Falko Guderian and Gerhard Fettweis
Vodafone Chair Mobile Communications Systems
Technische Universität Dresden, 01062 Dresden, Germany
e-mail:{falko.guderian, fettweis}@ifn.et.tu-dresden.de
Abstract—This paper introduces a systematic develop-
ment of design ﬂows for embedded systems. The idea of
an executable design ﬂow provides a basis for the design
automation starting at system level. The aim is to develop,
manage and optimize design ﬂows more eﬃciently.
A
seamless integration of design space exploration into a
design ﬂow is presented coping with the conﬂicting design
goals of embedded systems at electronic system level.
It is further shown that an abstract design ﬂow model
simpliﬁes a derivation of domain-speciﬁc design ﬂows. A
novel programming language is introduced allowing for
the development of design ﬂows in a visual and textual
manner. A case study of the heterogeneous multicluster
architecture demonstrates a usage of the design approach
and automation. A systematic dimensioning of the multi-
cluster architecture, in terms of the necessary computation
resources, is presented in detail. The case study addresses
various design problems of future embedded systems
at electronic system level.
Finally, this paper presents
design ﬂow development and design space exploration for
embedded systems being systematically, fully integrated,
and automated in order to improve a system level design.
Keywords-electronic design automation, electronic system
level, design ﬂow, design space exploration
I
INTRODUCTION
It is commonly accepted by all major semiconduc-
tor roadmaps that only by raising the design process to
higher levels of abstraction will designers be able to cope
with the existing design challenges.
This leads to an
electronic system level (ESL) design ﬂow. The term sys-
tem level refers to a use of abstract system functions in
order to improve comprehension about a system. De-
sign space exploration (DSE) needs to be integrated in
order to trade-oﬀ between the conﬂicting goals of ESL
design, such as performance, power consumption, and
area [1]. ESL design aims at a seamless transformation
of a system speciﬁcation into a hardware (HW)/ software
(SW) implementation [2]. Hence, electronic design au-
tomation (EDA) requires a system speciﬁcation, which
is executable in a computer simulation. An executable
speciﬁcation is a simulation model of the intended sys-
tem functions, also called a virtual prototype [3][4].
Today’s ESL design ﬂows, from now on shortened
to ﬂows, are typically based on a specify-explore-reﬁne
(SER) methodology [5]. Such ﬂows include a sequence
of design steps, from now on shortened to steps, succes-
sively reﬁning a system model. Each step solves a de-
sign problem, such as application mapping. Moreover,
a speciﬁcation model deﬁnes the starting point represent-
ing the targeted application characteristics and require-
ments. “Speciﬁcation model is used by application de-
signers to prove that their algorithms work on a given
system platform” [2]. Then, each exploration step cre-
ates a design decision continuously increasing the ac-
curacy of the system model.
Afterwards, the reﬁned
model is passed to the next exploration step. Recently
developed EDA environments for ESL design, as pro-
posed in the MULTICUBE project [6] and NASA frame-
work [7], turn away from ad-hoc software infrastructure.
The generic EDA systems provide modularization and
well-deﬁned interfaces. Despite these advancements, the
problem of a large number of possible ﬂow sequences
has not been addressed yet.
Since future embedded systems will have an increas-
ing design complexity, the number of steps in a ﬂow
is further rising. For example, an optimization of the
resource management will require additional steps [8].
Furthermore, the huge design space will draw more at-
tention to an ESL design at an early design stage in or-
der to avoid time-consuming low-level simulations. A
systematic methodology to develop, manage and opti-
mize ﬂows promises for a signiﬁcantly improved design
process. In this paper, the approach is denoted as the
92
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

design of design ﬂow (DODF). Similar methodologies
have been developed in other scientiﬁc ﬁelds, such as
physics [9], mechanical engineering [10], and software
engineering [11]. Nevertheless, their degree of automa-
tion is limited and the main contribution of this paper is
to address this drawback. The aim is to provide an EDA
environment increasing the user’s productivity.
The remainder of this paper is organized as follows.
The related work and design approach are presented in
the Sections II and III. In Section IV, the authors intro-
duce the principle of an executable ﬂow. The section also
focuses on an explanation of the DODF approach. Then,
the introduced concepts are exempliﬁed via a functional
exploration of a ﬁnite impulse response (FIR) ﬁlter. In
Section V, the modeling of ﬂows is explained. The idea
of abstracting the ﬂows and a corresponding derivation
of a domain-speciﬁc ﬂow are further introduced. In ad-
dition, DSE techniques, applicable to a step and ﬂow,
are covered. In Section VI, a visual and textual design
ﬂow language (DFL) are presented allowing to develop,
manage, and optimize a ﬂow. An according tool ﬂow
is introduced afterwards. Finally, Section VII applies the
previously developed models and automation tools for an
ESL design of the heterogeneous multicluster architec-
ture [12]. The several ﬂows are arranged in a sequence of
ﬂows. The ﬂow for the multicluster dimensioning prob-
lem will be described in detail.
II
RELATED WORK
The related work reviews representative design and
speciﬁcation languages. Moreover, state-of-the-art DSE
environments are covered.
Then, related studies on
meta-modeling are presented. Finally, the use of script-
ing languages is discussed in the context of EDA.
Speciﬁcation Languages and DSE Environments
There is a variety of graphical and textual speciﬁcation
languages and frameworks. They can be used to real-
ize ESL design by following a given design methodol-
ogy. Nevertheless, this is done in a less formal and less
generic manner compared to our systematic development
of ﬂows. Hence, the reuse and interoperability across
tools, designers, and domains are limited. An example
is the speciﬁcation and description language (SDL) [13]
allowing for formal and graphical system speciﬁcation
and their implementation. In [14], HW/SW co-design
of embedded systems is presented using SDL-based ap-
plication descriptions and HW-emulating virtual proto-
types.
Moreover, SystemC [15] and SpecC [16] are
system-level design languages (SLDL), which model ex-
ecutable speciﬁcations of HW/SW systems at multiple
levels of abstraction. These simulation models support
SW development. For example, SystemCoDesigner [17]
enables an automatic DSE and rapid prototyping of be-
havioral SystemC models. In [18], a comprehensive de-
sign framework for heterogeneous MPSoC is presented.
Based on the SpecC language and methodology, it sup-
ports an automatic model generation, estimation, and
veriﬁcation enabling rapid DSE. Using an abstract spec-
iﬁcation of the desired system as starting point, pin-and
cycle-accurate system models are automatically created
through an iterative reﬁnement at various levels of ab-
straction. Another example is the speciﬁcation in a syn-
chronous language, e.g., via Matlab/Simulink. Opposed
to that, Ptolemy [19] supports various models of compu-
tation to realize executable speciﬁcations including syn-
chronous concurrency models. For both examples, DSE
has to be realized through a dedicated implementation.
As mentioned in Section I, the MultiCube project [6]
and the NASA framework [7] provide a generic infras-
tructure for ESL design including DSE. Nevertheless,
the works do not provide a systematic development of
ﬂows and an according design ﬂow language. Hence,
they are limited to proprietary ﬂows.
Meta-modeling
Our paper diﬀers to existing work since it is the ﬁrst us-
ing meta-modeling for developing a design ﬂow for em-
bedded systems. Meta-modeling has also been studied to
transform from the uniﬁed markup language (UML) to
SystemC at the meta-model level [20]. This guarantees
reuse of models and uniﬁes a deﬁnition of the transfor-
mation rules. In [21], meta-modeling enables heteroge-
neous models of computations during modeling. In [22],
meta-modeling is used to improve the model semantics
and to enable type-checking and inference-based facili-
ties.
Electronic Design Automation
Principally, a general-purpose programming language,
such as C/C++, Java, C#, etc., can deﬁne a ﬂow via
data and control structures.
There are diﬀerent im-
plementation options for a ﬂow description avoiding a
unique representation of a ﬂow. Moreover, compilation
times prevent from a seamless programming. Hence, a
scripting language, tailored to that task, would be rather
suited. For example, the major EDA tool vendors Synop-
sys [23], Cadence [24], and Mentor Graphics [25] pro-
vide a scripting language interface for design automa-
tion. Therein, the EDA functions are accessible via the
language commands in order to build custom ﬂows. The
ﬁrst example is the tool command language (Tcl) [26].
The scripting language has been integrated in the EDA
93
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

tools of Synopsys and Mentor Graphics. Tcl is available
as open source project without licensing. Another design
automation language represents SKILL [27].
SKILL,
also a scripting language, has been derived from Lisp,
and is integrated in the EDA tools of Cadence. In addi-
tion, Perl, Ruby, and Python are used as EDA scripting
languages, as presented in [28]. A major drawback of the
languages is, they leave it to the designer how to develop,
manage and optimize a ﬂow. Hence, the realization of
a systematic structure, parallelization, and debugging of
ﬂows can diﬀer for each language and designer. This
makes the understanding, maintenance and reuse of the
ﬂow descriptions a challenging task. This paper address-
ing the issue by supporting a systematic development of
ﬂows via DFL. Furthermore, DSE is directly considered
in the language design and implementation, which is not
the case for the existing EDA scripting languages.
III
DESIGN APPROACH
This section provides an overview of the design ap-
proach. It includes two conceptual levels and one in-
stance level related to the terms method, methodology,
and model. This is illustrated in the Figure 1. The basic
idea is that models and methods are used by a method-
ology. The classiﬁcation and relationships will be ex-
plained in the following. A composition refers to an el-
ement, which is part of another element. Instantiation
means that an element is derived from another element.
Moreover, the term meta is used in order to describe an
abstraction of a subject. An example is the meta-data,
which means data about data.
The meta-methodology deﬁnes a methodology re-
alizing another methodology.
In Section B, a meta-
methodology for the development of ﬂows, also consid-
ered as DODF, is introduced. Hence, a ﬂow represents
a methodology, composed of steps, in order to build the
intended design. A view allows for a partitioning of a
ﬂow resulting in a subset of the steps. Furthermore, a
step solves a design problem via a method or simula-
tion model. The step consumes inputs and produces out-
puts. An input can be an executable ﬁle, conﬁguration,
parameter, or constraint. A method or simulation model
are compiled into an executable ﬁle or callable library.
Moreover, an output will be a conﬁguration, which is
produced when the step has been ﬁnished. Each out-
put needs to be validated via a subsequent step includ-
ing a simulation model or evaluation method. In addi-
tion, a control loop between both steps will allow for
several design iterations until an output conforms to the
pre-deﬁned constraints.
The meta-modeling describes the modeling of the
modeling languages. This includes an abstract syntax
and the semantics. For example, a meta-model enables
heterogeneous models of computations in the ESL de-
sign, as presented in [29]. In this paper, a meta-model
of a ﬂow is introduced in Section A. The intension is
to avoid a discussion about the best deﬁnition of the
term model. The considered example is a suitable def-
inition, found in Wikipedia [30]: “A model is a pat-
tern, plan, representation (especially in miniature), or
description designed to show the main object or work-
ings of an object, system, or concept.”. A ﬂow model
is derived from the meta-model. It deﬁnes a set of steps
and views in order to build a ﬂow. The λ-chart [8], de-
scribed in Section C, represents a ﬂow model follow-
ing the meta-model. Meta-models can also be deﬁned
for the application and architecture models further be-
ing implemented in a simulation model and executable
speciﬁcation, respectively. The application model rep-
resents the functions and the data exchange between the
functions of a target application. Moreover, an archi-
tecture model describes the structure and functions of
the intended system, such as the computation architec-
ture, interconnect topology, management infrastructure,
communication protocols, etc. Referring to Figure 1, an
application and architecture model for future embedded
systems are introduced in the Section VII.
A meta-method is a method to analyze another
method.
For example, meta-optimization is an opti-
mization method to tune another optimization method.
In [31], a genetic programming technique has been used
for the meta-optimization in order to ﬁne-tune compiler
heuristics.
In Section VII, the author applies meta-
optimization via an exhaustive search in the Parameter
Tuning ﬂow in order to ﬁnd suitable input parameters
of a genetic algorithm (GA). Referring to Figure 1, the
method denotes a technique for solving an ESL design
problem. Optimization and estimation methods are used
in the case study presented in Section VII.
IV
ESL DESIGN FLOW
Early EDA ﬂows were dominated by capturing and
simulating incomplete speciﬁcations.
Later, the logic
level and register-transfer level (RTL) synthesis allowed
to describe a design only from its behavior and struc-
tural representations. However, a system gap between
SW and HW design exists since SW designers still
provide HW designers with incomplete speciﬁcations.
An executable speciﬁcation, such as implemented via
C++, SystemC [15], LabVIEW [32], Simulink [33], Es-
terel [34], Lustre [35], and Rhapsody [36], closed the
94
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 1. Overview of the design approach.
system gap by describing the system functionality [37].
An ESL ﬂow copes with the design complexity of cur-
rent multi-processor system-on-chips (MPSoCs). It is
expected that the complexity of future many-core SoCs
with thousands of cores will further increase the design
space [38]. An increasing number of components and
their interactions increases the complexity of implement-
ing a many-core SoC ﬂow. The result is a larger num-
ber of steps and the inputs/outputs consumed and pro-
duced by the steps. In addition, the control structure
of a ﬂow will become more complicated. For example,
a step can be dependent on multiple steps. Moreover,
the variation of multiple parameters/constraints may re-
quire nested looping and feedback loops. This section
addresses the complexity problem by introducing an ex-
ecutable ﬂow and the DODF approach. The result is a
uniﬁed methodology to develop, manage, and optimize
ﬂows.
A.
Executable Design Flow
In [1], the authors presented the concept of an integra-
tion of DSE into a system-level speciﬁcation. From that,
the idea of an executable ﬂow [39] has been derived. An
executable ﬂow denotes a program solving certain de-
sign problems and being automatically interpretable by
a machine. In an executable ﬂow, methods and simu-
lation models, assigned to steps, are called in the same
way instructions of a computer program are called by
an interpreter. Predeﬁned methods and models for the
steps, e.g., accessible via C++ libraries, would further
improve the quality, time and costs of a design. In an ex-
ecutable ﬂow, inputs and outputs are consumed and pro-
duced by the steps. The input parameters and constraints
control an execution of the steps in a ﬂow. Moreover, an
output could comprise a conﬁguration of a reﬁned sys-
tem model. Since several input values are most likely
possible, it results in a huge input or design space of an
executable ﬂow. An optimization of the input combina-
tions of each step aims at an adequate step result. Never-
theless, an optimum, comprising all step inputs, is most
Figure 2. An example of an executable design ﬂow.
likely impossible due to the huge design space. This im-
plies several local optima and according design tradeoﬀs.
Moreover, a read access to inputs of a ﬂow will allow for
a detection of interfering, inadequate or missing inputs.
A further goal is to execute as much as possible steps
in parallel. This can be realized for the inputs of a step
or by executing independent steps of a ﬂow in parallel.
A simple executable ﬂow is illustrated in Figure 2. The
ﬂow includes two steps realizing the methods of Dimen-
sioning and Mapping. First, the dimensioning, imple-
mented, e.g., via an estimation method, extracts an HW
architecture from the input conﬁgurations of the HW unit
options and application. Then, simulation results can be
obtained from the mapping of the application onto the
HW architecture, as done in the mapping step. Referring
to Figure 2, an executable speciﬁcation implements the
system functions necessary to evaluate the system per-
formance.
B.
Design of Design Flow
The structure of an executable ﬂow and a methodology
for developing ﬂows are incorporated into the DODF ap-
proach [39]. The concepts and realizations of DODF are
summarized in a hierarchical manner, as seen in Fig-
ure 3. The ﬁgure shows several members assigned to
diﬀerent hierarchical levels. By moving from the outer
part to the inner part of the ﬁgure, the concepts are trans-
formed into concrete realizations.
The Section C in-
cludes an example of a digital ﬁlter design illustrating
an executable ﬂow and the DODF approach.
95
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 3. Hierarchy of concepts and realizations in the
design of design ﬂow.
First of all, the meta-methodology deﬁnes a method-
ology to create ﬂows. Referring to Section III, the pre-
ﬁx “meta” is used since a methodology is considered as
ﬂow. The meta-methodology includes diﬀerent stages
in order to correctly determine and arrange the mem-
bers deﬁned in the DODF hierarchy. For example, once
the steps, their inputs, and their outputs are detected,
the steps need to be combined to a ﬂow in order to re-
alize the design goal. In the DODF hierarchy, seen in
Figure 3, the ﬂow model is a domain-speciﬁc compo-
sition of steps and views. The λ-chart [8] is an exam-
ple of a ﬂow model. As already mentioned before, a
model for the modeling of other models is called meta-
model. From a meta-model, ﬂow models are created for
a speciﬁc domain. Then, ﬂows can be derived from the
domain-speciﬁc ﬂow model. Conceptually, ﬂows are hi-
erarchically composed in order to improve a division of
work by assigning a sub-ﬂow or step to specialists in a
team. Hence, a ﬂow can be a graph or subgraph with ver-
texes representing steps. The steps may further represent
sub-ﬂows, as indicated in Figure 4. Moreover, each step
can belong to a view. Hence, a ﬂow can also include sev-
eral views, as illustrated in Figure 4. A view represents a
level of abstraction in terms of a ﬁlter of selected steps.
In contrast to a hierarchical division of ﬂows into sub-
ﬂow, a view intends extracting a subset of steps assigned
to the view. This allows to focus on selective steps and
sub-ﬂows. For example, Kogel et al. [40] deﬁne the four
views: functional view, architects view, programmers
view, and veriﬁcation view. By deﬁning views, a design
can be explored from diﬀerent viewpoints, such as com-
putation topology, interconnect topology, etc. Then, the
functionality can be separately analyzed to be explored
together in a subsequent design stage. An example is a
step assigning the scheduling of computation tasks and
load/store tasks to separate views. After the scheduling
is explored separately, the results are combined in order
to apply the best scheduling technique for all task types.
Figure 4.
A design ﬂow composed of sub-ﬂows and
steps ﬁltered via the views.
As mentioned before, a ﬂow is a combination of
steps reﬁning a speciﬁcation model into a targeted sys-
tem model. Each step uses inputs to apply a method
or simulation model, which are compiled into an exe-
cutable ﬁle. An input parameter relates to a description
of the structure, behavior, and physical realization of a
component or system. Parameters, conﬁguring a design
method, are also covered. Furthermore, an input con-
straint is a restriction of a component or system, such
as latency, power consumption, or chip area. Then, the
output of a step serves as input for the subsequent step.
As explained before, a ﬂow is derived from a ﬂow
model using the meta-methodology and procedure, re-
spectively, illustrated in Figure 5. The idea is to sys-
tematically determine, assign, and order sub-ﬂows and
the further members of the presented DODF hierarchy,
seen in Figure 3. Moreover, an executable ﬂow is built
through an algorithmic ordering of the sub-ﬂows and
steps. That means, dependencies, loops, branches, etc.,
realize an execution order of sub-ﬂows and steps in an al-
gorithmic manner. Hence, the ordering of steps realizes
a system-level design algorithm based on ﬂow control
structures and patterns, respectively, presented in Sec-
tion B. The meta-methodology glues the members of
the DODF hierarchy together in order to systematically
follow the DODF approach. Referring to Figure 5, the
design goals are ﬁrst determined and sub-ﬂows are ex-
tracted. For example, the design of system components,
such as processors, memory, controller, etc., and the de-
sign in diﬀerent levels of abstraction, such as ESL and
transaction-level (TL), can be modeled into sub-ﬂows.
Then, an algorithmic ordering of the aub-ﬂows needs to
be formulated representing the structure of an executable
ﬂow. The next stage is to determine the design problems
in order to assign each step the corresponding method or
simulation model. A method is determined for a step in
order to solve a design problem. The simulation mod-
96
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 5. A meta-methodology for the proposed DODF
approach.
els are required for measuring the system performance.
Afterwards, each step is assigned a view enabling a hori-
zontal partitioning of the ﬂow. In addition, the inputs and
outputs are determined for each step. The next stage ﬁ-
nalizes the design of an executable ﬂow by bringing the
steps into an algorithmic order. In the end, the ﬂow is
executed based on the algorithmic order and variation of
the inputs. From the interpretation of the results, the de-
sign goals and sub-ﬂows are revised in order to improve
the structure and conﬁguration of the ﬂow.
C.
A First Example - An FIR Filter
In the following, the ﬂow development is illustrated con-
sidering a simple ﬂow. An FIR ﬁlter, an ubiquitous digi-
tal signal processing algorithm, has been chosen and im-
plemented in a simulation model and executable speciﬁ-
cation, respectively. Referring to the meta-methodology
in Figure 5, the goal and ﬂow are ﬁrst determined. The
goal is to minimize area and power consumption of the
memory in an HW implementation of the FIR ﬁlter. This
is realized via exploring a minimal word length for the
bit representation of the FIR ﬁlter coeﬃcients. The sim-
ple ﬂow is composed of two steps FIR ﬁlter simulation
and Validation, as seen in Figure 6. The ﬂow realizes
an algorithmic exploration of the FIR ﬁlter focusing on
the functional view deﬁned in [40]. Hence, the aim is to
ﬁnd the best conﬁguration of the input parameters hold-
ing an error constraint. The ﬁlter coeﬃcients are pro-
vided as real numbers. The word length of each coeﬃ-
Figure 6. An executable design ﬂow for a functional ex-
ploration of the FIR ﬁlter.
Figure 7. A functional simulation of the FIR ﬁlter via
SystemC.
cient radix can be varied separately. The step FIR ﬁlter
simulation requires an executable speciﬁcation, the in-
put stimuli and ﬁlter coeﬃcients as inputs. Referring to
Figure 6, the step calls an executable speciﬁcation sim-
ulating the FIR function. The simulation performance
is evaluated by comparing the output values with a given
Matlab reference and calculating a (mean) absolute error,
as seen in Figure 7. The output of the step is a mean ab-
solute error representing a degradation compared to the
ideal Matlab reference. Referring to Figure 6, the step is
executed until the word length w reaches w = 31. Then,
the Validation step ﬁnds the best conﬁguration that does
not infringe the maximum absolute error constraint. Fig-
ure 7 shows the executable speciﬁcation in terms of a
functional simulation of an FIR ﬁlter implemented via
SystemC [15]. The stimuli represents the input values
of the FIR ﬁlter. The executable speciﬁcation is conﬁg-
ured with the inputs mentioned before. After the error
calculation, a display function returns an absolute error
representing the output of the FIR ﬁlter simulation step.
The following test results are automatically gener-
ated by executing the ﬂow. A 16 taps FIR ﬁlter with
a low-pass characteristic and a cutoﬀ-frequency fg =
4kHz was conﬁgured. In the simulation setup, 1000 uni-
formly distributed random values are used as input stim-
uli ranging from 1 to 100. Moreover, the radix of the
FIR ﬁlter coeﬃcients are jointly varied from 1 to 31 bits.
97
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 8. Experimental results of the FIR ﬁlter explo-
ration.
The results are shown in Figure 8. The curve saturates
at around 28 bits radix word length with a mean error
of 2.6 · 10−7. In the ﬂow, the maximum absolute error
has been set to 10−8. Nevertheless, the parameter varia-
tion in the ﬂow needs to have its granularity reﬁned since
diﬀerent coeﬃcients might have diﬀerent optimal word
lengths. A further analysis is presented in the next sub-
section. The ﬂow is limited to a functional analysis of
the FIR ﬁlter. Hence, the results should be passed to a
ﬂow using executable speciﬁcations at a lower level of
abstraction, such as TL and RTL.
D.
Integrating Design Space Exploration
As mentioned before, an executable ﬂow includes con-
trol structures allowing to vary the inputs. Hence, the
systematic input variation realizes a design space explo-
ration (DSE). On the one hand, the inputs of a step can
be explored limiting the DSE to a step. This refers to
a step-oriented search. On the other hand, the aim is
to ﬁnd a suitable combination of all inputs for the steps
of a ﬂow. This relates to a ﬂow-oriented search. Step-
oriented and ﬂow-oriented search are illustrated in Fig-
ure 9. The step-oriented search is limited to the inputs
of a step, i.e., the parameters p1-2 or p3-4. Instead, the
ﬂow-oriented search aims at exploring all input combi-
nations of a ﬂow, here in the parameters p1-4. The step-
oriented search has been focused in this paper. So far,
an exhaustive search (ES) and heuristic technique (GA)
are developed both applicable to the step-oriented and
ﬂow-oriented search.
The authors refer to [41] for a
comprehensive overview of state-of-the-art search tech-
niques. In general, the DSE methods can be divided into
the problem space or the solution/objective space. In the
problem space, the parameters, deﬁned in a speciﬁca-
tion, are considered. An example is a design of a register
bank, for which a discrete set of word lengths (columns)
and number of words (rows) are available. Now, all pos-
Figure 9. Step-oriented vs. ﬂow-oriented search in an
executable ﬂow.
sible parameter combinations of columns and rows can
be searched within the problem space. In this scenario,
the solution space is driven by constraints, such as la-
tency, power, and area. An according DSE strategy can
be realized in an unguided or guided manner. ES is a
representative of an unguided type allowing for an unbi-
ased view on the design space. Heuristic search, such as
hill climbing and GA, is a path-oriented method. It in-
corporates knowledge in order to guide the search along
a path. The advantage is that the intermediate search re-
sults may be reused.
As mentioned before, parameters and constraints are
similarly represented in a step and ﬂow. Depending on
the number of inputs and their range of values, a design
space may be divided into sub spaces. The realization
of the ES is rather trivial, for example the inputs can
be iteratively incremented or taken from a predeﬁned
list. In this paper, a GA is presented implementing a
heuristic search in the design space. The GA needs to
be conﬁgured in terms of a minimization or maximiza-
tion problem. An one-chromosome individual is used to
describe the DSE problem. The chromosome includes
an one-dimensional array of genes. Each gene denotes
an input and the gene value deﬁnes an according value.
For example, a chromosome g = (3, 2, 5) includes three
inputs. The corresponding gene values are in the inte-
ger range. Hence, a set or range of values has to be
deﬁned for each input.
Given a randomly initialized
population, the GA generates its oﬀspring via variation.
Each chromosome is evaluated by calculating a ﬁtness
value. The calculation is done externally in a step and
the ﬁtness value is gathered by the GA. In addition, the
GA prevents from recalculating already evaluated solu-
tions. Furthermore, variation through an one-point mu-
tation and order crossover enables an iterative improve-
ment of the oﬀspring. In an executable ﬂow, the imple-
mentation of a step-oriented and ﬂow-oriented search is
realized by an expansion of the executed nodes, namely
steps and ﬂows. Figure 10 shows an iterative execution
of many steps/ﬂows parallelized via a selection node and
98
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 10. Step-/ﬂow-oriented search via parallelization,
synchronization, iteration, and feedback.
synchronized via an evaluation node. In case of an ES,
only one iteration is necessary. For each iteration, the
GA selects the steps/ﬂows from the population and eval-
uates the individuals via a provided ﬁtness value. Hence,
the selection node performs the genetic operators, such
as initialization, mutation, crossover, replacement, and
selection. An end of the GA-based search is determined
by the number of iterations (generations). This requires
a feedback-loop between the selection and evaluation
nodes. Further stopping criteria can be included. More-
over, the initialization of the GA population can be used
to realize a random (Monte Carlo) search. Hence, the
population size corresponds to the number of random
samples and the number of generations is set zero.
The step-oriented search is demonstrated via the
FIR ﬁlter example presented before.
The number of
taps (#taps) of the FIR ﬁlter is #taps=16 and the word
length w of each coeﬃcient radix is deﬁned in the range
of 1 ≤ w ≤ 31 bits. Hence, 3116 input combinations mo-
tivate for solving the optimization problem via the GA
search. Equation (1) deﬁnes the ﬁtness (objective) func-
tion in terms of a minimization.
γ ·

1
#taps
#taps
X
i=1
wi
wmax

|                {z                }
word length
+ (1 − γ) ·
1 − emin
abs
eabs

|       {z       }
absolute error
→min
(1)
As mentioned before, Equation (1) needs to be im-
plemented in the FIR ﬁlter simulation in order to pro-
vide a ﬁtness value for the GA. The ﬁtness function ﬁnds
a tradeoﬀ between the conﬂicting goals of a minimal
word length of the coeﬃcients and a minimal absolute
error. The weight γ realizes a prioritization between both
goals. The ﬁrst term minimizes the word length wi of the
taps i. In the example, the FIR ﬁlter requires 16 taps and
coeﬃcients, respectively. Then, wmax = 31 bits denotes
the maximum word length conﬁgurable in the FIR ﬁlter
step. In addition, the second term targets a minimiza-
tion of the absolute error eabs. Referring to Figure 7, the
error is calculated from comparing the ﬁlter output in
case of quantized coeﬃcients with a non-quantized ref-
erence generated via Matlab. Following, emin
abs represents
the minimum absolute error obtained from an FIR ﬁlter
step by using the maximum word length wmax = 31 bits
for all coeﬃcients. Figure 11 shows the GA search re-
sults in terms of two convergence plots. In the follow-
ing, the GA is used in order to ﬁnd a minimum ﬁtness
value. The maximum absolute error is set to emax
abs = 10−3
in the FIR ﬁlter step.
In case the constraint is vio-
lated, the FIR ﬁlter simulation returns a very large ﬁt-
ness value indicating an invalid solution. In addition,
the weight γ = 0.3 prioritizes the error minimization ac-
cording to the error constraint introduced before. From
the FIR ﬁlter results in Figure 8, it is known that an aver-
age bit width of w = 15 reaches a good solution holding
the given error constraint. The goal is to reduce the av-
erage bit width w not violating the constraint. Hence,
the bit width of the coeﬃcients is varied in the interval
13 ≤ wi ≤ 17. Furthermore, the GA parameters are set
as follows: pS ize = 50, nGen = 100, mRate = 0.1,
cRate = 0.8, and rRate = 0.5. In Figure 11, the upper
plot shows that the GA converges after 85 generations
with a ﬁtness value of 0.6231. Please note, the small de-
crease of the ﬁtness value at 85 generations is not vis-
ible in the ﬁgure.
From the lower plot in Figure 11,
the according absolute error eabs = 0.00081 and average
bit width w = 14.3125 bits can be obtained. Hence, the
applied GA search has reduced w by almost 5% com-
pared to the result illustrated in Figure 8. In addition, the
GA outperforms the average bit width w, obtained via a
Monte Carlo simulation and holding the error constraint,
by around 12%. The GA generated 332 diﬀerent solu-
tions and the DSE ﬁnishes after 72 seconds on an Intel
Core 2 Duo L7500 with 1.6 GHz utilizing one core. This
shows the eﬃciency of the GA compared to the 516 so-
lutions of an exhaustive search and a solution via Monte
Carlo simulation. Nevertheless, an optimal solution can
not be guaranteed due to the heuristic nature of a GA.
V
MODELING DESIGN FLOWS
This section introduces a meta-model representing an
abstract ﬂow model [39]. Moreover, ﬂow patterns are
shown in terms of reusable ﬂow structures. Given the
meta-model and patterns, a derivation of a ﬂow is illus-
trated based on the modiﬁed λ-chart model [8].
99
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 11. Convergence plots of the GA search in the
FIR ﬁlter example.
A.
Meta-Model of Design Flows
A meta-model has been developed in order to provide a
minimal set of generic modeling elements necessary to
build a ﬂow. The meta-model is described via a UML
class diagram, seen in Figure 12. It represents a funda-
ment or kernel of the language design and implementa-
tion presented in the Section VI. The language elements
relate to the meta classes. The Element class contains
Properties and Transitions from/to elements.
A tran-
sition between two elements is used to model a unidi-
rectional dependency and a property represents an input,
output, or further information added to an element. The
transition also models a relationship between two ﬂows.
Moreover, both Flow and Node inherit from the element
class. The assignment of elements to a view is realized
via a property class. Moreover, a ﬂow may include many
nodes. Flows may have a nested structure consisting of
many ﬂows. This allows to reduce model complexity and
to improve the reuse of available ﬂows. Finally, a node
represents an executable element, such as step, loop and
branch nodes. Loop and branch nodes are further used
to describe an algorithmic ordering of ﬂows and steps, as
introduced in Section B.
Figure 12. A meta-model for the derivation of design
ﬂows.
B.
Design Flow Patterns
In addition to the meta-model described before, a deriva-
tion of recurring structures of ﬂows allows to determine
further modeling elements necessary for a systematic
construction of ﬂows. The ﬂow patterns, illustrated in
Figure 13, are a key enabler of the language design and
implementation presented in Section VI. In principle,
the patterns describe a parallel, iterative and conditional
execution of ﬂows.
Pattern (a) models a data depen-
dency between two steps. Hence, the subsequent step is
fed with inputs produced by its predecessor. An exam-
ple is that a scheduling step produces application map-
pings further being analyzed by a validation step. More-
over, a control dependency models decision making in
a ﬂow as seen in pattern (b).
It shows a conditional
statement deciding for one of two steps depending on
the output of a previous step. An example is that only
one of the two conﬁgurations of a scheduling step will
be selected based on the output of a provisioning step.
Moreover, pattern (c) describes a divide and conquer
approach aiming at a recursive break down of a prob-
lem into sub-problems.
A possible realization would
be that a ﬂow contains several sub-ﬂows representing
the sub-problems. In pattern (d), a parallel execution of
many steps and the synchronization of the results are de-
scribed. An example would be to execute the same step
with diﬀerent conﬁgurations multiple times in parallel
and choosing the best output as input of a subsequent
step. Moreover, pattern (e) and pattern (f) consider iter-
ations in a ﬂow. In pattern (e), a step is executed until an
end condition reaches. For example, a step increments
a parameter in order to ﬁnd a suitable parameter value.
Pattern (f) shows an iterative execution based on a feed-
back from a subsequent step. The information may al-
low for changing the selected inputs in order to improve
a step result.
100
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 13. Reoccurring structures (patterns) in design
ﬂows.
C.
Domain-Speciﬁc Design Flow
In a previous work [8], the authors introduced the
λ-chart, which represents a model of design abstraction
and exploration. It addresses an ESL design of MPSoCs
and future many-core SoCs at an early stage. The mo-
tivation was to provide the designer with a ﬂow model
allowing for a clear deﬁnition of the steps and a sepa-
ration of the important system functions. Therefore, an
administration view was included in order to highlight
the rising importance of management functions in em-
bedded systems. The model further allows to combine
the diﬀerent steps of a ﬂow. In the following, the λ-chart
has been slightly modiﬁed in order to focus more on the
design and exploration of the system resources, as illus-
trated in Figure 14. In addition, the term administration
has been replaced by a more management-centric point
of view. Hence, the λ-chart deﬁnes three views allow-
ing to separate the orthogonal system functions. A re-
source management view considers tasks for planning,
assignment, monitoring, and control. Instead, a com-
putation resources view relates to the code execution.
Moreover, a data logistic resources view addresses a de-
sign of data storage and data exchange between compo-
nents. Furthermore, the concentric bands underline the
ﬁve steps of a uniﬁed process. The modeling and par-
titioning step describes a starting point in order to build
the representations of the system structure and behav-
ior.
Partitioning focuses on the parallelization of ap-
plications. Following, provisioning means to select the
type and number of components and behavior necessary
Figure 14. The modiﬁed λ-chart [8] - A model of design
abstraction and exploration.
to fulﬁll the purpose of the intended system. In schedul-
ing, a temporal planning of the computation, data logis-
tics and management is applied. This includes both the
application and architectural components, such as deter-
mining an execution sequence, power-aware planning,
monitoring, etc. Moreover, the allocation step focuses
on spatial planning, such as placement and packaging of
components, and application binding. Finally, validation
proves whether the system fulﬁlls a previously deﬁned
purpose. The authors refer to [8] for a more detailed ex-
planation.
The λ-chart follows the meta-model presented in
Section A. That means, a step is derived from the node
element and a ﬂow is a sequence of steps connected via
transitions. Moreover, a view is modeled via the property
element. An example of a ﬂow, depicted in Figure 15,
demonstrates the derivation of a ﬂow from the λ-chart.
Three steps, limited to the computation resources view,
have been chosen. The combination of the steps and a
connection via transitions build the ﬂow. The block di-
agram in Figure 15 shows an equivalent representation
of the ﬂow. In addition, control primitives, such as a
branch node (if-then-else, switch-case) and loop node
(for/while), are inserted in a ﬂow enabling a parallel, it-
erative and conditional execution of the ﬂow. This al-
lows to realize the ﬂow patterns presented before. In
Section IV, the DODF approach was introduced, giving
the designer a methodology to select appropriate ﬂows,
views, steps, etc. The control structure is build via an
algorithmic order of the steps. Figure 16 details the in-
stantiation from the Element, Transition and Property
classes deﬁned in the meta-model. Figure 16 (left) shows
101
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 16. An example of a λ-chart ﬂow with instantiation from the meta-model.
Figure 15. An example for the derivation of a ﬂow in the
modiﬁed λ-chart.
a ﬂow traversing the allocation and validation steps it-
eratively. The DSE is restricted to the data logistic re-
sources view. In the following, a limited part of the ﬂow,
marked by a dotted line, is considered. Referring to Fig-
ure 16 (right), the example focuses on the allocation step,
loop node, and transition from the loop to allocation. The
loop node controls an iteration of the input parameters
of allocation and includes an exit condition. Moreover,
the ﬂow is named network-on-chip (NoC) DSE. NoC is
a promising network design approach for scaling from
MPSoC to many-core systems because the eﬃcient com-
munication infrastructure supports a large amount of IP
cores [42, 43]. As mentioned before, an assignment of
the allocation step to a view is realized via the Property
class. The step also includes properties, such as the num-
ber of rows in a NoC. Hence, the properties are used as
input parameters of a step.
VI
ESL DESIGN AUTOMATION
A comprehensive list of academic and commercial EDA
environments for ESL design can be found in [2]. Mod-
ern environments address DSE but with the limitation to
a proprietary implementation for a speciﬁc design prob-
lem, such as optimization of the application mapping.
Recent research introduces generic infrastructures turn-
ing away from ad-hoc software [6, 7]. Nevertheless, the
complexity of ﬂows for future embedded systems is not
yet considered. The large number of ﬂows, steps, inputs
and outputs requires a more systematic development. In
addition, commercial EDA systems allow for a ﬂexi-
ble and eﬃcient implementation of ﬂows via scripting
languages. The major drawback of academic and com-
mercial EDA systems is that no systematic development,
management and optimization of ﬂows is supported. The
user is either dependent on a proprietary implementation
or has to develop a representation of a ﬂow by oneself.
This paper presents two programming languages [39] ad-
dressing these problems and supporting all aspects of our
DODF approach.
Therefore, the user is supported in
developing, managing, and optimizing a ﬂow. This in-
cludes ﬂexible and eﬃcient realization of DSE strategy
in the ﬂow via little program code. First of all, a visual
programming language is introduced. This language has
been evolved to a textual programming language, called
102
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

design ﬂow language (DFL). A tool ﬂow, enabling DFL,
is presented afterwards.
A.
Visual Programming of Flows
A visual programming of ﬂows has been implemented
via a graphical prototype based on Microsoft Visio by
the authors [1]. It realizes the concepts introduced in
the Sections IV and V. The implementation allows to
instantiate steps and ﬂows via drag-and-drop and copy
functions using the λ-chart model. The graphical user
interface (GUI) corresponds to the visualization in Fig-
ure 16 (left). The construction of a ﬂow from the GUI
has been realized via the visual basic for applications
(VBA) programming language by detecting the depen-
dencies between the steps and reading the properties of
the steps. The prototype includes an import/export func-
tion in order to load and store the ﬂows based on a prede-
ﬁned XML-format. The deﬁnition of the XML-format is
explained via a simple ﬂow, illustrated in Listing 1. The
ﬂow corresponds to the Figure 16 (left). The XML-ﬁle
is read by an interpreter program implemented in C++.
The interpreter allows for a sequential and parallel exe-
cution of the steps. Referring to Listing 1, the ﬂow and
node tags follow the meta-model presented in Section A.
The step and loop nodes are connected via transitions
and include many properties. Moreover, the loop node
requires a loop/exit body and an exit condition in order to
traverse the ﬂow iteratively. In a property value, expres-
sions and system functions are used to read and modify
variables, directories, and ﬁles during a step execution.
Referring to Listing 1, the step “My Allocation”
(lines 3-10) and the step “My Validation” (lines 11-14)
are created. Therein, several properties are deﬁned, such
as Step, View, etc. Moreover, the Rows property (line 6)
is initialized to three.
Together with the Arguments
(line 7), Rows will be used as input of the IPCoreMap-
ping tool (line 8). Moreover, the loop node (lines 16-
21) deﬁnes several expressions in order to increment the
Rows property (line 18), to check for the exit condition
(line 19), and to deﬁne an action after the exit (line 20).
Finally, the ﬂow is constructed by connecting the steps
via transitions (lines 22-24).
Nevertheless, the XML-format makes it inconve-
nient to program multiple expressions, nested condi-
tions, nested loops, and feedback loops. In addition, a
reuse of ﬂows and steps is not supported. The limitations
motivated for an evolution towards the DFL representing
an eﬃcient and ﬂexible programming language.
B.
Design Flow Language (DFL)
DFL is specially targeted to a development, manage-
ment and optimization of ﬂows including the necessary
1 <?xml version=" 1.0 "
encoding="UTF−8" ?>
<flow>
3
<node name="My A l l o c a t i o n ">
<p r o p e r t y
name=" Step "
value=" A l l o c a t i o n " />
5
<p r o p e r t y
name="View"
value=" Data
L o g i s t i c
Resources " />
<p r o p e r t y
name="Rows"
value="3" />
7
<p r o p e r t y
name=" Arguments "
value="−app_in
lambda \ \ a p p s _ s t a t e . xml
. . . " />
<p r o p e r t y
name=" Tool "
value=" IPCoreMapping
" />
9
<!−−
. . .
−−>
< / node>
11
<node name="My V a l i d a t i o n ">
<p r o p e r t y
name=" Step "
value=" Scheduling " />
13
<p r o p e r t y
name="View"
value=" Data
L o g i s t i c
Resources " />
<!−−
. . .
−−>
15
< / node>
<node name="My Loop ">
17
<p r o p e r t y
name=" type "
value="LOOP" />
<p r o p e r t y
name=" loop_body "
value="Rows=
Rows+1;
. . . " />
19
<p r o p e r t y
name=" e x i t _ c o n d i t i o n "
value="
Rows==4;
. . . " />
<p r o p e r t y
name=" exit_body "
value="
renameDir ( lambda \ \ maps , Rows ) ;
. . . " />
21
< / node>
< t r a n s i t i o n
source="My A l l o c a t i o n "
t a r g e t ="My
V a l i d a t i o n " />
23 < t r a n s i t i o n
source="My V a l i d a t i o n "
t a r g e t ="My
Loop " />
< t r a n s i t i o n
source="My Loop "
t a r g e t ="My
A l l o c a t i o n " />
25 < / flow>
Listing 1. XML source code imported/exported by the
visual programming prototype.
control and automation capabilities. Moreover, design
space exploration (DSE) is directly considered in the lan-
guage design and implementation. The requirements and
structure of DFL are shortly introduced in the follow-
ing. A simple ﬂow example illustrates the use of the
language. For more details on the language, the authors
refer to [39].
Language Requirements
The purpose of DFL is to make the design of future em-
bedded systems more ﬂexibly and eﬃciently via a sys-
tematic development of ﬂows. This includes manage-
ment and optimization capabilities. The requirements
are summarized in the following.
A clean syntax in-
creases the user’s productivity. Program commands for
the construction of ﬂows are necessary.
As in mod-
ern programming languages, control structure and pro-
gram modularization enable more complex applications.
Moreover, an acceleration of ﬂows via parallelization
103
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

should be realized. The use of DSE techniques within
a step or ﬂow will allow to ﬁnd an optimal or feasible
solution in design spaces with diﬀerent complexity. Fur-
ther requirements relate to the EDA tools and design data
accessible via DFL. An executable ﬁle or library needs
to be assigned to a step. Moreover, design data should
be accessible via data structures, ﬁles, and data base op-
erations. In addition, some kind of inter-process com-
munication serves as interface between the EDA tools.
Finally, non-functional requirements address an access
from/to other programming languages. Moreover, data
analysis and debugging support will be beneﬁcial in a
ﬂow development.
Language Structure
The DFL is an imperative (procedural) programming
language read by an interpreter program.
The inter-
preter controls an execution of the steps deﬁned in a
ﬂow. The syntax is derived from the C/C++ program-
ming language widely known in HW/SW programming.
The Flow, Step, Property and Transition classes, deﬁned
in the meta-model and introduced in Section A, have
been integrated in the language design and implemen-
tation. Modularization is realized via subroutines and an
#include statement. Basic data types (bool, int, double,
string) and complex data types (vector, Flow, Step) are
available. DFL is further a structural programming lan-
guage supporting a full set of control primitives, such as
for, while, if-then-else and switch-case. The language
includes a limited number of keywords and various in-
put/output names are reserved for the step and ﬂow. DFL
additionally supports typical arithmetic operators, log-
ical operators, and vector indexing.
Moreover, com-
mands are case sensitive and single statements must be
ended with a semicolon.
A Simple Design Flow in DFL
In the Listing 2, a simple ﬂow is described in DFL il-
lustrating its structure. The program accomplishes an
execution of two dependent steps in a ﬂow, which corre-
sponds to Figure 16 (left). Lines 2-8 relate to the con-
ﬁguration of an allocation step. This includes an assign-
ment of an executable ﬁle, called alloc(.exe), to the step
(line 3). The executable requires arguments (line 6) and
an input (line 7) in order to solve the IP core mapping
problem (line 4). In addition, the View parameter cor-
responds to the λ-chart in Figure 16. Since the step al-
lows for several input combinations, here indicated via
the rows vector (line 7), it is conﬁgured for a parallel ex-
ecution (lines 10-13). A space vector contains the vari-
ables deﬁning the input combinations (lines 10-11). The
input parameter HPCJob (line 13) conﬁgures an avail-
able high performance cluster (HPC) environment for a
parallel execution of the steps. Then, a validation step
(lines 15-16) is instantiated. Further assignments to the
step are left out for simpliﬁcation. Finally, the ﬂow is
constructed (lines 19-22) and executed (line 24). The
steps need to be added to the ﬂow (line 20) and the
execution order is determined via the connect function
(line 21). Line 22 saves the ﬂow description in the visu-
alization of compiler graph (VCG) format [44] allowing
to check the ﬂow structure.
1 /∗∗∗∗∗∗∗∗ ALLOCATION STEP ∗∗∗∗∗∗∗∗/
Step
s1 = Step ( " A l l o c a t i o n " ) ;
3 s1 . add ( " Execution " ," a l l o c " ) ;
s1 . add ( " Tool " ," IPCoreMapping " ) ;
5 s1 . add ( " View " ," Data
L o g i s t i c
Resources " ) ;
s1 . add ( " Arguments " ," − app_in
lambda \ \ a p p s _ s t a t e
. xml
. . . " ) ;
7 vector <int > rows = [ 3 : 4 ] ;
/ /
. . .
9 /∗∗∗∗∗∗∗∗ PARALLEL EXECUTION ∗∗∗∗∗∗∗∗/
vector <s t r i n g > space ;
11 space . push_back ( " rows " ) ;
s1 . add ( " Space " ," space " ) ;
13 s1 . add ( " HPCJob " ,
" t r u e " ) ;
/∗∗∗∗∗∗∗∗ VALIDATION STEP ∗∗∗∗∗∗∗∗/
15 Step
s2 = Step ( " V a l i d a t i o n " ) ;
s2 . add ( " Execution " ," v a l i d " ) ;
17
/ /
. . .
/∗∗∗∗∗∗∗∗ FLOW CONSTRUCTION ∗∗∗∗∗∗∗∗/
19 Flow
f ;
f . add ( s1 ) ;
f . add ( s2 ) ;
21 connect ( s1 , s2 ) ;
f . save ( " vcg " ,
" flow . vcg " ) ;
23 /∗∗∗∗∗∗∗∗ FLOW EXECUTION ∗∗∗∗∗∗∗∗/
execute ( f ) ;
Listing 2. Simple design ﬂow in DFL.
DFL Tool Flow
In the following, the tool ﬂow for the DFL is presented.
As typical for modern programming languages, it is sep-
arated into frontend, middle-end, and backend.
Fig-
ure 17 illustrates the tool ﬂow. The frontend includes a
scanner and parser to validate the DFL syntax. The scan-
ner splits the DFL source code into tokens by recogniz-
ing lexical patterns in the text. GNU Flex [45] has been
used to generate the scanner (lexical analyzer). Then,
the parser applies syntax-rule matching. The parser has
been generated using GNU Bison [46]. From the pars-
ing results, an abstract syntax tree and a statement list
are derived. In addition, a symbol table holds informa-
tion about the program. The statement list and symbol
table allow to interpret and optimize the program code,
104
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 17. Tool ﬂow for the design ﬂow language.
as done in the middle-end. The interpreter is responsi-
ble for type checking, type erasure (conversion), and ex-
pression evaluation. The code optimization refers to an
exploitation of the step-level and ﬂow-level parallelism.
As mentioned before, the interpreter supports an export
of the ﬂow structure in the VCG format [44] in order to
visualize the graph. Moreover, the explorer includes an
exhaustive, random and heuristic search allowing to ex-
plore design spaces with diﬀerent complexity. Finally,
the backend provides functionality executing a DFL pro-
gram on a single computer or HPC. After a step execu-
tion, according design and validation data will be avail-
able for a further analysis. The next stage is to merge
DFL and model/method design into an integrated devel-
opment environment (IDE), presented in [39]. Therein,
the design methods and simulation models are imple-
mented via a native language, such as C/C++, in order
to fulﬁl the critical performance requirements. The aim
is to compile an executable or library and assign it di-
rectly to a DFL step in one IDE realizing a seamless de-
velopment. Then, the ﬂow can be executed, tested, and
optimized in the IDE. The DFL implementation includes
a full set of language features. Open topics relate to the
implementation of performance analysis functions, plot-
ting functions, and database access. Furthermore, a fu-
ture DFL revision needs to address name spacing avoid-
ing naming conﬂicts.
VII
DESIGN FLOW CASE STUDY
This section demonstrates the concept of an executable
ﬂow and the DODF approach under realistic conditions.
The case study targets an ESL design of the heteroge-
neous multicluster architecture, as introduced by the au-
thors in [1].
The multicluster architecture represents
a promising candidate for future embedded many-core
SoCs [12].
The outline of this section is as follows:
First, a description of the application and architecture
model forms the basis of the underlying simulation mod-
els. Next, an according sequence of ﬂows is introduced
showing a separation of the addressed design problems.
This allows to solve the complex problems more ﬂex-
ibly and more eﬃciently as compared to a proprietary
and fully integrated design ﬂow. Due to a lack of space,
only the dimensioning of the multicluster architecture is
selected for a more detailed explanation in terms of a de-
sign methodology, ﬂow description, and the experimen-
tal results.
A.
Application and Architecture Model
The models consider functionalities of the three views
deﬁned in the modiﬁed λ-chart, seen in Figure 14. The
application model includes multiple, concurrently run-
ning applications and threads, respectively.
A thread
is represented by a high-level task graph and it sequen-
tially executes tasks. Threads are only synchronized be-
fore or after execution. Then, a task is an atomic ker-
nel exclusively executing on an intellectual property (IP)
core, e.g., processing element (PE), memory (MEM) in-
terface, control processor (CP) interface, etc. Tasks pro-
duce and consume chunks of data accessed via shared
memory. Side eﬀects are excluded by preventing access
to external data during computation.
As shown in Figure 18, the architecture model is
a heterogeneous set of multiprocessor system-on-chips
(MPSoCs) and clusters, respectively. The management
unit (MU) represents an application processor and in-
cludes a load balancer aiming at equally distributing
thread load amongst the clusters. Moreover, an MPSoC
contains heterogeneous types and numbers of IP cores.
In the model, each MPSoC contains a network-on-chip
(NoC) connecting the IP cores. Moreover, each clus-
ter includes a CP responsible for dynamically schedul-
ing arriving tasks to the available IP cores. The CPs are
directly connected to the MU. The heterogeneous multi-
cluster architecture, seen in Figure 18, includes a regular
2D mesh NoC. Each tile contains a router and n mod-
ules (IP cores). A module can be an MEM, CP, or PE,
such as general purpose processor (GPP), digital signal
processor (DSP), application-speciﬁc integrated circuits
(ASIC), etc.
B.
Sequence of Design Flows
This case study is composed of ﬁve ﬂows using dif-
ferent design methods and system models. Figure 19
illustrates a sequence of the ﬂows. Further ﬂows can
be added, such a memory optimization. The heteroge-
105
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 18. An architecture model for the heterogeneous
multicluster.
neous multicluster architecture implies a wide diversity
in terms of structural, behavioral (functional) and physi-
cal parameters. DFL programs have been developed for
the ﬂows. Therein, the view and step deﬁnitions fol-
low the modiﬁed λ-chart model. Referring to Figure 19,
this case study addresses input parameters of the design
method, structural design, behavioral design, and phys-
ical design. In the following, the ﬂows are shortly in-
troduced and a DFL program for the sequence of ﬂows
is presented. The rest of this section will focus on the
multicluster dimensioning.
• Parameter Tuning aims at ﬁnding the best tool pa-
rameters for a GA solving the IP core mapping
problem [47];
• Multicluster Dimensioning creates a heterogeneous
multicluster architecture by distributing the antic-
ipated application load among clusters and solv-
ing the optimization problem via a genetic algo-
rithm (GA) and mixed-integer linear programming
(MILP) formulation [48];
• IP Core Mapping places IP cores in an 1-ary n-
mesh NoC constrained by the number of modules
at each router. The optimization problem is solved
via a GA and MILP formulation [47];
• NoC Arbitration and Multicluster Load Balancing
aim at ﬁnding suitable behavioral schemes from a
selection based on simulation results. NoC Arbi-
tration compares a locally fair with a globally fair
arbitration scheme [49]. In addition, ﬂit-based and
packet-based switching are considered. Multiclus-
ter Load Balancing compares diﬀerent estimators
of cluster load, such as response time and queue
size, used in the load balancing scheme of an MU.
Figure 19. The sequence of ﬂows in the case study.
In the following, a DFL program for the sequence
of the ﬂows is presented. The ﬂows Parameter Tuning
and Multicluster Load Balancing are used as examples.
The source code of parameter_tuning.dﬂ, shown in List-
ing 4 in the appendix, gives a deep insight into a ﬂow
developed in DFL. Referring to Listing 3 (lines 2-3),
the #include directive allows to insert predeﬁned DFL
source code as mentioned in the previous section. The
variables tun and bal are declared in one include ﬁle
and they represent the predeﬁned ﬂows of the Parame-
ter Tuning and Multicluster Load Balancing. After the
#include, an execution sequence is scheduled by insert-
ing an identiﬁer for each ﬂow in the vector ﬂow_order
(lines 5-9). Thereafter, the vector is iterated (lines 11-42)
and a switch-case statement (lines 17-38) lists the avail-
able ﬂow choices. If a ﬂow matches a case statement, it
is executed and a status message is displayed (lines 40-
41). The example further includes two speciﬁc inputs
and vectors, respectively (line 15). The elements of each
vector are used for a DSE purpose, such as searching for
the best conﬁguration. The DSE is declared in the steps.
The input arch_in represents a set of available architec-
ture conﬁgurations. The elements in the vector are used
as parameter values for the tun step (line 21) and the bal
step (line 28). In addition, the vector conﬁg includes dif-
ferent conﬁgurations of the simulation setup for the bal
step in order to select a suitable load balancing scheme
(line 28). The sequence of ﬂows can be further extended
in terms of additional ﬂows, inputs, and, commands.
C.
Multicluster Dimensioning
Given a set of target applications, the Multicluster Di-
mensioning ﬂow realizes a provisioning of resources in
the heterogeneous multicluster architecture [48].
The
aim is to generate an appropriate distribution of the ap-
plications onto the clusters containing diﬀerent types and
numbers of PEs.
The E3S Benchmark Suite [50] is
106
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

used as basis of the applied application scenario. E3S
is largely based on data from the Embedded Micropro-
cessor Benchmark Consortium [51]. The included task
graphs describe periodic applications. The 20 applica-
tions range from automotive, industrial, telecommunica-
tion, networking to general-purpose applications. An ap-
plication scenario is built from the concurrently running
task graphs.
An overview of the methodology is illustrated in Fig-
ure 20. Besides optimization of the multicluster archi-
tecture, the ﬂow applies further methods, such as esti-
mation, (architecture) reﬁnement, simulation, and vali-
dation. Referring to Figure 20, the ﬁrst step is to extract
a parallelism value matrix Φ via parallelism analysis, in-
troduced by the authors in [48]. The matrix is used as
input for the optimization via a GA and MILP formu-
lation. Given the optimized cluster conﬁgurations, the
selected IP cores are used to generate an multicluster ar-
chitecture. Then, the dynamic mapping of an application
onto the reﬁned architecture is simulated. Each task of
an application is dynamically mapped onto an IP core at
runtime assuming a point-to-point communication pro-
tocol between the directly connected IP cores. Each task
is executable on at least one IP core of the reﬁned ar-
chitecture ensuring schedulability. Moreover, a task ex-
ecution is prioritized based on its deadline. Afterwards,
the mapping results are validated by an average thread
response time quantifying the system performance. Re-
sponse time deﬁnes the time from the request of a thread
until its end including a possible network delay.
A compact ﬂow description, seen in Figure 21, is
realized via the modiﬁed λ-chart. The ﬂow focuses on
a suitable computation infrastructure for the heteroge-
neous multicluster architecture. Hence, DSE is limited
to the computation resources view. The modeling and
partitioning step serves as a starting point without any
further purpose. In the provisioning step, a target appli-
cation and the available IP cores are used to generate the
heterogeneous multicluster architecture. As mentioned
before, the optimization problem is solved via a GA and
MILP formulation. The subsequent scheduling step per-
forms an application mapping via simulation. An ac-
cording simulation model performs both a temporal and
spatial mapping of the tasks to the available PEs dynam-
ically at runtime. The results are analyzed in the vali-
dation step. Referring to Figure 21, a loop node incre-
ments a maximum allowed number of PEs in a cluster
(#PEsmax). For the simulations, the value range of the
input constraint is set to 3 ≤ #PEsmax ≤ 7.
In the literature, to the best knowledge of the authors,
multicluster dimensioning was not yet applied for the
E3S Benchmark Suite [50]. In order to compare the re-
Figure 20. Methodology of the Multicluster Dimension-
ing ﬂow.
Figure 21. Overview of the Multicluster Dimensioning
ﬂow via the modiﬁed λ-chart.
107
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

sults, a single-cluster conﬁguration with nine PEs is pro-
vided as reference in Figure 22. It has also been gener-
ated with the Multicluster Dimensioning ﬂow. Applica-
tion mapping onto the single-cluster architecture results
in over 40 % thread cancelation. Then, using the thread
response time as a metric would be meaningless, hence
the total amount of PEs is considered as a reference.
Figure 22. Single-cluster reference for the Multicluster
Dimensioning ﬂow.
Figure 23 shows the validation results in terms of
a total number of clusters/PEs and (average) thread re-
sponse time. The latter includes the impact of the dy-
namic scheduling scheme. The GA has been used to
solve the multicluster dimensioning problem. All val-
ues have been normalized to the largest occurring value.
The selection of a suitable solution bases on a trade-
oﬀ between the conﬂicting goals of a minimum number
of resources and a minimum thread response time. In
the ﬁgure, #PEsmax = 7 (red arrow) is selected as the
best tradeoﬀ. Its application mappings did not produce
aborted threads. It includes a minimum number of clus-
ters of three and PEs of eleven. As mentioned before,
each cluster contains a CP further increasing the number
of resources in the system. In the result, the number of
clusters and PEs do not change for the larger #PEsmax
values. But due to its heuristic nature, the GA produced
the best solution in terms of a thread response time for
#PEsmax = 7. The resulting conﬁguration, depicted in
Figure 24, represents a heterogeneous multicluster so-
lution since all clusters are heterogeneous in terms of PE
types (depicted by diﬀerent shades of grey). In the Fig-
ure 24, it is shown that the PEs of the PE types AMD
K6-2E+ and IBM PowerPC are marginally used. The
both GPPs are able to execute most of the tasks in the
benchmark. The remaining PEs are well utilized using
the anticipated application load based on the average par-
allelism values. The conﬁguration shows improvement
potential in the cluster C2. A solution would be to ex-
clude the IBM PowerPC from the mapping option table
in order to reduce the number of PEs in the cluster by
one PE. This requires that the PE can be replaced and no
additional PE is necessary to perform the tasks assigned
to the IBM PowerPC. Hence, the total number of PEs
decreases to ten.
Figure 23. Normalized results of the Multicluster Di-
mensioning ﬂow.
Figure 24. Best multicluster conﬁguration of the Multi-
cluster Dimensioning ﬂow.
VIII
CONCLUSION AND OPEN TOPICS
The large number of inputs and steps in the ﬂows for
future embedded systems necessitates the development
of a systematic design of design ﬂow (DODF) approach.
Then, the concept of an executable ﬂow allows for ex-
ecuting steps in the same way instructions of a program
are processed. Both contributions of this paper are exem-
pliﬁed via a functional exploration of an FIR ﬁlter. Af-
terwards, the modeling principles of ﬂows are explained.
The idea of abstracting the ﬂows and a corresponding
derivation of a domain-speciﬁc ﬂow are focused. The
concepts are the motivation for a visual and textual de-
sign ﬂow language. The design automation allows for a
development, management, and optimization of ﬂows.
108
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Design space exploration is directly considered in the
language design and implementation.
Finally, a case
study demonstrates a realistic ESL design of the hetero-
geneous multicluster architecture. The ﬁve ﬂows are ar-
ranged in a sequence of ﬂows. Each ﬂow outputs ex-
perimental results representing suitable solutions for the
individual design problems.
In the rest of this paper, a discussion outlines the fu-
ture work. An open topic relates to the further develop-
ment of DFL towards additional language features, such
as name spacing, proﬁling, etc., allowing for more com-
plex applications. In addition, the language should pro-
vide advanced access and functions to analyze the de-
sign data. It would be beneﬁcial to support more DSE
techniques, such as simulated annealing, hill climbing,
etc. In addition, the ﬂow-based search is an open topic.
The implementation of DFL comprises a full set of lan-
guage features opposed to the visual language, which re-
quires several adjustments, such a support of sub-ﬂows
in a ﬂow. In future, the design ﬂow development should
be extended towards a high-level synthesis for embedded
systems.
VIII
APPENDIX: DFL FLOW EXAMPLE
The appendix illustrates the DFL source code for the
Parameter Tuning ﬂow through Listing 4.
REFERENCES
[1] F. Guderian and G. Fettweis, “Integration of design space
exploration into system-level speciﬁcation exempliﬁed in
the domain of embedded system design,” in Proceed-
ings of International Conference on Advances in Circuits,
Electronics and Micro-electronics (CENICS), Aug. 2012.
[2] D. D. Gajski, S. Abdi, A. Gerstlauer, and G. Schirner,
Embedded System Design: Modeling, Synthesis and Ver-
iﬁcation.
Springer, 2009.
[3] R. Ernst, “Automatisierter entwurf eingebetteter sys-
teme,” at - Automatisierungstechnik, pp. 285–294, jul
1999.
[4] B. Bailey, G. Martin, and A. Piziali, ESL design and
veriﬁcation: a prescription for electronic system-level
methodology, 1st ed., W. Wolf, Ed.
Morgan Kaufmann,
2007.
[5] D. D. Gajski, F. Vahid, S. Narayan, and J. Gong, Speciﬁ-
cation and design of embedded systems.
Prentice-Hall,
Inc., 1994.
[6] W. Fornaciari, G. Palermo, V. Zaccaria, F. Castro,
M. Martinez, S. Bocchio, R. Zafalon, P. Avasare, G. Van-
meerbeeck, C. Ykman-Couvreur, M. Wouters, C. Kavka,
L. Onesti, A. Turco, U. Bondi, G. Marianik, H. Posadas,
E. Villar, C. Wu, F. Dongrui, Z. Hao, and T. Shibin,
“Multicube: Multi-objective design space exploration of
multi-core architectures,” in Proceedings of IEEE Com-
puter Society Annual Symposium on VLSI (ISVLSI), July
2010, pp. 488 –493.
[7] Z. J. Jia, A. Pimentel, M. Thompson, T. Bautista, and
A. Nunez, “Nasa: A generic infrastructure for system-
level mp-soc design space exploration,” in Proceedings
of Embedded Systems for Real-Time Multimedia (ESTI-
Media), Oct 2010, pp. 41 –50.
[8] F. Guderian and G. Fettweis, “The lambda chart: A model
of design abstraction and exploration at system-level,” in
Proceedings of International Conference on Advances in
System Simulation (SIMUL), 2011, pp. 7–12.
[9] R. A. Fisher, The Design of Experiments.
Oliver and
Boyd Ltd., Edinburgh, 1935.
[10] G. L. Glegg, The Design of Design, 1st ed.
Cambridge
University Press, 1969.
[11] F. Brooks, The Design of Design: Essays from a Com-
puter Scientist.
Addison-Wesley, 2010.
[12] K. I. Farkas, P. Chow, N. P. Jouppi, and Z. Vranesic, “The
multicluster architecture: reducing cycle time through
partitioning,” in IEEE/ACM International Symposium on
Microarchitecture (Micro), 1997, pp. 149–159.
[13] ITU-T, Recommendation Z.100 (08/02) Speciﬁcation and
Description Language (SDL), International Telecommu-
nication Union (2002).
[14] S. Traboulsi, F. Bruns, A. Showk, D. Szczesny, S. Hes-
sel, E. Gonzalez, and A. Bilgic, “Sdl/virtual prototype
co-design for rapid architectural exploration of a mobile
phone platform,” in Proceedings of international SDL
conference on design for motes and mobiles, 2009, pp.
239–255.
[15] A. S. Initiative. (26 May 2013) Systemc, osci. [Online].
Available: http://www.systemc.org/
[16] D. D. Gajski, R. Zhu, J. Dömer, A. Gerstlauer, and
S. Zhao, SpecC Speciﬁcation Language and Methodol-
ogy.
Kluwer Academic Publishers, 2000.
[17] C. Haubelt, T. Schlichter, J. Keinert, and M. Meredith,
“Systemcodesigner: automatic design space exploration
and rapid prototyping from behavioral models,” in Pro-
ceedings of the 45th annual Design Automation Confer-
ence, ser. Proceedings of Design Automation Conference
(DAC), 2008, pp. 580–585.
[18] R. Dömer, A. Gerstlauer, J. Peng, D. Shin, L. Cai, H. Yu,
S. Abdi, and D. D. Gajski, “System-on-chip environ-
ment: a specc-based framework for heterogeneous mpsoc
design,” EURASIP Journal on Embedded Systems, vol.
2008, pp. 5:1–5:13, Jan. 2008.
[19] J. Eker, J. Janneck, E. Lee, J. Liu, X. Liu, J. Ludvig,
S. Neuendorﬀer, S. Sachs, and Y. Xiong, “Taming het-
erogeneity - the ptolemy approach,” Proceedings of the
IEEE, vol. 91, no. 1, pp. 127–144, jan 2003.
109
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[20] L. Bonde, C. Dumoulin, and J.-L. Dekeyser, “Metamod-
els and mda transformations for embedded systems.” in
FDL, 2004, pp. 240–252.
[21] D. Mathaikutty, H. Patel, S. Shukla, and A. Jantsch,
“Ewd: A metamodeling driven customizable multi-moc
system modeling framework,” ACM Transactions on
Design Automation of Electronic Systems (TODAES),
vol. 12, no. 3, pp. 33:1–33:43, May 2008.
[22] D. Mathaikutty and S. Shukla, “Mcf: A metamodeling-
based component composition framework–composing
systemc ips for executable system models,” IEEE Trans-
actions on VLSI Systems, vol. 16, no. 7, pp. 792 –805,
july 2008.
[23] “Synopsys Inc.” 26 May 2013. [Online]. Available:
http://www.synopsys.com
[24] “Cadence Design Systems Inc.” 26 May 2013. [Online].
Available: http://www.cadence.com/
[25] “Mentor
Graphics
Inc.”
26
May
2013.
[Online].
Available: http://www.mentor.com/
[26] B. Welch, Practical Programming in Tcl and Tk, 4th ed.
Prentice Hall, 2003.
[27] T. Barnes, “Skill: a cad system extension language,” in
Design Automation Conference, 1990. Proceedings., 27th
ACM/IEEE, jun 1990, pp. 266 –271.
[28] Q. Nguyen, CAD Scripting Languages: A collection of
Perl, Ruby,Python,TCL & SKILL scripts.
Ramacad Inc.
[29] A.
Sangiovanni-Vincentelli,
G.
Yang,
S.
Shukla,
D. Mathaikutty, and J. Sztipanovits, “Metamodeling: An
emerging representation paradigm for system-level de-
sign,” Design Test of Computers, IEEE, vol. 26, no. 3,
pp. 54 –69, may-june 2009.
[30] “Deﬁnition of model,” 26 May 2013. [Online]. Available:
http://en.wikipedia.org/wiki/Model
[31] M. Stephenson, S. Amarasinghe, M. Martin, and U.-
M. O’Reilly, “Meta optimization: improving compiler
heuristics with machine learning,” in Proceedings of the
ACM SIGPLAN, ser. PLDI ’03.
ACM, 2003, pp. 77–90.
[32] National Instruments, “Labview,” 26 May 2013. [Online].
Available: www.ni.com/labview
[33] Mathworks, “Matlab and simulink,” 26 May 2013.
[Online]. Available: http://www.mathworks.com/
[34] G. Berry, “The constructive semantics of pure es-
terel.” 26 May 2013. [Online]. Available: http://www-
sop.inria.fr/esterel.org/
[35] P. Caspi, D. Pilaud, N. Halbwachs, and J. A. Plaice, “Lus-
tre: a declarative language for real-time programming,”
in Proceedings of the 14th ACM SIGACT-SIGPLAN sym-
posium on Principles of programming languages, 1987,
pp. 178–188.
[36] IBM,
“Ibm
rational
rhapsody,”
26
May
2013.
[Online].
Available:
http://www.ibm.com/software/awdtools/rhapsody/
[37] D. D. Gajski, J. Peng, A. Gerstlauer, H. Yu, and D. Shin,
“System design methodology and tools,” CECS, UC
Irvine, Technical Report CECS-TR-03-02, January 2003.
[38] S. Borkar, “Thousand core chips: a technology perspec-
tive,” pp. 746–749, 2007.
[39] F. Guderian, Developing a Design Flow for Embedded
Systems.
Jörg Vogt Verlag, 2013.
[40] T. Kogel, A. Haverinen, and J. Altis, “Ocp tlm for archi-
tectural modelling,” OCP-IP white-paper, 2005.
[41] M. Gries, “Methods for evaluating and covering the de-
sign space during early design development,” Journal In-
tegration, the VLSI Journal, vol. 38, no. 2, pp. 131–183,
Dec. 2004.
[42] P. Guerrier and A. Greiner, “A generic architecture for on-
chip packet-switched interconnections,” in Proceedings
of Design, Automation, and Test in Europe (DATE), 2000,
pp. 250–256.
[43] A. Hemani, A. Jantsch, S. Kumar, A. Postula, J. Öberg,
M. Millberg, and D. Lindquist, “Network on a chip: An
architecture for billion transistor era,” in Proceedings of
NorChip, 2000.
[44] G. Sander, “Vcg visualization of compiler graphs,”
26 May 2013. [Online]. Available:
http://rw4.cs.uni-
sb.de/ sander/html/gsvcg1.html
[45] V. Paxson, “Fast lexical analyzer generator, lawrence
berkeley laboratory,” 26 May 2013. [Online]. Available:
http://prdownloads.sourceforge.net/ﬂex/ﬂex-2.5.35.tar.gz
[46] “Bison - gnu parser generator,” 26 May 2013. [Online].
Available: http://www.gnu.org/software/bison/
[47] F. Guderian, R. Schaﬀer, and G. Fettweis,
“Administration- and communication-aware ip core
mapping in scalable multiprocessor system-on-chips
via evolutionary computing,” in Proceedings of IEEE
Congress on Evolutionary Computation (CEC), june
2012, pp. 1–8.
[48] F. Guderian, R. Schaﬀer, and G. Fettweis, “Dimension-
ing the heterogeneous multicluster architecture via par-
allelism analysis and evolutionary computing,” in Pro-
ceedings of IEEE Congress on Evolutionary Computation
(CEC), june 2012, pp. 1–8.
[49] F. Guderian, E. Fischer, M. Winter, and G. Fettweis, “Fair
rate packet arbitration in network-on-chip,” in Proceed-
ings of SOC Conference (SOCC), sept. 2011, pp. 278 –
283.
[50] R.
Dick,
“Embedded
system
synthesis
bench-
marks
suite,”
26
May
2013.
[Online].
Available:
http://ziyang.eecs.umich.edu/∼dickrp/e3s/
[51] EEMBC, “The embedded microprocessor benchmark
consortium,”
26
May
2013.
[Online].
Available:
http://www.eembc.org/
110
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

/∗∗∗∗ INCLUDE PREDEFINED FLOWS AND STEPS ∗∗∗∗/
2 # i n c l u d e
" p arameter_tuning . d f l "
# i n c l u d e
" m u l t i c l u s t e r _ l o a d _ b a l a n c i n g . d f l "
4 /∗∗∗∗ SEQUENCE IDENTIFIER DEFINITION ∗∗∗∗/
i n t S_TUN = 1;
i n t S_BAL = 2;
6 /∗∗∗∗ DFFINE THE SEQUENCE OF FLOWS ∗∗∗∗/
vector <int > flow_order ;
8 flow_order . push_back (S_TUN) ;
flow_order . push_back (S_BAL) ;
10 /∗∗∗∗ RUN CONFIGURED FLOWS ∗∗∗∗/
f o r
( i n t
i =0;
i <flow_order . s i z e ( ) ; ++i ) {
12
s t r i n g
d e s c r i p t i o n ;
Flow eslDesignFlow ;
14
/∗∗∗∗ DEFINITION OF FLOW SPECIFIC PARAMETERS
∗∗∗∗/
vector <s t r i n g > arch_in ,
config ;
16
/∗∗∗∗ SELECT FLOW CONFIGURATION ∗∗∗∗/
switch
( flow_order . a t ( i ) ) {
18
case S_TUN:
{
20
d e s c r i p t i o n = " Parameter
Tuning " ;
a r c h _ i n . push_back ( " lambda_tun / archs / ∗ .
xml " ) ;
22
eslDesignFlow = tun ;
break ;
24
}
case S_BAL :
26
{
d e s c r i p t i o n = " M u l t i c l u s t e r
Load
Balancing " ;
28
a r c h _ i n = getFilenames ( " lambda_bal / archs
/ ∗ . xml " ) ;
co nfig = getFilenames ( " lambda_bal /
c o n f i g s / ∗ . xml " ) ;
30
eslDesignFlow = bal ;
break ;
32
}
d e f a u l t :
34
{
p r i n t l n ( " Unknown Flow Choice :
" +
flow_order . a t ( i ) ) ;
36
c o n t i n u e ;
}
38
}
/∗∗∗∗ EXECUTE SELECTED FLOW ∗∗∗∗/
40
p r i n t l n ( d e s c r i p t i o n + "
i s
running
. . . " ) ;
execute ( eslDesignFlow ) ;
42 }
Listing 3. DFL source code for the ﬂow sequence in the
case study prototype.
/∗∗∗∗∗∗ ALLOCATION STEP ∗∗∗∗∗/
2 Step
a l l o c = Step ( " A l l o c a t i o n " ) ;
vector <s t r i n g > views ;
4 views . push_back ( " Computation
Resources " ) ;
views . push_back ( " Data
L o g i s t i c
Resources " ) ;
6 views . push_back ( " Resource Management " ) ;
a l l o c . add ( " View " ,
views ) ;
8
a l l o c . add ( " Execution " ,
" A l l o c a t i o n " ) ;
a l l o c . add (" − t o o l " ,
" IPCoreMapping " ) ;
10
a l l o c . add ( " IPCoreMapping " ,
" t r u e " ) ;
s t r i n g
alloc_config_param = "− app_in
lambda_tun \ \ apps_state_mod . xml −co nfig
lambda_tun \ \ dfConfigNoC . xml
−
arch_inlambda_tun \ \ arch_gen . xml −
a r c h _ d i r _ o u t
lambda_tun \ \ archs −
mappings_in
lambda_tun \ \ mappings_ideal . xml
" ;
12
s t r i n g
a l l o c _ s t a t i c _ p a r a m = " −AffinityWeight
0.5 − s t a r _ s i z e
2 −rows 3 −columns 3 −r 1 −
s
50";
a l l o c . add ( " Argument " ,
alloc_config_param +
a l l o c _ s t a t i c _ p a r a m ) ;
14 /∗∗∗∗∗ INPUT PARAMETER SPACE ∗∗∗∗∗/
vector <int > ngen = [1000:10000:1000];
16 vector <int > popsize = [ 5 0 : 2 0 0 : 5 0 ] ;
vector <int > pmut = [ 0 . 0 1 : 0 . 1 : 0 . 0 1 ] ;
18 vector <int > pc ross = [ 0 . 2 : 0 . 4 : 0 . 2 ] ;
vector <s t r i n g > space ;
20 space . push_back ( " ngen " ) ;
space . push_back ( " popsize " ) ;
22 space . push_back ( " pmut " ) ;
space . push_back ( " pcro ss " ) ;
24
a l l o c . add ( " Space " ,
" space " ) ;
a l l o c . add ( " S t r a t e g y " ,
"ES " ) ;
26 /∗∗∗∗∗ PARALLEL EXECUTION ∗∗∗∗∗/
s t r i n g
p a r a l l e l = " t r u e " ;
28
a l l o c . add ( " HPCJob " ,
p a r a l l e l ) ;
a l l o c . add ( " workDirectory " ,
" \ \ \ \ s e r v e r \ \ hpc " ) ;
30
a l l o c . add ( " MaxCores " ,
15) ;
a l l o c . add ( " s c h e d u l e r " ,
" entmhpc3 " ) ;
32 /∗∗∗∗∗ VALIDATION STEP ∗∗∗∗∗/
Step
val = Step ( " Computation_Validation " ) ;
34 val . add ( " View " ,
" Computation
Resources " ) ;
val . add ( " Execution " ,
" V a l i d a t i o n " ) ;
36 val . add (" − t o o l " ,
" E v a l u a t i o n " ) ;
val . add ( " O b j e c t i v e " ,
" min " ) ;
38 val . add ( " Metric " ,
" GAFitnessScore " ) ;
s t r i n g
val_config_param = "− mappings_dir_in
lambda_tun \ \ maps −e v a l _ o u t
lambda_tun \ \
eval_mappings . xml " ;
40 val . add ( " Argument " ,
val_config_param ) ;
/∗∗∗∗∗ FLOW CONSTRUCTION ∗∗∗∗∗/
42 Flow tun = Flow ( " Parameter
Tuning " ) ;
tun . add ( a l l o c ) ;
44 tun . add ( val ) ;
connect ( a l l o c ,
val ) ;
46 /∗∗∗∗∗ FLOW VISUALIZATION ∗∗∗∗∗/
tun . save ( " vcg " ,
" p a r a me t e r_ t u ni n g . vcg " ) ;
Listing 4. DFL source code for the Parameter Tuning
ﬂow.
111
International Journal on Advances in Systems and Measurements, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

