Genetic Algorithm for Time-Effective IoT Service Function Placement
Arvind Kalyan
Westview High School
San Diego CA 92129
email: arvindkrishnakalyan@gmail.com
Abstract—This paper focuses on the concept of IoT Service
Function Chains (IoTSFC): a set of Internet of Things (IoT)
Network Functions that must be allocated and implemented
on IoT nodes in a speciﬁc order. Our problem is of Integer
Linear Programming (ILP) type and therefore NP-Hard, so an
optimal solution cannot be found in polynomial time. Therefore,
we attempt to devise a heuristic method to solve the problem
at a lower time complexity. The paper develops a solution
using a genetic algorithm that attempts to minimize the total
processing time and incurred transmission delay time required
to execute a group of network functions across IoT nodes. The
genetic algorithm is run on a string denoting placement of the
network functions and runs a set of genetic operators in order to
work toward an optimal solution. Our experimental results are
encouraging, however, remain in progress.
Keywords – Internet of Things; IoT Service Function Chaining;
Minimax Problem; Genetic Algorithm; Natural Selection; Fitness.
I. INTRODUCTION
With the rise of network technologies in the last decade, the
progress of the Internet of Things (IoT) has ramped up. Using
various devices, such as sensors, remote monitors, etc., IoT
networks can collect and process data on a massive scale. Ser-
vices offered by an IoT device consist of various IoTSFC, and
each IoTSFC itself contains a set of Network Functions (NFs).
As opposed to less stringent network structures, IoTSFC func-
tions must be implemented and executed in a speciﬁc order in
order to carry out the appropriate service. With a rising amount
of data, the efﬁciency of deployment becomes paramount.
Traditional solutions involve function implementation on both
hardware in the IoT gateway and in the cloud. However, this
has proved unsuitable due to exorbitant costs and inﬂexibility.
The introduction of Network Function Virtualization (NFV)
has helped alleviate these concerns. Instead of implementation
in the gateway, NFV allows for various NFs to be rendered
through software on IoT nodes. This allows for programma-
bility, as well as the required ﬂexibility of network function
assignment. Performance time can be improved by altering the
site of implementation of a certain IoTSFC. However, high
complexity and volume of these network functions can bring
about challenges. The assignment of functions in IoTSFCs to
viable IoT nodes is crucial to keep up with the increasing
demands of today’s age.
Section II delves into our contributions with this paper as
compared to existing solutions. Section III establishes the
mathematical model of the IoT problem. We specify the
constraints and objective function that we look to minimize.
Section IV introduces the proposed genetic algorithm we
have devised, and it is further illustrated with a pseudo-code
model. Section V depicts experimental setup and testing of
our proposed algorithm, featuring a Gantt chart to illustrate
these results. Finally, Section VI contains the conclusion and
ﬁnal remarks.
II. OUR CONTRIBUTIONS
Our problem presents an approach to minimizing the com-
bination of processing time and incurred transmission delays
through the placement of IoT network functions across a set
of IoT nodes. We utilize a genetic algorithm to discover a
minimum solution, returning a full placement scheme for a
set of network functions.
Ren et al. [1] delved into a new scheme for the placement of
IoT service functions, attempting to deploy these functions on
nodes that are as close to their data source as possible. Doing
so allows them to minimize total resource costs and maximize
system performance. Qu et al. [2] introduced the concept of
delays in their paper regarding NFV. The authors explored
two different types of delay, one of them being a transmission
delay incurred by a switch in virtual machines. They looked
to ﬁnd a scheme to minimize the maximum time as well,
treating the service function chain problem as a ”ﬂexible job-
shop scheduling problem”. The authors also utilized a genetic
algorithm to discover a minimum solution. Gao et al. [3]
developed a genetic algorithm to solve the job-shop problem,
using various genetic operators to add diversity. Moghadam
et al. [4] brought up the concept and execution of a POX
crossover to be used in the offspring generation in a genetic
algorithm.Kouah et al. [5] have developed an energy-aware
optimization model to solve the placement of IoTSFC problem
and proposed a genetic algorithm heuristic solution and an
energy-agnostic algorithm, with the goal to avoid exhausting
nodes with limited energy capacities and providing an optimal
solution for energy consumption for a small network topology.
Wang [6] has considered an IoTSFC placement problem from
the perspective of minimizing the number of VNF instances
implemented and proposed a genetic algorithm based solution.
Our paper is unique in its inclusion of transmission delays
in an IoTSFC placement scheme problem, utilizing a modiﬁed
genetic algorithm in order to work toward a solution that min-
imizes the maximum time of implementation. While Ren et al.
[1] attempt to minimize the distance from functions to a data
source, we instead attempt to minimize the overall processing
time and incurred transmission delay between network nodes.
Wang [6] has considered an overall processing delay not to
exceed a certain acceptable delay threshold, however has not
accounted for transmission delay. Our problem formulation
23
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-753-5
ICSNC 2019 : The Fourteenth International Conference on Systems and Networks Communications

models closer to a real life IoT network as we take into account
the varied transmission delays between network nodes. To our
best knowledge, we are not aware of other research that has
taken this into account, and this is a novel approach for solving
IoTSFC placement problem. Our solution appears promising,
but has not been fully tested. This remains the next step in the
authors’ research.
III. MATHEMATICAL FORMULATION OF THE PROBLEM
This section presents a mathematical representation of the
problem, including constraints and the objective function that
will be solved using a genetic algorithm.
A. Model
We represent a graph of IoT nodes G = (V, E), where V is
the set of nodes on the graph and E is the set of traversable
edges connecting these nodes. We create a set of service
requests {s1, s2, s3, ..., sN}, where each of these service re-
quests consist of network functions {fi1, fi2, ..., fiki}. Each
node that implements these requests is denoted by k ∈ V .
These network functions must be implemented in the exact
order as speciﬁed in the IoTSFC.
We deﬁne i ∈ {1, 2, ..., N} as an index of service requests.
j ∈ {1, 2, ..., ki} is an index for each service request that
denotes the network function in the necessary order. For a
service request i, the processing time required to implement
network function j on node k is deﬁned as ti,j,k. The time
that this implementation begins is represented by si,j, and
the time it ends is denoted by ei,j. In addition, we include
a transmission delay when a request implements network
function j on node k and implements function j+1 on another
node k′, denoted by di,j,k,k′.
We denote xi,j,k to be a binary variable representing
whether or not a network function j contained in service
request i is implemented on node k. We denote yi,j,k,k′ as
another binary variable for service i, network function j is
implemented on a node k while function j +1 is implemented
on separate node k′ (i.e., the node is switched from k to k′).
B. Objective
We treat this problem as a “minimax” problem, attempting
to minimize the combination of processing time and incurred
transmission delays through the placement of IoT network
functions across a set of IoT nodes. We must take into account
both the time of implementation of each network function, as
well as transmission delays incurred by switching nodes.
min C
where C = max P
i
P
j(ti,j,k · xi,j,k + di,j,k,k′ · yi,j,k,k′)
C. Constraints
First, we must deﬁne binary variable xi,j,k to represent
whether a network function j contained in service request i is
implemented on node k.
xi,j,k =
 1 if implemented
0 else
(1)
Similarly, yi,j,k,k′ as another binary variable that represents
whether a service i, network function j is implemented on a
node k while function j + 1 is implemented on separate node
k′ (i.e., the node is switched from k to k′).
yi,j,k,k′ =

1 if (k, k’) is traversed
0 else
(2)
To prevent a network function j of service request i from
being implemented on an underresourced node, we create a
constraint governing the start time si,j across all nodes k ∈
V . In addition, the function must be implemented after the
previous function has ended, ensuring that the necessary order
of functions is preserved.
si,j +
X
k
ti,j,k · xi,j,k ≤ ei,j, ∀i, j
(3)
Furthermore, when switching nodes within a request, we
must ensure that the next function is implemented following
the incurred transmission delay, preserving the order of im-
plementation.
ei,j +
X
k
di,j,k,k′ · yi,j,k,k′ ≤ si,j+1, ∀i, j
(4)
When switching a service i from function j to j+1 through
node k to k′, we assure the j + 1 is implemented on k′.
X
k
yi,j−1,k,k′ = xi,j,k′, ∀i, j
(5)
Additionally, we create a constraint that makes sure we can
only switch to one other node at each function in a request.
′
X
k
yi,j,k,k′ ≤ 1, ∀i, j, k
(6)
The ﬁnal constraint governs the implementation of each
service function i for a request j, allowing each to be im-
plemented only once on a node.
X
k
xi,j,k = 1, ∀i, j
(7)
Our problem is ILP and therefore NP-Hard, so an optimal
solution cannot be found in polynomial time [6]. Therefore,
we attempt to devise a heuristic method to solve the problem
at a lower time complexity.
24
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-753-5
ICSNC 2019 : The Fourteenth International Conference on Systems and Networks Communications

IV. GENETIC ALGORITHM FOR IOT FUNCTION
PLACEMENT
This section proposes a genetic algorithm that will allow
the scheduling of a set of network functions onto IoT nodes,
using pseudo-code to visualize this solution.
A. Proposed Solution Setup
We attempt to minimize the combined processing time and
incurred delay times of IoT service function chains assigned
across IoT nodes. In order to do so, we designate two strings
[3] representing the function placement to be utilized by the
algorithm. The ﬁrst is the Operation Selection (OS) string,
listing a set of functions given in the order they are meant
to be implemented in. A service request i with j network
functions, for example, is listed j times in the total string in
various positions. The ﬁrst network function will be listed as
the ﬁrst appearance, the second network function the second,
and so on. The nth listing of a service request is the nth
network function it contains, for example. This string cannot
be edited, and is given as an input into the algorithm.
The second string, known as the Machine Selection (MS)
string, outlines the nodes that each of the functions will be
placed on. It has the same length as the OS string, however, it
is split up into its i components, one for each service request.
The jth element of the ith component represents the node on
which jth function of service function i is to be implemented,
as deﬁned by the OS string. Each smaller component, denoting
a service request, represents a chromosome. Each element,
containing the node of implementation, is a gene. A solution
is represented by placements dictated by an MS string.
To decode the MS string and return a set of xi,j,k and
yi,j,k,k′ values, we iterate through the string. If the value of the
jth network function in the ith service request chromosome
is equal to some value k, we set xi,j,k = 1. For all network
functions in a gene, if the value is a different value k′ from
the previous, indicating a different node used to implement,
we set yi,j,k,k′ = 1.
For example, we consider a set of 3 jobs containing 2
functions each. These f ∈ f1,1, f1, 2, ..., f3,1, f3,2 may be
implemented on one of 3 virtual nodes.
We randomly designate an OS String, in this case, to
131223, denoting the order of function placement. The initial
value is the ﬁrst repetition of 1, so we implement f1,1 ﬁrst.
The second function to implement is f3,1, third is f1,2, and
so on. Similarly, we create a MS String of 213122. f1,1 is
implemented on Node 2, f1,2 on Node 1, f2,1 on Node 3, and
so forth.
B. Proposed Genetic Algorithm
We begin by setting an arbitrary population size to store
the MS strings. We deﬁne a simple ﬁtness function as the
maximum time taken to implement all the functions on the
nodes denoted by the string. We generate two MS strings ran-
domly, and unpartitioned to begin. To generate a population,
it must satisfy each of the constraints listed previously. We
select a node at random for each network function of each
service request. Going in the order dictated by the OS string,
we create a suitable starting time for each function after the
previous function has been implemented, using the idle times
available on each node. If there is enough time in an idle
slot, we may add the next function in it. If not, it will be
implemented at the end. These strings are stored in a sorted
queue of length equal to the previously selected population
size.
Inside the loop, we begin by evaluating the ﬁtness of
our population. This ﬁtness test is done by calculating the
time required for implementation, and a lower time entails
a higher ﬁtness score. We also deﬁne termination criteria;
in this paper, the algorithm terminates when we reach the
maximum generation or the maximum step with no signiﬁcant
improvement. If the termination criteria are satisﬁed, we exit
and return the MS string that provides the optimal time at the
beginning of the queue. If not satisﬁed, we select the two MS
strings that provide the lowest maximum time to implement
all functions in the OS string. These strings are crossed over
to create two new offspring. We utilize a POX crossover [4]
that will allow us to remain within the given constraints. First,
the service requests contained in the string are partitioned at
random into two groups. An element in the ﬁrst parent string
that is sectioned into the ﬁrst group is placed in the same
position in the ﬁrst offspring, then removed from the ﬁrst
parent string. Meanwhile, elements in the second parent string
that are in the second group occupy the same position in the
second offspring and are removed from the parent. Elements
that remain in the ﬁrst parent string are placed in that order in
the remaining spots of the second offspring, and vice versa.
We also introduce simple swapping mutations to the off-
spring after crossover. Two elements chosen at random in the
offspring strings may be swapped, adding another layer of
randomness to the selection process. After the offspring are
completed, we evaluate their ﬁtness as well. If any offspring
are deemed to be more ﬁt than any elements in the population,
we add these offspring to the population and remove the least
ﬁt members of the population in order to maintain the constant
population size. After the loop is completed, the algorithm will
return the updated values of xi,j,k and yi,j,k,k′ for all i, j, k.
V. EXPERIMENTAL RESULTS
We have begun to test our algorithm using the network
graph depicted in Fig. 1. The topology features six IoT nodes,
with links connecting each node to its adjacent neighbors. We
also removed the link from Node 1 to 3, so a service request
may not switch between the two. Along each connected node
pair, we labeled the transmission delay that would be incurred
by switching across the two nodes. As suggested earlier, this
closely models a real IoT network as we take into account the
varied transmission delays between network nodes.
For this topology, as shown in Fig. 2, we created a set of four
requests with a random amount of network functions contained
in each. For example, Service Request 1 contains both f11
and f12, while Service Request 3 contains three functions
f31, f32, and f33. We then deﬁned a random implementation
25
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-753-5
ICSNC 2019 : The Fourteenth International Conference on Systems and Networks Communications

Algorithm 1 Genetic Algorithm for IoTSFC Placement
Input: G(V, E); ti,j,k; di,j+1,k,k′; OS string
Output: xi,j,k, yi,j,k,k′
population = empty sorted queue of length popsize
MS1, MS2 = randomly generated MS strings
population = population ∪ MS1, MS2
while TRUE do
evaluate ﬁtness of all elements in population
if termination criteria are met then
optimalString = MS string with highest ﬁtness score in
population
for all element in optimalString do
update xi,j,k, yi,j,k,k′ using element
end for
end if
P1, P2 = two MS strings from population with the highest
ﬁtness, implementing network functions in lowest times
O1, O2 = POX crossover on P1, P2
randomly mutate O1, O2
if ﬁtness of O1 ≥ lowest ﬁtness in population then
add O1 to population
remove least ﬁt element of population
end if
if ﬁtness of O2 ≥ lowest ﬁtness in population then
add O2 to population
remove least ﬁt element of population
end if
end while
return xi,j,k, yi,j,k,k′∀i, j, k
Fig. 1. 6 IoT-node topology
time for each network function on the six nodes given by
the topology. Some of the functions cannot be implemented
on all nodes; for example, f31 can only be implemented on
Nodes 3 and 6. During simulations, we set the processing time
for any unimplementable function on a certain node to be a
very large integer, preventing the cost-reducing algorithm from
implementing there.
Fig. 2. Set of 4 service requests with NF implementation times in each node
A. Simulation Results and Discussion
As shown in Fig. 3, our test was able to execute each
network function contained in each service request in a total
time of 7 units. The ﬁnal and optimal string requires ﬁve
node switches, incurring delays each time. Node 1 implements
the most service functions, with three, while Nodes 3, 4, 5,
and 6 are only tasked with implementing 1 function each.
The algorithm took 15.55 seconds to run, creating additional
generations until this solution was reached.
While these initial results are promising, our testing remains
a work in progress. The authors look to test the algorithm on
a variety of different topologies, as well as different functions
which take a random time to implement on each of the nodes.
VI. CONCLUSIONS
We attempted to minimize the combination of processing
time and incurred transmission delay of the placement of IoT
network functions across a set of nodes. Since this problem
falls under the classiﬁcation of ILP problems, it is NP-Hard
and therefore cannot be solved in a polynomial time. We
utilized a genetic algorithm to discover a solution to the
problem at a lower complexity. The algorithm takes into
account both execution time and transmission delays incurred
by a request switching nodes. Our testing is a work in progress,
however, the initial results have been promising. We hope
to reach an acceptable optimal solution in a time-efﬁcient
manner.
REFERENCES
[1] W. Ren, Y. Sun, H. Luo, and M. Obaidat,
A New Scheme for IoT
Service Function Chains Orchestration in SDN-IoT Network Systems,
IEEE Systems Journal, pp. 1-12, July 2019.
[2] L. Qu, C. Assi, and K. Shaban, Delay Aware Scheduling and Resource
Optimization with Network Function Virtualization, IEEE Transactions
on Communications, pp. 3746-3758, Sept. 2018.
[3] L. Gao and X. Li, An Effective Hybrid Genetic Algorithm and Tabu
Search for Flexible Job Shop Scheduling Problem, International Journal
Production Economics, pp. 93-110, Dec. 2015.
[4] A.M. Moghadam, K. Wong, and H. Piroozfard,
An Efﬁcient Genetic
Algorithm For Flexible Job-shop Scheduling Problem,
2014 IEEE
International Conference on Industrial Engineering and Engineering
Management, pp. 1409-1413, Dec. 2014.
[5] Xin-Gang Wang, An Effective Solution Based on Genetic Algorithm for
Virtual Network Functions Placement, ICEIT, pp. 21-31, 2017.
[6] R. Kouah, A. Alleg, A. Laraba, and T. Ahmed, Energy-aware placement
for IoT-Service Function Chain, IEEE 23rd International Workshop on
Computer Aided Modeling and Design of Communication Links and
Networks, pp. 1-7, 2018.
[7] S. Skiena, The Algorithm Design Manual, Springer-Verlag, 1998.
26
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-753-5
ICSNC 2019 : The Fourteenth International Conference on Systems and Networks Communications

Fig. 3. GA Algorithm solution for IoTSFC Placement for 4 service requests
on 6 IoT-node topology
27
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-753-5
ICSNC 2019 : The Fourteenth International Conference on Systems and Networks Communications

