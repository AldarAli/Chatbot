Extended Fault Based Attack against Discrete Logarithm Based
Public Key Cryptosystems
Sung-Ming Yen
Dept of Computer Science and Information Engineering
National Central University
Chung-Li, Taiwan 320, R.O.C.
Email: yensm@csie.ncu.edu.tw
Chi-Dian Wu
Dept of Computer Science and Information Engineering
National Central University
Chung-Li, Taiwan 320, R.O.C.
Email: cs122016@csie.ncu.edu.tw
Abstract—Since Bellcore’s researchers proposed fault based
attacks, these attacks have become serious threats to the imple-
mentation of cryptosystems. Boneh et al. ﬁrst proposed a fault
based attack against the exponentiation algorithm for RSA,
and some variants of attack were proposed later. However, the
previous variants of similar attack are applicable only to the
right-to-left exponentiation algorithm and none of these attacks
can be successfully applied to the left-to-right alternative
algorithm since 1997. In this paper, we focus on cryptosystems
operated under prime-order groups and emphasize that an
extended fault based attack against implementations using the
left-to-right exponentiation algorithm is possible. Our attack
can also be applied to the Montgomery ladder algorithm which
is a well-known countermeasure against some critical physical
attacks.
Keywords-exponentiation algorithm; hardware fault attack;
physical attack; public key cryptosystem.
I. INTRODUCTION
In the past, cryptographers only analyzed the security of
cryptosystems by mathematics. However, when cryptosys-
tems are implemented on physical devices, it brings new
threats which had never been considered carefully. These
new threats are called the physical attacks, such as the side-
channel attack [14] and the fault based attacks [1], [4], [8].
Physical attacks utilize the power consumption and program
execution time, or disturb the program execution to infer the
secret information stored inside the devices, even though
these cryptosystems have been proved secure with mathe-
matical approach. So, when implementing cryptosystems, it
is usually essential to prevent such kinds of attack.
Both exponentiation and scalar multiplication are the most
central computations for many public key cryptosystems. To
evaluate exponentiation or scalar multiplication, the left-to-
right and the right-to-left algorithms are the two most widely
employed methods. Fault based attack was ﬁrst introduced
in 1997, and afterwards many kinds of fault based attack
have been proposed to break a variety of cryptosystems.
For example, Boneh et al. [8] proposed a fault based attack
against the right-to-left exponentiation algorithm for RSA
by injecting random faults during the computation to reveal
the private exponent. Biehl et al. presented a similar attack
on elliptic curve cryptosystems (ECC) in 2000 and showed
that the secret scalar of a scalar multiplication can be
revealed by providing illegal input parameters [4]. Berzati
et al. modiﬁed Boneh et al.’s attack in 2008 [2]. Biham
and Shamir proposed a differential fault attack (DFA) [5]
against symmetric key cryptosystems, e.g., DES. All these
researches show that fault based attacks are powerful and
dangerous to cryptosystem implementations, especially for
those on smart cards.
The aforementioned fault based attacks against public
key cryptosystems target at the right-to-left exponentiation
algorithm (or the right-to-left scalar multiplication for ECC),
while in this paper we extend this kind of fault based attack
to the left-to-right exponentiation algorithm. The proposed
attack assumes the knowledge of the order of a group and
the order must be a prime. For performance reasons or
security reasons, many important public key cryptosystems,
such as Schnorr scheme [19] and ECC [13] (e.g., elliptic
curve Difﬁe-Hellman key exchange [17]), the group order
is a prime integer and it is a public information. So, this
attack assumption is reasonable and the proposed attack
can be applied to these widely employed cryptosystems.
Moreover, the proposed attack can also be extended easily
to the Montgomery ladder algorithm.
This paper is organized as follows. In Section II, we
ﬁrst introduce RSA and Difﬁe-Hellman cryptosystems. We
also show the algorithms to compute exponentiation. In
Section III, the previous fault based attacks against the
exponentiation algorithm are reviewed. In Section IV, we
propose an extended attack against the left-to-right expo-
nentiation algorithm and show how to apply this attack to
the Montgomery ladder algorithm. Section V concludes the
paper.
II. PRELIMINARY BACKGROUND
A. The RSA Cryptosystem
In the RSA [18] cryptosystem, let p and q be two large
primes kept secret to the public and N = p · q is the RSA
public modulus. The public key e should be relatively prime
to φ(N) = (p − 1) · (q − 1), and d is the corresponding
25
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

private key satisfying e · d ≡ 1 (mod φ(N)). To encrypt a
message m with the public key e, we compute C = me mod
N and to decrypt a cipher C with the private key d, we
compute m = Cd mod N. Signing a message m, the private
computation S = md mod N is performed and veriﬁcation
of a signature S is to check whether m = Se mod N.
B. Public Key Cryptosystems Based on Discrete Logarithm
Many important public key cryptosystems have been
designed with their security based on solving the discrete
logarithm problem, e.g., Difﬁe-Hellman key exchange [9],
ElGamal scheme [10], Schnorr scheme [19], and ECC
[13] (e.g., elliptic curve Difﬁe-Hellman key exchange [17]).
These cryptosystems are constructed over a ﬁnite cyclic
group and solving the discrete logarithm problem over this
group is believed to be hard. The multiplicative group and
the additive group on an elliptic curve are two widely used
groups for constructing this kind of cryptosystems. The
Difﬁe-Hellman key exchange scheme is reviewed in the
following.
Key generation: Let G be a cyclic group of order p and g
is a generator. Each user selects a random integer xi ∈ Zp
as the private key and the public key is yi = gxi.
Key exchange: To exchange a shared key kab with another
party, user a receives the public key yb from user b and
computes the shared key kab = yxa
b .
C. Exponentiation Algorithms
Let d = Pn−1
i=0 di 2i be the binary expression of the expo-
nent d. An exponentiation algorithm computes the value of
md given the base number m and the exponent d. A variety
of efﬁcient exponentiation algorithms have been proposed so
far to compute md while the binary left-to-right square-and-
multiply algorithm (refer to Figure 1) and the right-to-left
square-and-multiply algorithm (refer to Figure 2) are the two
most widely employed methods [15].
In this paper, the iteration number of the left-to-right ex-
ponentiation algorithm is denoted decreasingly from (n−1)
downward towards zero and that of the right-to-left version
is denoted increasingly from zero upward towards (n − 1).
III. REVIEW OF FAULT BASED ATTACKS AGAINST
EXPONENTIATION ALGORITHM
Some fault based attacks against the exponentiation or the
scalar multiplication have been proposed [1], [2], [4], [7],
[8], [11] so far and can be classiﬁed into two categories. The
ﬁrst category of attacks modify the value of the exponent
and the second category of attacks disturb the intermediate
value of the exponentiation computation, e.g., the value R[0]
in the right-to-left exponentiation algorithm.
A. Fault Based Attack on the Exponent
Bao et al. [1] proposed a fault based attack to threaten
some cryptosystems, e.g., the RSA system. The fault model
Input: m, d = (dn−1 · · ·d0)2
Output: md
01
R[0] ← 1
02
for i from n − 1 downto 0 do
03
R[0] ← R[0]2
04
if (di = 1) then
R[0] ← R[0] · m
05
return R[0]
Figure 1.
Left-to-right exponentiation.
Input: m, d = (dn−1 · · ·d0)2
Output: md
01
R[0] ← 1; R[1] ← m
02
for i from 0 to n − 1 do
03
if (di = 1) then
R[0] ← R[0] · R[1]
04
R[1] ← R[1]2
05
return R[0]
Figure 2.
Right-to-left exponentiation.
of this attack is to induce a one-bit fault into the exponent
d such that the binary value of certain bit, say dj, will be
inverted. Let d′ be the faulty exponent and the faulty output
of the exponentiation is S′ = md′ = m(Pn−1
i=0,i̸=j di2i)+dj2j
where dj is the one’s complement of dj. Given the afore-
mentioned faulty output S′ and the corresponding correct
one S, the adversary can identify the value of the bit dj by
analyzing the value of S′
S = m(dj−dj)2j. We have S′
S =
1
m2j
if dj = 1, and S′
S = m2j if dj = 0.
The attack is also applicable to the multi-bit-fault model.
Assume dj and dk are inverted, the adversary can derive
the values of both bits by analyzing
S′
S
= m(dj−dj)2j ·
m(dk−dk)2k. In [11], Joye et al. extended the attack such
that only the faulty result S′ is needed with the knowledge
of the plaintext m and additionally its order.
B. Bellcore’s Fault Based Attack against the Right-to-left
Exponentiation Algorithm
Bellcore’s researchers proposed the fault based attack [8]
to defeat the RSA private computation with the right-to-left
exponentiation algorithm (refer to Figure 2). The fault model
of Bellcore’s attack is a random one-bit fault injected into
the intermediate value of R[0] at the end of the iteration
(j − 1) or at the end of the Step (03) of that iteration. The
faulty result of R[0] at the end of the iteration (j − 1) can
be expressed as
R[0] = (m
Pj−1
i=0 di2i
j
) ± 2b mod N
where 2b is the injected error in which 0 ≤ b ≤ n − 1 (n is
the bit length of N) and mj is the base number, e.g., the
plaintext in a signature.
26
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

The principle of Bellcore’s attack.
Bellcore’s attack
consists of the following steps.
1) The adversary collects sufﬁcient faulty signatures S′
j
with the corresponding plaintexts mj by injecting a
random one-bit fault into R[0] during each execution
of md.
2) The adversary analyzes each faulty signature S′
j with
the plaintext mj and he has
S′
j
=
(m
Pj−1
i=0 di2i
j
± 2b) · m
Pn−1
i=j di2i
j
mod N
=
Sj ± (2b · m
Pn−1
i=j di2i
j
) mod N,
or Sj = S′
j ± 2b · mω
j mod N where ω = Pn−1
i=j di2i.
3) With the public exponent e and the collected pairs of
(S′
j, mj), the adversary tests all the possible candi-
dates of b and ω by checking whether
mj = (S′
j ± 2b · mω
j )e mod N.
To derive the value of ω in each test needs a known part of
binary representation of d and at most l unknown bits where
l denotes the longest distance between two nearby iterations
at which random faults occurred. Suppose the position at
which the random fault occurred on R[0] is unknown (i.e.,
unknown 0 ≤ b ≤ n − 1) and the time at which the random
fault occurred during the exponentiation is unknown (i.e.,
unknown j) and uniformly distributed over [0, n− 1]. Let k
be the number of necessary collected pairs of (S′
j, mj). The
number of tests necessary to recover d is at most k · (n · k ·
Pl
r=1 2r) and the complexity of this attack is
O(n · k2 · 2l).
In [8, Theorem 3], Boneh et al. proved that to recover
d with probability at least
1
2 requires about (n/l) log(2n)
pairs of (S′
j, mj) and the complexity of the attack becomes
O(n3 · log2(n) · 2l/l2).
C. Berzati et al.’s Fault Based Attack
In 2008, Berzati et al. [2] modiﬁed the Bellcore’s
attack by injecting random one-byte faults into the RSA
public modulus N
right after some iterations instead
of the intermediate value of R[0] of the exponentiation
computation. In Berzati et al.’s attack, the faulty modulus
N can be expressed as N ′ = N ± R8 · 28i where R8 is a
nonzero random byte value and i ∈ [0, n
8 − 1].
The principle of Berzati et al.’s attack. This attack needs
to collect a correct signature S and k faulty signatures S′
j.
The values of R[0] and R[1] after the computation within the
iteration (j − 1) are m
Pj−1
i=0 di2i mod N and m2j mod N,
respectively. Suppose the fault upon N occurs at the end
of the iteration (j − 1). The value of the collected faulty
signature S′
j becomes
S′
j =
(m
Pj−1
i=0 di2i mod N) · (m2j mod N)
Pn−1
i=j di2i
mod N ′.
Let ω
=
Pn−1
i=j di2i, so the correct signature can be
expressed as S = mω+Pj−1
i=0 di2i mod N. Based on the
above expression of S and all the possible candidates of
ω and N ′, the adversary can compute
S′
(ω,N′) =

(S · m−ω mod N) · (m2j mod N)ω
mod N ′
and the correct values of ω and N ′ can be determined by
checking whether
S′
(ω,N′) ≡ S′
j (mod N ′)
on all collected faulty outputs S′
j.
Suppose each check requires to determine l unknown bits
of ω and (28 − 1) · n
8 possible byte faults on N, hence the
complexity of Berzati et al.’s attack is
O((28 − 1) · n
8 · k · 2l).
It was claimed that under the assumption of known values
of all j (i.e., the time the faults occurred) [2] the complexity
of the attack becomes
O((28 − 1) · n2
8l · 2l),
if k = n
l .
IV. THE PROPOSED FAULT BASED ATTACK AGAINST THE
LEFT-TO-RIGHT EXPONENTIATION ALGORITHM
The proposed fault based attack is based on Bellcore’s
attack [8] and Berzati et al.’s attack [2], but the attack
targets at the left-to-right exponentiation algorithm with the
additional knowledge of the group order which is a prime.
A. Fault Model
The proposed fault based attack is based on modifying
the intermediate value of R[0] within the left-to-right expo-
nentiation algorithm (refer to Figure 1) by injecting random
one-byte faults. This random one-byte fault model (i.e., the
fault model #3 in [6]) has been considered practical and
widely adopted in many fault based attacks [2], [3], [20].
The faulty value of R[0] can be expressed as
R[0]′ = R[0] ± R8 · 28i
where R8 is a nonzero random byte value and i ∈ [0, n
8 −1]
both are unknown to the adversary.
27
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

B. Principle of the Proposed Attack
The proposed attack needs to collect a correct output S
and k faulty outputs S′
j by injecting random one-byte faults
into the intermediate value of R[0] each at the end of the
iteration j where the iteration number j is unknown to the
adversary and is uniformly distributed over [0, n − 1].
The intermediate value of R[0] after the computation
within the iteration j (denoted as R[0, j]) is R[0, j] =
m
Pn−1
i=j di2i−j. The value of correct output S = md can
be expressed as
S = md = R[0, j]2j · m
Pj−1
i=0 di2i.
Suppose the fault upon R[0] occurs at the end of the iteration
j. The value of the collected faulty output S′
j becomes
S′
j = (R[0, j] ± ε)2j · m
Pj−1
i=0 di2i = (R[0, j] ± ε)2j · mω
where ε = R8 · 28i, i ∈ [0, n
8 − 1] and ω = Pj−1
i=0 di2i.
To derive the partial value of d, say ω, the adversary needs
a previously known Pr
i=0 di2i (r < j−1) and needs to guess
at most l unknown bits of d (say (dj−1, . . ., dr+1)2) where
l denotes the longest distance between two nearby iterations
at which random faults injected.
Suppose that the order of the group is a prime integer
and which is known to the adversary. The correct value of
R[0, j] can therefore be derived from the correct output S
by
R[0, j] = (S · m− Pj−1
i=0 di2i)(2j)−1 = (S · m−ω)(2j)−1.
The reason of the assumption of a known prime order is to
enable the adversary to compute (2j)−1.
Based on the derived ω, R[0, j], and all the possible
candidates of ε, the adversary can compute
S′
(ω,ε) =

(S · m−ω)(2j)−1 ± ε
2j
· mω
and the correct values of ω and ε can be veriﬁed by checking
whether
S′
(ω,ε) ≡ S′
j
on all collected faulty outputs S′
j.
Based on the above proposed attack the adversary can
recover the binary expression of the private exponent d
from the least signiﬁcant bits towards the most signiﬁcant
bits. However, the last few bits with the most signiﬁcant
weightings cannot be derived by the attack. These few bits,
say (dn−1, . . ., dt)2 and t is the maximum value for which
a fault occurred at the iteration t, can only be obtained by
other approaches, e.g., a brute force search. Bellcore’s attack
and Berzati et al.’s attack share the same property of the
proposed attack but the brute force search happens at the
least signiﬁcant bits.
C. Practicability of the Attack
We wish to point out that injecting a one-byte fault into
the intermediate value of a register of an exponentiation
algorithm assumed in the proposed attack would be more
practical than injecting a one-bit fault into a register assumed
in the Bellcore’s attack. Moreover, the aforementioned as-
sumption made in the proposed attack might be much more
practical than injecting a one-byte fault into the storage of
a cryptographic parameter, e.g., the RSA public modulus
N assumed in Berzati et al.’s attack. The reason is that
usually a cryptographic parameter will be stored in a non-
volatile storage, e.g., ﬂash memory or ROM, and a previous
random one-byte fault once injected will be difﬁcult to
remove and a new one-byte fault to be injected again which
is implicitly assumed in Berzati et al.’s attack. So, among
the aforementioned three fault based attacks, the proposed
attack in this paper demonstrates a higher feasibility.
The computation time of an exponentiation algorithm
dominates the performance of many cryptosystems. To im-
prove the performance of cryptosystems, especially for those
with their security based on solving the discrete logarithm
problem, the group G is usually replaced by a subgroup
with a prime order q of which when binary represented
the number of bits is much smaller than that of p. This
technique was ﬁrst employed in the Schnorr scheme [19].
For security reasons, elliptic curve based cryptosystems, e.g.,
elliptic curve Difﬁe-Hellman key exchange [17], usually
choose a prime order [16]. Both the aforementioned prime
order of a multiplicative subgroup and the prime order of
an elliptic curve are public informations. So, the assumption
made in the proposed attack is reasonable.
D. Complexity of the Proposed Attack and Comparison with
Other Attacks
Suppose the byte-fault pattern R8 ∈ [1, 28 − 1], the byte
position i ∈ [0, n
8 − 1] at which the random byte fault
occurred on R[0], and the time (say, the iteration number
j ∈ [0, n − 1]) at which the random byte fault occurred
during the exponentiation are all unknown to the adversary.
In the proposed attack, to perform test of the relationship
S′
(ω,ε) ≡ S′
j, the adversary needs to try all the possible
candidates of ω and ε to identify the correct values of both
ω and ε.
A segment of at most l least signiﬁcant bits of d will be
derived ﬁrst when the correct value of ω can be identiﬁed,
and the exact value of the corresponding iteration number j
will be found as well. At most Pl
r=1 2r possible ω will be
tested. Other portion of the binary representation of d can be
derived in the same approach towards the most signiﬁcant
bits. The correct value of ε can be identify from one of the
possible (28 − 1) · n
8 one-byte faults occurred on R[0]. All
in all, the number of tests necessary to recover d is at most
k · ((28 − 1) · n
8 · k · Pl
r=1 2r) and the complexity of this
28
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

attack becomes
O((28 − 1) · n
8 · k2 · 2l).
The complexity of the proposed attack is basically similar
to Bellcore’s attack, and the difference is that we assume
random one-byte faults while Bellcore’s attack assumes
random one-bit faults. The numbers of possible fault patterns
in the proposed attack and Bellcore’s attack are (28 − 1) · n
8
and n, respectively. However, the numbers of necessary
faulty outputs (i.e., k) of both attacks are different, and both
attacks assume different fault models.
With the knowledge of all values of iteration number j
(i.e., the time the random byte faults occurred) as assumed
in Berzati et al.’s attack [2], the complexity of the proposed
attack can be reduced to O((28 − 1) · n
8 · k · 2l). Let k = n
l ,
the complexity becomes
O((28 − 1) · n2
8l · 2l)
which is the same as Berzati et al.’s attack.
E. Attack Extension to the Montgomery Ladder
In [12], an exponentiation algorithm based on the Mont-
gomery ladder was proposed to prevent the SPA attack [14],
the computational safe-error attack [22], and the memory
safe-error attack [21]. The Montgomery ladder algorithm
shown in Figure 3 behaves regularly and accordingly it
is secure against the SPA attack. Most specially, there
is no dummy computation within the Montgomery ladder
algorithm so it can be secure against the computational safe-
error attack. Any random computational fault occurred will
lead to a faulty result of md.
Input: m, d = (dn−1 · · ·d0)2
Output: md
01
R[0] ← 1; R[1] ← m
02
for i from n − 1 downto 0 do
03
R[di] ← R[0] · R[1]
04
R[di] ← R[di]2
05
return R[0]
Figure 3.
Montgomery ladder algorithm.
The proposed fault based attack can be extended to
the Montgomery ladder algorithm with the same random
one-byte fault model. The byte fault will be injected into
the intermediate value of R[0] at the end of a speciﬁc
iteration j during the exponentiation. The adversary needs
to collect sufﬁcient faulty outputs S′
j and a correct output S.
Principle of the attack. According to the basic principle
of Montgomery ladder, the intermediate values of R[0]
and R[1] after the computation within the iteration j are
R[0, j] = m
Pn−1
i=j di2i−j and R[1, j] = m(Pn−1
i=j di2i−j)+1 =
R[0, j] · m, respectively. So, the output of the algorithm can
be expressed as
S = md = R[0, j]2j · m
Pj−1
i=0 di2i.
Providing two initial values B0 = ma and B1 = ma+1 for
some integer a, and a k-bit binary bit string (ek−1 · · ·e0)2
representing an exponent e = Pk−1
i=0 ei2i, we deﬁne a
function Mont(B0, B1, (ek−1 · · ·e0)2) which represents the
output Be
0 of the Montgomery ladder algorithm. The out-
put S = md of the Montgomery ladder algorithm can
therefore be expressed as Mont(1, m, (dn−1 · · ·d0)2) or
Mont(R[0, j], R[1, j], (dj−1 · · ·d0)2). If a fault ε is injected
into R[0] at the end of the iteration j, then the faulty output
S′
j of the Montgomery ladder algorithm becomes
S′
j = Mont(R[0, j] ± ε, R[1, j], (dj−1 · · ·d0)2)
where ε = R8 ·28i, i ∈ [0, n
8 −1] and ω represents the value
Pj−1
i=0 di2i. Here we also assume that the order of the group
is a public prime integer, hence the values of R[0, j] and
R[1, j] can therefore be derived based on the correct output
S by
R[0, j]
=
(S · m− Pj−1
i=0 di2i)(2j)−1 = (S · m−ω)(2j)−1
R[1, j]
=
R[0, j] · m.
Based on all the possible candidates of bit string
(dj−1 · · ·d0)2 (accordingly the value ω = Pj−1
i=0 di2i) and
injected byte fault ε, the adversary can compute
S′
(ω,ε) =
Mont

(Sm−ω)(2j)−1 ± ε, (Sm−ω)(2j)−1m, (dj−1 · · ·d0)2

.
The correct values of ω and ε can be veriﬁed by checking
whether S′
(ω,ε) ≡ S′
j on all collected faulty outputs S′
j.
The complexity of the above attack on the Montgomery
ladder algorithm is basically the same as that attacking
the left-to-right exponentiation algorithm. An alternative
attack
approach
is
that
the
byte
faults
are
injected
to
the
intermediate
value
of
R[1]
instead
of
R[0]
and in this case the faulty output is assumed to be
S′
j = Mont(R[0, j], R[1, j] ± ε, (dj−1 · · · d0)2).
Practicability of the attack.
The proposed fault based
attack can break not only the well-known conventional
left-to-right exponentiation algorithm but also the enhanced
algorithm against side-channel attack and safe-error attack,
say the Montgomery ladder algorithm. In fact, the Mont-
gomery ladder algorithm might be more vulnerable to the
proposed attack because the algorithm behaves regularly in
each iteration.
In the Montgomery ladder algorithm, each iteration per-
forms two similar operations and the total number of oper-
ations to be performed within the algorithm is always 2n.
Therefore, a very precise estimation of the computation time
29
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

for a single iteration is accessible after a few experiments.
These experiments can even be performed upon other similar
devices. From the view point of controllability of fault
occurrence time (e.g., fault injected at the end of an iteration)
and accordingly the feasibility of an attack, the proposed ex-
tended attack on the Montgomery ladder algorithm becomes
more practical than all the previous attacks.
V. CONCLUSION
In this paper, based on the previous fault based attacks
against the right-to-left exponentiation algorithm, we pro-
pose a new attack against the left-to-right exponentiation
algorithm on some public key cryptosystems, such as Difﬁe-
Hellman key exchange and ECC, if they are constructed
under a group with a prime order. The complexity of
the proposed attack is the same as that of the previous
related attacks. Moreover, the proposed attack can also be
extended to threaten the Montgomery ladder algorithm and
this extended attack could be even more practical than all
other related attacks.
ACKNOWLEDGMENT
This research was supported in part by the National
Science Council of the Republic of China under contract
NSC 98-2221-E-008-047-MY3.
REFERENCES
[1] F. Bao, R. H. Deng, Y. Han, A. Jeng, A. D. Narasimbalu,
and T. Ngair, “Breaking public key cryptosystems on tamper
resistant devices in the presence of transient faults,” in Proc.
Security Protocols Workshop 1997, LNCS 1361, Springer-
Verlag, pp. 115–124.
[2] A. Berzati, C. Canovas, and L. Goubin, “Perturbing RSA
public keys: an improved attack,” in Proc. CHES 2008, LNCS
5154, Springer-Verlag, pp. 380–395.
[3] A. Berzati, C. Canovas, and L. Goubin, “(In)security against
fault injection attacks for CRT-RSA implementations,” in Proc.
Workshop on Fault Diagnosis and Tolerance in Cryptography
– FDTC 2008, pp. 101–107.
[4] I. Biehl, B. Meyer, and V. Muller, “Differential fault attacks on
elliptic curve cryptosystems,” in Proc. CRYPTO 2000, LNCS
1880, Springer-Verlag, pp. 131–146.
[5] E. Biham and A. Shamir, “Differential fault analysis of secret
key cryptosystems,” in Proc. CRYPTO 1997, LNCS 1294,
Springer-Verlag, pp. 513–525.
[6] J. Bl¨omer, M. Otto, and J. P. Seifert, “A new CRT-RSA
algorithm secure against bellcore attacks,” in Proc. ACM CCS
2003, ACM Press, pp. 311–320.
[7] J. Bl¨omer, M. Otto, and J. P. Seifert, “Sign change fault
attacks on elliptic curve cryptosystems,” in Proc. Workshop
on Fault Diagnosis and Tolerance in Cryptography – FDTC
2006, LNCS 4236, Springer-Verlag, pp. 36–52.
[8] D. Boneh, R. A. DeMillo, and R. J. Lipton, “On the impor-
tance of checking cryptographic protocols for faults,” in Proc.
EUROCRYPT 1997, LNCS 1233, Springer-Verlag, pp. 37–51.
[9] W. Difﬁe and M. E. Hellman, “New directions in cryptogra-
phy,” IEEE Trans. Inf. Theory, vol. 22, no. 6, pp. 644–654,
1976.
[10] T. ElGamal, “A public key cryptosystem and a signature
scheme based on discrete logarithms,” in Proc. CRYPTO 1984,
LNCS 196, Springer-Verlag, pp. 10–18.
[11] M. Joye, J. J. Quisquater, F. Bao, and R. H. Deng, “RSA-
type signatures in the presence of transient faults,” in Proc.
Cryptography and Coding 1997, LNCS 1355, Springer-Verlag,
pp. 155–160.
[12] M. Joye and S. M. Yen, “The Montgomery powering ladder,”
in Proc. CHES 2002, LNCS 2523, Springer-Verlag, pp. 291–
302.
[13] N. Koblitz, “Elliptic curve cryptosystems,” Mathematics of
Computation, vol. 48, pp. 203–209, 1987.
[14] P. Kocher, J. Jaffe, and B. Jun, “Differential power analysis,”
in Proc. CRYPTO 1999, LNCS 1666, Springer-Verlag, pp. 388–
397.
[15] A. J. Menezes, P. C. van Oorschot, and S. A. Vanstone,
Handbook of Applied Cryptography. CRC Press, 1997.
[16] National Institute of Standards and Technology, Recom-
mended Elliptic Curves for Federal Government Use. In the
appendix of FIPS 186-2.
[17] National Institute of Standards and Technology, Special Pub-
lication 800-56A: Recommendation for Pair-Wise Key Estab-
lishment Schemes Using Discrete Logarithm Cryptography.
March, 2006.
[18] R. Rivest, A. Shamir, and L. Adleman, “A method for
obtaining digital signatures and public key cryptosystems,”
Comm. of the ACM, vol. 21, no. 2, pp. 120–126, 1978.
[19] C. P. Schnorr, “Efﬁcient identiﬁcation and signatures for smart
cards,” in Proc. Crypto 1989, LNCS 435, Springer-Verlag,
pp. 239–252.
[20] D. Wagner, “Cryptanalysis of a provably secure CRT-RSA
algorithm,” in Proc. ACM CCS 2004, ACM press, pp. 311–
320.
[21] S. M. Yen and M. Joye, “Checking before output may not
be enough against fault-based cryptanalysis,” IEEE Trans.
Computers, vol. 49, no. 9, pp. 967–970, 2000.
[22] S. M. Yen, S. Kim, S. Lim and S. Moon, “A countermeasure
against one physical cryptanalysis may beneﬁt another attack,”
in Proc. ICISC 2001, LNCS 2288, Springer-Verlag, pp. 414–
427.
30
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

