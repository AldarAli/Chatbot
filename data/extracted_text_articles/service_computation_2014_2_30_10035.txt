Genetic Algorithm to the Power of SMT:
a Hybrid Approach to Web Service Composition Problem
Artur Niewiadomski
Institute of Computer Science
Siedlce University
Siedlce, Poland
e-mail: artur.niewiadomski@uph.edu.pl
Wojciech Penczek
Institute of Computer Science
Polish Academy of Science
Warsaw, Poland
e-mail: penczek@ipipan.waw.pl
Jaroslaw Skaruz
Institute of Computer Science
Siedlce University
Siedlce, Poland
e-mail: jaroslaw.skaruz@uph.edu.pl
Abstract—The paper deals with the concrete planning problem – a
stage of the Web Service Composition in the PlanICS framework,
which consists in choosing the best service offers in order to
satisfy the user query and to maximize the quality function. We
introduce a novel planning technique based on a combination of
a Genetic Algorithm with a Satisﬁability Modulo Theories Solver,
which allows to obtain better results than each of the methods
separately. The paper presents some preliminary, although very
encouraging, experimental results.
Keywords-Web Service Composition; Concrete Planning; Ge-
netic Algorithm; Satisﬁability Modulo Theories; Hybrid Algorithm
I.
INTRODUCTION
One of the fundamental ideas of Service-Oriented Architec-
ture (SOA) [1] is to compose simple functionalities, accessible
via well-deﬁned interfaces, in order to realize more sophisti-
cated objectives. The problem of ﬁnding such a composition
is hard and known as the Web Service Composition (WSC)
problem [1][2][3].
PlanICS [4] is a framework aimed at WSC, easily adapting
existing real-world services. The main assumption in PlanICS
is that all the web services in the domain of interest as well as
the objects that are processed by the services, can be strictly
classiﬁed in a hierarchy of classes, organised in an ontology.
Another key idea is to divide the planning into several stages.
The ﬁrst phase deals with classes of services, where each class
represents a set of real-world services, while the other phaces
work in the space of concrete services. The ﬁrst stage produces
an abstract plan composed of service classes [5]. Next, offers
are retrieved by the Offer Collector (OC), a module of PlanICS,
and used in the concrete planning (CP). As a result of CP,
a concrete plan is obtained, which is a sequence of offers
satisfying predeﬁned optimization criteria. Such an approach
enables to reduce dramatically the number of web services to
be considered, and inquired for offers.
This paper deals with the Concrete Planning Problem
(CPP), shown to be NP-hard [6]. Our previous works employ
several techniques to solve it: a Genetic Algorithm (GA) [7],
numeric optimization methods [8] as well as Satisﬁability
Modulo Theories (SMT) Solvers [6]. The results of the exten-
sive experiments show that the proposed methods are comple-
mentary, but every single one suffers from some disadvantages.
The main disadvantage of an SMT-based solution is often a
long computation time, which is not acceptable in the case of
a real-world interactive planning tool. On the other hand, a
GA-based approach is relatively fast, but it yields solutions,
which are far from optimum and found with a low probability.
Thus, our aim is to exploit the advantages of both methods
by combining them into one hybrid algorithm, which is the
main contribution of this paper. The main idea of our new
hybrid approach involves a modiﬁcation of the standard GA,
such that after every couple of iterations of GA, several top-
ranked individuals are processed by the SMT-based algorithm
in order to improve them.
Over the last few years, CPP has been extensively studied
in the literature. G. Canfora et al. [9] use a simple GA to obtain
a good quality concrete plan. Y. Wu et al. [10] transforms
CPP to a multi-criteria optimization problem and exploits GA
to ﬁnd a concrete plan. However, the authors present the
experiments on a relatively small search space that could not
provide valuable conclusions.
The rest of the paper is structured as follows. In Section
II the PlanICS framework is introduced and CPP is deﬁned.
Section III presents the main ideas of our hybrid approach
as well as some technical solutions. Next, the preliminary
experimental results are presented and discussed. The paper
ends with some conclusions.
II.
CONCRETE PLANNING PROBLEM
This section introduces the main ideas behind the PlanICS
framework and gives all the necessary deﬁnitions for deﬁning
the concrete planning problem.
An ontology contains a system of classes describing the
types of the services as well as the types of the objects they
process. A class consists of a unique name and a set of the
attributes. By an object we mean an instance of a class. By a
state of an object we mean a valuation of its attributes. A set
of objects in a certain state is called a world. A key notion
of PlanICS is that of a service. We assume that each service
processes a set of objects, possibly changing values of their
attributes, and produces a set of new (additional) objects. We
say that a service transforms a world. The types of services
available for planning are deﬁned as elements of the branch of
44
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-337-7
SERVICE COMPUTATION 2014 : The Sixth International Conferences on Advanced Service Computing

abstract
planner
ontology
provider
concrete
planner
service registry
web services interfaces
offers
service selection
abstract
plans
source
of semantics
offer
collector
offer
plans
Figure 1.
A simpliﬁed diagram of the PlanICS system architecture.
classes rooted at Service concept. Each service type stands
for a description of a set of real-world services of similar
functionality.
The main goal of the system is to ﬁnd a composition of
services that satisﬁes a user query. The query interpretation
results in two sets of worlds: the initial and the expected
ones. Moreover, the query may include additional constraints,
especially quality constraints, the sum of which is used to
choose the best from all the potential solutions. Thus, the task
of the system is to ﬁnd such a set of services, which transform
some initial world into a world matching some expected one in
such a way that the value of the quality function is maximized.
Figure 1 shows the general PlanICS architecture. The bold
arrows correspond to computation of a plan, the thin arrows
model the planner infrastructure.
In the ﬁrst stage of the composition, an abstract planner
matches services at the level of input/output types and the
abstract values. At this planning stage, it is enough to know if
an attribute does have a value, or it does not, so we abstract
from the concrete values of the object attributes. The result
of this stage is a Context Abstract Plan (CAP), consisting of
a multiset of service types (deﬁned by a representative se-
quence), contexts (mappings between services and the objects
being processed), and a set of ﬁnal worlds containing objects
that fulﬁll the user query. See [5] for more details.
In the second planning stage, a CAP is used by OC,
i.e., a tool, which in cooperation with the service registry,
queries real-world services. The service registry keeps an
evidence of real-world web services, registered accordingly to
the service type system. During the registration, the service
provider deﬁnes a mapping between the input/output data of
the real-world service and the object attributes processed by the
declared service type. OC communicates with the real-world
services of types present in a CAP, sending the constraints on
the data, which can potentially be sent to the service in an
inquiry, and on the data expected to be received in an offer
in order to keep on building a potential plan. Usually, each
service type represents a set of real-world services. Moreover,
querying a single service can result in a number of offers.
Thus, we deﬁne offer sets as the main result of the second
planning stage.
Deﬁnition 1 (Offer, Offer set): Assume that the n-th in-
stance of a service type from a CAP processes some number
of objects having in total m attributes. A single offer collected
by OC is a vector P = [v1, v2, . . . , vm], where vj is a value
of a single object attribute processed by n-th service of the
CAP. An offer set On is a k × m matrix, where each row
corresponds to a single offer and k is the number of offers in
the set. Thus, the element on
i,j is the j-th value of the i-th offer
collected from the n-th service type instance from the CAP.
The responsibility of OC is to collect a number of offers,
where every offer represents one possible execution of a single
service. However, other important tasks of OC are: (1) building
a set of constraints resulting from the user query and from
semantic descriptions of service types, and (2) a conversion of
the quality constraints expressed using objects from the user
query to an objective function built over variables from offer
sets. Thus, we can formulate CPP as a constrained optimization
problem.
Deﬁnition 2 (CPP): Let n be the length of CAP and let
O = (O1, . . . , On) be the vector of offer sets collected by OC
such that for every i = 1, . . . , n
Oi =


oi
1,1
. . .
oi
1,mi
...
...
...
oi
ki,1
. . .
oi
ki,mi

 , and the j-th row of Oi is
denoted by P i
j. Let P denote the set of all possible sequences
(P 1
j1, . . . , P n
jn), such that ji ∈ {1, . . . , ki} and i ∈ {1, . . . , n}.
The Concrete Planning Problem is deﬁned as:
max{Q(S) | S ∈ P} subject to C(S),
(1)
where Q : P 7→ R is an objective function deﬁned as the sum
of all quality constraints and C(S) = {Cj(S) | j = 1, . . . , c
for c ∈ N}, where S ∈ P, is a set of constraints to be satisﬁed.
Finding a solution of CPP consists in selecting one offer
from each offer set such that all constraints are satisﬁed and
the value of the objective function is maximized. This is the
goal of the third planning stage and the task of a concrete
planner.
Example. Consider a simple ontology describing a frag-
ment of some ﬁnancial market consisting of service types
inheriting from the class Investment, which represent various
types of ﬁnancial instruments. Moreover, the ontology contains
three object types: Money having the attribute amount,
Transaction having the two attributes amount and profit,
and Charge having the attribute fee. Suppose that each
investment service takes m - an instance of Money as input,
produces t and c - instances of Transaction and Charge, and
updates the amount of money remaining after the operation,
i.e., the attribute m.amount. Assume that the user would like
to invest up to $100 in three ﬁnancial instruments, but he wants
to locate more than $50 in two investments. Moreover, the user
wants to maximize the sum of proﬁts and wants to use only
services of handling fees less than $3. The latter two conditions
can be expressed as an appropriate quality function and an
aggregate condition. Consider an exemplary CAP consisting
of three instances of the Investment service type. A single
offer collected by OC is a vector [v1, v2, v3, v4, v5], where v1
corresponds to m.amount, v2 to t.amount, v3 to t.profit,
and v4 to c.fee. Since the attribute m.amount is updated
during the transformation, the offers should contain values
from the world before and after the transformation. Thus
v5 stands for the value of m.amount after modiﬁcation.
Assuming that instances of Investment return k1, k2, and
k3 offers in response to the subsequent inquiries, we obtain
three offer sets: O1, O2, and O3, where Oi is a ki × 5
45
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-337-7
SERVICE COMPUTATION 2014 : The Sixth International Conferences on Advanced Service Computing

matrix of offer values. The conditions from the query are
translated to the following constraints: C1 := (o1
i1,1 ≤ 100)
and C2 := (o1
i1,2 + o2
i2,2 > 50), where i1, i2, and i3 are
variables ranging over 1 . . . ki. Moreover, the amount of money
left after the operation is an input for the next investment.
Thus, we have: C3 := (o1
i1,5 = o2
i2,1) and C4 := (o2
i2,5 =
o3
i3,1). The aggregate condition is translated to the following
constraint: C5 :=

the values of the changed genes are decoded from the model
returned by the SMT-solver, and the improved individual I′
replaces I in the current population.
B. Experimental Results
As benchmarks for our experiments we choose four in-
stances of CPP, which turned out to be difﬁcult to solve
using our “pure” SMT- and GA-based planner [6][8]. All
the instances represent plans of length 15. Each offer set of
Instances 1 and 3 contains 256 offers, hence, the number of
the potential solutions equals 25615 = 2120. In the case of
Instances 2 and 4 each offer set consists of 512 offers, thus
the size of the search space is 51215 = 2135. The objective
functions are as follows:
Q1,2 =
n
X
i=1
oi
ji,1,
Q3,4 =
n
X
i=1
(oi
ji,1 + oi
ji,2),
(5)
while the set of the constraints is the same for all instances,
and is deﬁned as:
C = {(oi
ji,2 < oi+1
ji+1,2)},
for i = 1, . . . , n − 1.
(6)
Besides the ordinary parameters of GA (which have been
set to the same values as in pure GA), that is, the population
size (1000), the number of iterations (100), the crossover
and mutation probabilities (95% and 0.5% respectively), we
introduce also parameters inﬂuencing the behaviour of the
SMT component. Namely, when to start the SMT procedure
for the ﬁrst time (in the 20th iteration), how often the SMT
procedure should be run (the parameter int stands for the
number of the iterations between the subsequent SMT calls),
the number of individuals passed to the SMT-solver during one
iteration (parameter inds), and how many genes are allowed to
be changed by SMT (the parameter ch.genes). Every instance
has been tested 12 times, using a different combination of
the parameters combination, and every experiment has been
repeated 30 times on a standard PC with 2.8GHz CPU and Z3
[11] version 4.3 as SMT-solving engine.
The preliminary results of applying our new hybrid algo-
rithm to Instance 1 and 2 are presented in Table I, where
the columns from left to right display the parameter values
and for each Instance, the total runtime of the algorithm
(t[s]), the average quality of solutions found (avgQ), and the
probability of ﬁnding a solution (P). For reference, we report
in the two bottom rows the results of the pure SMT- and
GA-based planners. One can easily see that quality values
obtained in every experiment are higher than these returned
by GA. However, in several cases the runtime or probability
is not acceptable. We marked in bold the results, where the
probability of ﬁnding a solution is at least 40% and the runtime
is lower than that of the pure SMT-based planner.
For Instances 3 and 4, which objective function is more
difﬁcult, the results are given in Table II. Still, in some cases,
the results are better than these returned by the pure planning
methods. Note that the pure SMT-based algorithm was not able
to ﬁnd the optimal solution within given time limit (500 sec.).
Although the results are encouraging, the hybrid solution is
clearly a trade-off between the three measures: the quality, the
probability, and the computation time of the pure algorithms. In
TABLE I.
EXPERIMENTAL RESULTS FOR INSTANCES 1 AND 2.
Parameters
Instance 1
Instance 2
ch.genes
inds
int
t[s]
avgQ
P
t[s]
avgQ
P
8
1
10
9.29
1305.0
3.33
14.94
1382.0
6.67
20
8.25
1331.5
6.67
13.23
1371.5
13.3
10
10
41.04
1386.7
53.3
59.52
1437.6
36.7
20
22.44
1389.0
26.7
41.73
1414.0
33.3
20
10
76.29
1405.8
70.0
118.1
1441.0
73.3
20
34.28
1356.5
43.3
61.94
1420.3
40.0
12
1
10
39.61
1363.1
66.7
56.59
1405.3
93.3
20
14.48
1326.9
46.7
20.38
1380.0
40.0
10
10
203.6
1417.6
100
273.2
1455.8
100
20
114.7
1362.2
100
155.9
1431.3
100
20
10
346.5
1424.2
100
443.1
1460.5
100
20
196.4
1416.5
100
261.7
1455.3
100
Pure SMT
266
1443
100
388
1467
100
Pure GA
4.96
1218.5
8
5.61
1319.9
10
TABLE II.
EXPERIMENTAL RESULTS FOR INSTANCES 3 AND 4.
Parameters
Instance 3
Instance 4
ch.genes
inds
int
t[s]
avgQ
P
t[s]
avgQ
P
8
1
10
13.05
2176.5
6.67
22.08
2229.5
6.67
20
12.36
2054.3
10.0
22.02
2193.6
16.7
10
10
121.7
2311.5
46.7
248.3
2359.1
43.3
20
54.18
2279.4
26.7
151.9
2353.5
43.3
20
10
324.9
2369.4
76.7
566.8
2390.7
60.0
20
175.7
2304.2
50.0
290.8
2334.1
53.3
12
1
10
208.1
2153.4
46.7
239.7
2216.3
56.7
20
54.05
2274.1
36.7
64.08
2167.0
26.7
10
10
1727
2377.9
100
2205
2485.3
100
20
1066
2327.7
96.7
1325
2414.3
96.7
20
10
2814
2447.1
100
4456
2568.2
100
20
2027
2387.3
100
2477
2469.8
96.7
Pure SMT
500
2266*
100
500
2409*
100
Pure GA
5.95
2085.4
10
6.64
2001.9
7
order to compare the results obtained taking all the measures
into account at the same time, we deﬁne four simple score
functions: scorei(P, t, avgQ) = P
t · (avgQ − consti), where
P, t, and avgQ stand for the probability, the computation time,
and the average quality, respectively, and consti is a parameter,
which value is selected in such a way that for each Instance
i from I to IV, the score of the pure GA- and SMT-based
algorithm is the same. These scores are the benchmarks for
the comparison given in Figure 3. The values on the X-axes
correspond to the rows of Table I and II, while the Y-axes
indicate the values of the score functions. The black bars stand
for the best hybrid results in comparison with the pure SMT-
and GA-based algorithms. Notice that the hybrid algorithm
can improve the solution score of each pure algorithm from 2
times (Instance 4) to nearly 6 times (Instance 1).
IV.
CONCLUSION AND FUTURE WORK
The prototype of the hybrid concrete planner has been
implemented and some preliminary experiments have been
performed. The very ﬁrst results show that even using a simple,
or a naive strategy of combining the SMT- and GA-based
approach, one can obtain surprisingly good results. We believe
that the proposed method has a big potential. We plan to further
improve the efﬁciency of our hybrid approach in terms of: a
better quality of solutions, lower computation times, as well
as higher probabilities of ﬁnding solutions. Another important
task to be addressed in a future work is to investigate how to
choose the parameter values, in order to get a trade-off between
quality, probability, and the computation time desired by the
user. Moreover, using the experience gained from the concrete
47
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-337-7
SERVICE COMPUTATION 2014 : The Sixth International Conferences on Advanced Service Computing

0 
100 
200 
300 
400 
500 
600 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 SMT GA 
Instance 1 
0 
20 
40 
60 
80 
100 
120 
140 
160 
180 
200 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 SMT GA 
Instance 2 
-20 
0 
20 
40 
60 
80 
100 
120 
140 
160 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 SMT GA 
Instance 3 
0 
50 
100 
150 
200 
250 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 SMT GA 
Instance 4 
Figure 3. The evaluation of the experimental results using the score functions.
planning, we intend also to develop a hybrid solution for the
abstract planning stage.
ACKNOWLEDGMENT
This work has been supported by the National Science
Centre under the grant No. 2011/01/B/ST6/01477.
REFERENCES
[1]
M. Bell, Introduction to Service-Oriented Modeling (SOA): Service
Analysis, Design, and Architecture.
John Wiley & Sons, 2008.
[2]
S. Ambroszkiewicz, “Entish: A language for describing data processing
in open distributed systems,” Fundam. Inform., vol. 60, no. 1-4, 2003,
pp. 41–66.
[3]
J. Rao and X. Su, “A survey of automated web service composition
methods,” in Proc. of SWSWPC’04, ser. LNCS, vol. 3387.
Springer,
2005, pp. 43–54.
[4]
D. Doliwa et al., “PlanICS - a web service compositon toolset,” Fundam.
Inform., vol. 112(1), 2011, pp. 47–71.
[5]
A. Niewiadomski and W. Penczek, “Towards SMT-based Abstract
Planning in PlanICS Ontology,” in Proc. of KEOD 2013 International
Conference on Knowledge Engineering and Ontology Development,
September 2013, pp. 123–131.
[6]
A. Niewiadomski, W. Penczek, and J. Skaruz, “Smt vs genetic algo-
rithms: Concrete planning in planics framework,” in CS&P, 2013, pp.
309–321.
[7]
J. Skaruz, A. Niewiadomski, and W. Penczek, “Automated abstract
planning with use of genetic algorithms,” in GECCO (Companion),
2013, pp. 129–130.
[8]
A. Niewiadomski, W. Penczek, J. Skaruz, M. Szreter, and M. Jarocki,
“SMT versus Genetic and OpenOpt Algorithms: Concrete Planning in
the PlanICS Framework,” (submitted to Fundam. Inform.), 2014.
[9]
G. Canfora, M. D. Penta, R. Esposito, and M. L. Villani, “An approach
for qos-aware service composition based on genetic algorithms,” in
Proceedings of the 2005 Conference on Genetic and Evolutionary
Computation, 2005, pp. 1069–1075.
[10]
Y. Wu and X. Wang, “Applying multi-objective genetic algorithms
to qos-aware web service global selection,” Advances in Information
Sciences and Service Sciences, vol. 3(11), 2011, pp. 134–144.
[11]
L. M. de Moura and N. Bjørner, “Z3: An efﬁcient SMT solver,” in
Proc. of TACAS’08, ser. LNCS, vol. 4963.
Springer-Verlag, 2008, pp.
337–340.
48
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-337-7
SERVICE COMPUTATION 2014 : The Sixth International Conferences on Advanced Service Computing

