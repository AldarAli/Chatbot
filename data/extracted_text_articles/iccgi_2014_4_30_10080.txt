P2P Integration of Relational Knowledge Bases
Tadeusz Pankowski
Institute of Control and Information Engineering
Pozna´n University of Technology
Pozna´n, Poland
Email: tadeusz.pankowski@put.poznan.pl
Abstract—We discuss some strategies of query answering in
a Peer-to-Peer (P2P) knowledge integration system. In such a
system, a set of autonomous services (peers) manage knowledge
bases, which are connected by means of mappings between
signatures of these knowledge bases. A query is issued against an
arbitrarily chosen peer (a target peer) and is propagated along
semantic paths determined by mappings. Next, partial answers
are sent back to the target peer. We discuss a strategy of both
query propagation and merging partial answers with possibility of
discovering some ”missing values”. The proposed method guar-
antees improvement of quality of answers (their completeness)
and controlling efﬁciency of merging partial answers by deciding
whether it is useful to involve the whole peer’s knowledge base
in the process of discovering missing values.
Keywords—knowledge bases; data integration; integrity con-
straints; data exchange; ontology-based data management.
I.
INTRODUCTION
In recent years, we can observe a dynamic development of
the Semantic Web technologies and using these technologies to
create Web-oriented applications. Semantic Web technologies
enable web-wide integration of data coming from various
sources. In this way, the Web of Data is created, which
can be perceived as a set of interrelated knowledge bases.
Extensional layers of these knowledge bases consist of sets
of the Resource Description Framework (RDF) triples [20] (or
the corresponding Web Ontology Language (OWL) assertions
[11]), and intensional layers are sets of axioms (in RDF
Schema or OWL). Very often, the knowledge bases expose re-
lational databases – then we can call them relational knowledge
bases (RKBs). Owners of such RKBs are often interested in
making them available to a wide range of users. So, the owners
might be interested in including their knowledge resources into
knowledge integration or knowledge exchange systems.
Assuming that RKBs independently created resources on
the Web of Data, we face the challenging issues of knowl-
edge exchange and knowledge integration across them. In the
case of the knowledge exchange, we have to solve problems
connected with mappings and restructuring the knowledge
(captured by axioms in TBoxes and assertions in ABoxes)
[1], and in the case of knowledge integration we have to do
with execution and rewriting of queries according to so-called
Ontology-Based Data Access (OBDA) paradigm [2].
A. Related work
Some recent results of representing relational databases in
the Semantic Web are surveyed in [3] and some solutions
were proposed in [4]–[6]. A relationship between relational
databases and Description Logics (DLs) knowledge bases
has been studied in [7] and [6]. Similarities and differences
between databases and knowledge bases, and combining these
technologies in data integration activities, has been an impor-
tant and attractive ﬁeld of research since many years [7]–[9].
Usually, a knowledge base is founded on one of DL variants
[10] or on one of OWL proﬁles [11]. Formally, a knowledge
base is a pair K = (T , A), where T is a set of axioms
modeling the intensional knowledge (the TBox axioms), and
A is a set of assertions forming the extensional knowledge
(the ABox assertions). In the case of RKBs, T is divided
into two parts, T
= (S, C), where: S is a set of axioms
treated as deductive rules (so-called standard TBox axioms),
and C is a set of axioms treated as checks (called integrity
constraint TBox axioms or ic-axioms) [7]. Some standards
for representing relational databases by means of RDF and
OWL have been under development by a special W3C Working
Group [5]. Following these RDB-to-RDF methods of mapping,
one can create Web of Data repositories consisting of a set of
RKBs representing traditional relational databases (RDBs). It
is expected that such a representation obeys some requirements
concerning preservation of information and semantics of the
underlying RDBs [4] [6].
One of the most promising integration architectures is the
integration in P2P environment [12] [13]. Much work has been
done on data integration systems both with a mediated (global)
schema and in P2P architecture, where the schema of any peer
can play the role of the mediated schema. There is a number of
systems built in P2P data integration paradigm [14] (notably
Piazza [15], PeerDB [16]). In these research, the focus was
on overcoming syntactic heterogeneity and schema mappings
were used to specify how data structured under one schema
(the source schema) can be transformed into data structured
under another schema (the target schema) [17]. A little work
has been paid on how schema constraints inﬂuence the query
propagation.
B. Contribution
In this paper, we will follow the P2P integration archi-
tecture and we will assume that the OBDA paradigm can be
applied to any peer. Then, the peer’s knowledge base plays
the role of a reference ontology and mappings (alignments)
between ontologies (knowledge bases) are used in query
rewriting. The user issues queries against an arbitrarily chosen
peer (the target peer) and expects that the answer will include
relevant data stored in all P2P-connected data sources. The data
sources are related by means of schema mappings. A query
must be propagated to all peers in the system along semantic
paths determined by mappings and reformulated accordingly.
78
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

The partial answers must be merged and sent back to the
calling peer.
In this paper, we will focus on strategies of query propa-
gation and query answering in a P2P knowledge integration
system. The aim is to obtain an answer with a maximal
information contents. We will show that this contents depends
on the way the query is propagated and on the way in which the
partial answers are being merged. The important role plays the
process of discovering missing values, i.e., values denoted by
labeled nulls. Missing values can be sometimes discovered –
either by merging only partial answers or in result of involving
also the whole local RKB. In the latter, the cost of computation
can be high, so the decision what way of merging should be
applied is signiﬁcant.
We formulate and prove a necessary condition (Proposition
4.2 in Section IV) stating when it is useful to discover
missing values by referring to the whole local RKB, and
when it is pointless. We will discuss a strategy of query
propagation and the method of merging partial answers with
possibility of discovering some missing values. The proposed
method guarantees improvement of quality of answers (their
completeness) and controlling efﬁciency of merging partial
queries by deciding whether it is useful to involve a whole
peer’s knowledge base in the process of discovering missing
values. We shortly show how the issues under consideration
have been implemented in SixP2P (Semantic Integration in
P2P environment) system [18] [19].
The structure of the paper is as follows. In Section II, we
introduce a running example consisting of relational databases
(RDBs), we study some query propagation strategies and
merging partial answers. In Section III, we discuss a way of
representing RDBs by means of RKBs. The P2P knowledge
integration is proposed in Section IV. Section V summarizes
and concludes the paper.
II.
MOTIVATION SCENARIO
In this section, we motivate our research. We will start with
three relational databases (Figure 1) as information resources
stored in three peers forming a P2P data integration system
(Figure 2). We discuss how a sample query can be propagated
and answered in the system, and how these inﬂuence the
contents of the answer to the query.
Without loss of generality we will assume that names and
attributes of tables in databases are pair-wise disjoint. Integrity
constraints in DB1 (analogously in DB2 and DB3) are:
•
PKey(Paper1, PapId1) – PapId1 is the primary
key in Paper1, i.e., values in PapId1 are both unique
and not-null;
•
unique(Paper1, Title1) – not-null values in Title1
uniquely identiﬁes tuples in Paper1;
•
FKey(Author1, APapId1, Paper1, PapId1)
–
APapId1 in Author1 is a foreign key referencing to
the column PapId1 in Paper1.
The databases considered in Figure 1 can be stored in peers
constituting a data integration system depicted in Figure 2.
DB1 :
Paper1
PapId1
Title1
Y ear1
Author1
Name1
Univ1
APapId1
DB2 :
Paper2
PapId2
Title2
p1
KBs
Author2
Name2
Univ2
APapId2
John
NY
p1
Ann
NULL
p1
DB3 :
Paper3
PapId3
Title3
Y ear3
p1
KBs
2014
Author3
Name3
APapId3
Ann
p1
Figure 1.
Databases DB1 (with empty instance), DB2 and DB3
Peer1
DB1
Peer2
DB2
Peer3
DB3
Figure 2.
A sample P2P integration architecture with three peers and three
local databases
Now, let us consider a query q1 issued against DB1 on
Peer1. Informally, the meaning of the query is:
”Give all information about John.”
The query can be answered using different strategies. We will
consider three strategies depicted in Figure 3.
1)
In strategy (1), see Figure 3(1), q1 is issued to DB1
(at Peer1). Peer1 rewrites q1 to queries q12 and
q13 against, respectively, DB2 and DB3 and sends
them to Peer2 and Peer3, respectively. Next, the
answer q1(DB1) is obtained and the peer waits for
answers q12(DB2) and q13(DB3). After receiving all
expected answers, the peer merges them producing
the ﬁnal answer. In this case we have:
q1(DB1) = q13(DB3) = ∅,
q12(DB2) = {Paper2(p1, KBs),
Author2(John, NY, p1)}.
2)
In strategy (2), see Figure 3(2), q1, q12, and q13, are
sent to, respectively, Peer1, Peer2, and Peer3, as in
the strategy (1). Peer2 rewrites q12 to q123 and sends
it to Peer3. Now, Peer3 has to answer two queries,
q13 and q123. These queries are not identical because
79
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

(1)
DB1
q1
DB2
q12
DB3
q13
(2)
DB1
q1
DB2
q12
DB3
q13
q123
(3)
DB1
q1
DB2
q12
DB3
q13
q132
Figure 3.
Query propagation strategies
q13 expects information about Y ear3 whereas q123
does not, since the property Y ear is not in its area of
interest. Answers q13(DB3) and q123(DB3) are ex-
pected to be sent to, respectively, Peer1 and Peer2.
Peer2 merges q123(DB3) with q12(DB2) and the
result returns to Peer1. Finally, Peer1 merges all
received data and produces the ﬁnal result. In this
case we have:
q1(DB1) = q13(DB3) = q123(DB3) = ∅,
q12(DB2) = {Paper2(p1, KBs),
Author2(John, NY, p1)}.
3)
Strategy (3), see Figure 3(3), is similar to strategy
(2), but now, Peer3 rewrites q13 to q132 and sends it
to Peer2. We have the following answers:
q1(DB1) = q13(DB3) = ∅,
q12(DB2) = {Paper2(p1, KBs),
Author2(John, NY, p1)},
q132(DB2) = {Paper2(p1, KBs),
Author2(John, , p1)}.
The difference between q12(DB2) and q132(DB2)
follows from the fact that Peer3 does not ask about
university of ”John”.
Now, we will consider some possible ways for merging
answers and discovering missing values in the process of data
integration. We will use the following two operators:
•
⊗i – a binary operator that: restructures its operands
(if necessary) to the structure of DBi and merges these
operands;
•
⊕i – a unary operator that discovers missing values
in its operand using DBi.
Merging in strategy (1):
q1(DB1) ⊗1 q12(DB2) ⊗1 q13(DB3) =
{Paper1(p1, KBs, NULL), Author1(John, NY, p1)}
(1)
Merging in strategy (2). There are two possible merges:
(2a) a partial merge
q1(DB1) ⊗1 q13(DB3) ⊗1 (q12(DB2)
⊗2q123(DB3)) = {Paper1(p1, KBs, NULL),
Author1(John, NY, p1)}
(2)
(2b) a total merge
q1(DB1) ⊗1 q13(DB3) ⊗1 (⊕2(q12(DB2)
⊗2q123(DB3))) = {Paper1(p1, KBs, NULL),
Author1(John, NY, p1)}
(3)
Merging in strategy (3). Again, two merges are possible:
(3a) a partial merge
q1(DB1) ⊗1 q12(DB2) ⊗1 (q132(DB2)
⊗3q13(DB3)) = {Paper1(p1, KBs, NULL),
Author1(John, NY, p1)}
(4)
(3b) a total merge
q1(DB1) ⊗1 q12(DB2) ⊗1 (⊕3(q132(DB2)
⊗3q13(DB3))) = {Paper1(p1, KBs, 2014),
Author1(John, NY, p1)}
(5)
We see that merging strategies (1), (2a), (2b) and (3a)
produce the same result. However, the strategy (3b) gives more
information than the other strategies. It is so, since in (3b) the
missing value of Y ear1 (the year of publication of the paper
KBs) has been discovered (inferred). It is possible, because
there is a functional dependency between titles and years of
papers.
III.
RELATIONAL DB VS RELATIONAL KB
Relationships between RDBs and RKBs can be considered
from the following two points of view.
1. RDB-to-RKB transformation. RDBs can be naturally
represented in the Semantic Web by means of RDF triples
or OWL speciﬁcation [5]. Then, the instance of an RDB is
represented by an ABox (A), and the structure, properties and
integrity constraints by a TBox (devided into a set of deductive
axioms, S, and a set of ic-axioms, C). Then we obtain an RKB
K = (S, C, A) [6].
2. Checking properties of RKB. For a given set of RDF
triples or OWL assertions, treated as an ABox A, and for
a given RKB schema T = (S, C), check whether the tuple
(S, C, A) is a consistent RKB.
Let C = {C1, ..., Ck} and P = {P1, ..., Pp} be sets of
(names of), respectively, classes and properties. The set Σ =
C ∪ P is then referred to as a signature of a knowledge base.
We say that an RKB K = (S, C, A) has the signature Σ (or K
is over Σ) if all classes and properties occurring in K are in
Σ.
80
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

A. Relational knowledge bases
Let ∆Cons be a set of constants, and ∆V ar be a set of
labeled nulls or variables. We assume that for constants the
Unique Name Assumption (UNA) holds while for labeled nulls
the UNA does not hold [8]. Constants will be denoted by
a, b, c (possibly with subscripts), and labeled nulls by x, y, z
(possibly with subscripts), by v (possibly with subscripts) will
be denoted elements from ∆Cons ∪ ∆V ar. The satisfaction of
UNA means that different constants always denote different
objects, i.e., the equality a = b, for a, b ∈ ∆Cons, is always
false. In contrast, x = y for x, y ∈ ∆V ar may be true if
an interpretation assigns the same object to them. Similarly,
x = a can be true when x is interpreted as a. (For the precise
deﬁnition of interpretation, see [10].)
Further on, we will write ABox assertions in a (simpliﬁed)
RDF-notation [20]. In particular: Triple(x, rdf:type, C) or
(x, rdf:type, C) corresponds to OWL class assertion C(x);
and Triple(x, P, v) or (x, P, v) corresponds to OWL property
assertion P(x, v). If clear from the context, the predicate name
Triple will be omitted.
We assume that the following rules must always hold for
any RKB. We will call them general RKB-rules.
•
Classes are subsets of the set of labeled nulls, i.e., for
each C ∈ C, C ⊑ ∆V ar.1
•
Domains of properties are subsets of the set of labeled
nulls, i.e., for each P ∈ P, dom(P) ⊑ ∆V ar.
•
Ranges of properties are subsets of the set of constants
or labeled nulls, i.e., for each P ∈ P, rng(P) ⊑
∆Cons ∪ ∆V ar.
•
Any property is a function, i.e., for each P ∈ P, the
speciﬁcation (funct P) ∈ S holds, which means that
(x, P, v1) ∧ (x, P, v2) ⇒ v1 = v2.
There are also so-called speciﬁc RKB-rules, which are
used to characterize RKBs. These rules correspond to integrity
constraints in relational databases. We restrict ourselves to
key and referential constraints deﬁned only on singletons of
columns. The set of rules is divided into a set of deductive
rules (S), and a set of integrity constraints or check rules (C).
We assume that (funct P) ∈ S. The rest of general RKB-
rules belongs to C. The set of speciﬁc RKB-rules includes the
following classes of rules (TBox axioms):
1)
dom(P) ⊑ C ∈ S – the domain of a property P is
a subset of a class C, i.e.,
(x, P, v) ⇒ (x, rdf:type, C).
2)
(funct P −) ∈ S – the inversion of a property P is
a function, i.e., values of P uniquely identify objects
in the domain of P
(x1, P, v) ∧ (x2, P, v) ⇒ x1 = x2.
1We distinguish between the semantic notion of inclusion (⊆), and the
syntactic notion of subsumption (⊑). Then A ⊑ B iff AI ⊆ BI, where I
is an interpretation function, see [10].
3)
C ⊑ dom(P) ∈ C – a class C is a subset of the
domain of P, i.e., P is a total (not-null) on C
(x, rdf:type, C) ⇒ ∃v.(x, P, v).
4)
rng(P) ⊑ C ∈ C – the range of P is a subset of a
class C, i.e., P references objects in C
(x, P, x′) ⇒ (x′, rdf:type, C).
B. Transformation of RDBs to RKBs
Each RDB DBi, depicted in Figure 1, can be translated into
an RKB K = (Si, Ci, Ai), where Si and Ci, for i = 1, 2, 3, can
be created from S and C in Figure 4 by appropriate extension
of the property names and class names with postﬁxes ’1’,
’2’, and ’3’. Additionally, in S2 do not occur rules involving
Y ear2, and in S3 are not rules containing Univ3.
S = {dom(PapId) ⊑ Paper,
dom(Title) ⊑ Paper,
dom(Y ear) ⊑ Paper,
dom(Name) ⊑ Author,
dom(Univ) ⊑ Author,
dom(APapId) ⊑ Author,
(funct PapId−), (funct Title−)}.
C = {Paper ⊑ dom(PapId), Paper ⊑ dom(Y ear),
Author ⊑ dom(Name), rng(APapId) = Paper}.
Figure 4.
Standard TBox axioms (S) and TBox ic-axioms (C) corresponding
to schemas of RDBs in Figure 1. Names should be appropriately extended
with postﬁxes ’1’, ’2’, and ’3’.
Then we obtain the following RKBs, Ki = τ(DBi), i =
1, 2, 3, where τ denotes the translation operator from RDBs
into RKBs:
1)
τ(DB1) = K1 = (S1, C1, A1), where:
A1 = ∅.
2)
τ(DB2) = K2 = (S2, C2, A2), where:
A2 = {(x1, PapId2, p1),
(x1, Title2, KBs),
(x2, Name2, John),
(x2, Univ2, NY ),
(x2, APapId2, x1),
(x3, Name2, Ann),
(x3, APapId2, x1)}.
3)
τ(DB3) = K3 = (S3, C3, A3), where:
A3 = {(y1, PapId3, p1),
(y1, Title3, KBs),
(y1, Y ear3, 2014),
(y2, Name3, Ann),
(y2, APapId3, y1)}.
A set A of ABox assertions arises from an instance of
relational database in the result of the translation performed
by Algorithm 1.
In Algorithm 1, for each relation symbol R and each
attribute A ∈ att(R):
81
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

Algorithm 1 Creating ABox assertions
Input:
An RDB (R, IC, I), and an empty ABox A.
Output:
ABox assertions in A representing I.
for each R(t) ∈ I
x := a fresh labeled null in ∆Var
UR,t := {A ∈ att(R) | t.A ̸= NULL}
if UR,t = ∅ then
A := A ∪ {(x, rdf:type, CR)}
else
for each A ∈ UR,t
if FKey(R, A, R′, A′) ∈ IC and
exists x′ such that (x′, PA′, t.A) ∈ A then
A := A ∪ {(x, PA, x′)}
else
A := A ∪ {(x, PA, t.A)}
end
a)
a fresh labeled null x is selected from ∆Var for each
tuple t in an instance of R;
b)
for each A ∈ att(R) if t.A = a ̸= NULL and A is not
a foreign key in R, the triple (x, PA, a) is inserted
into A; so, ﬁelds with NULL values are omitted;
c)
if A is a foreign key in R, i.e., FKey(R, A, R′, A′) ∈
IC, and t.A = a, then the triple (x, PA, x′) is in-
serted into A, where x′ is such that (x′, PA′, a) ∈ A;
d)
if for each attribute A ∈ att(R), t.A = NULL then
(x, rdf:type, CR) is inserted into A.
IV.
P2P KNOWLEDGE INTEGRATION
Processing a query in a peer-to-peer environment is pre-
sented in Algorithm 2. In general, the algorithm is self-
explaining. However, some procedures will be discussed
deeply later on, namely:
•
margeAnswers(curPeer, query) – merge all an-
swers to query gathered in curPeer;
•
canDiscover(curPeer, query)
–
decide
whether
some missing values in the answer to query can be
discovered using the whole RKB stored in curPeer;
•
discoverUsingRKB(curPeer, query)
–
discover
missing values in the answer to query, using the
whole RKB in curPeer.
We consider conjunctive queries, which are conjunctions
of equalities of the form P = a, where P is a property and a
is a constant.
By Triple(x, p, v) we denote a triple that either is in A or
can be deduced from A by means of S (in the current peer’s
RKB, K = (S, C, A)). An answer to P = a consists of all
triples determined by the following recursive datalog program:
Answer(x, p, v) ← Triple(x, p, v), p = ”P”, v = ”a”
Answer(x, p, v) ← Answer(x, , ), Triple(x, p, v)
Answer(x, p, v) ← Answer( , , x), Triple(x, p, v)
The answer encompasses all triples, which describe an object
x with the value a of property P, all other properties of x,
and triples connected with x by means of references.
Further on, we will use i instead of Peeri, and we assume
the following denotations:
Algorithm 2 Processing a query in a peer
Input:
Set of peers with local RKBs. A peer is
connected with its partners by means of mappings
between signatures of RKBs.
query - a query against a current peer.
Output:
Answer to the query containing local answer
and answers returned by all peer’s partners.
for each srcPeer in partnersOf(curPeer) {
query = rewriteQuery(curPeer, srcPeer, query);
▷ query is rewritten using the mapping from curPeer to srcPeer
sendQuery(curPeer, srcPeer, query);
▷ query is sent from curPeer to srcPeer
}
for each srcPeer in partnersOf(curPeer) {
answer = answer ∪
transformAnswer(curPeer, srcPeer, query);
▷ answer to query from srcPeer is gathered in curPeer
}
answer = margeAnswers(curPeer, query);
▷ all answers to query are merged in curPeer
if canDiscover(curPeer, query) then {
answer = discoverUsingRKB(curPeer, query);
▷ curPeer’s RKB is used to discover missing values
▷ in the answer to query
}
1)
{i1, . . . , in} – a set of partners of a peer i;
2)
Mk,i – a mapping between signatures Σk and Σi of
RKBs stored in peers k and i, respectively;
3)
Mk,i(ansk(q)) – the transformation of an answer
ansk(q) speciﬁed by a mapping Mk,i.
Then the answer ansi(q) is obtained in the following steps:
Step 1. The answer q(i), i.e., the local answer to q w.r.t.
the current RKB is returned
ansi(q) = q(i).
Step 2. Answers of all i’s partners are added to ansi(q)
ansi(q) = ansi(q) ∪ {Mk,i(ansk(q)) | k ∈ {i1, . . . , in}}.
Step 3. Axioms in Si ∪ Ci are used to deduce all possible
facts in ansi(q)
ansi(q) = ansi(q) ∪ Si ∪ Ci =
{(x, p, v) | ansi(q) ∪ Si ∪ Ci ⊢ (x, p, v)}.
Let us focus on the merge operation in Peer3 – see the
merging strategy (5) in Section II applied to RKBs – we have:
Step 1 :
ans3(q) = ∅;
Step 2 :
ans3(q) = ans3(q) ∪ M23(ans2(q)) =
{(x1, PapId3, p1), (x1, Title3, KBs),
(x2, Name3, John), (x2, APapId3, x1)};
Step 3 :
ans3(q) = ans3(q) ∪ S3 ∪ C3 =
{(x1, PapId3, p1), (x1, Title3, KBs),
(x2, Name3, John), (x2, APapId3, x1),
(a)
(x1, rdf:type, Paper3),
(b)
(x2, rdf:type, Author3),
(c)
(x1, Y ear3, x3)}.
Triples (a) and (b) were deduced using dom(Title3) ⊑
Paper3 ∈ S3, and dom(Name3) ⊑ Author3 ∈ S3. Triple
82
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

(c) was deduced by application of the axiom Paper3 ⊑
dom(Y ear3) ∈ C3 to the triple (x1, rdf:type, Paper3). Note
that x3 is a ”fresh” labeled null in ∆V ar.
Now, the question is whether the missing value represented
by x3 can be discovered referring to the whole RKB K3. To
this order we can proceed as follows:
{(x1, Title3, KBs), (x1, Y ear3, x3)} ⊆ ans3(q),
{(y1, Title3, KBs), (y1, Y ear3, 2014)} ⊆ A3.
Since Title3 is unique in A3 ∪ ans3(q), which is stated by
the axiom (funct Title3−) ∈ S3 , we have x1 = y1. Now
we can apply the axiom (funct Y ear3) ∈ S3 to the set
{(y1, Y ear3, 2014), (y1, Y ear3, x3)} ⊆ A3 ∪ ans3(q).
From functionality of Year3, we have x3 = 2014. In this way
the missing value represented by x3 has been discovered.
Now, we can describe the process of discovering missing
values more precisely. Proposition 4.2 formulates the neces-
sary condition for the possibility of success in the discovery
process.
Deﬁnition 4.1: Let a triple (x, P, x′) be in an a set ans(q)
of triples constituting an answer to a query q. We say that x′
is a missing value of P if there is not any triple in ans(q)
whose ﬁrst component (the subject) is x′.
It means that a labeled null x′ in a triple (x, P, x′) represents a
missing value if the property P is not interpreted as a reference.
Proposition 4.2: Let P occur in a query q issued against a
peer, K = (S, C, A) be an RKB in this peer, and ans(q) be a
result of merging all partial answers returned to this peer. Let
a triple (x, P2, x′) ∈ ans(q), where x′ is a missing value of
P2. The necessary condition for discovering the value of x′ is:
(c1)
there is a triple (x, P1, a) ∈ ans(q), P1 ̸= P, and
(c2)
P1 is unique in its domain, i.e., (funct P1
−) ∈ S.
Proof: Note that the given condition is a necessary
condition.
1)
Let (c1) and (c2) be true. Assume that the following
two triples: (y, P1, a) and (y, P2, b) are in A. Then,
from the uniqueness of P1 it follows that y = x, and
from functionality of P2 w obtain x′ = b. So, b is the
discovered value of x′.
2)
Let P1 = P and (c2) hold. Because ans(q) contains
also the answer to q returned by K then the triple
(y, P1, a) (mentioned in 1)) occurs either in both A
and ans(q), or in neither of them. Thus, to discover
the missing value of x′ we can restrict ourselves only
to ans(q).
3)
Now, let (c1) holds and (c2) is not true. Then the
equality y = x, considered in 1) can not be deduced,
and the discovering process fails.
Thus, the thesis of the proposition holds.
V.
CONCLUSIONS AND FUTURE WORK
We discussed the problem of aswering queries issued in
a knowledge integration systems in P2P architecture. In such
a system, there are many autonomous services (peers), which
collaborates in the process of producing answers to queries.
The system is ﬂexible and peers can enter and leave the system
dynamically. A peer has a knowledge base and while entering
the system it establishes semantic relationships between the
signature of its knowledge base and signatures of some knowl-
edge bases already belonging to the system (its partners). A
query posed against a peer is propagated to its partners along
semantic paths deﬁned by mapping, those partners propagate
the query to their partners, etc. Answers to the query ﬂow
back in the opposite directions. The target peer merge the
answers producing the expected answer. In this merge either
only answers are taken into account or also the whole RKB
stored in the peer can be involved. This inﬂuence the quality
(completeness) of the answer as well as the efﬁciency of the
query answering process. We have shown how one can control
these factors of the knowledge integration system. In particular,
we discussed when the involvement of the whole RKB is useful
from the so-called ”discovery of missing values” point of view.
The proper decision signiﬁcantly inﬂuence both the quality of
the answer as well as efﬁciency of processing. The discussed
strategy was inspired by the SixP2P system originally designed
for integrating XML data [18] [19]. The future extension of the
implementation is intended to capture also semantic-oriented
repositories, such as relational knowledge bases organized in
a form of RDF triples or OWL speciﬁcations.
ACKNOWLEDGMENT
This research has been supported by Polish Ministry of
Science and Higher Education under grant 04/45/DSPB/0122.
REFERENCES
[1]
M. Arenas, E. Botoeva, and D. Calvanese, “Knowledge base exchange,”
in 24th International Workshop on Description Logics (DL 2011), 2011,
pp. 1–11.
[2]
D. Calvanese, G. Giacomo, D. Lembo, M. Lenzerini, and R. Rosati,
“Tractable Reasoning and Efﬁcient Query Answering in Description
Logics: The DL-Lite Family,” J. Autom. Reason., vol. 39, no. 3, 2007,
pp. 385–429.
[3]
J. Sequeda, S. H. Tirmizi, ´O. Corcho, and D. P. Miranker, “Survey
of directly mapping SQL databases to the Semantic Web,” Knowledge
Eng. Review, vol. 26, no. 4, 2011, pp. 445–486.
[4]
J. Sequeda, M. Arenas, and D. P. Miranker, “On Directly Mapping
Relational Databases to RDF and OWL (Extended Version),” CoRR,
vol. abs/1202.3667, 2012, pp. 1–17.
[5]
M. Arenas, A. Bertails, E. Prud’hommeaux, and J. Sequeda, “A Direct
Mapping of Relational Data to RDF,” 2012, http://www.w3.org/TR/
rdb-direct-mapping, [retrieved: May, 2014].
[6]
T. Pankowski, “Reasoning About Consistency Of Relational Knowledge
Bases,” in 8th International Multi-Conference on Computing in the
Global Information Technology, ICCGI 2013, July 21 - 26, 2013 - Nice,
France.
IARIA, 2013, pp. 283–288.
[7]
B. Motik, I. Horrocks, and U. Sattler, “Bridging the gap between OWL
and relational databases,” Journal of Web Semantics, vol. 7, no. 2, 2009,
pp. 74–89.
[8]
S. Abiteboul, R. Hull, and V. Vianu, Foundations of Databases.
Read-
ing, Massachusetts: Addison-Wesley, 1995.
[9]
R. Reiter, “Towards a logical reconstruction of relational database
theory,” in On Conceptual Modelling. Perspectives from Artiﬁcial
Intelligence, Databases, and programming Languages, 1982, pp. 191–
233.
[10]
F. Baader, D. Calvanese, D. McGuinness, D. Nardi, and P. Petel-
Schneider, Eds., The Description Logic Handbook: Theory, Implemen-
tation and Applications.
Cambridge University Press, 2003.
83
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

[11]
OWL 2 Web Ontology Language Proﬁles, 2009, www.w3.org/TR/
owl2-proﬁles, [retrieved: May, 2014].
[12]
D. Calvanese, E. Damaggio, G. D. Giacomo, M. Lenzerini, and
R. Rosati, “Semantic data integration in P2P systems,” in DBISP2P-
2003, LNCS 2944, Springer, 2004, pp. 77–90.
[13]
F. Buccafurri and G. Lax, “Enabling Selective Flooding to Reduce P2P
Trafﬁc,” in OTM Conferences, LNCS 4803, Springer, 2007, pp. 188–
205.
[14]
G. Koloniari and E. Pitoura, “Peer-to-peer management of XML data:
issues and research challenges,” SIGMOD Record, vol. 34, no. 2, 2005,
pp. 6–17.
[15]
I. Tatarinov, et al., “The Piazza peer data management project,” SIG-
MOD Record, vol. 32, no. 3, 2003, pp. 47–52.
[16]
B. C. Ooi, Y. Shu, , and K.-L. Tan, “Relational data sharing in peer-
based data management systems,” SIGMOD Record, vol. 32, no. 3,
2003, pp. 59–64.
[17]
A. Fuxman, P. G. Kolaitis, R. J. Miller, and W. C. Tan, “Peer data
exchange,” ACM Trans. Database Syst, vol. 31, no. 4, 2006, pp. 1454–
1498.
[18]
G. Brzykcy, J. Bartoszek, and T. Pankowski, “Schema Mappings and
Agents’ Actions in P2P Data Integration System,” Journal of Universal
Computer Science, vol. 14, no. 7, 2008, pp. 1048–1060.
[19]
T. Pankowski, “Query propagation in a P2P data integration system in
the presence of schema constraints,” in Data Management in Grid and
P2P Systems DEXA/Globe’08, LNCS 5187, 2008, pp. 46–57.
[20]
Resource Description Framework (RDF) Model and Syntax Speciﬁca-
tion, 1999, www.w3.org/TR/PR-rdf-syntax/, [retrieved: May, 2014].
84
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-346-9
ICCGI 2014 : The Ninth International Multi-Conference on Computing in the Global Information Technology

