On Machine Integers and Arithmetic
Pavel Loskot
ZJU-UIUC Institute
Haining, China
e-mail: pavelloskot@intl.zju.edu.cn
Abstract—All signal and data processing is performed on
computing machines. However, the computing efﬁciency requires
that numbers are represented in a ﬁnite memory space. It is
claimed that all such numbers can be considered to be integers,
and that decimal point has purely syntactical meaning to align
numbers in arithmetic operations. This subtle, but fundamental
observation seems to have been ignored so far. As an introductory
exploration of integer arithmetic, this paper introduces a dual
modulo operator to select digits in string representations of
machine numbers. Moreover, it is proposed that natural integers
offset by a real-valued constant satisfy Peano axioms. The Fermat
last theorem is then considered as an example of Diophantine
equation. It is shown how it can be modiﬁed to allow the solutions
to exist. A Fermat metric is newly introduced to deﬁne distances
between integers to allow their partitioning into subsets. These
results point at the importance of investigating integer arithmetic,
integer algebra, and integer analysis in designing and modeling
computing systems.
Keywords—dual modulo arithmetic; Fermat last theorem; Fer-
mat metric; natural numbers.
I. INTRODUCTION
Numbers are abstract mathematical objects that can also
carry semantic meaning of quantity. The former leads to rich
axiomatic algebraic systems, and the latter enables performing
arithmetic operations in computing problems. Since computing
machines have limited resources, and must execute numerical
algorithms in a time and memory efﬁcient manner, they have
to represent numbers as constant size objects. This limits the
largest and the smallest number values as well as precision,
which can be considered. Therefore, any algorithm described
or implemented in a programming language can only compute
numbers from a ﬁnite set, N = {N1 < N2 < ...}, such that,
∀i : −∞ < inf(N ) ≤ Ni ≤ sup(N ) < ∞.
(1)
Thus, two machine numbers, Ni, and, Nj, can be compared,
i.e., ordered, and the difference, mini̸=j |Ni − Nj| = ε0, repre-
sents the precision. The set, N , is necessarily computable [1].
Most machine number systems use ﬂoating point and ﬁxed
point number representations. These representations including
basic arithmetic operations are precisely deﬁned by the IEEE
754 standard [2]. They enable efﬁcient utilization of hardware
and software resources to achieve the time and space efﬁciency
in implementing computing algorithms. Some languages (e.g.,
Python) support inﬁnite-precision integer arithmetic, or per-
form computations at the user-deﬁned precision (e.g., Mathe-
matica). The GNU library [3] is a popular and efﬁcient imple-
mentation in C programming language of the multi-precision
arithmetic for integer and ﬂoating-point numbers; this library
is also used in several commercial software products (e.g.,
Mathematica and Maple). The smallest and the largest integers
and single and double precision ﬂoating point numbers are
deﬁned in Matlab toolbox, Elementary Matrices, and in the C
standard libraries, limits.h and ﬂoat.h.
The algorithms described in various programming languages
represent numbers as strings of digits in a given basis. In
particular, the number, N ∈ N , in basis, B, is represented as,
N =
imax
∑
i=imin
Di ×Bi
↔
DimaxDimax−1 ···D1D0 ...D−1 ···Dimin
(2)
where the digits, Di ∈ {0,1,...,9,A,B,C,...B − 1}, and the
orders, imin ≤ 0 ≤ imax. It is customary to place decimal point
between the digits D0 and D−1, which divides the digits into
the integral and the fractional part, respectively. More impor-
tantly, the decimal point allows aligning digits of numbers
when performing arithmetic operations and comparisons.
The most common bases are decimal (B = 10), hexadecimal
(B = 16), and binary (B = 2). However, internally, the numbers
are stored much more efﬁciently in a byte-size basis, i.e.,
B = 28×#bytes−1, with one bit reserved for the sign. The total
number of bytes used for each number is usually ﬁxed for
different number classes (types) such as short and long inte-
gers, and single and double precision ﬂoating point numbers.
The conversions between the string notation and the internal
representation are performed automatically by compilers.
The textbook [2] provides a comprehensive overview of
the number systems used on computers. The computability
of functions of natural numbers is established in [4]. The mis-
match between exact mathematical description and practical
implementation of algorithms with approximate number rep-
resentations has been studied in [5] including the methods how
to mitigate such a discrepancy. The construction of large-scale
real numbers, which are suitable for software implementations
is considered in [6]. Binary approximations of real-numbers
are investigated in [7]. Other representations of real numbers
such as binary expansion, Dedekind cut and Cauchy sequence
are compared in [1]. The p-adic number systems allow deﬁn-
ing real-numbers as an arithmetic of rational numbers [8].
Logical statements involving comparisons of real-numbers are
evaluated in satisﬁability modulo theories [9]. The article [10]
conclusively argues that a ﬁnite precision is usually sufﬁcient
in practical engineering applications. Many number-theoretic
theorems and conjectures can be found in [11].
63
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-057-5
SIGNAL 2023 : The Eighth International Conference on Advances in Signal, Image and Video Processing

In this paper, it is argued that the number systems commonly
used on computers can be assumed to be integer-valued,
which also includes single and double precision ﬂoating point
numbers and the corresponding arithmetic operations. Con-
sequently, computing machines are inherently governed by
integer algebras and arithmetic. The paper contributions are
formulated as four claims and one proposition. In particular,
in Section II, dual modulo operator is introduced to select
digits in string representations of numbers. It can be exploited
to deﬁne equivalences between numbers in integer arithmetic.
In addition, it is proposed that natural numbers can be offset
by a real-valued constant, and still be considered as being
integers. In Section III, several modiﬁcations of Fermat last
theorem (FLT) are devised to allow the solutions to exist. A
Fermat metric is newly deﬁned, which is then used to compute
distances between natural numbers, and to divide the numbers
into subsets. The paper is concluded in Section IV.
II. MACHINE INTEGERS AND ARITHMETIC
Constraining machine computations to numbers, N , has
several fundamental consequences. First, the results of arith-
metic operations can overﬂow the limits, inf(N ), or, sup(N ).
Second, the results of arithmetic operations can underﬂow the
precision, ε0, so the results may have to be truncated, rounded,
or otherwise approximated. Third, the decimal point to align
numbers can be arbitrarily placed in-between any digits as
long as the placement is consistent in the number system and
arithmetic used. This is formalized as the following claim.
Claim 1. The machine numbers allocated a predeﬁned mem-
ory space are integers, N , isomorphic to a ﬁnite set of ﬁnite
integers, Z = {...,−1,0,+1,...}.
The important consequence is that (without a formal proof)
any machine arithmetic is isomorphic to integer arithmetic.
However, implementing such integer arithmetic at large scale
and precision to be efﬁcient and also error-free is non-trivial.
The memory allocated by compilers of programming lan-
guages allows adding only a ﬁnite number of digits before and
after a decimal point. If the numbers are padded by zero-digits
from both ends, all numbers are represented by strings of the
same length, and the decimal point becomes a hypothetical
construct. The non-zero digits at the right end of the number
string represent the precision (resolution), whereas the ﬁrst
non-zero digits from the left represent the scale.
The algorithms usually contain many logical statements
(predicates). These statements involve comparisons of numer-
ical values. The two integers are said to be exactly equal,
provided that all digits in their string representations are the
same. The exact comparison can be rather restrictive in some
applications, where the differences in scale and precision
could be or must be tolerated. Speciﬁcally, if the differences
are tolerated in precision (the right-end sub-strings), it is
equivalent to comparing quantized numbers. If the differences
are tolerated at scale (the left-end sub-strings), it is equivalent
to comparing periodically repeated values.
Mathematically, removing the right-end or the left-end sub-
strings from the string representations of numbers can be
expressed by a canonical modulo operator. In particular, for
any integer a, and any positive integer b, let, (a mod b) =
(|a| mod b) ∈ {0,1,...,b−1}, to be a reminder after the inte-
ger division of a by b. Note that this can be readily extended to
real numbers as, 0 ≤ (a mod b) = (|a| mod b) < b, assuming a
real division of, a ∈ R , by integer, b. Then, the numbers, a1,
and, a2, are said to be equivalent in a sense of congruence,
provided that, a1 ≡ a2 (modb). Both equality (indicated by
symbol, =) and equivalence (indicated by symbol, ≡) satisfy
axiomatic properties of reﬂexivity, symmetry, and transitivity,
and the equality implies equivalence.
If the machine numbers, Ni = ∑L−1
i=0 DiBi, are represented by
strings of L digits in some basis B, then the ﬁrst L1 digits and
the last L2 digits, (L1 +L2) < L, can be zeroed by applying a
dual modulo operator introduced next.
Deﬁnition 1. The dual modulo operator has two parameters,
m1, and, m2, and it is deﬁned as the difference,
Ni Mod(m1,m2) = (Ni mod m1)−(Ni mod m2)
= 0···0
| {z }
L1
DL−L1−1 ···DL2+1DL2 0···0
| {z }
L2
.
(3)
where m1 = BL−L1, and m2 = BL2.
Modular arithmetic with dual modulo operator has similar
properties as the arithmetic involving canonical modulo oper-
ator. In particular, given integers a, b, m1, and m2, then,
a Mod(0,m2) = a−(a mod m2)
a Mod(m1,1) = a mod m1
a Mod(m1,m1) = 0.
(4)
Furthermore, it is straightforward to prove that,
a+b ≡ a Mod(m1,m2)+b Mod(m1,m2) (Mod(m1,m2))
a−b ≡ a Mod(m1,m2)−b Mod(m1,m2) (Mod(m1,m2))
a·b ≡ a Mod(m1,m2)·b Mod(m1,m2) (Mod(m1,m2)).
(5)
However, in general, for integer division with a reminder,
a/b ̸≡ a Mod(m1,m2)/b Mod(m1,m2) (Mod(m1,m2)).
(6)
The Chinese reminder theorem [11] can be restated for dual
modulo operator as follows. If m11 and m12 are co-prime, and,
Ni ≡ a1 (Mod(m11,m2))
Ni ≡ a2 (Mod(m12,m2))
(7)
for some integers, Ni, and, m2, then there is a unique integer,
a, such that,
Ni ≡ a (Mod(m11m12,m2)).
(8)
The proof is based on the property that, if Ni ≡ a (mod m1),
then also, Ni ≡ a (Mod(m1,m2)).
Furthermore, it is useful to consider how the machine
integers used in algorithms are approximations of inﬁnite
precision real-numbers obtained from mathematical analysis.
64
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-057-5
SIGNAL 2023 : The Eighth International Conference on Advances in Signal, Image and Video Processing

The dual modulo operator deﬁned in (3) produces a ﬁnite-
size integer, x Mod(m1,m2), from a real number, x ∈ R .
This introduces a periodicity due to truncation from the left
(speciﬁed by the parameter, m1), and the quantization due to
truncation from the right (speciﬁed by the parameter, m2).
It is also useful to deﬁne countably inﬁnite integer sets,
˜Nx = {x,x+1,x+2,...}
(9)
parameterized by ﬁnite constants, x ∈ R , so that, ˜N0, is
the set of natural numbers. Such integer sets can provide
exact solutions to some integer (Diophantine) problems, which
otherwise do not have any solution. More importantly, for all
ﬁnite x, the integers, ˜Nx, satisfy Peano axioms [11].
III. CASE STUDY: FLT PROBLEMS
The FLT states that there are no positive integers a, b, c,
and n > 2, such that, an +bn = cn. This has been ﬁrst veriﬁed
numerically until the proof was obtained only recently [11].
Note also that, |an +bn −cn| ≤ 1, has a trivial solution, a = 1,
and, b = c, for ∀n > 1. The Fermat Number Transform (FNT)
resembles Discrete Fourier Transform, however, the former
assumes the sums modulo a prime [12].
More importantly, the original formulation of FLT can be
modiﬁed to allow the solutions to exist.
Claim 2. For every n, there exist inﬁnitely many natural
integers a, b, c, m1 and m2 satisfying the congruence,
an +bn ≡ cn (Mod(m1,m2)).
(10)
For example, assuming the ﬁrst 100 natural numbers as
strings of l = 9 digits in the number basis, B = 8, and, B = 10,
the total number of solutions, nl, and, nr, respectively, of (10)
for the ﬁrst l1 digits and the last l2 = l − l1 digits is given
in Table I. It can be observed that, always, nl > nr, since the
number strings often contain zeros at the left to make up the
given width, l.
TABLE I. The number of solutions of (10)
B = 8
B = 10
n = 3
n = 4
n = 3
n = 4
(l1,l2)
(3,6)
(4,5)
(3,6)
(4,5)
(3,6)
(4,5)
(3,6)
(4,5)
nl
69627
22278
5505
2318
1284
44532
10666
3622
nr
212
644
730
2076
198
207
230
596
Claim 3. For any integer, n ≥ 1, the equation,
an +bn = cn
(11)
has inﬁnitely many solutions among the integers, ∪x ˜Nx, for
speciﬁc real-values (from some set), x > 0.
Proof. Let c = y ∈ R , a = y − d1, and, b = y − d2, where d1
and d2 are arbitrarily chosen positive natural integers. Then,
for any n, the polynomial (11) has at least one real-valued
solution, y > max(d1,d2). Let d0 = ⌊y⌋ (ﬂoor function), so that
x = (y−d0) < 1. This deﬁnes the positive integers, c = d0 +x,
a = d0 −d1 +x, and b = d0 −d2 +x, from the set, ˜Nx.
Proposition 1. For any natural integer, n, there exists an
integer, m ≥ n, such that the expression,
m
∑
i=1
an
i = bn
(12)
is satisﬁed for a set of natural integers, {a1,a2,...,am}∪{b}.
The proof of Proposition 1 appears to be rather non-trivial,
except when n = 1 and n = 2 (Pythagorean theorem). However,
it is easy to ﬁnd examples satisfying the expression (12), e.g.,
32 +42 = 52 (m = n = 2)
33 +43 +53 = 63 (m = n = 3)
24 +24 +34 +44 +44 = 54 (m = n+1 = 5)
195 +435 +465 +475 +675 = 725 (m = n = 5).
(13)
In general, the sequence, an +bn, obtained by enumerating
all natural integers, a, and, b, becomes rapidly very sparse
as the exponent, n, is increased. Given n, it is easy to show
that the best approximation of (an + bn) by cn is obtained
when, c = ⌊(an +bn)1/n⌉ (rounding function). This motivates
the following Fermat metric.
Deﬁnition 2. The Fermat metric for positive numbers, a, and,
b, is computed as,
Fn(a,b) = an +bn −⌊(an +bn)1/n⌉n
(14)
where n = 2,3,... is a natural number, and always, F1(a,b) =
0. The Fermat distance between the numbers, a, and, b, is the
absolute value of the Fermat metric, i.e.,
Dn(a,b) = |Fn(a,b)|.
(15)
The distribution of Fermat metric values by enumerating
all pairs of natural integers up to 105 are shown in Figure 1
for n = 2 and n = 3, respectively. It can be observed that the
Fermat metric values are spread much more evenly when n =
2, and the distributions are asymmetric about 0.
-1000
-500
0
500
1000
0
5
10 5
(A)
-1000
-500
0
500
1000
0
5
10 5
(B)
Figure 1. The counts of Fermat metric values for all pairs of natural integers
up to 105, for the exponents n = 2 (A), and n = 3 (B).
65
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-057-5
SIGNAL 2023 : The Eighth International Conference on Advances in Signal, Image and Video Processing

The Fermat distance can be used to cluster natural numbers
into subsets. Figure 2 shows the dendrogram assuming the
distance, F2(a,b). The corresponding assignment of the ﬁrst
50 natural numbers into four subsets based on the distances,
F2, F3, F4, and F5 are shown in Figure 3.
 4 211117  1 1422  2 1518  3  5  7  6  9 20  8 1224131019162325
10
20
30
40
50
60
70
Figure 2. The dendrogram of natural numbers constructed assuming the
Fermat distance, F2(a,b), deﬁned in (15).
0
10
20
30
40
50
n=2
n=3
n=4
n=5
Clust. 1
Clust. 2
Clust. 3
Clust. 4
Figure 3. The ﬁrst 50 natural numbers partitioned into four clusters (subsets)
using the Fermat distances, Fn(a,b), for n = 2,3,4, and 5.
IV. DISCUSSION AND CONCLUSION
This paper investigated modular arithmetic and introduced
dual modulo operator under the premise that all machine num-
bers can be assumed to be integers, when they are pre-allocated
a ﬁxed space in a computer memory. This is the case with
ﬁxed point as well as ﬂoating point number representations.
The meaning of a decimal point is mainly syntactical to allow
aligning the operands in arithmetic operations. This leads to
another fundamental claim.
Claim 4. Any computing algorithm utilizing ﬁnite number
representations can be represented by a system of Diophantine
equations.
Hence, there is a large gap between mathematical descrip-
tion based on real analysis, and the actual implementation of
corresponding algorithms on computers [5].
Improving accuracy of machine numbers by p-adic rep-
resentations [8] and by Diophantine approximations [13] is
impractical, since the underlying arithmetic operations require
more time and more memory. More efﬁcient multi-precision
arithmetic is available as a C-library [3]. In many practical
applications, ﬁnite accuracy is often sufﬁcient [10]. On the
other hand, the full accuracy is required in cryptography [14].
The FLT can be modiﬁed to allow the solutions to exist. The
key ideas introduced in this paper are to deﬁne equivalences
between numbers assuming only a subset of digits in their
number string representations, and to consider sets of natural
numbers offset by real-valued constants. In addition, the
Fermat metric can be used to deﬁne distances between natural
and other numbers.
Future work can deﬁne and prove further properties of ma-
chine numbers and arithmetic, which are explicitly considered
to be integers. This can lead to more efﬁcient design of integer-
based models and architectures for large-scale computing ma-
chines, and improved approximations of real-valued systems.
ACKNOWLEDGMENT
This work was funded by a research grant from Zhejiang
University.
REFERENCES
[1] X. Zheng and R. Rettinger, “Weak computability and representation of
reals,” Mathematical Logic Quarterly, vol. 50, no. 4–5, pp. 431–442,
Sep. 2004.
[2] R. T. Kneusel, Numbers and Computers, 2nd ed. Springer International
Publishing, Cham, Switzerland, 2017.
[3] T. Granlund, “The GNU multiple precision arithmetic library, GNU MP
6.2.1,” https://gmplib.org, Jan. 2020, accessed: 2023-01-30.
[4] M. Wrocłlawski, “Representations of natural numbers and computability
of various functions,” in Conference on Computability in Europe, 2019,
pp. 298–309.
[5] R. Krebbers and B. Spitters, “Type classes for efﬁcient exact real
arithmetic in Coq,” Logical Methods in Computer Science, vol. 9, no.
1:01, pp. 1–27, Feb. 2013.
[6] R. O’Connor, “A monadic, functional implementation of real numbers,”
Mathematical Structures in Computer Science, vol. 17, no. 1, pp. 129–
159, 2007.
[7] J. van der Hoeven, “Computations with effective real numbers,” Theo-
retical Computer Science, vol. 351, pp. 52–60, 2006.
[8] F. Q. Gouvˆea, p-adic Numbers: An Introduction, 3rd ed.
Springer,
Cham, Switzerland, 2020.
[9] G. Kremer, F. Corzilius, and E. ´Abrah´am, “A generalised branch-and-
bound approach and its application in SAT modulo nonlinear integer
arithmetic,” in Computer Algebra in Scientiﬁc Computing, vol. 9890,
2016, pp. 315–335.
[10] NASA/JPL
Edu,
“How
many
decimals
of
Pi
do
we
really
need?”
https://www.jpl.nasa.gov/edu/news/2016/3/16/
how-many-decimals-of-pi-do-we-really-need,
Oct. 2022, accesssed:
2023-01-30.
[11] T. Gowers, J. Barrow-Green, and I. Leader, The Princeton Companion
to Mathematics. Princeton University Press, Princeton, NJ, USA, 2008.
[12] M. Kˇri´ıˇzek, , F. Luca, and L. Somer, 17 Lectures on Fermat Numbers:
From Number Theory to Geometry.
Springer New York, USA, 2001,
ch. Fermat Number Transform and Other Applications, pp. 165–186.
[13] B. Church, “Diophantine approximation and transcendence theory,” Apr.
2019, lecture Notes.
[14] J. Hoffstein, J. Pipher, and J. H. Silverman, An Introduction to Mathe-
matical Cryptography, 2nd ed.
Springer, New York, NY, USA, 2014.
66
Copyright (c) IARIA, 2023.     ISBN:  978-1-68558-057-5
SIGNAL 2023 : The Eighth International Conference on Advances in Signal, Image and Video Processing

