BSPL: A Language to Specify and Compose
Fine-grained Information Flow Policies
St´ephane Geller, Val´erie Viet Triem Tong, Ludovic M´e
Team Cidre
SUPELEC
Rennes, France
Email: stephane.geller@supelec.fr, valerie.viettriemtong@supelec.fr, ludovic.me@supelec.fr
Abstract—We tackle the problem of operating systems secu-
rity. The seriousness of the vulnerabilities in today’s software
underlines the importance of using a monitor at the operating
system level to check the legality of operations executed by
(un)trusted software. Information ﬂow control is one way to track
the propagation of information in order to raise an alert when
a suspicious ﬂow, consequence of an attack, occurs. We propose
here BSPL, a language to specify a ﬁne-grained information ﬂow
policy. We present how BSPL enables to precisely specify the
expected behavior of applications relatively to sensitive pieces of
information. We also propose a way to compose such information
ﬂow policies.
Keywords—Information ﬂow policies, speciﬁcation language,
composition of information ﬂow policies
I.
INTRODUCTION
Information ﬂows characterize all the operations on the
system resulting in data movements from one location to
another, such as when a process reads or writes to a ﬁle.
Over the past decade, many worksd [1], [2], [3], [4],
[5] have focused on providing strong information security
guarantees by tracking and/or controlling information ﬂows.
Basically, information ﬂow tracking identiﬁes sensitive data
with a dedicated mark called taint, label or tag. The marks are
propagated along the ﬂow to taint objects in the system and a
monitor uses the marks to check the legality of the information
ﬂows, with respect to a previously deﬁned ”information ﬂow
policy”.
We believe that there is a need for a language to pre-
cisely deﬁne such policies, as proposed by Efstathopoulos and
Kohler, who were the ﬁrst to present such a language [6].
In this paper, we focus on the Blare monitor [7]. Blare
monitors information ﬂows at the operating system level. It
uses two marks (called tags) associated with any container of
information in the operating system. This monitor has shown to
be helpful to detect attacks, especially those that generate data
leakage [8]. Though, as with other existing monitors, Blare
suffers from a major drawback: the information ﬂow policy
that manages the monitor is either a toy policy [2], set by
hand [9], or automatically computed from an access control
policy [8].
In this article, we introduce the Blare Security Policy
Language (BSPL). This language has been created to be a
convenient way to specify an information ﬂow security policy,
in particular in contexts where several types of data coexist in
the same system, like on a smartphone. BSPL allows a high
level expression of the policy while keeping it simple and clear.
A BSPL policy can be used to conﬁgure an information ﬂow
monitor (in our case Blare) to detect illegal read or write
accesses to sensitive information by any malicious software.
On smartphones, the global information ﬂow policy associ-
ated to the system can be viewed as a composition of multiple
smaller policies provided by the application developers, the
administrators and the users. This motivates our work around
the composition of policies that is also presented in this paper.
The two major contributions of this paper are, thus: (1)
the BSPL language and (2) the composition deﬁnition for
policies written in this language. We also propose a consistency
property for such information ﬂow policies and prove that a
policy constructed using BSPL is consistent and it is easy to
prove that the composition of consistent policies is consistent.
The remainder of this paper is organized as follows:
Section II presents the related work. Section III introduces
our underlying model of information ﬂow. In Section IV,
we present the BSPL syntax and semantics, and Section
V
shows how to compose policies. Lastly, before concluding the
paper, in Section VI, we illustrate the use of BSPL to express
information ﬂow policies.
II.
RELATED WORK
As far as we know, the work most related to our approach
has been proposed by Efstathopoulos and Kohler [6]. They
proposes a policy description language where application de-
velopers can express their security requirements in terms of
communication relationships. They claim that concentrating
the policy speciﬁcation in one place makes policies easier to
write and reason about. They also provide a parser to translate
these communication relationships considered as high-level
policy to the equivalent Asbestos labels [10].
Unfortunately, they note that their language does not
capture the full expressiveness of the Asbestos labels. More
precisely, a process can be impacted by different policies but
the language does not permit the construction of a global
policy, which includes all these fragments of policy. In other
words, their language does not support the composition of dif-
ferent policies concerning the same process. Our composition
46
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-298-1
SECURWARE 2013 : The Seventh International Conference on Emerging Security Information, Systems and Technologies

mechanism could solve this type of problem. They also have
trouble inferring the high-level policy from the labels of the
system.
We want to pursue the efforts initiated in [6] to concentrate
the policy speciﬁcation in one place. However, contrarily to
what has been proposed by Efstathopoulos, our high-level
language allows such a centralized deﬁnition while being very
close to the actual labels managed by the Blare monitor.
Hence, it would be easy to rebuild the system global policy
in BSPL given the different labels found in that system.
In addition, we also propose a consistency property, which
permits the elimination of ill-formed information ﬂow policies.
In the following section, we detail the model of labels used
by the Blare monitor and thus describe the requirements for
our speciﬁcation language, BSPL.
III.
THE UNDERLYING MODEL OF INFORMATION FLOW
Blare is a model of information ﬂow created to accom-
plish mainly two objectives: (1) the tracking of the content
of the containers of the system and (2) the easy veriﬁcation
that this content respects our information ﬂow policy. To
accomplish these goals, we distinguish the containers from
their content, potentially composed of multiple pieces of
information depending on the time of the observation.
We separate containers of information into three categories:
PC denotes the set of persistent containers (typically ﬁles),
and Execute(X) (or shortly E) denotes the set of processes
executing a code in X. We also consider users as containers
of information. We use U to denote the set of users. In the
following we will thus use the notation C = PC ∪ U ∪ E to
deal with any container of information.
To differentiate between a piece of information which has
been executed (a running code) and a piece of information
which has not, we deﬁne two disjoint sets of meta-information
I and X to track these pieces of information. The elements of
the ﬁrst set correspond to non-executed pieces of information,
while those of the second set correspond to pieces of infor-
mation executed by processes. Once a piece of information
identiﬁed by a meta-information I is executed, the meta-
information used to track it will be changed thanks to the
function running : I → X. For instance, if app is an
application considered as sensitive, we attach i ∈ I to its code
viewed as a data stored in a ﬁle; once app is launched by a
process p we consider that p is running the code denoted by
x ∈ X such that x is equal to runnning(i). This distinction
permits to distinguish the policy associated to a code viewed
as data, and to the same code when it runs. The identiﬁers in
I and X are either deﬁned at the initialization of the model
or during the execution of the system if new content is added.
Any container existing in the operating system is charac-
terized with two tags: an information tag and a policy tag.
The information tag is a collection of elements of I ∪ X that
denotes the origins of the current content of the container (it
is the tag used to accomplish the objective (1)). The policy tag
is a set of elements of P(I ∪X) that denotes the information
ﬂow policy attached to the container (it is the tag used to
accomplish the objective (2)).
The information ﬂow policy deﬁnes for each of these
containers (let us remind that users are viewed as containers)
which data mixture they are allowed to contain. The informa-
tion ﬂow policy uses the function PC : C → P(P(I ∪ X))
as building block. This function deﬁnes the data mixture
allowed to ﬂow into any container of information. For instance,
PC(c) = {{i1, i2, x1}, {i1, i3, x1}} means that a process
executing the tainted program x1 is allowed to write into
the container c; it also means that c can either contain data
computed from the tainted data i1 and i2 or data computed
from i1 and i3.
When a process is launched during the execution, the value
of its policy tag depends on the process owner and the policy
tag attached to the code the process is currently running. More
precisely, let us consider a process pnew resulting from the
execution of the binary ﬁle bf by a process p. Let us also
consider that p has an information tag equal to Ip ⊆ I ∪ X
and p executes a binary ﬁle bf, which has an information
tag equal to Ibf ⊆ I ∪ X. The information tag Ip tells us
what information is transmitted (in the worst case) by p to
its child pnew. The information tag Ibf tells us which code
will be executed in pnew. The information tag of pnew is thus
equal to the union of the information tag of its father process
and the function running applied to the information tag of
the executed binary ﬁle bf: Ip ∪ running(Ibf). Its policy tag
Ppnew depends on the policy tag Pu ⊆ P(I∪X) of the process
owner u ∈ U and on the value of PC(Eexecute(running(i)))
for any i in Ibf. Pu is deﬁned by PC(u). Lastly, the policy tag
Ppnew is deﬁned by ⊓i∈Ibf \X PC(Eexecute(running(i)))⊓Pu
(A ⊓ B = {a ∩ b|a ∈ A, b ∈ B}).
The policy tag Pc of a container of information (whatever
its type is) represents the set of combinations of sensitive
pieces of information which can legally be found in the
container. The fact that the content of a container c is legal in
accordance with an information ﬂow policy can be veriﬁed by
checking if its information tag Ic is included in at least one
element of its policy tag Pc.
The function PC permits deﬁning which data mixture is
allowed to ﬂow into any type of containers of information. This
function implicitly deﬁnes a second function that associates
to sensitive pieces of information i their possible mixes and
locations. We denote this function PI∪X , its type is I ∪ X →
P(C × P(I ∪ X)). This function associates to any identiﬁer
of sensitive piece of information ix ∈ I ∪ X a set of pairs
(c, s) where c can be either a persistent container, a user or a
process and s is a set of identiﬁers of pieces of information. A
pair (c, s) ∈ P(I∪X)(ix) means that a data computed from the
piece of information ix is allowed to ﬂow into the container
(persistent, user or process) c mixed with any data computed
from any subset of pieces of information appearing in s.
We have proved in [11] that this model of information
ﬂows was complete: if a violation of the policy occurs, it
is detected. We can also prove that the model is sound.
Nevertheless, this proof of soundness is less relevant, as it
supposes that any information ﬂow can be observed. This “total
observability” is in practice impossible to obtain. This means
that the implementation of our model is not exempt of false
positives. Nevertheless, our experiments have shown that this
false positive rate is lower with a monitor implementing our
model than with more classical monitors.
47
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-298-1
SECURWARE 2013 : The Seventh International Conference on Emerging Security Information, Systems and Technologies

In previous works [2], [9], we have proposed constructing
an information ﬂow policy in specifying for each container
the list of data mixtures that the container is allowed to
contain. In other words, the deﬁnition of the policy was guided
by containers and we directly deﬁned the policy through
the speciﬁcation of PC. In this case, the function PI∪X is
deﬁned by reversing PC. We believe that it is interesting to
permit guiding the deﬁnition of an information ﬂow policy by
specifying where data mixtures are allowed to ﬂow and thus
in partially deﬁning the function PI∪X . BSPL offers such a
feature as it is detailed in the following section.
If we permit deﬁning an information ﬂow policy through
the deﬁnition (even partial) of the function PI∪X we may
face an inconsistency problem of the policy. Intuitively, an
information ﬂow policy is consistent if when a piece of
information is allowed to ﬂow into a container with a data
mixture, it is equivalent to two things : the concerned container
is also allowed to receive this data mixture and all the pieces of
information of the mixture are allowed to ﬂow in the container
with the same mixture. Deﬁnition 1 makes this notion clear.
Deﬁnition 1: An information ﬂow policy is consistent if
the following formulas are equivalent :
∀c ∈ C, ∀s ∈ P(I ∪ X),
∃ix ∈ s, (c, s \ {ix})
∈
PI∪X (ix)
(1)
∀ix ∈ s, (c, s \ {ix})
∈
PI∪X (ix)
(2)
s
∈
PC(c)
(3)
When a policy is consistent, we can express the two parts
of the policy in function of the other: PI∪X (ix) = {(c, I)|c ∈
C∧I∪{ix} ∈ PC(c)} and PC(c) = S
ix∈I∪X {I∪{ix}|(c, I) ∈
PI∪X (ix)}. An information ﬂow policy uniquely speciﬁed
through one of the two is necessarily consistent since the last
function is in this case entirely deﬁned by reversing.
In the following section, we propose a dedicated language,
BSPL, associated to this model.
IV.
THE BSPL LANGUAGE
A. BSPL Grammar
A Blare policy is basically composed of two elements:
the deﬁnition of sensitive data and their corresponding policy,
and the deﬁnition of containers and their corresponding policy.
The ﬁrst element on the policy is called Data policy
and deﬁnes the policy attached to sensitive data. Pieces of
information listed in this element belong to the user/the
application/the system that deﬁnes the current policy. These
pieces of information are thus considered as sensitive. This
element is composed of a sequence of element data (each one
characterizing a single piece of information, for example the
initial content of a ﬁle), which is composed of:
•
an element data_identification that permit
the exact characterization of the sensitive piece of
information (it gives its alias, its original container,
its owner, its type (executable (X) or not (I)), the
expected reaction of the monitor if it observes
an illegal information ﬂow: either it has to block the
incriminated information ﬂow or it has to raise an
alert. Lastly an element data_identification
has an attribute
case_of_unknown_containers that is helpful
for policy composition. This last attribute speciﬁes the
behaviour of the information identiﬁed above when
the policy has to be composed with another policy
that speciﬁes information ﬂows with this piece of
information. It can be either Ask for ask to the
owner of the piece of information (encouraged de-
fault value), AlwaysAccept (very permissive) or
NeverAccept (very protective ).
•
a list of elements can_flow each of them having
two attributes: into that denotes a container and
mixed_with that denotes a list of sets of identiﬁers
of sensitive data.
The attributes composing the element can_flow mean
that the sensitive data identiﬁed by the previous element
identification can be mixed with any set of pieces of
information listed in mixed_with in the container in the at-
tribute into. We can use the particular identiﬁer all_data,
which will mean all the possible sensitive data. The precise
semantics associated with the group Data policy is given in
Section IV-B.
The second element deﬁnes the information ﬂow policy
attached to containers of information and is called Contain-
ers policy. This element is composed of a list of element
container. An element container is deﬁned by:
•
an element container_identification
with
ﬁve attributes that permit the exact characteriza-
tion of the container (it gives an alias for the
container, its original location, its owner and its
type (ﬁle, process executing a code identiﬁed pre-
viously in data_policy) or user) , the expected
reaction of the monitor if it observes an ille-
gal information ﬂow and lastly a behaviour. Du-
ally to the case of unknown containers, an element
container_identification has an attribute
case_of_unknown_data, which speciﬁes the be-
haviour of the container identiﬁed above when the
policy has to be composed with another policy that
speciﬁes information ﬂows with this container. It can
be either Ask for ask to the owner of the container
(encouraged default value), AlwaysAccept (very
permissive) or NeverAccept (very protective).
•
an element can_receive composed of one at-
tribute: mixture_of_data, which indicates the
mixture of data allowed to ﬂow into the concerned
container: mixture_of_data has to be a list of list
of pieces of information separated with commas or it
can be simply all_data (all the possible sensitive
data).
In the next subsection, we describe the sense of the syntax
given in this section, i.e., the semantics of BSPL, using the
notations introduced in Section III.
48
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-298-1
SECURWARE 2013 : The Seventh International Conference on Emerging Security Information, Systems and Technologies

B. BSPL semantics
We deﬁne two tables TI∪X and TC. The ﬁrst table TI∪X
is used to store information permitting to characterize sensitive
data (their owners, their initial location, their type (executable
or not) and the reaction attached to an illegal ﬂow with the
data.. The second table TC is used to store the origin, the
owner and the reaction attached to a container deﬁned in the
policy.
The monitor refers to these tables when it detects an illegal
information ﬂow, since the expected reaction is stored in theses
tables. These tables will be used during the installation process
and will be helpful for the enforcement of the policy. These
tables can be deduced from the deﬁnition of PI∪X and PC.
The four rules given hereafter deﬁne the semantics of the
BSPL language.
V.
COMPOSITION OF POLICIES
In this section, we present how to compose two information
ﬂow policies designed by different owners of data and contain-
ers. We give a formula that permits to compute an information
ﬂow policy Pf resulting from the composition of two policies
P1 and P2 and we denote it by:
Pf = (Pf
Cf , Pf
If ∪Xf , Tf
Cf , Tf
If ∪Xf ) = P1 ⊕ P2 =
(P1
C1, P1
I1∪X1, T1
C1, T1
I1∪X1)) ⊕ (P2
C2, P2
I2∪X2, T2
C2, T2
I2∪X2)
The tables TC and TI∪X are used for the behaviour in case
of unknown containers/data and to extract the owners of the
containers/data and the authors of the policies. We suppose
here that data are uniquely identiﬁed (through their initial
location for instance) and that an identiﬁer only corresponds to
a piece of information. We also suppose that users, persistent
containers and processes are uniquely identiﬁed. The sensitive
non-executed pieces of information manipulated by Pf is
denoted by If and is equal to I1 ∪I2. Codes that will later be
executed by processes and that are considered as sensitive for
the policy Pf are X1 ∪ X2. Consequently (If ∪ Xf) is equal
to ((I1 ∪ I2) ∪ (X1 ∪ X2)).
In the same way, containers of information manipulated by
Pf are Cf = PCf∪Uf ∪ Execute(Xf) where users are Uf =
U1∪ U2, persistent containers are PCf = PC1∪PC2 and lastly
processes Execute(Xf) are Execute(X1) ∪ Execute(X2).
The ﬁnal tables are Tf
Cf = T1
C1 ∪ T2
C2 and Tf
If ∪Xf =
T1
I1∪X1 ∪ T1
I2∪X2.
We deﬁne the function information owner ownerl : If →
U (U is the set of users owning containers or data in one
of the two policies, we can build it with the ﬁeld owner of
the tables). ownerl(i) = Tf
If ∪Xf (i)3 (the third ﬁeld of the
table, the owner). We also deﬁne the function container owner
ownerc : Cf → U. ownerc(c) = Tf
Cf (c)3. The function
behaviour : If∪Cf → {AlwaysAccept; NeverAccept; Ask}
is used to access the ﬁeld behaviour of the tables. We deﬁne
the function authors, which returns the set of the authors of
Rule 1: construction of the data policy (PI∪X )
data_identification
= {
alias = al;
origin = or;
owner = own;
data_type = type;
reaction = reac;
case_of_unknown
_containers = beha; },
Jcan_flow
= {
into = c;
mixed_with_data = mix; }
can_flow
= {. . .
}K
if(al, , , , ) ̸∈ TI∪X
then TI∪X = TI∪X ∪ (al, or, own,
type, reac, beha);
for each can_flow element do
PI∪X (al) ← (c, mix)
∀ix ∈ mix PI∪X (ix) ← (c, (mix
∪{al}) \ {ix})
PC(c) ← PC(c) ∪ (mix ∪ {al})
done
Rule 2.1: Construction of the Container Policy (PC): User’s Case
container_identification
= {
alias = u;
origin = ””;
owner = ””;
container_type = User;
reaction = reac;
case_of_unknown
_data = beha; }
can_receive
= {
mixture_of_data = mix; }
if(u, ””, ””, User, ) ̸∈ TC
then TC = TC ∪ (u, ””, ””, User, reac,
beha);
PC(u) ← mix;
∀ix ∈ mix, PI∪X (ix)
← (c, (mix \ {ix}))
Rule 2.2: Construction of the Container Policy (PC): File’s Case
container_identification
= {
alias = al;
origin = or;
owner = own;
container_type = F ile;
reaction = reac;
case_of_unknown
_data = beha; }
can_receive
= {
mixture_of_data = mix; }
if(al, , , , ) ̸∈ TC
then TC = TC ∪ (al, or, own, reac,
beha);
PC(al) ← mix
∀ix ∈ mix, PI∪X (ix)
← (c, (mix \ {ix}))
Rule 2.3: Construction of the Container Policy (PC): Process Case
container_identification
= {
alias = al;
origin = or;
owner = own;
container_type = P rocess;
reaction = reac;
case_of_unknown
_data = beha; }
can_receive
= {
mixture_of_data = mix; }
if(al, , , , ) ̸∈ TC
then TC = TC ∪ (Execute(al), or, own,
reac, beha);
PC(Execute(al)) ← mix
∀ix ∈ mix, PI∪X (ix)
← (c, (mix \ {ix}))
Fig. 1: Semantics rules of BSPL
49
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-298-1
SECURWARE 2013 : The Seventh International Conference on Emerging Security Information, Systems and Technologies

a policy (the set of owners of data/containers appearing in
the table of this policy). We ﬁnally use request : U × (If ∪
Cf)×P(If ∪Xf) → {True; False}, boolean function as the
answer from the user to the request of a policy.
The building function Pf
Cf is formally deﬁned by the deﬁni-
tion 2. Intuitively this deﬁnition states that the sets I associated
with c are either in the policy P1 (resp. P2) with every data
and c owned by an author of P1 (resp. P2) or correspond to
an intersection of the two policies on the containers for which
both policies specify mixes of information. The rest of the
sets in the deﬁnition are used to collect the cases in which the
behaviour speciﬁed for an unknown container or an unknown
data by an owner allows the result policy to contain an element.
Deﬁnition 2 explains the construction of Pf
If ∪Xf . This
deﬁnition is dual (thanks to the coherence property) with the
deﬁnition of Pf
Cf .
With this deﬁnition, we are able to prove that the policy
computed by composition of two consistent policies is still a
consistent policy. The proof is not detailed here due to the
limitation of space.
Deﬁnition 2 (composition of policies):
P1 and P2 two information ﬂow policies. The policy Pf
=
(Pf
Cf , Pf
If ∪Xf ) obtained by composition of P1 and P2 is
denoted by P1 ⊕P2 and is deﬁned by Pf
Cf and Pf
If ∪Xf where :
(If ∪ Xf) = ((I1 ∪ I2) ∪ (X1 ∪ X2)), and Cf = C1 ∪ C2
Pf
Cf (c) =
{I ∈ P1
C1(c)|∀i ∈ I,
ownerl(i) ∈ authors(P1) ∧ (ownerc(c) ∈ authors(P1))
∪
{I ∈ P2
C2(c)|∀i ∈ I,
ownerl(i) ∈ authors(P2) ∧ (ownerc(c) ∈ authors(P2))
∪
{(I1 ∩ I2)|I1 ∈ P1
C1(c)
∧I2 ∈ P2
C2(c)}
∪
{I ∈ P1
C1(c)|(ownerc(c) ∈ author(P2))
∧(behaviour(c) = AlwaysAccept
∨(behaviour(c) = Ask
∧request(ownerc(c), c, I)))}
∪
{I ∈ P2
C2(c)|(ownerc(c) ∈ author(P1))
∧(behaviour(c) = AlwaysAccept
∨(behaviour(c) = Ask
∧request(ownerc(c), c, I ∪ {ix})))}
∪
{I ∈ P1
C1(c)|∃ix ∈ I, ownerl(ix) ∈ authors(P2)
∧(ownerc(c) ∈ author(P1))
∧(behaviour(ix) = AlwaysAccept
∨(behaviour(ix) = Ask
∧request(ownerl(ix), ix, I ∪ {ix})))}
∪
{I ∈ P2
C2(c)|∃ix ∈ I, ownerl(ix) ∈ authors(P1)
∧(ownerc(c) ∈ author(P2))
∧(behaviour(ix) = AlwaysAccept
∨(behaviour(ix) = Ask
∧request(ownerl(ix), ix, I ∪ {ix})))}
Pf
If ∪Xf (ix) =
{(c, I) ∈ P1
I1∪X1(ix)|∀i ∈ (I ∪ {ix}),
ownerl(i) ∈ authors(P1) ∧ (ownerc(c) ∈ authors(P1))
∪
{(c, I) ∈ P2
I2∪X2(ix)|∀i ∈ (I ∪ {ix}),
ownerl(i) ∈ authors(P2) ∧ (ownerc(c) ∈ authors(P2))
∪
{(c, I1 ∩ I2)|(c, I1) ∈ P1
I1∪X1(ix)
∧(c, I2) ∈ P2
I2∪X2(ix)}
∪
{(c, I) ∈ P1
I1∪X1(ix)|(ownerc(c) ∈ author(P2))
∧(behaviour(c) = AlwaysAccept
∨(behaviour(c) = Ask
∧request(ownerc(c), c, I ∪ {ix})))}
∪
{(c, I) ∈ P2
I2∪X2(ix)|(ownerc(c) ∈ author(P1))
∧(behaviour(c) = AlwaysAccept
∨(behaviour(c) = Ask
∧request(ownerc(c), c, I ∪ {ix})))}
∪
{(c, I) ∈ P1
I1∪X1(ix)|ownerl(ix) ∈ authors(P2)
∧(ownerc(c) ∈ author(P1))
∧(behaviour(ix) = AlwaysAccept
∨(behaviour(ix) = Ask
∧request(ownerl(ix), ix, I ∪ {ix})))}
∪
{(c, I) ∈ P2
I2∪X2(ix)|ownerl(ix) ∈ authors(P1)
∧(ownerc(c) ∈ author(P2))
∧(behaviour(ix) = AlwaysAccept
∨(behaviour(ix) = Ask
∧request(ownerl(ix), ix, I ∪ {ix})))}
VI.
USING BSPL: EXAMPLES
A. Example of policy in BSPL
We propose in this section a part of what could be
a ﬂow policy of a game application for Android, e.g.,
AngryBirdsSpace. We have studied this application and found
that the pieces of information linked to the application (as its
code, its own data) can ﬂow to 61 containers of information
(more precisely 22 processes and 39 ﬁles). Our study has
also shown that once launched the game receives piece of
information from more than 30 differents origins.
If we were developers of this application, we would have to
specify a BSPL policy that takes into account this behavior. We
present in Fig. 2 a part of this policy. This part deﬁnes a sensi-
tive piece of information, which is the content of the applica-
tion package ﬁle /data/app/com.rovio.angrybirds
-space.ads-1.apk aliased as AngryBirdSpace. This piece
of information is owned by an owner deﬁned by the Android
operating system during the installation process. It is not
an executed information (i.e., it is of type I). In case of
detection of an illegal ﬂow, the monitor raises an alert but
does not forbid the ﬂow. The default behavior is used in case
of an unknown container. The rest of the
<Data-policy>
deﬁnes the containers this piece of information can ﬂow into.
More precisely it speciﬁes that this application may create a
ﬁle where it will store its cookies, will create a ﬁle named
highscores.lua.tmp that will contain the scores, will use
the vibrate facility and will ask the music player to play its
own music. This application will create at least one container
of information (a process) named ybirdsspace.ads that
will receive data, in particular it will receive the piece of
information identiﬁed just above AngryBirdSpace.
50
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-298-1
SECURWARE 2013 : The Seventh International Conference on Emerging Security Information, Systems and Technologies

<BSPL-policy>
<Data-policy>
<data>
<data_identification
alias ="AngryBirdSpace"
origin="/data/app/com.rovio.angrybirdsspace
.ads-1.apk"
owner="App_2"
type="I"
reaction="Alert"
case_of_unknown_containers="Ask"
/>
<can_flow
into="/data/data/com.rovio.angrybirdsspace
.ads/databases/cookiedb-journal"
mixed_with_data=""
/>
<can_flow
into="/data/data/com.rovio.angrybirdsspace
.ads/files/highscores.lua.tmp"
mixed_with_data=""
/>
<can_flow
into=""
mixed_with_data="/sys/devices/virtual/
timed_output/vibrator
/enable"
/>
<can_flow
into="android.musicfx"
mixed_with_data=""
/>
<can_flow>
into="system_server"
mixed_with_data=""
/>
<can_flow
into="system_server"
mixed_with_data=""
/>
</data>
</Data-policy>
<Containers-policy>
<container>
<container_identification
alias=" ybirdsspace.ads"
origin=" ybirdsspace.ads"
owner="app_2"
container_type="Process"
reaction="Alert"
case_of_unknown_data="Ask"
/>
<can_receive
mixture_of_data="AngryBirdSpace"
/>
</can_receive>
</container>
</Containers-policy>
</BSPL-policy>
Fig. 2: A part of a BSPL policy for Angry Bird Space
<BSPL-policy>
<Data-policy>
<data>
<data_identification
alias ="file"
origin="/data/local/tmp/file"
owner="me"
type="I"
reaction="Alert"
case_of_unknown_containers="Ask"
/>
<can_flow>
into="md5sum"
mixed_with_data=""
/>
<can_flow
into="hash"
mixed_with_data=""
/>
</data>
</Data-policy>
<Containers-policy>
<container>
<container_identification
alias="hash"
origin="/data/local/tmp/hash"
owner="root"
container_type="File"
reaction="Alert"
case_of_unknown_data="NeverAccept"
/>
</container>
<container>
<container_identification
alias="md5sum"
origin="/system/bin/md5sum"
owner="me"
container_type="Process"
reaction="Alert"
case_of_unknown_data="AlwaysAccept"
/>
</container>
</Containers-policy>
</BSPL-policy>
Fig. 3: Hashing Example: Initial Policy
B. Example of Composition
In this subsection, we describe another example to illustrate
a simple case of composition. We propose a scenario involving
a hashing function. Notice that in this example the owner of
all data and all containers is root, but it could be anything else
and in particular the two processes could be owned by different
users. The hashing function md5sum is installed in our system.
We have also a ﬁle named FILE containing sensitive values ;
we want to forbid the reading of these values. However, we
trust the application md5sum and we permit to compute and
publish the hash value of FILE using md5sum in HASH. Fig. 3
gives this simple policy.
With
such
a
policy,
using
the
com-
mand
md5sum /data/local/tmp/file >
/data/local/tmp/hash does not raise an alert while
51
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-298-1
SECURWARE 2013 : The Seventh International Conference on Emerging Security Information, Systems and Technologies

<Containers-policy>
<container>
<container_identification
alias="sha1sum"
origin="/system/bin/sha1sum"
owner="root"
container_type="Process"
reaction="Alert"
case_of_unknown_data="NeverAccept"
/>
<can_receive
mixture_of_data="file"
/>
</container>
</Containers-policy>
Fig. 4: Hashing Example: sha1sum Policy
the
command
sha1sum /data/local/tmp/file >
/data/local/tmp/hash does. Indeed, the policy does
not take sha1sum into account at this point. Notice that the
behavior “ask” is associated to unknown containers.
Fig. 4 illustrates: md5sum is now considered unsafe
and the owner of sha1sum wants to replace md5sum by
sha1sum. This policy expresses that the owner of sha1sum
requests the right for the processes running sha1sum to
contain ﬁle.
We can now compose these two last policies. In our sce-
nario, this composition requires the intervention of the owner
of ﬁle since the behavior speciﬁed in the case of an unknown
container is “ask”. If this behavior was “alwaysaccept”
or “neveraccept”, the composition could be realized au-
tomatically. The owner of ﬁle accepts since he wants to
replace md5sum by sha1sum. Fig. 5 shows the result of the
composition.
In this composed policy, both md5sum and sha1sum have
the right to contain ﬁle and hash can still contain ﬁle too.
There are three containers and all of them can contain ﬁle.
Now the command sha1sum /data/local /tmp/file
> /data/
local/tmp/hash
no
longer
raises
an
alert.
How-
ever, the command md5sum /data/local/tmp/file >
/data/local/
tmp/hash neither raises an alert. The ﬁnal step is thus to
remove the right of md5sum to contain ﬁle. This step can
only be realized by a manual intervention from the owner
of md5sum. The ﬁnal resulting policy is almost the same as
in Fig. 5, but md5sum can no longer contain ﬁle. After this
step, the command md5sum /data/local/tmp/file >
/data/local/tmp/hash raises an alert. The lines of the
policy that disappear are all the lines concerning md5sum.
This scenario illustrates a simple use of BSPL, but it shows
the expressiveness of the language. Each owner can express
a policy for its data and containers and let the composition
mechanism merge the policies to produce the policy to be
ﬁnally enforced by Blare on the system. This example also
shows that it is possible to restrain access to some pieces of
information to speciﬁc processes executing a code considered
as safe.
<?xml version="1.0" encoding="UTF-8"?>
<BSPL-policy>
<Data-policy>
<data>
<data_identification
alias ="file"
origin="/data/local/tmp/file"
owner="root"
type="I"
reaction="Alert"
case_of_unknown_container="Ask"
/>
<can_flow
into="md5sum"
mixed_with_data=""
/>
<can_flow
into="sha1sum"
mixed_with_data=""
/>
<can_flow
into="hash"
mixed_with_data=""
/>
</data>
</Data-policy>
<Containers-policy>
<container>
<container_identification
alias="hash"
origin="/data/local/tmp/hash"
owner="root"
container_type="File"
reaction="Alert"
case_of_unknown_data="NeverAccept"
/>
</container>
<container>
<container_identification
alias="md5sum"
origin="/system/bin/md5sum"
owner="root"
container_type="Process"
reaction="Alert"
case_of_unknown_data="AlwaysAccept"
/>
</container>
<container>
<container_identification
alias="sha1sum"
origin="/system/bin/sha1sum"
owner="root"
container_type="Process"
reaction="Alert"
case_of_unknown_data="NeverAccept"
/>
</container>
</Containers-policy>
</BSPL-policy>
Fig. 5: Hashing Example: Composed Policy
VII.
CONCLUSION AND FUTURE WORK
In this paper, we have presented BSPL, a language de-
signed to specify an information ﬂow policy for developpers of
52
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-298-1
SECURWARE 2013 : The Seventh International Conference on Emerging Security Information, Systems and Technologies

applications of users. This language is dedicated to the Blare
monitor.
The information ﬂow policies expressed using BSPL spec-
ify which and how sensitive pieces of information may be
combined and in which containers of information these data
mixtures can ﬂow.
The language has been presented here and we have pro-
posed precise semantics based on a solid model of information
ﬂow published earlier.
We have deﬁned a consistency property for a policy spec-
iﬁed in this model and have shown how to compose two
consistent policies. Our deﬁnition of composition respects the
consistency property: a composition of two consistent policies
leads to a third consistent policy.
We already have a tool allowing to compute blare tags
using a BSPL policy. Thus, we are able to monitor ﬂows
spawned by applications running over Android with respect
to a BSPL policy.
For our future work, we plan to focus on adding the
possibility for users to declassify sensitive data in certain
contexts and to administrate their policy.
REFERENCES
[1]
N. Zeldovich, S. Boyd-Wickizer, E. Kohler, and D. Mazi`eres, “Making
information ﬂow explicit in histar,” in OSDI, 2006, pp. 263–278.
[2]
V. V. T. Tong, A. J. Clark, and L. M´e, “Specifying and enforcing a ﬁne-
grained information ﬂow policy : model and experiments,” vol. 1, no. 1,
2010, pp. 56–71, this paper was part of the 2nd International Workshop
on Managing Insider Security Threats (MIST 2010); Morika, Iwate,
Japan (14-15 June 2010).
[3]
A. Sabelfeld and A. C. Myers, “Language-based information-ﬂow
security,” IEEE Journal on Selected Areas in Communications, vol. 21,
no. 1, pp. 5–19, 2003.
[4]
P. Efstathopoulos, M. N. Krohn, S. Vandebogart, C. Frey, D. Ziegler,
E. Kohler, D. Mazi`eres, M. F. Kaashoek, and R. Morris, “Labels and
event processes in the asbestos operating system,” in SOSP, 2005, pp.
17–30.
[5]
W. Enck, P. Gilbert, B. gon Chun, L. P. Cox, J. Jung, P. McDaniel, and
A. Sheth, “Taintdroid: An information-ﬂow tracking system for realtime
privacy monitoring on smartphones,” in OSDI, 2010, pp. 393–407.
[6]
P. Efstathopoulos and E. Kohler, “Manageable ﬁne-grained information
ﬂow,” in EuroSys, 2008, pp. 301–313.
[7]
S. Geller, C. Hauser, F. Tronel, and V. V. T. Tong, “Information ﬂow
control for intrusion detection derived from mac policy,” in ICC, 2011,
pp. 1–6.
[8]
G. Hiet, V. V. T. Tong, L. M´e, and B. Morin, “Policy-based intrusion
detection in web applications by monitoring java information ﬂows,”
pp. 53–60, 2008.
[9]
“Designing information ﬂow policies for android’s operating system,”
in ICC, 2012, pp. 976–981.
[10]
S. Vandebogart, P. Efstathopoulos, E. Kohler, M. N. Krohn, C. Frey,
D. Ziegler, M. F. Kaashoek, R. Morris, and D. Mazi`eres, “Labels and
event processes in the asbestos operating system,” ACM Trans. Comput.
Syst., vol. 25, no. 4, 2007.
[11]
S. Geller, “Information ﬂow and execution policy for a model of
detection without false negatives,” in Network and Information Systems
Security (SAR-SSI), 2011 Conference on, 2011, pp. 1–9.
53
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-298-1
SECURWARE 2013 : The Seventh International Conference on Emerging Security Information, Systems and Technologies

