Annotated Component-Based Description for Application Composition  
Christian Brel, Philippe Renevier-Gonin, Anne-Marie Pinna-D√©ry, Michel Riveill 
Laboratoire I3S - UMR7271 - UNS CNRS 
2000, route des Lucioles - Les Algorithmes 
BP 121 - 06903 Sophia Antipolis Cedex ‚Äì France 
{christian.brel, philippe.renevier, anne-marie.pinna, michel.riveill}@unice.fr 
 
Abstract ‚Äì One possible way of developing applications faster is 
by composing existing applications. In order to support 
developers this way, we propose a composition approach 
manipulating both Functionalities and User Interfaces. We 
present a model of annotation for describing Component-
Based applications. By tagging the components with their ‚Äúui‚Äù 
and functional concerns, we take into account the UI part of 
application at a same level as business part. Thanks to such 
annotations, we define a substitution between components in 
order to merge controls, inputs or outputs.   
Keywords‚Äìapplication composition; ontology; component-
based architecture 
I. 
 INTRODUCTION 
Nowadays, the trend in software usage is to consume 
specialized applications. End-users can use the same 
functionality in several situations, i.e., with several 
applications. For example, Google Maps is often integrated 
for geo-localization. In an idealistic way, developers must be 
able to reuse functionalities without (or with minor) 
developments. To support developers in their task of 
combining 
features 
from 
several 
component-based 
applications, we contribute towards reducing developers‚Äô 
efforts. We propose an application composition through its 
User Interface (UI). Our composition preserves the 
functional linking between components of the applications. 
Considering a UI as an assembly of components, we explore 
the composition via their ports. Using the fact that a port can 
be provided by a component or required by it, we add some 
annotations about the role the port plays for its attached unit. 
The added information lets the different components to be 
combined to obtain a running application.  
Section II presents a description of related work. Section 
III describes the model that an application has to respect in 
order to be composed. A case study to illustrate our proposed 
model is shown in Section IV. After the presentation of the 
composition by substitution in Section V, Section VI details 
the substitution between two elements. The paper finished 
with a discussion about our work in Section VII and a 
conclusion in Section VIII. 
II. 
RELATED WORK 
The described problem is naturally related to the state-of-
the-art in software composition and UI composition. For 
software composition, ‚ÄúComposition can be defined as any 
possible and meaningful interaction between the software 
constructs involved‚Äù according to [5] where a taxonomy of 
composition mechanisms (e.g., orchestration, aspect oriented 
programming, etc.) is defined. When the application code is 
available, solutions, such as aspect oriented programming, 
are meaningful. On the contrary, when the application code 
is not available, we can only access to published interfaces 
and we have to use connectors [7] to perform the 
composition. 
For UI composition, we identify two different 
approaches. In the first approach, the UI composition is 
based on abstract description, like in UsiXML [6], in the 
ServFace project [8], Alias [10] and in Transparent Interface 
[4]. Those models are defined by XML languages. Final UI 
are obtained thanks to transformations of those models. In 
the second approach, the UI composition is based on ‚ÄúUI 
Components‚Äù. These ones are reusable high-level widgets, 
available in repositories. ‚ÄúUI components‚Äù are reused by 
applying design pattern (code level) and detecting pattern of 
use (UI level). Compose [3], COTS-UI [1], CRUISe [9], 
WinCuts [12], UI fa√ßades [11] and on-the-fly mashup 
composition [13] illustrate such kind of UI composition. 
From the analysis of these works, we note that we can 
compose the UI (respectively, the functional parts) of former 
applications, but the other side (respectively, the UI) has to 
be built again. Moreover, none of these works allows the 
reusing of former applications with supporting replacement 
of UI parts. Our goal is to compose applications and in 
particular their UI, not only by juxtapositions, but also by 
substitutions between former components of the UI. To 
obtain a functional application, we also want to preserve 
former functional links between components of application, 
in particular between the UI and the business part. 
Our proposition is based on applications made of black-
box components. We propose a composition model based on 
roles and ports of those components. The roles are expressed 
as annotations. The UI are also represented as component 
assemblies. The composition will be performed by 
transforming the manipulation on an abstract representation 
to manipulation on components.  
III. 
APPLICATION MODEL BASED ON PORTS AND ROLES 
In order to be compliant with our composition method, the 
existing applications must follow a clear separation between 
the functionalities (business part) and the UI (separation of 
concerns). A Component may belong to the two parts. Each 
Component is described with its ports that we can tag with 
one of the application concerns, e.g., a port used for a UI 
506
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

concern will be tagged as ‚ÄúUI‚Äù. Each Component may have 
required ports (ports required to obtain desirable behavior of 
another Component) and may have provided ports (ports that 
Component can provide to other Components). Moreover, 
each port of a Component must be annotated with a ‚Äúrole‚Äù 
representing the involved behavior of the Component. This 
role can be Trigger, Input or Output. Trigger describes the 
fact that through its attached port, the Component can call 
another Component. It can be the button to trigger a 
particular action or it can be an observable ‚ÄúComponent‚Äù 
notifying its observers.  Input is used to describe a port to 
get some data. The Component with an Input port can 
provide data to other Components (like an ‚Äúinput text‚Äù in UI 
or any ‚ÄúGetter‚Äù facet of a Component).  Output is used to 
describe a port to set some data. The Component can receive 
data to store or to display (like a ‚Äúlist‚Äù or a ‚Äúlabel‚Äù in UI or 
any ‚ÄúSetter‚Äù facet of a Component). An application to 
compose must be provided with the annotations of ports of 
its Components. Those annotations are about roles (trigger, 
input, output / provided or required) or kind (‚ÄúUI‚Äù or not, 
i.e., Business). In the remainder of the paper, we use the 
following acronyms:  rt - ‚Äúrequired-trigger‚Äù, pt - ‚Äùprovided-
trigger‚Äù, ri - ‚Äúrequired-input‚Äù, pi - ‚Äùprovided-input‚Äù, ro - 
‚Äúrequired-output‚Äù and po - ‚Äùprovided-output‚Äù. 
IV. 
ILLUSTRATION WITH A CASE STUDY 
We consider two applications: 
1. 
‚ÄúMovie Theaters‚Äù, shown in Figure 1, an 
application displaying movies played in a cinema. 
There are a text field to entering the name of the 
cinema (E1), a ‚Äúget played movies‚Äù button (E2) 
and a display area to list the played movies (E5). 
The list can also be obtained by validation with 
‚ÄúEnter‚Äù key in text field (E1). 
2. 
‚ÄúCinema Localization‚Äù, shown in Figure 2, an 
application displaying the location of a cinema on 
a map (e.g. using Google Maps). Its UI is also 
simple: a text field to entering the name of the 
cinema (E6), a ‚Äúshow cinema place‚Äù button (E7) 
and a map to show the localization of the cinema 
(E10). 
These two applications could be composed in a different 
way, in order to obtain new applications. A possibility is to 
have at the same time both the list of the displayed movies 
and the localization of the cinema. A result of the 
composition‚Äôs UI is shown in Figure 3. 
V. 
COMPOSITION BY SUBSTITUTION 
An application appi is a set of Components {En}. We 
define ‚ÄúPorts‚Äù, the set of ports of a component, and 
‚ÄúUsedPorts‚Äù, the set of used ports: 
ÔÄ¢Ej ÔÉé appi, Ports(Ej) ={ Pn } is the set of the n ports of Ej 
UsedPorts(Ej, appi) = { Pk } is the set of used ports of Ej in appi  
First, we define the role of the ports and their 
connectivity as the Linkable property, independently of the 
application in which components are used: 
ÔÄ¢Ej ÔÉé appi1,ÔÄ¢ Pm ÔÉé Ports(Ej),  Role(Pm) ÔÉé {pi, po, pt,  ri,  ro,  rt} 
isProvided(Pm)‚ü∫ Role(Pm)ÔÉé{pi,po,pt} 
isRequired(Pm)‚ü∫ Role(Pm)ÔÉé{ri,ro,rt} 
ÔÄ¢Ek ÔÉé appi2,ÔÄ¢Pm ÔÉé Ports(Ej), ÔÄ¢Pn ÔÉé Ports(Ek) 
We denote rm = Role(Pm) and rn = Role(Pn) 
Linkable(Pm, Pn)‚ü∫(rm = ro and rn = po) or (rn = ro and  
rm = po) or (rm = ri and rn = pi) or (rn = ri and rm = pi) or  
(rm = rt and rn = pt) or (rn = rt and rm = pt) 
We define a link between two components through two 
connected ports in an application as a property Link:  
Link((Ej, Pm), (Ek, Pn), appi) is true if Ej and Ek are linked in a 
appi through the ports Pm and Pn.  
Such link is possible only if Ej belongs to appi , Ek belongs to 
appi,  Pm belongs to UsedPorts(Ej, appi), Pn belongs to 
UsedPorts(Ek, appi) and Linkable(Pm, Pn). For each 
Component Ej, we define the set Links(Ej, Pm, appi): 
Links(Ej, Pm, appi) = { (Ek, Pn), Ek ÔÉé appi,  
Pn ÔÉé UsedPorts(Ek, appi) / Link((Ej,Pm),(Ek,Pn),appi) } 
For all ports, we define a property ‚ÄúisUIPort‚Äù indicating 
if the port has a ‚ÄúUI‚Äù concern and a function 
‚ÄúisUIPortInApp‚Äù for contextual ‚ÄúUI‚Äù concern: 
ÔÄ¢Ej,ÔÄ¢Pm ÔÉé Ports(Ej): 
ÔÇ∑ 
isUIPort(Pm)‚ü∫isProvided(Pm) and Pm is tagged ‚ÄúUI‚Äù 
ÔÇ∑ 
isUIPortInApp(Pm, appi) ‚ü∫ (Pm ÔÉé UsedPorts(Ej, appi) 
and isUIPort(Pm)) or (isRequired(Pm) and ÔÄ§(Ek,Pn) / 
isUIPort(Pn) and Link((Ej, Pm),(Ek, Pn), appi) ) 
Our composition is made through the construction of a 
new application, appr, initially defined as the union of all 
former applications: 
appr = ÔÉà1nb appi  where nb is the number of  
applications being composed. ÔÄ¢Ej ÔÉé appi: 
ÔÇ∑ 
Ej ÔÉé appr  
ÔÇ∑ 
UsedPorts(Ej, appr)= UsedPorts(Ej, appi) 
ÔÇ∑ 
ÔÄ¢Ek ÔÉé appi, ÔÄ¢PmÔÉéPorts(Ej), ÔÄ¢PnÔÉé Ports(Ek), Link((Ej, 
Pm), (Ek, Pn), appr) = Link((Ej,Pm),(Ek,Pn), appi) 
ÔÇ∑ 
ÔÄ¢Pm ÔÉé Ports(Ej), isUIPortInApp(Pm, appr) = 
isUIPortInApp(Pm, appi)   
The new application appr will change with the successive 
substitutions. A substitution is made between a selection of 
pairs {(Ej, Pm)i} and a conserved pair (Ek, Pk). We define a 
‚Äúsubst‚Äù function to operate substitution. In a few words, the 
substitution creates several connectors [7] in order to replace 
previous links involving substituted pairs by the kept one. 
We denote PreLinksk the value of Links(Ek,Pk,appr) before the 
substitution. We denote card(PreLinksk) the number of Components 
in PreLinksk , i.e., the number of Components linked with Ek 
through Pk. 
For each pair (Ej, Pm)i, we denote PreLinksi the value of 
Links(Ej, 
Pm, 
appr) 
before 
the 
substitution. 
We 
denote 
card(PreLinksi) the number of Components in PreLinksi i.e., the 
507
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

number of Components linked with Ej through Pm. We denote sel 
the set of the substituted pairs: 
sel = {(Ej, Pm)i, i‚àà{1‚Ä¶z}}.  
ÔÄ¢(Ej, Pm)i  ‚àà sel, Pm ÔÉé UsedPorts(Ej, appr) ;  
isProvided(Pm)= isProvided(Pk) 
We denote nk(i) :  
ÔÇ∑ 
nk(i) = 0 if the substitution doesn‚Äôt impact previous 
link with (Ek, Pk) , i.e., the new link and previous 
links are independent. 
ÔÇ∑ 
nk(i) = card(PreLinksk) if the substitution impacts 
previous link with (Ek, Pk), i.e., the new link and 
previous links are dependent (merged). 
 
 
Figure 1. Movie Theater, UI and Components of application. 
 
 
Figure 2. Cinema Localization, UI and Components of application. 
 
If (nk(i) > 0 ÔÄ¢(Ej, Pm)i) then PreLinksk ÔÉá Links(Ek, Pk, 
appr) = ÔÉÜ, i.e., all connectors also replace the previous links 
involving the conserved pair (Ek, Pk) like in Figure 4. For 
each Component in sel, UsedPorts, Link and isUIPortInApp 
are impacted by substitution. 
subst : ùí´(PAIRS) √ó PAIRS ‚Üí ùí´(PAIRS) 
subst(sel,(Ek, Pk))= { ( Ecj,a, Pmj,a)i x (Ecj,a,Pnj,a)i x ÔÉà (Ecj,a,Pky)i,    
i‚àà{1...z},  y‚àà{1...nk(i)}, a‚àà{1...card(PreLinksi)} }  
ÔÄ¢(Ej, Pm)i‚àà sel, Pm ÔÉè UsedPorts(Ej, appr) 
ÔÄ¢(Ej, Pm)i‚àà sel, Links(Ej, Pm, appr) = ÔÉÜ 
ÔÄ¢(Ej, Pm)i‚àà sel,ÔÄ¢a‚àà{1...card(PreLinksi)}, Ecj,a is a new 
Component of appr   / {Pmj,a,Pnj,a } ÔÉå Ports(Ecj,a) and 
{Pmj,a,Pnj,a} ÔÉå UsedPorts(Ecj,a,appr) and Linkable(Pm,Pmj,a) and 
Linkable(Pnj,a, Pk)  
ÔÄ¢Ecj,a, (Ecj,a , Pnj,a) ‚àà Links(Ek, Pk, appr) 
ÔÄ¢(Ej, Pm)i, ÔÄ§(Ecj,a,Pmj,a ) / Links(Ecj,a ,Pmj,a , appr) = PreLinksi 
ÔÄ¢(Ecj,a,Pmj,a ), ÔÄ§(Ej, Pm)i / Links(Ecj,a ,Pmj,a , appr) = PreLinksi 
ÔÄ¢(Ej, Pm)i, nk(i)>0 => ÔÄ¢y ‚àà{1..Card(PreLinksk)}, Ecj,a is a new 
Component of appr  / {Pky} ÔÉå Ports(Ecj,a) and  
{Pky} ÔÉå UsedPorts(Ecj,a,appr) and ÔÄ§(E,P)‚àà PreLinksk /  
(Ecj,a, Pky) ‚àà Links(E,P,appr) 
As a result, Components no longer involved in links left 
are removed. The substitution of any pair (Ej, Pm) by a pair 
(Ek, Pk) is based on the annotations. The role of a port is used 
to define possible substitutions and the way connectors are 
used. This is explained in the Section VI. The use of the kind 
of ports (‚ÄúUI‚Äù or not) is used as following. If before the 
substitution 
isUIPortInApp(Pm,appr) 
is 
different 
from  
isUIPortInApp(Pk,appr), then the substitution changes the 
508
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

concern implied in the link, i.e., an input field may be 
replaced by a data coming from a ‚ÄúBusiness‚Äù Component. 
That is possible but in such case we could emit a notification. 
VI. 
SUBSTITUTING TWO PAIRS 
We now consider substitution between two pairs: a 
replaced pair and a conserved pair. The function ‚Äúsubst‚Äù can 
replace n pairs, but it is just n substitutions performed in 
parallel. We present the compatibility between the two pairs 
according to the role of the conserved pair.  
In order to perform a substitution between two pairs 
(Component, Port with a role), we need to add a connector 
between the substituted pair and the conserved one [7]. 
Connectors may have several uses: (i) adapting formats of 
the data or (ii) defining a policy of substitution or (iii) adding 
a role when the new role makes the Component the ‚Äúcaller‚Äù. 
Thanks to the identification of the Connector and its roles, 
we can know define the ‚Äúsubst‚Äù function for two pairs. 
Indeed, in Sections VI.A, VI.B, VI.C and VI.D, we describe 
both the definition domain for two pairs and the results.  
 
 
Figure 3. A Result for composition of ‚ÄúMovie Theater‚Äù with ‚ÄúCinema Localization‚Äù. 
 
A. Keeping a Provided Output 
When keeping an output, there is no constraining on the 
role of substituted ports. By placing a connector before the 
Component having port playing the Output role, the 
substitution can be performed. This is a case in the ‚Äúsubst‚Äù 
function where nk(i) > 0 ÔÄ¢(Ej, Pm)i.  
First, the connector may be used to adapt the format of 
data to display if the substituted role is also Output (a 
Conversion Connector in [7]) or to define a policy of 
displaying data if the substituted role is also Output (a mix 
between a Conversion Connector and a Data Access 
Connector in [7]). Such policy may be displaying all data, 
the last received data, etc. Secondly, the connector may also 
be used to store displayed data and can restitute them when 
asked if the substituted role is an Input (see Figure 4) (a Data 
Access Connector in [7]). Thirdly, the connector may also be 
used to generate an event when the output is updated if the 
substituted role is a Trigger (an Event Connector in [7]). 
In Figure 4, the connector C1 can store displayed data 
from (E3,ro1) and can restitute them to (E8,ri1) when asked. 
With that solution, E5 doesn‚Äôt need to have a port playing a 
role of Input, but the Connector has both provided port with 
Output role for (E3,ro1), required port with Output role for 
(E5,po1) and required port with Input role for (E8,ri1). 
B. Keeping a Provided Trigger 
As ‚ÄúTrigger‚Äù is the only one port‚Äôs role that makes the 
associated Component a ‚Äúcaller‚Äù, the role of the port in 
substituted pair must be also a ‚ÄúTrigger‚Äù. We place a 
connector after the kept ‚ÄúTrigger‚Äù for two reasons: (i) 
adapting the format of the ‚Äúevent‚Äù and (ii) defining the 
policy of the substitution (a mix between an Event Connector 
and a Procedure Call Connector in [7]). The connector can 
proceed a sequence between the two triggered actions or put 
them in parallel etc. This is a case in the ‚Äúsubst‚Äù function 
where nk(i) > 0 ÔÄ¢(Ej, Pm)i. 
509
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

C. Keeping a Provided Input 
An ‚ÄúInput‚Äù cannot replace an ‚ÄúOutput‚Äù because of the 
direction of the data. Conversely, an ‚ÄúInput‚Äù may replace a 
‚ÄúTrigger‚Äù (see Figure 5). The connector placed before the 
kept port can provide on demand (a Data Access Connector 
in [7]). At the same time, when called, the connector can 
generate an event and so it can ‚Äúcall‚Äù the requiring port (an 
Event Connector in [7]). The ‚ÄúTrigger‚Äù is ‚Äúon access‚Äù (i.e., 
when the value is got). Of course, an ‚ÄúInput‚Äù can replace 
another ‚ÄúInput‚Äù. In that case, the connector is used to adapt 
the provided data to what is expected (a Conversion 
Connector in [7]). Keeping an ‚ÄúInput‚Äù is a case where nk(i) 
could either be 0 (pi replacing pi) or be greater than 0 (pi 
replacing a pt). 
 
 
Figure 4 : (E5, po1) replacing (E6, pi1), connector C1 before (E5, po1.) 
 
D. Keeping a Required port 
In the ‚Äúsubst‚Äù function, if Pk is a required port, all 
substituted pairs must be made of ports with the same role as 
Pk. Even through a connector, the requirements could not be 
changed: a setter requirement (required output) could not 
become a getter requirement (required input). So, even if a 
connector could have two ports, one ‚Äúpo‚Äù and ‚Äúri‚Äù to be 
connected to a ‚Äúpi‚Äù, inside that connector, the setter used by 
Ek could not be functionally translated in a getter. The 
connector could not appropriately exploit the value coming 
from Ek. Such substitutions are cases where nk(i) > 0 ÔÄ¢(Ej, 
Pm)i.  All connectors are not only conversion one [7] but they 
may: (i) merge all input or trigger if Role(Pk) is ri or rt or (ii) 
call of setter on output if Role(Pk) is ro. 
 
E. Towards Automatic Substitution 
From this substitution operator, we can define an operator 
at a higher level. The objective is to compose two 
Components from the new application appr. Based on 
substitutions between ports of Components, we can define 
the substitution of two Components. Let E1 be the removed 
Component and Ek be the kept Component. For each P 
belonging to UsedPorts(E1, appr), we define: 
CompatiblePorts(P, Ek), the set of all possible port P‚Äô of Ek for a 
substitution subst({(E1, P)}, (Ek, P‚Äô)) 
If isRequired(P) or P = po, CompatiblePorts(P, Ek) = { P‚Äô ÔÉé 
Ports(Ek) / Role(P‚Äô) = Role(P) } 
If  Role(P) = pi, CompatiblePorts(P, Ek) =  
{P‚Äô ÔÉé Ports(Ek) / Role(P‚Äô)ÔÉé{po, pi} } 
If  Role(P) = pt, CompatiblePorts(P, Ek) =  
{ P‚Äô ÔÉé Ports(Ek) / isProvided(P‚Äô) } 
We denote card(CompatiblePorts(P, Ek)) the number of  
ports in CompatiblePorts(P, Ek). We apply the algorithm 
PairSelection(P, KeptElements): 
Let KeptElements the set of Components used in the 
substitution. Initially KeptElements = {Ek}.   
Let nb_potential_pairs = ÔÅìcard(CompatiblePorts(P, E)),  
EÔÉé KeptElements 
If (nb_potential_pairs = 1), (E, P) could be substituted 
by only one pair is possible. Let E‚Äô ÔÉé KeptElements / ÔÄ§P‚ÄôÔÉé 
CompatiblePorts(P, E‚Äô). The following substitution is 
computed:  subst({(E, P)}, (E‚Äô, P‚Äô)}. 
If (nb_potential_pairs > 1), one of the ports in 
CompatiblePorts(P) must be selected. That selection may be 
by the developer operating the composition or by an 
external algorithm.   
If (nb_potential_pairs = 0), (E, P) could not be 
substituted by a pair involving a Components from 
KeptElements.  
If KeptElements = appr, the algorithm finishes without 
substituting (E, P). Else, we extend the substitution by 
searching possible ports in Components linked with 
Components from KeptElements: 
ExtendedSelection = { Ej ÔÉé appr / ÔÄ§E‚ÄôÔÉé KeptElements / 
ÔÄ§ PmÔÉé UsedPorts(Ej, appr) and ÔÄ§ PnÔÉé UsedPorts(E‚Äô, appr) /  
Link( (Ej, Pm), (E‚Äô, Pn), appr) }.  
Then we apply PairSelection(P, ExtendedSelection) 
At the end of the process, if UsedPorts(E1, appr) is empty, 
E1 is removed from appr.  
F. Enforcement Of Substitutions On Case Study 
The corresponding operations to obtain the case study 
composition shown in Figure 3 are the substitution of 
(E7,pt1) - the button of ‚ÄúCinema Localization‚Äù app - by 
(E1,pt1) - the text field of ‚ÄúMovie Theater‚Äù app -  then the 
substitution of (E6,pi1) - the text field of ‚ÄúCinema 
Localization‚Äù app -  by (E1,pi1). There will be only one text 
entry left E1 and only one button left E2. As the composition 
finalizes, we can delete button E2 cause of its misspelled 
action label (see ‚ÄúDiscussion‚Äù part). So, there is only E1 left 
to lunch the research because no port is used in E6 and E7. 
When typing the name of the movie theater, the research 
could be launched (at each key stroke or only after an 
‚Äúenter‚Äù). 
VII. DISCUSSION 
The composition by substitution introduced in this paper 
needs to be integrated in a larger process as in [1]. This 
process can include another step to finalize the composition. 
This finalization can add several classic operators as a delete 
operator to suppress some links in the final components 
assembly, as we need to complete our case study described 
510
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

in Section VI. We also add a step to let developer rearrange 
the various pieces of UI in the new composed UI. We 
illustrate this in Figure 3 when we position component E10 
on the right of component E5. The scalability of our 
approach and its enforcement on large-scale application rely 
on the scalability on the ontology engine we use to annotate 
components. Our composition approach is described with 
small applications. However, we expect our approach to be 
appreciated in large-scale applications. The selection of the 
different pieces to compose of applications [1] is improved 
thanks to the same annotations presented in this paper. With 
such help during the whole composition process (selection 
and substitution), the developer may be more efficient during 
the composition. We plan to test this idea in our future work.
 
 
Figure 5 : (E1, pt1) replacing (E7, pt1), connector C1 between (E1, pt1) and (E8,rt1). 
 
VIII. CONCLUSION 
In this paper we presented a new application composition 
approach. 
The 
challenge 
is 
to 
integrally 
compose 
applications, considering both business part and UI part. Our 
approach is based on description of components constituting 
the applications. Our model enables substitution of 
Components coming from former applications, according to 
their known ports roles. Thus, we can merge controls, inputs 
or outputs and keeping operational functional links. 
Out next challenge is to propose rules for the 
representation of elements to compose. Indeed an application 
may have several representations such as its component 
assembly, its UI or its task model. Our intuition is that to 
quickly specify a composition, working on the UI is the most 
adapted. But to ensure consistency of the usability, we will 
explore the use of task models. And for making complex 
merge of application, we probably need to manually 
manipulate links between components. So we want to verify 
our intuitions and we will study the limits of each approach.  
REFERENCES 
[1] Brel C., Pinna-D√©ry A.-M., Renevier P., and Riveill M. 
OntoCompo: A Tool To Enhance Application Composition. 
In Proceedings of the 13th IFIP TC13 Conference in Human-
Computer Interaction, Lisboa, Portugal, 2011, pp. 588-591. 
[2] Criado, J., Padilla, N., Iribarne, and L., and Asensio, J. User 
Interface 
Composition 
with 
COTS-UI 
and 
Trading 
Approaches: Application for Web-Based Environmental 
Information Systems. Communications in Computer and 
Information Science vol. 111, 2010, pp. 259-266. 
[3] Gabillon, Y., Petit, M., Calvary, G., and Fiorino, H. 
Automated planning for userinterface composition. In 
Proceedings of the 2nd International Workshop. on Semantic 
Models for Adaptive Interactive Systems, Palo Alto, CA, 
USA, 2011, [retrieved: October, 2012]. 
[4] Ginzburg, J., Rossi, G., Urbieta, and M., Distante, D. 
Transparent Interface Composition in Web Applications. In 
Proceedings of the 7th International Conference on Web 
Engineering, Como, Italy, 2007, pp. 152-166. 
[5] Lau K.-K. and Rana T. A Taxonomy of Software 
Composition 
Mechanisms. 
In 
Proceedings 
of 
36th 
EUROMICRO 
Software 
Engineering 
and 
Advanced 
Application, Lille, France, 2010, pp. 102‚Äì110. 
[6] Lepreux S., Vanderdonckt J., and Kolski C. User Interface 
Composition with UsiXML. In Proceedings of 1st Int. 
Workshop on User Interface Extensible Markup Language, 
Berlin, Germany, 2010, pp. 141-151. 
[7] Mehta N. R., Medvidovic N., and Phadke S. Towards a 
taxonomy of software connectors.  In Proceedings of 
International Conference on Software Engineering, Limerick, 
Ireland, 2000, pp. 178-187. 
[8] Nestler T., Feldmann M., Preu√üner A., and Schill A. Service 
Composition at the Presentation Layer using Web Service 
Annotations. In Proceedings of the 1st Intl. Workshop on 
Lightweight Integration on the Web, San Sebastian, Spain, 
2009, pp. 63-68. 
[9] Pietschmann S., Voigt M., R√ºmpel A., and Meissner K. 
CRUISe: Composition of Rich User Interface Services. In 
Proceedings of International Conference on Web Engineering, 
San Sebastian, Spain, 2009, pp. 473-476. 
[10] Pinna-D√©ry A.-M., Joffroy C., Renevier P., Riveill M., and 
Vergoni C. ALIAS: A Set of Abstract Languages for User 
Interface Assembly. In Proceedings of Software Engineering 
and Applications, Orlando, FL, USA, 2008, pp. 77-82.  
[11] Stuerzlinger W., Chapuis O., Phillips D., and Roussel N. User 
Interface Fa√ßades: Towards Fully Adaptable User Interfaces. 
In Proceedings of the ACM Symposium on User Interface 
Software and Technology, Montreux, Switzerland, 2006, pp. 
309-318. 
[12] Tan D.S., Meyers B., and Czerwinski M. WinCuts: 
Manipulating Arbitrary Window Regions for more Effective 
Use of Screen Space. In Proceedings. of ACM Conference on 
Human Aspects in Computing Systems, Vienna, Austria, 
2004, pp. 1525-1528. 
[13] Zhao Q., Huang G., Huang J., Liu X., Mei H., Li Y., and 
Chen Y. A Web-Based Mashup Environment for On-the-Fly 
Service Composition. In Proceedings. of Symposium on 
Service-Oriented System Engineering, Jhongli, Taiwan, 2008, 
pp. 32-37. 
 
511
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

