Robustness of Security-Oriented Binary Codes
Under Non-Uniform Distribution of Codewords
Igor Shumsky and Osnat Keren
Faculty of Engineering
Bar-Ilan University
Ramat-Gan, Israel 52900
Email: ig.shum@gmail.com, osnat.keren@biu.ac.il
Mark Karpovsky
Department of Electrical and Computer Engineering
Boston University
Boston, Massachusetts 02215
Email: markkar@bu.edu
Abstract‚ÄîRobust and partially robust codes are used in
cryptographic devices for detecting active side channel attacks
on the hardware. The codes are usually designed for uniformly
distributed codewords. In practice, however, there are codewords
that are much more likely to appear than others. This paper
addresses the question of how good are existing robust codes in
this context. The worst case scenario is analyzed and a method
that allows the designer to avoid this scenario with a relatively
low cost is presented.
Index Terms‚ÄîRobust codes; security; undetected error proba-
bility; puncturing; fault analysis attacks; non-uniform distribution;
I. INTRODUCTION
The security of cryptographic devices is threatened by
fault injection attacks on the hardware. By injecting faults
an adversary can obtain secret or private information that is
stored in the device. Modern fault injection techniques allow
an adversary to introduce faults at any physical point of the
circuitry. A fault can Ô¨Çip bits, stuck a gate at a certain value,
or change data on wires [2], [8], [10]. In turn, an attack can be
mathematically modeled as an additive (i.e., symmetric) error
that distorts the correct output of that circuit. Unlike random
errors, i.e., errors caused by nature, an error induced by an
adversary can be of any multiplicity.
Fault injection attacks can be detected with relatively high
probability by security-oriented codes. It is convenient to
classify fault injection attacks by their strength; In weak
attacks the adversary cannot control which codeword will
appear at the output of the circuitry, while in strong attacks, he
can determine the outputs by choosing the inputs.A schematic
architecture, which provides robustness against weak attacks
is shown in Fig. 1; Its equivalent mathematical model is shown
in Fig. 2.
Codes for detecting weak attacks, e.g., [1], [3]‚Äì[6], [11],
are usually designed under the assumption that the codewords
are equally likely to occur. However, when the source of the
information is a computation channel, i.e., a combinatorial
logic or a sequential machine, this assumption is almost
always violated. Indeed, the distribution of vectors applied
at run-time to the inputs of the combinational portion of a
sequential machine is highly skewed due to the fact that some
state transitions are more common than others and that some

	
	

	
	
	
	
	

	
	
	


	
Fig. 1.
A schematic architecture of a circuit component protected by
a systematic security-oriented code. The shaded area is accessible to the
attacker.

	

	

	
	
	
	
	

	
	
	
























Fig. 2.
Mathematical model of a circuit component protected by a systematic
security-oriented code.
input combinations are invalid and hence cannot occur. The
distribution of the outputs of arithmetic modules is also highly
non-uniform. For example, it is more likely to have a ‚Äô0‚Äô at the
output of a multiplier than other values. In arithmetic modules
and in sequential state machines, the probability of having a
certain output can be easily computed. A judicious attacker
can use this information to choose an error that is hardly (if
ever) detected.
This paper addresses two questions: a) how good are the
25
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-301-8
DEPEND 2013 : The Sixth International Conference on Dependability

known robust codes, and in particular the Quadratic-Sum
codes and codes derived from the cubic code, against an
adversary that knows the distribution of the codewords, and
b) is it possible to reduce the error masking probability of the
code without adding more redundancy?
The remaining of the paper is organized as follows. Sec-
tion II brieÔ¨Çy describes security oriented codes and presents
the Punctured-Cubic and the Quadratic-Sum codes. Section
III analyzes the worst case scenario. Section IV introduces
methods to avoid this scenario by mapping the set of most
probable words to a predeÔ¨Åned set. An upper bound on the
error masking probability when using this mapping is also
presented. Section V concludes the paper.
II. PRELIMINARIES - SECURITY ORIENTED CODES
A binary code C(n, k) is a subset of size 2k of an n-
dimensional binary vector space Fn
2, (F2
= GF(2)). In
conventional coding theory, codes are designed to provide
reliability against random errors, i.e., errors of low multiplic-
ity. The codes are therefore characterized by their rate (i.e.,
k/n), the minimal distance between the codewords, and the
undetected (random) error probability. All these parameters
are determined by the chosen code; They are indifferent to
the encoding scheme.
In cases where the reliability of the system is the main
concern, a systematic code, that is, a code in which the
information word is embedded in the codeword in its original
form, has an advantage over non-systematic codes since it
simpliÔ¨Åes the decoding procedure and usually has a lower
implementation cost. However, in security oriented coding,
the most important property of a code is its robustness, i.e its
ability to provide immunity against weak attacks. As we show
next, when some codewords are more probable to appear than
others, the encoding (i.e., the mapping between an information
word m ‚àà Fk
2 to a codeword c ‚àà Fn
2) plays a crucial role in
determining the robustness of a code.
A. DeÔ¨Ånition of robustness
Let C be a code and denote by p(c) is the probability that
the codeword c ‚àà C will be used. The robustness of C is
measured in terms of its undetected error probability, which
is also referred to as the error masking probability. The error
masking probability is the probability, Q(e), that a given error
e ‚àà Fn
2 will map a codeword onto another codeword, i.e.,
Q(e) ‚â°
X
c‚ààC
p(c)Œ¥(c ‚äï e)
(1)
where Œ¥(z) is the characteristic function of the code, Œ¥(z) = 1
if z ‚àà C and it equals 0 otherwise.
When the adversary induces an error e one of the following
three scenarios may happen:
1) The error will always be detected (Q(e) = 0). The set
of errors of this type is denoted by Ea.
2) The error will never be detected (Q(e) = 1). Errors that
are never detected form a group. The group, denoted by
Kd, is called the Kernel of the code.
Fig. 3.
The error e1 ‚àà Ea is always detected since C ‚à© {e1 ‚äï C} = ‚àÖ.
The error e2 ‚àà Kd is never detected since C = {e2 ‚äï C}, and e3 is detected
with probability Q(e3) = |C ‚à© {e3 ‚äï C}|/|C|.
3) The error will be detected with probability 0 < 1 ‚àí
Q(e) < 1. That is, there exists at least one codeword that
detects the error, and there exists at least one codewords
that masks it.
The three scenarios are illustrated in Fig. 3.
DeÔ¨Ånition 1 (Robust and partially robust codes): Robust
codes are codes for which the dimension of Kd equals zero,
that is, no attack is masked. Partially robust codes are codes
for which the dimension of Kd is greater than zero but less
than k.
B. The error masking equation
Let C(n, k) be a binary systematic code of length n = k +
r and size 2k. A codeword c ‚àà C(n, k) has two parts: an
information part denoted by x and a redundancy part w, which
is a function of x. Each part can be referred to as an element
of a Ô¨Ånite Ô¨Åeld or as a vector over a Ô¨Ånite Ô¨Åeld. For example,
the information part x can be considered as a binary vector
in k-dimensional space Fk
2; It can be also referred to as an
element of the Ô¨Ånite Ô¨Åeld F2k = GF(2k). For example, the
expression Px3 where P is a r √ó k matrix, has to be read as:
refer to x as an element in F2k and compute x3, then refer to
the result as a vector in Fk
2 and multiply it by the matrix P,
the outcome of this operation is an element in F2r.
Let c = (x, w) ‚àà C be a codeword, where w = w(x). Let
e = (ex, ew) be a nonzero error vector, ex ‚àà F2k, ew ‚àà F2r.
An error is undetected (masked) by the codeword c if c‚äïe ‚àà C.
Equivalently, e is masked by c if
w(x ‚äï ex) = w(x) ‚äï ew.
(2)
Equation (2) is called the error masking equation for
systematic codes. The number of solutions (x‚Äôs) to (2) and
the probability of each determine Q(e). Namely, let X(e) be
the set of x‚Äôs that satisfy this equation,
X(e) = {x|c(x) ‚äï e ‚àà C}.
(3)
Then,
Q(e) =
X
x‚ààX(e)
p(x),
(4)
where p(x) is the probability of the codeword c = (x, w), i.e.,
p(x) = p(c).
26
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-301-8
DEPEND 2013 : The Sixth International Conference on Dependability

The error masking probabilities of C and error masking
probabilities of a coset of C are identical. Therefore, without
loss of generality, we assume that 0 = (0, 0) ‚àà C. Conse-
quently,
Property 1: If 0 ‚àà X(e), then e ‚àà C.
The error masking probability for uniformly distributed
codewords is lower bounded by [6],
Q(e) ‚â• max(2/2k, 2k/2n).
(5)
Codes that achieve this bound are called optimum codes.
C. The Punctured-Cubic code and the Quadratic-Sum code
In this paper, we analyze two robust codes, the Punctured-
Cubic (PC) code derived from the cubic (x, x3) code by
deleting some redundancy bits, and the Quadratic-Sum (QS)
code. Both codes are robust systematic codes of rate higher
than one-half [1], [4], [7]. Moreover, both codes are optimum
or close to optimum.
Construction 1 (Punctured-Cubic code [1]):
Let P be a binary r √ó k matrix of rank r ‚â§ k. The code
C = {(x, w) : x ‚àà F2k, w = Px3 ‚àà F2r}
(6)
is called a Punctured Cubic C(k + r, k) code.
The error masking equation of the PC code is
P(x ‚äï ex)3 = Px3 ‚äï ew.
(7)
Construction 2 (Quadratic-Sum code [4]):
Let k = 2sr and x = (x1, x2, ¬∑ ¬∑ ¬∑ x2s), where xi ‚àà F2r for
1 ‚â§ i ‚â§ 2s. The code
C = {(x, w) : x ‚àà F2k, w = x1x2 ‚äï ¬∑ ¬∑ ¬∑ ‚äï x2s‚àí1x2s ‚àà F2r}
(8)
is called a Quadratic-Sum C(k + r, k) code.
The error masking equation for the QS code is
s
X
i=1
(x2i‚àí1 ‚äï ex,2i‚àí1)(x2i ‚äï ex,2i) =
s
X
i=1
x2i‚àí1x2i ‚äï ew.
(9)
D. The robustness of the PC and QS codes under uniform
distribution
If the codewords are uniformly distributed, then each code-
word may appear on the output with probability of 1/|C|. The
worst case error masking probability under uniform distribu-
tion of the codewords is denoted by Qmc. The subscript mc
stands for maximal correlation, since in this case
Q(e) = R(e)
R(0),
(10)
and,
Qmc = maxeÃ∏=0 R(e)
R(0)
,
(11)

	
	

	
	
	
	
	

	
	
	


























	


Fig. 4.
A mathematical model of a computation channel protected by a
one-to-one mapping œï followed by a systematic error detecting code C.
where R is the autocorrelation function of Œ¥, that is,
R(e) =
X
z‚ààFn
2
Œ¥(z)Œ¥(z ‚äï e).
(12)
The error masking probabilities of the PC and QS codes are
the following:
Theorem 1 ( [7]): Let C be a PC code deÔ¨Åned by a binary
r √ó k matrix P of rank r > 1, Then the kernel of the code is
of dimension 0. For odd values of k, Qmc = 2‚àír+1. For even
values of k, there exist P matrices for which Qmc = 2‚àír.
Theorem 2 ( [4]): Let C be a QS code. Then the kernel of
the code is of dimension 0. For k = 2sr, the error masking
probability is Qmc = 2‚àír.
III. THE WORST CASE SCENARIO
Consider a computation channel that produces each cycle
an output vector m ‚àà Fk
2. Let œï be a one to one mapping
between m and an information word x, i.e., x = œï(m). To
provide immunity, each cycle a codeword c = (x, w(x)) is
generated from the information word x (as shown in Fig. 4).
The probability that a codeword c(x) = c(œï(m)) is used
equals to the probability that the output m is produced, that
is,
p(c) = p(x) = p(m).
(13)
Since for a given code, X(e) is Ô¨Åxed, and
Q(e) =
X
x‚ààX(e)
p(x) =
X
m, œï(m)‚ààX(e)
p(m),
(14)
the error masking probability under non-uniform distribution
of the outputs depends solely on œï.
The following lemma provides a lower bound on the error
masking probability when the worst œï is used. In the next
27
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-301-8
DEPEND 2013 : The Sixth International Conference on Dependability

section we show that if one uses a œï that maps the most
probable vectors m to a predeÔ¨Åned set S, s/he can reduce the
error masking probabilities.
Without loss of generality assume that
1 ‚â• p(m1) ‚â• p(m2) ‚â• ¬∑ ¬∑ ¬∑ ‚â• p(m2k) ‚â• 0
(15)
and
2k
X
i=1
p(mi) = 1.
(16)
Consider the mapping xi = mi. For this mapping we have,
1 ‚â• p(x1) ‚â• p(x2) ‚â• ¬∑ ¬∑ ¬∑ ‚â• p(x2k) ‚â• 0.
(17)
Denote by P(S) the accumulated probability P
xi‚ààS p(xi) and
assume that there is a set S ‚äÜ Fk
2 for which P(C \ S) is
negligible. In the worst case scenario there exists an error e
such that either S ‚äÜ X(e) or X(e) ‚äÇ S. Namely,
Lemma 1: The worst case error masking probability, Qwc,
is lower bounded by
Qwc ‚â•
Ô£±
Ô£¥
Ô£≤
Ô£¥
Ô£≥
P(S)
|S| ‚â§ Qmc2k
Qmc2k
|S|
P(S)
otherwise
(18)
Example 1: Let k = 3 and r = 1. The eight codewords
of the corresponding PC code (represented by their integer
values) are
(0, 0), (1, 0), (2, 0), (3, 1), (4, 1), (5, 1), (6, 1), (7, 0).
(19)
Table I shows the X(e) of each error vector.
TABLE I
THE ERROR VECTORS AND THEIR MASKING CODEWORDS
e
|X(e)|
X(e)
(0,0)
8
all x‚Äôs
(0,1)
0
-
(1,0)
4
0,1,4,5
(1,1)
4
2,3,6,7
(2,0)
4
0,2,4,6
(2,1)
4
1,3,5,7
(3,0)
4
1,2,5,6
(3,1)
4
0,3,4,7
(4,0)
0
-
(4,1)
8
all x‚Äôs
(5,0)
4
2,3,6,7
(5,1)
4
0,1,4,5
(6,0)
4
1,3,5,7
(6,1)
4
0,2,4,6
(7,0)
4
0,3,4,7
(7,1)
4
1,2,5,6
The rows of the table are written in pairs. In each pair, one
error vector is a codeword and the second is a non-codeword.
By Prop. 1, an error vector whose X(e) contains the all-zero
word, is a codeword. It is clear from the table that the code
is partially robust since the non-zero error (4, 1) is masked
by all codewords. However, all the remaining error vectors
are either always detected or they are masked by half of the
codewords. Therefore, for uniformly distributed codewords,
Qmc(e) = 0.5. Although this paper deals with robust codes, to
simplify the presentation, we assume that the adversary cannot
induce the error (4, 1). This assumption allows us to use the
C(4, 3) partially robust PC code.
Assume now that the m‚Äôs are not uniformly distributed,
p(m) =
Ô£±
Ô£≤
Ô£≥
(1 ‚àí «´)/5
m ‚àà {2, 3, 4, 6, 7}
«´/3
otherwise
(20)
If no mapping is used (i.e., xi = mi), then a judicious at-
tacker would apply the error (5, 0) whose corresponding error
masking probability is the maximal, Q((5, 0)) =
4
5(1 ‚àí «´).
However, a Gray code can reduce the worst case error masking
probability. A Gray code maps m = (mk‚àí1, . . . m0) to x =
(xk‚àí1, . . . x0) as follows: xi = mi+1 ‚äïmi for i = 0, . . . k ‚àí1
where mk = 0. In our case, the highly probable m‚Äôs are
mapped to the set S = {2, 3, 4, 5, 6}, and the worst case error
masking probability becomes 3
5(1 ‚àí «´). As we show next, no
better mapping can be found.
IV.
CONSTRUCTIVE UPPER BOUNDS ON THE ERROR
MASKING PROBABILITY
For uniformly distributed codewords, the error masking
probability of the PC and the QS codes is upper bounded
by Qmc. Therefore, any error vector is masked by at most
2kQmc codewords. Consequently, if the size of S, is greater
than 2kQmc, then any error will be detected with probability
of at least
1 ‚àí 2kQmc
|S|
P(S) > 0.
(21)
Obviously, if the size of S is smaller than that, the probability
that the error will be masked increases. In what follows we
discuss the case where
|S| ‚â§ min
eÃ∏=0 |X(e)|,
(22)
and present mappings for which any nonzero error will never
be masked.
A. SufÔ¨Åcient conditions for Q < 1
In cases where |S| = 2, no mapping can help; An adversary
who knows the two most probable outputs, say m1 and m2,
and the mapping œï may choose an error
e = c(œï(m1)) ‚äï c(œï(m2)),
(23)
for which Q(e) ‚â• P(S) = 1 ‚àí «´.
The following theorem suggests a lower bound on the size
of S for which there exists a mapping that can reduce Q(e).
Theorem 3: Let C be a PC or a QS code. Then, there exists
at least one set S of size s,
k + 1
‚àílog2(Qmc) + 1 ‚â§ s ‚â§ min(2kQmc, 2k‚àí2),
(24)
such that S \ X(e) Ã∏= œÜ for all non-zero e.
28
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-301-8
DEPEND 2013 : The Sixth International Conference on Dependability

Example 2: Let k = 16 and r = 4. Assume that twenty
vectors (out of the 216) may appear with probability 1 ‚àí «´ at
the output of the device to be protected. Since there exists an
error for which min(|X(e)|) = 212, and 20 << 212, in the
worst case scenario the error will not be noticed. For a PC
code we have,
16 + 1
4 ‚àí 1 + 1 ‚â§ |S| = 20 ‚â§ min(213, 216‚àí2).
(25)
therefore, by Theorem 3, there exist a subset S of twenty
vectors such that any error is detected with probability of at
least 1‚àí«´
20 .
Although Th. 3 states that it is possible to Ô¨Ånd a set that
can detect any error, it does not provide an efÔ¨Åcient way to
do so. In the following sections we introduce two mappings,
i.e., two sets, for which any non-zero error can be detected.
B. Generalized Hamming ball mapping
We deÔ¨Åne a generalized Hamming ball as follows:
DeÔ¨Ånition 2: Let V = {vi}u
i=1 ‚äÇ Fk
2 be an arbitrary set
of u, u ‚â§ k, linearly independent vectors. A generalized
Hamming ball B(u,w) ‚äÜ Fk
2
is a set (or a coset of a set)
that consists of the vectors
( u
X
i=1
aivi | a = (au, . . . a1) ‚àà Fu
2, wtH(a) ‚â§ w
)
(26)
where wtH(a) stands for the Hamming weight of a.
Theorem 4: Let C be a PC or a QS code. Let S ‚äÜ B(u,w)
where u ‚â• k + log2(Qmc) + 1 and w is the smallest integer
such that Pw
j=0

C. Robust-code based mapping
The following theorem states that if the elements of S are
the codewords of a robust code, then a nonzero error is never
masked.
Theorem 6: Let C be a PC or a QS code of dimension k,
r redundancy bits, and error masking probability Qmc. Let S
be a robust code of length ÀÜn = k, dimension ÀÜk = u and error
masking probability ÀÜQmc. Then, the error masking probability
of C is
Q(e) ‚â§
q
2 ÀÜQmcQmc2k‚àíu.
(33)
Corollary 2: Let C be a PC or a QS code of dimension
k, r redundancy bits, and error masking probability Qmc. Let
S be a subset of a robust code of length k, dimension u =
‚åàlog2(|S|)‚åâ and error masking probability ÀÜQmc. Then,
Q(e) ‚â§
q
Qmc2k( ÀÜQmc2u + 1)
|S|
.
(34)
Corollary 3: Let C be a PC or a QS code of dimension k,
r redundancy bits. Let S be a QS code of dimension u and
k ‚àí u redundancy bits. Then we have,
Q(e) ‚â§
p
2 ¬∑ 2‚àí(k‚àíu) ¬∑ 2‚àír+1 ¬∑ 2k‚àíu ‚â§ 2
‚àír+2
2
.
(35)
Example 4: As before, let k = 16, r = 4 and assume that
400 output vectors may appear with probability 1 ‚àí «´. Here
again, in the worst case scenario we have Q(e) ‚â• 1‚àí«´. DeÔ¨Åne
S to be a subset of a C(ÀÜn = k = 16, ÀÜk = u = 9, ÀÜr = k‚àíu = 5)
PC code with ÀÜQmc = 2‚àí5+1. Then,
Q(e) ‚â§
‚àö
2 ¬∑ 2‚àí4 ¬∑ 2‚àí3 ¬∑ 25 = 0.707.
(36)
Note that in this case, the construction suggested in Th. 4
provides Q(e) ‚â§ 378
400 = 0.945.
The following example shows the relation between the
three upper bounds on the error masking probability when
a mapping is applied.
Example 5 (Concluding example): Consider a PC code of
dimension k = 16 and r = 4 redundancy bits. Assume that
the |S| most probable words are mapped to a set S, and that
p(x) =
(
1‚àí«´
|S|
x ‚àà S
«´
2k‚àí|S|
x /‚àà S
.
(37)
The efÔ¨Åciency of the mapping, i.e., the error masking
probabilities that can be achieved by using the suggested
mappings, is shown in Fig. 6.
The
X-axis
is
the
size
of
S
and
the
Y -axis
is
maxeÃ∏=0(Q(e)). The black line represents a lower bound on
worst case scenario (Lemma 1). The other lines represent
upper bounds on Q(e). The red line is the bound presented in
Theorem 4, the blue line is the bound presented in Theorem
3, and the green line is the bound in Corollary 2.
10
0
10
1
10
2
10
3
10
4
0
0.2
0.4
0.6
0.8
1
k=16  r=4
Fig. 6.
Error masking probability of punctured cubic code with k = 16 and
r = 4 as a function of |S|.
V. CONCLUSIONS
The Punctured-Cubic code and the Quadratic-Sum code are
systematic robust codes designed for uniformly distributed
codewords. The codes can detect any error with non-zero
probability regardless its multiplicity. In cases where the
codewords are not equally likely to appear, the performance
of the codes degrades signiÔ¨Åcantly and the robustness may
vanish. The paper addresses this problem. It is shown that by
mapping the most probable data patterns to a predeÔ¨Åned set
before the encoding, it is possible to signiÔ¨Åcantly reduce the
error masking probability and maintain the robustness of the
codes.
ACKNOWLEDGMENT
The work of the Ô¨Årst two authors was supported by the Israel
Science Foundation (ISF) grant No. 1200/12. The work of the
third author was supported by the NSF Grant CNS 1012910
REFERENCES
[1] N. Admaty, S. Litsyn, and O. Keren, ‚ÄùPunctuating, Expurgating and
Expanding the q-ary BCH Based Robust Codes‚Äù, The 27-th IEEE
Convention of Electrical and Electronics Engineers in Israel, 2012, pp.1‚Äì
5.
[2] H. Bar-El, H. Choukri, D. Naccache, M. Tunstall, and C. Whelan, ‚ÄùThe
sorcerers apprentice guide to fault attacks‚Äù, Vol.94, No.2, 2006, pp.370‚Äì
382.
[3] S. Engelberg and O. Keren, ‚ÄúA Comment on the Karpovsky-Taubin
Code,‚Äù IEEE Trans. Info. Theory, Vol. 57, No. 12, 2011, pp. 8007‚Äì8010.
[4] M.G.Karpovsky, K. Kulikowski, and Z. Wang, ‚ÄùRobust Error Detection
in Communication and Computation Channels‚Äù Keynote paper in the Int.
Workshop on Spectral Techniques, 2007.
[5] M. G. Karpovsky and P. Nagvajara, ‚ÄùOptimal Codes for the Minimax
Criterion on Error Detection,‚Äù IEEE Trans. on Information Theory, Vol.
35, No. 6, November 1989, pp. 1299‚Äì1305.
[6] M.G.Karpovsky and A. Taubin, ‚ÄúA New Class of Nonlinear Systematic
Error Detecting Codes,‚Äù IEEE Trans. Info. Theory, Vol 50, No.8, 2004,
pp.1818‚Äì1820.
[7] Y. Neumeier and O. Keren, ‚ÄùPunctured Karpovsky-Taubin Binary Robust
Error Detecting Codes for Cryptographic Devices,‚Äù IEEE International
On-Line Testing Symposium, March 2012, pp.156‚Äì161.
[8] S. P. Skorobogatov, ‚ÄùSemi-Invasive Attacks - a New Approach to Hard-
ware Security Analysis‚Äù Technical Report, University of Cambridge.
Number 630.
[9] I. Shumsky and O. Keren, ‚ÄùSecurity-Oriented
State Assignment‚Äù,
TRUDEVICE, 1‚Äôst Workshop on trustworthy manufacturing and utiliza-
tion of secure devices, 2013.
[10] I. M.R. Verbauwhede(Ed.), Secure Integrated Circuits and Systems,
Springer, 2010.
[11] Z. Wang, M. G. Karpovsky, and K. Kulikowski, ‚ÄúDesign of Memories
with Concurrent Error Detection and Correction by Non-Linear SEC-
DED Codes‚Äù Journal of Electronic Testing, Vol. 26, No. 5, Oct 2010,
pp.559‚Äì580.
30
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-301-8
DEPEND 2013 : The Sixth International Conference on Dependability

