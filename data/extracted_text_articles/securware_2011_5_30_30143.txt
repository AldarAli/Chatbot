Enhancing System-Called-Based Intrusion Detection with Protocol Context
Anyi Liu∗, Xuxian Jiang†, Jing Jin∗, Feng Mao‡, and Jim X. Chen∗
∗Department of Computer Science
George Mason University, Fairfax VA 22030
Email: aliu1, jjin3, jchen@gmu.edu
†North Carolina State University
Raleigh, NC 27695
Email: jiang@cs.ncsu.edu
‡EMC
Santa Clara, CA 95054
Email: fengmao@acm.org
Abstract—Building an accurate program model is chal-
lenging but vital for the development of an effective host-
based intrusion detection system (IDS). The model should be
designed to precisely reveal the intrinsic semantic logic of a
program, which not only contains control-ﬂows (e.g., system
call sequences), but also data-ﬂows as well as their inter-
dependency. However, most existing intrusion detection models
consider either control-ﬂows or data-ﬂows, but not both or their
interweaved dependency, leading to inaccurate or incomplete
program modeling. In this paper, we present a semantic ﬂow-
based model that seamlessly integrates control-ﬂows, data-
ﬂows, as well as their inter-dependency, thus greatly improv-
ing the precision and completeness when modeling program
behavior. More speciﬁcally, the semantic ﬂow model describes
program behavior in terms of basic semantic units, each of
which semantically captures one essential aspect of a program’s
behavior. The relationship among these semantic units can be
further obtained by applying the protocol knowledge behind
the (server) program. We show that the integrated semantic
ﬂow model enables earlier detection and prevention of many
attacks than existing approaches.
Keywords-Intrusion detection; System calls; Protocol speciﬁ-
cation; Context.
I. INTRODUCTION
Building an accurate program model is challenging but
vital for the development of an effective host-based intrusion
detection system (IDS). A strict model will likely generate
alerts with high false positives while a loose model might
not detect any advanced evasive attacks. To improve the
detection accuracy, a number of models [4], [5], [12] have
been proposed to precisely capture the intrinsic semantic
logic of a program. Particularly, due to the efﬁciency and
convenience in collecting system call logs as well as rich
semantics of collected logs, system calls have been widely
leveraged to build program models. For example, Forrest et
al. [7] uses normal system call sequences to model program
behavior and considers any violation as an intrusion; Gao et
al. [5] applies a gray-box approach to reconstruct program
execution graph and is able to detect anomaly system call
sequences when any inconsistency is observed; Sekar et al.
[1] leverages system call arguments to obtain a model that
describes the inherent data-ﬂow dependency.
From another perspective, note that a program’s seman-
tic logic usually contains control-ﬂows (e.g., system call
sequences), data-ﬂows (e.g., system call argument rela-
tionships), and their inter-dependency. However, existing
techniques consider either control-ﬂows or data-ﬂows, but
not both, resulting in an inaccurate or incomplete program
modeling. This weakness could be potentially exploited by
advanced attackers to avoid their detection. For example,
Wagner et al. [13] demonstrates that the mimicry attack can
effectively evade the detection from system call sequence-
based models and related IDSes.
To address the weakness, we present a new semantic ﬂow-
based model that naturally integrates control-ﬂows, data-
ﬂows, and their inter-dependency. Different from previous
program models, the semantic ﬂow model describes program
behavior in terms of basic semantic units. With collected
system call sequences, arguments, as well as related run-
time context information, each semantic unit semantically
describes one essential aspect of a program’s behavior. In
addition, with the protocol knowledge behind the (server)
program, the interweaved dependency among these semantic
units can be naturally extracted and modeled. For example,
the possible data-control relation describes the dependency
from system call arguments to subsequent system calls and
the data-data relation reveals the inherent semantic depen-
dency among different system call arguments. Speciﬁcally,
when compared with existing approaches, our semantic ﬂow
approach has the following three key advantages: (1) Logical
integration of control-ﬂows and data-ﬂows. (2) Protocol-
aware semantic analysis. (3) Early and accurate detection.
We have applied the semantic ﬂow model to characterize
most popular server programs (e.g., httpd and ftpd).
For each one of them, we are able to observe those basic
semantic units and then construct their semantic relations.
The experimental results with real world attacks, including
both control-ﬂow and data-ﬂow exploits, show that the
semantic ﬂow model can immediately detect them once any
violation to the normal semantic ﬂow model occurs, result-
ing in much earlier detection and prevention than existing
approaches. We believe that the semantic ﬂow model holds
great promise for more precise and complete host-based
intrusion detection.
103
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

II. RELATED WORK
To construct a program behavior-based anomaly detection
model, various approaches have been proposed. Starting
from the work of Forrest et al. [7], the black-box ap-
proaches
[12], [13] model the normal program behavior
(e.g., based on system calls) and then detect intrusions
by identifying anomaly within observed system calls. The
white-box approaches apply static analysis on either source
code [9], [14] or binary
[6] to build program models.
And the gray-box approaches further leverage the program
runtime information to improve the accuracy of anomaly
detection models
[2], [4], [5]. Our work is more closely
related to data-ﬂow anomaly detection [1], which examines
inherent data-ﬂow dependencies among system call argu-
ments to make the model more robust. However, none of
the previous works utilizes protocol knowledge behind the
modeled program, which inspires our work to fully exploit
the semantic meanings of system call arguments and build
semantic dependencies among extracted semantic units. Our
approach makes one step further and allows to derive more
complicated semantic dependencies, e.g., data → control
and control → data relations. As such, our approach enables
the construction of more accurate and complete program
models for anomaly detection.
III. AN ILLUSTRATIVE EXAMPLE
In this section, we illustrate the semantic ﬂow model with
a representative example, i.e., the Apache web server. For
each incoming web request, we can divide the corresponding
Apache behavior (or the httpd worker daemon) into the
following four logical phrases: (1) The Apache server waits
for a client request, and prepares a worker thread. (2) The
worker thread handles the request and process it. (3) The
server generates response for the incoming request. (4) After
the response is sent back to the clinet, the network socket
used for the communication is closed.
Figure 1 shows the Apache behavior when answering an
incoming request, both from a network/OS viewpoint as
well as the semantic ﬂow viewpoint. Speciﬁcally, Figure
1(a) contains a list of invoked system calls as well as
their arguments while Figure 1(b) highlights some inherent
dependencies within these system calls and their arguments.
Instead of syntactically grouping adjacent system calls into
sequences or mining arguments for possible relationships,
the semantic ﬂow model aims to leverage the protocol logic
that has been implemented by the modeled program to
characterize its behavior. In addition, we can verify the
program logic by reconstructing the implemented protocol
with semantic-sensitive information from observed system
calls, arguments, or other run-time context information.
The above example illustrates system calls and arguments
are strongly connected. The key to obtain their relationships
lies in protocol-aware semantic analysis. Partial analysis on
system call sequences or arguments without knowing their
semantic implications will lead to incomplete and imprecise
program modeling.
Session 
Assmbler
Protocol 
Specification
Model 
Generator
Semantic 
Flow Model
Detection 
Results
Networking 
Payload
Tainter
System 
Calls
Enhanced Anomly Detection 
System
Figure 2.
Overview of semantic ﬂow model
IV. DESIGNING SEMANTIC FLOW MODEL
A. Terminologies
In this section, we ﬁrst deﬁne the terminologies that will
be used throughout this paper.
• We denote the set of system calls and the set of system
call arguments as C = {ci | 1 ≤ i ≤ m} and A = {ai |
1 ≤ i ≤ n}, respectively. For simplicity, the return
value of a system call will be considered as one of its
arguments. We also represent the control-ﬂow relation
Rc on C as Rc ⊆ C ×C and the data-ﬂow relation Rd
on A as Rd ⊆ A × A. Note that existing models that
are built upon {C, Rc} fall into the control-ﬂow model
category and others built based on {A, Rd} belong to
the data-ﬂow model category.
• We log system calls and save them as a record in the
form of sc = {n, A}, in which sc.n is the name of
the system call, sc.A is the set of arguments. When
processing system calls, we simply consider them as
an array sc. An argument sc[i].aj ∈ A is assigned
by a value and a semantic type, which denoted as
sc[i].aj.value, and sc[i].aj.type, respectively.
• The semantic set Ssem is the super set of system
calls and arguments and can be simply represented as
Ssem = 2C∪A. The semantic relation Rs on Ssem
is similarly denoted as Rs ⊆ Ssem ×
Ssem. We
call models build upon {Ssem, Rs} as semantic ﬂow
models.
B. System Overview
Figure 2 shows our semantic ﬂow-based intrusion de-
tection model, which has three main components: (1) The
session assembler propagate tainted networking payload to
invoked system calls within a networking session (Sec-
tion V-A); (2) The protocol selector leverages protocol
knowledge and matches semantic units with pre-deﬁned
protocol speciﬁcation (Section V-B); (3) The semantic ﬂow
model generator will reconstruct semantic relations among
semantic units and build the program behavior model as
the corresponding semantic ﬂow model (Section V-C). The
doted line circulated the major components.
V. METHODOLOGY
A. Networking Input Propagation
To correlate the networking trafﬁc with system calls and
their arguments, we use tain techniques, which have been
discussed in [11], [15]. Speciﬁcally, we initially taint the
string in packet payload received by networking-related
104
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

Server
Send the file content
Ack
Network  View
OS View
Client
Request a file
Wait for a request
Handle the request
Close connection
Send the response
1. accept (socket m) = s1
2. getsockname(s1)=0
3. getsockopt (s1)=0
4. read (s1, Message1)=sizeOf(Message1)
5. stat (“index.html”, T2)=0
6. open (“index.html”, RD)=fd1
7. mmap (fd1)=add1
8. close (fd1)
9. select(s1, RD)=0
10. write (s1, Message2)=sizeOf(Message2)
12. shutdown(s1, SHUT_WR)=0
13. read (s1, Buffer)=0
14. close (s1)
11. write(fd2, Log)=sizeOf(Log)
(a) Network and OS views
If  (method == ‘GET’) 
Message2.Code = 200 (OK)
Message2.Connection=Close
Message2.Length =  file_size
System calls (9-10): Send the Response
System calls (1-4): Wait for Request 
stat.filename 
=  file_name
IF (stat.modify_time >= modify_time) {
           file_size
  stat.filesize 
          open.filename =  file_name
          mmap.length =  file_size
}
System calls (5-8): Handle the Request
If  (stat.modify_time          
     >= modify_time) 
file_name
 Message1.URI 
modify_time 
Message1.Last_Modified
Shutdown.method =SHUT_WR
IF( Message.Co
nnection=close)
System calls (12-14): Close the Connection 
Log.Code = Message2.Code
Log.Content_Length = file_size
System calls (11): Write to Local Log 
(b) Semantic dependencies between system calls
Figure 1.
The simpliﬁed network/OS view (left) and the semantic ﬂow (right) of Apache when answering an incoming request. In the OS view, the
recorded system calls are sequentially labeled (some of them are omitted for readability). The semantic ﬂow highlights some inherent dependencies among
invoked system calls and their arguments.
system calls, such as sys socket. We also instrument the
data movement instructions (e.g., mov) and arithmatic/logic
instruction (e.g., add, mul, and), such that the tainted
string can be propagated through the lifetime of string
processing. For a data movement instruction, we check
whether the source operand is marked. If yes, we will
annotate the destination operand, which can be a register
or a memory location, with the source operand’s annotation,
i.e. its offset in the original message. If the source operand is
not marked, we will simply unmark the destination operand.
If two marked operands appear in the same instruction, we
will union their annotations (e.g., for the add operation, the
result is the union of the operands if they are both marked).
Then, we need to re-map system call arguments based on
semantic types, based on the protocol speciﬁcation. Semantic
types are used to more precisely capture the semantic mean-
ing of system call arguments as they cannot be naturally
obtained from the original argument types according to the
neutral system-wide system call convention. An an example,
the ﬁrst argument of the open system call, which originally
deﬁned as a string, is now redeﬁned as the Filename
semantic type. Its return value will be similarly redeﬁned
as the semantic type FileDescriptor, instead of int.
Name
Filename
Flag
FileDescriptor
open
‘‘/etc/passwd’’
‘‘RD’’
6
Besides the knowledge of system call convention, we
further use protocol speciﬁcation to extend our knowledge
of semantic meaning. We used the technique in [10] to dis-
cover protocol formatting speciﬁcation. In the following, we
illustrate the snippet of SERVICE_REQUEST speciﬁcation
for the HTTP protocol.
<SERVICE_REQUEST>
SYSCALL = Read(FD, BUFFER, RET)
FD = %Accepted_Socket
BUFFER =((GENERAL_HEADER|REQUEST_HEADER)\13\10)*\13\10
GENERAL_HEADER = %Method %URI %Dummy\13\10
REQUEST_HEADER = From|Host|If-Match|Last-Modified...=\%VALUE
RET = sizeOf(BUFFER)
Recall the read system call in the line 4 of Figure 1(a). We
can capture its semantic meaning with the above protocol
speciﬁcation. More speciﬁcally, the ﬁle descriptor equals
to the accepted socket number after accepting the incom-
ing request. The argument BUFFER contains two ﬁelds,
GENERAL_HEADER and REQUEST_HEADER, each of them
can be further parsed into various sub-ﬁelds and eventually
casted into more speciﬁc semantic types. For example, the
REQUEST_HEADER ﬁeld can be analyzed based on the
following format:
From: Type = Email, Format = %username@%hostname
Host: Type = IP|Host_Name, Format = %{4B}|String
Last-Modified: Type = Date, Format = Timestamp
The ﬁrst line states that the From ﬁeld should be parsed
as an email address. The second line speciﬁes that the Host
ﬁeld should be deﬁned as an IP address or a host name. The
third line is to deﬁne the type of Last-Modified ﬁeld
as the default timestamp format.
B. Algorithm for Constructing Semantic Units
To describe the high-level functionalities of a networking
protocol, we introduce the concept of user session S to rep-
resent a execution path of one server program, and semantic
unit U, which intended to capture one essential aspect of
modeled program behavior. As an example, the accept
and the close system call are the starting point and the
ending point of the user session shown in Figure 1. Semantic
units comprises of a number of system calls, their arguments,
as well as return values. In our current implementation, we
organize semantic units from adjacent system calls based on
whether they share the same ﬁle descriptors, ﬁlenames, or
network sockets. In other words, adjacent system calls that
manipulate the same ﬁle descriptor, ﬁlename, or network
socket will be grouped to the same semantic unit. For
example, the following system call sequence is a semantic
unit as the three system calls open, read, and close are
105
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

used to access a ﬁle named “/etc/passwd” by referring to
the same ﬁle descriptor.
open("/etc/passwd", RD)=6,
read(6, buf)=123,
close(6)=0
Algorithm 1: SemanticUnitExtraction(sc, U)
input : A system call sc, and the semantic unit
array U.
output: The updated array of semantic units U.
begin
for i=1 to N do
for j=1 to M do
if sc.ai.type = U[i].aj.type and
sc.ai.value = U[i].aj.value then
U[no of su] = UNION(U[i], sc);
break;
else
no of su++; instantiate
U[no of su];
U[no of su] = sc;
break;
end
With collected system calls, our algorithm SemanticU-
nitExtraction(sc, U) groups them into different semantic
units. The algorithm works as follows: It maintains a global
variable no of su (initialized with 0) that keeps the current
number of semantic units in S. For each collected system
call sc, the algorithm will be check whether it is a member
of the existing semantic unit U[no of su]. If yes, it will be
added to U[no of su] (via the UNION(U[i], sc) function)
and the global variable remains intact. Otherwise, a new
semantic unit will be created and the no of su will be
incremented by 1. We need to point out that adjacent
system calls manipulate the same ﬁle descriptors, ﬁle names,
or sockets will be grouped into the same semantic unit.
However, not all system calls that manipulate the same ﬁle
descriptor, ﬁlename, or socket will be included into the same
semantic unit. This design choice makes the Algorithm 1
easy to implement.
Example 1 We illustrate the algorithm by revisiting the
simpliﬁed httpd case in Section III. First, when the ﬁrst
system call – accept – is encountered, it will be included
in a new semantic unit U1. The following three system calls
(at line 2-4) will also be grouped into the same semantic unit
U1 as they essentially wait for (and then receive) incoming
requests and manipulate the same socket (as the accept
system call). After that, the stat system call at line 5 will
start with a new semantic unit U2 as it is not related to
the previous socket, and their main purpose is to handle the
request. Moreover, since the following system calls at lines
6-8 handles the same ﬁle named “index.html” with the stat
system call, they will join with the second semantic unit
because they send back the response to the requesting client.
In a similar manner, system calls at line 9-10 (U3) send back
the response to the requesting client; the requesting behavior
is locally recorded at line 11 (U4); and the communication
channel is ﬁnally shutdown and closed at lines 12-14, U5).
C. Constructing Semantic Speciﬁcation
Different from previous approaches that solely depend on
either control-ﬂow or data-ﬂow relations, a semantic relation
ﬂow Rs covers the inter-dependencies between them. In
this paper, we focus our semantic ﬂow relations in three
categories: Data → Control, Data → Data, and Control →
Data, which illustrate in Table I.
VI. EVALUATION
We have implemented a proof-of-concept system that runs
on the Fedora 13. The system calls, arguments, and return
values are collected with a customized loadable Linux kernel
module (LKM). The experiments are performed on a PC
with Intel Core 2 Due 2.83GHZ CPU and 2G physical
memory.
A. Effectiveness
We evaluate the effectiveness of our approach with a
number of real-world attacks that are publicly obtained from
[3]. Table II contains the list of ﬁve experimented server
programs as well as attacks exploiting their vulnerabilities.
Within these attacks, two of them are control-ﬂow attacks
which directly hijack the control ﬂow of vulnernable pro-
grams, while the other three are data-ﬂow attacks that are
able to manipulate security-critical data to evade traditional
detection techniques. Since server programs of wu-ftpd
and ghttpd are vulnerable to both control-ﬂow and data-
ﬂow attacks, we simply use a subscript to differentiate them.
For instance, we use wu-ftpd1 to represent the control-ﬂow
attack and wu-ftpd2 to represent the data-ﬂow attack against
wu-ftpd.
In the following, we use three examples to show that how
the three types of semantic relations, i.e., Data → Control,
and Data → Data are used to detect attacks.
Data → Control Violation Detection All versions of wu-
ftpd before 2.6.1 contain a vulnerability that can be exploited
to trigger a heap corruption vulnerability (CVE-2001-0550).
The vulnerability is located in the ftpglob function, which
fails to properly handle the FTP commands and consequently
allows remote attackers to execute arbitrary commands via
a ∼ { argument [16].
Figure 3(a) shows the related semantic ﬂow speciﬁcation
that will be violated by this attack. More speciﬁcally, there
exist three related semantic units for the exploited wu-ftpd
sub-session. The ﬁrst semantic unit receives the command
request from the client and interprets it to be a CWD
command. The following semantic unit will actually execute
the CWD command by invoking the chdir system call. The
return value of chdir will determine the code ﬁeld that
will be later sent back to the client in the third semantic
unit. The code ﬁeld essentially notiﬁes the client whether
the operation is successful or not.
Our approach detected this attack when the server sent
its response to the client via a write system call. Based
on the ftp protocol, the raw command CWD pathname
106
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

Category
Subcategory
Meaning
Example
Single data to control relations
Relations that a single argument determines fol-
lows system calls
In ftp protocol, the argument CWD determines system call
chdir
Data → Control
Multiple data to control relations
Multiple arguments together determine system
calls later
The readfds and writefds arguments of select system call
determine the following read or write system call
Number of loops relations
Relations that arguments determine the number
of system calls that will appear later
The argument st_size of system call stat determines the
number of write system calls be invoked later
Logical relations
Relations that a single argument might deter-
mine future system calls
The return value of -13 (meaning Permission denied) of
open determines the error code 304 in the reply buffer.
Data → Data
Numeric relations
Relations that evaluate two numeric values v1
and v2
LargerThan(v1, v2), SmallerThan(v1, v2), EqualTo(v1, v2)
Timing relations
Relations evaluate two timing values d1 and d2
Before(d1, d2), After(d1, d2), and At(d1, d2)
Control → Data
Relations determine system calls to system call
arguments
The system call write determines certain keywords in the
reply buffer, such as Code, Connection, and Length
Table I
SEMANTIC RELATIONS Rs IN OUR FRAMEWORK
Program
Reference
Attack description
Program
Total # of
# of system calls
Violation
(version)
size(KB)
system calls
in attack session
wu-ftpd1(2.6.1)
CVE-2001-0550
Heap corruption allows execute arbitrary commands via
2916
1372
2
Data → Control
a ∼ { argument to commands
ghttpd1(1.4)
CAN-2001-0820
Long arguments passed to the Log function in util.c
311
27
20
Data → Control
allows attackers to get shell
wu-ftpd2(2.6.0)
S.Chen et al. [3]
Format string overwrite user ID
2916
15754
8
Data → Data
ghttpd2(1.4)
S.Chen et al. [3]
Stack overﬂow to overwrite backup value of ESI
311
105
14
Control → Data
null-httpd(0.5)
S.Chen et al. [3]
Two POST commands corrupt CGI-BIN conﬁgure string
806
230
72
Data → Data
Table II
VULNERABLE SERVERS AND REAL-WORLD ATTACKS USED IN OUR EVALUATION
allows the client to change the current working directory
to pathname. As such, in our semantic ﬂow speciﬁcation
(Figure 3(a)), the semantic unit U2 will invoke the system
call chdir. After invoking the chdir, the server will
notify the client with the return code either 250(indicating
“the CWD command is successful”), or 550(meansing “No
such ﬁle or directory”).
When considering the actual attack sequence, it violates
at least twice our semenatic ﬂow speciﬁcations: First, there
does not exist a subsequent chdir system call. Second, the
response message will usually contain return code of 250 or
550. For previous approaches that detect control injection
attacks, the same attack could be detected when the attack
invokes the execve system call to obtain a command shell
(“/bin/sh”), which is much later than the detection point by
our approach. Figure 3(b) shows the difference between the
detection point by our approach and the detection point by
other approaches.
Data → Data Violation Detection
The same wu-ftpd
server (versions 2.6.0 and earlier) contains another vulner-
ability, i.e., a format string bug (CVE-2000-0573), which
can be exploited with a specially-crafted string to the SITE
EXEC command. Instead of overwriting the return address
on the stack, this attack use format string to overwrote a
security-critical variable pw → pw uid to 0. After that, the
attack further established another data connection and issues
a get command, which essentially invoked the function
getdatasock() in the wu-ftpd server. Due to the corruption
of pw → pw uid, the execution of the function will set the
EUID of the process to 0, elevating the process privilege
to the super-root. As such, an originally non-privileged user
is able to access the system with the root privilege. This
overall exploitation is a typical data-ﬂow attack [3].
It is interesting to point out that data-ﬂow-based anomaly
detection is also able to detect this attack. As dis-
cussed in [1], this attack can be detected as a vio-
lation of the equality relation between the seteuid
system call and another setuid system call (in func-
tion pass()). However, the root cause of this attack is
that the attacker crafts a format string, in the form as
SITE EXEC aaabcd%.f%.f%.f%...%d...|%.8x, to over-
write pw → pw uid to 0. And our semantic ﬂow-based
detection is able to identify this attack when the Equal
relation between the ﬁle name execve invoked and the
ﬁle name in reply message is been violated, which is earlier
than the previous detection point.
107
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

#U1: Receive a client request 
U1(Message){
SWITCH(CMD)
CASE (“CWD”){ 
PARAMETER = pathname;
CALL U2(chdir,PARAMETER);
}
……
#U2: Handle the request
U2(SYSCALL, PARAMETER) {
IF(chdir(PARAMETER).ret < 0)
{
/* No such file or directory */
Code= 550; 
}
ELSE{
/* The CWD command succeeds */
Code = 250;
}
}
#U3: Send the reply
U3(CMD, Code){
write.Message.cmd = CMD;
write.Message.code = Code;
}
…...
…...
(a) Partial semantic speciﬁcation for wu-ftpd
Others’ detection points
#Other normal system calls
……
read(0, "CWD ~{\10././././././.\10.\
10000….\10", 1024) = 7 
write(1, "$\10sP\10$", 4) = 4
read(0, “3U/AF3E…..”, 255) = 72
setreuid(0, 0) = 0
mkdir (“T”, 237)=0
chroot(“T”)=0
chroot()=0
execve(“//bin/sh”, addr, 00000000)
Our detection point
(b) Logged (attack) system calls and the detection points
Figure 3.
A control-ﬂow attack based on the wu-ftpd heap corruption
vulnerability (CVE-2001-0550): The system call sequences shown in Figure
3(b) violates the semantic speciﬁcation in Figure 3(a).
VII. CONCLUSION
In this paper, we have presented a semantic ﬂow-based
host intrusion detection model that seamlessly integrates
control-ﬂow and data-ﬂow dependencies. When compared
with existing approaches, which only focus on control-ﬂows,
or data-ﬂows but not both, our approach greatly improves the
accuracy and completeness of the obtained program behavior
models. An efﬁcient algorithm is presented to accurately
extract basic semantic units, each of which characterizes
an essential aspect of the modeled program behavior, and
then obtain the semantic dependencies among them. Our
experimental results show that our model enables earlier
detection and prevention of many attacks than existing
approaches and holds great promise for more precise and
complete host-based intrusion detection.
ACKNOWLEDGMENT
We would like to thank Zhiqiang Lin from Purdue Uni-
versity for providing the source code of AutoFormat, the
networking protocol reverse engineering tool.
REFERENCES
[1] S. Bhatkar, A. Chaturvedi, and R. Sekar. “Dataﬂow Anomaly
Detection”. In S&P ’06: Proceedings of 2006 IEEE Sympo-
sium on Security and Privacy, Oakland, CA, USA. pp. 48-62.
May 2006.
[2] M. D. Bond, V. S. Kathryn, S. McKinley, V. Shmatikov. “Ef-
ﬁcient Context-Sensitive Detection of Real-World Semantic
Attacks”. In PLAS ’10: Proceedings of the 5th ACM SIG-
PLAN Workshop on Programming Languages and Analysis
for Security. pp. 1-10. ACM, 2010
[3] S. Chen, J. Xu, E. Sezer, P. Gauriar and R. Iyer. “Non-
Control-Data Attacks Are Realistic Threats”. In USENIX
Security ’05: Proceedings of the 14th USENIX Security
Symposium, Baltimore, MD, USA. pp. 177-192. August 2005.
[4] H. Feng, J. Gifﬁn, Y. Huang, S. Jha, W. Lee, and B. P. Miller.
“Formalizing sensitivity in static analysis for intrusion detec-
tion”. In S&P ’04: Proceedings of 2004 IEEE Symposium on
Security and Privacy, Oakland, California, USA, pp. 194-208.
May 2004.
[5] D. Gao, M.K. Reiter and D. Song. “Gray-Box Extraction
of Execution Graphs for Anomaly Detection”. In CCS ’04:
Proceedings of the 11th ACM Conference on Computer and
Communications Security. Washington, DC, pp. 318-329.
October 2004
[6] J. Gifﬁn, S. Jha, and B. Miller. “Efﬁcient contextsensitive
Intrusion Detection”. In NDSS ’04: Proceedings of The 11th
Annual Network and Distributed System Security Symposium,
San Diego, CA.
[7] S. A. Hofmeyr, S. Forrest, and A. Somayaji. “Intrusion
Detection Using Sequences of System Calls”. Journal of
Computer Security (JCS), 6(3):151-180, 1998.
[8] C. Kruegel, D. Mutz, F. Valeur, and G. Vigna. “On the Detec-
tion of Anomalous System Call Arguments”. In ESORICS’03:
Proceedings of the 8th European Symposium on Research in
Computer Security. Gjovik, Norway, pp. 101-118. October
2003
[9] L. C. Lam and T. Chiueh. “Automatic Extraction of Accu-
rate Application-speciﬁc Sandboxing Policy”. In RAID ’04:
Proceedings of the 7th International Symposium on Recent
Advances in Intrusion Detection. French Riviera, France. pp.
1-20.
[10] Z. Lin, X. Jiang, D. Xu, and X. Zhang. “Automatic Protocol
Format Reverse Engineering Through Context-Aware Mon-
itored Execution”. In NDSS ’08: Proceedings of the 15th
Network and Distributed System Security Symposium, San
Diego, CA, February 2008
[11] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, D.
Song. “A Symbolic Execution Framework for JavaScript”. In
S&P ’10: Proceedings of IEEE Symposium on Security and
Privacy, Oakland, California, USA, May 2010.
[12] R. Sekar, M. Bendre, P. Bollineni and D. Dhurjati. “A Fast
Automaton-Based Method for Detecting Anomalous Program
Behaviors”. In S&P ’01: Proceedings of 2001 IEEE Sympo-
sium on Security and Privacy, Oakland, California, USA. pp.
144re-155. May 2001.
[13] D. Wagner and P. Soto. “Mimicry attacks on host-based
intrusion detection systems”. In CCS’02: Proceedings of the
9th ACM Conference on Computer and Communications
Security, Washington, DC, USA. pp. 255-264. Noverber 2002.
[14] D. Wagner and D. Dean. “Intrusion Detection via Static
Analysis”. In S&P’01: Proceedings of 2001 IEEE Symposium
on Security and Privacy, Oakland, California. May 2001.
[15] H. Yin, D. Song, E. Manuel, C. Kruegel, and E. Kirda.
“Panorama: Capturing system-wide information ﬂow for mal-
ware detection and analysis”. In CCS’07: Proceedings of the
14th ACM Conferences on Computer and Communication
Security, pp. 116-127. October 2007.
[16] Wu-ftpd
vulnerability.
http://www.securityfocus.com/bid/
3581/references (June 2, 2011)
108
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-010-9
SECURWARE 2011 : The Fifth International Conference on Emerging Security Information, Systems and Technologies

