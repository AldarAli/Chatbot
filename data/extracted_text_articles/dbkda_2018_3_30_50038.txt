A Distributed Collaborative Filtering Algorithm Using Multiple Data Sources
Mohamed Reda Bouadjenek†♭, Esther Pacitti†, Maximilien Servajean†, Florent Masseglia†, Amr El Abbadi‡
†INRIA & LIRMM University of Montpellier France,
♭The University of Toronto, Department of Mechanical and Industrial Engineering
Email: mrb@mie.utoronto.ca, {esther.pacitti, maximilien.servajean}@lirmm.fr, ﬂorent.masseglia@inria.fr
‡University of California, Santa Barbara, CA, USA, Email: amr@cs.ucsb.edu
Abstract—Collaborative Filtering (CF) is one of the most com-
monly used recommendation methods. CF consists in predicting
whether, or how much, a user will like (or dislike) an item
by leveraging the knowledge of the user’s preferences as well
as that of other users. In practice, users interact and express
their opinion on only a small subset of items, which makes the
corresponding user-item rating matrix very sparse. Such data
sparsity yields two main problems for recommender systems:
(1) the lack of data to effectively model users’ preferences, and
(2) the lack of data to effectively model item characteristics.
However, there are often many other data sources that are
available to a recommender system provider, which can describe
user interests and item characteristics (e.g., users’ social network,
tags associated to items, etc.). These valuable data sources
may supply useful information to enhance a recommendation
system in modeling users’ preferences and item characteristics
more accurately and thus, hopefully, to make recommenders
more precise. For various reasons, these data sources may be
managed by clusters of different data centers, thus requiring the
development of distributed solutions. In this paper, we propose a
new distributed collaborative ﬁltering algorithm, which exploits
and combines multiple and diverse data sources to improve
recommendation quality. Our experimental evaluation using real
datasets shows the effectiveness of our algorithm compared to
state-of-the-art recommendation algorithms.
Keywords–Recommender Systems; Collaborative Filtering; So-
cial Recommendation; Matrix Factorization.
I.
INTRODUCTION
Nowadays, Internet ﬂoods users with useless information.
Hence, recommender systems are useful to supply them with
content that may be of interest. Recommender systems have
become a popular research topic over the past 20 years, to
make them more accurate and effective along many dimensions
(social dimension [1][2][3], geographical dimension [4][5],
diversiﬁcation aspect [6][7][8], etc.).
Collaborative Filtering (CF) [9] is one of the most com-
monly used recommendation methods. CF consists in predict-
ing whether, or how much, a user will like (or dislike) an
item by leveraging the knowledge of the user preferences,
as well as that of other users. In practice, users interact and
express their opinions on only a small subset of items, which
makes the corresponding user-item rating matrix very sparse.
Consequently, in a recommender system, this data sparsity
induces two main problems: (1) the lack of data to effectively
model user preferences (new users suffer from the cold-start
problem [10]), and (2) the lack of data to effectively model
items characteristics (new items suffer from the cold-start
problem since no user has yet rated them).
On the other hand, beside this sparse user-item rating
matrix, there are often many other data sources that are
available to a recommender system, which can provide useful
information that describe user interests and item characteris-
tics. Examples of such diverse data sources are numerous: a
user social network, a user’s topics of interest, tags associated
to items, etc. These valuable data sources may supply useful
information to enhance a recommendation system in model-
ing user preferences and item characteristics more accurately
and thus, hopefully, to make more precise recommendations.
Previous research work has demonstrated the effectiveness of
using external data sources for recommender systems [1][2][3].
However, most of the proposed solutions focus on the use
of only one kind of data provided by an online service
(e.g., social network in [1] or geolocation information in
[4][5]). Extending these solutions into a uniﬁed framework
that considers multiple and diverse data sources is itself a
challenging research problem.
Furthermore, these diverse data sources are typically man-
aged by clusters at different data centers, thus requiring the
development of new distributed recommendation algorithms
to effectively handle this constantly growing data. In order
to make better use of these different data sources, we pro-
pose a new distributed collaborative ﬁltering algorithm, which
exploits and combines multiple and diverse data sources to
improve recommendation quality. To the best of our knowl-
edge, this is the ﬁrst attempt to propose such a distributed
recommendation algorithm. In summary, the contributions of
this paper are:
1)
A new recommendation algorithm, based on matrix
factorization, which leverages multiple and diverse
data sources. This allows better modeling user pref-
erences and item characteristics.
2)
A distributed version of this algorithm that mainly
computes factorizations of matrices by exchanging
intermediate latent feature matrices in a coordinated
manner.
3)
A thorough comparative analysis with state-of-the-art
recommendation algorithms on different datasets.
This paper is organized as follows: Section II provides two use
cases; Section III presents the main concepts used in this paper;
Section IV describes our multi-source recommendation model;
Section V gives our distributed multi-source recommendation
algorithm; Section VI describes our experimental evaluation;
Section VII discusses the related work; Finally, Section VIII
concludes and provides future directions.
46
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

II.
USE CASES
Let us illustrate our motivation with two use cases, one
with internal data sources, one with external data sources.
A. Diverse internal data sources
Consider John, a user who has rated a few movies he saw
on a movie recommender system. In that same recommendation
system, John also expressed his topics of interest regarding
movie genres he likes. He also maintains a list of friends,
which he trusts and follows to get insight on interesting movies.
Finally, John has annotated several movies he saw, with tags
to describe their contents.
In this example, the same recommender system holds many
valuable data sources (topics of interest, friends list, and
annotations), which may be used to accurately model John’s
preferences and movies’ characteristics, and thus, hopefully
to make more precise recommendations. In this ﬁrst scenario,
we suppose that these diverse data sources are hosted over
different clusters of the same data center of the recommender
system. It is obvious that a centralized recommendation al-
gorithm induces a massive data transfer, which will cause
a bottleneck problem in the data center. This clearly shows
the importance of developing a distributed recommendation
solution.
B. Diverse external data sources
Let us now consider that John is a regular user of a movie
recommender system and of many other online services. John
uses Google as a search engine, Facebook to communicate and
exchange with his friends, and maybe other online services
such as Epinions social network, IMDb, which is an online
database of information related to ﬁlms, Movilens, etc, as
illustrated in Figure 1.
In this second use case, we believe that by exploiting
and combining all these valuable data sources provided by
different online services, we could make the recommender
system more precise. The data sources are located and dis-
tributed over the clusters of different data centers, which are
geographically distributed. In this second use case, we assume
that the recommendation system can identify and link entities
that refer to the same users and items across the different
data sources. We envision that the connection of these online
services may be greatly helped by initiatives like OpenID
(http://openid.net/), which promotes a uniﬁed user identity
across different services. In addition, we assume that the online
services are willing to help the recommender system through
contracts that can be established.
III.
DEFINITIONS AND BACKGROUND
In this section, we introduce the data model we use, and a
CF algorithm based on matrix factorization. Then, we describe
the recommendation problem we study.
A. Data Model
We use matrices to represent all the data manipulated
in our recommendation algorithm. Matrices are very useful
mathematical structures to represent numbers, and several
Movies 
database 
service
Recommender 
system
Search engine
Social 
network
Movies 
reviews
Trust social 
network
Figure 1. Use case: Movielens.
TABLE I. SAMPLE OF ATTRIBUTES.
Attribute 1
Attribute 2
Example of correlation
User
User
Similarity between the two users
User
Topic
Interest of the user in the topic
Item
Topic
Topic of the items
Item
Item
Similarity between two items
techniques from matrix theory and linear algebra can be used
to analyze them in various contexts. Hence, we assume that
any data source can be represented using a matrix, whose value
in the i, j position is a correlation that may exist between the
ith and jth elements. We distinguish mainly three different
kinds of data matrices:
Users’ preferences history: In a recommender system, there
are two classes of entities, which are referred as users and
items. Users have preferences for certain items, and these
preferences are extracted from the data. The data itself is
represented as a matrix R, giving for each user-item pair, a
value that represents the degree of preference of that user for
that item.
Users’ attributes: A data source may supply information
on users using two classes of entities, which are referred to
users and attributes. An attribute may refer to any abstract
entity that has a relation with users. We also use matrices
to represent such data, where for each user-attribute pair, a
value represents their correlation (e.g., term frequency-inverse
document frequency (tf-idf) [11]). The way this correlation is
computed is out of the scope of this paper.
Items’ attributes: Similarly, a data source may embed in-
formation that describes items using two classes of entities,
namely items and attributes. Here, an attribute refers to any
abstract entity that has a relation with items. Matrices are used
to represent these data, where for each attribute-item pair, a
value is associated to represent their correlation (e.g., tf-idf).
The way this correlation is computed is also beyond the scope
of this paper.
Table I gives examples of attributes that may describe both
users and items, as well as the meaning of the correlations.
It is interesting to notice that these three kinds of matrices
are sparse matrices, meaning that most entries are missing.
A missing value implies that we have no explicit information
regarding the corresponding entry.
47
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

B. Matrix Factorization (MF) Models
Matrix factorization aims at decomposing a user-item rating
matrix R of dimension I × J containing observed ratings ri,j
into a product R ≈ U T V of latent feature matrices U and V
of rank K. In this initial MF setting, we designate Ui and Vj
as the ith and jth columns of U and V such that U T
i Vj acts
as a measure of similarity between user i and item j in their
respective k-dimensional latent spaces Ui and Vj.
However, there remains the question of how to learn U
and V
given that R may be incomplete (i.e., it contains
missing entries). One answer is to deﬁne a reconstruction
objective error function over the observed entries, that are to
be minimized as a function of U and V , and then use gradient
descent to optimize it; formally, we can optimize the following
MF objective [12]: 1
2
I
X
i=1
J
X
j=1
IR
ij(rij − U T
i Vj)2, where Iij is the
indicator function that is equal to 1 if user ui rated item vj
and equal to 0 otherwise. Also, in order to avoid overﬁtting,
two regularization terms are added to the previous equation
(i.e., 1
2∥U∥2
F and 1
2∥V ∥2
F ).
C. Problem Deﬁnition
The problem we address in this paper is different from
that in traditional recommender systems, which consider only
the user-item rating matrix R. In this paper, we incorporate
information coming from multiple and diverse data matrices
to improve recommendation quality. We deﬁne the problem
we study in this paper as follows. Given:
•
a user-item rating matrix R;
•
N data matrices that describe the user preferences
{SU 1, . . . , SU n} distributed over different clusters;
•
M data matrices that describe the items’ charac-
teristics {SV 1, . . . , SV m} distributed over different
clusters;
How to effectively and efﬁciently predict the missing values
of the user-item matrix R by exploiting and combining these
different data matrices?
IV.
RECOMMENDATION MODEL
In this section, we ﬁrst give an overview of our recommen-
dation model using an example. Then, we introduce the factor
analysis method for our model that uses probabilistic matrix
factorization.
A. Recommendation Model Overview
Let us ﬁrst consider as an example the user-item rating
matrix R of a recommender system (see Figure 2). There
are 5 users (from u1 to u5) who rated 5 movies (from v1
to v5) on a 5-point integer scale to express the extent to
which they like each item. Also, as illustrated in Figure 2,
the recommender system provider holds three data matrices
that provide information that describe users and items. Note
that only part of the users and items of these data matrices
overlap with those of the user-item rating matrix.
v1
v2 v3 v4 v5
V
u1
u2 u3 u4 u5
U
Item-Attribute 
Matrix
User-Attribute 
Matrices
u8
1
0.2
u6
0.5
1
0.3
0.2
u2
u1
u3
0.2
u3
u6
1
u1
u8
u2
0.3
0.4
1
0.5
1
SU 1
u9
0.4
0.1
u8
0.3
0.1
0.3
t1
0.2
t3
u7
u6
t4
u3
t5
t2
0.3
0.1
0.5
0.5
0.4
u4
0.1
SU 2
(3) Items’ Genres
0.5
0.4
v9
0.2
v7
v3
0.2
0.3
0.2
g3
v1
g4
v2
g1
0.3
0.4
g2
0.5SV 1
u1
u2 u3 u6 u8
ZU 1
t1
t2 t3 t4 t5
ZU 2
g1
g2 g3 g4
ZV 1
u8 u9
u3
u4 u6 u7
U 2
v1 v2 v3 v7 v9
V 1
Sharing features
2
u3
v1
v3
2
u5
u4
3
v4
4
u1
v5
v2
3
1
4
5
4
5
u2
5
1R
User-Item Matrix
u1
u2 u3 u6 u8
U 1
(2) Users’ Interests
(1) Trust Social Network
Figure 2. Overview of the recommendation model using toy data. Users and
items in green are users for which we make the recommendation, whereas
users and items in red are used as additional knowledge.
1)
Matrix (1): provides the social network of u1, u2, and
u3, where each value in the matrix SU 1 represents the
trustiness between two users.
2)
Matrix (2): provides information about the interests
of u3 and u4, where for each user-topic pair in the
matrix SU 2, a value is associated, which represents
the interest of the user in this topic.
3)
Matrix (3): provides information about the genre of
the movies v1, v2, and v3 in the matrix SV 1.
The problem we study in this paper is how to predict the miss-
ing values of the user-item matrix R effectively and efﬁciently
by combining all these data matrices (SU 1, SU 2, and SV 1).
Motivated by the intuition that more information will help to
improve a recommender system, and inspired by the solution
proposed in [1], we propose to disseminate the data matrices of
the data sources in the user-item matrix, by factorizing all these
matrices simultaneously and seamlessly as illustrated in Figure
2, such as: R ≈ U T V , SU 1 ≈ U 1T ZU 1, SU 2 ≈ U 2T ZU 2, and
SV 1 ≈ ZV 1T V 1, where the k-dimensional matrices U, U 1,
and U 2 denote the user latent feature space, such as U1 = U 1
1 ,
U2 = U 1
2 , U3 = U 1
3 = U 2
1 , U4 = U 2
2 (U1, U2, U4, and U4 refer
respectively to the 1st, 2nd, 3rd, and 4th column of the matrix
U), the matrices V and V 1 are the k-dimensional item latent
feature space such as V1 = V 1
1 , V2 = V 1
2 , V3 = V 1
3 , and ZU 1,
ZU 2, and ZV 1, are factor matrices. In the example given in
Figure 2, we use 3 dimensions to perform the factorizations of
the matrices. Once done, we can predict the missing values in
the user-items matrix R using U T V . In the following sections,
we present the details of our recommendation model.
48
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

B. User-Item Rating Matrix Factorization
Suppose that a Gaussian distribution gives the probability
of an observed entry in the User-Item matrix as follows:
rij ∼ N(rij|U T
i Vj, σ2
R)
(1)
where N(x|µ, σ2) is the probability density function of the
Gaussian distribution with mean µ and variance σ2. The idea
is to give the highest probability to rij ≈ U T
i Vj as given by
the Gaussian distribution. Hence, the probability of observing
approximately the entries of R given the feature matrices U
and V is:
p(R|U, V, σ2
R) =
IY
i=1
J
Y
j=1

N(rij|U T
i Vj, σ2
R)
IR
ij
(2)
where IR
ij is the indicator function that is equal to 1 if a user i
rated an item j and equal to 0 otherwise. Similarly, we place
zero-mean spherical Gaussian priors [13][1][12] on user rating
and item feature vectors:
p(U|σ2
U) =
IY
i=1

N(Ui|0, σ2
U)

, p(V |σ2
V ) =
J
Y
j=1

N(Vj|0, σ2
V )

(3)
Hence, through a simple Bayesian inference, we have:
p(U, V |R, σ2
R, σ2
U, σ2
V ) ∝ p(R|U, V, σ2
R)p(U|σ2
U)p(V |σ2
V )
(4)
C. Matrix factorization for data sources that describe users
Now let’s consider a User-Attribute matrix SU n of P
users and K attributes, which describes users. We deﬁne the
conditional distribution over the observed matrix values as:
p(SU n|U n, ZU n, σ2
SUn ) =
P
Y
p=1
K
Y
k=1
h
N(sU n
pk |U nT
p
ZU n
k
, σ2
SUn )
iISUn
pk
(5)
where ISUn
pk
is the indicator function that is equal to 1 if user p
has a correlation with attribute k (in the data matrix SU n) and
equal to 0 otherwise. Similarly, we place zero-mean spherical
Gaussian priors on feature vectors:
p(Un|σ2
U ) =
P
Y
p=1
h
N (Un
p |0, σ2
U )
i
,
p(ZUn
|σ2
ZUn ) =
K
Y
k=1

N (ZUn
k
|0, σ2
ZUn )

(6)
Hence, similar to Equation 4, through a simple Bayesian
inference, we have:
p(U n, ZU n|SU n, σ2
SUn , σ2
U, σ2
ZUn ) ∝
p(SU n|U n, ZU n, σ2
SUn )p(U n|σ2
U)p(ZU n|σ2
ZUn )
(7)
D. Matrix factorization for data sources that describe items
Now let’s consider an Item-Attribute matrix SV m of H
items and K attributes, which describes items. We also deﬁne
the conditional distribution over the observed matrix values as:
p(SV m|V m, ZV m, σ2
SV m ) =
H
Y
h=1
K
Y
k=1
h
N(sV m
hk |V mT
h
ZV m
k
, σ2
SV m )
iISV m
hk
(8)
where ISV m
hk
is the indicator function that is equal to 1 if an
item h is correlated to an attribute k (in the datasource SV m)
and equal to 0 otherwise. We also place zero-mean spherical
Gaussian priors on feature vectors:
p(V m|σ2
V ) =
H
Y
h=1

N(V m
h |0, σ2
V )

p(ZV m|σ2
ZV m ) =
K
Y
k=1
h
N(ZV m
k
|0, σ2
ZV m )
i
(9)
Hence, through a Bayesian inference, we also have:
p(V m, ZV m|SV m, σ2
SV m, σ2
V , σ2
ZV m) ∝
p(SV m|V m, ZV m, σ2
SV m )p(V m|σ2
V )p(ZV m|σ2
ZV m)
(10)
E. Recommendation Model
Considering N data matrices that describe users, M data
matrices that describe items, and based on the graphical model
given in Figure 3, we model the conditional distribution over
the observed ratings as:
p(U, V |R, SU1, . . . , SUn, SV 1, . . . , SV m
σ2
ZU1 . . . , σ2
ZUn , σ2
ZV 1 , . . . , σ2
ZV m ) ∝
p(R|U, V, σ2
R)p(U|σ2
U)p(V |σ2
V )
N
Y
n=1
p(SUn|U n, ZUn, σ2
SUn )p(U n|σ2
U)p(ZUn|σ2
ZUn )
M
Y
m=1
p(SV m|V m, ZV m, σ2
SV m )p(V m|σ2
V )p(ZV m|σ2
ZV m )
(11)
Hence, we can infer the log of the posterior distribution
for the recommendation model as follows:
L(U, U 1, . . . , U n, V, V 1, . . . , V m, ZU1, . . . , ZUn, ZV1, . . . , ZVm) =
1
2
I
X
i=1
J
X
j=1
IR
ij(rij − U T
i Vj)2



Error over the
reconstruction of R
+
N
X
n=1
λSUn
2
P
X
p=1
K
X
k=1
ISUn
pk
(sUn
pk − U nT
p
ZUn
k
)2



Error over the
reconstruction of
datasources that
describe users
+
M
X
m=1
λSV m
2
H
X
h=1
K
X
k=1
ISV m
hk
(sV m
hk
− V mT
h
ZV m
k
)2
)
Error over the
reconstruction of
datasources that
describe items
+ λU
2 (∥U∥2
F +
N
X
n=1
∥U n∥2
F )
+ λV
2 (∥V ∥2
F +
M
X
m=1
∥V m∥2
F )
+
N
X
n=1
λZUn
2
∥ZUn∥2
F +
M
X
m=1
λZUm
2
∥ZUm∥2
F





















Regularization
terms
(12)
49
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

n=1,…,N
m=1,…,M
Datasources that 
describe Users
Datasources that 
describe Items
Rij
Ui
Vj
σU
σV
σR
i = 1, · · · , I
j = 1, · · · , J
h=1,…,H
k=1,…,K
SV m
hk
ZV m
k
σZV m
σSV m
V m
h
p=1,…,P
k=1,…,K
SU n
pk
ZU n
k
σZUn
σSUn
U n
p
Figure 3. Graphical model for recommendation.
where ∥.∥2
F denotes the Frobenius norm, and λ∗ are regular-
ization parameters. A local minimum of the objective function
given by Equation 12 can be found using Gradient Descent
(GD). A distributed version of this algorithm in the next
section.
V.
DISTRIBUTED RECOMMENDATION
In this section, we ﬁrst present a distributed version of the
Gradient Descent Algorithm, which minimizes Equation 12,
and then we carry out a complexity analysis to show that it
can scale to large datasets.
A. Distributed CF Algorithm
In this section, we show how to deploy a CF algorithm
in a distributed setting over different clusters and how to
generate predictions. This distribution is mainly motivated
by: (i) the need to scale up our CF algorithm to very large
datasets, i.e., parallelize part of the computation, (ii) reduce
the communication cost over the network, and (iii) avoid to
transfer the raw data matrices (for privacy concerns). Instead,
we only exchange common latent features.
Based on the observation that several parts of the central-
ized CF algorithm can be executed in parallel and separately on
different clusters, we propose to distribute it using Algorithms
1, 2, and 3. Algorithm 1 is executed by the master cluster that
handle the user-item rating matrix, whereas each slave cluster
that handle data matrices about users’ attributes executes an
instance of Algorithm 2, and each slave cluster that handles
data matrices about items’ attributes executes an instance of
Algorithm 3.
Basically, the ﬁrst step of this distributed algorithm is an
initialization phase, where each cluster (master and slaves)
initializes its latent feature matrices with small random values
(lines 1 of Algorithms 1, 2, and 3). Next, in line 4 of Algorithm
1, the master cluster computes part of the partial derivative of
the objective function given in Equation 12 with respect to U
(line 4 of Algorithm 1). Then, for each user ui, the master
cluster sends its latent feature vector to the other participant
slave clusters, which share attributes about that user (lines
5 and 6 in Algorithm 1). Then, the master cluster waits for
responses of all these participant slave clusters (line 8 in
Algorithm 1).
Algorithm 1: Distributed Collaborative Filtering Algo-
rithm (Master Cluster 1/3)
input : The User-Item matrix Rij;
A learning parameter α;
Regularization parameters λU, λV ;
output: Feature matrices U, V ;
1 Initialize latent feature matrices to small random values.
/* Minimize L using gradient descent as follows:
*/
2 while L > ϵ /* ϵ is a stop criterion
*/
3 do
/* Compute local intermediate results of the
gradient of U as follows:
*/
4
∇U =

IR(U T V − R)V
T T + λUU
5
foreach user ui do
6
Send Ui to data sources that share information about the user ui
7
end
8
foreach πn received do
/* ⊕ is an algebraic operator given in
Definition 1.
*/
9
∇U = ∇U ⊕ πn
10
end
/* Compute local intermediate results of the
gradient of V
as follows:
*/
11
∇V =

IR(U T V − R)T U T T + λV V
12
foreach item vj do
13
Send Vj to data sources that share information about the item vj
14
end
15
foreach πm received do
16
∇V = ∇V ⊕ πm
17
end
/* Update global U and V
latent features matrices
as follows:
*/
18
U = U − α (∇U)
19
V = V − α (∇V )
20
check U and V for convergence
21 end
Algorithm 2: Distributed Collaborative Filtering Algo-
rithm (User data slave cluster 2/3)
1 Initialize latent feature matrices ZUn and U n to small random values.
2 Procedure RefineUserFeatures()
input : A User-Object matrix SUn;
The common user latent features matrix U;
A learning parameter α;
Regularization parameters λSUn , λZUn ;
3
foreach Ui received do
4
Replace the right latent user feature vector U n
k with the received Ui
5
end
/* Compute intermediate result:
*/
6
πn = λSUn

ISUn
(U nT ZUn − SUn)ZUn T
T
7
Keep in πn vectors of users that are shared with the recommender system
8
Send πn to the recommender system
/* Compute gradients of U n and Z with respect to
L
*/
9
∇Un = λSUn
 
ISUn
(UnT ZUn
− SUn
)ZUn T
!T
+ λSUn Un
10
∇Z =

λSUn
 
ISUn
(UnT ZUn
− SUn
)
!T
UnT


T
+ λZUn ZUn
/* Update local latent features matrices U and Z
as follows:
*/
11
U n = U n − α (∇Un)
12
ZUn = ZUn − α (∇Z)
Next, each slave cluster that receives users’ latent features
replaces the corresponding user latent feature vector U n
k with
the user latent feature vector Ui received from the master
cluster (lines 3 and 4 in Algorithm 2). Then, the slave cluster
computes πn, which is part of the partial derivative of the
objective function given in Equation 12 with respect to U (line
6 in Algorithm 2). Next, the slave cluster keeps in πn, only
50
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

Algorithm 3: Distributed Collaborative Filtering Algo-
rithm (Item data slave cluster 3/3)
1 Initialize latent feature matrices ZV m and V m to small random values.
2 Procedure RefineUserFeatures()
input : An Object-Item matrix SVm;
The common user latent features matrix V ;
A learning parameter α;
Regularization parameters λSVm , λZVm ;
3
foreach Vj received do
4
Replace the right latent item feature vector V m
k
with the received Vj
5
end
/* Compute intermediate result:
*/
6
πm = λSV m
 
ISV m
(ZV mT V m − SV m)
T
ZV m T
!T
7
Keep in πm vectors of items that are shared with the recommender system
8
Send πm to the recommender system
/* Compute gradients of V
and Z with respect to L:
*/
9
∇V m =
λSV m


 
ISVm (ZV mT V m − SV m
)
!T
ZV m T


T
+ λSV m V m
10
∇Z = λSV m
 
ISV m
(ZV mT V m − SV m
)V T
!T
+ λZUm Z
/* Update local latent features matrices V
and Z
as follows:
*/
11
V m = V m − α (∇V m)
12
ZV m = ZV m − α (∇Z)
vectors of users that are shared with the master cluster (line 7
in Algorithm 2). The slave cluster sends the remaining feature
vectors in πn to the master cluster (line 8 in Algorithm 2).
Finally, the slave cluster updates its local user and attribute
latent feature matrices ZU n and U n (lines 9-12 in Algorithm
2).
As for the master cluster, each user latent feature matrix
πn received from a slave cluster is added to ∇U, which is the
partial derivative of the objective function with respect to U
(line 9 in Algorithm 1). This addition is performed using ⊕,
an algebraic operator deﬁned as follows:
Deﬁnition 1.
For two matrices Am,n = (aij) and Bm,p = (bij), A ⊕ B
returns the matrix Cm,n where:
cij =

aij + bij
if Aj and Bj refer to the same user/item
aij
otherwise
Once the master cluster has received all the partial deriva-
tive of the objective function with respect to U from all the
user participant sites, it has computed the global derivative of
the objective function given in Equation 12 with respect to
U . A similar operation is performed for item slave cluster
from line 11 to line 16 in Algorithm 1 to compute the global
derivative of the objective function given in Equation 12 with
respect to V . Finally, the master cluster updates the user and
item latent feature matrices U and V , and evaluates L in lines
18, 19, and 20 of Algorithm 1 respectively. The convergence
of the whole algorithm is checked in line 2 of Algorithm 1.
Note that all the involved clusters that hold data matrices on
users and items’ attributes execute their respective algorithm
in parallel.
B. Complexity Analysis
The main computation of the GD algorithm evaluates
the objective function L in Equation 12 and its derivatives.
Because of the extreme sparsity of the matrices, the com-
putational complexity of evaluating the object function L is
O(ρ1 + . . . + pn), where ρn is the number of nonzero entries
in matrix n. The computational complexities for the derivatives
are also proportional to the number of nonzero entries in data
matrices. Hence, the total computational complexity in one
iteration of this gradient descent algorithm is O(ρ1+. . .+pn),
which indicates that the computational time is linear with
respect to the number of observations in the data matrices.
This complexity analysis shows that our algorithm is quite
efﬁcient and can scale to very large datasets.
VI.
EXPERIMENTAL EVALUATION
In this section, we carry out several experiments to mainly
address the following questions:
1)
What is the amount of data transferred?
2)
How does the number of user and item sources affect
the accuracy of predictions?
3)
What is the performance comparison on users with
different observed ratings?
4)
Can our algorithm achieve good performance even if
users have no observed ratings?
5)
How does our approach compare with the state-of-
the-art collaborative ﬁltering algorithms?
In the rest of this section, we introduce our datasets and exper-
imental methodology, and address these questions (question 1
in Section VI-C, question 2 in Section VI-D, questions 3 and
4 in Section VI-E, and question 5 in Section VI-F).
A. Description of the Datasets
The ﬁrst round of our experiment is based on a dataset
from Delicious, described and analyzed in [14][15][16]
(http://data.dai-labor.de/corpus/delicious/). Delicious is a book-
marking system, which provides to the user a means to freely
annotate Web pages with tags. Basically, in this scenario we
want to recommend interesting Web pages to users. This
dataset contains 425,183 tags, 1,321,039 Web pages, and
318,769 users. The user-item matrix contains 2,265,207 entries
(a density of ≃ 0.0005%). Each entry of the user-item matrix
represents the degree of which a user interacted with an item
expressed on a [0, 1] scale. The dataset contains a user-tag
matrix with 4,598,815 entries, where each entry expresses the
interest of a user in a tag on a [0, 1] scale. Lastly, the dataset
contains an item-tags matrix with 4,403,244 entries, where
each entry expresses the coverage of a tag in a Web page on a
[0, 1] scale. The user-tag matrix and item-tags are used as user
data matrix, and item data matrix respectively. However, to
simulate having many data matrices that describe both users
and items, we have manually and randomly broken the two
previous matrices into 10 matrices in both columns and rows.
These new matrices kept their property of sparsity. Hence, we
end up with a user-item rating matrix, 10 user data matrices
(with approximately 459 000 entries each), and 10 item data
matrices (with approximately 440 000 entries each).
51
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

The second round of experiments is based on one
of
the
datasets
given
by
the
HetRec
2011
workshop
(http://ir.ii.uam.es/hetrec2011/datasets.html), and reﬂect a real
use case. This dataset is an extension of the Movielens dataset,
which contains personal ratings, and data coming from other
data sources (mainly IMDb and Rotten Tomatoes). This dataset
includes ratings that range from 1 to 5, including 0.5 steps.
This dataset contains a user-items matrix of 2,113 users, 10,109
movies, and 855,597 ratings (with a density of ≃ 4%). This
dataset also includes a user-tag matrix of 9,078 tags describing
the users with 21,324 entries on a [0, 1] scale, which is used
as a user data matrix. Lastly, this dataset contains four item
data matrices: (1) an item-tag matrix with 51,794 entries, (2)
an item-genre matrix with 20 genres and 20,809 entries, (3)
an item-actor matrix with 95,321 actors, and 213,742 entries,
and (4) an item-location matrix with 187 locations and 13,566
entries.
B. Methodology and metrics
We have implemented our distributed collaborative al-
gorithm and integrated it into Peersim [17], a well-known
distributed computing simulator. We use two different training
data settings (80% and 60%) to test the algorithms. We
randomly select part of the ratings from the user-item rating
matrix as the training data (80% or 60%) to predict the
remaining ratings (respectively 20% or 40%). The random
selection was carried out 5 times independently, and we report
the average results. To measure the prediction quality of the
different recommendation methods, we use the Root Mean
Square Error (RMSE), for which a smaller value means a better
performance. We refer to our method Distributed Probabilistic
Matrix Factorization (DPMF).
C. Data transfer
Let’s consider an example where a recommender system
uses a social network as a source of information to improve
its precision. Let’s assume that the social network contains 40
million unique users with 80 billion asymmetric connections
(a density of 0.005%). It turns out that if we only consider
the connections, the size of the user-user matrix representing
this social network is 80 × 109 × (8 B + 8 B) ≃ 1.16 TB
(assuming that we need 8 bytes to encode a double to rep-
resent the strength of the relation between two users, and
8 bytes to encode a long that represents the key for the
entry of the value in the user-user matrix). Hence, for the
execution of the centralized collaborative ﬁltering algorithm,
1.16 TB of data need to be transferred through the network.
However, if we assume that there are 10% of common users
between the recommender system and the social network,
each iteration of the DPMF algorithm requires the transfer
of 4 × 106 × 10 × 8 B × 2 ≃ 610 MB (assuming that we
use 10 dimensions for the factorization, that we need 8 bytes
to encode a double value in a latent user vector, and a round
trip of transfer for the latent vectors in line 6 of Algorithm 1
and line 8 of Algorithm 2). Hence, if the algorithm requires
100 iterations to converge (roughly the number of iterations
needed in our experiment), the total amount of data transferred
is 59 GB, which represents 5% of the data transferred in
the centralized solution.
Finally, the total amount of data
transferred depends on the density of the source, the total
Item sources
User sources
Mixed sources
 0.29
 0.3
 0.31
 0.32
 0.33
 0.34
 0.35
 0.36
 0.37
 0.38
 0
 2
 4
 6
 8
 10
RMSE
Number of sources
(a) Training: 80%.
 0.3
 0.31
 0.32
 0.33
 0.34
 0.35
 0.36
 0.37
 0.38
 0.39
 0
 2
 4
 6
 8
 10
RMSE
Number of sources
(b) Training: 60%.
Figure 4. Results of the impact of the number of sources on the Delicious
dataset.
 0.765
 0.77
 0.775
 0.78
 0.785
 0.79
 0.795
 0.8
 0.805
 0.81
 0
 1
 2
 3
 4
 5
RMSE
Number of sources
(a) Training: 80%.
 0.83
 0.84
 0.85
 0.86
 0.87
 0.88
 0.89
 0.9
 0.91
 0
 1
 2
 3
 4
 5
RMSE
Number of sources
(b) Training: 60%.
Figure 5. Results of the impact of the number of sources on the Movielens
dataset. The data matrices are added in the following order: (1) user-tag, (2)
item-tag, (3) item-genre, (4) item-actor, and (5) item-location.
number of common attributes, the number of latent dimensions
used for the factorization and the number of iterations needed
for the algorithm to converge. These parameters can make the
DPMF very competitive compared to the centralized solution
in terms of data transfer.
D. Impact of the number of sources
Figures 4 and 5 show the results obtained on the two
datasets, while varying the number of sources. Note that
source=0 means that we factorize only the user-item matrix.
In Figure 4, the green curve represents the impact of adding
item sources only, the red curve the impact of adding user
sources only, and the blue curve the impact of adding both
sources (e.g., 2 sources means we add 2 item and 2 user
sources). First, the results show that adding more sources helps
to improve the performance, conﬁrming our initial intuition.
The additional data sources have certainly contributed to
reﬁne users’ preferences and items’ characteristics. Second,
we observe that sources that describe users are more helpful
than sources that describe items (about 10% gain). However,
we consider this observation to be speciﬁc to this dataset, and
cannot be generalized. Third, we notice that combining both
data sources provides the best performance (blue curve, about
8% with respect to the use of only user sources). Lastly, the
best gain obtained with respect to the PMF method (source=0)
is about 32%.
Figure 5 shows the results obtained on the Movielens
dataset. The obtained results here are quite different than those
obtained on the Delicious dataset. Indeed, we observe that the
data matrices 1, 2 and 3 have a positive impact on the results;
however, data matrices 4 and 5 decrease the performance. This
is certainly due to the fact that the data embedded in these
52
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

 0.05
 0.1
 0.15
 0.2
 0.25
 0.3
 0.35
 0.4
=0
1−5
6−10
11−20
21−40
41−80
81−160
161−320
321−640
>640
RMSE
Number of Observed Ratings
PMF
DPMF 5 sources
DPMF 10 sources
(a) Different users.
 0.21
 0.22
 0.23
 0.24
 0.25
 0.26
 0.27
 0.28
 0.29
 0.3
 0.31
=0
1−5
6−10
11−20
21−40
41−80
81−160
161−320
321−640
>640
RMSE
Number of Observed Ratings
PMF
DPMF 5 sources
DPMF 10 sources
(b) Different items.
Figure 6. Performance for different ratings on the Delicious dataset.
two matrices are not meaningful to extract and infer items’
characteristics. In general, the best performance is obtained
using the three ﬁrst data matrices, with a gain of 10% with
respect to PMF (source=0).
E. Performance on users and items with different ratings
We stated previously that the data sparsity in a recom-
mender system induces mainly two problems: (1) the lack of
data to effectively model user preferences, and (2) the lack
of data to effectively model item characteristics. Hence, in
this section we study the ability of our method to provide
accurate recommendations for users that supply few ratings,
and items that contain few ratings (or no ratings at all). We
show the results for different user ratings in Figure 6a, and for
different item ratings in Figure 6b on the Delicious dataset. We
group them into 10 classes based on the number of observed
ratings: “0”, “1-5”, “6-10”, “11-20”, “21-40”, “41-80”, “81-
160”, “161-320”, “321-640”, and “>640”. We show the results
for different user ratings in Figure 6a, and for different item
ratings in Figure 6b on the Delicious dataset. We also show the
performance of the Probabilistic Matrix Factorization (PMF)
method [12], and our method using 5 and 10 data matrices.
In Figure 6a, on the X axis, users are grouped and ordered
with respect to the number of ratings they have assigned. For
example, for users with no ratings (0 on the X-axis), we got an
average of 0.37 for RMSE using the PMF method. Similarly,
in Figure 6b, on the X-axis, items are grouped and ordered
with respect to the number of ratings they have obtained.
The results show that our method is more efﬁcient in
providing accurate recommendations compared to the PMF
method for both users and items with few ratings (from 0 to
about 100 on the-X axis). Also, the experiments show that the
more we add data matrices, the more the recommendations are
accurate. However, for clarity, we just plot the results obtained
for our method while using 5 and 10 data matrices. Finally,
we also noticed that the performance is better for predicting
ratings to items that contain few ratings, than to users who
rated few items. This is certainly due to the fact that users’
preferences change over time, and thus, the error margin is
increased.
F. Performance comparison
To demonstrate the performance behavior of our algorithm,
we compared it with eight other state-of-the-art algorithms:
User Mean: uses the mean value of every user; Item Mean:
utilizes the mean value of every item; NMF [18]; PMF [12],
SoRec [1]; PTBR [19]; MatchBox [20]; HeteroMF [21]. The
results of the comparison are shown in Table II. The optimal
parameters of each method are selected, and we report the ﬁnal
performance on the test set. The percentages in Table II are
the improvement rates of our method over the corresponding
approaches.
First, from the results, we see that our method consistently
outperforms almost all the other approaches in all the settings
of both datasets. Our method can almost always generate
better predictions than the state-of-the-art recommendation
algorithms. Second, only Matchbox and HeteroMF slightly
outperform our method on the Movielens dataset. Third, the
RMSE values generated by all the methods on the Delicious
dataset are lower than those on Movielens dataset. This is due
to the fact that the rating scale is different between the two
datasets. Fourth, our method outperforms the other methods
better on the Delicious dataset, than on the Movielens dataset
(10% to 33% on Delicious and -0.05% to 11% on Movielens).
This is certainly due to the fact that: (1) the Movilens dataset
contains less data (fewer users and fewer items), (2) there
are less data matrices in the Movielens dataset to add, and
(3) the data matrices of the Delicious dataset are of higher
quality. Lastly, even if we use several data matrices in our
method, using 80% of training data still provides more accurate
predictions than 60% of training data. We explain this by
the fact that the data of the user-item matrix are the main
resources to train an effective recommendation model. Clearly,
an external source of data cannot replace the user-item rating
matrix, but can be used to enhance it.
VII.
RELATED WORK
Enhanced recommendation: Many researchers have started
exploring social relations to improve recommender systems
(including implicit social information, which can be employed
to improve traditional recommendation methods [22]), essen-
tially to tackle the cold-start problem [23][1][10]. However, as
pointed in [24], only a small subset of user interactions and
activities are actually useful for social recommendation.
In collaborative ﬁltering based approaches, Liu and Lee
[25] proposed very simple heuristics to increase recommenda-
tion effectiveness by combining social networks information.
Guy et al. [26] proposed a ranking function of items based
on social relationships. This ranking function has been further
improved in [19] to include social content such as related
terms to the user. More recently, Wang et al. [27] proposed
a novel method for interactive social recommendation, which
not only simultaneously explores user preferences and exploits
the effectiveness of personalization in an interactive way, but
also adaptively learns different weights for different friends.
Also, Xiao et al. [28] proposed a novel user preference model
for recommender systems that considers the visibility of both
items and social relationships.
In the context of matrix factorization, following the intu-
ition that a person’s social network will affect her behaviors
on the Web, Ma et al. [1] propose to factorize both the users’
social network and the rating records matrices. The main idea
is to fuse the user-item matrix with the users’ social trust
networks by sharing a common latent low-dimensional user
53
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

TABLE II. PERFORMANCE COMPARISON USING RMSE. OPTIMAL VALUES OF THE PARAMETERS ARES USED FOR EACH METHOD (K= 10).
Dataset
Training
U. Mean
I. Mean
NMF
PMF
SoRec
PTBR
Matchbox
HeteroMF
DPMF
Delicious
80%
0.4389
0.4280
0.3814
0.3811
0.3566
0.3499
0.3297
0.3301
0.2939
33,03%
31,33%
22,94%
22,88%
17.58%
16.00%
10.85%
10.96%
Improvement
60%
0.3965
0.4087
0.3779
0.3911
0.3681
0.3599
0.3387
0.3434
0.3047
23,15%
25,44%
19,37%
22,09%
17.22%
15.33%
10.03%
11.26%
Improvement
Movielens
80%
0.8399
0.8467
0.7989
0.8106
0.774
0.7801
0.7605
0.7788
0.7658
8,82%
9,55%
4,14%
5,52%
1.05%
1.83%
-0.69%
1.66%
Improvement
60%
0.9478
0.9667
0.9011
0.9096
0.882
0.8912
0.8399
0.8360
0.8365
11,74%
13,46%
7,16%
8,03%
5.15%
6.13%
0.40%
-0.05%
Improvement
feature matrix. This approach has been improved in [29] by
taking into account only trusted friends for recommendation
while sharing the user latent dimensional matrix. Almost a
similar approach has been proposed in [30] and [31] who
include in the factorization process, trust propagation and
trust propagation with inferred circles of friends in social
networks respectively. In this same context, other approaches
have been proposed to consider social regularization terms
while factorizing the rating matrix. The idea is to handle
friends with dissimilar tastes differently in order to represent
the taste diversity of each user’s friends [2][3]. A number of
these methods are reviewed, analyzed and compared in [32].
Also, few works consider cross-domain recommendation,
where a user’s acquired knowledge in a particular domain
could be transferred and exploited in several other domains,
or offering joint, personalized recommendations of items in
multiple domains, e.g., suggesting not only a particular movie,
but also music CDs, books or video games somehow related
with that movie. Based on the type of relations between
the domains, Fern´andez-Tob´ıas et al. [33] propose to cate-
gorize cross-domain recommendation as: (i) content based-
relations (common items between domains) [34], and (ii)
collaborative ﬁltering-based relations (common users between
domain) [35][36]. However, almost all these algorithms are not
distributed.
Distributed recommendation: Serveral decentralized recom-
mendation solutions have been proposed mainly from a peer
to peer perspective, basically for collaborative ﬁltering [37],
search and recommendation [38]. The goal of these solutions
is to decentralize the recommendation process.
Other works have investigated distributed recommendation
algorithms to tackle the problem of scalability. Hence, Liu et
al. [25] provide a multiplicative-update method. This approach
is also applied to squared loss and to nonnegative matrix
factorization with an “exponential” loss function. Each of
these algorithms in essence takes an embarrassingly parallel
matrix factorization algorithm developed previously and di-
rectly distributes it across a MapReduce cluster. Gemulla et
al. [39] provide a novel algorithm to approximately factor
large matrices with millions of rows, millions of columns,
and billions of nonzero elements. The approach depends on a
variant of the Stochastic Gradient Descent (SGD), an iterative
stochastic optimization algorithm. Gupta et al. [40] describe
scalable parallel algorithms for sparse matrix factorization,
analyze their performance and scalability. Finally, Yu et al.
[41] uses coordinate descent, a classical optimization approach,
for a parallel scalable implementation of matrix factorization
for recommender system. More recently, Shin et al. [42]
proposed two distributed tensor factorization methods, CDTF
and SALS. Both methods are scalable with all aspects of data
and show a trade-off between convergence speed and memory
requirements.
However, note that almost all the works described above
focus mainly on decentralizing and parallelizing the matrix
factorization computation. To the best of our knowledge, none
of the existing distributed solutions proposes a distributed
recommendation approach using diverse data sources.
VIII.
CONCLUSION
In this paper, we proposed a new distributed collabora-
tive ﬁltering algorithm, which uses and combines multiple
and diverse data matrices provided by online services to
improve recommendation quality. Our algorithm is based on
the factorization of matrices, and the sharing of common
latent features with the recommender system. This algorithm
has been designed for a distributed setting, where the ob-
jective was to avoid sending the raw data, and parallelize
the matrix computation. All the algorithms presented have
been evaluated using two different datasets of Delicious and
Movielens. The results show the effectiveness of our approach.
Our method consistently outperforms almost all the state-of-
the-art approaches in all the settings of both datasets. Only
Matchbox and HeteroMF slightly outperform our method on
the Movielens dataset.
REFERENCES
[1]
Hao Ma, Haixuan Yang, Michael R. Lyu, and Irwin King.
Sorec:
Social recommendation using probabilistic matrix factorization. In Pro-
ceedings of the 17th ACM Conference on Information and Knowledge
Management, CIKM ’08, pages 931–940, New York, NY, USA, 2008.
ACM.
[2]
Hao Ma, Dengyong Zhou, Chao Liu, Michael R. Lyu, and Irwin King.
Recommender systems with social regularization. In Proceedings of the
Fourth ACM International Conference on Web Search and Data Mining,
WSDM ’11, pages 287–296, New York, NY, USA, 2011. ACM.
[3]
Joseph Noel, Scott Sanner, Khoi-Nguyen Tran, Peter Christen, Lexing
Xie, Edwin V. Bonilla, Ehsan Abbasnejad, and Nicolas Della Penna.
New objective functions for social collaborative ﬁltering. In Proceed-
ings of the 21st International Conference on World Wide Web, WWW
’12, pages 859–868, New York, NY, USA, 2012. ACM.
[4]
J. J. Levandoski, M. Sarwat, A. Eldawy, and M. F. Mokbel. Lars: A
location-aware recommender system. In 2012 IEEE 28th International
Conference on Data Engineering, pages 450–461, April 2012.
[5]
Hao Wang, Manolis Terrovitis, and Nikos Mamoulis. Location recom-
mendation in location-based social networks using user check-in data. In
Proceedings of the 21st ACM SIGSPATIAL International Conference on
Advances in Geographic Information Systems, SIGSPATIAL’13, pages
374–383, New York, NY, USA, 2013. ACM.
[6]
Soﬁane Abbar, Sihem Amer-Yahia, Piotr Indyk, and Sepideh Mahabadi.
Real-time recommendation of diverse related articles. In Proceedings
of the 22Nd International Conference on World Wide Web, WWW ’13,
pages 1–12, New York, NY, USA, 2013. ACM.
54
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

[7]
Cai-Nicolas Ziegler, Sean M. McNee, Joseph A. Konstan, and Georg
Lausen. Improving recommendation lists through topic diversiﬁcation.
In Proceedings of the 14th International Conference on World Wide
Web, WWW ’05, pages 22–32, New York, NY, USA, 2005. ACM.
[8]
Mi Zhang and Neil Hurley. Avoiding monotony: Improving the diversity
of recommendation lists. In Proceedings of the 2008 ACM Conference
on Recommender Systems, RecSys ’08, pages 123–130, New York, NY,
USA, 2008. ACM.
[9]
Paul Resnick and Hal R Varian. Recommender Systems. Commun.
ACM, 40(3):56–58, 1997.
[10]
Suvash Sedhain, Scott Sanner, Darius Braziunas, Lexing Xie, and Jor-
dan Christensen. Social collaborative ﬁltering for cold-start recommen-
dations. In Proceedings of the 8th ACM Conference on Recommender
Systems, RecSys ’14, pages 345–348, New York, NY, USA, 2014. ACM.
[11]
Ricardo A Baeza-Yates and Berthier Ribeiro-Neto. Modern Information
Retrieval. Addison-Wesley Longman Publishing Co., Inc., 2 edition,
2010.
[12]
Ruslan Salakhutdinov and Andriy Mnih. Probabilistic matrix factoriza-
tion. In Proceedings of the 20th International Conference on Neural
Information Processing Systems, NIPS’07, pages 1257–1264, USA,
2007. Curran Associates Inc.
[13]
Delbert Dueck and Brendan J Frey. Probabilistic sparse matrix factor-
ization. Technical report, 2004.
[14]
Robert Wetzker, Carsten Zimmermann, and Christian Bauckhage. Ana-
lyzing Social Bookmarking Systems: A del.icio.us Cookbook. In ECAI,
2008.
[15]
Mohamed Reda Bouadjenek, Hakim Hacid, and Mokrane Bouzeghoub.
SoPRa: A New Social Personalized Ranking Function for Improving
Web Search.
In Proceedings of the 36th International ACM SIGIR
Conference on Research and Development in Information Retrieval,
SIGIR ’13, pages 861–864, New York, NY, USA, 2013. ACM.
[16]
Mohamed Reda Bouadjenek, Hakim Hacid, Mokrane Bouzeghoub, and
Athena Vakali. Persador: Personalized social document representation
for improving web search. Information Sciences, 369:614 – 633, 2016.
[17]
A. Montresor and M. Jelasity.
Peersim: A scalable p2p simulator.
In Peer-to-Peer Computing, 2009. P2P ’09. IEEE Ninth International
Conference on, pages 99–100, Sept 2009.
[18]
Daniel D Lee and H Sebastian Seung. Learning the parts of objects by
non-negative matrix factorization. Nature, 401(6755):788–791, 1999.
[19]
Ido Guy, Naama Zwerdling, Inbal Ronen, David Carmel, and Erel Uziel.
Social media recommendation based on people and tags. In Proceedings
of the 33rd International ACM SIGIR Conference on Research and
Development in Information Retrieval, SIGIR ’10, pages 194–201, New
York, NY, USA, 2010. ACM.
[20]
David H. Stern, Ralf Herbrich, and Thore Graepel. Matchbox: Large
scale online bayesian recommendations.
In Proceedings of the 18th
International Conference on World Wide Web, WWW ’09, pages 111–
120, New York, NY, USA, 2009. ACM.
[21]
Mohsen Jamali and Laks Lakshmanan.
Heteromf: Recommendation
in heterogeneous information networks using context dependent factor
models. In Proceedings of the 22Nd International Conference on World
Wide Web, WWW ’13, pages 643–654, New York, NY, USA, 2013.
ACM.
[22]
Hao Ma. An Experimental Study on Implicit Social Recommendation.
In SIGIR, 2013.
[23]
Jovian Lin, Kazunari Sugiyama, Min-Yen Kan, and Tat-Seng Chua.
Addressing cold-start in app recommendation: Latent user models con-
structed from twitter followers. In Proceedings of the 36th International
ACM SIGIR Conference on Research and Development in Information
Retrieval, SIGIR ’13, pages 283–292, New York, NY, USA, 2013.
ACM.
[24]
Suvash Sedhain, Scott Sanner, Lexing Xie, Riley Kidd, Khoi-Nguyen
Tran, and Peter Christen.
Social afﬁnity ﬁltering: Recommendation
through ﬁne-grained analysis of user interactions and activities.
In
Proceedings of the First ACM Conference on Online Social Networks,
COSN ’13, pages 51–62, New York, NY, USA, 2013. ACM.
[25]
Fengkun Liu and Hong Joo Lee. Use of social network information
to enhance collaborative ﬁltering performance.
Expert Syst. Appl.,
37(7):4772–4778, 2010.
[26]
Ido Guy, Naama Zwerdling, David Carmel, Inbal Ronen, Erel Uziel,
Sivan Yogev, and Shila Ofek-Koifman. Personalized recommendation
of social software items based on social relations. In Proceedings of the
Third ACM Conference on Recommender Systems, RecSys ’09, pages
53–60, New York, NY, USA, 2009. ACM.
[27]
Xin Wang, Steven C.H. Hoi, Chenghao Liu, and Martin Ester. Inter-
active social recommendation. In Proceedings of the 2017 ACM on
Conference on Information and Knowledge Management, CIKM ’17,
pages 357–366, New York, NY, USA, 2017. ACM.
[28]
Lin Xiao, Zhang Min, Zhang Yongfeng, Liu Yiqun, and Ma Shaoping.
Learning and transferring social and item visibilities for personalized
recommendation. In Proceedings of the 2017 ACM on Conference on
Information and Knowledge Management, CIKM ’17, pages 337–346,
New York, NY, USA, 2017. ACM.
[29]
Hao Ma, Irwin King, and Michael R. Lyu. Learning to recommend
with social trust ensemble. In Proceedings of the 32Nd International
ACM SIGIR Conference on Research and Development in Information
Retrieval, SIGIR ’09, pages 203–210, New York, NY, USA, 2009.
ACM.
[30]
Mohsen Jamali and Martin Ester.
A matrix factorization technique
with trust propagation for recommendation in social networks.
In
Proceedings of the Fourth ACM Conference on Recommender Systems,
RecSys ’10, pages 135–142, New York, NY, USA, 2010. ACM.
[31]
Xiwang Yang, Harald Steck, and Yong Liu. Circle-based recommenda-
tion in online social networks. In Proceedings of the 18th ACM SIGKDD
International Conference on Knowledge Discovery and Data Mining,
KDD ’12, pages 1267–1275, New York, NY, USA, 2012. ACM.
[32]
Xiwang Yang, Yang Guo, Yong Liu, and Harald Steck. A survey of
collaborative ﬁltering based social recommender systems.
Computer
Communications, 41(0):1–10, 2014.
[33]
Ignacio Fern´andez-Tob´ıas, Iv´an Cantador, Marius Kaminskas, and
Francesco Ricci.
Cross-domain recommender systems: A survey of
the state of the art. Proceedings of the 2nd Spanish Conference on
Information Retrieval. CERI, 2012.
[34]
Fabian Abel, Eelco Herder, Geert-Jan Houben, Nicola Henze, and
Daniel Krause. Cross-system user modeling and personalization on the
social web. User Modeling and User-Adapted Interaction, 23(2):169–
209, Apr 2013.
[35]
Pinata Winoto and Tiffany Tang. If You Like the Devil Wears Prada the
Book, Will You also Enjoy the Devil Wears Prada the Movie? A Study
of Cross-Domain Recommendations.
New Generation Computing,
26(3):209–225, June 2008.
[36]
Shlomo Berkovsky, Tsvi Kuﬂik, and Francesco Ricci. Mediation of user
models for enhanced personalization in recommender systems. User
Modeling and User-Adapted Interaction, 18(3):245–286, August 2008.
[37]
Anne-Marie Kermarrec and Francois Taiani.
Diverging towards the
common good: Heterogeneous self-organisation in decentralised rec-
ommenders. In Proceedings of the Fifth Workshop on Social Network
Systems, SNS ’12, pages 1:1–1:6, New York, NY, USA, 2012. ACM.
[38]
Fady Draidi, Esther Pacitti, and Bettina Kemme.
P2prec: A P2P
recommendation system for large-scale data sharing.
T. Large-Scale
Data- and Knowledge-Centered Systems, 3:87–116, 2011.
[39]
Rainer Gemulla, Erik Nijkamp, Peter J. Haas, and Yannis Sismanis.
Large-scale matrix factorization with distributed stochastic gradient
descent.
In Proceedings of the 17th ACM SIGKDD International
Conference on Knowledge Discovery and Data Mining, KDD ’11, pages
69–77, New York, NY, USA, 2011. ACM.
[40]
Anshul Gupta, George Karypis, and Vipin Kumar.
Highly scalable
parallel algorithms for sparse matrix factorization. IEEE Trans. Parallel
Distrib. Syst., 8(5):502–520, May 1997.
[41]
Hsiang-Fu Yu, Cho-Jui Hsieh, Si Si, and Inderjit Dhillon.
Scalable
coordinate descent approaches to parallel matrix factorization for rec-
ommender systems. In Proceedings of the 2012 IEEE 12th International
Conference on Data Mining, ICDM ’12, pages 765–774, Washington,
DC, USA, 2012. IEEE Computer Society.
[42]
Kijung Shin, Lee Sael, and U Kang.
Fully scalable methods for
distributed tensor factorization. IEEE Trans. on Knowl. and Data Eng.,
29(1):100–113, January 2017.
55
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-637-8
DBKDA 2018 : The Tenth International Conference on Advances in Databases, Knowledge, and Data Applications

