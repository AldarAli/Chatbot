Transforming Basic Robotic Platforms into Easily
Deployable and Web Remotely Controllable Robots
Yvon Autret∗, Jean Vareille ∗, Philippe Le Parc∗
∗Universit´e Europ´eenne de Bretagne, France
Universit´e de Brest - EA3883 LISyC
Laboratoire d’Informatique des Syst`emes Complexes
20 av. Victor Le Gorgeu, BP 809, F-29285 Brest
Contact E-mail: {yvon.autret, jean.vareille, philippe.le-parc}@univ-brest.fr
Abstract—This paper describes a way to transform basic
robotic platforms into Web remotely controllable robots. Our
goal is to achieve robot deployment anywhere, at anytime, at
low-cost. As soon as full or even restricted Internet access is
available (WiFi or 3G), the robot can be deployed and Web-
controlled. The distant user can send commands to the robot
and monitor the state of the robot. For example, the distant user
can make the robot move and get snapshots taken by the robot.
Keywords - Ubiquitous robot, Web control, service robotics.
I. INTRODUCTION
In the past years, we have been working on models for
ubiquitous systems [1] and one current application is an
ubiquitous system to enable persons with disabilities (related
to age or illness) to stay living in their home. In such an
application there are ﬁx devices and mobile devices. From our
point of view, available mobile devices (autonomous robots)
are not satisfactory. Some of them are very expensive and
sometime not reliable, others are difﬁcult to control. The
autonomy is also a major problem. The aim of this paper is to
propose a robot architecture especially designed for this kind
of HAL environment (Human Assisted Living Environment).
We focus on two main constraints. First, the robot must be
cheap enough to keep the proposed HAL system accessible to
the users. Second, it must be controllable over the network.
The use of network technologies inside robots is nowadays
classical [2], [3]. A WiFi network can be used and an on-board
Web server may allow control of the robot from anywhere in
the world. This solution can be easily implemented. It is used
in the commercial Rovio WowWee robot [12]. Unfortunately,
it has some disadvantages. First, a moving robot evolves in a
limited WiFi area and may get out of control. That is a major
problem for outdoor robots. Second, a robot including an on-
board server cannot use any WiFi router without conﬁguration.
This means that deploying a remote controlled robot is not a
”plug-and-play” operation.
Current 3G coverage is now so wide that it provides almost
universal Internet access. Unfortunately, 3G networks are not
perfect for remote control of robots. Many 3G providers block
all ports except some outgoing ports (HTTP port 80, HTTPS
port 443, etc.). This means that an on-board web server cannot
work on a remote controlled robot. This restriction can be
overcome by using HTTP tunnelling [7]. A distant server
is used and all communications performed are encapsulated
using the HTTP protocol. The main problem of this solution
is often the lack of performance due to the overhead of
communications in the distant server.
In this paper, we propose to use distant servers for only one
purpose: ensuring efﬁcient robot control in a restricted Internet
environment. We will adapt HTTP tunneling to remote robot
control in order to guarantee correct performances and simple
conﬁguration. The remote user has no direct access to the robot
and sends commands to a distant server which will transmit
them to the robot (Fig. 1). On the other side, the robot can
send its state to the distant server, making it available to the
user (internal state of the robot, snapshots of the environment,
etc).
The distant server can control several robots which can be in
various locations. The only thing required is the ability of the
robot to send HTTP requests to the distant server. Either WiFi
or restricted 3G networks can be used. Installing a robot at
anytime and anywhere in the world is possible as soon as basic
Internet access is available (for example, only an outgoing port
80).
In this paper, we ﬁrst present a basic robotic platform
which includes a robot that moves/turns forward or backward
on tracks when powered. It is used with a computer which
has the ability to control the robotic platform and get an
Internet access. We then show how to obtain Web-control
and transform it into a communicating robot which can be
easily deployed anywhere. This ubiquitous robot [4], [5], [6]
is designed to be integrated in an ubiquitous environment.
Fig. 1.
The proposed architecture.
123
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

II. THE BASIC ROBOTIC PLATFORM
Many commercial Web-controllable robots such as Miabot
[13] or WoWee Rovio [12] are available. They can be used
in an ubiquitous environment to monitor a house. The Miabot
robot is rather small (about 3 inches long). The WoWee is
bigger (about 14 inches long). Both are not easily expandable.
That is why we start from an open robotic platform which
includes only two tracks. It is a Rover 5 from RobotBase (Fig.
2). The size is that of the WoWee Rovio. When powered, it
can move forward or backward and turn. It is strong enough
to carry a computer and some electronic devices (up to two
kilograms). The robot is controlled by the computer it carries
and the computer is connected to the network to get Web-
control. As the computer is a standard PC, external devices
can be easily connected to upgrade the robot. The total cost
(computer included) is comparable to that of a WoWee Rovio.
Our robot is designed to be integrated in a low-cost ubiquitous
system.
The computer we use is a PC which can be disk-less and
screen-less and must run on batteries. We made tests with a
Linutop computer [14] as well as with a standard mini laptop.
A USB key (3G key or WiFi Key) provides Internet access.
A Linux system (ISO ﬁle) is set on another USB Key and
the computer boots from it in such a way that the whole
system is running in Ram-Disk. The system is conﬁgured to
automatically load the network conﬁguration (WiFi WEP key,
etc.) from a text ﬁle on the USB key. This text ﬁle is not
included into the ISO system ﬁle. This ﬁle is loaded by the
Linux system at boot time (the system executes an ”ifup”
Linux command to load the network conﬁguration). Thus,
editing this ﬁle before starting the system is the only thing
required to ensure network connection.
A Phidget 1017 electronic board (Fig. 3) including an USB
port and 8 DPDT relays (Double-Pole Double-Throw) is used
as an interface between the computer and the robot [11], [15].
We use the Java language to control the relays.
The Phidget board just avoid soldering and micro-controller
programming. The computer controls the DPDT relays through
the USB port. Two relays (one per track) are used to make
the robot presented above move or turn. Two more relays are
required to reverse the current (one per track) and make the
robot move or turn, forward or backward.
Fig. 2.
The basic Rover 5 robot.
III. WEB-CONTROL OF THE ROBOT
We want our system working even if Internet access is
restricted, i.e. if some ports are not available. For example,
the system must work if there is only one outgoing port 80
available. That means that the robot cannot wait neither for
HTTP requests nor any other request. The robot will only
send HTTP requests and wait for HTTP responses. Our robot
has the ability to do that because the system is connected to
the Internet and a Java program inside a Unix process can be
launched to send HTTP requests.
On the user side, it is the same thing. We want the distant
user send only HTTP requests and wait for HTTP responses.
The only thing required on the user side will be a Web browser,
for example, running on a PC Phone.
A. The distant server
In that system, the distant user has no direct access to the
robot and we use an additional distant server. The distant user
sends a robot command to the distant Web server through a
Web interface. The distant server forwards the command to
the robot.
1) Encapsulating robot commands into HTTP requests:
To send commands to the robot, the distant user uses a Web
interface which displays buttons and various ﬁelds. A robot
command is nothing but a Web form. For example, the distant
user clicks on the ”MOVE FORWARD” button to make the
robot move forward. Parameters can be used, for example,
how long the robot must keep moving. The Web browser
will automatically encapsulate the parameters of the robot
command (i.e the Web form) inside an HTTP request. The
distant server processes the request as soon as it is sent.
2) Processing HTTP requests by Servlets:
To process
HTTP requests on the distant server, we use an Apache Web
server [8]. Requests received are ﬁrst forwarded to a second
Web server which is a Tomcat Web server [9]. Servlets running
on the Tomcat server process the requests and extract the
parameters (Fig. 4). The Apache server is only used to provide
a standard access on port 80.
3) Forwarding requests to the robot: As we want the
system working with very limited Internet access, may be only
outgoing port 80, it is not possible to install any kind of server
on the robot. To make the system work, the robot ﬁrst sends an
HTTP request to the distant server. The request is processed
Fig. 3.
Phidget wiring.
124
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

by a Servlet and let pending. As soon as the distant user sends
a robot command, the HTTP request processing resumes and
an HTTP response is sent to the robot. The robot command
is inserted in the HTTP response as a serialized object. If
the distant user does not send a robot command within a
few seconds, a timeout is triggered on the robot system. The
robot stops waiting for the current HTTP response. A new
HTTP request is sent to the distant server to wait for a robot
command. The system is working in four steps as shown above
(Fig.4) and below:
• The robot sends an HTTP request to wait for one com-
mand.
• The user sends an HTTP request which contains the robot
command.
• After having inserted the robot command in the HTTP
response, the distant server sends it to the robot.
• The HTTP response is sent to the user. This response can
carry various information about command processing by
the robot: in progress, not taken into account, etc.
4) Acknowledgment: An optional acknowledgment can be
sent from the robot to the distant server. As soon as the robot
has received or terminated a command, it can send an HTTP
request to the distant server. This optional acknowledgment
can also be sent from the distant server to the distant user.
B. Synchronisation and Servlet programming
The distant server synchronizes asynchronous HTTP re-
quests from the distant user and the robot. There is no
synchronization across the Internet except for single HTTP
requests. Synchronization only appears in the Servlet. It is
implemented by using Java monitors (”wait’ and ”notify”).
When the robot sends an HTTP request, a ”wait” is executed
in the Servlet. When the distant user sends an HTTP request
containing a robot command, a ”notify” is executed to let the
HTTP response including the robot command come back to
the robot. From the robot, a Java program only sends HTTP
requests and processes the responses.
Fig. 4.
Using Servlets for synchronization.
IV. FULL ROBOT SENDING IMAGES
The robot platform includes a PC computer and can be
easily extended. Any device that can be connected to a PC can
be added to the robot platform and we focus on the example
of a Webcam. One or more Webcam can be connected to
the computer (Fig. 5). By using the same mechanism as that
shown above, the robot can send information about itself or
its environment to the distant server. In fact, as the distant
user sends requests to make the robot move, the distant user
send other requests to get information about the robot. In this
chapter, we will focus on how the distant user can get images
taken by the robot.
A. The distant user asks for images
The distant user can click on a button in the user interface
to ask for images. The distant user can also let the browser
automatically ask for images. In this case, a thread in the
browser periodically asks for images. In both cases, as seen
in III-A, an HTTP request is sent to the robot to ask for an
image.
B. The robot processes the image request
On the robot there is a Unix process to wait for robots
commands (MOVE, TURN, etc.). A second Unix process is
used to produce the images. We use a third Unix process to
wait for images requests and send the images. As the ﬁrst
process, these processes are automatically launched when the
robot is powered. The second Unix process is a local WEB
server on the computer of the robot. Its role is to get images
from the Webcam and make them available through a local
Web server. We use MJPG-streamer [16] (also called MJPEG-
streamer or M-JPEG-streamer) to do that . It is a light solution
to stream JPEG ﬁles over an IP-based network. It can get
images from a Webcam plugged on a USB port. We use the
following options:
• ”- - resolution 320x240” to send images of that size
• ”- - device /dev/video0 -y” so the streamer can only use
”yuv” mode to output the images (this is because our PC
is USB2.0)
• ”- - port 8090” to ouput images on port 8090
Fig. 5.
Robot components including Webcam
125
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

MJPG-streamer is able to send streams over the network but
we use it only to send snapshots. MJPG-streamer is not CPU
hungry. It consumes less than 10% CPU. Several Webcams can
be connected to the PCs and several MJPG-streamer can be
launched (/dev/video0 port 8090, /dev/video1 port 8091, etc.).
The third Unix process is used to wait for image requests from
the distant user. It gets the images from the second process
(MJPG-streamer) and sends them to the distant server which
forwards them to the distant user. The process waits for image
requests as if it was waiting for other robot commands. An
HTTP request is sent from the distant user to the distant server
which ensures synchronization. We just use a different Servlet
to let this HTTP request pending until an image request comes
from the distant user. When the third process receives the
HTTP response from the distant server, it sends a new HTTP
request to the MJPG-streamer server. The aim of this request
is to get an image. To get the image, we use an URL such as
http://localhost:8090/
?action=snapshot
The HTTP response contains a JPEG image which is
extracted and sent to the distant server as an attached ﬁle in an
HTTP request. Standard Java classes ”URL” and ”HttpURL-
Connection” are used to do that. On the distant server, we use
the Apache FileUpload package to extract the attached ﬁle
from the request and we write it to a ﬁle which can be loaded
and displayed by a Web Browser.
C. The distant server sends the image to the distant user
In fact, it is the distant user who asks for the image. To
send the HTTP request from the browser, we use the Javascript
language and the jQuery library [10]. As shown below, we use
Ajax capabilites of jQuery to perform an asynchronous HTTP
request.
$.ajax({
type: "get",
url: "../servletImage1",
async: false,
success: function (data) {
...
}
});
The HTTP request is processed on the distant server and
we have seen that the robot ﬁnally sends an image to the
distant server. A ﬁle containing an image is created on the
distant server. Synchronization is required inside the distant
server. The HTTP request from the distant user must be let
pending until a new image comes from the robot. At that
time, a response is sent to the distant user. On the user side,
the Ajax call is a success and a Javascript function is called.
This function has one parameter indicating whether an image
is available or not. If there are several distant user requests
pending, only one will get the ability to display the new image
and the other distant user requests will have no effect on the
user interface. To display the image, we use jQuery to modiﬁy
the DOM (to modify the HTML elements). An ”img” HTML
tag is present the distant user Web page. We use jQuery to
modify the ”src” attribute and change the displayed image.
$("webcam0").attr("src",
"../servletImage2/?val="+
Math.random());
We use a Servlet to ensure that one image cannot be sent
twice to the distant user. The Servlet always sends the last
image produced. It sends an HTTP response whose content
type is ”image/jpeg” and content is a JPEG image. The
”Math.random” parameter shown above just avoids the image
staying in a cache. A network failure will not affect the system.
Only some images will be lost.
D. The user interface
The user interface is a Web page. A form (not shown below)
is used to identify the distant user and to ensure that the robot
is available. When identiﬁed, the distant user can use buttons
to make the robot move. Images are displayed as they come
from the robot. Two parameters are available in the interface
shown in Fig. 6. The distant user can set the duration of a
robot command and the number of ms between two image
requests. The distant user can also monitor the network state
and get information about the time required to get the last
image.
E. Performances
Figure 7 shows the working robot powered with AA batter-
ies. By using a WiFi connection, the robot sends an average
of three images per second. By using a 3G connection, it is
almost one image per second.
Fig. 6.
The user interface.
126
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Fig. 7.
The working robot.
V. CONCLUSION AND FUTURE TRENDS
The proposed system can work indoor or outdoor. It uses
free software (the Linux operating system) and thanks to
HTTP, can recover from temporary network failures. In the
future, it could be integrated in an ubiquitous environment
for remote monitoring. It is a cheap and modular platform.
The computer boots from a memory which is external. The
mechanical and electromechanical parts are separated from
the computer which is itself separated from the digital storage
medium that carries the operating system. In case of failure
of a component, the system can be repaired and restarted in
a short time. MTTR (mean time to repair) is signiﬁcantly
reduced.
The hardware and the sofware of the proposed robot can
be easily upgraded. Local or remote image processing could
be performed. GPS or UWB (Ultra Wide Band) components
could be added for localization. If one component is added,
the operating system and the software can be upgraded plug
and play. There is only one USB key to replace.
When using the Linutop computer, autonomy is limited to
10mn. When using a laptop, it goes up to 1 hour or more but
a laptop is not easy to carry. Using a small tablet PC will be
probably a better solution as soon as a whole Linux system
will be available for them.
In the future, a better network management could also
be implemented. For example, as soon as the WiFi signal
becomes weak, the system should be able to automatically
switch to 3G.
REFERENCES
[1] A. Touil, J. Vareille, F. L’Herminier, P. Le Parc. Modeling and Analysing
Ubiquitous Systems Using MDE Approach.
The Fourth International
Conference on Mobile Ubiquitous Computing, Systems, Services and
Technologies. Florence, Italy. October 2010.
[2] K. Goldberg, R. Siegwart. Beyond Webcams : an introduction to online
robots.
The MIT Press, 2001.
[3] P. Le Parc, J. Vareille and L. Marce. Web remote control of machine-
tools the whole world within less than one half-second.
In ISR 2004 :
International Symposium on Robotics, Paris, France, March 2004.
[4] J.H. Kim, Y.D. Kim, K.H. Lee. The third generation of robotics: Ubiqui-
tous robot. Proc of the 2nd Int Conf on Autonomous Robots and Agents,
December 13-15, 2004 Palmerston North, New Zealand.
[5] Y.G. Ha, J.C. Sohn, Y.J. Cho, H. Yoon. Towards a ubiquitous robotic
companion: Design and implementation of ubiquitous robotic service
framework.
ETRI journal, volume 27, number 6, pp 666-676, Elec-
tronics and Telecommunications Research Institute, 161 Gajeong-Dong,
Yuseong-Gu, Daejeon, 305-350, South Korea, 2005.
[6] J.H. Kim, K.H. Lee, Y.D. Kim. Ubiquitous robot: Recent progress and
development.
SICE-ICASE, 2006. International Joint Conference , pp.I-
25-I-30, Oct. 2006.
[7] E. Pitt. Fundamental Networking in Java.
Springer London Ltd, 2010.
[8] B. Laurie, P. Laurie. Apache: The Deﬁnitive Guide, 3rd Edition. O’Reilly,
3rd Revised edition, 2003.
[9] V. Chopra, S. Li, J. Genender. Professional Apache Tomcat 6.
John
Wiley & Sons Inc, 2007.
[10] B. Bibeault, Y. Katz. jQuery in Action.
Manning Publications, 2010.
[11] C. Fitchett, S. Greenberg. The Phidget Architecture: Rapid Development
of Physical User Interfaces.
UbiTools’01 Workshop on Application
Models and Programming Tools for Ubiquitous Computing. Held as part
of UBICOMP 2001.
[12] WoWee
Rovio,
a
Wi-Fi
enabled
mobile
webcam.
http://www.wowwee.com/en/products/tech/telepresence/rovio/rovio.
Online; accessed June 29, 2011.
[13] J.
Baxter.
Introduction
to
the
Miabots
&
Robot
Soccer.
http://www.asap.cs.nott.ac.uk/˜robots/talks/asap-talk-2.ps.
Online;
accessed June 29, 2011.
[14] Linutop.
http://www.linutop.com. Online; accessed June 29, 2011.
[15] Phidgets.
http://www.phidgets.com. Online; accessed June 29, 2011.
[16] Mjpg-streamer.
http://sourceforge.net/projects/mjpg-streamer. Online;
accessed June 29, 2011.
127
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-171-7
UBICOMM 2011 : The Fifth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

