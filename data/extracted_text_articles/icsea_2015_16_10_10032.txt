Teaching Robotics and Mechanisms
with MATLAB
Daniela Marghitu
Computer Science and Software Engineering Dept.
Auburn University
Auburn, Alabama 36830
Email: marghda@auburn.edu
Dan Marghitu
Mechanical Engineering Dept.
Auburn University
Auburn, Alabama 36830
Email: marghdb@auburn.edu
Abstract—Engineering mechanics involves the development of
mathematical models of the physical world. Mechanisms and
robots address the motion and the dynamics of kinematic links.
MATLAB is a modern tool that has transformed mathematical
methods because MATLAB not only provides numerical cal-
culations but also facilitates analytical or symbolic calculations
using the computer. The intent is to show using an R(rotation)-
R(rotation)T(translation)R(rotation) chain the convenience of
MATLAB for theory and applications in mechanisms. The dis-
tinction of the study from other projects is the use of MATLAB
for symbolic and numerical applications. This project is intended
primarily for use in dynamics of multi-body systems courses. The
MATLAB graphical user interface enables students to achieve
mechanisms programming helping this way the retention in
engineering courses. The project can be used for classroom
instruction, for self-study, and in a distance learning environment.
It would be appropriate for use as an undergraduate level.
Keywords–MATLAB; symbolic calculations; kinematic chain.
I.
INTRODUCTION
In this paper, MATLAB is considered for a mathemati-
cal equations of a three moving link kinematic chain. The
achievements in the robot starting with the development of the
recursive Newton-Euler algorithm are given in [1]. Algorithms
and equations can be developed using Kane’s equations [2]
and are of great value. The system kinematics are computed
from experimental measurements in [3]. The method for the
kinematics of rigid bodies connected by three degrees of
freedom rotational joints uses the position measurements.
The kinematics of a simulated three-link model and of an
experimentally measured motion of human body during ﬂight
phase of a jump are discussed. The use of Mathematica and
MATLAB for the analysis of mechanical systems is developed
in [4] [5] [6]. Educational robotics research studies [7] and
our experience of teaching robotics has shown robotics to be
one of the best context for teaching computational thinking
and problem solving. Habib presented the methodology of
integrating MATLAB/Simulink into mechanical engineering
curricula [8]. The beneﬁts of integrating MATLAB are the
basic concepts, the graphical visualization, and the mathe-
matical libraries. MATLAB software packages for biomedical
engineers including nonlinear dynamics and entropy-based
methods were presented in [9] and are suitable for an upper-
level undergraduate course.
This paper describes the systematic computation of motion
for a three link chain using MATLAB. The software combines
symbolical and numerical computations and can be applied to
ﬁnd and solve the motion for humans, animals, and robotic
systems.
II.
POSITION ANALYSIS
The planar R-RTR chain is considered is shown in Figure 1.
The driver link is the rigid link 1 (the link AB). The following
numerical data are given: AB = 0.10 m, and CD = 0.18 m.
The angle of the driver link 1 with the horizontal axis is φ =
45◦. The constant angular speed of the driver link 1 is 100 rpm.
A Cartesian reference frame xy is selected. The joint A is in
x (m)
-0.2
-0.15
-0.1
-0.05
0
0.05
0.1
0.15
0.2
y (m)
-0.2
-0.15
-0.1
-0.05
0
0.05
0.1
0.15
0.2
A
B
C
D
φ
1
2
3
Figure 1. R-RTR chain.
the origin of the reference frame, that is, A ≡ O,
xA = 0
and
yA = 0.
The coordinates of the joint C are given
xC = 0.05 m and
yC = −xC.
Position of joint B
The unknowns are the coordinates of the joint B, xB and yB.
Because the joint A is ﬁxed and the angle φ is known, the
coordinates of the joint B are computed from the following
415
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

expressions
xB = AB cos φ,
yB = AB sin φ.
(1)
The MATLAB commands for joints A, C, and B are:
AB = 0.10 ;
% (m)
CD = 0.18 ;
% (m)
phi = pi/4;
% (rad)
xA = 0; yA = 0;
rA_ = [xA yA 0];
xC =
0.05;
% (m)
yC = -xC;
rC_ = [xC yC 0];
xB = AB*cos(phi);
yB = AB*sin(phi);
rB_ = [xB yB 0];
Angle φ2
The angle of link 2 (or link 3) with the horizontal axis is
calculated from the slope of the straight line BC:
φ2 = φ3 = arctan yB − yC
xB − xC
.
(2)
Position of joint D
The unknowns are the coordinates of the joint D, xD and yD
xD = xC + CD cos φ3,
yD = yC + CD sin φ3.
(3)
The MATLAB commands for the position of D are:
phi2 = atan((yB-yC)/(xB-xC));
phi3 = phi2;
CB = norm([xB-xC, yB-yC]);
ux = (xB - xC)/CB;
uy = (yB - yC)/CB;
xD = xC + CD*ux; yD = yC + CD*uy;
rD_ = [xD yD 0];
The components of the unit vector of the vector −−→
CD are ux
and uy. The numerical results are:
% phi = phi1 = 45 (degrees)
% rA_ = [ 0.000, 0.000,0] (m)
% rC_ = [ 0.050,-0.050,0] (m)
% phi2 = phi3 = 80.264 (degrees)
% rD_ = [ 0.080, 0.127,0] (m)
The position simulation for a complete rotation of the driver
link 1 (φ ∈ [0, 360◦]) is obtained with the MATLAB using
a loop command and the graphical representation is shown in
Figure 2.
III.
VELOCITY AND ACCELERATION ANALYSIS
The velocity of the point B1 on the link 1 is
vB1 = vA + ω1 × rAB = ω1 × rB,
(4)
where vA ≡ 0 is the velocity of the origin A ≡ O.
The angular velocity of link 1 is
ω1 = ω1 ˆk = πn
30
ˆk = π(100)
30
ˆk rad/s.
(5)
x (m)
-0.25
-0.2
-0.15
-0.1
-0.05
0
0.05
0.1
0.15
0.2
y (m)
-0.25
-0.2
-0.15
-0.1
-0.05
0
0.05
0.1
0.15
0.2
0.25
Figure 2. MATLAB representation of the R-RTR chain for a complete
rotation of the driver link.
The position vector of point B is
rAB = rB − rA = xBˆı + yB ˆ + zB ˆk.
(6)
The velocity of point B2 on the link 2 is vB2 = vB1 because
between the links 1 and 2 there is a rotational joint. The
velocity of B1 = B2 is
vB1 = vB2 =

ˆı
ˆ
ˆk
0
0
ω
xB
yB
0

.
(7)
The acceleration of the point B1 = B2 is
aB = aB1
=
aB2 = aA + α1 × rB + ω1 × (ω1 × rB)
=
−ω2
1rB.
(8)
The angular acceleration of link 1 is α1 = ˙ω1 = 0. The
MATLAB commands for the velocity and acceleration of B1 =
B2 are
vB1_ = vA_ + cross(omega1_,rB_);
vB2_ = vB1_;
aB1_ = aA_
+ cross(alpha1_,rB_) - ...
dot(omega1_,omega1_)*rB_;
aB2_ = aB1_;
The numerical results are:
% vB1_ = vB2_ =[-0.740, 0.740,0] (m/s)
% aB1_ = aB2_ =[-7.754,-7.754,0] (m/sˆ2)
The velocity of the point B3 on the link 3 is calculated in
terms of the velocity of the point B2 on the link 2
vB3 = vB2 + vrel
B32 = vB2 + vB32,
(9)
where vrel
B32 = vB32 is the relative acceleration of B3 with
respect to a reference frame attached to link 2. This relative
velocity is parallel to the sliding direction BC, vB32||BC, or
vB32 = vB32 cos φ2ˆı + vB32 sin φ2ˆ,
(10)
where φ2 is known from position analysis. The points B3 and
C are on the link 3 and
vB3 = vC + ω3 × rCB = ω3 × (rB − rC),
(11)
416
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

where vC ≡ 0 and the angular velocity of link 3 is ω3 = ω3ˆk.
Equations (9), (10), and (11) give

ˆı
ˆ
ˆk
0
0
ω3
xB − xC
yB − yC
0

=
vB2 + vB32 cos φ2ˆı + vB32 sin φ2ˆ.
(12)
Equation (12) represents a vectorial equations with two scalar
components on x-axis and y-axis and with two unknowns ω3
and vB32
−ω3(yB − yC) = vBx + vB32 cos φ2,
ω3(xB − xC) = vBy + vB32 sin φ2.
(13)
The vectorial equation (12) is obtained in MATLAB with:
omega3z=sym(’omega3z’,’real’);
vB32=sym(’vB32’,’real’);
omega3u_ = [ 0 0 omega3z];
vB3B2u_ = vB32*[cos(phi2) sin(phi2) 0];
vC_ = [0 0 0]; % C is fixed
vB3_ = vC_ + cross(omega3u_,rB_-rC_);
eqvB_ = vB3_ - vB2_ - vB3B2u_;
eqvBx = eqvB_(1); eqvBy = eqvB_(2);
The solutions of the system are obtained with:
solvB = solve(eqvBx,eqvBy);
omega3zs=eval(solvB.omega3z);
vB32s=eval(solvB.vB32);
omega3_ = [0 0 omega3zs];
omega2_ = omega3_;
vB3B2_ = vB32s*[cos(phi2) sin(phi2) 0];
The numerical results are:
% omega2_ = omega3_ = [0,0, 6.981](rad/s)
% vB32_ = [-0.102,-0.596,-0] (m/s)
The acceleration of the point B3 on the link 3 is calculated in
terms of the acceleration of the point B2 on the link 2
aB3 = aB2 + arel
B3B2 + acor
B3B2 = aB2 + aB32 + acor
B32,
(14)
where arel
B3B2 = aB32 is the relative acceleration of B3 with
respect to B2 on link 3. This relative acceleration is parallel
to the sliding direction BC, aB32||BC, or
aB32 = aB32 cos φ2ˆı + aB32 sin φ2ˆ.
(15)
The Coriolis acceleration of B3 realative to B2 is
acor
B32 = 2 ω3 × vB32 = 2 ω2 × vB32
= 2

ˆı
ˆ
ˆk
0
0
ω3
vB32 cos φ2
vB32 sin φ2
0

=
2(−ω3vB32 sin φ2ˆı + ω3vB32 cos φ2ˆ).
(16)
The points B3 and C are on the link 3 and
aB3 = aC + α3 × rCB − ω2
3rCB,
(17)
where aC ≡ 0 and the angular acceleration of link 3 is α3 =
α3ˆk. Equations (14), (15), (16), and (17) give

ˆı
ˆ
ˆk
0
0
α3
xB − xC
yB − yC
0

− ω2
3(rB − rC)
= aB2 + aB32(cos φ2ˆı + sin φ2ˆ) + 2 ω3 × vB32.(18)
Equation (18) represents a vectorial equations with two scalar
components on x-axis and y-axis and with two unknowns α3
and aB32
−α3(yB − yC) − ω2
3(xB − xC)
= aBx + aB32 cos φ2 − 2ω3vB32 sin φ2,
α3(xB − xC) − ω2
3(yB − yC)
= aBy + aB32 sin φ2 + 2ω3vB32 cos φ2.
(19)
The MATLAB commands for the calculating α3 and aB32 are:
aB3B2cor_ = 2*cross(omega3_,vB3B2_);
alpha3z=sym(’alpha3z’,’real’);
aB32=sym(’aB32’,’real’);
alpha3u_ = [0 0 alpha3z];
aB3B2u_ = aB32*[cos(phi2) sin(phi2) 0];
aC_ = [0 0 0]; % C is fixed
aB3_=aC_+cross(alpha3u_,rB_-rC_)- ...
dot(omega3_,omega3_)*(rB_-rC_);
eqaB_ = aB3_ - aB2_ - aB3B2u_ - ...
aB3B2cor_;
eqaBx = eqaB_(1); eqaBy = eqaB_(2);
solaB = solve(eqaBx,eqaBy);
alpha3zs=eval(solaB.alpha3z);
aB32s=eval(solaB.aB32);
alpha3_ = [0 0 alpha3zs];
alpha2_ = alpha3_;
aB32_ = aB32s*[cos(phi2) sin(phi2) 0];
and the vectorial solutions are:
% alpha2_=alpha3_=[0,0,-17.232](rad/sˆ2)
% aB3B2_=[ 0.505, 2.942,0] (m/sˆ2)
The velocity of D is
vD = vC + ω3 × rCD = ω3 × (rD − rC) =

ˆı
ˆ
ˆk
0
0
ω3
xD − xC
yD − yC
0

.
(20)
The acceleration of D is
aD = aC + α3 × rCD − ω2
3rCD =
α3 × (rD − rC) − ω2
3(rD − rC) =

ˆı
ˆ
ˆk
0
0
α3
xD − xC
yD − yC
0

−ω2
3 [(xD − xC)ˆı + (yD − yC)ˆ] .
(21)
The velocity and acceleration of D are calculated in MATLAB
with:
vD_ = vC_ + cross(omega3_,rD_-rC_);
aD_=aC_+cross(alpha3_,rD_-rC_)-...
dot(omega3_,omega3_)*(rD_-rC_);
417
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

IV.
DYNAMIC FORCE ANALYSIS
The force of gravity, G1, the force of inertia, Fin1, and the
moment of inertia, Min1, of the link 1 are calculated using the
MATLAB commands:
m1 = rho*AB*h*d;
G1_ = [0,-m1*g,0];
Fin1_ = -m1*aC1_;
IC1 = m1*(ABˆ2+hˆ2)/12;
IA
= m1*(ABˆ2+hˆ2)/3 ;
alpha1_ = [0 0 0];
Min1_ = -IC1*alpha1_;
For the links 2 and 3 there are similar MATLAB statements.
The joint forces are calculated using Newton-Euler equations
of motion for each link, as depicted in Figure 3. The dynamic
A
B
C
B
D
B
G2
C3
2
F12
C1
F21
(a)
F03
D
F23
M23
(b)
(c)
F32
M32
Me
Mm
C
G3
G1
F01
3
1
Figure 3. Free body diagrams for each link.
force analysis starts with the last link 3 because the given
external moment acts on this link. For link 3, the unknowns
are:
F23x=sym(’F23x’,’real’);
F23y=sym(’F23y’,’real’);
F23_=[F23x, F23y, 0];
M23z=sym(’M23z’,’real’);
M23_=[0, 0, M23z];
Because the joint between 2 and 3 at B is a translational joint
the reaction force F23_ is perpendicular to the sliding di-
rection BC: eqF23 = (rB_-rC_)*F23_.’;
A moment
equation for all the forces and moments that act on link 3 with
respect to the ﬁxed point C can be written:
eqM3C_ = cross(rB_-rC_,F23_)+....
cross(rC3_-rC_,G3_)+M23_+Me_-IC*alpha3_;
eqM3z = eqM3C_(3);
There are two scalar equations %(1) and %(2) with three
unknowns F23x, F23y, M23z. The force calculation will
continue with link 2. For link 2, a new unknown force, the
reaction of link 1 on link 2 at B, is introduced:
F12x=sym(’F12x’,’real’);
F12y=sym(’F12y’,’real’);
F12_=[F12x, F12y, 0];
The Newton-Euler equations of motion for link 2, are written
as:
eqF2_ = F12_+G2_+(-F23_)-m2*aC2_;
eqF2x = eqF2_(1);
eqF2y = eqF2_(2);
eqM2_ = -M23_ - IC2*alpha2_;
eqM2z = eqM2_(3);
Now there are 5 equations with 5 unknowns and the system
can be solve using MATLAB:
sol23=solve(eqF23,eqM3z,eqF2x,eqF2y,eqM2z);
F23xs=eval(sol23.F23x);
F23ys=eval(sol23.F23y);
F12xs=eval(sol23.F12x);
F12ys=eval(sol23.F12y);
M23zs=eval(sol23.M23z);
The motor moment, M_, required for the dynamic equilibrium
of the mechanism is determined from:
Mm_=IA*alpha1_-(cross(rC1_,G1_)+...
cross(rB_,-F12s_));
V.
CONCLUSION
The paper presented a modern tool to teach robotic systems
using MATLAB. MATLAB provides numerical and symbolical
calculations for an R-RTR kinematic chain. This study is
intended for use in mechanism and robotic courses for the
undergraduate level.
REFERENCES
[1]
R. Featherstone and D. Orin, “Robot dynamics: Equations and algo-
rithms,” in IEEE International Conference Robotics & Automation, San
Francisco, CA, 2000, pp. 826–834.
[2]
T. Kane and D. Levinson, “Kane’s dynamical equations in robotics,”
International Journal of Robotics Research, vol. 2(3), 1983, pp. 3–21.
[3]
J. Lee, H. Flashner, and J. McNitt-Gray, “Estimation of multibody
kinematics using position measurements,” Journal of Computational and
Nonlinear Dynamics, vol. 6(3), 2011, p. 9 pages.
[4]
D. Marghitu, Mechanical Engineer’s Handbook.
Academic Press, San
Diego, CA, 2001.
[5]
——, Kinematic Chains and Machine Component Design.
Elsevier,
Amsterdam, 2005.
[6]
D. Marghitu and M. Dupac, Advanced Dynamics: Analytical and Nu-
merical Calculations with MATLAB.
Springer, 2009.
[7]
J. Davis, B. Wellman, M. Anderson, and R. M., “Providing robotic
experiences through object-based programming (preop),” in Proceedings
of 2009 Alice Symposium in cooperation with SIGCSE, ACM, Durham,
NC, 2009.
[8]
M. Habib, “Enhancing mechanical engineering deep learning approach
by integrating matlab/simulink,” Int. J. Engng. Ed., vol. 21, 2005, pp.
906–914.
[9]
J. Semmlow and B. Griffel, Biosignal and Medical Image Processing.
CRC Press, 2014.
418
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

