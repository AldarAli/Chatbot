Invariant Preservation by Component Composition
Using Semantical Interface Automata
Sebti Mouelhi, Samir Chouali, Hassan Mountassir
Computer Science Laboratory (LIFC),
University of Franche-Comt´e, Besanc¸on, FRANCE
Email: {sebti.mouelhi, samir.chouali, hassan.mountassir}@lifc.univ-fcomte.fr
Abstract—Component assembly is based on the veriﬁcation
of the compatibility between the component interface speci-
ﬁcations. In general, these speciﬁcations do not combine the
three levels of the compatibility check: behavioral protocols,
signatures, and semantics of operations. In this paper, we
enrich the formalism of interface automata, used to specify
component protocols, by the signatures and semantics of
operations. We propose a new formalism, called “semantical
interface automata” (SIAs), endowed with a stronger compo-
sitional semantics than interface automata. The semantics of
operations is speciﬁed by pre and post-conditions stated over
their parameters and a set of variables reﬂecting the behavioral
conduct of components interoperability. First, we show how the
component compatibility is checked at the signature, semantic,
and protocol levels. Second, we establish a formal methodology
to check the preservation of invariants by composition of SIAs.
Keywords-software components; interface automata; action
semantics; formal correctness; invariants.
I. INTRODUCTION
An individual component is a software unit of a third-
party composition and deployment that encapsulates a set of
implemented offered services and asks for a set of required
ones [1]. The component interfaces depict its access points
and it must be associated to a contractual speciﬁcation that
specify the necessary sufﬁcient of its functional behavior at
the levels of the signatures and the semantics of operations
and the behavioral protocol, etc. [2], [3].
In this paper, we focus on assembling components whose
behaviors are described by interface automata [4] enriched
by the semantics of actions. The new formalism combines
the protocol and the semantic levels of interface speciﬁca-
tions, hence the name semantical interface automata. The
actions of a semantical interface automaton are annotated
by pre and post-conditions stated over the parameters of
their correspondent operations and a set of interface vari-
ables shared by the automaton and its environment. The
compatibility check of SIAs takes into account the action
constraints speciﬁed by these conditions. Furthermore, we
found a formal methodology to check correctness properties
thanks to the rich interface description of SIAs. Correctness
properties are typically invariants written in terms of the
interface variables. The invariance properties are assessed at
all the states of a labeled transition system representation of
a SIA. In particular, we study the invariant preservation by
component composition.
The paper is organized as follows. In Section II, we
present the SIAs formalism features and how we check their
composability and compatibility. In Section III, we explain
how LTS representations are extracted from SIAs and how
we check the preservation of invariants by composition
of SIAs. Related works are presented in Section IV. The
conclusion and future works are presented in Section V.
II. SEMANTICAL INTERFACE AUTOMATA
Interface automata (IAs) [4], [5] have been introduced
to model both the output behavior and the environment
assumptions of software components. These models are
non-input-enabled I/O automata [6], which means that at
every state some input actions may be non-enabled. Every
component interface is described by one interface automaton
where input actions are used to model methods that can
be called, the end of receiving messages, and the return
values from such calls, as well as exception treatment.
Output actions are used to model method calls, message
transmissions, exceptions, and sending return values. Hidden
actions represents local operations. The alphabet of an
interface automaton is built of its action names annotated
by “?” for input actions, by “!” for output actions, and by
“;” for hidden actions.
Before deﬁning semantical interface automata, we start
by giving some preliminaries. The signature of an action a
is the signature of its correspondent operation implemented
or solicited by the component that provokes the action. It
has the form a(i1,...,in) → (o) where n ≥ 0. The set P i
a =
{i1, ..., in} represents the set of input parameters of a. The
set P o
a is deﬁned by the singleton {o}. The absence of input
or output parameters is denoted by (). We suppose that an
action has no signature if it corresponds to a return value.
Given a set of components C, a SIA Ac of a component
c in C is deﬁned in relation to the other components in
C\{c}. This relation is based on a set of variables VC
shared between them. We denote, by Dw, the domain of
a variable or a parameter w. Given a set of variables V,
305
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

1
2
3
4
5
login!
notlogged?
logged?
addToPanel!
rentValid?
valdRental!
logout!
addToPanel!
logout!
Client AC
login
notLogged
logged
addToPanel
valdRental
logout
rentValid
rentNonValid
1
2
3
4
5
6
login?
notLogged!
logged!
addToPanel?
valdRental?
setDuration!
rentNonValid!
rentValid!
logout?
addToPanel?
logout?
Services AS
login
notLogged
logged
logout
addToPanel
valdRental
setDuration
rentValid
rentNonValid
Figure 1.
The semantical interface automata of the components Client and Services
Preds(V ) represents the set of ﬁrst order predicates whereof
free variables belong to V. We denote by p′ the predicate
obtained by replacing v by v′ in p ∈ Preds(V ). The set
Preds′(V ) is equal to {p′ | p ∈ Preds(V )}.
Deﬁnition 1: Given a component c ∈ C, a semantical
interface automaton Ac = ⟨SAc, iAc, ΣI
Ac, ΣO
Ac, ΣH
Ac, δAc,
LAc, VAc, InitAc, ΨAc⟩ of c consists of
• a ﬁnite set SAc of states containing an initial state iAc.
A is called “empty” if SA = ∅;
• three disjoint sets ΣI
Ac, ΣO
Ac and ΣH
Ac of inputs, output,
and hidden actions;
• a set δAc ⊆ SAc × ΣAc × SAc of transitions;
• a set LAc of local variables and a set VAc ⊆ VC of
shared variables. The set LVAc = VAc ∪LAc represents
the set of all variables of Ac;
• ΨAc is a function that associates for each action
a ∈ ΣAc a tuple ⟨PreΨAc(a), PostΨAc(a)⟩ such that
PreΨAc(a)
∈
Preds(VAc ∪ P i
a) and PostΨAc(a)
∈
Preds(VAc ∪ P i
a ∪ P o
a );
According to Deﬁnition 1, the pre and post-conditions are
deﬁned only in terms of parameters and shared variables.
They are used to verify the compatibility of two semantical
interface automata, then they should be deﬁned only on what
is shared between them. The presence of local variables can
be problematic because the local variables of one automaton
are unknown to the others.
Example 1: As an example, we will consider a simple
distributed multi-tier application that allows object leasing
between users. The component Services is a server side
component that plays the role of the mediator between the
Client and the database. It provides the operations login
that returns a reference to a persistent component User
(the output action logged!) that represents the authenticated
user or provokes an exception (notLogged!). It provides
also, for the registered users, the operations addToPanel,
valdRental, and logout. The ﬁrst method makes an object
to lend in the member panel, the second one validates its
request to rent the objects saved in his panel if the operation
addToPanel is called at least once, and the third one allows
the member logout. The component Services requires the
operation setDuration that affects a default rental duration
for the chosen resource and validates totally the rental
(rentValid!). An exception rentNonValid is detected if the
rental validation cannot be made. In Figure 1, we show the
SIAs AC and AS of the two components Client and Services.
The signatures of Services’s provided operations are lo-
gin(id,pass)→(user), logout()→(), addToPanel(res)→(), val-
idateRental(ren)→(), and setDuration(beg,end)→(). The pa-
rameters id, beg, and end are integers. The parameter pass
is a string. The parameters user, res, and ren, which are
references to the persistent components, are records.
According to AS, Client can make at most two connection
attempts. Elsewhere, the client connections fail. The set C
of components is deﬁned by {Client,Services}. The set of
shared variables VC is deﬁned by {sess,panel}. The variable
sess indicates the status of the client session, and the variable
panel indicates the panel status. We assume that VAC = VAS
= VC, LAC = ∅, and LAS = {satt}. The local variable satt
represents the number of connection attempts accorded to
clients by the component Services. We assume that Dsatt =
N, Dsess = {active,inactive}, and Dpanel = {empty,nonempty}.
The semantics ΨAC(login) and ΨAS(login) of the action
login are given in Table I as an example of the action
semantics. ■
A. Composability
Before deﬁning the composability conditions of two SIAs,
we introduce the notion of action effects, which are essential
to deﬁne the concepts of full and partial control of variables
by a component. Mainly, effects are used later in Section III
to deﬁne the LTS representation of SIAs, but we need to
introduce them at this stage to deﬁne the criteria by which
the composability of two SIAs can be decided.
An effect of an action intervenes its pre and post-
conditions and changes the values of shared and local
variables because they are needed to check the correctness
properties. We deﬁne by ChgAc : ΣAc → 2LVAc the function
that associates for each a ∈ ΣAc, the set of variables
ChgAc(a) ⊆ LVAc modiﬁable by a.
Deﬁnition 2: An effect of an action a is deﬁned by
eAc(a) =
_
k≥1
(grdk ∧ cmdk ∧ Unchgk)
306
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

Table I
THE SEMANTICS OF THE SHARED ACTION login
Client AC
Services AS
PreΨAC (login) ≡ id > 0 ∧ 8 ≤ pass.length() ≤ 10
PreΨAS (login) ≡ id ≥ 1 ∧ 6 ≤ pass.length() ≤ 10
∧ sess = inactive
∧ sess = inactive
PostΨAC (login) ≡ user.getId() = id
PostΨAS (login) ≡ user.getId() = id
Table II
THE EFFECTS OF ACTIONS IN AC AND AS
Action
eAC
eAS
login
sess = inactive ∧ Unchanged(LVAC )
sess = inactive ∧ ((satt ≥ 0 ∧ satt′ = satt − 1∧
sess′ = sess ∧ panel′ = panel) ∨ Unchanged(LVAS }))
notLogged
sess = inactive ∧ Unchanged(LVAC )
sess = inactive ∧ Unchanged(LVAS )
logged
sess = inactive ∧ sess′ = active
sess = inactive ∧ 0 ≤ satt < 2 ∧ sess′ = active
∧Unchanged({panel})
∧Unchanged({satt, panel})
addToPanel
sess = active ∧ ((panel = vide
sess = active ∧ ((panel = vide
∧panel′ = nonvide
∧panel′ = nonvide ∧ satt′ = satt
∧sess′ = sess) ∨ Unchanged(LVAC ))
∧sess′ = sess) ∨ Unchanged(LVAS ))
valdRental
sess = active ∧ Unchanged(LVAC )
sess = active ∧ Unchanged(LVAS )
setDuration
not deﬁned
sess = active ∧ panel = nonvide
∧panel′ = vide ∧ satt′ = satt
∧sess′ = sess
rentNonValid
not deﬁned
sess = active ∧ Unchanged(LVAS )
rentValid
sess = active ∧ Unchanged(LVAC )
sess = active ∧ Unchanged(LVAS )
logout
sess = active ∧ sess′ = inactive
sess = active ∧ sess′ = inactive ∧ satt′ = 2
∧Unchanged(LVAC \ {sess})
Unchanged(LVAS \ {sess, satt})
such that
• the predicate grdk ∈ Preds(LVAc), for k ≥ 1, is a one
of the guards of a ;
• cmdk ∈ Preds′(Vk), where Vk ⊆ ChgAc(a), is a com-
mand predicate deﬁned in terms of primed variables v′
that represents the variables v ∈ Vk after the execution
of a, if grdk is satisﬁed;
• Unchgk
= Unchanged(LVAc \ Vk) is a predicate
deﬁned in terms of variables in LVAc \ Vk that still
unchanged after the execution of a. The predicate
Unchanged(V ), for a set of variables V, is
^
v∈V
v′ = v.
The pre and post-conditions of an action a are not
sufﬁcient to deﬁne the full semantics of an action because
they ignore local variables. The effect eAc(a) of a imposes
guards grdk on the local and shared variables and, for each
guard, deﬁnes a modiﬁcation cmdk on variables LVAc.
Example 2: Consider the previous example, the effects of
actions in AC et AS are deﬁned in Table II. The reader can
easily deduce ChgAC and ChgAS. ■
The fully-controlled variables by Ac are the shared vari-
ables in VAc whereof Ac is conscious of all the environment
actions that can modify them. This requirement states that a
speciﬁcation must include all the actions that can modify its
shared fully-controlled variables. This condition is crucial in
component-based assembly, it ensures that the composite of
two SIAs is consistent with both of them.
The set of partially-controlled variables by Ac are the
shared variables that can be modiﬁed by the environment
actions unknown to Ac. We denote by Σext
A = ΣI
A ∪ ΣO
A the
external actions of A.
Deﬁnition 3: The set V fc
Ac of fully-controlled variables by
Ac is deﬁned by {v ∈ VAc | (∀c′ ∈ C \ {c}, a ∈ ΣAc′ | v ∈
ChgAc′ (a) ⇒ a ∈ Σext
Ac )}. The set of partially-controlled
variables is V pc
Ac = VAc \ V fc
Ac.
Example 3: The variable sess is fully-controlled by AC
and AS. Contrariwise, the variable panel is fully-controlled
by AS and partially-controlled by AC because setDu-
ration
/∈
Σext
AC
and it changes the variable (panel ∈
ChgAS(setDuration)). ■
Given two SIAs Ac1 and Ac2, Shared(Ac1,Ac2) = (ΣI
Ac1 ∩
ΣO
Ac2 )∪(ΣI
Ac2 ∩ΣO
Ac1 ) is the set of shared input and output
actions of Ac1 and Ac2. The external shared actions should
have the same signatures in both Ac1 and Ac2.
Deﬁnition 4: Two semantical interface automata Ac1 and
Ac2 of two components c1 and c2 in C are composable iff
• ΣI
Ac1 ∩ ΣI
Ac2 = ΣO
Ac1 ∩ ΣO
Ac2 = ΣH
Ac1 ∩ ΣAc2 =
ΣAc1 ∩ ΣH
Ac2 = ∅;
• LAc1 ∩ LAc1 = ∅;
• ∀a ∈ Shared(Ac1,Ac2), φ ∈ IVAc1 ∩VAc2 | eAc1 (a) ∧
eAc2 (a) is satisﬁable;
307
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

• for all a ∈ Shared(Ac1,Ac2) whereof the signature is
given by a(i1,...,in) → (o) in Ac1 and by a(i′
1,...,i′
n)
→ (o′) in Ac2 for all n ∈ N
– if a ∈ ΣO
Ac1 , then Dik ⊆ Di′
k for 1≤k≤n
and Do ⊆ Do′;
– if a ∈ ΣI
Ac1 , then Dik ⊇ Di′
k for 1≤k≤n
and Do ⊇ Do′.
The composition of two semantical interface automata
Ac1 and Ac2 may take effect if (i) their actions are disjoint
except shared input, output, hidden ones, (ii) their shared
input and output actions have the same effect on variables in
VAc1 ∩VAc2 (eAc1 (a)∧eAc2 (a) is satisﬁable), (iii) the param-
eter sub-typing [7] property of actions in Shared(Ac1,Ac2)
is satisﬁed, and (iv) their local variables are disjoint.
Example 4: We have Shared(AC,AS) = ΣAC. According
to Deﬁnition 4 and the indications given in the previous
examples, AC and AS are composable. ■
B. Compatibility
The semantical compatibility [8] of external shared ac-
tions and the synchronized product of two composable SIAs
is deﬁned as follows.
Deﬁnition 5: Given an action a ∈ Shared(Ac1,Ac2), if
one of the following conditions is satisﬁed then the action a
in Ac1 is semantically compatible with the action a in Ac2,
denoted by SCompa(Ac1, Ac2) ≡ true (false otherwise):
• if a ∈ ΣO
Ac1 , then (1) PreΨAc1 (a) ⇒ PreΨAc2 (a), and
(2) PostΨAc1 (a) ⇐ PostΨAc2 (a),
• if a ∈ ΣI
Ac1 , then (1) PreΨAc1 (a) ⇐ PreΨAc2 (a), and
(2) PostΨAc1 (a) ⇒ PostΨAc2 (a).
We assume that the name of parameters are the same in
the semantics of actions in Ac1 and Ac2.
The deﬁnition of the synchronized product is deﬁned as
follows.
Deﬁnition 6: Given two components c1, c2 ∈ C whose the
semantical interface automata Ac1 and Ac2 are composable,
their product Ac1 ⊗ Ac2 is deﬁned by
• SAc1⊗Ac2 = SAc1 × SAc2 ; iAc1⊗Ac2 = (iAc1 , iAc2 );
• ΣI
Ac1⊗Ac2 = (ΣI
Ac1 ∪ ΣI
Ac2 ) \ Shared(Ac1, Ac2);
• ΣO
Ac1⊗Ac2 = (ΣO
Ac1 ∪ ΣO
Ac2 ) \ Shared(Ac1, Ac2);
• ΣH
Ac1⊗Ac2 = ΣH
Ac1 ∪ ΣH
Ac2 ∪ {a ∈ Shared(Ac1, Ac2) |
SCompa(Ac1, Ac2) ≡ true};
• LAc1⊗Ac2 = LAc1 ∪ LAc2 ; VAc1⊗Ac2 = VAc1 ∪ VAc2 ;
• ((s1, s2), a, (s′
1, s′
2)) ∈ δAc1⊗Ac2 iff
– a /∈ Shared(Ac1, Ac2)∧(s1, a, s′
1) ∈ δAc1 ∧s2 = s′
2,
– a /∈ Shared(Ac1, Ac2)∧(s2, a, s′
2) ∈ δAc2 ∧s1 = s′
1,
– a
∈ Shared(Ac1, Ac2) ∧ (s1, a, s′
1)
∈
δAc1 ∧
(s2, a, s′
2) ∈ δAc2 ∧ SCompa(Ac1, Ac2) ≡ true;
• ΨAc1⊗Ac1 is deﬁned by:
– ΨAci for a ∈ ΣAci \ Shared(Ac1, Ac2) for i ∈
{1, 2};
– ⟨PreΨAc1 (a), PostΨAc2 (a)⟩ for a
∈ Shared(Ac1,
Ac2)∩ ΣO
Ac1 such that SCompa(Ac1, Ac2) ≡ true;
– ⟨PreΨAc2 (a), PostΨAc1 (a)⟩ for a
∈ Shared(Ac1,
Ac2)∩ ΣI
Ac1 such that SCompa(Ac1, Ac2) ≡ true.
We assume that eAc1⊗Ac1 is deﬁned by eAc1 (a)∧eAc2 (a)
for all a ∈ Shared(Ac1, Ac2), by eAc1 (a) for all a ∈
ΣAc1 \Shared(Ac1, Ac2), and by eAc2 (a) for all a ∈ ΣAc2 \
Shared(Ac1, Ac2).
The incompatibility between Ac1 and Ac2 is due to (i)
the existence of some illegal states (s1,s2) in the set of
transitions δAc1⊗Ac1 where one of the two SIAs Ac1 and
Ac2 outputs a shared action a from s1, which is not accepted
as input from s2 or vice versa, or (ii) from that states they
synchronize on the action a but SCompa(Ac1, Ac2) ≡ false.
Deﬁnition 7: The set of illegal states Illegal(Ac1, Ac2) ⊆
SAc1 × SAc2 is deﬁned by {(s1, s2) ∈ SAc1⊗Ac2 | (∃ a ∈
Shared(Ac1, Ac2) | (C1 ∨ C2 holds))}
C1 =
 
(a ∈ ΣO
Ac1 (s1) ∧ a ̸∈ ΣI
Ac2 (s2)) ∨ (a ∈ ΣO
Ac1 (s1)∧
a ∈ ΣI
Ac2 (s2) ∧ SCompa(Ac1, Ac2) ≡ false)
!
C2 =
 
(a ∈ ΣO
Ac2 (s2) ∧ a ̸∈ ΣI
Ac1 (s1)) ∨ (a ∈ ΣO
Ac2 (s2)∧
a ∈ ΣI
Ac1 (s1) ∧ SCompa(Ac1, Ac2) ≡ false)
!
The reachability of states in Illegal(Ac1, Ac2) do not
implies that Ac1 and Ac2 are not compatible. The existence
of an environment E (a semantical interface automaton)
that produces appropriate inputs for Ac1 ⊗ Ac2 ensures that
illegal states are not reached. The compatible states, denoted
by Comp(Ac1, Ac2), are states in which Ac1 ⊗ Ac2 avoids
reaching illegal states by enabling output or internal actions
(optimistic approach) [4].
Deﬁnition 8: Ac1 and Ac2 are compatible iff the initial
state of Ac1 ⊗ Ac2 is compatible.
The veriﬁcation steps [4] of the compatibility between
Ac1 and Ac2 without considering the semantics of actions
are listed below.
Algorithm
Input : Two SIAs Ac1 and Ac2.
Output : Ac1 ∥ Ac2.
Algorithm steps :
1) compute the product Ac1 ⊗ Ac2,
2) compute Illegal(Ac1, Ac2),
3) compute the set of incompatible states in Ac1 ⊗ Ac2:
the states from which the illegal states are reachable
by enabling only internal and output actions,
4) compute the composition Ac1 ∥ Ac2 by eliminating
from the automaton Ac1 ⊗ Ac2, the illegal state, the
308
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

incompatible states, and the unreachable states from
the initial state,
5) if Ac1 ∥ Ac2 is empty then Ac1 and Ac2 are not
compatible, therefore c1 and c2 can not be assembled
correctly in any environment. Otherwise, Ac1 and Ac2
are compatible.
Our approach increases the complexity1 of the previous
proposed one by taking into account the semantic com-
patibility check of actions in Shared(A1, A2), whereof the
complexity is determined by the logic and the context
theories within the formulas are deﬁned.
Example 5: According to Table I and II and the previous
deﬁnitions and examples, AC and AS are compatible if
SCompa(AC,AS) ≡ true for all a ∈ Shared(AC,AS). ■
Theorem 1: The composition ∥ between SIAs is a com-
mutative and associative operation.
Proof: The proof is based on that presented in [5] by
considering the action semantics.
III. CHECKING INVARIANCE PROPERTIES
In this section, we found formal methodology to design
and check the correctness properties of semantical interface
automata thanks to their rich semantics based on the use
of variables. The correctness properties, as said in the
beginning of the paper, are invariants. Commonly, speciﬁers
have to model a system by a transition system to check
invariants and other types of system temporal properties.
The states of a such transition system are associated to
a set of atomic propositions stated on a set of modiﬁable
variables. Our contribution follows a similar procedure. A
SIA A is translated to a labeled transition system LTS(A)
whose states are the variable valuations. Starting from an
initial valuation, the effects of actions update the variables
and LTS(A) is generated.
A. LTS representation
Before deﬁning the LTS representations of a SIA, we
start by deﬁning some preliminaries. A valuation of a set
of variables V is deﬁned by
φ : V →
[
vi∈V
Dvi
that associates to each vi ∈ V a value in Dvi. We denote
by φ⟨V ′⟩ the restriction of φ to the set V ′ ⊆ V . The set IV
is the set of all possible valuations φ in V. Given an action
a ∈ ΣA, we denote by E(φ, eA(a)) ∈ ILVA the valuation of
variables LVA after the execution of a for a valuation φ of
LVA.
The LTS representation of a SIA A transforms its set of
transitions to a labeled transition system whereof the states
1The complexity of checking the compatibility between two interface
automata A1 and A2 is in time linear on |A1| and |A2| [4].
belong to ILVA and the labels are the actions in ΣA. The LTS
representations of SIAs allows the separation between the
task of checking interoperability and that of the correctness
properties check. It’s clear that a SIA has fewer states than
its LTS representation, which allow to reduce the complexity
of the interoperability checking. The LTS representations are
devoted to check correctness properties.
Deﬁnition 9: The
LTS
representation
LTS(A)
=
⟨SLTS(A),
ILTS(A),
ΣLTS(A),
δLTS(A)⟩
of
a
semantical
interface automata A is a labeled transition system deﬁned
by
• SLTS(A) ⊆ ILVA;
• ILTS(A) = InitA where InitA is the initial valuation of
LVA;
• ΣLTS(A) = ΣA;
• (φ1, a, φ2) ∈ δLTS(A) iff φ1 ∈ ILVA, for s ∈ SA, a ∈
ΣA(s), and φ2 = E(φ1, eA(a)).
{sess7→inactive,
panel7→empty}
{sess7→active,
panel7→empty}
login!
notLogged?
logged!
valdRental!
rentValid?
addToPanel!
{sess7→active,
panel7→n-empty}
addToPanel!
{sess7→inactive,
panel7→n-empty}
login!
notLogged?
logout?
logged!
logout?
Figure 2.
The LTS representation LTS(AC) of AC
Example 6: The LTS representation LTS(AC) of the
semantical interface automaton AC
of the component
Client is shown in Figure 2 where InitAC = {sess 7→
inactive, panel 7→ empty}. ■
Given two SIAs A1 and A2, the following property
establishes that for each state φ ∈ SLTS(A1∥A2), only the
valuations of fully-controlled variables of both A1 and A2
are the same in A1, A2 et A1 ∥ A2. These variables are
modiﬁable exclusively by actions in Shared(A1, A2). We
denote by LV fc
A , the set V fc
A ∪ LA of a SIA A.
Property 1: Given W = LVA1∥A2, V = LV fc
A1 ∩ LV fc
A2,
V ′ = LV fc
A1 ∪ LV fc
A2, V1 = LV fc
A1 \ LV fc
A2, and V2 =
LV fc
A2 \ LV fc
A1 where A1 and A2 are two compatible SIAs
309
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

and InitA1⟨VA1 ∩ VA2⟩ = InitA2⟨VA1 ∩ VA2⟩, for all φ ∈
SLTS(A1∥A2), there exists φ1 ∈ SLTS(A1) and φ2 ∈ SLTS(A2)
such that
1) φ⟨V ⟩ = φ1⟨V ⟩ = φ2⟨V ⟩ knowing that (V = LV fc
A1 ∩
LV fc
A2 = V fc
A1 ∩ V fc
A2);
2) φ⟨V ′⟩ is deﬁned as follows :



φ⟨V ⟩
for all v ∈ V ;
φ1⟨V1⟩
for all v ∈ V1;
φ2⟨V2⟩
for all v ∈ V2.
B. Invariant speciﬁcation
Given an LTS representation LTS(A) of a SIA A, we
denote by ϕ[V ] ∈ Preds(V ), a ﬁrst order formula whose free
variables belong to V ⊆ LVA. A formula ϕ[V ] is satisﬁed at
the state φ ∈ SLTS(A) iff φ satisﬁes ϕ[V ], i.e., the following
condition is satisﬁed:
(
^
v∈LVA
v = φ(v)) ⇒ ϕ[V ].
Deﬁnition 10: Given an LTS representation LTS(A) of a
SIA A and a set V ⊆ LVA, an invariant ϕ[V ] of LTS(A)
(written LTS(A) |= ϕ[V ]) is a ﬁrst order formula such that
for all φ ∈ SLTS(A), φ⟨V ⟩ satisﬁes ϕ[V ] (φ⟨V ⟩ |= ϕ[V ])
and φ satisﬁes ϕ[V ] (φ |= ϕ[V ]).
Example 7: The predicate ϕ[LVAS] = ¬(satt = 2 ∧ sess
= active) is an invariant of LTS(AS) shown in Figure 2. ■
C. Invariant preservation by composition
The following theorem establishes that only invariants
stated on local and fully-controlled variables can be pre-
served by the LTS representations of the composition A1 ∥
A2 of two compatible SIAs A1 and A2 because they are
aware of all the environment actions that can modify these
variables. An invariant stated on partially-controlled vari-
ables of A1 (resp. A2) cannot be preserved by composition
because it is possible that A2 (resp. A1) modiﬁes the values
by actions unknown to A1 (resp. A2) in such way the
invariant is violated. Corollary 2 can easily be deduced from
that theorem.
Theorem 2 (Invariant Preservation by SIA Composition):
Given two LTS(A1) and LTS(A2) respectively of two
compatibles SIAs A1 and A2 and InitA1⟨VA1 ∩ VA2⟩ =
InitA2⟨VA1 ∩ VA2⟩, for all ϕ1[LV fc
A1] and ϕ2[LV fc
A2], if
LTS(A1) |= ϕ1[LV fc
A1] and LTS(A2) |= ϕ2[LV fc
A2], then
LTS(A1 ∥ A2) |= (ϕ1[LV fc
A1] ∧ ϕ2[LV fc
A2]).
Proof: We have the following assumptions:
1) ∀φ1 ∈ SLTS(A1) | φ1⟨LV fc
A1⟩ |= ϕ1[LV fc
A1] and φ1 |=
ϕ1[LV fc
A1];
2) ∀φ2 ∈ SLTS(A2) | φ2⟨LV fc
A2⟩ |= ϕ2[LV fc
A2] and φ2 |=
ϕ2[LV fc
A2];
We have to prove that, for all φ ∈ SLTS(A1∥A2), φ⟨LV fc
A1 ∪
LV fc
A2⟩ |= (ϕ1[LV fc
A1] ∧ ϕ2[LV fc
A2]) and φ |= (ϕ1[LV fc
A1] ∧
ϕ2[LV fc
A2])? According to the property 1(2), we have for
all φ ∈ SLTS(A1∥A2), there exists φ1 ∈ SLTS(A1) and φ2 ∈
SLTS(A2) such that φ⟨LV fc
A1 ∪ LV fc
A2⟩ is equal to



φ⟨LV fc
A1 ∩ LV fc
A2⟩
∀v ∈ LV fc
A1 ∩ LV fc
A2;
φ1⟨LV fc
A1 \ LV fc
A2⟩
∀v ∈ LV fc
A1 \ LV fc
A2;
φ2⟨LV fc
A2 \ LV fc
A1⟩
∀v ∈ LV fc
A2 \ LV fc
A1.
We can deduce, according to the property 1(1), that
φ⟨LV fc
A1 ∪ LV fc
A2⟩ =
 φ1⟨LV fc
A1⟩
for all v ∈ LV fc
A1;
φ2⟨LV fc
A2⟩
for all v ∈ LV fc
A2.
We have φ1⟨LV fc
A1⟩ |= ϕ1[LV fc
A1] (assumption 1) and
φ2⟨LV fc
A2⟩ |= ϕ2[LV fc
A2] (assumption 2), then we can deduce
that φ⟨LV fc
A1 ∪ LV fc
A2⟩ |= ϕ1[LV fc
A1] and φ⟨LV fc
A1 ∪ LV fc
A2⟩ |=
ϕ2[LV fc
A2]. Consequently, φ⟨LV fc
A1 ∪ LV fc
A2⟩ |= (ϕ1[LV fc
A1] ∧
ϕ2[LV fc
A2]) and φ |= (ϕ1[LV fc
A1] ∧ ϕ2[LV fc
A2]).
Corollary 1: Given two LTS(A1) and LTS(A2) of two
compatibles SIAs A1 and A2 such that the assumptions of
Theorem 2 are satisﬁed, for all ϕ[V fc
A1 ∩V fc
A2], if LTS(A1) |=
ϕ[V fc
A1 ∩V fc
A2] and LTS(A2) |= ϕ[V fc
A1 ∩V fc
A2], then LTS(A1 ∥
A2) |= ϕ[V fc
A1 ∩ V fc
A2].
Example 8: The predicate ϕ[LV fc
AS] = ¬(satt = 2 ∧ sess
= active) is an invariant of LTS(AS). We can deduce that
LTS(AC ∥ AS) |= ¬(satt = 2 ∧ sess = active). ■
IV. RELATED WORKS
Luca de Alfaro and al. [9] has proposed “sociable”
interface modules SIMs to specify component interfaces.
The formalism communicates via both actions and shared
variables and the synchronization between actions is based
on two main principles: (i) the ﬁrst principle is that the same
actions can label both input and output transitions, and (ii)
the second is that global variables can be updated by multiple
interfaces. The authors show that the compatibility and the
reﬁnement check of SIMs can be made thanks to efﬁcient
symbolic algorithms implemented in the tool TICC [10]
(Tool for Interface Compatibility).
The main differences between SIMs and our proposed
approach can be identiﬁed in the following points. First, in
SIMs, internal actions are not considered. They concertize
the local behaviors of components and the synchronization
of shared input and output actions. Internal actions are nec-
essary to develop closed systems composed of a preﬁxed set
of components. They can be also useful when a component
instance is associated with a speciﬁc client. For example, the
EJB stateful session beans cannot be composed with many
clients. Shared input and output actions disappear (become
internal) in the composition between a stateful the session
bean instance and its client in such way other clients cannot
be connected to the bean using the same shared actions.
Thus, SIAs can be applied to specify both closed and open
310
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

component-based systems by cons, SIMs are rather relevant
to specify only open systems.
Second, in SIMs, a component could require and offer
the same service (an action can label both input and output
transitions). In our approach, this type of components is not
considered. Furthermore, in our approach, we explicitly de-
ﬁne to what input and output actions correspond (operation
calls, receiving return values, exceptions, etc) which is not
the case in SIMs.
Third, we demonstrate that only invariants stated on
fully-controlled variables (history variables in SIMs) can be
preserved by composition. The authors in [9] do not take
into account this issue. Finally, SIAs uniﬁes the use of oper-
ation parameters and variables to describe the compositional
semantics of components. In addition, we show that we
can separate protocols, used commonly to verify component
compatibility and composition from models used to check
correctness. SIAs (simple states, actions, and semantics)
are used to check the component compatibility and their
LTS representations are used to check correctness properties
preservation by composition.
Ivana ˇCern´a and al. [11] have founded “Component-
interaction automata” (CoIN) to reason about the behavioral
aspects of component-based systems by respecting a given
architecture. They also proposed methods to check com-
ponent assembly correctness by verifying properties, like
consequences of operation calls and fairness without using
variables. These properties are expressed in an extended
version of the linear temporal logic called CI-LTL and
veriﬁed using model-checking techniques [12].
The approach proposed in [13] is a formal methodology
for describing behavioral protocols of interacting, concurrent
components with data states. The authors describes com-
ponent protocols by means of labeled transition systems,
which specify the scheduling of operation calls and the
data states updates by using of pre and post-conditions.
Furthermore, they endow protocols with a model-theoretic
semantics describing the class of all correct implementations
(reﬁnement) of an abstract protocol.
In [14], the authors have proposed an approach endowing
Sun’s Enterprise JavaBeans (EJB) component by behavioral
protocols. The proposed framework provides a set of mech-
anisms allowing the automated extraction of protocols from
EJB components and the veriﬁcation of coherence between
these protocols. Protocols are represented by particular la-
beled transition systems.
V. CONCLUSION AND FUTURE WORKS
In this paper, we propose a formalism based on interface
automata enriched by the use of the action semantics to
describe behavioral protocols of components and to check
their compatibility and safety. In particular, We study the
problem of invariant preservation by composition. In the
future, we intent to adapt the alternating simulation approach
used to reﬁne interface automata to support the treatment
of the action semantics and to ensure the requirement of
invariant preservation also by reﬁnement.
REFERENCES
[1] C. Szyperski, Component Software: Beyond Object-Oriented
Programming.
Boston, USA: Addison-Wesley Longman
Publishing Co., Inc., 2002.
[2] D. Konstantas, Interoperation of object-oriented applications.
Hertfordshire, UK: Prentice Hall International Ltd., 1995, pp.
69–95.
[3] P. Wegner, “Interoperability,” ACM Comput. Surv., vol. 28,
pp. 285–287, March 1996.
[4] L. de Alfaro and T. A. Henzinger, “Interface automata,”
SIGSOFT Softw. Eng. Notes, vol. 26, no. 5, pp. 109–120,
2001.
[5] L. d. Alfaro and T. A. Henzinger, “Interface-based de-
sign,” in Engineering Theories of Software-intensive Systems.
Springer, 2005, pp. 83–104.
[6] N. A. Lynch and M. R. Tuttle, “Hierarchical correctness
proofs for distributed algorithms,” in PODC ’87: Proc. of
the 6th ACM Symp. on principles of distributed computing.
New York, USA: ACM, 1987, pp. 137–151.
[7] B. H. Liskov and J. M. Wing, “A behavioral notion of
subtyping,” ACM Trans. Program. Lang. Syst., vol. 16, pp.
1811–1841, November 1994.
[8] S. Heiler, “Semantic interoperability,” ACM Comput. Surv.,
vol. 27, pp. 271–273, June 1995.
[9] L. d. Alfaro, L. D. d. Silva, M. Faella, A. Legay, P. Roy, and
M. Sorea, “Sociable interfaces,” in The Proc. 5th Int. WS.
on Frontiers of Combining Systems, LNAI 3717.
Springer-
Verlag, 2005, pp. 81–105.
[10] L. d. Alfaro, L. D. d. Silva, M. Faella, A. Legay, V. Raman,
and P. Roy, “Ticc: A tool for interface compatibility and
composition,” in The Proc. 18th Int. Conf. on Computer Aided
Veriﬁcation (CAV), volume 4144 of LNCS.
Springer, 2006,
pp. 59–62”.
[11] B. Zimmerova, P. Vaˇrekov´a, N. Beneˇs, I. ˇCern´a, L. Brim,
and J. Sochor, “The common component modeling example.”
Berlin, Heidelberg: Springer-Verlag, 2008, ch. Component-
Interaction Automata Approach (CoIn), pp. 146–176.
[12] J. Barnat, L. Brim, I. ˇCern´a, P. Moravec, P. Roˇckai, and
P. ˇSimeˇcek, “Divine - a tool for distributed veriﬁcation,” in
Computer Aided Veriﬁcation, ser. LNCS.
Springer Berlin /
Heidelberg, 2006, vol. 4144, pp. 278–281.
[13] S. S. Bauer, R. Hennicker, and S. Janisch, “Behaviour pro-
tocols for interacting stateful components,” Electron. Notes
Theor. Comput. Sci., vol. 263, pp. 47–66, June 2010.
[14] A. Far´ıas and M. S¨udholt, “On components with explicit
protocols satisfying a notion of correctness by construction,”
in Confederated Int. Conf. DOA, CoopIS and ODBASE 2002.
London, UK: Springer-Verlag, 2002, pp. 995–1012.
311
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

