Protecting Eavesdropping over Multipath TCP Communication 
Based on Not-Every-Not-Any Protection
Toshihiko Kato1)2), Shihan Cheng1)2), Ryo Yamamoto1), Satoshi Ohzahata1) and Nobuo Suzuki2) 
1) University of Electro-Communications,  Tokyo, Japan 
2) Advanced Telecommunication Research Institute International,  Kyoto, Japan 
e-mail: kato@is.uec.ac.jp, chengshihan@net.is.uec.ac.jp, ryo_yamamotog@is.uec.ac.jp,  
ohzahata@is.uec.ac.jp, nu-suzuki@atr.jp 
 
Abstract—Recent mobile terminals have multiple interfaces, 
such as 4G and wireless local area network (WLAN).  In order 
to use those interfaces at the same time, multipath transmission 
control protocol (MPTCP) is introduced in several operating 
systems.  However, it is possible that some interfaces are 
connected to untrusted networks and that data transferred over 
them is observed in an unauthorized way.  In order to avoid this 
situation, we propose a new method to improve privacy against 
eavesdropping using the data dispersion by exploiting multipath 
nature of MPTCP.  One feature of the proposed method is to 
realize that an attacker cannot observe data on any path, even 
if he observes traffic over only a part of paths.  Another feature 
is to use data scrambling instead of ciphering.  The results of 
performance evaluation show that the processing overhead of 
the proposed method is much smaller than cipher based 
methods.    
Keywords- Multipath TCP; Eavesdropping; Data Dispersion; 
Data Scrambling.   
I. INTRODUCTION 
Recently, mobile terminals with multiple interfaces have 
come to be widely used.  For example, most smart phones are 
installed with interfaces for 4G Long Term Evolution (LTE) 
and WLAN.  In the next generation (5G) network, it is studied 
that multiple communication paths provided multiple network 
operators are commonly involved [1].  In this case, mobile 
terminals will have more than two interfaces at the same time.   
In order for applications to use multiple interfaces 
effectively, MPTCP [2] is being introduced in several 
operating systems, such as Linux, Apple OS/iOS [3] and 
Android [4].  MPTCP is an extension of TCP.  Conventional 
TCP applications can use MPTCP as if they were working 
over traditional TCP and are provided multiple byte streams 
through different interfaces.   
MPTCP is defined in three request for comments (RFC) 
documents by the Internet Engineering Task Force.  RFC 
6182 [5] outlines architecture guidelines for developing 
MPTCP protocols, by discussing the high level design 
decisions on selecting the protocol functions from multiple 
candidates.  RFC 6824 [6] presents the details of extensions to 
the traditional TCP to support multipath operation.  It defines 
the MPTCP control information realized as new TCP options, 
and the MPTCP protocol procedures for the initiation and 
association of subflows (TCP connections related with an 
MPTCP connection), the data transfer and acknowledgment 
over multiple subflows, and the closing MPTCP connection.  
RFC 6356 [7] presents a congestion control algorithm that 
couples the congestion control algorithms running on different 
subflows.   
When a mobile terminal uses multiple interfaces, i.e., 
multiple paths, some of them may be unsafe such that an 
attacker is able to observe data over them in an unauthorized 
way.  For example, a WLAN interface is connected to a public 
WLAN access point, data transferred over this WLAN may be 
disposed to other nodes connected to it.  In order to prevent 
this eavesdropping, the transport layer security (TLS) is used 
to provide communication security.  Although TLS can be 
applied various applications including web access, e-mail and 
ftp, however, it is widely used only with HTTP, and some 
applications like VoIP cannot use TLS.  In this paper, we 
propose a new method to improve privacy against 
eavesdropping by exploiting multipath nature of MPTCP.  
Even if an unsafe WLAN path is used, another path may be 
safe, such as LTE supported by a trusted network operator.  So, 
we propose a method such that if an attacker cannot observe 
the data on every path, he cannot observe the traffic on any 
path [8].  We call this scheme a not-every-not-any protection.  
Although there are several proposals on multipath data 
dispersion to protect eavesdropping, all of them adopt just a 
simple method dispatching data packets among multiple paths 
with or without encryption.  The feature of the proposed 
method is to adopt the not-every-not-any protection, and to 
use the data scrambling instead of ciphering.   
The rest of this paper is organized as follows.  Section II 
explains the overview [9] and the security issues of MPTCP.  
Section III describes the design of the proposed method 
protecting against eavesdropping.  Section IV gives the 
performance evaluation on the processing overhead of the 
proposal method and other ciphering methods.  In the end, 
Section V concludes this paper.   
II. 
OVERVIEW AND SECURITY ISSUES OF MPTCP 
A. MPTCP connections and subflows 
As described in Figure 1, the MPTCP module is located 
on top of TCP.  As described above, MPTCP is designed so 
that the conventional applications do not need to care about 
the existence of MPTCP.  MPTCP establishes an MPTCP 
connection associated with two or more regular TCP 
connections called subflows.  The management and data 
transfer over an MPTCP connection is done by newly 
introduced TCP options for MPTCP operation.   
Figure 2 shows an example of MPTCP connection 
establishment where host A with two network interfaces 
invokes this sequence for host B with one network interface.  
87
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-582-1
SECURWARE 2017 : The Eleventh International Conference on Emerging Security Information, Systems and Technologies

In the beginning, host A sends a SYN segment to host B with 
a Multipath Capable (MP_CAPABLE) TCP option.  This 
option indicates that the initiator supports the MPTCP 
functions and requests to use them in this TCP connection.  It 
contains host A’s Key (64 bits) used by this MPTCP 
connection.  Then, host B replies a SYN+ACK segment with 
MP_CAPABLE option with host B’s Key.  This reply means 
that host B accepts the use of MPTCP functions.  In the end, 
host A sends an ACK segment with MP_CAPABLE option 
including both A’s and B’s Keys.  Through this three-way 
handshake procedure, the first subflow and the MPTCP 
connection are established.  Here, it should be mentioned that 
these “Keys” are not keys in a cryptographic sense.  As 
described below, they are used for generating the Hash-based 
Message Authentication Code (HMAC), but MPTCP does not 
provide any mechanisms to protect them from attackers’ 
accessing while transfer.   
Next, host A tries to establish the second subflow through 
another network interface.  In the first SYN segment in this 
try, another TCP option called a Join Connection (MP_JOIN) 
option is used.  An MP_JOIN option contains the receiver’s 
Token (32 bits) and the sender’s Nonce (random number, 32 
bit).  A Token is an information to identify the MPTCP 
connection to be joined.  It is obtained by taking the most 
significant 32 bits from the SHA-1 hash value for the 
receiver’s Key (host B’s Key in this example).  Then, host B 
replies a SYN+ACK segment with MP_JOIN option.  In this 
case, MP_JOIN option contains the random number of host B 
and the most significant 64 bits of the HMAC value.  An 
HMAC value is calculated for the nonces generated by hosts 
A and B using the Keys of A and B.  In the third ACK segment, 
host A sends an MP_JOIN option containing host A’s full 
HMAC value (160 bits).  In the end, host B acknowledges the 
third ACK segment.  Using these sequence, the newly 
established subflow is associated with the MPTCP connection.   
B. Data transfer 
An MPTCP implementation will take one input data 
stream from an application, and split it into one or more 
subflows, with sufficient control information to allow it to be 
reassembled and delivered to the receiver side application 
reliably and in order.  The MPTCP connection maintains the 
data sequence number independent of the subflow level 
sequence numbers.  The data and ACK segments may contain 
a Data Sequence Signal (DSS) option depicted in Figure 3.    
The data sequence number and data ACK is 4 or 8 byte 
long, depending on the flags in the option.  The number is 
assigned on a byte-by-byte basis similarly with the TCP 
sequence number.  The value of data sequence number is the 
number assigned to the first byte conveyed in that TCP 
segment.  The data sequence number, subflow sequence 
number (relative value) and data-level length define the 
mapping between the MPTCP connection level and the 
subflow level.  The data ACK is analogous to the behavior of 
the standard TCP cumulative ACK.  It specifies the next data 
sequence number a receiver expects to receive.   
C. Security issues on MPTCP and related work 
Some new security issues emerge by the introduction of 
MPTCP [8].  One is a new threat that an attacker splits 
malicious data over multiple paths.  Traditional signature-
based intrusion detection systems (IDSs) suppose that they 
can monitor all packets of a given flow.  If a target system uses 
MPTCP and an attacker sends signatures over different 
subflows, IDSs cannot detect them.  Ma, et al. [10] proposed 
a new approach for this problem, where each IDS locally 
scans and processes its monitored traffic, and all IDSs share 
asynchronously a global state of string matching automaton.   
Another issue is related to MPTCP and privacy.  MPTCP 
has a potential to provide improved privacy against attackers 
who are able to observe or interfere with subflow traffic along 
a subset of paths.  Dispersing traffic over multiple paths makes 
it less likely that attackers will get access to all of the data.  
Pearce and Zeadally [8] suggested the concept of the not-
every-not-any protection and introduced some ideas including 
sending cryptographic signing details using multiple paths and 
applying cryptographic chaining, such as cipher block 
chaining (CBC), across multiple paths.   
There have been several proposals on the data dispersion 
over multiple paths.  Yang and Papavassiliou [11] provided a 
method to analyze the security performance when a virtual 
connection takes multiple disjoint paths to the destination, and 
a traffic dispersion scheme to minimize the information 
leakage when some of the intermediate routers are attacked.  
Nacher, et al. [12] tried to determine the optimal trade-off 
between traffic dispersion and TCP performance over mobile 
ad-hoc networks to reduce the chances of successful 
eavesdropping while maintaining acceptable throughput.  
 
Figure 1.  Layer structure of MPTCP. 
Host A
Address A1
Address A2
Host B
Address B
 SYN (MP_CAPABLE [Key-A]) 
 SYN+ACK (MP_CAPABLE [Key-B]) 
 ACK (MP_CAPABLE [Key-A, Key-B]) 
 SYN (MP_JOIN 
[Token-B, Nonce-A]) 
 SYN+ACK (MP_JOIN 
[HMAC-B, Nonce-B]) 
 ACK (MP_JOIN [HMAC-A]) 
 ACK 
 
Figure 2.  Example of MPTCP connection establishment. 
 
Application
MPTCP
Subflow (TCP)
Subflow (TCP)
IP
IP
Kind (= 30)
Length
Subtype
(= 2)
Flags
Data ACK (4 or 8 octets, depending on flags)
Data sequence number (4 or 8 octets, depending on flags)
Subflow sequence number (4 octets)
Data-level length (2 octets)
Checksum (2 octets)
 
Figure 3.  Data Sequence Signal option. 
88
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-582-1
SECURWARE 2017 : The Eleventh International Conference on Emerging Security Information, Systems and Technologies

These two studies use multiple TCP connections by their own 
coordination methods instead of MPTCP.  Gurtov and 
Polishchuk [13] used host identity protocol (HIP), which 
locates between IP and TCP to provide multiple paths, and 
propose how to spread traffic over them.  Apiecionek, et al. 
[14] proposed a way to use MPTCP for more secure data 
transfer.  After data are encrypted, they are divided into blocks, 
mixed in the predetermined random sequence, and then 
transferred through multiple MPTCP subflows.  A receiver 
rearranges received blocks in right order and decrypts them.   
All of those proposals aim at just spreading data packets 
over multiple paths, and do not consider the coordination over 
multiple paths.  If the transferred data are encrypted before 
dispersion, it can be said that they are coordinated by the 
encryption procedure, but the coordination is not realized by 
the dispersion schemes.   In contrast with them, our proposal 
adopts an approach to improve privacy by coordinating data 
over multiple paths through data scrambling not encryption.   
III. PROPOSAL 
A. Requrements and possible approaches 
The followings are the requirements for designing a not-
any-not-every protection method protecting eavesdropping.   
 
The method needs to cope with two way data exchanges 
within one MPTCP connection.   
 
The length of exchanged data should not be expanded.   
 
Even if there are any bytes with known values, such as 
fixed bytes in an application protocol header, the method 
provides protection from information leakage.   
 
The method does not introduce any new overheads into 
MPTCP as much as possible.   
 
The method does not change the behaviors of MPTCP as 
much as possible.   
In designing the proposed method, we have considered the 
following possible candidates.   
(1) Secret sharing method 
The secret sharing method is to divide data D into n pieces 
in such a way that D is easily reconstructed from any k pieces, 
but even complete knowledge of k -1 pieces reveals absolutely 
no information about D [15].  Shamir [15] gave an example 
method based on polynomial interpolation.  It is possible to 
apply the idea of secret sharing to data transfer.  Zhao et al. 
[16] proposed an efficient anonymous message submission 
protocol based on secret sharing and a symmetric key 
cryptosystem.  It aggregates messages of multiple members 
into a message vector such that a member knows only his own 
position in the submission sequence.   
Figure 4 shows an idea of applying secret sharing to the 
eavesdropping protection.  It supposes the case that n = 2 and 
k = 2.  Pieces D1 and D2 are generated from an original data 
and transferred through different paths.  An attacker can 
access only D2 over an untrusted path, and so he cannot obtain 
the original data.  In this approach, however, the amount of 
transferred data is increased, twice in this example.   
(2) Network coding 
The second candidate is the network coding [17].  In this 
framework, the exclusive OR (XOR) is calculated among 
multiple packets and the result is transferred instead of packets 
themselves.  Ahlswede, et al. [17] mentioned that by 
employing coding at network nodes, which they referred to as 
network coding, it is possible to save bandwidth in general.  
Li, et al. [18] proposed a network coding based multipath TCP 
(NC-MPTCP), which uses the mix of regular subflows, 
delivering original data, and network coding subflows, which 
deliver linear combinations of original data.  NC-MPTCP 
achieves higher goodput compared to MPTCP in the presence 
of different subflow qualities.   
Figure 5 shows an idea of applying network coding to the 
eavesdropping protection.  Using data A and B, their XOR 
(A ⊕ B) is calculated.  Through a trusted path, an original data 
A is transferred, and through an untrusted path, A ⊕ B is 
transferred.  Since an attacker observes only A ⊕ B, he cannot 
obtain data B without knowledge of data A.  This idea can be 
said a packet level data scrambling.  Although it can provide 
the not-every-not-any protection, it introduces an additional 
overhead due to the variable length packets, and an additional 
control in MPTCP, such as sending XOR data only over an 
untrusted path.   
(3) Mode of operation in block ciphering 
The third candidate is the mode of operation, such as CBC 
and output feedback (OFB), used in block ciphering [19].  The 
block cipher defines only how to encrypt or decrypt a fixed 
length bits (block).  A mode of operation defines how to apply 
this operation to data longer than a block.  CBR and OFB 
introduce a chaining between blocks such that a block is 
combined with the preceding block by XOR calculation.   
Figure 6 shows an idea of applying mode of operation to 
the eavesdropping protection.  Data to be sent (data 1 and 2) 
are divided into blocks (A through D).  The first block is 
XORed with the initialization vector (IV), and the following 
 
Figure 4.  Secret sharing based approach. 
data A
A   B
receiver
A
A   B
trusted
untrusted
sender
data B
 
Figure 5.  Network coding based approach. 
A
receiver
trusted
untrusted
sender
IV
data 1
B
C
data 2
D
IV A A B
IV A A B
B C C D
B C C D
 
Figure 6.  Block ciphering based approach.   
data
D1
D2
receiver
D1
D2
trusted
untrusted
sender
89
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-582-1
SECURWARE 2017 : The Eleventh International Conference on Emerging Security Information, Systems and Technologies

blocks are XORed with their preceding blocks.  The XORed  
results are transferred via different paths.  In the example, an 
attacker can only observe B ⊕ C and C ⊕ D, and does not 
know block B, which is transferred through a trusted path.  So, 
he cannot obtain C and D any more.  This idea can be said a 
block level data scrambling.  Although it can provide the not-
every-not-any protection, it introduces an additional data 
overhead because the length of packets is not integral multiple 
of block length in general.  
According to those considerations, we select a byte stream 
based data scrambling approach described below.   
B. Detailed design of proposed method 
As shown in Figure 7, we introduce a data scrambling 
function within MPTCP and on top of the original MPTCP.  
When an MPTCP communication is started, the use of data 
scrambling is negotiated.  It may be done using a flag bit in 
MP_CAPABLE TCP option.   
Figure 8 shows an overview of data scrambling.  In the 
data sending side, an application sends data to MPTCP.  It is 
stored in the send socket buffer, and the data scrambling 
module scrambles it in a byte-by-byte basis.  The result is 
stored in the send socket buffer again.  The data in this buffer 
is transferred reliably by MPTCP.  While sending data, 
MPTCP tries to send the first packet over an MPTCP 
connection via a subflow that uses a trusted path.  After that, 
the data transfer by MPTCP is performed according to its 
native scheduler.  We suppose that the distinction of trusted or 
untrusted path can be done by the IP address of interfaces.  In 
the data receiving side, data is transferred through MPTCP 
without any losses, transmission errors, nor duplications.  The 
received in-sequence data is stored in the receive socket buffer.  
After that, the data descrambling module is invoked to restore 
the scrambled data to the original one.   
Figure 9 shows the details of data scrambling.  As 
described above, the scrambling is performed in a byte-by-
byte basis.  More specifically, one byte being sent is XORed 
with its preceding 64 bytes.  In order to realize this scrambling, 
the data scrambling module maintains the send scrambling 
buffer, whose length is 64 bytes.  It is a shift buffer and its 
initial value is HMAC of the key of this side.  Since the length 
of HMAC is 20 bytes, the higher bytes in the send scrambling 
buffer is filled by zero.  When a data comes from an 
application, each byte (bi in the figure) is XORed with the 
result of XOR of all the bytes in the send scrambling buffer.  
The obtained byte (Bi) is the corresponding sending byte.  
After calculating the sending byte, the original byte (bi) is 
added to the send scramble buffer, forcing out the oldest 
(highest) byte from the buffer.  The send scrambling buffer 
holds recent 64 original bytes given from an application.  By 
using 64 byte buffer, the access to the original data is protected 
even if there are well-known byte patterns (up to 63 bytes) in 
application protocol data.   
Figure 10 shows the details of data descrambling, which is 
similar with data scrambling.  The data scrambling module 
also maintains the receive scramble buffer whose length is 64 
bytes.  Its initial value is HMAC of the key of the remote side.  
When an in-sequence data is stored in the receive socket 
buffer, a byte (Bi that is scrambled) is applied to XOR 
calculation with the XOR result of all bytes in the receive 
scramble buffer.  The result is the descrambled byte (bi), 
which is added to the receive scramble buffer.   
original MPTCP
Subflow (TCP)
Subflow (TCP)
Data Scrambling
M
P
T
C
P
 
Figure 7.  Layer structure of MPTCP with data scrambling. 
Send socket 
buffer
Data Scrambling
original MPTCP
trusted path
untrusted 
path
  
Receive socket 
buffer
Data 
Descrambling
original MPTCP
trusted path
untrusted 
path
 
 
(a) Sending data 
(b) Receiving data 
Figure 8.  Overview of data scrambling processing. 
sending data
XOR
　　　　・・・
send scramble buffer
scrambled sending data
XOR
・・・
・・・
・・・
・・・
　　　　・・・
・・・
・・・
sending data
send scramble buffer
(a) Scrambling
(b) Adding sending byte to scramble buffer
bi
bi
Bi
bi
 
Figure 9.  Processing of data scrambling.   
scrambled received data
XOR
　　　　・・・
receive scramble buffer
received data
XOR
・・・
・・・
・・・
・・・
　　　　・・・
・・・
・・・
received data
receive scramble buffer
(a) Descrambling
(b) Adding received byte to scramble buffer
bi
Bi
bi
bi
 
Figure 10.  Processing of data descrambling. 
90
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-582-1
SECURWARE 2017 : The Eleventh International Conference on Emerging Security Information, Systems and Technologies

By using the byte-wise scrambling and descrambling, the 
proposed method does not increase the length of exchanged 
data at all.  The separate send and receive control enables two 
way data exchanges to be handled independently.  Moreover 
the proposed method introduces only a few modification to 
the original MPTCP.   
IV. PERFORMANCE EVALUATION 
In this section, we evaluate the processing overhead of the 
proposed method.  In addition, we evaluate the overhead of 
commonly used cryptographic methods for the purpose of 
comparison.  We adopt the data encryption standard (DES) 
[20], the triple data encryption algorithm (TDEA) [20], and 
the advanced encryption standard (AES) [21].   
DES is a block based ciphering algorithm standardized by 
the National Institute of Standards and Technology (NIST).  It 
is designed to encipher and decipher of blocks of data 
consisting of 64 bits (8 bytes) under control of a 64 bit (8 byte) 
key.  Currently, it has been withdrawn as a standard ciphering 
method, but the TDEA, a compound operation of DES 
encryption and decryption operations, can be used as one of 
cipher suites in TLS.   
AES is another block based ciphering algorithm newly 
standardized by NIST in 2001.  It is a symmetric block cipher 
that can process data blocks of 128 bits (16 bytes), using 
cipher keys with lengths of 128, 192, and 256 bits (16 bytes, 
24 bytes, and 32 bytes, respectively).   
In this paper, we used publicly available source programs 
for DES and AES [22] distributed by PJC, a Japanese software 
company.  They are written in C language.  As for the DES 
algorithm, we prepared 160 blocks (8 × 160 = 1280 bytes) 
and performed encryption and decryption for those blocks 
with the electronic codebook (ECB) mode.   That is, each 
block is just encrypted and decrypted independently from 
other blocks.  As for the TDEA algorithm, each of 160 blocks 
is encrypted or decrypted three times according to the DES 
algorithm with independent three keys.  As for the AES 
algorithm, we prepared 80 blocks (16 × 80 = 1280 bytes) and 
used keys with 128, 192 and 256 bit length (AES-128, AES-
192 and AES-256).  We also used the ECB mode here.  It 
should be mentioned that we suppose 1280 byte long message 
to be transferred.   
As for the proposed method, we introduced two kinds of 
implementations.  One is a straightforward implementation, 
where the proposed method described in the previous section 
is programmed in C language as they are.  The followings are 
the summary of the straightforward implementation.   
 
The send/receive scramble buffers are realized by an 
array of unsigned char type.   
 
When a byte is scrambled or descrambled, the exclusive 
OR of all bytes in the scramble buffer is calculated.   
 
When a byte is scrambled or descrambled, it is added to 
the scramble buffer by shifting all bytes in the buffer.   
The other is a revised implementation, where unnecessary 
data copying nor exclusive OR calculation are avoided.  The 
followings are the summary of the revised implementation.   
 
The send/receive scramble buffers are realized by an 
array of unsigned char type.  In order to avoid 
unnecessary data copying, the oldest element in the array 
is maintained by an index parameter.   
 
The exclusive OR calculation for all bytes in the 
scramble buffer is performed just once in the beginning.  
This result is maintained by a static variable sXor or rXor.     
 
When a byte is to be scrambled or descrambled, the static 
variable (sXor or rXor) is overwritten by the exclusive 
OR of the oldest element in the scramble buffer, sXor (or 
rXor) and the new byte.   
 
When a byte is to be scrambled or descrambled, it is 
added to the scramble buffer just by moving the index 
parameter.   
By use of these two implementation, we executed the data 
scrambling and descrambling for a message with length of 
1280 bytes.   
We evaluated the performance of those seven methods 
(DES, TDEA, AES-128, AES-192, AES-256, the proposed 
method by straightforward implementation, and the proposed 
method by revised implementation).  Table I shows the 
specification of personal computer used for the evaluation.  It 
is a laptop computer manufactured by Lenovo over which the 
Linux operating system is installed.  We measured the 
processing time of the encryption and decryption, or the 
scrambling and descrambling for a message with 1280 byte 
length.  We used Linux time command for 10,000 iterations, 
and calculated the processing time for one operation.   
Table II gives the performance results.  The encryption 
and decryption of the DES and AES-128 algorithms require 
around 2.2 or 2.3 msec.  The AES-192 and AES-256 
algorithms requires a little more time.  The TDEA algorithm 
requires around 6.7 msec, which is about three time of the 
DES algorithm.  On the other hand, the straightforward 
implementation of the proposed method requires around 1 
msec.  This is smaller than the cryptographic approaches, but 
the improvement is not large.  However, the revised 
implementation of the proposed method decreases the 
processing time largely, to around 0.04 msec.  It is less than 
1/60 compared with the DES and AES algorithms.  Although 
the implementation of DES and AES algorithms is a publicly 
accessible software, which may be optimized adequately, the 
obtained results are considered to show that the proposed 
method is able to decrease the processing overhead of 
TABLE I.  SPECIFICATION OF PC USED IN EVALUATION.   
model
CPU
clock
memory size
kernel
lenovo ThinkPad E430
Intel Core i5-3230M CPU×4
2.60GHz
3.7 Gbytes
ubuntu 16.04 LTS
 
TABLE II.  PROCESSING TIME OF 1280 BYTE MESSAGE.   
DES
TDEA
AES-
128
Proposed 
(straight)
Proposed 
(revised)
2.24 
msec
6.69 
msec
2.29 
msec
0.950 
msec
0.0352 
msec
AES-
192
2.80 
msec
AES-
256
3.40 
msec
 
91
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-582-1
SECURWARE 2017 : The Eleventh International Conference on Emerging Security Information, Systems and Technologies

ciphering operations and to provide some level of security 
against the eavesdropping over untrusted paths in MPTCP 
communications.   
V. DISCUSSIONS AND CONCLUSIONS 
This paper proposes a new method to improve privacy 
against eavesdropping over MPTCP communications, which 
has become popular among recent mobile terminals.  Recent 
mobile terminals have multiple communication interfaces, 
some of which are connected to trusted network operators (e.g. 
LTE interfaces), and some of which may be connected to 
untrusted network, such as public WLAN hot spots.  The 
proposed method here is based on the not-every-not-any 
protection principle, where, if an attacker cannot observe the 
data on every path, he cannot observe the traffic on any path.  
We designed detailed procedure by following the byte 
oriented data scrambling in order to avoid unnecessary data 
length expansion.   
We need to discuss here about the security scheme of the 
proposed method.  The proposed method does not use the data 
ciphering, and so it does not protect eavesdropping in a strict 
sense.  It depends on the difficulty of unauthorized data access 
over trusted network operators.  That is, the intruder model is 
that an attacker can access to only untrusted networks, such as 
public WLAN access points.  We also need to point out that 
the proposed method gives a small modification to MPTCP.  
It uses the HMAC value of sender side Key as an initial value 
of XORing, which means that no additional vulnerabilities are 
introduced for the initialization vector setting.  Besides, as for 
the dependency between multiple paths that a byte cannot 
obtained only after the precedence bytes are received, it is 
intrinsic to MPTCP and is not a defect of the proposed method 
itself.   
We evaluated the processing overhead of the DES, TDEA 
and AES encryption/decryption and that of data scrambling in 
the proposed method.  The result showed that the optimized 
implementation of our method requires only less than 1/60 
processing time compared with the cryptographic approaches.  
Although the proposed method is a practical solution, as 
described above, the processing capability of mobile terminals 
is still low, and so our proposal is considered to be useful to 
increase the security against eavesdropping over untrusted 
mobile communication networks.   
We are currently implementing the proposed method on 
top of MPTCP software in the Linux operating system.  We 
will continue this implementation and conduct the 
performance evaluation over real networks.   Moreover, the 
proposed method can only prevent eavesdropping, and cannot 
ensure the integrity of transferred data.  We need to improve 
our method in this aspect.   
ACKNOWLEDGMENT 
This research was performed under the research contract 
of “Research and Development on control schemes for 
utilizations of multiple mobile communication networks,” for 
the Ministry of Internal Affairs and Communications, Japan.   
REFERENCES 
[1] NGNM Alliance, “5G White Paper,” https://www.ngmn.org/uploads/ 
media/NGMN_5G_Paper_V1_0.pdf, Feb. 2015, [retrieved: May 2017].   
[2] C. Paasch and O. Bonaventure, “Multipath TCP,” Communications of 
the ACM, vol. 57, no. 4, pp. 51-57, Apr. 2014.   
[3] AppleInsider Staff, “apple found to be using advanced Multipath TCP 
networking in iOS 7,” http://appleinsider.com/articles/13/09/20/apple-
found-to-be-using-advanced-multipath-tcp-networking-in-ios-7, 
[retrieved: May 2017].   
[4] icteam, “MultiPath TCP – Linux Kernel implementation, Users:: 
Android,” 
https://multipath-tcp.org/pmwiki.php/Users/Android, 
[retrieved: May 2017].   
[5] A. Ford, C.Raiciu, M. Handley, S. Barre, and J. Iyengar, “Architectural 
Guidelines for Multipath TCP Development,” IETF RFC 6182, Mar. 
2011.   
[6] A. Ford, C. Raiciu, M. Handley, and O. Bonaventure, “TCP Extensions 
for Multipath Operation with Multiple Addresses,” IETF RFC 6824, 
Jan. 2013.   
[7] C. Raiciu, M. Handley, and D. Wischik, “Coupled Congestion Control 
for Multipath Transport Protocols,” IETF RFC 6356, Oct. 2011.   
[8] C. Pearce and S. Zeadally, “Ancillary Impacts of Multipath TCP on 
Current and Future Network Security,” IEEE Internet Computing, vol. 
19, iss. 5, pp. 58-65, Sept.-Oct. 2015.   
[9] T. Kato, M. Tenjin, R. Yamamoto, S. Ohzahata, and H. Shinbo, 
“Microscopic Approach for Experimental Analysis of Multipath TCP 
Throughput under Insufficient Send/Receive Socket Buffers,” in Proc. 
15th ICWI 2016, pp. 191-199, Oct. 2016.   
[10] J. Ma, F. Le, A. Russo, and J. Lobo, “Detecting Distributed Signature-
based Intrusion: The Case of Multi-Path Routing Attacks,” in Proc. 
2015 INFOCOM, pp. 558-566, Apr. 2015.   
[11] J. Yang and S. Papavassiliou, “Improving Network Security by 
Multipath Traffic Dispersion,” in Proc. MILCOM 2001, pp. 34-38, Oct. 
2001.   
[12] M. Nacher, C. Calafate, J. Cano, and P. Manzoni, “Evaluation of the 
Impact of Multipath Data Dispersion for Anonymous TCP 
Connections,” In Proc. SecureWare 2007, pp. 24-29, Oct. 2007. 
[13] A. Gurtov and T. Polishchuk, “Secure Multipath Transport For Legacy 
Internet Applications,” In Proc. BROADNETS 2009, pp. 1-8, Sep. 
2009.   
[14] L. Apiecionek, W. Makowski, M. Sobczak, and T. Vince, “Multi Path 
Transmission Control Protocols as a security solution,” in Proc. 2015 
IEEE 13th International Scientific Conference on Informatics, pp. 27-
31, Nov. 2015.   
[15] A. Shamir, “How to share a secret,” Communications of the ACM, vol. 
22, no. 11, pp.612-613, Nov. 1979.   
[16] X. Zhao, L. Li, G. Xue, and G. Silva, “Efficient Anonymous Message 
Submission,” in Proc. INFOCOM 2012, pp.2228-2236, Mar. 2012.   
[17] R. Ahlswede, N. Cai, S. Li, and R. Yeung, “Network Information Flow,” 
IEEE Trans. Information Theory, vol. 46, no. 4, pp.1204-1216, Jul. 
2000.   
[18] M. Li, A. Lukyanenko, and Y. Cui, “Network Coding Based Multipath 
TCP,” in Proc. Global Internet Symposium 2012, pp.25-30, Mar. 2012.   
[19] ISO JTC 1/SC27, “ISO/IEC 10116: 2006 – Information technology – 
Security techniques – Modes of operation for an n-bit cipher,” ISO 
Standards, 2006.   
[20] Federal 
Information 
Processing 
Standards 
Publication 
46-3, 
“Annoucing the Data Encryption Standard,” Oct. 1999.   
[21] Federal 
Information 
Processing 
Standards 
Publication 
197, 
“Anouncing the Advanced Encryption Standard (AES),” Nov. 2001.   
[22] PJC, “Distribution of Sample Program / Source / Software (in 
Japanese),” http://free.pjc.co.jp/index.html, [retrieved: May 2017].   
 
92
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-582-1
SECURWARE 2017 : The Eleventh International Conference on Emerging Security Information, Systems and Technologies

