Static and Dynamic Analysis
for Robustness under Slowdown
Ingram Bondin
Department of Computer Science
University of Malta
Msida, Malta
email: ingrambondin@gmail.com
Gordon J. Pace
Deparment of Computer Science
University of Malta
Msida, Malta
email: gordon.pace@um.edu.mt
Abstract—Robustness
of
embedded
systems
to
potential
changes in their environment, which may result in the inputs
being affected, is crucial for reliable behaviour. One typical
possible change is that the system’s inputs are slowed down,
altering its temporal behaviour. Algorithmic analysis of systems
to be able to deduce their robustness under such environmental
interference is desirable. In this paper, we present a framework
for the analysis of synchronous systems to analyse their behaviour
when the inputs slow down through stuttering. We identify
different types of slowdown robustness constraints and present
static and dynamic analysis techniques for determining whether
systems written in Lustre satisfy these robustness properties.
Keywords-Synchronous Languages; Lustre; Slowdown
I. INTRODUCTION
Software is increasingly becoming more prominent as a
controller for a variety of devices and processes. Embedded
systems operate within an environment, by which they are
affected and with which they interact — this tight interaction
usually means that changes to the environment directly affect
the behaviour of the embedded system. One such situation
can occur when the environment slows down its provision
of input to the system, possibly resulting from a variety of
reasons. For example, the system producing the inputs or the
communications channel on which these inputs pass to the
program might be under heavy load, delaying the inputs; or
the program is deployed on a faster platform, therefore making
the input relatively slower.
One question which arises immediately in such scenarios
is how the system behaves when its input slows down. Does
it act in an expected manner, or does the slow input cause
it to produce unwanted output? In this paper, we develop
an approach to study whether a system continues to behave
correctly under these conditions. We characterise different
notions of correctness since, for instance, in some cases we
may desire the output to be delayed by the same amount as the
inputs, whereas in others, the values but not the actual delays
on the outputs are important.
The theory we develop is applied to the synchronous
language Lustre [1], which enables the static deduction of
a program’s resource requirements, making it ideal for the
design of embedded systems. Although retiming analysis
techniques for continuous time can be found in the literature
[2], our approach adapts them for discrete time, the timing
model used by Lustre and other synchronous languages.
Such a theory requires addressing a number of considera-
tions. In section II we deﬁne streams [3], which are inﬁnite
sequences of values, as well as the Lustre programs which
manipulate them. In the model we adopt, streams can be
slowed down through the repetition of values, which is also
called stuttering. Stuttering can be a valid model for slow input
under several scenarios:
• If a memory’s clock signal becomes slower, the memory
will take more time to read new input, and thus will
maintain its present output for a longer time. A program
which samples the values of this memory at the same rate
will then experience repetition in its input.
• The system providing the input might not be ready to
provide its output, or it might experience a fault from
which it needs time to recover. In these situations, some
systems might keep their present output constant until
they are ready once again. In this case, the receiving
program will also experience repetition in its input.
• A physical process which is being sampled in order to
provide input to a program might slow down. Under
certain sampling conditions, the resulting input received
by the program corresponds to experiencing stutter in its
inputs.
Providing stuttered input to a program will cause it to react
in a particular manner. A program can be said to be robust with
respect to slow input if it behaves in a way which is acceptable
to the scenario under consideration. Section III provides a
number of robustness properties which characterise what may
be acceptable in different scenarios. Given such a property, one
needs some algorithmic means of checking whether it holds or
not for a given program. Section IV considers a method based
on the static analysis of the program’s text, while section V
focuses on a method based on the dynamic analysis of its
state space. This is followed by a case study in section VI,
in which these two approaches are applied to a number of
Boolean Lustre programs. Section VII presents work related
to the theory which has been developed, while section VIII
provides some concluding remarks.
14
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

II. STREAMS, SLOWDOWN AND LUSTRE PROGRAMS
We adopt the standard view of a stream as an inﬁnite
sequence of values over a particular type, representing the
value of the stream over a discrete time domain. We will
write s(t) to denote the value taken by stream s at time t,
lifting the notation for vectors of streams. For instance, for
two streams s and s′, ⟨s, s′⟩(t) is deﬁned to be the tuple of
values ⟨s(t), s′(t)⟩.
By slowing down a stream, one obtains the same sequence
of values, but possibly with some of the values repeated a
number of times, representing stutter. A slowdown can be
characterised using a latency function — a total function which
returns the number of times each value in the stream will
stutter for. Given a stream s, which is slowed down according
to a latency function λ, one obtains the slowed down stream
sλ:
sλ = s(0), . . . s(0)
|
{z
}
λ(0)+1
, s(1), . . . s(1)
|
{z
}
λ(1)+1
, . . . s(n), . . . s(n)
|
{z
}
λ(n)+1
. . .
Note that sλ is obtained from s by replacing the value of s at
time t by a block of of λ(t) + 1 copies of this value. We will
write Startλ
t to denote the time instant at which the tth such
block begins: Pt−1
i=0 λ(i). Similarly, Endλ
t denotes the time
instant at which the block ends and is analogously deﬁned.
Note that the constant zero latency function leaves the
stream untouched. If a latency function is a constant function,
we shall refer to it as uniform.
As before, we will overload this notation for vectors of
streams, with ⟨s, s′⟩λ being equivalent to ⟨sλ, s′
λ⟩.
Lustre [1] provides a way of symbolically specifying sys-
tems which process streams in a declarative manner. A Lustre
program P = ⟨V, I, O, E⟩ is deﬁned over a set of stream
variables V , with two disjoint subsets I and O consisting of the
input and output stream variables of the program respectively,
and a set of equations E which explains how to compute the
value of each output variable at every instant of time in terms
of other program variables. Equations can take one of the
following forms:
y
=
⊗(x1, . . . xn)
y
=
pre x1
y
=
x1 -> x2
y
=
x1 fby x2
Instantaneous operators ⊗ are used to represent computation
performed at each time instant. For instance, the equation
y = ∧(x1, x2) would update the value of stream variable y
with the value of the conjunction of the stream variables x1
and x2 at each time instant: y(t) = x1(t) ∧ x2(t). The delay
operator pre allows access to the previous value of a given
stream variable: (pre x)(t+1) = x(t) with the resulting stream
being undeﬁned for the initial time point, at which it is said
to take the value Nil. In fact, pre behaves like an uninitialised
memory. The initialisation operator x1 -> x2 yields a stream
behaving like x1 at the ﬁrst time instant, and like x2 elsewhere:
(x1 -> x2)(0) = x1(0) and (x1 -> x2)(t+1) = x2(t+1).
These last two operators are frequently combined to produce
an initialised memory using the followed-by operator, with
x1 fby x2 being equivalent to x1 -> pre x2.
Below we illustrate two sample programs. The program
TOGGLE represents a toggle switch which starts in the Boolean
state true, and which outputs its present state if its toggle input
is false and inverts and outputs its present state if the toggle
input is true. On the other hand, the program SISO is a 4-bit
serial in serial out register, which starts with all its memories
set to true.
node TOGGLE(toggle : bool)
returns(out : bool);
var X, Y : bool;
let
out = if toggle then x else y;
x = not y;
y = true fby out
tel;
node SISO(i1 : bool)
returns(i5 : bool);
var i2, i3, i4 : bool;
let
i2 = true fby i1;
i3 = true fby i2;
i4 = true fby i3;
i5 = true fby i4;
tel;
We will use the notation Pinst, Pdelay, Pinit, and Pfby for
the primitive programs with just one equation consisting of a
single application of an instantaneous, delay, initialisation or
followed-by operator respectively. For each primitive program,
the variable occurring on the left hand side of its equation is
an output variable, those appearing on the right are inputs.
For a Lustre program P, dep0(P) ⊆ V × V relates a
stream variable y to a stream variable x if y is deﬁned in
P by an equation with x appearing on the right hand side.
The irreﬂexive transitive closure of this relation denotes the
dependencies between the stream variables and is written as
dep(P). Another important concept is that of an instantaneous
dependency relation. This relation can be obtained by starting
from the relation inst0(P) ⊆ V × V , which relates a stream
variable y to a stream variable x only if y’s deﬁning equation
involves x, and x does not appear in a pre equation or on the
right hand side of an fby equation. The irreﬂexive transitive
closure of this relation, inst(P) denotes the instantaneous
dependencies between stream variables. A Lustre program P is
said to be well-formed if none of its variables instantaneously
depend on themselves: ∀s · (s, s) /∈ inst(P).
Given two Lustre programs P1 and P2 (with inputs I1, I2
and outputs O1, O2 respectively) their composition, written
P1 | P2, is the Lustre program whose equation set is the union
of the equation sets of the respective programs. Its inputs are
the inputs of either program not appearing as outputs of the
other (I = (I1∪I2)\(O1∪O2)), and vice versa for its outputs
(O = (O1∪O2)\(I1∪I2)). In particular, certain speciﬁc types
of composition shall be referred to as follows:
• Disjoint composition, if O2 ∩ I1 = O1 ∩ I2 = ∅.
• Composition without feedback, if O2∩I1 = ∅ or O1∩I2 =
∅.
• Fully connected composition, if O2∩I1 = ∅ and O1 = I2,
or conversely O1 ∩ I2 = ∅ and O2 = I1.
Another important operation is that of adding a feedback
loop to a program P by connecting an output y to an
15
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

input x written P[y → x], provided y does not depend
on x, that is (y, x) ̸∈ dep(P). Given the Lustre program
P ′ = ⟨{x, y}, {y}, {x}, {x = y}⟩, adding a feedback loop
can also be deﬁned in terms of composition as follows:
P[y → x]
df= P | P ′
Assuming the existence of an ordering on the program’s
variables, given a Lustre program P, and a vector i which
assigns a stream to each of the program’s input variables, P(i)
denotes the vector o of output streams corresponding to the
output variables of P as computed by the semantics of Lustre
[1].
Our goal is therefore that of identifying Lustre programs
P such that upon slowing down their inputs i according to a
latency function λ, will result in P still being well behaved. In
the next section we will identify different forms of such well-
behaviour of P(iλ) with respect to the unslowed behaviour
P(i).
Boolean Lustre programs can also be compiled into au-
tomata spanning over the state space they cover [4]. This can
be deﬁned for Lustre programs using fby (instead of delays)
as follows:
Deﬁnition 1: (Lustre Automaton). Let P be a Boolean Lus-
tre program with n input variables, m output variables, and k
fby equations of the form y = x1 fby x2. Then, this program
can be compiled into an automaton A = ⟨S, sinit, τ, δ⟩, where
S is its set of states, sinit is its initial state, τ : Bn × S → S
is its transition function and δ : Bn × S → Bm is its output
function. The automaton processes the input vector provided
to the program one tuple at a time. During each instant, it
uses its current input tuple and its present state to (i) move to
a new state under the guidance of its transition function τ and
(ii) output an output tuple as deﬁned by its output function δ,
which represents the values of the program’s output variables
at that particular time instant. The program P can be converted
into automaton A using the following procedure.
External Initialisation: A program is said to be initialised
externally if in at least one of its fby statements x1 fby x2,
the initial variable x1 depends on one of the program’s input
variables.
States: Each fby statement x1 fby x2 corresponds to a mem-
ory element in the program, whose value is determined by
the variable x1 at the ﬁrst instant and by the variable x2 at
all further instants. Since each such memory can either be
true or false, we create 2k states, with each state representing
one possible conﬁguration of the program’s memories. If the
program is initialised externally, we also add a special initial
state init to the set of states.
Initial State: If the program is initialised externally, the
initial state is init. Otherwise, the initial state is the state
corresponding to the conﬁguration obtained by evaluating the
variables of the form x1 within the program’s fby statements.
Transition Function: With n input variables, there are 2n
possible input tuples. Each state therefore has 2n transitions,
with each transition labeled with the associated input tuple.
true
start
false
true/false
true/true
false/true
false/false
Fig. 1.
Automaton obtained from toggle switch program
Given a state s ̸= init and input tuple a, the next state τ(a, s)
is computed as follows: (i) assign the conﬁguration represented
by present state s to the respective variables of the form
x2 occurring on the right hand side of fby statements, (ii)
assign the input values represented by tuple a to the respective
input variables and (iii) simulate the Lustre program, using the
deﬁning equations of the variables of the form x2 to determine
the conﬁguration of the memories at the next time instant,
allowing the selection of the appropriate next state. The initial
state init, if present, also has 2n transitions. The next states are
determined as follows (i) assign the input values represented
by tuple a to the respective input variables, (ii) use the deﬁning
equations of variables of the form x1 to compute the value of
the initialisation variables and (iii) simulate the Lustre program
using the deﬁning equations of the variables of the form x2
which determine the next state. Again, these values determine
the conﬁguration of the memories at the next time instant and
allow the selection of the appropriate next state.
Output Function: Each transition is associated with an m-
tuple, which represents the values of the output variables when
the automaton ﬁnds itself in a certain state and processes a
certain input tuple. The procedure for obtaining the output
tuple is similar to that for obtaining the next state, except that
the output tuple is constructed by simulating the program and
considering the values of the output variables.
Fig. 1 shows the automaton which would be obtained by
applying the above procedure to the toggle switch program
TOGGLE. The two states represent the two possible conﬁgu-
rations which the memory corresponding to the program’s only
fby equation can be in. Meanwhile, for each transition, the
value on the left shows the value of the toggle input variable
which causes the transition, and the value on the right shows
the output value computed by the program. We shall return to
this representation of the TOGGLE program at a later stage.
We now consider a number of different forms of program
robustness to slow input.
III. SLOWDOWN ROBUSTNESS
Whether a program behaves in an acceptable way depends
on the scenario it is operating in. In this section, the four well
behaviour properties of stretch robustness, stutter robustness,
fast-enough robutness and immediate-at-ﬁrst robustness are
introduced, characterising desirable behaviour under different
circumstances.
16
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

A. Stretch Robustness
Stretch robustness (STR) speciﬁes the fact that if the input
of a program slows down by some amount, then the output
of a program should slow down by the same amount. This
property can be formalised by requiring that whenever a
latency function λ is applied to a program’s input, the program
will respond by applying the same latency to its output.
Deﬁnition 2: (Stretch Robustness). A program P is said to
be stretch robust with respect to a latency function λ, if for
any input vector i: P(iλ) = P(i)λ. P is simply said to be
stretch robust if it is stretch robust with respect to all latency
functions.
The table below shows the relationship between a slow input
vector iλ and the required program output P(iλ):
iλ
i(0), . . . i(0)
|
{z
}
λ(0)+1
,
i(1), . . . i(1)
|
{z
}
λ(1)+1
,
. . .
i(n), . . . i(n)
|
{z
}
λ(n)+1
. . .
P(iλ)
o(0), . . . o(0)
|
{z
}
λ(0)+1
,
o(1), . . . o(1)
|
{z
}
λ(1)+1
,
. . .
o(n), . . . o(n)
|
{z
}
λ(n)+1
. . .
One immediate consequence of this property is that addi-
tional repetition of the program’s input does not cause the
program to change its output. Stretch robustness is thus useful
in situations where one requires the program not to change its
output when faced with additional latency. Stretch robustness
is a very strong property, which can be relaxed in a number
of ways to obtain weaker criteria which may be sufﬁcient in
certain circumstances. We shall now consider these criteria.
B. Stutter Robustness
Stutter robustness (STU) requires that if the input of a
program slows down by some amount, the output of the
program should also slow down, but possibly at a different
rate. This will be modeled by requiring that whenever a latency
function λ is applied to a program’s input, the program will
respond by applying some latency function λ′ to its output.
Unlike stretch robustness, λ and λ′ need not be equal:
Deﬁnition 3: (Stutter Robustness). A program P is stutter
robust with respect to a latency function λ if there exists a
latency function λ′ such that for every input vector i: P(iλ) =
P(i)λ′. P is said to be stutter robust if it is stutter robust with
respect to any latency function.
The relationship between a slow vector of inputs iλ and the
required program output P(iλ) is shown below:
iλ
i(0), . . . i(0)
|
{z
}
λ(0)+1
,
i(1), . . . i(1)
|
{z
}
λ(1)+1
,
. . .
i(n), . . . i(n)
|
{z
}
λ(n)+1
. . .
P(iλ)
o(0), . . . o(0)
|
{z
}
λ′(0)+1
,
o(1), . . . o(1)
|
{z
}
λ′(1)+1
,
. . .
o(n), . . . o(n)
|
{z
}
λ′(n)+1
. . .
Thus for a stutter robust program, the output under slow
input can be obtained from the original output by adding any
number of repetitions to the values appearing in the original
output, without adding any other artifacts nor removing any
values. This means that stutter robustness is useful as a well
behaviour property in situations where one needs to ensure
that the output under slow input has the same structure as the
original output, but one is able to tolerate additional repetition
in the slow output.
C. Fast-Enough and Immediate-at-First Robustness
In stretch robustness, the value of the outputs remains equal
to the original value in the unslowed system. In fast-enough
robustness (FE) this constraint is relaxed by requiring only that
the program converge to the original output before the slowed
down input ends. Formally, we shall say that a program is
fast-enough robust if, when we apply a latency function λ to
the program’s input, the slow output has the property that its
value at the end of each block of repetitions (at points of the
form Endλ
t ) is equal to the value taken by the original output
at the points t (i.e. those points which were expanded into the
blocks of repetitions).
Deﬁnition 4: (Fast-Enough Robustness). A program P is
fast-enough robust with respect to a latency function λ if for
any input vector i:
∀t : T · P(iλ)(Endλ
t ) = P(i)(t)
Program P is said to be fast-enough robust if it is fast-
enough robust with respect to any latency function.
Fast-enough robustness is primarily of interest for particular
latency functions, since general fast-enough robustness can be
proved to be equivalent to general stretch robustness.
Fast-enough robustness can be visualised as follows (using
? to indicate don’t-care values):
iλ
i(0), . . . i(0)
|
{z
}
λ(0)+1
,
i(1), . . . i(1)
|
{z
}
λ(1)+1
,
. . .
i(n), . . . i(n)
|
{z
}
λ(n)+1
. . .
P(iλ)
?, . . .?, o(0)
|
{z
}
λ(0)+1
,
?, . . .?, o(1)
|
{z
}
λ(1)+1
,
. . .
?, . . .?, o(n)
|
{z
}
λ(n)+1
. . .
This well behaviour property is useful in scenarios in which
one can tolerate the fact that additional latency on the input
might produce undesirable intermediate results as long as the
original value is produced by the end of the latency period.
The dual of fast-enough robustness is immediate-at-ﬁrst
robustness (IAF) — instead of constraining the slow input
to converge to the original value before a block of repetitions
ends, it requires it to produce the original value as soon as a
block of repetitions starts, leaving it free to assume any value
until that block of repetition ends.
Deﬁnition 5: (Immediate-At-First Robustness). A program
P is said to be immediate-at-ﬁrst robust with respect to latency
function λ if for any input vector i:
∀t : T · P(iλ)(Startλ
t ) = P(i)(t)
P is said to be immediate-at-ﬁrst robust if it satisﬁes the
above constraint with respect to any latency function.
Immediate-at-ﬁrst robustness can be visualised as follows:
17
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

iλ
i(0), . . . i(0)
|
{z
}
λ(0)+1
,
i(1), . . . i(1)
|
{z
}
λ(1)+1
,
. . .
i(n), . . . i(n)
|
{z
}
λ(n)+1
. . .
P(iλ)
o(0), ?, . . .?
|
{z
}
λ(0)+1
,
o(1), ?, . . .?
|
{z
}
λ(1)+1
,
. . .
o(n), ?, . . .?
|
{z
}
λ(n)+1
. . .
This well behaviour property is useful in scenarios in which
one requires the program to react immediately as soon as
the latency on a previous input value wears off, but in
which further repetition of the input can be safely ignored
by outputing any result.
We shall now consider algorithmic means to check Lustre
programs for robustness.
IV. DETECTING ROBUSTNESS: STATIC ANALYSIS
The ﬁrst approach to checking whether a program satisﬁes
a well behaviour property is based on a static analysis of
the structure of the Lustre program. The analysis is based
on two main theorems: (i) Theorem 1 which identiﬁes which
primitive programs satisfy which well behaviour properties
and; (ii) Theorem 2 which identiﬁes which well behaviour
properties are preserved upon composition of two well be-
haved programs.
Theorem 1: Primitive Lustre programs all come with a level
of guaranteed robustness: (i) instantaneous programs are robust
under all four forms; (ii) delay and followed-by programs are
robust under stutter and immediate-at-ﬁrst robustness; and (iii)
primitive initialisation programs are immediate-at-ﬁrst robust.
Proof: (i) Instantaneous programs apply a pointwise operator
to their input streams to obtain their output streams. Thus,
the same input tuple always causes the same output tuple.
Repetition of inputs through latency will therefore cause
repetition of outputs, which makes the program stretch robust.
(ii) The output of delay and fby programs has an additional
initial value with respect to the input stream. Slowing the input
stream down by a latency function, causes the program to
attach this value to the slow stream. The output under slow
input can therefore be obtained from the original input through
a latency function, which does not repeat the attached element,
and which repeats all subsequent elements accordingly. These
programs are therefore stutter robust. The programs are also
immediate-at-ﬁrst robust as can be inferred from the depiction
below, which shows how the values of the original output (ﬁrst
row) are associated to the corresponding blocks of the output
under latency (second row). It is clear that the value at the
beginning of each block is equal to the corresponding value
in the original output.
P (i)
Nil
x1(0)
x1(1)
P (iλ)
Nil, x1(0)...x1(0)
|
{z
}
λ(0)
x1(0), x1(1)...x1(1)
|
{z
}
λ(1)
x1(1), x1(2)...x1(2)
|
{z
}
λ(2)
(iii) Initialisation programs take the ﬁrst value of stream
x1, and attach to it the stream x2 from its second value
onwards. Below one can see how the blocks of output under
i
λ
P1
j
λ′
P2
o
λ′′
Fig. 2.
Fully connected composition preserves STU
slow input relate to the original output; this illustrates the fact
that the value at the beginning of each block is equal to the
corresponding value in the original output.
P (i)
x1(0)
x2(1)
x2(2)
P (iλ)
x1(0), x2(0)...x2(0)
|
{z
}
λ(0)
x2(1)...x2(1)
|
{z
}
λ(1)+1
x2(2)...x2(2)
|
{z
}
λ(2)+1
□
We can now consider the effect of composing robust programs.
Theorem 2: Some forms of composition of robust programs
guarantee robustness of the resulting program: (i) the composi-
tion without feedback of two stretch robust programs is always
stretch robust, so is adding a feedback loop to a stretch robust
program; (ii) the fully connected composition of two stutter
robust Lustre programs is always stutter robust; and (iii) the
disjoint composition of two immediate-at-ﬁrst robust programs
is always immediate-at-ﬁrst robust.
Proof: We provide a proof of (ii) to illustrate the proof idea.
We consider two arbitrary stutter robust programs P1 and
P2, and show that their fully connected composition is also
stutter robust. Since P1 and P2 are being composed in a fully
connected way, every output of P1 is connected to an input of
P2, and there are no feedback connections. This is shown in
Fig. 2.
Now suppose that if we pass a vector i to P1, the program
responds by outputting vector j. Also suppose that when P2
receives vector j it outputs vector o in response. We need to
show that if a latency function λ is applied to the composite
program’s input vector i, the composite program applies some
latency function to its output vector o. Since P1 is stutter
robust, applying λ to the input vector i will make P1 apply
some latency function λ′ to its output j. Hence, P2 receives
the vector j slowed down by λ′ as input. Since P2 is also
stutter robust it will apply some other latency function λ′′ to
its output o. Thus, applying a latency function to the input
of the composed program, causes the composed program to
slow its output by some latency function, proving that stutter
robustness is preserved by fully connected composition.
□
We now consider a method which analyses the behaviour
of the particular program under examination, rather than its
structure.
V. DETECTING ROBUSTNESS: DYNAMIC ANALYSIS
Theorem 2 allows us to conclude robustness of composed
programs in a syntactically compositional manner. In this
18
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

section, we give richer, although more expensive, semantic
analysis techniques for Lustre programs allowing for dynamic
robustness analysis of their behaviour. Through the use of
symbolic methods, such as with Binary Decision Diagrams
(BDDs), the analysis can be applied either on whole programs
or to subprograms. In the latter case, Theorem 2 can then be
used to obtain results about the composition of the subpro-
grams.
The techniques we shall discuss rely on identifying condi-
tions on the Lustre automaton which are sufﬁcient to guarantee
that certain well behaviour properties are satisﬁed by that
program. Two types of conditions are deﬁned: (i) latency
independent conditions, which check whether a robustness
property holds in general, and (ii) latency dependent con-
ditions, which check whether a property holds when some
particular latency function is applied to the program’s input.
The conditions identiﬁed can be checked using either an
exhaustive analysis of the automaton’s state space, or prefer-
ably using a symbolic representation of the automaton such as
BDDs to ensure that the approach scales up to larger systems.
A. Latency Independent Conditions
We start by identifying properties which guarantee slow-
down robustness for any latency function. The strongest con-
dition, is that stateless1 programs are always stretch robust.
Theorem 3: (Condition
1
—
Stretch
Robustness).
If
∀a, s, s′
·
δ(a, s) = δ(a, s′), then the program is stretch
robust.
Proof: Under such a condition, a particular input tuple always
generates the same output tuple, independently of the state
the automaton ﬁnds itself in. Thus, any repetition of an input
tuple caused by a latency function causes a repetition of the
corresponding output tuple. This is sufﬁcient to ensure stretch
robustness.
□
Under stutter robustness, slowing a program’s input by a
latency function λ, causes the program to slow its output by
a latency function λ′. In practice, this means that the output
under slow input can be obtained through the repetition of the
original output tuples only. We now show that if the automaton
has a certain feature, then this property cannot hold.
Theorem 4: (Condition 2 — Failure Of Stutter Robustness).
Programs satisfying the following condition are not stutter
robust:
∃a, b, s, s′, j, k, l ·
δ(a, s) = j ∧ τ(a, s) = s′∧
δ(a, s′) = k ∧ k ̸= j ∧
δ(b, s′) = l ∧ b ̸= a ∧ l ̸= k
Proof: Condition 2 looks for the presence of reachable states
s and s′ having the following properties: (i) under input tuple
a, state s outputs tuple j and passes to state s′; (ii) under
input tuple a, state s′ outputs k ̸= j and (iii) under input tuple
b ̸= a, state s′ outputs tuple l ̸= k.
We now show that if this structure is present in the automa-
ton, there will always be some input vector and some latency
1A program is stateless if the output depends solely on the input at that
point in time.
function which breaks the stutter robustness property. We ﬁrst
construct the input vector as follows. Choose a path from the
start state sinit to the state s. By following this path of n
transitions, we obtain the ﬁrst n tuples of the input vector. We
also obtain the ﬁrst n tuples of the output vector. To this initial
segment of the input vector, one appends the input tuples a, b,
which causes the resulting output vector to be augmented by
the output tuples j, l. The rest of the input vector can be chosen
arbitrarily.
We now choose a latency function, which when applied
to the input vector above, breaks the property. The chosen
latency function will insert 1 repetition for the input tuple at
time instant n + 1, and 0 repetitions elsewhere. Applying this
latency function to the input vector chosen earlier yields the
original initial segment followed by the tuples a, a, b. Through
the presence of the regularity identiﬁed in the theorem, the
resulting output will be the initial segment of the output vector
followed by the output tuples j, k, which means that with
respect to the original output an l tuple has been deleted. This
makes it impossible to derive the output under slow input from
the original output through the addition of repetitions only. □
Finally, we can also identify a sufﬁcient condition for
immediate-at-ﬁrst robustness. If the automaton obtained from
the program always loops with repetitions after the ﬁrst
occurrence of an input, then the program is guaranteed to be
immediate-at-ﬁrst robust.
Theorem 5: (Condition 3 — Immediate-At-First Robust-
ness). If ∀a, s, s′
·
(τ(a, s) = s′)
=⇒
(τ(a, s′) = s′),
then the program is immediate-at-ﬁrst robust.
Proof: When processing an input vector i, the automaton uses
the current input i(t) and state s(t), to compute the output o(t)
and next state s(t+1). When input i has latency λ, the program
receives consecutive blocks of constant inputs, with the nth
block consisting of tuples of the form i(n). For the program
to be immediate-at-ﬁrst robust, the output at the beginning of
the nth block must have the form o(n).
We observe that if the automaton ﬁnds itself in state s(n) at
the beginning of block n, the condition guarantees that (i) at
the ﬁrst time instant in the block the automaton moves to state
s(n + 1); (ii) it stays in state s(n + 1) for the remainder of
the block and (iii) the (n + 1)th block starts in state s(n + 1).
Noting that in block 0, the automaton starts in the initial state
s(0), provides the base case for an inductive argument which
guarantees that the automaton ﬁnds itself in state s(n) at the
beginning of the nth block, causing the output to be o(n) as
required.
□
B. Latency Dependent Conditions
So far, we tried to identify programs which are robust under
an input slowed down by an unknown latency. If one knows
that the inputs of a program are going to slow down by some
uniform latency function λ(t) = c, where c is a constant, it
is possible to check whether the program is robust for that
particular scenario using the following weakened conditions.
Condition 4 requires that for any state s, the state reached
by the automaton after the occurrence of a speciﬁc input tuple,
19
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

τ(a, s), is the same state reached after the occurrence of c+1
such input tuples, which we denote by τ c+1(a, s).
Theorem 6: (Condition
4
—
Immediate-At-First-
Robustness). If ∀a, s
·
τ(a, s) = τ c+1(a, s) for some
positive natural number c ≥ 2, the program is immediate-at-
ﬁrst robust for latency functions of the form λ(t) = c
Proof: When processing an input vector i, the automaton uses
the current input i(t) and state s(t), to compute the output
o(t) and next state s(t + 1). When input i has latency λ, the
program receives consecutive blocks of constant inputs of size
c+1, with the nth block consisting of tuples of the form i(n).
For the program to be immediate-at-ﬁrst robust, the output at
the beginning of the nth block must have the form o(n).
Suppose that at the beginning of the nth block the automa-
ton ﬁnds itself in state s(n). Then at the beginning of the
(n + 1)th block it is in state s(n + 1) on account of the
following facts: (i) at the ﬁrst time instant in the nth block the
automaton moves to s(n+1) and (ii) the condition guarantees
that after c+1 steps of the same input the automaton will return
to s(n + 1). Noting that in block 0, the automaton starts in
the initial state s(0), provides the base case for an inductive
argument which guarantees that the automaton ﬁnds itself in
state s(n) at the beginning of the nth block, causing the output
to be o(n) as required.
□
The ﬁnal condition which will be considered requires that
if an automaton is in state s, it will return to the same state s
after c repetitions of the input.
Theorem 7: (Condition 5 — Immediate-At-First and Fast-
Enough Robustness). If ∀a, s · τ c(a, s) = s for some positive
natural number c ≥ 2, the program is both immediate-at-ﬁrst
robust, as well as fast-enough robust, for latency functions of
the form λ(t) = c.
Proof: When processing an input vector i, the automaton uses
the current input i(t) and state s(t), to compute the output o(t)
and next state s(t+1). When input i has latency λ, the program
receives consecutive blocks of constant inputs of size c + 1,
with the nth block consisting of tuples of the form i(n). For
the program to be immediate-at-ﬁrst robust, the output at the
beginning of the nth block must have the form o(n). Similarly,
for a program to be fast-enough robust, the output at the end
of the nth block must have the form o(n).
Suppose that at the beginning of the nth block the automa-
ton ﬁnds itself in state s(n). Then at the end of the nth block
it is in state s(n) on account of the fact that the automaton
returns to its original state after c transitions of the same input.
This state also combines with input i(n) to ensure passage to
state s(n+1) at beginning of the (n+1)th block. Noting that in
block 0, the automaton starts in the initial state s(0), provides
the base case for an inductive argument which guarantees that
the automaton always ﬁnds itself in state s(n) at the end of
the nth block, causing the output to be o(n) as required for
fast-enough robustness, and in state s(n + 1) at the beginning
of the (n+1)th block guaranteeing that the output is o(n+1)
as required by immediate-at-ﬁrst robustness.
□
i1
SISO1
i2
SISO2
i3
SISO3
i4
SISO4
i5
Fig. 3.
SISO program broken into primitive programs
VI. CASE STUDY
The static and dynamic analysis theorems were applied to
six Boolean Lustre programs to examine whether these are
strong enough to deduce slowdown robustness. For compari-
son purposes, a manual analysis of these programs was also
performed in order to discover which robustness properties
each program satisﬁes or fails to satisfy. The programs under
consideration, with the actual properties satisﬁed by each are
listed below:
• RCA, a (stateless) ripple carry adder which satisﬁes
stretch robustness.
• RISE, a program which receives a Boolean stream and
detects the presence of rising edges, and which satisﬁes
stutter robustness and immediate-at-ﬁrst robustness.
• SWSR, a switch with a set and reset input, which satisﬁes
stretch robustness.
• TOGGLE, a switch with a toggle input, which does not
satisfy any property for every latency function.
• SISO, a serial in serial out register, which satisﬁes stutter
robustness.
• PIPO, a parallel in parallel out register, which satisﬁes
stutter robustness and immediate-at-ﬁrst robustness.
We shall now discuss the application of the static and
dynamic analysis theorems to the programs in question. To
illustrate how the static analysis theorems can be employed to
reason about a program, we will consider their use to prove
that the SISO register program is stutter robust.
Example 1: Since the SISO program has 4 equations, we
ﬁrst break it down into four separate primitive programs
SISO1, SISO2, SISO3 and SISO4 as shown in Fig. 3, where
SISOj = ⟨{ij, ij+1}, {ij}, {ij+1}, {ij+1 = true fby ij}⟩
It is clear that each such program is an fby primitive
program, and that these primitive programs can be composed
through fully connected composition to obtain the program
SISO. This can be done by starting from SISO1 and sequen-
tially composing the programs SISO2, SISO3 and SISO4. Since
SISO can be built from stutter robust primitives and through
stutter robustness preserving compositions, we can conclude
that it is stutter robust.
Table I illustrates the results which can be obtained in a
similar manner through the static analysis of the programs
in question. An entry in the table indicates whether the
corresponding program can be shown to satisfy a particular
robustness property or not through this technique. Within an
entry, a ✓ symbol indicates that the program was found to
satisfy the property. In addition, a ? symbol indicates that the
static analysis yielded an inconclusive result, while a − symbol
indicates that a test was unnecessary since the program was
found to satisfy the stronger property of stretch robustness.
20
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

TABLE I
RESULTS OBTAINED THROUGH STATIC ANALYSIS
Property/Program
RCA
RISE
SWSR
TOGGLE
SISO
PIPO
STR
✓
?
?
?
?
?
STU
-
?
?
?
✓
?
IAF
-
?
?
?
?
✓
TABLE II
RESULTS OBTAINED THROUGH DYNAMIC ANALYSIS
Property/Program
RCA
RISE
SWSR
TOGGLE
SISO
PIPO
STR
✓
?
?
?
?
?
STU
-
?
?
×
?
?
IAF
-
✓
✓
✓c=2
?
✓
FE
-
?
?
✓c=2
?
?
As one can see, the static analysis reveals that the ripple
carry adder is stretch robust, that the SISO register is stutter
robust and that the PIPO register is immediate-at-ﬁrst robust.
Static analysis thus yields results when the programs have a
simple structure in terms of the interconnections between the
component primitive programs.
We now illustrate how dynamic analysis can be applied by
means of another example. We shall show that the Toggle
Switch program TOGGLE is both immediate-at-ﬁrst robust as
well as fast-enough robust for the latency function λ(t) = 2.
Example 2: Starting from the TOGGLE program, we ﬁrst
obtain the automaton representation of the program by using
the construction outlined in Deﬁnition 1. This yields the
automaton depicted earlier in Fig. 1. By observing the structure
of the automaton, we note that from any state, taking 2
transitions with the same input tuple returns the automaton
to the same state. The program thus satisﬁes the properties in
question through the use of Theorem 7.
Table II summarises the results obtained through the dy-
namic analysis of the programs under consideration. In ad-
dition to the earlier conventions, an × symbol indicates that
the program was found not to satisfy the property in question,
while a ✓ symbol with subscript c = 2, indicates that the
program has been proven to satisfy the property for the latency
function λ(t) = 2 through the use of a latency dependent
condition. In practice, BDD techniques were used to evaluate
the conditions, and the evaluation was instantaneous for the
programs in question.
Dynamic analysis enlarges the scope of automatically de-
rived well behaviour results to programs which have more
complex structures. The ripple carry adder is reconﬁrmed
as strech robust and the PIPO register has been reconﬁrmed
imemdiate-at-ﬁrst robust. In addition, the rising edge program,
the switch with set and reset program and the PIPO register
have been shown to be immediate-at-ﬁrst robust, and the toggle
switch has been conclusively shown not to be stutter robust.
More over, the toggle switch program has been shown to be
both immediate-at-ﬁrst robust and fast-enough robust for the
speciﬁc latency function λ(t) = 2.
While not all of the properties satisﬁed by the programs
have been discovered through the automated analysis, the
combination of static and dynamic analysis has revealed many
details about the well behaviour of the programs in question.
The number of programs which have been proved immediate-
at-ﬁrst robust indicates that the condition which detects it
might be applicable for some interesting set of programs. On
the other hand, the results obtained using the latency dependent
conditions are encouraging as they indicate the possibility of
satisfying a property under a particular slowdown scenario
even though the program might not satisfy it in general. One
can also note that the two approaches complement one another;
in particular, unlike dynamic analysis, static analysis can be
used to reason about programs which satisfy stutter robustness.
VII. RELATED WORK
The discrete theory of slowdown considers the effect of
slowing down all the input streams of a stream processing pro-
gram by the same amount through the addition of stutter. There
are various other models of slowdown which can be found
in the literature. The theory of latency insensitive design [5]
allows streams to slow down through the addition of explicit
stall moves into those streams. In reaction to performing a stall
move on an input stream, a program reacts by performing
a procrastination effect, that is by inserting additional stall
moves in its other streams to ensure that causality between
the events of a program is preserved. A program is said to
be patient if it knows how to perform a procrastination effect
in response to any possible stall move. In other words, the
program is always able to delay its operation in response
to slow input without breaking. Patience is thus a form of
robustness to delays in the process’ streams, but which, unlike
our properties, does not dictate the exact form which this
robustness should take.
In the theory of polychronous processes [6], used to give
a semantics to the synchronous language Signal [3], streams
do not have to take a value at every time instant. Given
a particular program behaviour, consisting of the input and
output streams of a program, the operations of stretching and
relaxation can be used to obtain a slower program behaviour.
Stretching remaps the time instants at which the values occour
on each stream, preserving the order of values in each stream,
and the simultaneity of values between different streams. The
stretching operation stretches all the streams by exactly the
same amount and is similar to how a stretch robust program
would behave when its inputs are slowed down. On the other
hand, when relaxation slows a behaviour, it only guarantees
that the order of values within each stream is preserved. The
notion of relaxation which arises when all input streams are
slowed down by one amount, and all output streams by another
amount, is similar to how to a stutter robust program would
behave under input slowdown. Signal guarantees that all its
programs are stretch closed (a property analogous to stretch
robustness), but this is only possible because no additional
values are ever inserted as a result of slowing down a stream.
Reasoning about slowdown and speedup for continuous time
behaviour has been investigated in [2]. The behaviour of a
program can be slowed down by stretching these real-time
signals through time by using the concept of time transforms.
21
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

The concept of a latency function can be seen as a discrete
time version of a time transform. When one slows a behaviour
through a time transform, all streams are slowed down exactly
by the same amount. This manner of slowing down a behaviour
corresponds to how one would expect a stretch robust system
to react in our discrete theory.
Stutter invariance for Linear Temporal Logic (LTL) proper-
ties has been investigated in [7], in which a stuttered path slows
down all inputs and outputs of a program by the same amount.
Stutter invariant properties are ones which, if they are satisﬁed
by a program, then they are also satisﬁed by all stutterings of
its behaviour. If a Lustre program is stretch robust, then its
inputs can be safely slowed down without the risk of breaking
the constraint imposed by a stutter invariant property on the
program.
The theory of stability [8] considers programs whose out-
puts ﬂuctuate when their inputs are kept constant. Programs
which do not exhibit such a phenomenon are said to be stable;
when the inputs of these programs are unchanged, the outputs
will converge to stable values after a ﬁnite period of time.
The concept of stability relates to the concept of fast-enough
robustness. An input which has stopped changing is similar
to an input which is stuttering when considered over some
ﬁnite horizon of time. While the theory of stability requires the
output of a system to eventually converge to some particular
value, fast-enough robustness requires an output to converge
to an expected value before the sequence of repetitions ends.
Instead of checking whether a system exhibits certain
classes of behaviour when an environment changes, it is
possible to check whether a system degrades gracefully when
the environment misbehaves. In [9] the authors consider a
robustness approach in response to environments which fail to
obey the assumptions made during system design. A system
is said to be robust, if a small number of violations of
the environment assumptions causes only a small number of
violations of the system speciﬁcation.
It is also possible to use a probabilistic approach to under-
stand how changes in the environment are propagated through
the system’s components, and how the behaviour of these
components under changed or missing input contributes to
cause unacceptable system wide behaviour [10]. From our
perspective, the general approach is interesting because it can
help to isolate which components misbehave under slow input,
causing a complex system to fail.
VIII. CONCLUSIONS
Since input stutter can arise in various situations, especially
in systems which ﬁnely sample input, it is crucial that such
systems do not change their behaviour as such transformations
on their input occur. In this paper we have identiﬁed a number
of different levels of robustness with respect to slowdown
which one may require, and presented sound checks using
static analysis of the code or using symbolic veriﬁcation
techniques over the system’s behaviour.
Of these robustness properties, the most restrictive, stretch
robustness is highly compositional, and relaxing it to obtain
the weaker properties loses this compositionality property. Dy-
namic analysis allows for the analysis of programs on a global
level, at an increased computational cost. The two approaches
can, however, be combined, allowing for the analysis of more
complex programs.
One major restriction of our results is that we assume that all
the inputs of the system are slowed down by the same amount.
In practice, this may be too strong a restriction, for instance
with some nodes using a combination of external inputs and
streams coming from other nodes and which may have been
slowed down further. Another restriction is that we limit our
dynamic analysis techniques to Boolean Lustre programs or
circuits.
In the future, we plan to relax this constraint by using
control graph analysis techniques to programs with numeric
values, using approaches similar to [11].
REFERENCES
[1] P. Caspi, D. Pilaud, N. Halbwachs, and J. Plaice, “Lustre: a declara-
tive language for programming synchronous systems,” Proc. 14th ACM
SIGACT-SIGPLAN symposium on Principles of programming languages
(POPL ’87), ACM, Jan. 1987, pp. 178 - 188.
[2] C. Colombo, G. Pace, and G. Schneider, “Safe runtime veriﬁcation of real-
time properties,” Proc. 7th International Conference on Formal Modeling
and Analysis of Timed Systems (FORMATS ’09), Springer Verlag, Sep.
2009, pp.103–111.
[3] A. Gamati´e, Designing embdedded systems with the SIGNAL program-
ming language - synchronous reactive speciﬁcation. Springer, 2010.
[4] N. Halbwachs, P. Raymond, and C. Ratel, “Generating efﬁcient code from
data-ﬂow programs,” Proc. 3rd International Symposium on Programming
Language Implementation and Logic Programming (PLILP ’91), LNCS
528, Springer Verlag, Aug. 1991, pp. 207–218.
[5] L. Carloni, K. Mcmillan, and A. Sangiovanni-Vincentelli, “Theory of la-
tency insensitive design,” IEEE Transactions on Computer-Aided Design
of Integrated Circuits and Systems, vol. 20(9), Sep. 2001, pp.1059–1076.
[6] P. Le Guernic, J.-P. Talpin, and J.-C. Le Lann, “Polychrony for system
design,” Journal of Circuits, Systems and Computers, vol. 12(3), Jun.
2003, pp.261–304.
[7] D. Peled and T. Wilke, “Stutter-invariant temporal properties are express-
ible without the next-time operator,” Information Processing Letters, vol.
63(5), Sep. 1997 pp. 243–246.
[8] N. Halbwachs, J.-F. H´ery, J.-C. Laleuf, and X. Nicollin, “Stability of
discrete sampled systems,” Proc. 6th International Symposium on Formal
Techniques in Real-Time and Fault-Tollerant Systems (FTRTFT ’00),
Springer Verlag, London, Sep. 2000, pp.1-11.
[9] R. Bloem, K. Greimel, T. Henzinger, and B. Jobstmann, “Synthesizing
robust systems,” Proc. Formal Methods in Computer-Aided Design (FM-
CAD ’09), IEEE Computer Society, Nov. 2009, pp. 85–92.
[10] X. Ge, R. Paige, and J. McDermid, “Probabilistic failure propagation
and transformation analysis,” Proc. 28th International Conference on
Computer Safety, Reliability and Security (SAFECOMP ’09), LNCS
5775, Springer Verlag, Sep. 2009, pp. 215–228.
[11] B. Jeannet, N. Halbwachs, and P. Raymond, “Dynamic partitioning
in analyses of numerical properties,” Proc. Static Analysis Symposium
(SAS’99), LNCS 1694, Springer Verlag, Sep. 1999, pp. 39–50.
22
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-277-6
COMPUTATION TOOLS 2013 : The Fourth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

