Assessment of Data Storage Strategies Using the Mobile
Cross-Platform Tool Cordova
Gilles Callebaut, Lieven De Strycker
KU Leuven
DraMCo research group
Department of Electrical Engineering
Technology Campus Ghent, Gebroeders De Smetstraat 1
Email: firstname.lastname@kuleuven.be
Michiel Willocx, Vincent Naessens, Jan Vossaert
KU Leuven
MSEC, imec-DistriNet
Technology Campus Ghent, Gebroeders De Smetstraat 1
Email: firstname.lastname@cs.kuleuven.be
Abstract—The mobile world is fragmented by a variety of mobile
platforms, e.g., Android, iOS and Windows Phone. While native
applications can fully exploit the features of a particular mobile
platform, limited or no code can be shared between the different
implementations. Cross-platform tools (CPTs) allow developers
to target multiple platforms using a single codebase. These tools
provide general interfaces on top of the native APIs. Apart from
the performance impact, this additional layer may also result in
the suboptimal use of native APIs. This paper analyses the impact
of this abstraction layer using a data storage case study. Both
the performance overhead and API coverage is discussed. Based
on the analysis, an extension to the cross-platform storage API
is proposed and implemented.
Keywords–Cross-platform tools; data storage; performance anal-
ysis; API coverage; Apache Cordova/Phonegap.
I.
INTRODUCTION
An increasing number of service providers are making their
services available via the smartphone. Mobile applications are
used to attract new users and support existing users more
efﬁciently. Service providers want to reach as many users as
possible with their mobile services. However, making services
available on all mobile platforms is very costly due to the frag-
mentation of the mobile market. Developing native applications
for each platform drastically increases the development costs.
While native applications can fully exploit the features of a
particular mobile platform, limited or no code can be shared
between the different implementations. Each platform requires
dedicated tools and different programming languages (e.g.,
Objective-C, C# and Java). Also, maintenance (e.g., updates or
bug ﬁxes) can be very costly. Hence, application developers
are confronted with huge challenges. A promising alternative
are mobile cross-platform tools (CPTs). A signiﬁcant part of
the code base is shared between the implementations for the
different platforms. Further, many cross-platform tools such
as Cordova use client-side Web programming languages to
implement the application logic, supporting programmers with
a Web background.
Although several cross-platform tools became more mature
during the last few years, some scepticism towards CPTs
remains. For many developers, the limited access to native
device features (i.e. sensors and other platform APIs) remains
an obstacle. In many cases, the developer is forced to use a
limited set of the native APIs, or to use a work-around –which
often involves native code– to achieve the desired functionality.
This paper speciﬁcally tackles the use case of data storage APIs
in Cordova. Cordova is one of the most used CPTs [22, 23]. It
is a Web-to-native wrapper, allowing the developer to bundle
Web apps into standalone applications.
Contribution. The contribution of this paper is threefold.
First, four types of data storage strategies are distinguished in
the setting of mobile applications. The support for each strategy
using both native and Cordova development is analysed and
compared. Second, based on this analysis a new Cordova plugin
that extends the Cordova Storage API coverage is designed
and developed. Finally, the security and performance of the
different native and Cordova storage mechanisms is evaluated
for both the Android and iOS platform.
The remainder of this paper is structured as follows.
Section II points to related work. Section III discusses the inner
workings of Cordova applications, followed by an overview
of data storage strategies and their API coverage in Cordova
and native applications. The design and implementation of
NativeStorage, a new Cordova storage plugin, is presented in
Section IV. Section V presents a security and performance
evaluation of the Cordova and native storage mechanisms. The
ﬁnal section presents the conclusions and points to future work.
II.
RELATED WORK
Many studies compare CPTs based on a quantitative
assessment. For instance, R¨osler et al. [26] and Dalmasso et al.
[18] evaluate the behavioral performance of cross-platform
applications using parameters such as start-up time and memory
consumption. Willocx et al. [30] extend this research and
include more CPTs and criteria (e.g., CPU usage and battery
usage) in the comparison. Further, Ciman and Gaggi [17] focus
speciﬁcally on the energy consumption related to accessing
sensors in cross-platform mobile applications. These studies are
conducted using an implementation of the same application in
a set of cross-platform tools and with the native development
tools. This methodology provides useful insights in the overall
performance overhead of using CPTs. Other research focuses on
evaluating the performance of speciﬁc functional components.
For instance, Zhuang et al. [31] evaluate the performance of the
Cordova SQlite plugin for data storage. The work presented in
25
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-568-5
MOBILITY 2017 : The Seventh International Conference on Mobile Services, Resources, and Users

this paper generalizes this work by providing an overview and
performance analysis of the different data storage mechanisms
available in Cordova, and comparing the performance with
native components.
Several other studies focus on the evaluation of cross-
platform tools based on qualitative criteria. For instance,
Heitk¨otter et al.
[19] use criteria such as development
environment, maintainability, speed/cost of development and
user-perceived application performance. The user-perceived
performance is analyzed further in [20], based on user ratings
and comments on cross-platform apps in the Google Play Store.
The API coverage (e.g., geolocation and storage) of cross-
platform tools is discussed in [24]. It is complementary with
the work presented in this paper, which speciﬁcally focuses
on the API coverage, performance and security related to data
storage.
III.
DATA STORAGE IN CORDOVA
A. Cordova Framework
A typical Cordova application consists of three important
components: the application source, the WebView and plugins,
as depicted in Figure 1.
Figure 1. Structure of a Cordova application. Light grey arrows represent
JavaScript calls, darker grey arrows represent native calls. The Cordova
framework is illustrated by the grey area.
Cordova applications are, similar to Web apps, developed
in client-side Web languages (i.e. HTML, CSS and JavaScript).
Typically, developers use JavaScript frameworks such as Ionic
and Sencha, which facilitate the development of mobile-friendly
UIs.
The application code is loaded in a chromeless WebView.
By default, Cordova applications use the WebView bundled
with the operating system. An alternative is to include the
Crosswalk WebView [13]. The Crosswalk WebView provides
uniform behaviour and interfaces between different (versions
of) operating systems.
Cordova developers have two options for accessing device
resources: the HTML5 APIs provided by the WebView and
plugins. Despite the continuously growing HTML5 function-
ality [11] and the introduction of Progressive Web Apps [8],
the JavaScript APIs provided by the WebView are not –yet–
sufﬁcient for the majority of applications. They do not provide
full access to the diverse resources of the mobile device, such
as sensors (e.g., accelerometer, gyroscope) and functionality
provided by other applications installed on the device (e.g.,
contacts, maps, Facebook login). Plugins allow JavaScript code
to access native APIs by using a JavaScript bridge between the
Web code and the underlying operating system. Plugins consist
of both JavaScript code and native code (i.e. Java for Android,
Objective-C and recently Swift for iOS). The JavaScript code
provides the interface to the developer. The native source code
implements the functionality of the plugin and is compiled when
building the application. The Cordova framework provides
the JavaScript bridge that enables communication between
JavaScript and native components. For each platform, Cordova
supports several bridging mechansims. At runtime, Cordova
selects a bridging mechanism. When an error occurs, it switches
to another mechanism. Independent of the selected bridging
mechanism, the data requires several conversion steps before
and after crossing the bridge. Commonly used functionality such
as GPS are provided by Cordova as core plugins. Additional
functionality is provided by over 1000 third-party plugins,
which are freely available in the Cordova plugin store [12].
B. Storage API Coverage
This work focuses on data storage mechanisms in Cor-
dova applications. Four types of data storage strategies are
distinguished: ﬁles, databases, persistent variables and sensitive
data. Databases are used to store multiple objects of the same
structure. Besides data storage, databases also provide methods
to conveniently search and manipulate records. File storage can
be used to store a diverse set of information such as audio, video
and binary data. Persistent variables are stored as key-value
pairs. It is often used to store settings and preferences. Sensitive
data (e.g., passwords, keys, certiﬁcates) are typically handled
separately from other types of data. Mobile operating systems
provide dedicated mechanisms that increase the security of
sensitive data storage.
The remainder of this section discusses the storage APIs
available in Cordova and native Android/iOS. A summary of
the results is shown in Table I.
TABLE I. STORAGE API COVERAGE
Cordova
Android
iOS
Databases
WebSQL
SQLite
SQLite
IndexedDB
SQLite Plugin
Files
Cordova File Plugin
java.io
NSData
Persistent Variables
LocalStorage
Shared Prefs
NSUserDefaults
Property Lists
Sensitive Data
SecureStorage Plugin
KeyStore
Keychain
KeyChain
1) Databases: Android and iOS provide a native interface
for the SQLite library. Cordova supports several mechanisms
to access database functionality from the application. First,
the developer can use the database interface provided by
the WebView. Both the native and CrossWalk WebViews
provide two types of database APIs: WebSQL and IndexedDB.
26
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-568-5
MOBILITY 2017 : The Seventh International Conference on Mobile Services, Resources, and Users

Although WebSQL is still commonly used, it is ofﬁcially
deprecated and thus no longer actively supported [10]. Second,
developers can access the native database APIs via the SQLite
Plugin [6].
2) Files: In Android, the ﬁle storage API is provided by the
java.io package, in iOS this is included in NSData. Cordova
provides a core plugin for File operation, namely Cordova
File Plugin (cordova-plugin-ﬁle) [4]. Files are referenced via
URLs which support using platform-independent references
such as application folder.
3) Persistent Variables: In Android, storing and accessing
persistent variables is supported via SharedPreferences. It
allows developers to store primitive data types (e.g., booleans,
integers, strings). iOS developers have two options to store
persistent variables: NSUserDefaults and Property Lists.
NSUserDefaults has a similar behaviour to SharedPreferences
in Android. Property Lists offer more ﬂexibility by allowing
storage of more complex data structures and speciﬁcation of the
storage location. Cordova applications can use the LocalStor-
age API provided by the Android and iOS WebView. Although
it provides a simple API, developers should be aware of several
disadvantages. First, LocalStorage only supports storage of
strings. More complex data structures need to be serialized
and deserialized by the developer. Second, LocalStorage is
known [1] to perform poorly on large data sets and has a
maximum storage capacity of 5MB.
4) Sensitive Data: Android provides two mechanisms to
store credentials: the KeyChain and the KeyStore. A KeyStore
is bound to one speciﬁc application. Applications can not
access credentials in KeyStores bound to other applications.
If credentials need to be shared between applications, the
KeyChain should be used. The user is asked for permission
when an application attempts to access credentials in the
KeyChain. Credential storage on iOS is provided by the
Keychain. Credentials added to the Keychain are, by default,
app private, but can be shared between applications from the
same publisher. Cordova developers can use the credential
storage mechanisms provided by Android and iOS via the
SecureStorage (cordova-plugin-secure-storage) [7] plugin.
IV.
NATIVESTORAGE PLUGIN
An important limitation of using HTML5 APIs (e.g.,
IndexedDB and LocalStorage) to store data in Cordova applica-
tions is that both on Android and iOS the cache of the WebView
can be cleared when, for instance, the system is low on memory.
This section presents NativeStorage, a Cordova plugin for
persistent data object storage, mitigating the limitations of
the HTML5 storage mechanisms.
A. Requirements
The requirements of the plugin are listed below:
R1
Persistent and sufﬁcient storage
R2
Storage of both primitive data types and objects
R3
Support for Android and iOS
R4
App private storage
R5
Responsive APIs
R6
A user-friendly API
1 // coarse grained API
2 NativeStorage.setItem("reference_to_value",<value>,
<success-callback>, <error-callback>);
3 NativeStorage.getItem("reference_to_value",<success-
callback>, <error-callback>);
4 NativeStorage.remove("reference_to_value",<success-
callback>, <error-callback>);
5 NativeStorage.clear(<success-callback>, <error-
callback>);
Listing 1. NativeStorage – Coarse-grained API
1 // fine grained API
2 NativeStorage.put<type>("reference_to_value",<value>,
<success-callback>, <error-callback>);
3 NativeStorage.get<type>("reference_to_value",<
success-callback>, <error-callback>);
4 NativeStorage.remove("reference_to_value",<success-
callback>, <error-callback>);
Listing 2. NativeStorage – Fine-grained API
B. Realisation
The plugin consist of JavaScript and native code. The
JavaScript API provides the interface to application developers.
The native side handles the storage of variables using native
platform APIs.
NativeStorage provides two sets of JavaScript APIs, a ﬁne-
grained and a coarse-grained API, which are both asynchronous
and non-blocking. The coarse grained API (Figure 2a) provides
a type-independent interface, variables are automatically con-
verted to JSON objects via the JSON interfaces provided by the
WebView and passed as string variables to the native side. When
a value is retrieved, the WebView is used to convert the string
back to an object. The ﬁne-grained API (Figure 2b) provides a
separate implementation for the different JavaScript types. On
the native side, the variables are stored via SharedPreferences
in Android and NSUserDefaults in iOS.
Object
Object
Disk
Web App
Plugin
JSON
string
JSON
string
Object
Object
(a) Coarse-grained API
Boolean
Boolean
Disk
Web App
Plugin
Boolean
Boolean
(b) Fine-grained API
Figure 2. NativeStorage API
27
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-568-5
MOBILITY 2017 : The Seventh International Conference on Mobile Services, Resources, and Users

C. Evaluation
The plugin is evaluated based on the previously listed
requirements.
Persistent storage is provided via the native storage mech-
anisms. The documentation of the used native mechanisms
doesn’t state a limitation on the storage capacity. Hence, as
opposed to LocalStorage, the storage capacity is only limited
by the available memory on the device, satisfying R1.
The native part of the plugin is developed for both Android
and iOS. These mobile operating systems have a combined
market share of 99% [15]. The used native storage mechanisms
were introducted in iOS 2.0 and Android 1.0. The plugin, hence,
provides support for virtually all version of these platforms
used in practice, satisfying R3.
The plugin uses NSUserdefaults and SharedPreferences
to store the data in app-private locations, ensuring that the
variables can not be accessed from outside the application.
This satisﬁes R4.
The APIs are implemented using an asynchronous non-
blocking strategy, facilitating the development of responsive
applications (conform R5).
Web developers are familiar with duck typing used in
languages such as JavaScript. These types of languages often
have APIs that don’t distinguish between data types. The coarse-
grained API provides such a storage mechanism. This API is
shown in Listing 6. Not all Cordova developers, however, have
a Web background. Therefore, a ﬁne-grained API (Listing 5)
is provided for developers who are more comfortable with a
statically typed language, satisfying R6 and R2. Using both
the coarse- and ﬁne-grained API, the different JavaScript data
types can be stored. Developers, however, need to be aware
that the object storage relies on the JSON interface of the
WebView to convert the object to a JSON string representation.
The WebView, for instance, does not support the conversion of
circular data structures. These types of objects, hence, need to
be serialized by the developer before they can be stored.
Since its release to Github [16] and NPM [5] the plugin has
been adopted by many Cordova application developers. We’ve
registered over 4000 downloads per month. Furthermore, the
plugin is part of the 4% most downloaded packages on NPM.
The plugin has been adopted in Ionic Native (Ionic 2) [3] and
the Telerik plugin marketplace [9]. Telerik veriﬁes that plugins
are maintained and documented, thereby ensuring a certain
quality.
V.
EVALUATION
The evaluation of the data storage mechanisms consists of
two parts: a quantitative performance analysis and a security
evaluation.
A. Performance
Developers want to be aware of the potential performance
impact of using a CPT for mobile app development [21].
This section evaluates the performance of the different storage
mechanisms for Cordova applications and compares the results
with the native alternatives. Each storage strategy is tested by
deploying a simple native and Cordova test application that
intensively uses the selected storage strategy on an Android
and iOS device. For Android the Nexus 6 running Android 6
was used, for iOS the IPhone 6 running iOS 9 was used. The
test application communicates the test results via timing logs
that are captured via Xcode for iOS and Android Studio for
Android. The experiments were run sufﬁcient times to ensure
the measurements adequately reﬂect the performance of the
tested storage mechanisms.
1) Databases:
a) Test Application: The database test application ex-
ecutes 300 basic CRUD operations (i.e. 100 x create, 100 x
read, 50 x delete and 50 x read) of objects containing two
string variables. The performance is determined by means of
measuring the total duration of all the transactions. This test has
been executed using the SQLite (native and Cordova), WebSQL
(Cordova) and IndexedDB (Cordova) mechanisms.
b) Results and Comparison: The results are presented
in Table II. The mechanism for retrieving values by means of
an index clearly results in a better performance compared to the
SQL-based mechanisms. This analysis shows that IndexedDB
provides an efﬁcient way of storing and retrieving small
objects. WebSQL –provided by the WebView– acts as a
wrapper around SQLite. This is illustrated by the performance
overhead associated with this mechanism. The deprecation of
the speciﬁcation/development stop could also have contributed
to the performance penalty. The SQLite plugin suffers from
a performance overhead caused by the interposition of the
Cordova framework/bridge and has consequently a noticeable
performance overhead. The performance overhead introduced
by the Cordova bridge is discussed in more detail in the
following section.
TABLE II. RATIO OF DATABASE EXECUTION TIME TO THE NATIVE (SQLITE)
OPERATION DURATION (IN %). *IN IOS INDEXEDDB IS ONLY SUPPORTED
AS OF IOS 10.
Android
iOS
Nexus 6
iPhone 6
SQLite (Native)
100
100
IndexedDB
6.94
12.47*
WebSQL
153
128
SQLite Plugin
133
116
2) Files:
a) Test Application: The test application distinguishes
between read and write operations. Each operation is tested
using different ﬁle sizes, ranging from small ﬁles (∼ 1 kB) to
larger ﬁles (∼ 10 MB). The performance of small ﬁles provides
a baseline for ﬁle access. The performance of the read and
write operations itself can be determined via the results of the
large ﬁles. This test has been conducted ten times for each ﬁle
size. The read and write operations consist of different steps on
Android and iOS. Both the duration of the individual steps and
the entire operation (i.e. read/write) is measured via timestamps.
The application’s memory footprint is measured via Instruments
tool (Activity Monitor) in Xcode and via Memory Monitor in
Android Studio.
28
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-568-5
MOBILITY 2017 : The Seventh International Conference on Mobile Services, Resources, and Users

b) Results and Comparison: The results of the timing
analysis on Android and iOS is presented in Figure 3 and 4,
respectively. In both Android and iOS a signiﬁcant performance
difference between the native and the Cordova mechanism
can be observed. R/W operations via the ﬁle plugin take
longer compared to the native mechanisms. On top of a
performance overhead, Cordova also comes with a higher
memory consumption, especially in iOS (Figure 5).
0
5
10
15
20
0
1,000
2,000
3,000
4,000
Filesize [MB]
Operation duration [ms]
Native Write
Native Read
Cordova Write
Cordova Read
Figure 3. Duration of ﬁle operations in Android
0
1
2
3
4
5
6
7
8
9
10
0
1,000
2,000
3,000
4,000
Filesize [MB]
Operation duration [ms]
Native Write
Native Read
Cordova Write
Cordova Read
Figure 4. Duration of ﬁle operations in iOS
Speed. Tables III and IV give a ﬁne-grained overview of
the different operations executed during respectively a ﬁle read
and write using the Cordova platform on Android. Tables V
and VI provide the results for iOS. Before data can be sent
over the Cordova bridge, it needs to be converted to a string.
This can create signiﬁcant overhead when large binary ﬁles
such as images needs to be manipulated. Before they are sent
over the bridge, the binary data is converted to a Base64 string.
On Android, this is illustrated in the Processing ﬁle component
of Table IV. Sending the data over the bridge also comprises
a signiﬁcant part of the overhead (i.e. Sending over bridge,
from Table III). For small ﬁles, the overhead originates for the
most part from resolving the platform-independent URL to a
local path and retrieving meta-data. Similar observations can
be made based on the iOS results.
TABLE III. EXECUTION TIME OF COMPONENTS ASSOCIATED WITH A READ
OPERATION IN CORDOVA ANDROID (FILE PLUGIN). THE PROCEDURE
”SENDING OVER BRIDGE” CONSISTS OF ENCODING, SENDING AND
DECODING MESSAGES FROM THE JAVASCRIPT SIDE TO THE NATIVE SIDE.
Component
Duration [1 MB]
Duration [20 MB]
(ms)
(% total)
(ms)
(% total)
Resolve to local URL
58
46
59
7.56
Native reading
20
16
366
47
Sending over bridge
28
22
339
43
Total
126
780
TABLE IV. EXECUTION TIME OF COMPONENTS ASSOCIATED WITH A WRITE
OPERATION IN CORDOVA ANDROID (FILE PLUGIN). THE PROCEDURE
”PROCESSING FILE” CONVERTS THE BYTES –AS AN ARRAYBUFFER– TO A
STRING ARRAY. THE ”EXECUTE CALL DELAY” REPRESENTS THE DELAY
BETWEEN THE WRITE COMMAND EXECUTED IN JAVASCRIPT AND THE
EXECUTION AT THE NATIVE SIDE.
Component
Duration [1 MB]
Duration [20 MB]
(ms)
(% total)
(ms)
(% total)
Processing ﬁle
108
65
1290
56
Execute call delay
38
23
632
28
Writing
20
12
369
16
Total
166
2291
Memory. In iOS, applications manipulating large ﬁles will
require large amounts of memory. This is illustrated in Figure 5.
As shown, reading and writing a 10 MB ﬁle results in 400 MB
of allocated memory. Reading and writing ﬁles larger than
10 MB can result in unstable behavior on iOS due to the large
memory requirements. A solution for developers is to split
large ﬁle operations in different steps.
0
1
2
3
4
5
6
7
8
9
10
0
100
200
300
400
Filesize [MB]
Memory consumption [MB]
Native
Cordova
Figure 5. Memory consumption as a result of ﬁle operations in iOS
c) Conclusion: File storage on Apache Cordova comes
with a number of limitation in terms of performance. This is a
result of the Cordova framework/bridge technology. Allowing
binary data to pass over the Cordova bridge could signiﬁcantly
improve the performance of plugins that perform operations
on binary data. For instance, in [25] an bridging technology is
29
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-568-5
MOBILITY 2017 : The Seventh International Conference on Mobile Services, Resources, and Users

TABLE V. PERFORMANCE READ COMPONENTS IN CORDOVA IOS
Component
Duration [1 MB]
Duration [10 MB]
(ms)
(% total)
(ms)
(% total)
Resolve to local URL
11
3.56
16
0.6
Native reading
13.98
4.52
70
2.47
Arguments to JSONArray
202.77
65.62
2037.93
71.88
Sending over bridge
59.93
19.39
587.19
20.71
Total
309
2835
TABLE VI. PERFORMANCE WRITE COMPONENTS IN CORDOVA IOS
Component
Duration [1 MB]
Duration [10 MB]
(ms)
(% total)
(ms)
(% total)
Processing ﬁle
266
97
2614
96
Native writing
7
3
96
4
Total
273
2710
presented that allows access to native device APIs in HTML5
applications via WebSockets and HTTP servers, supporting the
use of binary data.
3) Persistent variables:
a) Test Application: The performance is examined via
storing and retrieving string values. The total duration of storing
and retrieving a thousand variables is measured. The average
storage and retrieval time is used to compare the different stor-
age mechanisms. The Cordova mechanisms are LocalStorage
and NativeStorage. These are compared to NSUserDefaults
(iOS), Property Lists (iOS) and SharedPreferences (Android).
b) Results and Comparison: All mechanisms have an
execution time under 1 ms, with the exception of NativeStorage
and Property Lists. The set operation takes around 1.9 ms, the
get operation takes less than 1 ms. NativeStorage is the only
mechanism which uses the Cordova bridge and framework,
introducing a certain overhead. However, the NativeStorage
API is asynchronous, hence, developers can continue processing
while the value is being stored. The listed measurements include
the time until the callback is ﬁred. Property Lists load an entire
ﬁle in an array, after which individual parameters can be read.
As a consequence, the performance of the get operation, which
takes 9.83 ms, is worse compared to the native alternatives.
SharedPreferences and NSUserDefaults also load all parameters
in memory, but this is done during the initialisation phase of
the application, which is not incorporated in the measurements.
B. Security
On both Android and iOS the security of storage mech-
anisms strongly depends on the storage location and the
platform’s backup mechanisms. Data stored inside the sandbox
of the application is only accessible by the application. However,
the backup mechanisms used in iOS and Android can result
in the exposure of sensitive data [27, 29, 28], or potentially
exhausting the limited cloud storage capacity. On iOS, this
can result in the rejection of the application (conform the Data
Storage Guidelines [14]). On Android, data stored inside the
application sandbox (e.g., the WebView’s storage) is included if
a backup is taken. The Backup API of Android can be used to
explicitly blacklist data that should not be backed up. On iOS,
whether or not a ﬁle is included in the backup depends on the
folder in which it is stored. For instance, by default, Cordova
stores the WebView’s data in a folder that allows backups. This
behavior can, however, be changed by modifying a Cordova
parameter.
1) Databases: All database mechanisms are by default
private to the application and can be backed up on both mobile
platforms, with the exception of the SQLite plugin in iOS.
The plugin initially followed the default behaviour, but as a
security measure the default storage location of the plugin in
iOS was changed to a directory which is not backed up. This
SQLite plugin also has an encrypted alternative, i.e. cordova-
sqlcipher-adapter. This alternative provides a native interface
to SQLCipher, encrypting SQLite databases via a user-supplied
password.
2) Files: In iOS ﬁles are protected by a protection class.
Each of these classes corresponds to different security properties.
As of iOS 7, all ﬁles are by default encrypted individually until
ﬁrst user authentication. The ﬁle plugin doesn’t allow changing
this default behaviour. Native, each ﬁle can be secured using a
protection class best suited for the security requirements of that
ﬁle. The plugin allows the developer to choose between folders
that are public/private and backup-enabled/disabled. However,
on Android backup-disabled locations can be accessed by other
applications.
3) Persistent variables: All persistent variable storage
mechanisms are private to the application and included in
backups on both mobile platforms, with the exception of
Property List. Property lists can be stored in arbitrary locations,
and can be backed up depending on the speciﬁed location.
4) Sensitive Data: The Secure Storage plugin provides
storage of sensitive data on Android and iOS. On iOS, the
plugin uses the SAMKeychain [2] plugin which provides an
API for the native iOS Keychain. The plugin allows app-global
static conﬁguration of the KeyChain items’ accessibility. This
could entail a security risk, as it does not allow ﬁne-grained
protection of individual items. When a user backs up iPhone
data, the Keychain data is backed up but the secrets in the
Keychain remain encrypted with a phone-speciﬁc key in the
backup. The Android KeyChain only allows storage of private
keys. Hence, for storing other tokens such as passwords or
JWT tokens, an additional encryption layer is used. The plugin
generates a key that is stored in the KeyChain and used to
encrypt/decrypt sensitive data. The KeyChain on Android is
not included in backups.
VI.
CONCLUSIONS
This paper presented an assessment of data storage strategies
using the mobile cross-platform tool Cordova. An in-depth
analysis was performed on the API coverage of the available
data storage mechanisms in Cordova and Native applications.
Based on the analysis, an additional Cordova storage plugin
was developed that improves the storage of persistent variables.
Furthermore, the performance and security of the available
storage mechanisms were evaluated. Our performance analysis
30
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-568-5
MOBILITY 2017 : The Seventh International Conference on Mobile Services, Resources, and Users

shows that using the Cordova bridge comes with a signiﬁcant
performance penalty. Hence, the WebView’s JavaScript API
should be used when possible. However, apart from perfor-
mance, other parameters such as functionality and security can
have an impact on the selection of the storage mechanism.
Databases. If access to a full ﬂedged SQL database is
required, the SQLite plugin should be used. However, in
most mobile applications, the functionality provided by the
signiﬁcantly faster IndexedDB interface of the WebView is
sufﬁcient.
Variables. As described in Sections IV and V, it is
recommended to use NativeStorage for storing persistent
variables, since LocalStorage does not guarantee persistence
over longer periods of time. This type of storage is often used
to store preferences. Preferences are typically only accessed
once or twice during the life cycle of the application. Hence,
the performance overhead of NativeStorage does not have a
signiﬁcant impact on de performance of the application.
Files. The WebView does not provide a ﬁle storage API.
Hence, developers have to use the core plugin, Cordova File
Plugin (cordova-plugin-file).
Sensitive data. The security analysis presented in Sec-
tion V-B shows that plugins such as SecureStorage offer
increased security compared to the WebView’s JavaScript API
because they beneﬁt from the platform’s native secure storage
APIs. It is therefore recommended to use a plugin such as
SecureStorage to store sensitive data.
Future work on this topic can include an in-depth analysis of
the CrossWalk WebView. Currently, Cordova applications suffer
from a major performance penalty every time the JavaScript
bridge is accessed. CrossWalk has its own plugin mechanism,
which could show better performance than Cordova plugins.
REFERENCES
[1] Cordova storage documentation.
URL https://cordova.
apache.org/docs/en/latest/cordova/storage/storage.html.
[2] Samkeychain. URL https://github.com/soffes/SSKeychain.
[3] Nativestorage in the ionic framework documentation. URL
http://ionicframework.com/docs/v2/native/nativestorage/.
[4] Cordova ﬁle plugin npm website, . URL https://www.
npmjs.com/package/cordova-plugin-ﬁle.
[5] Nativestorage plugin npm website, . URL https://www.
npmjs.com/package/cordova-plugin-nativestorage.
[6] Sqlite plugin npm website, . URL https://www.npmjs.
com/package/cordova-sqlite-storage.
[7] Securestorage plugin npm website, . URL https://www.
npmjs.com/package/cordova-plugin-secure-storage.
[8] Progressive web apps.
URL https://developers.google.
com/web/progressive-web-apps/.
[9] Cordova plugins in the telerik marketplace. URL http:
//plugins.telerik.com/cordova.
[10] Web sql database documentation. URL https://dev.w3.org/
html5/webdatabase/.
[11] Can i use ... ? URL http://caniuse.com/.
[12] Cordova plugins website. URL https://cordova.apache.
org/plugins/.
[13] Crosswalk website. URL https://crosswalk-project.org.
[14] ios data storage guidelines. URL https://developer.apple.
com/icloud/documentation/data-storage/index.html.
[15] Smartphone os market share, q2 2016.
http://www.
idc.com/prodserv/smartphone-os-market-share.jsp, 2015.
access date: 20/10/2016.
[16] Cordova plugin nativestorage, 2016. URL https://github.
com/TheCocoaProject/cordova-plugin-nativestorage.
[17] Matteo Ciman and Ombretta Gaggi. Evaluating impact
of cross-platform frameworks in energy consumption of
mobile applications.
In WEBIST (1), pages 423–431,
2014.
[18] Isabelle Dalmasso, Soumya Kanti Datta, Christian Bonnet,
and Navid Nikaein. Survey, comparison and evaluation
of cross platform mobile application development tools.
In Wireless Communications and Mobile Computing
Conference (IWCMC), 2013 9th International, pages 323–
328. IEEE, 2013.
[19] Henning Heitk¨otter, Sebastian Hanschke, and Tim A
Majchrzak. Evaluating cross-platform development ap-
proaches for mobile applications. In International Con-
ference on Web Information Systems and Technologies,
pages 120–138. Springer, 2012.
[20] Ivano Malavolta, Stefano Ruberto, Tommaso Soru, and
Valerio Terragni. End users’ perception of hybrid mobile
apps in the google play store. In 2015 IEEE International
Conference on Mobile Services, pages 25–32. IEEE, 2015.
[21] Vision Mobile.
Cross-platform developer tools 2012,
bridging the worlds of mobile apps and the web, 2012.
access date: 13/04/2016.
[22] Vision Mobile. Cross-platform tools 2015, 2015. URL
http://www.visionmobile.com/product/cross-platform-
tools-2015/. access date: 13/04/2016.
[23] Vision
Mobile.
Developer
economics
state
of
the
developer
nation
q1
2016,
2016.
URL
http://www.visionmobile.com/product/developer-
economics-state-of-developer-nation-q1-2016/.
access
date: 13/04/2016.
[24] Manuel Palmieri, Inderjeet Singh, and Antonio Cicchetti.
Comparison of cross-platform mobile development tools.
In Intelligence in Next Generation Networks (ICIN), 2012
16th International Conference on, pages 179–186. IEEE,
2012.
[25] Arno Puder, Nikolai Tillmann, and MichałMoskal. Ex-
posing native device apis to web apps. In Proceedings
of the 1st International Conference on Mobile Software
Engineering and Systems, MOBILESoft 2014, pages 18–
26, New York, NY, USA, 2014. ACM.
ISBN 978-
1-4503-2878-4. doi: 10.1145/2593902.2593908. URL
http://doi.acm.org/10.1145/2593902.2593908.
[26] Florian R¨osler, Andr´e Nitze, and Andreas Schmietendorf.
Towards a mobile application performance benchmark. In
International Conference on Internet and Web Applica-
tions and Services, volume 9, pages 55–59, 2014.
[27] Peter Teuﬂ, Thomas Zefferer, and Christof Stromberger.
Mobile device encryption systems. In 28th IFIP TC-11
SEC 2013 International Information Security and Privacy
Conference, pages 203 – 216, 2013.
[28] Peter Teuﬂ, Thomas Zefferer, Christof Stromberger, and
Christoph Hechenblaikner.
ios encryption systems -
deploying ios devices in security-critical environments. In
SECRYPT, pages 170 – 182, 2013.
[29] Peter Teuﬂ, Andreas Gregor Fitzek, Daniel Hein, Alexan-
der Marsalek, Alexander Oprisnik, and Thomas Zefferer.
Android encryption systems. In International Conference
31
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-568-5
MOBILITY 2017 : The Seventh International Conference on Mobile Services, Resources, and Users

on Privacy & Security in Mobile Systems, 2014. in press.
[30] Michiel Willocx, Jan Vossaert, and Vincent Naessens.
Comparing performance parameters of mobile app devel-
opment strategies. In Proceedings of the International
Workshop on Mobile Software Engineering and Systems,
pages 38–47. ACM, 2016.
[31] Yanyan Zhuang, Jennifer Baldwin, Laura Antunna, Ya-
giz Onat Yazir, Sudhakar Ganti, and Yvonne Coady.
Tradeoffs in cross platform solutions for mobile assistive
technology. In Communications, Computers and Signal
Processing (PACRIM), 2013 IEEE Paciﬁc Rim Conference
on, pages 330–335. IEEE, 2013.
32
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-568-5
MOBILITY 2017 : The Seventh International Conference on Mobile Services, Resources, and Users

