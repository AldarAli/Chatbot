A Zone-based Reachability Analysis of Variable
Driven Timed Automata
Omer Nguena-Timo
University of Bordeaux (LaBRI - CNRS)
Talence, France
nguena@labri.fr
Antoine Rollet
University of Bordeaux (LaBRI - CNRS)
Talence, France
rollet@labri.fr
Abstract—In this paper, we propose an algorithm for efﬁ-
cient reachability analysis of Variable Driven Timed Automata
(VDTA). VDTA is a new timed behavioural model for data-ﬂow
reactive systems in which inputs and outputs are modelled by
variables. Such an approach is commonly used in the indus-
try. Reachability analysis is often the basis of model-checking,
test generation (especially Test Purpose approach), or control
algorithms. For example, a model-based testing framework with
VDTA derives test cases by performing a region-based reachabil-
ity analysis. Thus, an efﬁcient analysis is needed. We propose an
algorithm based on the zone abstraction. The algorithm not only
checks the reachability, but it also computes timed sequences of
input updates required to reach a target. In practice, it is more
efﬁcient than region based one.
Keywords-reachability analysis, zone, timed systems, data-ﬂow,
urgent edges.
I. INTRODUCTION
In the context of reliable systems design, formal methods
provide a rigorous framework for modelling and reasoning
about the systems. Formal reasoning includes methods for test-
ing [15], model-checking [9], supervising [14], etc., the sys-
tems, which are commonly and efﬁciently modelled in a state-
transition/automata formalism in which systems behaviours are
represented by sequences of (constrained/guarded) transitions
between states. Reachability analysis amounts to checking
whether a target state is reachable from an initial one. A target
state may represent a failure of the system that may cause
considerable damages. Reachability analysis is often involved
in many validation methods. For example, the generation of
test cases with test purposes usually consists in analysing the
reachability of certain states and to compute the sequence of
actions permitting to reach them. The paper presents a new
efﬁcient algorithm for the reachability analysis of Variable
Driven Timed Automata [12].
A. Variable Driven Timed Automata (VDTA)
VDTA [12] is a new timed model adapted for modelling and
reasoning about data-ﬂow reactive systems in which input and
output are rather modelled by variables. A VDTA model-based
testing framework has been developed in [11], [13].
A VDTA is a guarded edge (transition) system in which
every edge is labelled with an update of output variables and
a constraint on input, output and clock variables. VDTA is
inspired by urgent timed input/ouput automata [2], [3]. VDTA
implements three main mechanisms. The ﬁrst mechanism,
which is not new, implemented in VDTA is urgent edges. As
with urgent timed automata [3], edges in VDTA are urgent
meaning that they are ﬁred as soon as their constraints become
true. Only output variable updates are performed on edges
ﬁrings. It is well-known [3] that urgency mechanism may
allow short and clear speciﬁcation. Secondly, VDTA imple-
ments the variable based communication mechanism. This
supposes that systems communicate with their environment
through input and output variables or sockets. This is closer
to how engineers think and how open systems are speciﬁed.
The VDTA model assumes that the environment freely updates
the input variables and only the systems can update the output
variables according to their states and timing information given
by clock variables. VDTA allows to specify explicitly the
events to the environment only. Unlike [2], [3], [8], the events
from the environment are not explicitly speciﬁed. Thirdly,
VDTA is a variable driven model. Edges ﬁrings in VDTA
do not depend on occurences of synchronizing actions but
rather on the truth value of constraints only. The values
of the variables are persistent and they last until they are
updated. Consequently, a single input variable change can
trigger instantaneously a chain of consecutive edges in VDTA.
This is not the case with event-based formalisms like [3], [8]
where each edge ﬁring is provoked by an occurrence of a (non
persistent) synchronising action.
The VDTA-based testing method [11], [13] is based on
test purposes. Test purposes are VDTA with special states
labelled with ACCEPT; they allow to guide the test selection.
Roughly speaking, the method consists of two main steps: (1)
a test graph is constructed from the speciﬁcation and a test
purpose and then (2) the reachability of the states labelled with
ACCEPT is checked. A VDTA reachability analysis algorithm
is proposed in [11]. This algorithm is inspired by a seminal
reachability algorithm for timed automata [2]. It uses the
symbolic region [2] representation of the time, which allows
elegant reasoning on timed systems. Since it is a precise
discrete representation of clock valuations, it allows to abstract
a timed model into a discrete model making thus easier
the analysis of urgent edge and unspeciﬁed input updates in
VDTA. In the backside, region abstraction is expensive. As for
the analysis of timed automata [4], [7], we wondered how the
symbolic zone abstraction could be used for the reachability
51
VALID 2011 : The Third International Conference on Advances in System Testing and Validation Lifecycle
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-168-7

analysis of VDTA. Roughly speaking, zones are larger abstrac-
tions of clock valuations: one zone can be decomposed into
an equivalent ﬁnite set of regions. Thus a single computation
over a zone may need many computations over the regions
it includes. Consequently, the region abstraction is in practice
less efﬁcient than the zone abstraction [2], [6]. So, providing
an efﬁcient zone-based analysis for VDTA will improve the
VDTA test generation algorithm [11], [13].
B. Contributions
We propose a backward zone-based reachability analysis
algorithm for VDTA. The general idea is presented in Algo-
rithm 1. Contrary to the forward one, it starts in the target
states P0 and iteratively visits predecessors of states until
a ﬁxpoint is reached and no new states is computed. P0 is
reachable if the ﬁxpoint include the initial state.
Algorithm 1 Principle of the Backward Analysis
P0 ← P
repeat
Pi+1 ← Pi ∪ Predecessor(Pi)
until Pi+1 equal to Pi
The predecessors of a state of a VDTA include its input
updates predecessors, output updates predecessors and time
predecessors. To ensure its termination, our algorithm rather
works on symbolic states. Input, output and clock values are
represented by zones in symbolic states. A similar method is
used for timed automata [2], [3], [5], [7]. But the zone-based
backward reachability analysis for VDTA could not be a
simple adaptation of the zone-based reachability of timed
automata. Besides, we found that the analysis of VDTA
has many common points with the analysis of timed game
automata (TGA)
[6]. But TGA analysis algorithm cannot
work for VDTA. Nevertheless, as for the analysis of TGA
we consider a notion of safe time predecessor in order to
compute predecessors of symbolic states.
C. Outline
Section II presents the VDTA model and its semantics. In
Section III we deﬁne symbolic states and the computation of
their predecessors. At the end of the section we present the
reachability algorithm and we discuss about its termination.
Section IV concludes the paper giving future works with
VDTA.
II. VARIABLE DRIVEN TIMED AUTOMATA (VDTA)
Before we provide a formal deﬁnition for VDTA, we
consider the following speciﬁcation of the control program
designed to start a “two buttons machine” [10]:
The machine starts when two buttons (L and R for left and
right buttons) are pushed within 1 time unit. If only one button
is pushed (then L or R is true) and a delay of greater than 1
time unit is performed (time-out has occurred), then the whole
process must be started again. After the machine has started
ℓ0
ℓ1
?LR; x := 0
ℓ2
t ≤ 1;?LR
ℓ3
ℓ4
ℓ5
ℓ6
?LR; t := 0
?LR; t := 0
t ≤ 1;?LR; x := 0
t > 1; !timeout
x = 0; !S
?LR; x := 0
?LR; x := 0
?LR; x := 0
x = 0; !S
?LR
x = 0;!S
(a) TIOA model for the two buttons machine.
ℓ0
ℓ1
ℓ2
ℓ3
L = 0 ∧ R = 0
L = 1 ∨ R = 1
t := 0
L = 0 ∧ R = 0 ∧ t ≤ 1
L = 1 ∧ R = 1 ∧ t ≤ 1
s := 1
L = 0 ∨ R = 0
s := 0
t > 1
(b) VDTA for the two buttons machine.
Fig. 1.
Event-based Vs variable-Based Model
(S=1), it stops as soon as one button is released, and it can
start again only after both buttons have been released (L and
R are both false).
The VDTA in Figure 1(b) is clearer and shorter than the
Timed Input Output Automata (TIOA) in Figure 1(a). The
TIOA has 4 input events (LR, LR, LR, LR where L/ L
mean that the left button is pushed/released), 2 output events
(S, S) and 2 clocks (x, t) whereas the VDTA model has 2
boolean input variables(L and R), 1 boolean output variable
(S), and a unique real-valued clock variable (t). The TIOA
assumed that in every state the program may receive (denoted
by the symbol “?”) an event that corresponds to a combination
of values of L and R before leaving the state. More generally,
if there are n buttons (variables) all in domains of size m,
one may consider up to nm outgoing edges for each location.
This explosion can be reduced using a variable-based mod-
elling approach. The main idea is to hide the synchronisation
(between the environment and the system) that happens on
variable updates and to concentrate on the functional behaviour
of the system that depends on constraints. Even if there is
not an explicit edge from ℓ0 to ℓ2 in Figure 1(b), one can
move instantaneously (through ℓ1) from ℓ0 to ℓ2 if L and R
are pressed simultaneously. Such a behaviour has required an
explicit edge from ℓ0 to ℓ2 in Figure 1(a).
However, the VDTA formalism would not have been advan-
tageous in situations where the behaviours depend on former
states of the buttons. This may occur when a rising edge of the
button needs to be captured and processed even if the button
52
VALID 2011 : The Third International Conference on Advances in System Testing and Validation Lifecycle
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-168-7

has been released again in the meantime; in such a situation,
we would probably need to keep the state “button was pressed”
and use a TIOA model.
Anyway, modelling input/output by variables is quite ordi-
nary for engineers. This allows short and clear speciﬁcation
in some circumstances.
A. Model and Semantics of VDTA
Let N, Q+ and R+ denote the sets of natural, non-
negative
rationals
and
real
numbers,
respectively.
Let
V = {V1, · · · , Vn} be a set of variables; each variable Vi ∈ V
ranges over a (possibly inﬁnite) domain Dom(Vi) in N, Q+ or
R+. We deﬁne Dom(V ) = Πi∈[1..n]Dom(Vi), the domain of
V . In the sequel, vi denotes a valuation of the variable Vi and
v the tuple of valuations of the set of variables V . A variable
assignment for V is a tuple Πi∈[1..n]({Vi}×(Dom(Vi)∪{⊥}))
and we denote by A(V ) the set of variable assignments for
V . Given a valuation v = (v1, · · · , vn) of V and a variable
assignment A ∈ A(V ), we deﬁne the tuple of valuations
v[A] as v[A](Vi) = c if (Vi, c) is an element of A and
c ̸= ⊥, and v[A](Vi) = vi otherwise. Intuitively, an element
(Vi, c) of variable assignment A, requires to assign c to
the variable Vi if c is a constant from Dom(Vi); otherwise
c is equal to ⊥ and no access to the variable Vi should
be done. V ar(A) denotes the set of variables of V
that
are updated by A. We denote IdV
the identity variable
assignment that let unchanged all the variables of V . We
denote by G(V ) (resp.G+(V )) the set of variable constraints
deﬁned as conjunction (resp. boolean combinations) of simple
constraints of the form Vi ▷◁ c with Vi ∈ V , c ∈ Dom(Vi)
and ▷◁∈ {<, ≤, =, ≥, >}. Given G ∈ G+(V ) and a valuation
v ∈ Dom(V ), we write v |= G when G(v) ≡ true and we
deﬁne [[G]] = {v ∈ Dom(V ) | v |= G}. For a subset I of
V , we denote GI the projection of G over the variables in
I. To ease the notation, if I, O, are two sets of different
sorts of variables, a constraint G in G+(I, O) is a boolean
combination of a constraint GI ∈ G+(I), and a constraint
GO ∈ G+(O). This generalises to an arbitrary number of sets
of variables.
Deﬁnition 1: A Variable Driven Timed Automaton (VDTA)
is a tuple A = ⟨L, X, I, O, ℓ0, G0, ∆A⟩, where L is a ﬁnite set
of locations, X is a ﬁnite set of clocks, I and O are disjoint
ﬁnite sets of input and output variables, ℓ0 ∈ L is the initial
location, G0 ∈ G(I, O) is the initial condition with only one
solution, a constraint with variables in I ∪ O and ∆A ⊆ L ×
G(I, O, X) × A(O) × 2X × L is the set of edges.
In an edge ⟨ℓ, G, A, X, ℓ′⟩ ∈ ∆A (often written ℓ
G,A,X
−−−−→ℓ′):
G ∈ G(I, O, X); A ∈ A(O) is an assignment on output
variables and X ∈ 2X is a set of clocks that are reset when
passing the edge. There is no explicit assignment on input
variables.
A state of a VDTA A is of the form (ℓ, i, o, x) where ℓ ∈ L
is a location, i, o and x are valuations of input, output and
clock variables. A valuation is simply a function that returns
the values of the variables. For example, (ℓ0, (0, 0), 1, 0.5)
is a state of the VDTA in Figure 1(b) where (0, 0) is the
valuation of the inputs L and R, S equals 1 and t equals 0.5.
If A ∈ A(I) is an assignment on input variables, the
valuation i[A] changes the value of input variables according
to the assignment. If x is clock valuation, X is a subset
of clocks, and δ ∈ R+ a delay, the valuation x + δ adds
δ to each clock value and the valuation x[X ← 0] resets
from x all clocks in X. For example, if i = (0, 0) and
A = {L := 1; R := 1} is an assignment over L and R then
i[A] is the valuation (1, 1).
Deﬁnition 2: The semantics of a VDTA A is a timed
transition system [[A]] = ⟨SA, s0, Σ, →⟩ where SA = L ×
Dom(I) × Dom(O) × RX
+ is the (inﬁnite) set of states,
s0 = (ℓ0, i0, o0, x0) is the initial state where x0 is the clock
valuation that maps every clock to 0 and (i0, o0) is the only
solution of G0, Σ = A(I) ∪ A(O) ∪ R+ is the (inﬁnite) set
of actions, and → is the transition relation with the following
three types of transitions:
T1 (ℓ, i, o, x)
A
−→ (ℓ′, i, o[A], x[X
← 0]) if there exists
(ℓ, G, A, X, ℓ′) ∈ ∆A such that (i, o, x) |= G,
T2 (ℓ, i, o, x)
A
−→
(ℓ, i[A], o, x)
with
A
∈
A(I)
if
∀(ℓ, G, A′, X, ℓ′) ∈ ∆A, (i, o, x) ̸|= G.
T3 (ℓ, i, o, x)
δ−→(ℓ, i, o, x+δ) with δ > 0 if for every δ′ < δ,
for every symbolic transition (ℓ, G, X ′, ℓ′) ∈ ∆A, we
have (i, o, x + δ′) ̸|= G.
The semantics considers discrete transitions (T1 and T2)
and continuous transitions (T3). Output-update transitions of
type T1 allow to update the output variables. Output-update
transitions correspond to edges passing. Edges are passed as
soon as their constraints are satisﬁed. Input-update transitions
of type T2 allow to update the input variables. Time-elapsing
transitions of type T3 represent the continuous elapse of time.
Deﬁnition 3: A stable state is a state from which no output-
update transition can be ﬁred.
Note that input-updates and time-elapsing transitions are
allowed stable states only; they are not allowed in non stable
states. Input-update transitions allow to change the inputs.
They are ﬁred by the environment. Considering Figure 1(b),
(ℓ0, (1, 0), 0, 0) is not stable whereas (ℓ0, (0, 0), 0, 0) is
stable. Consequently, the only transition from (ℓ0, (1, 0), 0, 0),
(ℓ0, (1, 0), 0, 0)
IdO
−−→ (ℓ1, (1, 0), 0, 0) corresponds to the
edge ℓ0
L=1∨R=1;t:=0
−−−−−−−−−−→ ℓ1 (ℓ0, (0, 0), 0, 0) whereas from
(ℓ0, (0, 0), 0, 0) one can perform input-update transitions
or
time-elapsing
transitions
like:
(ℓ0, (0, 0), 0, 0)
L=1
−−−→
(ℓ0, (1, 0), 0, 0), (ℓ0, (0, 0), 0, 0)
0.3
−−→ (ℓ0, (0, 0), 0, 0.3) or
(ℓ0, (0, 0), 0, 0)
0.7
−−→(ℓ0, (0, 0), 0, 0.7).
Deﬁnition 4: A run of A, r
=
s0a1s1 · · · ansn
in
SA.(Σ.SA)∗ is a sequence of alternating states si ∈ SA and
actions ai ∈ Σ with Σ = A(I) ∪ A(O) ∪ R+ such that
∀i ≥ 0, si
ai+1
−→ si+1.
53
VALID 2011 : The Third International Conference on Advances in System Testing and Validation Lifecycle
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-168-7

ℓ0
ℓ1
ℓ2
ℓ3
L = 1 ∧ 0 < t < 1
S := 0
L = 0 ∧ 1 < t < 2
S := 1
L = 0 ∧ 3 < t < 4
S := 1
Fig. 2.
A VDTA
Here are two possible runs of the VDTA in Figure 1(b):
(ℓ0, (0, 0), 0, 0)
L:=1
−−−→ (ℓ0, (1, 0), 0, 0)
IdO
−−→ (ℓ1, (1, 0), 0, 0)
0.3
−−→
(l1, (1, 0), 0, 0.3) and (ℓ0, (0, 0), 0, 0)
L:=1,R:=1
−−−−−−−→ (ℓ0, (1, 1), 0, 0)
IdO
−−→(ℓ1, (1, 1), 0, 0)
s:=1
−−−→(ℓ2, (1, 1), 1, 0).
B. Principle of Reachability Analysis
The reachability analysis amounts to checking whether
there exist a run that goes through a given target state. We
want that the VDTA reachability analysis algorithm returns
how and when to modify the inputs in order to reach the target
state eventually.
Let us consider the small running example VDTA in Fig-
ure 2 where L is the only boolean input variable, S is the
only boolean output variable and t is the only clock variable.
Now assume that one wants to check the reachability of the
location ℓ3 whatever are the values of L, S and t in ℓ3. We
want the reachability algorithm to return the verdict “yes” and
the following scenario:
1) From the initial state (ℓ0, 0, 0, 0), keep the value of L
unchanged and let the time elapse until t equals 1.
2) When t equal 1, set L to 1; then let the time elapse.
3) set L to 0 after the value of t has passed 3 and before
it reaches 4.
But if one wants to check the reachability of ℓ3 when S equals
0, the algorithm should return that the state is not reachable
since S equals 1 after the edge from ℓ0 to ℓ3 is taken.
Let Goal be a set of states of A we want to check
the reachability of. Algorithm 1 gives the principle of the
backward reachability analysis for A: it starts in Goal and
computes in each step the predecessors of already encountered
states. The algorithm stops when no new state is computed.
a) Predecessors: Let P ⊆ SA be a subset of states
of A. The computation of the set of predecessors of P
(denoted Pre(P)) involves the computation of its output-
update predecessors (Preo(P)), its input-update predecessors
(Prei(P)) and its time predecessors (Pret(P)).
The output-update predecessors of P, Preo(P) is the
set of states from which a state in P can be reached just
after an output-update is performed; formally, Preo(P) =
{(ℓ, i, o, x) | ∃ A ∈ A(O) ∃ (ℓ′, i′, o′, x′) ∈ P s.t (ℓ, i, o, x)
A
−→
(ℓ′, i′, o′, x′)}. None of the states in Preo(P) is stable.
Similarly, we deﬁne the input-update predecessors of P,
Prei(P) = {(ℓ, i, o, x) | ∃A ∈ A(I), ∃ (ℓ′, i′, o′, x′) ∈
P s.t (ℓ, i, o, x)
A
−→(ℓ′, i′, o′, x′)}. All the states in Prei(P)
are stable.
The time predecessors of P, Pret(P) is the set of states
from which a state in P can be reached by letting the
time elapse. Formally, Pret(P)
=
{(ℓ, i, o, x)
|
∃δ
>
0, ∃ (ℓ′, i′, o′, x′) ∈ P s.t (ℓ, i, o, x)
δ−→(ℓ′, i′, o′, x′)}. All the
states in Pret(P) are stable.
Finally, Pre(P) = Preo(P) ∪ Prei(P) ∪ Pret(P).
For example, let us consider the VDTA in Figure 2. The
state (ℓ0, 0, 0, 2.2) is a time predecessor of (ℓ0, 0, 0, 2.8); but
(ℓ0, 0, 0, 1.999) is not a time predecessor of (ℓ0, 0, 0, 2.8) since
(ℓ0, 0, 0, 1.999) is not stable and the transition to ℓ2 is taken
prior to time elapsing. (ℓ0, 0, 0, 1.999) is an output-update
predecessor of (ℓ2, 0, 1, 1.999).
An execution of Algorithm 1, which computes predecessors
of states, may not terminate. This is because VDTA has
inﬁnitely many states and each computation step may return
a new state. Thus, we consider symbolic representations
for states or shortly symbolic states; then we describe the
computation of predecessor (Preo, Prei, Pret and Pre) of
symbolic states. Later, we show that the number of symbolic
states encountered during the execution of the algorithm is
ﬁnite. This will ensure its termination.
b) Relation with other models: A similar zone based
analysis method is used for timed automata [2], [3], [5],
[7]. But it cannot be simply adapted for VDTA. The output
predecessor operator over symbolic states of VDTA works
like the discrete predecessor operator for timed automata
whereas the input and time predecessors do not. In particular,
the computation of the time predecessor should not return
time instants that enable an urgent edge. Similarly, the input
predecessors can not return input data that enable urgent edges.
Besides, the analysis of VDTA has many common points with
the analysis of timed game automata (TGA) [6]. Indeed, since
input-update are freely performed by the environment, they are
analogous to “controllable actions” in TGA. Output update
transitions are analogous to “uncontrollable actions” since all
edges in VDTA (that allow output-update) are eager and ﬁred
as soon as their constraints become true. But TGA analysis
algorithm cannot work for VDTA: edges passing in VDTA
cannot be restricted by letting the time progress forever or
by changing the inputs. This is because all edges in VDTA
are urgent. Moreover, input actions are not explicit in VDTA
whereas they are in TGA. Nevertheless, for the analysis of
VDTA we have considered the notion of safe time predecessor
inspired from [6].
III. PREDECESSORS OF SYMBOLIC STATES
There are two popular symbolic representations of a set of
clock valuations: the region-based [2] and the zone-based [4]
representations. Roughly speacking, regions and zones are
abstract representations of (inﬁnite) set of valuations; but zones
are larger representations: a zone can be decomposed into
an equivalent ﬁnite set of regions. A region-based analysis
algorithm for VDTA inspired by [2] early appeared in [11].
The algorithm is used for selecting real-time test cases for
54
VALID 2011 : The Third International Conference on Advances in System Testing and Validation Lifecycle
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-168-7

systems modeled with VDTA. The region abstraction allows
elegant reasoning on timed systems however it is practically
less efﬁcient than the zone abstraction: a single operation over
a zone needs many operations over the regions it includes.
We consider a zone-based approach for representing symbolic
states and to compute their (input/output/time) predecessors.
A. Symbolic States, Zones, and Operations
A symbolic state for A is a quadruple (ℓ, ZI, ZO, ZX)
where ℓ ∈ L, ZX ⊆ RX
+ is the standard clock-zone as
deﬁned in [4], ZI ⊆ V al(I) is a subset of V al(I) such
that ZI = [[G]] for some G ∈ G(I); the same for ZO.
We say that ZI and ZO are zones over input and output
variables. A symbolic state represents a set of states. We
write (ℓ, i, o, x) ∈ (ℓ′, ZI, ZO, ZX) if and only if ℓ = ℓ′,
i ∈ ZI, o ∈ ZO and x ∈ ZX. A symbolic state is stable iff
every state in it is stable.
The input, output and clock-zone ZI, ZO and ZX are
represented with difference bound matrices (DBM) [4]. DBM
are kinds of constraints (comparison between two clocks are
allowed). Considering Figure 2, (ℓ0, L = 1, true, 1 ≤ t < 4)
is one symbolic state where true denotes the constraint that
is always true.
Remark: zones for input/output values are simpler than the
ones used for linear integer systems or other models with
variables (like in [1]). This is because constraints in VDTA
never compare clock with input/output variables. Abstractions
for clock valuations can be separated for abstractions of signal
values. It is not the goal of this paper to discuss the effect of
this restriction on the expressiveness of the model.
Remark: in the sequel, constraints are often considered
as zones for simplifying the notations. We implicitly assume
that every constraint in G+(I, O, X) is equivalent to a set of
constraints of G(I, O, X).
Computable operations on zones [4]: if Z is a zone (over
clocks or variables), and A is a variable assignment or a clock
reset then [A]Z = {x | x[A] ∈ Z} denotes the set of valuations
from which we can reach a valuation in Z after A is executed.
Similarly we deﬁne Z[A] = {x[A] | x ∈ Z}. The past of a
clock zone Z, Z↓ = {x | ∃ δ ∈ R+, s.t x + δ ∈ Z} is the
set of valuations (the zone) from which valuations in Z can
be reached by letting the time elapse.
Safe time predecessors: given two clock zones Z and g,
Pres
t(Z, g) denotes the set of safe time predecessors [6] of Z
with respect to g. Intuitively, a clock valuation x′ belongs
to Pres
t(Z, g) if from x′ we can reach x ∈ Z by time
elapsing and along the (time) path from x′ to x we avoid all
valuations in g. Later, the safe time predecessor is involved in
the computation of the time predecessors. Intuitively, it will
prevent the time predecessor to return zones that enable urgent
edges. Formally:
Pres
t(Z, g) = {x′ ∈ RX
+ | ∃ δ ∈ R+ x ∈ Z s.t x = x′ + δ,
and ∀δ′ ∈ [0, δ], we have x′ + δ′ ̸∈ g}
The
computation
of
Pres
t(Z, g)
is
effective
[4],
[6]:
Pres
t(Z, g) = (Z↓ ∩ (¬(g↓))) ∪ ((Z ∩ (g↓) ∩ ¬g)↓) where Z,
g are convex sets and ¬g is the complement of g.
Partitioning of set of zones: later, we will also need to split
sets of zones into equivalent sets of disjoint zones. Indeed,
since zones are abstractions of larger sets of valuations, it
could happen that the input/time predecessors of two valua-
tions in a same zone differ according to constraints on urgent
edges. So we will need to consider these valuations separately.
The operation Split(C) allows to partition a set of sets of
valuations (or a set of zones) into a set of disjoint sets of
valuations (or a set of disjoint zones). Formally, let C be a
ﬁnite set of zones (or constraints). Split(C) is a ﬁnite set of
zones {Z1, . . . , Zn} such that: it partitions the set C meaning
that S
i=1..n Zi = S
Z∈C Z and ∀i ̸= j Zi ∩ Zj = ∅; and
secondly, its elements ”match” the clock constraints of C,
meaning that ∀i ∈ {1, . . . , n}, ∀Z ∈ C, Zi ⊆ Z or Zi∩Z = ∅.
For example, Split({1 ≤ t < 4, 1 < t < 2, 3 < t < 4} may
return {t = 1, 1 < t < 2, 2 ≤ t ≤ 3, 3 < t < 4}.
B.
Output-update Predecessors of Symbolic States
Deﬁnition 5: The set of output-update predecessors of a
symbolic state (ℓ, ZI, ZO, ZX), Preo(ℓ, ZI, ZO, ZX) is de-
ﬁned by:
Preo(ℓ, ZI, ZO, ZX)
=
{(ℓ′, Z′
I, Z′
O, Z′
X) | ∃ℓ′ G,A,X
−−−−→ℓ ∧
Z′
I = ZI ∩ GI
Z′
0 = [A](GO[A] ∩ ZO) ∩ GO
Z′
X = [X](GX[X] ∩ ZX) ∩ GX}
Proposition 1: (ℓ′, i′, o′, x′)
∈
Preo(ℓ, ZI, ZO, ZX) iff
there is (ℓ, i, o, x) ∈ (ℓ, ZI, ZO, ZX) such that (ℓ′, i′, o′, x′) ∈
Preo(ℓ, i, o, x)
Proof:
=⇒ This part of the proof is not difﬁcult.
⇐= Let (ℓ, i, o, x) ∈ (ℓ, ZI, ZO, ZX) then i ∈ ZI, o ∈ ZO
and x ∈ ZX. If (ℓ′, i′, o′, x′) ∈ Preo(ℓ, i, o, x) then
i = i′, o = o′[A] and x = x′[X] for some A ∈ A(O).
Moreover, according to the semantics of VDTA there
exists an edge ℓ′ G,A,X
−−−−→ℓ such that i′ ∈ GI, o′ ∈ GO
x′ ∈ GX and additionally i = i′, o = o′[A] and
x = x′[X].
1) we get that i′ ∈ ZI ∩ GI since i = i′, i′ ∈ GI and
i ∈ ZI.
2) Let us show that o′ ∈ [A](GO[A] ∩ ZO) ∩ GO.
Since o = o′[A] and o′ ∈ ProjO(G) we get
that o ∈ GO[A]. Then o ∈ GO[A] ∩ ZO since
o also belongs to ZO. Additionally, o = o′[A]
implies o′
∈ [A]o. As o ∈ GO[A] ∩ ZO we
get that o′
∈
[A](GO[A] ∩ ZO). Since it is
required that o′
∈
GO
we ﬁnally get that
55
VALID 2011 : The Third International Conference on Advances in System Testing and Validation Lifecycle
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-168-7

o′ ∈ [A](GO[A] ∩ ZO) ∩ GO.
3) A similar justiﬁcation is used to show that x′ ∈
[X](GX[X] ∩ ZX) ∩ GX.
As there exists an edge ℓ′ G,A,X
−−−−→ℓ, i′ ∈ ZI ∩ GI, o′ ∈
[A](GO[A]∩ZO)∩GO, and x′ ∈ [X](GX[X]∩ZX)∩GX
we get that (ℓ′, i′, o′, x′) ∈ Preo(ℓ, ZI, ZO, ZX). This
ends the proof of the proposition.
C. Input-update Predecessors of Symbolic States
Let us consider the VDTA in Figure 2 and the symbolic
state se = (ℓ0, L = 0, true, 1 ≤ t < 4). Assume that one
wants to compute Prei(se). As input update transitions keep
the outputs and the clocks unchanged, a simple implementation
of Prei could only replace in se the input zone L = 0
by the input zone true (i.e, any value of L) and return
(ℓ0, true, true, 1 ≤ t < 4). Such a simple implementation is
not correct since it is not possible to execute an input update
transition (the one that sets L to 0) from (ℓ0, 0, 1, 1.5) ∈
(ℓ0, true, true, 1 ≤ t < 4) in order to reach se. Indeed
(ℓ0, 0, 1, 1.5) is not stable and the edge ℓ0
L=0;1<t<2;S:=1
−−−−−−−−−−−→ℓ1
is urgently taken. A correct implementation returns stable
symbolic states only. On the other hand, a correct imple-
mentation may return the following input predecessors for
se: (ℓ0, true, true, t
=
1), (ℓ0, L
̸=
0, true, 1
<
t
<
2), (ℓ0, true, true, 2 ≤ t ≤ 3), (ℓ0, L ̸= 0, true, 3 < t < 4).
Clearly, such an implementation has decomposed the output
and clock zones of se in order to allow/forbid some input
values. The decomposition considers the constraints on the
outgoing edge of ℓ0.
Given a location ℓ, an output and a clock zone ZO and ZX
we consider the following sets.
The
set
of
constraints
on
the
outgoing
edges
of
ℓ
that
may
become
true
upon
an
input
update
is
Gds(ℓ, ZO, ZX)
=
{G | ∃ℓ
G,A,X
−−−−→ℓ′ : GO ∩ ZO ̸= ∅
and GX ∩ ZX ̸= ∅}.
The timing context of the tuple (ℓ, ZO, ZX) is the set
Ctxδ(ℓ, ZO, ZX) = {ZX} ∪ {GX | G ∈ Gds(ℓ, ZO, ZX)}.
The output context of the tuple (ℓ, ZO, ZX) is the set
CtxO(ℓ, ZO, ZX) = {ZO} ∪ {GO | G ∈ Gds(ℓ, ZO, ZX)}.
Following
the
example
we
get
that
:
Gds(se) = {(L = 1 ∧ 1 < t < 2), (L = 0 ∧ 3 < t < 4)},
Ctxδ(ℓ0, true, 1 ≤ t < 4) = {1 ≤ t < 4, 1 < t <
2, 3 < t < 4} and CtxO(ℓ0, true, 1 < t < 2) = {true}.
The
computation
of
Prei(se)
works
as
follows:
We
partition the timing context Ctxδ(ℓ0, true, 1 ≤ t < 4)
into an equivalent set of disjoint “atomic” clock constraints
{t = 1, 1 < t < 2, 2 ≤ t ≤ 3, 3 < t < 4}. Then, for
each atomic clock zone Z′
X in set of disjoint “atomic”
clock constraints, we partition CtxO(ℓ0, true, Z′
X) into an
equivalent set of disjoint “atomic” output constraints. In
this example, the result is always {true}. Finally for each
“atomic” clock constraints Z′
X and for each atomic output
constraint Z′
O the input predecessor compute the negation of
input part of constraints in Gds(ℓ, Z′
O, Z′
X).
Let us abstract the above thought into a formal deﬁnition.
Deﬁnition 6: The set of input-update predecessors of a
symbolic state (ℓ, ZI, ZO, ZX), Prei(ℓ, ZI, ZO, ZX) is de-
ﬁned by:
Prei(ℓ, ZI, ZO, ZX)
=
{(ℓ′, Z′
I, Z′
O, Z′
X) |
ℓ′ = ℓ,
Z′
X ∈ Split(Ctxδ(ℓ, ZO, ZX)),
Z′
O ∈ Split(CtxO(ℓ, ZO, Z′
X)),
Z′
I ∈
\
G′∈Gds(ℓ,G′
O,Z′
X)
¬G′
I}
One can show the following.
Proposition 2: (ℓ′, i′, o′, x′)
∈
Prei(ℓ, ZI, ZO, ZX) iff
there is (ℓ, i, o, x) ∈ (ℓ, ZI, ZO, ZX) such that (ℓ′, i′, o′, x′) ∈
Prei(ℓ, i, o, x)
D. Time Predecessors of Symbolic States
The time predecessor Pret(ℓ, ZI, ZO, ZX) is implemented
analogously to Prei. Similarly to input updates, the time
elapses in stable states only and then we also need to carefully
decompose constraints. As far as time elapsing transitions only
change the value of clocks, we decompose the input and the
output constraints.
We
deﬁne
the
sets
Gds(ℓ, ZI, ZO)
=
{G | ∃ℓ
G,A,X
−−−−→ℓ′ : GI ∩ ZI ̸= ∅
and GO ∩ ZO ̸= ∅},
CtxI(ℓ, ZI, ZO) = {ZI} ∪ {GI | G ∈ Gds(ℓ, ZI, ZO)} and
CtxO(ℓ, ZI, ZO) = {ZO}∪{GO | G ∈ Gds(ℓ, ZI, ZO)}. The
set Gds(ℓ, ZI, ZO) returns the constraints on the outgoing
edges of ℓ that may become true when one looks back into
the time from (ℓ, ZI, ZO, ZX).
Consider Figure 2 and assume that one wants to compute
Pret(s2) where s2 = (ℓ0, L = 0, true, 3 < t < 4). Note
that although 0 ≤ t < 4 is the past of 3 < t < 4, the
symbolic state (ℓ0, L = 0, true, 0 ≤ t < 4) is not a time
predecessor of st since it is not possible to reach s2 from
(ℓ0, 0, 0, 1.3) ∈ (ℓ0, L = 0, true, 0 ≤ t < 4) by letting
the time elapse. Indeed, (ℓ0, 0, 0, 1.3) is not stable. Then,
we consider Gds(L = 0, true) = {L = 0 ∧ 3 < t <
4, L = 0 ∧ 1 < t < 2}, CtxI(L = 0, true) = {L = 0}
and CtxO(L = 0, true) = {true}. In a ﬁrst time one
decomposes CtxI(L
=
0, true) into a set of disjoint
“atomic” input constraints and one gets {L = 0}. Secondly
one decomposes CtxO(L = 0, true) into a set of disjoint
“atomic” output constraints and one gets {true}. The unique
input/output context obtained after the decompositions is
given by L = 0 and true. Then, from the symbolic state
(ℓ0, L = 0, true, 3 < t < 4) we compute a clock zone
Z′ from which we can reach 3 < t < 4 by time elapsing
and along the (time) path from Z′ to 3 < t < 4 we must
avoid the clock part of all constraints in Gds(L = 0, true)
since otherwise one reach non stable states. This correspond
56
VALID 2011 : The Third International Conference on Advances in System Testing and Validation Lifecycle
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-168-7

to the computation of safe time predecessors of a clock
zone with respect to another one. For instance we compute
the safe time predecessor of 3 < t < 4 with respect to
{3 < t < 4, 1 < t < 2} and we should get 2 ≤ t ≤ 3. Finally
we should get that Pret(s2) = (ℓ0, L = 0, true, 2 ≤ t ≤ 3).
For the computation of Pret(ℓ, ZI, ZO, ZX), the next
step after the decomposition of input/output constraints is
to compute the safe time predecessors. We deﬁne the time
predecessor as follows:
Deﬁnition 7: The set of time predecessors of a symbolic
state (ℓ, ZI, ZO, ZX), Prei(ℓ, ZI, ZO, ZX) is deﬁned by:
Pret(ℓ, ZI, ZO, ZX) = {(ℓ′, Z′
I, Z′
O, Z′
X) |
ℓ′ = ℓ,
Z′
I ∈ Split(CtxI(ℓ, ZI, ZO)),
Z′
O ∈ Split(CtxO(ℓ, Z′
I, ZO)),
Z′
X ∈ Pres
t(ZX, {GX | G ∈ Gds(ℓ, Z′
I, Z′
O)})}
One can show the following.
Proposition 3: (ℓ′, i′, o′, x′)
∈
Pret(ℓ, ZI, ZO, ZX) iff
there is (ℓ, i, o, x) ∈ (ℓ, ZI, ZO, ZX) such that (ℓ′, i′, o′, x′) ∈
Pret(ℓ, i, o, x)
E. Zone-Based Reachability Analysis Algorithm
The zone based reachability analysis algorithm computes at
each step the predecessors of already encountered symbolic
states. The predecessors are computed as follows:
Pre(ℓ, ZI, ZO, ZX) =
[
τ∈{i,o,t}
Preτ(ℓ, ZI, ZO, ZX)
Note that all the operations on zones (update, pre-update,
past time, Split) can be effectively computed [4] using
DBM (or simple adaptations for input and output zones).
The iterative ﬁxpoint process of Algorithm 1 converges after
ﬁnite many steps. This is true as the computation of Prei,
Preo, Pres
t and Pret involves exactly the constants in A
and variable updates only set variables to constants. Using
similar argument to [6], one can show that the reachability
analysis algorithm is EXPTIME. Although we did not carry
out experiments of the zone-based algorithm, it should be clear
that this new algorithm for VDTA is practically more efﬁcient
than that based on regions [11].
IV. CONCLUSION AND FUTURE WORK
The paper proposed a more efﬁcient zone-based backward
algorithm for the reachability analysis of Variable Driven
Timed Automata (VDTA). The algorithm is based on the
deﬁnition of predecessors operators of symbolic states. Sym-
bolic states contain input, output, and clock constraints that
should be respected in order to reach the target state. These
informations can be used by the environment to control the
execution of systems or select test cases.
The VDTA model received a favorable echo among some
industrial partners since it is a good compromise between
simplicity and expressiveness. Ongoing works include com-
posability issues. Moreover, one can intensify the model with
tough arithmetic operations and study decidability issues.
ACKNOWLEDGMENT
This work has been supported by the ANR (Agence Na-
tionale de la Recherche) TesTEC Project. We also would like
to thank Herv´e Marchand for his comments.
REFERENCES
[1] Rajeev Alur, Thao Dang, and Franjo Ivancic. Reachability analysis of
hybrid systems via predicate abstraction. In 5th International Workshop
on Hybrid Systems: Computation and Control (HSCC’02), pages 35–48.
Springer, 2002.
[2] Rajeev Alur and David Dill. A theory of timed automata. Theoretical
Computer Science, 126:183–235, 1994.
[3] Roberto Barbuti and Luca Tesei. Timed automata with urgent transitions.
Acta Informatica, 40(5), 2004.
[4] Johan Bengtsson and Wang Yi. Timed automata: Semantics, algorithm
and tools. In Lectures on Concurrency and Petri Nets, pages 87–124.
Springer, 2004.
[5] Patricia Bouyer. Untameable timed automata! In 20th Symposium on
Theoretical Aspects of Computer Science (STACS’03), pages 620–631.
Springer, 2003.
[6] Franck Cassez, Alexandre David, Emmanuel Fleury, Kim G. Larsen,
and Didier Lime.
Efﬁcient on-the-ﬂy algorithms for the analysis of
timed games. In 16th International Conference on Concurrency Theory
(CONCUR’05), pages 66–80. Springer, 2005.
[7] Fr´ed´eric Herbreteau and B. Srivathsan. Efﬁcient on-the-ﬂy emptiness
check for timed b¨uchi automata.
In 8th Int. Symp. on Automated
Technology for Veriﬁcation and Analysis (ATVA’10), pages 218–232.
Springer, 2010.
[8] Dilsun K. Kaynar, Nancy Lynch, Roberto Segala, and Frits Vaandrager.
Timed i/o automata: A mathematical framework for modeling and
analyzing real-time systems. In The 24th IEEE International Real-Time
Systems Symposium (RTSS’03), volume 0, pages 166–177. IEEE, 2003.
[9] Stephan Merz. Model checking: A tutorial overview. In Modeling and
Veriﬁcation of Parallel Processes, pages 3–38. Springer, 2001.
[10] Houda Bel Mokadem, B´eatrice B´erard, Patricia Bouyer, and Franc¸ois
Laroussinie. A new modality for almost everywhere properties in timed
automata.
In 16th International Conference on Concurrency Theory
(CONCUR’05), pages 110–124. Springer, 2005.
[11] Omer Nguena-Timo, Herv´e Marchand, and Antoine Rollet. Automatic
test generation for data-ﬂow reactive systems with time constraints. In
22nd IFIP International Conference on Testing Software and Systems:
Short Papers (ICTSS’10 ). CRIM-Canada, 2010.
[12] Omer Nguena-Timo and Antoine Rollet. Conformance testing of vari-
able driven automata. In 8th IEEE International Workshop on Factory
Communication Systems Communication in Automation (WFCS’10),
2010.
[13] Omer Nguena-Timo and Antoine Rollet. Test selection for data-ﬂow
reactive systems based on observations. In Software Testing, Veriﬁcation
and Validation Workshops (ICSTW’11). IEEE Xplore, 2011.
[14] Peter J. Ramadge and W. Murray Wohnam. The control of discrete event
systems. Proceedings of the IEEE Computer Society, 77:81–98, 1989.
[15] J. Tretmans.
Test generation with inputs, outputs, and repetitive
quiescence. Software-Concepts and Tools, 17:103–120, 1996.
57
VALID 2011 : The Third International Conference on Advances in System Testing and Validation Lifecycle
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-168-7

