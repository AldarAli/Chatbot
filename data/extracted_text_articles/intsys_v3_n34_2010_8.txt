Bag Relational Algebra with Grouping and Aggregation over C-Tables with Linear
Conditions
Lubomir Stanchev
Computer Science Department
Indiana University - Purdue University Fort Wayne
Fort Wayne, IN, USA
stanchel@ipfw.edu
Abstract—We introduce bag relational algebra with grouping
and aggregation over a particular representation of incomplete
information called c-tables, which was ﬁrst introduced by
Grahne in 1984. In order for this algebra to be closed and “well-
deﬁned”, we adopt the closed world assumption as described
by Reiter in 1978 and extend the tuple and table conditions
to linear ones. We explore the problem of rewriting and
simplifying this novel type of c-tables, show how to perform
equivalence test for c-tables, and argue why it is difﬁcult
to create a canonical form for c-tables. We present certain
answer semantics for a full-blown relational algebra with
grouping and aggregation and accordingly present algorithms
for executing the different relational algebra operators over
our representation of incomplete information. The algorithms
run in polynomial time relative to the size of the precise
information, which makes them a candidate for implementation
as part of a DBMS engine that supports storage and retrieval
of incomplete information.
Keywords-incomplete information; c-tables; relational model;
null values; bag semantics
I. INTRODUCTION
This paper extends a conference paper on the topic of
querying incomplete information ([1]). We have added the-
oretical results on simplifying and checking the equivalence
of c-tables and discussion on the existence of a canonical
form for c-tables. We have also expanded the description of
all algorithms that implement non-trivial relational algebra
operators, such as monus, grouping, and aggregation, and
added detailed proofs on the correctness and time complexity
to all algorithms.
Many times, when information is entered into databases,
the values for some of the ﬁelds are left empty for various
reasons. In some cases, partial information about the blank
ﬁelds is available. However, existing relational database
technology does not allow for such information to be
processed. Imielinski and Lipski in [2] were among the
ﬁrst to propose richer semantics for null values that allows
for incomplete information to be processed. However, their
model was based on set semantics. Later on, Libkin and
Wong published a paper on querying incomplete information
in databases with multisets ([3]), but included only a limited
set of operators that excluded grouping and aggregation.
Other papers that tackle the problems of storing and query-
ing incomplete information include [4], [5], [6], [7], [8].
However, they all fail to explore grouping and aggregation
over bag semantics.
In this paper, we ﬁll a gap in published research in the
area of storing and querying incomplete information. More
precisely, we show how bag relational algebra with grouping
and aggregation can be applied over incomplete information
represented as a particular variation of c-tables. A c-table
consists of a of c-tuples and a global condition, where every
c-tuple contains a regular tuple that may include variables
for some of its ﬁelds plus a local condition (See Table I
for an example). The semantics of a c-table is determined
by the set of relational tables that it represents, where each
representation is derived from a valuation for the variables in
the c-table. In order for the relational algebra over c-tables
to be closed and well deﬁned, we deﬁne the semantics of a
c-table to be over the closed world assumption, as deﬁned in
[9], and we extend local and global conditions to be linear.
We will refer to such c-tables as linear c-tables, where the
exact semantics will be presented in Section II-A.
C-tables were ﬁrst introduced by Grahne in [10] to have
local and global conditions that did not contain the “+”
operator and the “>” relation. Later on, Grahne added the
“>” relation in [4]. However, we are not aware of any
published research that allows for the “+” operator to be
part of the local or global condition of a c-table. On the
other hand, introducing the “+” operator is required in order
for relational algebra with aggregation over c-tables to be
closed.
Note that several different linear c-tables may have the
same semantics, that is, have the same set of representations.
This is the reason why it is desirable to be able to check for
equivalence between linear c-tables and be able to normalize
linear c-tables. For example, when we store or visualize a
linear c-table, we would want to use a compact and easy to
understand representation. In the paper we present a novel
procedure for simplifying linear c-tables that runs in poly-
nomial time relative to the size of the precise information.
We show why it is difﬁcult to construct a canonical form
for linear c-tables and solve the problem of comparing linear
258
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

c-tables for equality.
The main contributions of the paper are the algorithm
for simplifying linear c-tables, the algorithm for comparting
two c-tables for equality, and the algorithms for performing
the different relational operators over linear c-tables. While
the implementation of the operator projection, selection, and
inner join are similar to the case of set semantics (see [2]),
the algorithms for monus, duplicate elimination, grouping,
and aggregation are non-trivial and novel.
A. Motivation
Real world requirements have shown the importance of
storing and querying incomplete information. However, con-
temporary database management systems (DBMSs) provide
only limited support (that is, only null values). Part of
the reason is the lack of research in the area. While the
problem of storing incomplete information is somewhat
solved, querying incomplete information remains an open
research challenge. This paper makes a signiﬁcant step
towards solving the later problem.
The main hurdle towards the implementation of a DBMS
that can processes rich incomplete information is the in-
trinsic high cost of managing such information. However,
note that the algorithms that we present for performing
the various relational algebra operators are non-polynomial
relative only to the size of the incomplete information. Tak-
ing into account the ever-increasing speed of computational
resources, we believe that incorporating tools that store and
query incomplete information within commercial database
engines is feasible and practical. This work can play a key
part in such an endeavor. For example, since the code for
executing bag relational algebra operators is an important
part of the kernel of a SQL engine, our algorithms can be
used to implement a SQL engine that can query incomplete
information stored as linear c-tables.
In what follows, in Section II we deﬁne a representation of
incomplete information in terms of linear c-tables. In Section
III we describe how linear c-tables can be simpliﬁed and
compared for equality and explore the problem of existence
of canonical form for c-tables. In Section IV we deﬁne bag
relational algebra operators over linear c-tables and present
example algorithms for their implementation. In Section V
the problems of grouping and aggregation over linear c-
tables are explored. Section VI provides a summary or the
presented work and addresses areas for future research.
II. C-TABLES WITH LINEAR CONDITIONS
The problem of representing incomplete information in
the relational model is almost as old as the relational model
itself ([11], [12], [13], [14], [15]). When a null value appears
in a relational table, its value can be interpreted as no
information available, only partial information available,
value not applicable, and so on. Most of the research on null
values has concentrated on the ﬁrst two meanings. Known
representations of relational tables adapting these meanings
for nulls include Codd tables, na¨ıve tables, Horn tables and
c-tables. Codd tables are relational tables, where the values
of some the ﬁelds can be null. Na¨ıve tables are an extension
of Codd tables, where each null is given a label and nulls
having the same label represent the same unknown value.
C-tables are na¨ıve tables with a local condition associated
which each c-tuple and a single global condition associated
with each c-table. A c-tuple in a c-table is part of the
representation of the c-table under some valuation when the
local condition of the c-tuples and global condition of the
c-table are both true. Horn tables are a special kind of c-
tables in which the local and global conditions are restricted
to Horn clauses.
Grahne, in [4], considered Boolean conditions over the
system ⟨R, {>, =}⟩ (i.e., Boolean expressions with variables
and constants deﬁned over the set R extended with “>” and
“=”). To the best of our knowledge, except for [1], this is
the most expressive system for expressing c-table conditions
in published research.
In this paper we explore c-tables with conditions over
the system ⟨R, {>, =, +}⟩ ∪ ⟨S, {=, ̸=}⟩, where R is
used to denote the set of real numbers and S is the set of
strings over some ﬁnite alphabet. While the “+” operator is
introduced in order to make the algebra closed relative to
aggregation, the system over strings is introduced in order
to extend the expressive power of c-tables. Note that we
do not explore conditions over ⟨Z, {>, =, +}⟩, where
Z is the set of integers, or over ⟨R, {>, =, ∗, +}⟩. The
reason is that, although these systems are more expressive,
reasoning with them is much harder. For example, Fischer
and Rabin have shown that the time complexity of deciding
whether a formula over the ﬁrst system is satisﬁable is super
exponential ([16]). Similarly, the time complexity of the
fastest known algorithm for solving the same problem for
the second system, which is presented in [17], is higher than
exponential.
A. Deﬁnitions
We next present the syntax and semantics of a linear c-
table.
Deﬁnition 1 (syntax of linear c-table): A linear c-table
T as a ﬁnite and unordered bag of linear c-tuples and a
global condition1. A linear c-tuple with attributes {Ai}a
i=1
is the sequence of mappings from Ai to D(Ai) ∪ Vi plus a
local condition, where i ranges from 1 to a, D(Ai) denote
the domain of Ai and Vi is used to represent a possibly
inﬁnite but countable set of variables over D(Ai). The local
and global conditions can range over the system ⟨R, {>, =,
+}⟩ ∪ ⟨S {=, ̸=}⟩.
1In order to keep the notation simple, we do not use special syntax for
c-tuples and c-tables, where it will be clear from the context when we are
referring a c-table (c-tuple) and when to a relational table (tuple).
259
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

name
school
condition
John
y
x = 1
Mark
y
x ̸= 1
q
z
TRUE
g.c. (q ̸=“Mark”) ∧ (q ̸=“John”) ∧ (z ̸= y)
Table I
AN EXAMPLE LINEAR C-TABLE
Table I shows an example of a linear c-table. We will refer
to the part of a linear c-table where the data is stored as the
main part and to the remaining parts as the local condition
part and the global condition part, respectively. In Table I, x,
y, z and q are used to represent variables. Since our model is
limited only to the domains of real numbers and strings, the
domain of a variable that does not appear in the main part of
a linear c-table can be inferred from the context in which it
appears. Fore example, we can use the local condition x = 1
to deduce that the domain of x is the set of real numbers.
Table I expresses the information that either there are no
students or there are two students that study in different
schools and the name of one of them is “John” or “Mark”
and the name of the other one is neither “John” nor “Mark”.
Note that in this example and throughout the paper we will
be using the closed world assumption. The assumption states
that the database contains all existing individuals. In our
example, we have used this assumption to conclude that
there are at most two students in the database.
In order to formally deﬁne the semantics of a c-table,
Imielinski and Lipski introduce a function called rep that
maps a c-table T to a possibly inﬁnite set of relational tables
([2]). Intuitively, the meaning of the rep function is that
given a c-table T, the function returns all relational tables
that T represents under different valuations. In [2], this
function is deﬁned relative to the open world assumption.
We deﬁne it relative to the closed world assumption. In
the deﬁnition that follows, main, lc and gc are used to
denote the main part, the local condition part, and the global
condition part of a linear c-table, respectively. The symbol
ε is used to denote the empty set.
Deﬁnition 2 (semantics of a linear c-table): A linear c-
table T represents the set of relational tables that are deﬁned
by the following equation.
rep(T) = {T ′|∃v, such that v(T) = T ′}
(1)
In the deﬁnition, v is a mapping that maps the variables in T
to constants in the corresponding domains and is generalized
to linear c-tuples as follows.
v(t) =
 v(main(t))
:
v(lc(t)) ∧ v(gc(T))
ε
:
otherwise
(2)
The value of v(main(t)) is calculated by substituting the
variables in the main part of t with the values to which v
Figure 1.
Three different ways to represent the same two-dimensional
point set as union of polyhedra
maps them. The mapping v is further extended to linear c-
tables as shown in Equation 3, where {ti}k
i=1 are the linear
c-tuples in T.
v(T) = {| v(ti)|i ∈ [1, k] ∧ v(ti) ̸= ε |}
(3)
In the above deﬁnition, we have used the common nota-
tion {| · |} to denote a bag of elements. While it is possible
to deﬁne an ordering on the linear c-tuples inside a linear
c-table, we leave this topic as area for future research.
Deﬁnition 2 is novel and differs from the deﬁnitions pre-
sented in [2], [4]. Unlike these papers, we deﬁne duplicate
semantics for c-tables and use the closed world assumption.
From now on, when the distinction is clear from the
context, we will refer to linear c-tuples simply as c-tuples
and to linear c-tables simply as c-tables.
III. SIMPLIFYING LINEAR C-TABLES
An important part of simplifying a linear c-table is
simplifying the local conditions and the global condition,
which are both expressed as linear conditions, and checking
for their satisﬁability. Details on how to simplify a linear
condition and how to check if it is satisﬁable under at least
one valuation are presented next.
A. Linear Condition Simpliﬁcation and Satisﬁability Check
A linear condition is a Boolean expression and, as such,
can be expressed as a disjunction of positive conjunctions.
A positive conjunction is a conjunction of positive atomic
linear conditions, where the later has the form ¯a · ¯x = ¯b
or ¯a · ¯x < ¯b (¯x is a variable vector and ¯a and ¯b are
vector constants). An atomic linear condition includes in
addition negative conditions of the form ¯a · ¯x ̸= ¯b. An
intuitive representation of a positive conjunction is a multi-
dimensional polyhedron, which deﬁnes a semilinear set.
Therefore, a linear condition can be interpreted as a set of
disjoint polyhedra. Note however that, as shown if Figure 1,
such a representation is not unique.
Let us ﬁrst consider the algorithm that was proposed in
[18] for normalizing conjunctions of linear equalities and
inequalities. More precisely, the paper represents a conjunc-
tion of atomic linear conditions by the system A¯x ≤ ¯b,
E¯x =
¯d, ¬(¯ci¯x =
¯fi), where A and E are matrices
with constants, ¯b, ¯d, ¯ci and ¯fi are vectors of constants
and ¯x is a variable vector. The normalization algorithm
260
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

runs in polynomial time and relies on calls to a module
that solves linear programs. We will refer to this algorithm
as normalize.The algorithm has the added advantage that
it recognizes sets of unsatisﬁable atomic conditions and
reports them as such by returning the empty set. Part of the
algorithm deals with the elimination of redundant conditions,
which is an extension of the research that is published in
[19]. The pivot theorem from [18] follows.
Theorem 1: If two sets of atomic conditions over ⟨R, {+,
>, =}⟩ deﬁne the same point set, where R is the set of real
numbers, then their canonical forms will have identical set
of equality conditions, the same inequality conditions up
to multiplication by a positive scalar, and the same set of
negative conditions.
Algorithm 1 simplify(C)
1: c1 ∨ c2 ∨ ... ∨ cn ← C, where {ci}n
i=1 are positive
conjunctions.
2: result ← break up(c1, . . . , cn)
3: if result = ∅ then
4:
return false
5: end if
6: return g1∨· · ·∨gm, where {gi}m
i=1 are the conjunctions
in result.
Algorithm 2 break up(c1, . . . , cn)
1: result ← {normalize(c1)}
2: for i ← 2 to n do
3:
for g ∈ result do
4:
result ← result ∪ {normalize(g ∧ ci)}
5:
result ← result ∪ {normalize(g ∧ ¬ci)}
6:
result ← result ∪ {normalize(¬g ∧ ci)}
7:
result ← result − {g}
8:
end for
9: end for
10: for g ∈ result do
11:
if g = false then
12:
result ← result − {g}
13:
end if
14: end for
15: return result.
The pseudo-code for simplifying a linear condition C is
presented in Algorithm 1. The algorithm ﬁrst breaks C into
a disjunction of positive conjunctions. Next, the algorithm
divides the conjunctions so that they do not overlap. As a
ﬁnal step, the algorithm normalizes the conjunctions that are
computed using the normalization algorithm from [18]. The
following theorem address the correctness of the algorithm.
Theorem 2: Algorithm 1 is correct, that is, C
=
simplify(C) for any linear condition C.
Proof: Line 1 of Algorithm 1 breaks C into disjunctive
normal form and therefore does not change the value of
C. Algorithm 2 breaks up conjunctions so that they do not
overlap. The conjunction of the expressions g ∧ ci, g ∧ ¬ci,
and ¬g ∧ ci is equal to g ∨ ci. Therefore, Lines 4-7 of the
Algorithm 2 remove g from the set of conjunctions stored
in result and add g ∨ ci. Therefore, the net effect of the
lines is to add ci to result. Therefore, after Lines 1-9 of
Algorithm 2 the conjunctions {ci}n
i=1 are added to result.
Lines 10-14 of Algorithm 2 remove false conjunctions
from result. If after this process result is empty, then C is
not satisﬁable and false is returned correctly at Lines 4
of Algorithm 1. Line 6 of Algorithm 1 returns the computed
disjoint conjunctions. ■
Theorem 3: Algorithm 1 runs in O(mc · 3n) time, where
m is the length of the linear condition C, n is the number
of conjunctions in the disjunctive normal form of C (i.e.,
n ≤ (
√
2)m), and c is a constant.
Proof: In order to verify the running time of the algorithm,
note that Line 1 takes O(m·n) time. Line 1 of Algorithm 2
makes a call to the normalization procedure from [18],
which runs in O(mc) time (the length of each conjunction
is smaller then the length of C). Lines 2-9 of Algorithm 2
make at most 3n−1
2
− 1 calls to the procedure from [18].
The reason is that during the kth iteration of the outer for-
loop there can be as many as 3(k−2) conjunctions in result
and therefore as much as 3(k−1) calls to the normalization
procedure from [18]. Lines 10-14 of Algorithm 2 take
less time to execute than Lines 2-9 of Algorithm 2 and
therefore do not contribute to the complexity. Therefore,
nP
k=2
3k−1 =
3n−1
2
− 1 is an upper bound on the number
of calls to the normalization procedure and each call takes
O(mc) time. ■
Algorithm 1 can be used to test the satisﬁability of a
linear condition. However, the part of the algorithm that
removes the overlapping part of the conjunctions will no
longer be needed. The modiﬁed pseudo-code is shown in
Algorithm 3. We will refer to the simpliﬁed algorithm
as fast simplify. Alternative methods for testing for linear
condition satisﬁability are described in [20], [21]. The full-
blown algorithm is only useful when we want to eliminate
including the same point set multiple times by breaking up
a linear condition into disjoint polyhedra.
Algorithm 3 fast simplify(C)
1: c1 ∨ c2 ∨ ... ∨ cn ← C, where {ci}n
i=1 are positive
conjunctions.
2: for i ← 1 to n do
3:
ci ← normalize(ci)
4: end for
5: if ci = false for i = 1 to n then
6:
return false
7: end if
8: return c1 ∨ · · · ∨ cn
261
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Theorem 4: Algorithm
3
is
correct,
that
is
fast simplify(C)
=
C.
Moreover,
fast simplify(C)
returns false exactly when C is not satisﬁable.
Proof: The algorithm breaks C into disjunctive normal
form and normalizes each conjunction. This will not affect
the value of C. Note that when C is not satisﬁable each
conjunction ci will be evaluated as false (see [18] for a
formal proof) and therefore the method will return false.
■
Theorem 5: The running time of Algorithm 3 is O(n ·
mc) = O((
√
2)m · mc), where m is the length of the
linear condition C, n is the number of conjunctions in the
disjunctive normal form of C (i.e., n ≤ (
√
2)m), and c is a
constant.
Proof: Line 3 is executed n times and the complexity of
the normalize method is O(mc). ■
The algorithm can be applied not only to conditions over
the system ⟨R, {>, =, +}⟩, but also to conditions over the
system ⟨R, {>, =, +}⟩ ∪ ⟨S, {=, ̸=}⟩. To do so, substitute
each atomic conditions of the form x ̸= c, where x is a
string variable and c is a string constant with x = c1 ∨ x =
c2∨· · ·∨x = cr∨x = cr+1, where cr+1 is a newly introduced
string constant and {ci}r
i=1 are the existing string constants
excluding c. In other words, we pin the value of x to be
equal to one of the existing constants (excluding c) or to a
new constant, which is equivalent to stating that x ̸= c.
Similarly, substitute each atomic condition of the form
x ̸= y, where x and y are string variables with
i̸=j
W
i,j=1,r+2
(x =
ci ∧ y = cj), where cr+1 and cr+2 are newly introduced
constants and {ci}r
i=1 are the existing string constants. In
other words, we add the restriction on the variables x and
y that they are equal to distinct constants, which implies
x ̸= y.
Alternatively, Line 1 of the algorithm can be modiﬁed to
require the breaking of C into not necessarily positive con-
junctions. This modiﬁcation allows the direct application of
the normalization algorithm to a linear condition containing
strings because the algorithm from [18] handles inequality
conditions in addition to equality and weak-inequality (i.e.,
greater than and less than) conditions.
B. C-Table Simpliﬁcation
Note that there may be different c-tables representing the
same set of bag relational tables, that is, it may be the case
that T1 ̸= T2 but rep(T1) = rep(T2). The following deﬁni-
tion formally deﬁnes the concept of c-table equivalence.
Deﬁnition 3 (c-table equivalence): If rep(T1) = rep(T2),
then we will say that T1 and T2 are equivalent and write
T1 ≈ T2.
Algorithm 4 shows how to simplify a c-table. The algo-
rithm relies on the notion of c-tuple uniﬁcation, which is
deﬁned next.
A
B
condition
1
2
x = 1
z
2
x = 2
p
w
x = t
g.c.: t ̸= 1 ∧ t ̸= 2
A
B
condition
a
b
((a = 1) ∧ (b = 2) ∧ (x = 1))∨
((a = z) ∧ (b = 2) ∧ (x = 2))∨
((a = p) ∧ (b = w) ∧ (x = t))
g.c.: t ̸= 1 ∧ t ̸= 2
Table II
A C-TABLE AND THE RESULT OF APPLYING STEPS 1 AND 2 OF THE
C-TABLE SIMPLIFICATION ALGORITHM
Deﬁnition 4 (c-tuple uniﬁcation): The c-tuples t1 and t2
of the c-table T are uniﬁable exactly when the formula
lc(t1) ∧ lc(t2) ∧ gc(T) is not satisﬁable. We will denote
this check as uniﬁable, that is uniﬁable(t1, t2) = ¬(lc(t1)∧
lc(t2) ∧ gc(T)).
Algorithm 4 simplify(T)
1: for t ∈ T do
2:
if fast simplify(lc(t) ∧ gc(t)) = false then
3:
remove t from T
4:
end if
5: end for
6: while ∃{t1, t2} s.t. uniﬁable(t1, t2) do
7:
remove t1 and t2 from T
8:
create c-tuple t with main part ¯X = x1, x2, ..., xn,
where n is the arity of T and {xi}n
i=1 are newly
introduced variables.
9:
add to t the local condition ( ¯X = main(t1)∧lc(t1))∨
( ¯X = main(t2) ∧ lc(t2))
10:
add t to T
11: end while
12: for t ∈ T do
13:
lc(t) ← simplify(lc(t) ∧ gc(T))
14:
if lc(t) = false then
15:
remove t from T
16:
else
17:
while main(t) contains the variable x for an at-
tribute and fast simplify(lc(t) ⇒ (x = c)) = true
do
18:
replace x with constant c in main(t)
19:
end while
20:
end if
21: end for
22: gc(T) ← true
23: return T
The intuition behind the deﬁnition is that if two c-tuples
have local conditions that cannot both hold under any
valuation, then at most one of the c-tuples could be present
in any representation of the c-table and therefore the two
262
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

c-tuples can be merged into a single c-tuple.
Table II shows the result of applying the ﬁrst eleven
lines of the algorithm. The following theorem captures the
correctness of Algorithm 4.
Theorem 6: Algorithm
4
is
correct,
that
is,
simplify(T) ≈ T for any c-table T.
Proof: Lines 1-5 of the algorithm remove c-tuples that are
not part of any representation. Therefore, they will not have
an effect on rep(T). Lines 6-11 of the algorithm unify c-
tuples that can be uniﬁed and thus reducing the size of the c-
table without changing its representations. The reason is that
two c-tuples that have incompatible local conditions cannot
both appear in any representation. Lines 12-22 of of the
algorithm move the global condition to the local conditions
and simplify the resulting local conditions. Again, this will
not affect the set of representations for the table. ■
The next theorem describes the time complexity of Algo-
rithm 4.
Theorem 7: Algorithm 4 runs in O(d3·(
√
2)d·m·(d·m)c+
(m · d)c · 3(
√
2)m·d · n) time, where n is the number of c-
tuples, m is the greater of the size of the longest c-tuple and
the size of the global condition, d is the number of c-tuples
with non-trivial local conditions (i.e., local conditions that
are different than true), and c is a constant.
Proof: Lines 1-5 of the algorithm takes O((
√
2)m · mc ·
d) time. The reason is that algorithm fast simplify, which
takes O((
√
2)m · mc) time, needs to be applied to d local
conditions.
Lines 6-11 will take O(d3 · (
√
2)d·m · (d · m)c) time. The
reason is that

Deﬁnition 6 (sound relational algebra): A relational al-
gebra is sound exactly when only correct answers appear in
the result of q(T1, . . . , Tn) or formally rep(q(T1, . . . , Tn)) ⊆
q(rep(T1, . . . , Tn)) for any c-tables {Ti}n
i=1 and operator q
with arity n.
Note that throughout the paper we use q(rep(T1, . . . , Tn))
to denote the result of applying q to each table in the set
rep(T1, . . . , Tn).
Deﬁnition 7 (complete relational algebra): A
relational
algebra is complete exactly when all correct answers
appear
in
the
result
of
q(T1, . . . , Tn)
or
formally
q(rep(T1, . . . , Tn)) ⊆ rep(q(T1, . . . , Tn)) for any c-tables
{Ti}n
i=1 and operator q with arity n.
A relational algebra operator is well deﬁned exactly when
it is closed, sound, and complete. In this section we deﬁne
the semantics of projection, selection, inner join, union,
monus, and duplicate elimination over c-tables with bag
semantics and show that all operators are well deﬁned. The
grouping and aggregation operations are discussed in the
next section.
A. Projection
Deﬁnition 8 (syntax and semantics of projection): If
T
is a c-table with attributes ¯A, then we denote the projection
of the attributes
¯A′ over this c-table as π ¯
A′(T). The
pseudo-code for performing the projection operator is
shown in Algorithm 5.
The c-table π ¯
A′(T) is constructed from the c-table T by
removing all columns in ¯A − ¯A′ and leaving the same local
and global conditions.
Algorithm 5 π ¯
A′(T)
1: for t ∈ T do
2:
remove attributes outside the set A from t
3: end for
4: return T
Note that the above deﬁnition deﬁnes duplicate-preserving
projection. The duplicate-eliminating projection, which is
more common in the relational model, can be constructed
by applying the duplicate-elimination operator to the result
of applying the duplicate-preserving projection. Algorithm 5
does not remove conditions that include variables associated
with removed attributes because these conditions are still
relevant. For example, even if an attribute that contains the
variable x is removed from Table I, the variable x should
not be removed from the local conditions because it stores
the information that only one of the ﬁrst two c-tuples can
appear in any representation.
Theorem 9: The projection operator is well deﬁned.
Proof: We need to show that rep(π ¯
A(T)) = π ¯
A(rep(T)).
⇒ Let T1 ∈ rep(π ¯
A(T)), where T1 is a relational table.
Then there exists a valuation v such that T1 = v(π ¯
A(T)).
Let T2 be a relational table that extends T1 with arbitrary
A
B
condition
2
x
x ̸= 3
2
4
TRUE
g.c. x ̸= 2
B
C
condition
4
1
TRUE
2
z
z > 3
g.c. TRUE
Table IV
EXAMPLE R1 AND R2 C-TABLES
B
condition
4
TRUE
2
z > 3
g.c. TRUE
B
C
condition
4
1
TRUE ∧ 1 > 2
2
z
z > 3 ∧ z > 2
g.c. TRUE
Table V
THE RESULT OF πB(R2) AND σC>2(R2)
values for the attributes outside the set ¯A. Then the equation
T1 = π ¯
A(T2) will hold. Let v′ be the valuation v extended
so that T2 = v′(T). Then T2 ∈ rep(T) and therefore T1 ∈
π ¯
A(rep(T)).
⇐ Let T1 ∈ π ¯
A(rep(T)). Then there exists valuation v
such that T1 = π ¯
A(v(T)). Let T2 be a relational table that
extends T1 with arbitrary values for the attributes outside
the set ¯A. Then the equation T1 = π ¯
A(T2) will hold. Note
that T1 = v′(π ¯
A(T)) where v′ is a valuation that extends v
to the attributes outside the set ¯A according to the values of
the attributes in T2. Therefore T1 ∈ rep(π ¯
A(T)). ■
Table IV shows two example c-tables that we will use
throughout this section. The left part of Table V shows
the result of πB(R2). The following theorem describes the
complexity of the projection operator.
Theorem 10: The projection operator takes O(s) time,
where s is the size of the c-table on which the projection is
applied.
Proof: The operator goes though the c-tuples of the c-table
exactly once and eliminates certain attributes. Therefore, the
time complexity of the operator is equal to order the size of
the c-table. ■
B. Selection
Deﬁnition 9 (syntax and semantics of selection): We de-
note the selection over a c-table T as σγ(T), where γ is
a predicate formula over ⟨R, {>, =, +}⟩ ∪ ⟨S, {=, ̸=}⟩ that
references the variables {Ai}n
i=1 that have the same names
as the attributes of T. The pseudo-code for performing
selection is presented in Algorithm 6.
Algorithm 6 σγ(T)
1: for t ∈ T do
2:
θ(t) ← a substitution that substitutes every variable
Ai with t[Ai] (the value for the attribute Ai in t).
3:
lc(t) ← lc(t) ∧ γθ(t)
4: end for
5: return T
264
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Theorem 11: The selection operator is well deﬁned.
Proof: We need to show that rep(σγ(T)) ≡ σγ(rep(T))
for every c-table T. But this is equivalent to proving that
there exists valuations v and v′ s.t. v(σγ(T)) = σγ(v′(T)).
However, we have deﬁned selection over c-tables in such
a way so that v(σγ(T)) = σγ(v(T)) for any valuation v,
which proves that selection is well deﬁned. ■
The right part of Table V shows the result of σC>2(R2).
The following theorem proves the time complexity of the
selection operator.
Theorem 12: The selection, as we have deﬁned it, takes
O(s ∗ m) time, where s is the size of the c-table and m is
the size of the selection condition.
Proof: The number of c-tuples in the c-table is bounded by
s. For every c-tuple, we need to add to its local condition
a condition of size m and therefore the time complexity of
the algorithm is O(s ∗ m). ■.
In order to save space, c-tuples with unsatisﬁable local
condition can be removed from the c-table, where we can
use the fast simplify algorithm to detect such c-tuples.
C. Inner Join
Deﬁnition 10 (syntax and semantics of inner join):
Consider a c-table T1 with attributes { ¯A, ¯B} and a c-table
T2 with attributes { ¯B, ¯C}. We denote the inner join of
T1 and T2 on the set of attributes ¯B as T1 ▷◁ ¯
B T2. The
pseudo-code for performing inner join is presented in
Algorithm 7.
Algorithm 7 T1 ▷◁ ¯
B T2
1: T ← empty c-table with attributes ¯A ∪ ¯B ∪ ¯C
2: rename the variables in T2 so that T1 and T2 do no share
variables
3: for t1 ∈ T1 do
4:
for t2 ∈ T2 do
5:
if
fast simplify(π ¯
B(main(t1))
=
π ¯
B(main(t2)))! = false then
6:
main(t) ← (t1, π ¯
C(t2))
7:
lc(t) ← lc(t1) ∧ lc(t2) ∧ (t1[ ¯B] = t2[ ¯B])
8:
add t to T
9:
end if
10:
end for
11: end for
12: gc(T) ← gc(T1) ∧ gc(T2)
13: return T
Theorem 13: The inner join operator is well deﬁned.
Proof: Let v be a valuation of the distinct variables of
T1 and T2 (after Line 2 of Algorithm 7 is executed). We
need to show that v(T1 ▷◁ ¯
B T2) = v(T1) ▷◁ ¯
B v(T2). Let
t ∈ v(T1 ▷◁ ¯
B T2). Then there must exist t1 ∈ T1 and t2 ∈ T2
such that the main part of t is equal to the join of the main
parts of t1 and t2. Then t = v(t1) ▷◁ ¯
B v(t2) and therefore
t ∈ v(T1) ▷◁ ¯
B v(T2). The other direction is analogous. ■
A
B
C
condition
2
x
1
x ̸= 3 ∧ x = 4 ∧ TRUE
2
x
z
x ̸= 3 ∧ x = 2 ∧ z > 3
2
4
1
TRUE ∧ TRUE
g.c. x ̸= 2 ∧ TRUE
Table VI
THE RESULT OF R1 ▷◁ R2
Table VI shows the result of R1 ▷◁ R2. The following
theorem proves the time complexity of the inner join oper-
ator.
Theorem 14: Inner join takes O(n′·n′′·(
√
2)m·mc) time,
where n′ and n′′ are the sizes of the c-tables that are being
joined, m is the size of the longest local condition in them,
and c is a constant.
Proof: The code inside the double for-loop is executed
n′ · n′′ number of times. The main time complexity in
Lines 5-9 come from the call to the fast simplify method,
which takes O((
√
2)m · mc) time to execute. ■.
D. Union
Deﬁnition 11 (syntax and semantics of union): If T1 and
T2 are c-tables, then we will denote their union as T1 ∪
T2. The pseudo-code for calculating the union of c-tables is
presented in Algorithm 8.
Algorithm 8 T1 ∪ T2
1: T ← empty c-table
2: rename the variables in T2 so that T1 and T2 do no share
variables
3: for t1 ∈ T1 do
4:
add t1 to T
5: end for
6: for t2 ∈ T2 do
7:
add t2 to T
8: end for
9: gc(T) ← gc(T1) ∧ gc(T2)
10: return T
Note that we deﬁne the union operator to be duplicate
preserving. Duplicate eliminating union can be performed
by applying duplicate elimination to its result.
Theorem 15: The union operator is well deﬁned.
Proof: We need to show that v(T1 ∪ T2) = v(T1) ∪ v(T2)
for any valuation v. Let t ∈ v(T1 ∪ T2). Then there exit
c-tuple t1 such that t1 is in either T1 or T2 and t = v(t1).
Therefore, t ∈ v(T1) ∪ v(T2). The reverse direction is
analogous. ■.
The following theorem proves the time complexity of
Algorithm 8.
Theorem 16: The time complexity of Algorithm 8 is
O(n + m) where n and m are the sizes of T1 and T2,
respectively.
265
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Proof: The time complexity of the algorithm comes from
Lines 3-5, which take O(n) time, and Lines 6-8, which take
take O(m) time. Therefore, the total time complexity of the
algorithm is O(n + m). ■.
E. Monus
In bag relational algebra over bag relational tables
monus is deﬁned as: T1 ˙−T2
= {t[k]|t ∈ T1 ∧ k
=
max(count(t, T1) − count(t, T2), 0)}, where t[k] is used
to denote the tuple t replicated k times and count is a
function that returns the number of occurrences of the tuple
speciﬁed as the ﬁrst parameter in the table speciﬁed as
the second parameter. The following deﬁnition extends the
monus operator to c-tables.
Deﬁnition 12 (syntax and semantics of monus): The
monus of two c-tables T1 and T2 is deﬁned as T1 ˙−T2.
The pseudo-code for performing the monus operator is
presented in Algorithm 9.
Algorithm 9 T1 ˙−T2
1: rename the variables in T2 so that T1 and T2 do no share
variables
2: V ← T1
3: i ← 0
4: for t1 ∈ T1 do
5:
j ← 0
6:
for t2 ∈ T2 do
7:
X[i][j] = (main(t1) = main(t2)) ∧ lc(t1) ∧
gc(T1) ∧ lc(t2) ∧ gc(T2)
8:
j ← j + 1
9:
end for
10:
i ← i + 1
11: end for
12: gc(V ) ← gc(V )∧
mV
j=1
[
nW
i=1
(Y [1, j] = · · · = Y [i−1, j] =
Y [i + 1, j] = · · · = Y [n, j] = 0 ∧ Y [i, j] = 1)] ∧
nV
i=1
[
mW
j=1
(Y [i, 1] = · · · = Y [i, j − 1] = Y [i, j + 1] =
· · · = Y [i, m] = 0 ∧ Y [i, j] = 1)]
13: for t ∈ V do
14:
lc(t) ← lc(t) ∧ ¬[
mW
j=1
(X[i, j] ∧ (Y [i, j] = 1))]
15: end for
16: return V
Theorem 17: The
monus
operator
is
well
deﬁned,
where
the
deﬁnition
of
complete
is
changed
to:
[Rep(T ′) ˙−Rep(T ′′)] ∪ {∅} ⊆ Rep(T ′ ˙−T ′′).
Proof: The algorithm ﬁrst renames the variables of T2 so
that they are distinct from those in T1. Next, it calculates the
matrix X and sets a restriction on the possible values for the
matrix Y . The value of X[i, j] contains the condition that
must hold for the ith c-tuple of T1 to be deleted from T1 and
the c-tuple that “deletes” it to be the jth c-tuple of T2. The
x ̸= 3 ∧ x ̸= 2 ∧
x = 4 ∧ TRUE ∧ TRUE
x ̸= 3 ∧ x ̸= 2 ∧
x = 2 ∧ z > 3 ∧ TRUE
TRUE ∧ x ̸= 2 ∧ 4 = 4
TRUE ∧ TRUE
FALSE
A
B
condition
2
x
x ̸= 3 ∧ ¬((X[1, 1]∧
Y [1, 1] = 1) ∨ (X[1, 2] ∧ Y [1, 2] = 1))
2
4
TRUE ∧ ¬((X[2, 1]∧
Y [2, 1] = 1) ∨ (X[2, 2] ∧ Y [2, 2] = 1))
g.c. (x ̸= 2) ∧ ((Y [1, 1] = Y [2, 2] = 1 ∧ Y [1, 2] = Y [2, 1] =
0) ∨ (Y [1, 2] = Y [2, 1] = 1 ∧ Y [1, 1] = Y [2, 2] = 0))
Table VII
SHOWS THE MATRIX X AND THE RESULT FOR R1 ˙−R2
matrix Y [i][j] has the restriction that for each j there exists
exactly one i such that Y[i][j]=1 and that for each i there
exists exactly one j such that Y [i][j] = 1 (the elements of
the matrix Y can only take the values 0 and 1). The matrix
Y is used to enforce the condition that every c-tuple t2 in
T2 can be used to delete at most one c-tuple of T1 and that
every c-tuple t1 in T2 can be deleted at most once. Lastly,
the local conditions that we add to the resulting c-table do
the deletions. They specify that if for some valuation both
X[i][j] and (Y [i][j] = 1) hold, (i.e., if a c-tuple t′
i in T ′
matches with a c-tuple t′′
j in T ′′ and the valuation is such
that t′
i can not be deleted by any c-tuple other then t′
j and
t′
j can only delete t′
i), then the c-tuple that was constructed
from the ith c-tuple in T1 should be deleted from the resulting
c-table V .
Given a valuation v, each c-tuple in T1 will be deleted
only if there exists a matching c-tuple in T ′′. Moreover,
given a valuation v, every c-tuple in T2 can delete at most
one c-tuple from T1. Therefore, the algorithm is correct and
Rep(T1 ˙−T2) ≡ [Rep(T1) ˙−Rep(T2)] ∪ {∅}. Here {∅} is
used to represent the empty c-table. ■
Note that we had to modify the deﬁnition of a complete
relational algebra because we constructed the global condi-
tion of T1 ˙−T2 in such a way so that we allow for {∅} to
be a possible representation. It is our believe that this is an
intrinsic problem of monus when dealing with the closed
world assumption.
A demonstration of how monus can be applied over the
example c-tables from Table IV is shown in Table VII.
The following theorem describes the time complexity of
Algorithm 9.
Theorem 18: Monus, takes O(m · n) time, where m and
m are the sizes of the c-tables on which the operation is
performed.
Proof: The complexity of the algorithm comes from the
two for-loops. The code inside the double for-loops runs
in constant time and it is executed O(m · n) time. ■
266
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

A
B
condition
2
x
x ̸= 3 ∧ (x ̸= 4 ∨ FALSE)
2
4
TRUE ∧(x ̸= 4 ∨ x = 3)
g.c. x ̸= 2
Table VIII
THE RESULT OF ε(R1)
F. Duplicate Elimination
The last relational algebra operation that we will explore
in this section is duplicate elimination. In the relational case,
duplicate elimination can be deﬁned as a grouping on all the
attributes. We adopt similar deﬁnition here.
Deﬁnition 13: We will denote the duplicate elimination
operator applied to the c-table T as ε(T). We will compute
ε(T) using the formula ε(T) = group ¯
A(T), where ¯A are
the attributes of T.
Note that the result of the group operation is a nested c-
table (see Table IX for an example of a nested c-table). We
deﬁne the semantics of a nested c-table and of the group
operation in Section V-A.
Theorem 19: The duplicate elimination operator is well
deﬁned.
Proof:
ε(Rep(T))
≡
group ¯
A(Rep(T))
≡
Rep(group ¯
A(T))
≡
Rep(ε(T)),
which
proves
that
duplicate elimination is well deﬁned. The fact that the
equation group ¯
A(Rep(T))
≡
Rep(group ¯
A(T)) holds
follows from the fact that the group operation is well
deﬁned over c-tables, which will be proven in Section V-A.
■
The result of ε(R1), where R1 is the c-table deﬁned in
Table IV, is shown in Table VIII.
V. APPLYING AGGREGATION TO C-TABLES
To the best of our knowledge, no research has been
previously published in the area of applying grouping and
aggregation to c-tables. We are aware of research on ap-
plying aggregation to fuzzy numbers ([23]) and to random
variables ([24]), but the query results in these algorithms
are approximations. On the other hand, the research done
in constraint databases ([25]) has explored the problem of
aggregation over constraint databases. Unfortunately, the
operation of aggregation in most constraint database systems
is not closed ([26]). We are also aware of recent research in
the area of auditing conﬁdential information ([27]), which,
however, deals only with aggregation over Boolean vari-
ables.
In general, we would like to be able to evaluate a
relational expression of the form
¯
AFagg1(B1),...,aggn(Bb)T,
where ¯A∪{Bi}b
i=1 are the attributes of T, ¯A = {Ai}a
i=1, and
each aggi is one of the aggregates: min, max, sum, count and
avg. In the relational case, the above expression is evaluated
by grouping the tuples that have the same value for the
attributes ¯A into a single tuple that has this common value
for the attributes ¯A. The value for the remaining attributes is
calculated by applying the aggregation operations {aggi}n
i=1
to the value of the ¯B attributes of the tuples in the group. In
order to extend this deﬁnition to c-tables, we will need to be
able to group c-tuples and perform aggregation on c-tuples.
A. Grouping
The result of the grouping operation is a nested c-table
that consists of nested c-tuples. An example nested c-table
is shown in Table IX. Informally, a nested c-table consists
of c-tuples that can have more than one value for some of
the attributes. A formal deﬁnition follows.
Deﬁnition 14 (nested c-tables and c-tuples): A nested c-
tuple with single valued attributes {Ai}a
i=1 and multi-valued
attributes {Bi}b
1 is the sequence of mappings from Ai to
D(Ai) ∪ Vi for i ranging from 1 to a plus the sequence
of mapping from Bi to a bag of values over D(Bi) ∪ Vi
for i ranging from 1 to b plus a local condition over ⟨R,
{>, =, +}⟩ ∪ ⟨S, {=, ̸=}⟩. Note that here D(A) is used
to denote the domain of A and Vi is used to represent a
possibly inﬁnite, but countable, set of variables over D(Ai)
in the ﬁrst case and over D(Bi) in the second case.
A nested c-table is a c-table that contains nested c-
tuples. The semantics of a nested c-table is similiar to the
semantics of a regular c-table as described in Section II-A
(see Equations 1, 2, and 3). The only difference is that a
nested c-table represents a set of nested bag relational tables
(see [28]) under different valuations and consists of a bag
of nested c-tuples.
The algorithm for performing the grouping uses the con-
cept of a semi-uniﬁable c-tuples and the ≺ relation for c-
tuples, which are formally presented next.
Deﬁnition 15 (semi-uniﬁable c-tuples): The
c-tuples
{ti}n
i=1 of the c-table T are semi-uniﬁable relative to
the set of attributes
¯A exactly when the expression
nV
i,j=1
π ¯
A(main(ti)) = π ¯
A(main(tj)) is satisﬁable under
some valuation.
Informally, a bag of c-tuples are semi-uniﬁable relative
to the set of attributes ¯A exactly when the c-tuples can be
potentially grouped into a single nested c-tuple in which ¯A
are the single-valued attributes.
Deﬁnition 16 (the ≺ relation): We will write t1 ≺A t2,
where t1 and t2 are c-tuples and
¯A is a set of at-
tributes exactly when main(π ¯
A(t2)) can be constructed
from main(π ¯
A(t1)) by substituting some of the variables
in main(π ¯
A(t1)) with constants.
Informally, the ≺ relation compares the main parts of two
c-tuples to determine if one c-tuple has more speciﬁc values
than the other. The ≺ relation is transitive and deﬁnes partial
order.
Deﬁnition 17 (syntax and semantics of grouping): We
denote the result of grouping by the attributes ¯A of T as
267
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

A
B
condition
2
x
x ̸= 3 ∧ (x ̸= 4 ∨ FALSE)
2
4
TRUE ∧ (x ̸= 4 ∨ x = 3)
2
2
4
x ̸= 3 ∧ TRUE ∧ x = 4
g.c. x ̸= 2
Table IX
THE RESULT OF groupBR1
A
B
C
condition
x
y
1
(x + y = 3) ∨ (x > 4) ∨ (x < 0)
x
3
2
(x + y = 3 ∧ x < 2) ∨ (x < 0)
2
3
3
x > 5
2
3
4
TRUE
3
4
5
TRUE
Table X
EXAMPLE C-TABLE R
group ¯
A(T). The pseudo-code for performing the grouping
operator is shown in Algorithm 10.
The result of the grouping operation will be a nested c-
table, that is, the value of a ﬁeld in it may be a bag of values.
For example, in group ¯
A(T) the values for the attributes in
¯A will be single values and for the the rest of the attributes
- bag of values. The result of groupBR1 is shown in Table
IX, where R1 is shown in Table IV.
Theorem 20: The group operator is well deﬁned, that is,
group ¯
A(Rep(T)) ≡ Rep(group ¯
A(T)).
Proof: Line 1 copies T into the resulting c-table (our
running example is on the the c-table R shown in Table
XVIII and we show how to calculate groupA,B(R)).
Line 2 clusters the c-tuples into e-bags relative to the
attributes of ¯A. Table XI shows the two e-bags that will
A
B
C
condition
x
y
1
((x + y = 3) ∨ (x > 4) ∨ (x < 0)) ∧ t = 1
x
3
2
(x + y = 3 ∧ x < 2) ∨ (x < 0)
2
3
3
x > 5
2
3
4
TRUE
A
B
C
condition
x
y
1
((x + y = 3) ∨ (x > 4) ∨ (x < 0)) ∧ t ̸= 1
3
4
5
TRUE
Table XI
E-BAGS IN groupA,B(R)
4
1
1
2
4
2
4
1
2
4
Graph 1                        
Graph 2                        
Graph 3                        Graph 4                        
1
2
Figure 2.
The four possible graphs for the ﬁrst e-bag
C[i]
value
c-tuples
C[1]
x < 0 ∧ t = 1
{1, 2, 4}
C[2]
0 ≤ x < 2 ∧ x + y = 3 ∧ t = 1
{1, 2, 4}
C[3]
2 ≤ x ≤ 4 ∧ x + y = 3 ∧ t = 1
{1, 4}
C[4]
4 < x ≤ 5 ∧ t = 1
{1, 4}
C[5]
x > 5 ∧ t = 1
{1, 3, 4}
C[6]
x < 0 ∧ t ̸= 1
{2, 4}
C[7]
0 ≤ x < 2 ∧ x + y = 3 ∧ t ̸= 1
{2, 4}
C[8]
x > 5 ∧ t ̸= 1
{3, 4}
C[9]
(x + y ̸= 3 ∧ 0 ≤ x ≤ 4) ∨ (4 < x ≤ 5 ∧ t ̸= 1)
{4}
C[i]
value
c-tuples
C[1]
((x + y = 3) ∨ (x > 4) ∨ (x < 0)) ∧ t ̸= 1
{1, 2}
C[2]
((x + y ̸= 3) ∧ (0 ≤ x ≤ x)) ∨ (t = 1)
{2}
Table XII
THE ARRAY C FOR THE TWO E-BAGS
D[i]
values
c-tuples
D[1]
C[1] ∨ C[2]
{1, 2, 4}
D[2]
C[3] ∨ C[4]
{1, 4}
D[3]
C[5]
{1, 3, 4}
D[4]
C[6] ∨ C[7]
{2, 4}
D[5]
C[8]
{3, 4}
D[6]
C[9]
{4}
D[i]
values
c-tuples
D[1]
C[1]
{1, 2}
D[2]
C[2]
{2}
Table XIII
THE ARRAY D FOR THE TWO E-BAGS
be constructed after applying Line 2 to our example. Note
that Line 2 is equivalence preserving and that c-tuples from
different e-bags cannot contribute to the same resulting
nested c-tuple under any valuation. This is why it sufﬁces
to perform the group operation to the c-tuples in each e-bag
and then merge the results.
Line 3 partitions each e-bag further into r-bags. In other
words, we partition the space over which the local conditions
of the c-tuples in the e-bags is deﬁned into non-overlapping
polyhedra. Each r-bag corresponds to a set of disjoint
A
B
C
condition
x
y
1
y ̸= 3 ∧ x ̸= 2 ∧ R
x
3
2
y ̸= 3 ∧ x ̸= 2 ∧ R
2
3
4
y ̸= 3 ∧ x ̸= 2 ∧ R
x
y
1
2
x ̸= 2 ∧ y = 3 ∧ R
2
3
4
x ̸= 2 ∧ y = 3 ∧ R
x
y
1
x = 2 ∧ y ̸= 3 ∧ R
2
3
2
4
x = 2 ∧ y ̸= 3 ∧ R
x
y
1
2
4
x = 2 ∧ y = 3 ∧ R
R = ((x < 0 ∧ t = 1) ∨ (0 ≤ x < 2 ∧ x + y = 2 ∧ t = 1))
Table XIV
THE CONTRIBUTION OF THE FIRST R-BAG OF THE FIRST E-BAG TO THE
RESULT OF groupA,B(R)
268
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Algorithm 10 group ¯
A(T)
1: V ← T
2: Cluster the c-tuples of V into biggest bags of semi-uniﬁable c-tuples relative to ¯A - we will call this e–bags. If a c-tuple
belongs to more than one e-bag, then make copies of the c-tuple and put a copy in each e-bag. To do so, add the local
condition x = i to the ith copy of the c-tuple for i < u and the local condition
u−1
V
i=1
x ̸= i to the uth copy, where x is a
newly introduced variable and u is the number of times the c-tuple is copied.
3: Partition each e-bag further into r-bags. To do so, call break up(
pW
i=1
lc(ti)), where {ti}p
i=1 are the c-tuples in the e-bag
that is being processed. This will produce a set of non-overlapping conjunctions {ci}w
i=1. Let C = {ci}w
i=1. Rewrite the
local condition of each ti as a disjunction of cis. Next, break C into equivalence classes relative to the operation ∼. We
deﬁne ci ∼ cj exactly when the set of the rewritten local conditions in which the two conjunctions appear is the same.
Next, create an array D, where D[i] is the disjunction of all the conjunctions in the ith equivalence class. Reconstruct
V by substituting each e-bag with a bag of r-bags. The c-tuples in ith r-bag of a given e-bag will have the same local
condition as the corresponding value of D[i] and the main parts will correspond to the c-tuples that contained the local
conditions that formed the equivalence class corresponding to D[i].
4: From each r-bag, create a set of vertices, where each vertex corresponds to a distinct c-tuple in the r-bag (i.e., for
duplicate c-tuples we will have a single vertex). Next, ﬁnd all spanning undirected graphs that are transitive and have
the property that if there is an edge between the vertices n1 and n3 and there exists a third vertex n2 such that t1 ≺ ¯
A t2
and t2 ≺ ¯
A t3, where t1, t2 and t3 are the c-tuples corresponding to the vertices, then there are edges between n1 and
n2 and between n2 and n3.
Next, the set of nested c-tuples that correspond to each graph are created. Their union yields the result of doing the
grouping. More precisely, suppose that we are examining an r-bag r and a graph G associated with it. Since G is
transitive, it will contain a set of disjoint complete sub-graphs, where each such sub-graph will correspond to a resulting
nested c-tuples. If the vertices in the complete sub-graph belong to the c-tuples {ti}p
i=1, then the corresponding nested
c-tuple will have the single value (x1, . . . , xa) for the attributes ¯A, the bag of values {| π ¯
Bmain(ti)|}p
i=1 for the
attributes ¯B, and the local condition Lr ∧ RG ∧ (
pV
i=1
[(π ¯
Amain(ti)) = (x1, . . . , xa)]). The condition Lr is the local
condition of the r-bag r. The condition RG is the condition that projection on the ¯A attributes of the main parts of the
c-tuples that correspond to nodes in G that are connected should be equal, while the projection on the ¯A attributes of
the main parts of the c-tuples that correspond to nodes in G that are not connected should be distinct.
polyhedra. Note that this operation is equivalence preserving.
The additional constraint that all the conjunctions that form
the D[i] of a given r-bag appear in the same set of c-
tuples’ local conditions guarantees that the r-bags partition
the possible valuations, that is, under every valuation the
local condition of at most one r-bag of every e-bag will be
true. In other words, given an arbitrary valuation and an e-
bag of r-bags, either none of the c-tuples’ local conditions
will be true or the local conditions of all the c-tuples in
exactly one r-bag will be true. For our example, Tables XII
and XIII show the value of the C and D array, respectively.
Note that, in order to keep the example simple, the local
conditions are not normalized using the algorithm from [18].
Next, the algorithm constructs a set of graphs for each
r-bag, where each graph corresponds to a valuation. In a
graph, there is an edge between two vertices if under the
corresponding valuation it is true that π ¯
A(main(t′)) =
π ¯
A(main(t′′)), where t′ and t′′ are the c-tuples correspond-
ing to the vertices. A graph is valid, that is, a corresponding
valuation exists exactly when (1) the graph is transitive (2)
if there is an edge between the vertices n1 and n3 and
there exists a third vertex n2 such that n1 ≺ ¯
A n2 and
n2 ≺ ¯
A n3, then there are edges between n1 and n2 and
between n2 and n3. This is why all the graphs having these
two properties are constructed and these graphs show which
c-tuples in the r-bag will be grouped relative to the attributes
¯A under different valuations. Figure 2 shows the graph for
the ﬁrst r-bag of the ﬁrst e-bag, where the c-tuple numbers
are preserved from Table XI. The resulting c-tuples that are
constructed from the four possible graphs are shown in Table
XIV. ■
The following theorem proves the time complexity of
Algorithm 10.
Theorem 21: A variable c-tuple is a c-tuple that has
variables in it it, while a regular c-tuple is a c-tuple that
does not. Let v be the number of variable c-tuples in T, m
be the greater of the size of the longest c-tuple and the size
of the global condition of T, n be the number of regular
c-tuples with distinct main parts, r be the highest count of
regular c-tuples that have the same main part but distinct
local conditions, s be the number of attributes in T, and c
be a constant. Then the total time to perform Algorithm 10
269
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

is O((2v + n) · s + (2v + n) · 3
√
2
m·(v+r) · (m · (v + r))c +
(2v + n) · 2v+r · 2v+n).
Proof: Line 2 of Algorithm 10 takes O(2v + n) · s time
because it may take as much as O(2v · s) time to partition
the variable c-tuples and then O(n · s) time to determine
the groups for the regular c-tuples. Note that we get this
low time bound thanks to the fact that regular c-tuples with
distinct main parts can not appear in the same e-bag.
Line 3 will take O((2v+n)·3
√
2
m·(v+r)·(m·(v+r))c) time
because the size of a c-tuple’s local condition may grow to
a size of O(m · (v + r)) after the normalization procedure
from [18] is applied.
Line 4 takes O((2v +n)·2v+r ·2v+n) time because there
maybe as much as 2v+r r-bags in each e-bag and each r-bag
may contain as much as n+v distinct c-tuples and therefore
there are 2v+n possible graphs for each r-bag. ■
B. Performing the Aggregation
Now that we have deﬁned how grouping over c-tables
can be done, performing aggregation is straightforward. The
following deﬁnition contains the details.
Deﬁnition 18 (syntax and semantics of aggregation):
Let T be a c-table. We will denote a grouping by the
attributes ¯A = {Ai}a
i=1 and aggregation for the attributes
¯B = {Bi}b
i=1 as A1,...,AaFagg1(B1),...,aggb(Bb)T, where the
sets ¯A = A1, . . . , Aa and ¯B = B1, ..., Bb are disjoint and
their union yields all the attributes in T. The value for agg
can be min, max, sum, count, or avg. Algorithm 11 shows
the pseudo-code for performing the aggregation.
Algorithm 11 A1,...,AaFagg1(B1),...,aggb(Bb)T
1: V ← group ¯
AT
2: for t in V do
3:
perform the mapping from Table XV to Table XVI
on t, where {xi}i = 1n are new variables and the
function con is deﬁned in Table XVII.
4: end for
5: return V
Note that Line 3 of Algorithm 11 performs aggregating
over the ¯B attributes by introducing new variables in the
main parts of the result and moving the aggregations to the
local conditions.
Theorem 22: The aggregation operator that is deﬁned in
Algorithm 11 is well deﬁned.
Proof: The correctness of the grouping algorithm follows
from Theorem 20 and the correctness of the con operator.
Let us next examine the con operator. For the min operation
it adds the condition that the new variable must be smaller
than the value for the other c-tuples for that attribute in
the group, which is the desirable behavior. The correctness
of the max operation is analogous. The count operation is
implemented correctly because it returns the count of the c-
tuples in each group. The sum operation adds the condition
¯
A
¯B
condition
a1 . . . ak
b1
1 . . . b1
n
c
. . .
bp
1 . . . bp
n
Table XV
A COMPLEX C-TUPLE t
¯
A
¯B
condition
a1 . . . ak
x1 . . . xn
c ∧ con(x1, agg1, b1
1, . . . , bp
1)∧
· · · ∧ con(xn, aggn, b1
n, . . . , bp
n)
Table XVI
THE RESULT OF ¯
AFagg1(B1),...,aggn(Bn)(t)
that the value for the aggregate attribute must be equal to
the sum of the values for that attribute in each group, which
is the expected behavior. Finally, for the avg operator we
add the condition that x ∗ n must be equal to the sum of
the values for the aggregate attribute and therefore the new
value for the attribute will be
nP
i=1
bi
n
, which is exactly the
average operator. ■
Table XVIII shows the result of BFsum(A)R1, where
Table R1 is deﬁned in Table IV
VI. CONCLUSION AND FUTURE RESEARCH
In the paper, we presented algorithms for querying c-
tables extended with linear conditions using the closed world
assumption. We have chosen this representation because it
is the least expressive extension of c-tables over which bag
relational algebra with grouping and aggregation is closed
(agg)
con(x, agg, b1, . . . , bn)
min
nV
i=1
(x ≤ bi)
max
nV
i=1
(x ≥ bi)
count
n
sum
x =
nP
i=1
bi
avg
x + · · · + x
|
{z
}
n times
=
nP
i=1
bi
Table XVII
EXPLAINS THE OPERATOR con
A
B
condition
2
x
x ̸= 3 ∧ (x ̸= 4 ∨ FALSE)
2
4
TRUE ∧ (x ̸= 4 ∨ x = 3)
y
4
x ̸= 3 ∧ TRUE ∧ x = 4 ∧ y = 2 + 2
g.c. x ̸= 2
Table XVIII
THE RESULT OF BFsum(A)R1
270
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

and can be well deﬁned. As expected, the running time of
the presented algorithms is polynomial relative to the size of
the certain information and non-polynomial relative to the
size of the incomplete information.
A major topic for future research is optimizing the al-
gorithms for performing the different relational operations.
For example, in the relational case, the join between two
tables can be performed in different ways and the efﬁciency
of performing the join depends on the implementation. The
same applies for joining c-tables.
In general, there are different ways of performing the
deferent relational algebra operations over c-tables. The pur-
pose of this paper is to deﬁne their semantics by presenting
example algorithms for doing the operations. The presented
algorithms are not optimal and optimization techniques such
as dynamic programming and iterative dynamic program-
ming can be used to optimize the different relational algebra
operators over c-tables.
Other possible extensions of the presented work follow.
• Explore c-tables with variables over additional do-
mains, such as date or currency. • Speed up the presented
algorithms by sacriﬁcing their accuracy, that is, explore
approximate query answering for incomplete information.
• Explore integrity constraints for incomplete information
and how they can be used to perform semantic query
optimization.
• Extend research done in relational databases, such as re-
search on view maintenance, transaction control, logging and
recovery, to databases that contain incomplete information.
• Explore introducing an ordering of the c-tuples in a c-table
and deﬁning an order by operator.
REFERENCES
[1] L. Stanchev, “Querying Incomplete Information using Bag
Relational Algebra,” eKNOW 2010, Second International
Conference on Information Process, and Knowledge Manage-
ment, pp. 110–119, 2010.
[2] T. Imielinski and W. Lipski, “Incomplete Information in
Relational Databases,” Journal of Association of Computing,
vol. 31, no. 4, pp. 761–791, October 1984.
[3] L. Libkin and L. Wong, “Some Properties of Query Lan-
guages for Bags,” Proceedings of Database Programming
Languages, pp. 97–114, 1994.
[4] G. Grahne, The problem of Incomplete Information in Rela-
tional Databases.
Berlin: Springer-Verlag, 1991.
[5] R. Reiter, “A Sound and Sometimes Complete Query Evalu-
ation Algorithm for Relational Databases with Null Values,”
JACM, vol. 33, no. 2, pp. 349–370, 1986.
[6] L. Y. Yuan and D.-A. Chiang, “A sound and Complete Query
Evaluation Algorithm for Relational Databases with Null
Values,” ACM, 1988.
[7] L. Libkin, “Query Language Primitives for Programming with
Incomplete Databases,” Proceedings of DBPL, 1995.
[8] P. Buneman, A. Jung, and A. Ohori, “Using Powerdomains
to Generalize Relational Databases,” Theoretical Computer
Science, vol. 91, no. 1, 1991.
[9] R. Reiter, On closed world databases, Logic and databases.
Plenum Press, 1978.
[10] G. Grahne, “Dependency Satisfaction in databases with In-
complete Information,” Proceedings of International Confer-
ence on Very Large Data Bases, pp. 37–45, 1984.
[11] J. A. Biskup, “A Formal Approach to null Values in Database
Relations,” Advances in Database Theory, pp. 299–341, 1981.
[12] E. F. Codd, “Understanding Relations (Installment 7),” FDT
Bull. of ACM-SIGMOD, vol. 3, no. 4, pp. 23–28, December
1975.
[13] ——, “Extending the Database Relational Model to Capture
more Meaning,” ACM Transactions on Database Systems,
vol. 4, no. 4, pp. 397–434, December 1979.
[14] J. Grant, “Null values in Relational Data Base,” Information
Processing Letters, vol. 6, no. 5, pp. 156–157, October 1977.
[15] T. Imielinski and W. Lipski, “On Representing Incomplete
Information in a Relational Data Base,” Proceedings of the
7th International Conference on Very Large Data Bases, pp.
388–397, September 1981.
[16] M. Fischer and M. O. Rabin, “Super Exponential Complexity
of Presburger Arithmetic,” Project MAC Tech. Mem. 43. MIT,
1974.
[17] S.Basu, “New Results on Qunatiﬁer Elimination over Real
Closed Fields and Applications to Constraint Databases,”
JACM, vol. 46, no. 4, pp. 537–555, 1999.
[18] J. L. Lassez and K. McAloon, “Applications of a Canonical
Form of Generalized Linear Constraints,” Journal of Symbolic
Computation, vol. 13, pp. 1–24, 1992.
[19] J. L. Lassez, T. Huynh, and K. McAloon, “Simpliﬁcation and
Elimination of Redundant Arithmetic Constraints,” Proceed-
ings of NACLP, 1989.
[20] A. Tarski, “A Decision Method for Elementary Algebra and
Geometry,” University of California Press, 1951.
[21] F. Jerrante and C. Rackoff, “ A Decision Procedure for the
First Order Theory of Real Addition with Order,” SIAM
Journal of Computing, vol. 4, no. 1, pp. 69–76, 1975.
[22] D. Kossmann and K. Stocker, “Iterative Dynamic Program-
ming: A New Class of Query Optimization Algorithms,” ACM
Transactions on Database Systems, vol. 25, no. 1, 2000.
[23] G. Klir, U. Clar, and B. Yuan, Fuzzy Set Theory. Foundations
and Applications.
Prentice Hall, 1997.
[24] M. D. Springer, “The Algebra of Random Variables,” Wiley
series in probability and mathematical statistics, 1979.
271
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[25] G. Kuper, L. Libkin, and J. Paredaens, Constraint Databases.
Springer, 1998.
[26] G. M. Kuper, “Aggregation in Constraint Databases,” Pro-
ceedings of the 1st International Workshop on Principles and
Practice of Constraint Programming, pp. 161–172, 1993.
[27] J. Kleinberg, C. Papadimitriou, and P. Raghavan, “Auditing
Boolean Attributes,” PODS, pp. 86–91, 2000.
[28] A. Makinouchi, “A Consideration of Normal Form of
Non-necessarily-normalized Relations in the Relational Data
Model,” Proceedings. of International Conference on Very
Large Data Bases, pp. 447–453, 1977.
272
International Journal on Advances in Intelligent Systems, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/intelligent_systems/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

