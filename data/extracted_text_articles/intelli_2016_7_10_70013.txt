Optimizing Network Calls by Minimizing
Variance in Data Availability Times
Luis Neto1, Henrique Lopes Cardoso2, Carlos Soares3, Gil Gonc¸alves4
{lcneto, hlc, csoares, gil}@fe.up.pt
Faculdade de Engenharia, Universidade do Porto, Porto, Portugal
14ISR-P, Instituto de Sistemas e Rob´otica - Porto, Portugal
2LIACC, Laborat´orio de Inteligˆencia Artiﬁcial e Ciˆencia de Computadores, Porto, Portugal
3INESC TEC, Instituto de Engenharia de Sistemas e Computadores, Tecnologia e Ciˆencia, Porto, Portugal
Abstract—Smart Nodes are intelligent components of sensor
networks that perform data acquisition and treatment, by the
virtualization of sensor instances. Smart Factories are an applica-
tion domain in which dozens of these cyber-physical components
are used, ﬂooding the network with messages. In this work, we
present a methodology to reduce the number of calls a Smart
Node makes to the network. We propose grouping individual
communications within a Smart Node to reduce the number of
calls is important to improve the efﬁciency of the process. The
paper exposes and explains the Smart Node internal structure,
formally describing the problem of minimizing the number of
calls Smart Nodes make to Cloud Services, by means of a
combinatorial Constraint Optimization Problem. Using two Con-
straint Satisfaction Solvers, we have addressed the problem using
distinct approaches. Optimal and sub-optimal solutions for an
actual problem instance have been found with both approaches.
Furthermore, we present a comparison between both solvers in
terms of computational efﬁciency and show the solution is feasible
to apply in a real case scenario.
Keywords–Sensor
Simulation;
Combinatorial
Optimization;
Time Synchronization; Smart Nodes; Industrial Wireless Sensor
Networks.
I.
INTRODUCTION
Wireless Sensor Networks (WSN) consist of sensors
sparsely distributed over a given area to sense physical prop-
erties, such as luminosity, temperature, current, etc. They are
composed of sensor nodes which pass data until a destination
gateway is reached. Common applications are industrial and
environment sensing, where they can be used to perceive the
state of a machine and prevent natural disasters, respectively.
Gateways in WSN play a preponderant role, since they acquire
data from the sensors, do pre-processing and in more advanced
cases are responsible to send the data to cloud systems for
advanced processing. A Smart Node is a gateway that has
enhanced data processing, reconﬁguration and collaborative ca-
pabilities [1]. These components are nodes in Industrial Cyber
Physical Systems, wich operate and control Industrial Wireless
Sensor Networks. Considering a scenario that comprises a
reasonable number of these components, in which:
•
Gateways are in constant synchronization with In-
tra/Inter Enterprise Cloud systems.
•
Gateways perform collaborative tasks by talking over
the network.
•
Human Machine Interface devices proceed to on de-
mand requests to the Smart Nodes.
A large number of messages is expected generated by a
large number of devices and services.
Gateways collect data from different sensor types (eg:
humidity, current, pressure). These cyber-physical components
are coupled to industrial machines, along with several sensors,
which collect data about the operation of machines; ﬁnally, the
data collected is treated and synchronized with Cloud systems
for multiple purposes. The majority of sensors coupled to
industrial machines sample data at very different rates and
synchronize the collected data with the Smart Node, in the
respective sampling frequency. A Smart Node can embed a
set of different data treatment modules. These modules can
be instantiated to provide different ways of treating sensor
data in a way that can be represented as a graph (Fig. 1).
A gateway internal logic arrangement is represented using a
directed acyclic graph (DAG). The graph structure in Fig. 1
can be divided into three levels, each with a different la-
bel and color assignment: the Sensor Level includes sensor
instances (bottom level), providing data to the gateway; the
data treatment level (middle level), includes nodes representing
instances of algorithms embedded at the gateway that can treat
information in several ways (eg: aggregate data using mean or
other functions, perform trend analysis); the Network Level
(top level) includes nodes where the ﬂow resulting from the
lower level nodes can be redirected to subscribing hosts in the
network. This internal structure can be dynamically rearranged:
new sensors and data modules can be loaded into the Smart
Node; the connections between nodes can be reformulated to
synchronize and treat data in new ways.
A problem of efﬁciency emerges due to the different rates
at which the data is gathered from the different sensors. When
the data reaches the Network Level nodes, it is immediately
sent to the subscriber, a network Cloud service. Slight time
differences in the availability of data lead the Network Level
nodes to perform new and individual calls. If those time
differences were eliminated, Network Level nodes would be
synchronized and data from the different nodes could be
packed together, reducing the total number of calls made and
reducing the network trafﬁc heavily. To accomplish synchro-
nization among Network Level nodes, data buffers for all the
142
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-518-0
INTELLI 2016 : The Fifth International Conference on Intelligent Systems and Applications (includes InManEnt 2016)

Figure 1. Internal Gateway conﬁguration.
edges connecting nodes previous to a particular Network node
must be resized to compensate: (1) different time to process
data by Data Treatment level nodes, since each module takes
different time to process data; (2) different sampling rates of
sensors, a same number of samples is accumulated at different
times.
Taking advantage of the DAG representation of the gate-
way, we formulate and propose a solution to the problem as a
combinatorial Constraint Optimization Problem.
In Section II, a formal deﬁnition of the problem is pre-
sented. Section III shows literature review, the problem for-
mulation basis. In Section IV, the solving process is detailed
along with assumptions, constraints and technology that has
been used. In Sections IV and V, respectively, collected results
and conclusions are presented.
II.
PROBLEM DEFINITION
Each arc in the graph (see Fig. 1) has an associated buffer
bn,m. Given the fact that sensors are sampling at different
frequencies freq, these buffers are ﬁlled at different rates. We
deﬁne G as the set of nodes in a particular Gateway instance;
three subsets of nodes are contained in G : N ⊂ G is the
subset of Network Nodes (index k nodes); P ⊂ G is the
subset of data Processing Nodes (index j nodes); S ⊂ G is
the subset of Sensor Nodes (index i nodes). The subsets obey
to the following conditions:
G = N ∪ P ∪ S; N ∩ P = ∅; P ∩ S = ∅; N ∩ S = ∅
(1)
Nodes in N can be classiﬁed as consumers; nodes in S are
exclusively producers; nodes in P are both producers and
consumers. Edges between nodes can be deﬁned as:
en,m =
(1 if n is consumer of m : n ̸= m;
m ∈ P ∪ S and n ∈ N ∪ P
0 otherwise
(2)
As an example, we can observe in Fig. 1 that node j6
consumes from i4 (Sensor Level) and j3 which is in same
level (Processing Level) and all the k nodes (Network Level)
only consume from inferior levels. To help in the deﬁnition of
this problem, two additional subsets of nodes, containing the
connections of a given node, are deﬁned as follows:
Wn = {j : j ∈ P ∧ en,j = 1} , n ∈ N ∪ P
(3)
Equation 3 deﬁnes a subset of nodes in P, which are producers
for the given node n ∈ N ∪ P. As an example (Fig. 1), for
n = j6 : Wj6 = {j3}; for n = k3 : Wk3 = {j6, j4}; and for
n = j3 : Wj3 = ∅ since it does not consume from any Data
Processing nodes.
Xn = {i : i ∈ S ∧ xn,i = 1} , n ∈ N ∪ P
(4)
Equation 4 deﬁnes a subset of nodes in S, which are producers
for the given node n ∈ N ∪P. In Fig. 1, these are the nodes i
in the Sensor Level, from which Processing Level nodes and
Network Level nodes consume. As an example (Fig. 1), for
143
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-518-0
INTELLI 2016 : The Fifth International Conference on Intelligent Systems and Applications (includes InManEnt 2016)

n = k3 : Xk3 = {i6, i7}; for n = k1 : Wk1 = ∅ since it does
not consume from any Sensor Level node and for n = j6 :
Wj6 = {i4}.
A processing node in P applies an algorithm to transform the
data coming from its associated producers. The data generated
at the sensor level is delivered to the processing nodes as a
batch, which contains the number of samples equal to the size
of the buffer for the corresponding edge.
In order to the processing to be possible, the number of
elements in each collection must be the same. This constraint
must be applied to the subsets Wn and Xn of a given node n
in N ∪ P, respectively; for that constraint to be respected, the
size of every buffer associated to each element in Wn ∪ Xn
must be the same. Formally this constraint can be represented
as:
∀n ∈ N ∪ P, ∀m ∈ Wn ∪ Xn : |bn,m| = f(n)
(5)
Where |bn,m| represents the size of the given buffer for the
given edge en,m and f(n) is the size of any buffer from which
node n consumes.
The size of the buffer is adjustable and can vary from 1 to
1000. The objective of this problem is to arrange a combination
of values to parameterize the size of every buffer |b|, for every
arc in the graph, that minimizes the differences between times
at the Network Nodes in which data is available to be sent
to the network. To calculate the time that it takes data to be
available at every node k ∈ N, the times for all its providers
in the graph must be calculated. As data comes in collections
(sets of single values), let us deﬁne burst as the exact time at
which data is sent from one provider node to a consumer node
and represent the burst of a node n as Bn.
The burst of a Sensor Node i, is deﬁned by the product of its
sampling frequency and the size of the buffer associated to the
edge en,i we are assuming. That way, every time a sample from
a sensor is collected, that sample is sent to all consumers of
that sensor. A burst of a Sensor Node to an adjacent consumer
node m occurs when the buffer for the edge ei,m is completely
ﬁlled, and is formally represented by the expression:
Bi,m = freq(i)×|bi,m|×ei,m = 1; ∀i ∈ S ∧m ∈ P ∪N (6)
For a Data Processing Node, the burst time must contemplate
all the burst times from its providers, the time that it takes
the associated function T(f(n)) to treat one data sample and
the size of the buffer associated to the edge en,m we are
assuming. The expression which determines burst time for a
Data Processing Node j to a consumer node m is deﬁned as:
Bj,m = (maxi∈Wj∪Xj(Bi,j) + T(fj) × (|Wj| + |Xj|)) × |bj,m|; ej,m = 1 (7)
We assume that the growth in time complexity of the function
T(fn) : n ∈ P is linear with the number of samples to process.
Since the size of each producer buffer is equal, we multiply
the total number of producers of j by the cost of treating a
single sample. To calculate the burst for j1 (see Fig. 1), we
take the max burst of Xj1 and sum the product of T(fj1) (time
to process one sensor sample) with the number of elements in
Xj1 (which corresponds to the producers i1, i2 and i3).
Finally, to calculate the burst of a Network Node k ∈ N:
Bk =
max
i∈Xk∪Wk(Bi,k)
(8)
Using the expression to calculate the burst for each Network
Node, the objective is to minimize the variance of burst for
all the Network Nodes and minimize buffer sizes. By varying
the size of the buffers in the graph, the variance of all burst
times for Network Nodes and the summation of all buffer sizes
are minimized. With a variance of zero or closer, data from
different Network Nodes can be packed in the same payload
and sent to the subscribers in the network. Even if the quantity
of data exceeds the maximum payload size for the protocol
or the physical link being used, the number of connections
needed is far less than it is in independent calls. The number
of buffers |P ∪ N|, times an upper bound buffer size of 1000
is multiplyed by the variance. This way, the variance has more
impact in the search of an optimal solution than the summation
of all buffer sizes.
ˆV (Bk) × 1000 × |P ∪ N| +
X
n∈|P ∪N|
X
m∈Wn∪Xn
|bn, m| (9)
As follows from Equation 9, minimizing variance of burst
times for network nodes is the major concern. To reﬂect this,
variance is multiplied by the maximum possible size for a
buffer (1000, which is a reasonable number of samples for a
sensor), times the number of Processing and Network nodes.
This will drive the solver to focus on a solution with less
variance, and break ties by considering the minimal buffer
sizes (as these incur a cost). With a variance of 0 for the bursts
at the Network Level nodes, all data produced can be sent to
the cloud using the same call. If variance is higher than 0,
a threshold must be used to decide the maximum reasonable
time to wait between bursts. In comparison with individual
calls strategy – a call made every time a burst at the Network
Level occurs – the number of calls to the cloud is minimized as
a consequence. The theoretical search space of the problem is
En, where E represents the total number of edges in the graph
and n = 1000 is the Buffer Size domain upper bound. The real
search space, imposed by the constraint of the Equation 5, can
be determined by F n, where F = |P|+|N| is the total number
of Processing and Network nodes in the graph.
III.
RELATED WORK
The theoretical background behind this problem has a large
spectrum of application. The problem of modeling buffer sizes
is mostly applied to network routing, where the works [2],[3]
and [4] are examples. As we are not interested in dealing with
networks intrinsic characteristics, those buffer optimization
problems can hardly be extrapolated to this work. The domain
of Wireless Sensor Networks (WSN) is another scope of
application of buffer modeling optimization, with relevant
literature in this domain; the section of Routing problems in [5]
covers a great number of important works regarding Flow
Based optimization models, for data aggregation and routing
problems. WSN optimization models care with constraints that
this problem modulation does not cover, such as: residual
144
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-518-0
INTELLI 2016 : The Fifth International Conference on Intelligent Systems and Applications (includes InManEnt 2016)

energy of nodes, link properties, network lifetime, network
organization and routing strategies.
A relevant work in WSN revealed to be of the major
interest for this work. The authors presented and solved
the problem of removing inconsistent time offsets, in time
synchronization protocols for WSN [6]. The problem presented
has an high degree of similarity with the case we are dealing.
The problem is represented by a Time Difference Graph (TDG),
each node is a sensor, every sensor has local time and every
arc has an associated cost time given by a function. The
solution to the problem is given by a Constraint Satisfaction
Problem (CSP approach. For every arc in the graph there exists
an adjustment variable (analogous to the buffer size in this
case), assignments are made to the variables to ﬁnd the largest
consistent subgraph, ie. a sub-graph in which inconsistent time
offsets are eliminated.
Focusing the search in the literature domain of CSP
problems, several works were revealed in the sub-domain
of balancing, planning and scheduling activities that can be
related to this application [7][8][9][10][11]. Namely, models of
combinatorial optimization for minimizing the maximum/total
lateness/tardiness of directed graphs of tasks with precedence
and time constraints [7][11]. These problems are analogous
to this work, and due to a simpliﬁed formulation with the
same constraints (precedences and time between nodes), can
be easily extrapolated to our case.
IV.
IMPLEMENTING AND TESTING
This section starts by stating the assumptions made and
introducing the constraint satisfaction solvers used. The last
part of this section describes in detail how tests were performed
and the implementation of the solution in both solvers.
A. Problem Assumptions
The Smart Node application has several interfaces for real
sensors, ranging from radio frequency to cable protocols. By
testing this model with simulated scenarios, we assume no
interference or noise of any type can cause disturbance in the
sampling frequency. In a real case scenario, a sensor could
enter in an idle state for a variety of reasons. In that case, data
would not be transmitted at all, causing the transmission of
data to the Cloud to be postponed for undeﬁned time, waiting
for the Network Level node burst depending on the idle sensor.
For simpliﬁcation, we assume a sensor never enters an idle
state. Also, it is assumed that the time that takes to treat one
collection of data will increase linearly for more than one
collection, as mentioned for T(fj) when introducing Equation
7.
B. Constraint Satisfaction Problem Solvers
For comparison of performance purposes we implemented
the problem using both OptaPlanner and SICStus Prolog. As
the Smart Node is implemented in Java we can take advantage
of a direct integration with OptaPlanner in future. On the
other hand, we expected that SICStus Prolog would produce
the same results with better computation times because of the
lightweight implementation and optimized constraint library.
Using this premises and the results presented in the next
section a grounded decision about what solver to use in future
implementations of the Smart Node can be made.
C. Tests
To validate the problem solutions several graph conﬁgura-
tions were tested using the two implemented versions, based on
OptaPlanner and SICStus Prolog, as described in Section IV.
To test the implementations an algorithm to generate instances
of the problem was built. The script generates instances of the
Smart Node internal structure, DAG’s, with a given number of
Processing and Network nodes. Algorithm 1 brieﬂy illustrates
the approach:
Data: G ← S ∪ P ∪ N
Result: Smart Node internal conﬁguration G
notV isitedNodes ← G;
Pnodes ← randomInteger( |P ∪N|
2
, |P ∪ N| − 2);
Nnodes ← nNodes − Pnodes;
Snodes ←
randomInteger( nNodes
2
, nNodes + nNodes
2
);
G ← S, P, N ←
generateNodes(Snodes, Pnodes, Nnodes);
remainingEdges ← Pnodes × 2 + Nnodes + Snodes;
while remainingEdges > 0 do
if node ← notV isitedNodes.nextNode() then
notV isitedNodes.remove(node);
else
node ← G.randomNode();
end
if node is S then
connect to a random P or S node, disconnected
nodes ﬁrst;
remainingEdges − −;
else if node is P then
get connection from a random P or S node,
disconnected nodes ﬁrst;
connect to a random P or S node, disconnected
nodes ﬁrst;
remainingEdges − −;
remainingEdges − −;
else
get connection from random a P or S node,
disconnected nodes ﬁrst;
remainingEdges − −;
end
end
Algorithm 1: Smart Node instance generation.
Real scenarios generally have a higher number of Sensor
Nodes, followed by a small number of Processing Nodes and
an even smaller number of Network Nodes. Typically the total
number of nodes does not exceed the 30 per operation. The
generator picks aleatory numbers for the nodes bounded by
a real case scenario application. Sampling frequencies for the
sensors are assumed to vary from 400 to 2000 milliseconds.
Functions to treat data in Processing Nodes are not typically
complex. We measured the real case scenario functions to treat
the minimum amount of data (1 sample) and we got values
ranging from 0.19 to 0.38 milliseconds. To cover the buffer
size domain, we need to take the worst case, 1000 samples.
Given best and worst cases, the values attributed to cost of
Processing Nodes ( T(fj) in Equation 7) are between 1 and
40 milliseconds.
145
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-518-0
INTELLI 2016 : The Fifth International Conference on Intelligent Systems and Applications (includes InManEnt 2016)

1) OptaPlanner: This solver [12] is a pure Java constraint
satisfaction API and solver that is maintained by the RedHat
community, and it can be embedded with the Smart Node
application to execute and provide on demand solutions to our
optimization problem. Because of the reconﬁgurable property
of the Smart Node internal structure, each time the structure
is rearranged, the solution obtained to the problem instance
prior to the reconﬁguration becomes infeasible. The integration
(see Fig. 3) between the two technologies is accomplished by
deﬁning the problem in the OptaPlanner notation: (1) Buffer
Size class corresponds to the Planning Variable, during the
solving process it will be assigned by the different solver
conﬁgurations; (2) Edge class is the Planning Entity, the
object of the problem that holds the Planning Variable; (3)
SmartNodeGraph class is the Planning Solution, the object
that holds the problem instance along with a class that allows
to calculate the score of problem instance. The score is given
by implementing Equation 9; the best hard score is 0, which
corresponds to null variance between the Network Levels
nodes. The soft score correspond to the minimization of the
summation of all buffer sizes and does not weight as much as
hard score in search phase.
Since the search space is exponential, heuristics can be imple-
mented to help the OptaPlanner solver to determine the easiest
buffers to change. The implemented heuristic sorts the buffers
from the easiest to the hardest. The sorting values are given
by the number of ancestors of a given edge, an edge with a
greater number of ancestors is more difﬁcult to plan. Also, if an
edge leads to a Network Node, it is considered more difﬁcult to
plan. OptaPlanner offers a great variety of algorithms to avoid
the huge search space of most CSPs. These algorithms can be
consulted in the documentation [13] and conﬁgured to achieve
best search performances. For a correct comparison we used
the Branch and Bound algorithm, which is the same algorithm
that SICStus Prolog uses by default, without heuristics.
Figure 2. UML for Smart Node and OptaPlanner integration.
The UML diagram in Fig. 3 shows the modeling of the
problem using the OptaPlanner methodology.
2) SICStus Prolog: SICStus Prolog [14] provides several
libraries of constraints that allow to model constraint satis-
faction problems much more naturally than the OptaPlanner
approach, which follows from the fact that modeling a problem
in SICStus Prolog takes advantage of the declarative nature of
logic programming. The problem modeling involved four types
of facts (to represent N, P and S nodes, and to represent
edges) and six predicates (to gather variables, express domain
and constraints). The clpfd (Constraint Logic Programming
over Finite Domains) [15] library was used to model and solve
the problem. This library contains several options of modeling
that can be used to optimize the labeling process. In our case
the labeling process takes as objective the minimization of
the difference between the Network Node with the maximum
burst time and the one with the lowest burst time (Equation
9). The variables of the problem are given by a list of all
the facts edge(from,to,buffer size)., where buffer size are the
variables to solve in a ﬁnite domain from 1 to 1000. In
future implementations of the problem, global constraints and
labeling options must be analyzed to ensure the modulation is
the most optimized.
V.
RESULTS
For both implementations the results are shown in Tables I
and II. The results shown, are a mean of 5 different problem in-
stances, for each problem size (which is determined by |P ∪N|,
see Section II. To gather results, the generator was used to
generate 5 instances of the problem for each row. Then, both
solvers were used in the same machine (Intel(R) Core(TM)
i7-4710HQ CPU @ 2.50GHz (8 CPUs), 2.5GHz, 16384MB
RAM), with the same conditions (Windows 10 Home 64-
bit), to run the tests. Considering that the solution will run
online (in idle CPU time), and that a suboptimnal solution
will also reduce heavilly the network traﬁc, by introducing a
time window to compensate residual variance. We established
a limit of 60s, which was considered acceptable for the solvers
to ﬁnd a feasible solution in a real case. Another limit was the
number of nodes used in the experiences. With a number of
nodes in the order of 100, and a time window of 8 hours, both
solvers were unable to give a response to most cases. Given
the complexity stated, and given the fact that in real cases the
number of nodes normally does not exceed 30, 50 nodes was
the limit used for the tests.
The quality of the solutions found is mostly given by the
second column, which represents the constraint of minimizing
the burst times at the Network Level. As we can see (Table
II), the SICStus Prolog implementation shows the best results
for the most relevant quality factor. In the third column, the
summation of all the buffer sizes is lower in the OptaPlanner
implementation (Table I). During the tests, we observed in the
logs that the OptaPlanner was much more slower walking the
search tree. Regarding all the columns, a clear tendency to
worst results is obvious along the table, but in the last line of
both tables, a sudden improvement in the variance occurs. This
behavior enforces the NP-Completeness nature of this kind of
problems. In every row of both tables in which a Solution
time of 60 seconds is found, that row matches a sub-optimal
solution. Since both solvers were programmed to stop at 60
seconds, mostly the solutions are not optimal. The sub-optimal
solutions found are feasible in a real case, even if the variance
between call times is not zero, because the gap is heavilly
146
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-518-0
INTELLI 2016 : The Fifth International Conference on Intelligent Systems and Applications (includes InManEnt 2016)

TABLE I. OPTAPLANNER RESULTS
TABLE II. SICSTUS RESULTS
reduced. Theoretically, every reduction in the variance is a
better solution, in practice, a minimum acceptable value for
variance needs to be deﬁned. The Smart Component can deﬁne
a time window with the size of the variance, and this way,
include all results in the same call.
VI.
CONCLUSION AND FUTURE WORK
Despite the search space of the problem, both solvers
reached an optimal solutions in cases that are feasible to real
application. In the future, tuning options of the solvers must
be explored. Another additional constraint to this problem
could be the introduction of a case in which a single or
several sensors are producing data with an higher priority.
The problem can be easily reformulated to embrace that
kind of situation modifying the objective function Equation
9. SICStus Prolog shows a clear advantage in computation
time. That difference can be the reﬂex of the number of
lines of code needed to model the problem. SICStus Prolog
required eight procedures (predicates), against 10 classes and
1 XML conﬁguration ﬁle for the OptaPlanner implementation.
The difference in modeling complexity possibly causes an
additional overhead. Another important remark is that, given
the experience of implementing the problem and playing with
the solvers options, two contrasts can be highlighted: (1)
SICStus Prolog is very intuitive at the problem modeling phase,
on the other hand, OptaPlanner required more effort, both in
implementing an perceiving the methodology; (2) tuning the
solvers, for example the time out feature that allows to stop the
solver in the desired time, is more intuitive in the OptaPlanner
approach. Considering all pros and cons, SICStus Prolog most
probably will be chosen to integrate the Smart Node in future
work. This experiments were made ofﬂine, as future work,
the Smart Component can embedd the optimization code and
adopt a strategy to optimize the variance in idle CPU time
until an optimal solution is found online. Although the time
limit used was short, in a continuous operation environment,
even if running in idle CPU time, the solvers will gradually
converge to an optiomal solution.
REFERENCES
[1]
L. Neto, J. Reis, D. Guimaraes, and G. Goncalves, “Sensor cloud:
Smartcomponent framework for reconﬁgurable diagnostics in intelligent
manufacturing environments,” in Industrial Informatics (INDIN), 2015
IEEE 13th International Conference on.
IEEE, 2015, pp. 1706–1711.
[2]
I. Ioachim, J. Desrosiers, F. Soumis, and N. B´elanger, “Fleet assign-
ment and routing with schedule synchronization constraints,” European
Journal of Operational Research, vol. 119, no. 1, 1999, pp. 75–90.
[3]
K. Avrachenkov, U. Ayesta, E. Altman, P. Nain, and C. Barakat, “The
effect of router buffer size on the tcp performance,” in In Proceedings of
the LONIIS Workshop on Telecommunication Networks and Teletrafﬁc
Theory.
Citeseer, 2001.
[4]
K. Avrachenkov, U. Ayesta, and A. Piunovskiy, “Optimal choice of
the buffer size in the internet routers,” in Decision and Control, 2005
and 2005 European Control Conference. CDC-ECC’05. 44th IEEE
Conference on.
IEEE, 2005, pp. 1143–1148.
[5]
A. Gogu, D. Nace, A. Dilo, and N. Meratnia, Review of optimization
problems in wireless sensor networks.
InTech, 2012.
[6]
M. Jadliwala, Q. Duan, S. Upadhyaya, and J. Xu, “On the hardness
of eliminating cheating behavior in time synchronization protocols for
sensor networks,” Technical Report 2008-08, State University of New
York at Buffalo, Tech. Rep., 2008.
[7]
J. Błazewicz, W. Kubiak, and S. Martello, “Algorithms for minimizing
maximum lateness with unit length tasks and resource constraints,”
Discrete applied mathematics, vol. 42, no. 2, 1993, pp. 123–138.
[8]
B. Gacias, C. Artigues, and P. Lopez, “Parallel machine scheduling
with precedence constraints and setup times,” Computers & Operations
Research, vol. 37, no. 12, 2010, pp. 2141–2151.
[9]
K. Rustogi et al., “Machine scheduling with changing processing
times and rate-modifying activities,” Ph.D. dissertation, University of
Greenwich, 2013.
[10]
A. Malapert, C. Gu´eret, and L.-M. Rousseau, “A constraint program-
ming approach for a batch processing problem with non-identical job
sizes,” European Journal of Operational Research, vol. 221, no. 3, 2012,
pp. 533–545.
[11]
J. H. Patterson and J. J. Albracht, “Technical noteassembly-line bal-
ancing: Zero-one programming with ﬁbonacci search,” Operations Re-
search, vol. 23, no. 1, 1975, pp. 166–172.
[12]
O. Team, OptaPlanne - Constraint Satisfaction Solver, Red Hat.
[Online]. Available: http://www.optaplanner.org/
[13]
——,
OptaPlanner
User
Guide,
Red
Hat.
[On-
line].
Available:
http://docs.jboss.org/optaplanner/release/6.3.0.Final/
optaplanner-docs/pdf/optaplanner-docs.pdf
[14]
M. Carlsson, J. Widen, J. Andersson, S. Andersson, K. Boortz, H. Nils-
son, and T. Sj¨oland, SICStus Prolog user’s manual.
Swedish Institute
of Computer Science Kista, Sweden, 1988, vol. 3, no. 1.
[15]
M. Carlsson, G. Ottosson, and B. Carlson, “An open-ended ﬁnite do-
main constraint solver,” in Programming Languages: Implementations,
Logics, and Programs.
Springer, 1997, pp. 191–206.
147
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-518-0
INTELLI 2016 : The Fifth International Conference on Intelligent Systems and Applications (includes InManEnt 2016)

