Table Reference-Based Acceleration of
a Lithography Hotspot Detection Method Based on Approximate String Search
Shuma Tamagawa, Masato Inagi, Shinobu Nagayama, Shin‚Äôichi Wakabayashi
email: shuma@lcs.info.hiroshima-cu.ac.jp, {inagi, s naga, wakaba}@hiroshima-cu.ac.jp
Graduate School of Information Sciences, Hiroshima City University
3-4-1 Ozuka-higashi, Asaminami-ku, Hiroshima, 731-3194 Japan
Abstract‚ÄîIn nanoscale large-scale integration (LSI) manufac-
turing, there exist hotspots on mask patterns, which cause
failures of pattern transfer. Such hotspots are detected by optical
simulation to remove them. However, it requires a long time.
Thus, development of efÔ¨Åcient hotspot detection methods is
required. As one of the methods, an existing one based on
approximate string search has been proposed. Although this
method is expected to Ô¨Ånd hotspots more Ô¨Çexibly than commonly-
used template matching, computation of edit distance matrices
used for approximate string search still requires a long time.
Thus, in this study, we accelerate the computation by using table-
reference of precomputed values and simultaneous computation
of multiple elements. Our experiments showed that our improved
method achieved about 1/11 computation time compared to the
original one.
Keywords‚Äìlithography; hotspot; optical simulation; approximate
string matching.
I.
INTRODUCTION
In nanoscale large-scale integration (LSI) manufacturing,
lithography process is one of the most important processes,
in which mask patterns printed on photomasks are transferred
to the wafer using exposure equipment. In the process, some
patterns tend to be failed to be transferred because of optical
diffraction. Such patterns are called hotspots [1].
Since the cost of manufacturing photomasks is quite high, it
is better to remove hotspots from the mask patterns in advance.
Thus, lithography engineers apply optical simulation to the
mask patterns received from mask designers. If hotspots are
found by the optical simulation, it is informed to the designers,
and the patterns are revised. This is repeated until all the
hotspots are removed. However, optical simulation is time-
consuming. To reduce the number of times of optical simu-
lation, mask designers need to detect and remove hotspots in
advance. Therefore, some studies on efÔ¨Åcient hotspot detection
have been conducted [2]‚Äì[6]Ôºé
[2] proposed a template-matching-based method, which
directly matches mask patterns and hotspot patterns. A mask
pattern and a hotspot pattern are shown in Figure 1, as
examples. A hotspot pattern is a pattern which should be
detected from a mask pattern. While this method has a high
ability to detect known patterns, its ability to detect unknown
patterns is low. [3] discussed some hotspot detection meth-
ods using some machine-learning methods, such as artiÔ¨Åcial
neural network (ANN) and support vector machine (SVM).
According to the nature of machine-learning-based methods,
they can detect unknown patterns as hotspots. However, they
cause a large number of false-positive detections. [4] proposed
a hybrid method based on template matching and machine-
learning. Though the hybrid approach improved the accuracy
of detection, the number of false-positive detections is still
large. In addition, it takes 10 to 100 times longer for detection.
[5] adopted a fuzzy-matching model instead of ANN or SVM.
They improved both of execution time of detection and the
accuracy of detection. Although there exist aforementioned
hotspot detection methods, some mask designers use template-
matching to detect hotspot patterns since their execution time
and accuracy do not meet the level required by the designers.


Figure 1. Circuit patterns: (a) mask patternÔºå(b) hotspot pattern
In [6], we proposed an approximate string matching-
based hotspot detection method for Ô¨Çexible hotspot detection.
Comparing to machine-learning-based methods, this method
can detect hotspot candidates in a short time. Comparing
to template-matching-based methods, this method can detect
hotspot candidates more Ô¨Çexibly (i.e., unknown patterns can
be detected.) However, to calculate the value of each element
in the edit distance matrix for approximate string matching, we
need to refer to three elements in the matrix. Thus, comparing
to template-matching-based methods, in which only one value
is referred for the corresponding calculation, it takes a longer
time for calculation (although it is just a constant coefÔ¨Åcient
factor).
Thus, in this paper, we improve the approximate string
matching-based method [6] by using table-reference of pre-
computed values and simultaneous calculation of multiple
elements in the edit distance matrix. Each region of simulta-
neously handled elements is a k √ó k partial matrix of the edit
distance matrix, where k is the user-deÔ¨Åned constant which
decides parallelism. In the proposed method, the calculation of
a region for every possible input set is performed in advance,
and the result is memorized in a reference-table. Then, the
8
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-585-2
CENICS 2017 : The Tenth International Conference on Advances in Circuits, Electronics and Micro-electronics

edit distance matrix is calculated by using the table. For
efÔ¨Åcient calculation, the values in a region is encoded to one
word of memory to calculate the values of multiple elements
with only one memory access. Experimental result showed the
high effectiveness of the proposed method in execution time
compared to the existing method [6].
The rest of this paper is organized as follows. First, in
Section II, we explain about lithography, and we provide the
deÔ¨Ånitions of the approximate string matching problem, the
edit distance, the approximate string search problem, which
is one of the variations of the approximate string matching
problem, and on which our proposing method and [6] are
based. Next, in Section III, the deÔ¨Ånition of the hotspot
detection problem and the existing hotspot detection method
[6] are shown. Then, in Section IV, we propose an improved
method which uses table-reference. Section VI shows some
experimental results, and Ô¨Ånally conclusions are given in
Section VII.
II.
PRELIMINARIES
A. Lithography
Lithography is one of the processes of LSI manufacturing.
In the process, a circuit pattern drawn on a photomask is trans-
ferred to the wafer using exposure equipment. A photomask
is one of the masters to make a circuit on the wafer.
Figure 2 illustrates lithography process. In lithography
process, a mask pattern drawn on a photomask is transferred
onto the wafer via lenses, shedding light from above the
photomask. While 193nm laser is commonly used in advanced
lithography processes [7], the minimum pitch between wires
is decreasing, and has reached 14nm. Therefore, some sub-
patterns cannot be transferred correctly because of diffraction
of light. Such a sub-pattern is called a hotspot. An example of
a mask pattern is shown in Figure 3(a). The transferred image
(by optical simulation) of Figure 3(a) is shown in Figure 3(b).
In Figure 3(b), wires are connected at an unintended position,
and some wires are too thin. Therefore, the pattern shown in
Figure 3(a) is a hotspot pattern.

	


	










	
Figure 2. Principle of photolithography process
B. Approximate String Matching Problem
Approximate string matching problem [8] is one of the
string matching problems, and is a problem to determine if
two given strings are similar or not. In this study, the similarity
between strings is measured by the edit distance explained in
(a)
(b)
Figure 3. Hotspot: (a) mask pattern, (b) its transferred image
the next subsection. If the edit distance is less than or equal
to a given threshold, we consider they are similar each other.
C. Edit Distance
Let us consider a pair of characters (a, b)(Ã∏= (œµ, œµ)), where
œµ is an empty character, which represents nonexistence of any
character. The operation transforming character a in a string
into b is called an edit operation, and is denoted by a ‚Üí b.
For example, let us consider a string A = gzh. If an edit
operation g ‚Üí f is applied to the Ô¨Årst character of A, we
get A
‚Ä≤ = fzh as the resultant string of the operation. If an
edit operation z ‚Üí œµ is applied to the second character of A,
we get A
‚Ä≤ = gh. If an edit operation œµ ‚Üí j is applied to
the empty character between the second and third characters
of A, we get A
‚Ä≤ = gzjh. Hereinafter, we call an operation
a ‚Üí b a substitution if a Ã∏= œµ and b Ã∏= œµ. Likewise, we call
an operation a ‚Üí œµ a deletion, and call an operation œµ ‚Üí b
an insertion. Any string can be transformed into an arbitrary
string by applying the edit operations. An edit operation has
its cost denoted by Œ≥(a ‚Üí b). We assume the costs of edit
operations satisfy the equation below.
Œ≥(a ‚Üí a) = 0
Œ≥(a ‚Üí b) + Œ≥(b ‚Üí c) ‚â• Œ≥(a ‚Üí c)
Suppose strings A and B on alphabets Œ£ are given. A sequence
of edit operations to transform A into B is denoted as O =
o1, o2, . . . , om. The cost of O is deÔ¨Åned as
Œ≥(O) =
m

i=1
Œ≥(oi).
The minimum value among the costs of all the sequences each
of which transforms A into B is deÔ¨Åned as the edit distance
between A and B [8].
D. Approximate String Search Problem
Approximate string search is to Ô¨Ånd substrings similar to
a given pattern in a long input sequence. More precisely,
approximate string search is to Ô¨Ånd all the substrings whose
edit distance to the pattern P are the minimum among all the
substrings (or less then the given threshold t), in the input
sequence S.
We here explain a dynamic programming-based (DP-based)
algorithm for approximate string search [8], [9]. Prepare an
(n + 1) √ó (m + 1) two-dimensional array D, where D has
n + 1 rows and m + 1 columns, n is the length of the pattern
P = a1a2 ¬∑ ¬∑ ¬∑ an, and m is the length of the input sequence
S = b1b2 ¬∑ ¬∑ ¬∑ bm. An element D(i, j) (at (i+1)-th row, (j+1)-
th column) of D is deÔ¨Åned by the following equations:
9
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-585-2
CENICS 2017 : The Tenth International Conference on Advances in Circuits, Electronics and Micro-electronics

D(0, 0) = 0, D(0, j) = 0,
D(i, 0) = D(i ‚àí 1, 0) + del(ai),
D(i, j)
= min{
D(i ‚àí 1, j) + del(ai),
D(i, j ‚àí 1) + ins(bj),
D(i ‚àí 1, j ‚àí 1) + sub(ai, bj) }
where the functions ins, del, and sub denote the insertion,
deletion, and substitution costs. Figure 4 illustrates the DP-
based calculation of an edit distance matrix, and Figure 5
shows the resultant edit distance matrix. D is called edit
distance matrix, and D(n, j)(1 ‚â§ j ‚â§ m) gives the edit
distance between the pattern P and a substring (whose terminal
character is bj) in the input sequence S. If the value is
the minimum among all the D(n, j)(j = 1, 2, . . . , m) (or
less than the user-deÔ¨Åned threshold t), we consider that the
substring is similar to the pattern. The initial character of such
a substring is found by tracing back the DP-based calculation
on D. Figure 6 illustrates how to identify similar substrings.
The details of the identiÔ¨Åcation of similar substrings in our
proposed method are explained in Section III.



       
      
       
  
       
      
    
	
		










	





	

	

	
	

	

Figure 4. Calculation of edit distance matrix



       
      
       
      
       
      
       
      
       
      
	
		










	





	

Figure 5. Edit distance matrix
III.
HOTSPOT DETECTION BASED ON APPROXIMATE
STRING SEARCH
In this section, the existing hotspot detection method based
on approximate string search [6], which we improve in this
study, is explained. In this method, the mask pattern and
a hotspot pattern, which are both two-dimensional data, are
transformed into one-dimensional strings to apply approximate
string search calculating array D by dynamic programming.
 	














	



       
      
       
      
       
      
       
      
       
      
	
		










	


	
	





	

	
	
	


	


	



Figure 6. IdentiÔ¨Åcation of similar substrings
A. Transformation into One-dimensional Data
Mask patterns and hotspot patterns are image data. We
transform them into two-dimensional array of characters, in
which wire area is represented by 1 and empty area is
represented by 0.
An example is shown in Figure 7. In the left image in it,
the white areas represent wires (or other objects), and the black
area represents an empty space.

























	




	

Figure 7. Image data and its corresponding array
We
transform
the
two-dimensional
arrays
into
one-
dimensional data. First, the two-dimensional array of the mask
pattern is divided into rows. Then, the tail of the Ô¨Årst row and
the head of the second row are connected. And, the tail of the
second row is connected to the head of the third row. Likewise,
all the rows are connected and the two-dimensional mask
pattern is transformed into one-dimensional data (Figure 8).

	

	
		
	
	
	


	
Figure 8. Transformation of mask pattern data
Next, the array of the hotspot pattern is divided into rows,
like the transformation of the mask pattern. Then, for each
10
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-585-2
CENICS 2017 : The Tenth International Conference on Advances in Circuits, Electronics and Micro-electronics

row, don‚Äôt-care characters are added so that the number of
characters of the row becomes equal to that of a row of the
mask pattern (Figure 9). A don‚Äôt-care character is the special
character which matches any character. By adding don‚Äôt-care
characters, mismatch of the positions of the head characters
of the rows of the hotspot pattern is corrected. Note that
such consecutive don‚Äôt-care characters can be substituted by
a special character, called a large-don‚Äôt-care, to efÔ¨Åciently
calculate the edit distance matrix [6]. Hereinafter, the hotspot
pattern is processed just like the mask pattern.












	
	
	

	

	
		
	



	


	




Figure 9. Transformation of hotspot pattern data
B. Dynamic Programming
In both of our proposed method and our previous one [6],
since hotspot candidates are searched by using approximate
string search, array D is calculated by using the dynamic
programming shown in the previous section. Except the Ô¨Årst
row and column, the value of each element of the array D is
calculated by using the value of its upper, left and upper-left
elements. These calculations are done line by line from the
top to the bottom.
C. Detection of Hotspot Candidates
After calculating array D, substrings similar to the hotspot
pattern are detected as hotspot candidates. To detect hotspot
candidates, we focus on the elements with the minimal values
(less than a user-deÔ¨Åned threshold) in the bottom row of D.
Each of these elements is considered to correspond to the
terminal character of a hotspot candidate. Since we assume
the hotspot candidate has the length same as the hotspot
pattern, the initial character can be identiÔ¨Åed from the terminal
character. The assumption is based on the fact that a hotspot
pattern and candidates similar to the pattern are originally
two-dimensional images, and have the same size or almost
the same size. Figure 10 illustrates an example of hotspot
candidate detection of our methods. (In the example, patterns
are described in regular strings for simplicity.)
IV.
PROPOSED METHOD
In this section, we propose an improved hotspot detection
method based on table-reference. Our proposed method is an
extension of the existing method [6]. First, we explain the
basis of table-reference-based edit distance calculation, some
problems for implementation, and our solutions of the prob-
lems. Then, we explain our proposed method, by describing
mask pattern encoding, hotspot pattern encoding, calculation
of the encoded edit distance matrix, and detection of hotspot
candidates.
 		

		
	
	

  !
	"
##


	




       
      
       
      
       
      
       
      
       
      
	











	
	

	




	





	
	
	
			

Figure 10. Detection of hotspot candidate
A. Table-reference
In our proposed method, calculation of the edit distance
matrix is accelerated by using table-reference of precomputed
values and simultaneous calculation of multiple elements in
the matrix. Each region of simultaneously handled elements is
a k √ó k partial matrix of the edit distance matrix, where k is
the user-deÔ¨Åned constant which decides parallelism. Figure 11
shows an example of 3 √ó 3 region. The number of inputs and
outputs necessary for calculating each region is decided by
k, as shown in Figure 12 (a) and (b). In addition, the values
of the outputs are uniquely determined by the values of the
inputs. Thus, a reference table for calculating a region can be
developed. Hereinafter, a set of inputs for a table refers to an
address (or index) of the table.



	















	
	





	


	

D‚Ä≤
Figure 11. 3 x 3 region in edit distance matrix
A set of inputs for the table consists of the necessary values
for DP-based calculation of the elements in a region. That is,
it consists of the corresponding characters of the mask and
hotspot patterns (2k characters), the k elements to the left of
the region, the k elements to the upper of the region, and the
element to the upper-left of the region (2k + 1 elements in
total). A set of outputs consists of the values of the elements
in the region. Given a region, then we call the partial matrix of
D which includes the region and the elements corresponding
to the inputs of the region, D‚Ä≤ (Figure 11). D‚Ä≤ is equivalent to
the region expanded one column and one row to the upper-left
direction.
However, it is not practical to directly make a table of
11
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-585-2
CENICS 2017 : The Tenth International Conference on Advances in Circuits, Electronics and Micro-electronics



		




	






		











	
	
	
	
	
	
x
x +1
+ 2
x
y
+1
y
+ 2
y
xa
+1
xa
 
yb
+1
yb
xc
+1
xc
y
d
y+1
d
xf
+1
xf
y
g
y+1
g
D‚Ä≤
Figure 12. Input-output relation on the calculation of a region : (a) case of
1 √ó 1, (b) case of 2 √ó 2, (c) case of 2 √ó 2 using the difference between
adjacent elements in the edit distance (with input-output names)
region calculation, because it requires a huge memory space.
This is because the range of the value of each element is large,
and thus the number of combinations of the input values of the
table explodes. Thus, we focus on the fact that, by deciding the
reference element (e.g., the upper-left one) of D‚Ä≤, the value of
an element can be represented by the difference between the
element and the reference one, and the value can be calculated
by using only the differences between elements. In addition,
we found the fact that the difference between the adjacent
two elements is -1, 0 or 1 (when an edit cost is deÔ¨Åned as 0
or 1). (The proof is omitted due to the limitation of space.)
By adopting difference calculation considering the facts, we
mitigate the virtual range of the value of each element, and
thus the required memory space. Furthermore, only the values
of the elements in the bottom row and the right-most column in
D‚Ä≤ are necessary for calculating the edit distance matrix D (the
values of the other elements are not necessary), because only
the bottom row of D is necessary for hotspot detection. Thus,
the computational complexity of each region can be reduced
to O(k) from O(k2) by table-reference. Examples of sets of
inputs/outputs of a table (the necessary values for calculating
regions) are shown in Figure 12(c).
Moreover, a set of inputs/outputs can be encoded into one
word when k is small. Thus, in that case, the edit distance
matrix can be calculated in the encoded values, so that the
computational complexity of each region is reduced to O(1)
from O(k). Figure 13 illustrates encoded inputs and outputs.
Let (x, y) be the coordinate of the upper-left element of
D‚Ä≤ in the edit distance matrix D. Then, the inputs are
‚Ä¢
ax, ax+1, ..., ax+(k‚àí1): mask pattern characters corre-
sponding to the region (input1)
‚Ä¢
by, by+1, ..., by+(k‚àí1): hotspot pattern characters cor-
responding to the region (input2)
‚Ä¢
cx, cx+1, ..., cx+(k‚àí1): the differences between adja-
cent two elements in the upper-most row of D‚Ä≤ (in-
put3)
‚Ä¢
dy, dy+1, ..., dy+(k‚àí1): the differences between adja-

	

	

 

x
x +1
+ 2
x
y
+1
y
+ 2
y
ax
x+1
a
 
yb
+1
yb
xc
+1
xc
y
d
y+1
d
xf
+1
xf
y
g
y+1
g
D‚Ä≤
	



x
x +1
+ 2
x
y
+1
y
+ 2
y
ax
x+1
a
yb
+1
yb
xc
+1
xc
y
d
y+1
d
xf
+1
xf
y
g
y+1
g


	



Figure 13. Encoding of inputs/outputs of region: (a) unencoded
inputs/outputs of 2 √ó 2 region, (b) encoded inputs/outputs
cent two elements in the left-most column of D‚Ä≤
(input4),
and the outputs are
‚Ä¢
fx, fx+1, ..., fx+(k‚àí1): the differences between adja-
cent two elements in the bottom row of D‚Ä≤ (output1)
‚Ä¢
gy, gy+1, ..., gy+(k‚àí1): the differences between adja-
cent two elements in the right-most column of D‚Ä≤
(output2).
The inputs/outputs are encoded by the encoding functions
P(px, px+1, ..., px+i) =
k‚àí1

i=0
px+i √ó 2(k‚àí1)‚àíi
(1)
Q(qx, qx+1, ..., qx+i) =
k‚àí1

i=0
qx+i √ó 3(k‚àí1)‚àíi
(2)
to develop a table.
Hereinafter, we call the four inputs, input1, input2, input3,
and input4, and the two outputs, output1 and output2. The
ones composed of binary variables are encoded by using (1),
and the ones composed of three-valued (‚àí1, 0, 1) variables are
encoded by using (2). Therefore, the outputs can be memorized
in two words of memory if log2 3k is less than or equal to the
bit width of a word. In that case, k √ó k-element calculation
can be done accessing the memory only two times, so that the
computational complexity of each region is O(1). Note that
the number of possible combinations of the inputs is 22k √ó
32k and is an exponential function of k. In our experimental
environment, we developed tables up to k = 5 (0.23GB).
B. Hotspot detection using table-reference
In this subsection, we explain our table-reference-based
hotspot detection method. As mentioned in the previous sub-
section, a table is developed by calculating the output values of
a region for each possible combination of input values before
starting hotspot detection. Then, the table is used for efÔ¨Åcient
hotspot detection.
1) Pattern encoding: The mask and hotspot patterns in
two-dimensional arrays are transformed into one-dimensional
strings in the same way as [6]. Next, the mask and hotspot
patterns are divided into k-character substrings and then each
substring is encoded to use the reference table for calculating
the edit distance matrix. Note that, in the hotspot pattern, since
large don‚Äôt-care characters cannot be calculated in the encoded
12
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-585-2
CENICS 2017 : The Tenth International Conference on Advances in Circuits, Electronics and Micro-electronics

form, large don‚Äôt-care characters are not encoded, and thus they
are not included in a k-character substrings. Each k-character
substring is encoded by using (1). The terminal substring (of
the mask pattern) whose length are less than k is left as an
unencoded string. Likewise, in the hotspot pattern, large don‚Äôt-
care characters and the substrings whose length are less than
k (including those resulting from the inserted large don‚Äôt-care
characters) are left as unencoded strings.
2) Calculation of edit distance matrix D: Using the en-
coded patterns, the calculation of the edit distance matrix
D is performed by referencing the table. Let us explain the
calculation using Figure 14. First, the values of the element of
the Ô¨Årst row and column are set according to the deÔ¨Ånition
of the edit distance matrix. Next, the region whose upper-
left element corresponding to the element D(1, 1) (region (1))
is calculated by table-reference. After calculating region (1),
the region adjacent to the right of region (1) (region (2))
is calculated. Let region (5) be an example. The input3 of
region (5) is from the output1 of region (3), and the input4 of
region (5) is from the output2 of region (4). In this way, the
encoded outputs of regions can be directly used as inputs to
calculate other regions. After table-reference-based calculation,
the values of the elements in the bottom row of the edit
distance matrix D can be restored by using the value of the
left-most element and the differences between adjacent two
elements obtained by decoding the output1 of each bottom
region.












	

	

	

	
	

	

	

	

	




	

	

	
	 	
	
	
	
	
	
	
	
	
				
	

	
	
	
	
	
	
		
	
	
	
	
	
		
	
		
	
	
	
	
	
 
Figure 14. Calculation of edit distance matrix by table reference
We have explained the edit distance calculation ignoring
unencoded substrings. Here, let us explain how to handle
unencoded mask pattern substrings using Figure 15(a). First,
the output2 of the region just before the unencoded mask pat-
tern character is decoded to the differences between adjacent
elements in the corresponding column. Next, the values of
the elements are restored using the value of the upper-most
element and the differences between elements. Then, the values
of the elements corresponding to the unencoded substrings are
calculated according to the DP-based deÔ¨Ånition in the same
way as [6].
Next, let us explain how to handle unencoded hotspot
pattern substrings using Figure 15(b). First, the output1s of
the regions just above the unencoded hotspot pattern character
are decoded to the differences between adjacent elements in
the corresponding row. Next, the values of the elements are
restored using the value of the left-most element and the
differences between elements. Then, the values of the elements
corresponding to the unencoded substrings are calculated ac-
cording to the DP-based deÔ¨Ånition in the same way as [6].
Also the substrings before the large don‚Äôt-care characters are
handled in the same way. Since each row of hotspot pattern
(in a two-dimensional hotspot pattern) means one large don‚Äôt-
care character, a hotspot pattern string contains multiple large
don‚Äôt-care characters. This calculation is performed for each
large don‚Äôt-care character.




























 	
		
















































































































		
	




























































































































		

		



		


		
	
	
 
		


		

		
Figure 15. Calculation for unencoded character: (a) mask pattern character,
(b) hotspot pattern character
Finally, if the hotspot pattern character corresponding to
the bottom row is encoded, the values of the elements in
the bottom row of the edit distance matrix D are restored to
Ô¨Ånd hotspot candidates. If the hotspot pattern character is not
encoded, the values of the elements in the bottom row of D
are calculated according to the deÔ¨Ånition as mentioned in the
previous paragraph.
3) Detection of similar patterns: After calculating the edit
distance matrix D, patterns similar to the hotspot pattern are
detected from the values of the bottom row of D. The elements
with minimal values (less than the user-deÔ¨Åned threshold) are
identiÔ¨Åed in the same way as [6]. Each of them corresponds
to the terminal character of a hotspot candidate. The initial
character can be identiÔ¨Åed by the terminal character because
the length of a hotspot candidate is the same as the given
hotspot pattern.
V.
EXPERIMENTAL RESULTS
We performed experiments to evaluate our method. In the
experiments, we evaluated the execution time of template-
matching, the existing method [6], and our proposed method
for k = 1, . . . 5, for the same mask pattern (1020 √ó 1020
pixels) and the same hotspot pattern (250 √ó 250 pixels), on
a CentOS (release 6.3 (Final)) PC equipped with Intel Core
i7-3770 CPU @ 3.4GHz and 7.6GB memory using gcc 4.4.7.
The experimental results are shown in Figure 16. Our
proposed method achieved the better result compared to [6]
13
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-585-2
CENICS 2017 : The Tenth International Conference on Advances in Circuits, Electronics and Micro-electronics


	



	









	

































	
	
	
	












	



















	

















 
!"#$#%
Figure 16. Calculation time
for each setting of k. When k ‚â• 3, our method outperformed
template-matching. We conÔ¨Årmed that the calculation time of
the edit distance matrix D was drastically reduced.
The calculation time of D is inversely proportional to k2.
Thus, it is expected that the decreasing rate of the calculation
time decreases with increasing k. In addition, the time to
make the reference table is proportional to the number of
combinations of input values (i.e., 22k √ó 32k). That is, the
time is proportional to an exponential function of k. Therefore,
from Figure 16, the sum of the time to make the reference
table and the time to calculate D increases when k ‚â• 5.
Thus, we conclude that k = 4 is best under the experimental
environment. The execution time when k = 4 was about
1/11 compared to the existing method [6]. Note that once a
reference table is made, it can be reused. In such a case, k ‚â• 5
are potentially effective.
VI.
CONCLUSIONS
In this paper, we proposed and evaluated an efÔ¨Åcient
hotspot detection method. Experimental results showed that
our proposed method found hotspot candidates much faster
than the existing one [6] on which our method is based. Our
future work includes further improvement of the execution
time and improvement of the accuracy of hotspot detection.
REFERENCES
[1]
T. Higashi and Y. Onishi, ‚ÄúTrends in semiconductor lithography tech-
nologies and Toshiba‚Äôs approach,‚Äù TOSHIBA review, vol. 67, no. 4,
pp. 2-6, 2012Ôºé(in Japanese)
[2]
H. Yao et al., ‚ÄúEfÔ¨Åcient range pattern matching algorithm for process-
hotspot detection,‚Äù IET Circuits Devices Syst., vol. 2, issue 1, pp. 2‚Äì15,
2008.
[3]
D. Ding, A. J. Torres, F. G. Pikus, and D. Z. Pan, ‚ÄúHigh per-
formance lithographic hotspot detection using hierarchically reÔ¨Åned
machine learning,‚Äù in Proc. the 16th Asia and South PaciÔ¨Åc Design
Autom. Conf. (ASP-DAC), pp. 775‚Äì780, 2011.
[4]
J. Wuu, Fedor G. Pikus, and M. Marek-Sadowska, ‚ÄúEfÔ¨Åcient approach
to early detection of lithographic hotspots using machine learning
systems and pattern matching,‚Äù in Proc. SPIE 7974, Design for Man-
ufacturability through Design-Process Integration V, 79740U, pp. 1‚Äì8,
April 04, 2011.
[5]
W. Wen, J. Li, S. Lin, J. Chen, and S. Chang, ‚ÄúA fuzzy-matching
model with grid reduction for lithography hotspot detection,‚Äù IEEE
Trans. CAD, vol. 33, no. 11, pp. 1671‚Äì1679, Nov. 2014.
[6]
S. Tamagawa, R. Fujimoto, M. Inagi, S. Nagayama, and S. Wak-
abayashi, ‚ÄúA hotspot detection method based on approximate string
search,‚Äù in Proc. the 9th International Conference on Advances in
Circuits, Electronics and Micro-electronics, pp. 6‚Äì12, 2016.
[7]
H. Yaegashi, ‚ÄúPattern Ô¨Ådelity control in multi-patterning towards 7nm
node,‚Äù in Proc. the IEEE 16th Int. Conf. on Nanotechnology (IEEE-
NANO), pp. 452‚Äì455, Aug. 2016.
[8]
R. A. Wagner and M. J. Fischer, ‚ÄúThe string-to-string correction
problem,‚Äù Journal of the ACM., vol. 21, issue 1, pp. 168‚Äì173, Jan.
1974.
[9]
Y. Utan, S. Wakabayashi, and S. Nagayama, ‚ÄúAn FPGA-based text
search engine for approximate regular expression matching,‚Äù in Proc. the
2010 International Conference on Field-Programmable Technology,
pp. 184‚Äì191, Dec. 2010.
[10]
D. E. Knuth, J. H. Morris, Jr., and V. R. Pratt, ‚ÄúFast pattern matching
in strings,‚Äù SIAM J. Comput., vol. 6, no. 2, pp. 323‚Äì350, 1977.
14
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-585-2
CENICS 2017 : The Tenth International Conference on Advances in Circuits, Electronics and Micro-electronics

