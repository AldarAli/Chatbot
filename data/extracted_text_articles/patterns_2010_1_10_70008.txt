A Formal Language of Pattern Compositions
Ian Bayley and Hong Zhu
Department of Computing and Electronics, Oxford Brookes University
Oxford OX33 1HX, UK. Email: ibayley@brookes.ac.uk, hzhu@brookes.ac.uk
Abstract—In real applications, design patterns are almost
always to be found composed with each other. Correct ap-
plication of patterns therefore relies on precise deﬁnition
of these compositions. In this paper, we propose a set of
operators on patterns that can be used in such deﬁnitions.
These operators are restriction of a pattern with respect to
a constraint, superposition of two patterns, and a number
of structural manipulations of the pattern’s components. We
also report a case study on the pattern compositions suggested
informally in the Gang of Four book in order to demonstrate
the expressiveness of the operators.
Keywords-Design patterns, Pattern composition, Object ori-
ented design, Formal methods.
I. INTRODUCTION
As codiﬁed reusable solutions to recurring design prob-
lems, design patterns play an increasingly important role
in the development of software systems [1], [2]. In the
past few years, many such patterns have been identiﬁed,
catalogued [1], [2], formally speciﬁed [3]–[6], and included
in software tools [7]–[9]. Although each pattern is speciﬁed
separately, they are usually to be found composed with
each other in real applications. It is therefore imperative to
represent pattern compositions precisely and formally so that
the correct usage of composed patterns can be veriﬁed and
validated.
However, while many approaches to pattern formalisation
have been proposed, very few authors have investigated
pattern composition formally. In [10], Taibi discussed com-
position but went no further than illustrating it with an
example. In [11], we formally deﬁned a pattern composition
operator. It is universal but not very ﬂexible for practical
uses. In this paper, we revise the work, taking a radically
different approach. Instead of deﬁning a single universal
composition operator, we formally deﬁne a set of operators,
with which each sort of composition can be accurately and
precisely expressed.
The remainder of the paper is organised as follows.
Section II reviews the different approaches to pattern for-
malisation to give the background of the paper. Section
III formally deﬁnes the set of six operators. Section IV
gives an example to illustrate how compositions can now
be speciﬁed. Section V reports a case study in which we
used the operators to realise all the pattern combinations
suggested by the Gang of Four (GoF) book [1]. Section VI
concludes the paper with a discussion of related works and
future work.
II. BACKGROUND
In the past few years, researchers have advanced several
approaches to the formalisation of design patterns. In spite
of the differences in their formalisms, the basic underlying
ideas are quite similar. In particular, valid pattern instances
are usually speciﬁed using statements that constrain their
structural features and sometimes their behavioural features
too. The structural constraints are typically assertions that
certain types of components exist and have a certain static
conﬁguration. The behavioural constraints, on the other
hand, detail the temporal order of messages exchanged
between the components that realise the designs.
The various approaches to pattern formalisation differ
in how they represent software systems and in how they
formalise the predicate. For example, Eden’s predicates are
on the source code of object-oriented programs [5] but they
are limited to structural features. Taibi’s approach in [4] is
similar but he takes the further step of adding temporal logic
for behavioural features. In contrast, our predicates are built
up from primitive predicates on UML class and sequence
diagrams [6]. These primitives are induced from GEBNF,
which is an extension of BNF for graphical modelling lan-
guages [12]. Nevertheless, the operators on design patterns
used in this paper are generally applicable and independent
of the particular formalism used. Still, the examples used
to illustrate the operators and our formalism come from our
previous work [6].
As examples, Figures 1 and 2 show the speciﬁcation
of the Object Adapter and Composite design patterns. The
class diagrams from the GoF book have been reproduced to
enhance readability. The primitive predicates and functions
we use are explained in Table I. All of them are either
induced directly from the GEBFN deﬁnition of UML, or
are deﬁned formally in terms of such predicates.
In general, a design pattern P can be deﬁned abstractly
as an ordered pair ⟨V, Pr⟩, where Pr is a predicate on
the domain of some representation of software systems, and
V is a set of declarations of variables free in Pr. In other
words, Pr speciﬁes the structural and behavioural features
of the pattern and V speciﬁes its components. Let V =
{v1 : T1, · · · , vn : Tn}, where vi are variables that range
over the type Ti of software elements. The semantics of the
1
PATTERNS 2010 : The Second International Conferences on Pervasive Patterns and Applications
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-111-3

Speciﬁcation 1: (Object Adapter Pattern)
Components
1) T arget,Adapter,Adaptee ∈ classes,
2) requests ⊆ T arget.opers,
3) specreqs ⊆ Adaptee.opers
Static Conditions
1) Adapter −−▷+ T arget, Adapter −→+ Adaptee,
2) CDR(T arget)
Dynamic Conditions
1) ∀o ∈ requests · ∃o′ ∈ specreqs · (calls(o, o′))
Figure 1.
Speciﬁcation of Object Adapter Pattern
Speciﬁcation 2: (Composite)
Components
1) Component, Composite ∈ classes,
2) Leaves ⊆ classes,
3) ops ⊆ Component.opers
Static Conditions
1) ops ̸= ∅
2) ∀o ∈ ops.isAbstract(o),
3) ∀l ∈ Leaves · (l −−▷+ Component
∧ ¬(l ⋄−→+ Component))
4) isInterface(Component)
5) Composite −−▷∗ Component
6) Composite ⋄−→+ Component
7) CDR(Component)
Dynamic Conditions
1) any call to Composite causes follow-up calls
∀m ∈ messages · ∃o ∈ ops ·
(toClass(m) = Composite ∧ m.sig ≈ o ⇒
∃m′ ∈ messages · calls(m, m′) ∧ m′.sig ≈ m.sig)
2) any call to a leaf does not
∀m ∈ messages · ∃o ∈ ops ·
toClass(m) ∈ Leaves ∧ m.sig ≈ o ⇒
¬∃m′ ∈ messages . calls(m, m′) ∧ m′.sig ≈ m.sig)
Figure 2.
Speciﬁcation of Composite Pattern
speciﬁcation is a ground predicate in the form.
∃v1 : T1 · · · ∃vn : Tn · (Pr)
(1)
In the sequel, we write Spec(P) to denote the predicate
(1) above, V ars(P) for the set of variables declared in V ,
and Pred(P) for the predicate Pr.
We can formally deﬁne the conformance of a design
model m to a pattern P, written as m |= P, and reason
about the properties of instances based on the patterns they
Table I
THE FUNCTIONS AND PREDICATES USED IN THE EXAMPLES
ID
Meaning
classes
The set of class nodes in the class diagram
opers
The operations contained in the class node
sig
The signature of the message
X −−▷+ Y
Class X inherits class Y directly or indirectly
X −→+ Y
There is an association from class X to Y
directly or indirectly
X ⋄−→+ Y
There is an composite or aggregate relation from
X to Y directly or indirectly
isInterface(X)
Class X is an interface
CDR(X)
No messages are sent to a subclass of X from
outside directly
calls(x, y)
Operation x calls operation y
isAbstract(op)
Operation op is abstract
toClass(m)
The class that message m is sent to
X ≈ Y
Operations X and Y share the same name
conform to, but we omit the details here for the sake of
space. Readers are referred to [6] and [12].
III. OPERATORS ON PATTERNS
We now formally deﬁne the operators on design patterns.
A. Restriction operator
The restriction operator was ﬁrst introduced in our previ-
ous work [11], where it is called the specialisation operator.
Deﬁnition 1: (Restriction operator)
Let P be given pattern and c be a predicate deﬁned on
the components of P. A restriction of P with constraint c,
written as P [c], is the pattern obtained from P by imposing
the predicate c as an additional condition on the pattern.
Formally,
1) V ars(P[c]) = V ars(P),
2) Pred(P[c]) = (Pred(P) ∧ c). ⊓⊔
For example, a variant of Composite pattern in which
there is only one leaf, called Composite1 in the sequel,
can be formally deﬁned as follows.
Composite1 = Composite[#Leaves = 1].
Restriction is frequently used in the case study, particu-
larly in the form P[u = v] for pattern P and variables u
and v of the same type. This expression denotes the pattern
obtained from P by unifying u and v to make them the same
element.
The restriction operator does not introduce any new com-
ponents into the structure of a pattern, but the following
operators do.
B. Superposition operator
Deﬁnition 2: (Superposition operator)
Let P and Q be two patterns. Assume that the compo-
nent variables of P and Q are disjoint, i.e., V ars(P) ∩
V ars(Q) = ∅. The superposition of P and Q, written P ∗Q,
is a pattern that consists of both pattern P and pattern Q as
is formally deﬁned as follows.
2
PATTERNS 2010 : The Second International Conferences on Pervasive Patterns and Applications
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-111-3

1) V ars(P ∗ Q) = V ars(P) ∪ V ars(Q);
2) Pred(P ∗ Q) = Pred(P) ∧ Pred(Q). ⊓⊔
For example, the superposition of Composite and Adapter
patterns, Composite ∗ Adapter, requires each instance to
contain one part that satisﬁes the Composite pattern and
another that satisﬁes the Adapter pattern. These parts may or
may not overlap, but the following expression does enforce
an overlap, requiring that a class in Leaves be the target of
an Adapter.
(Composite ∗ Adapter)[T arget ∈ Leave]
The requirement that V ars(P) and V ars(Q) be disjoint
is easy to fulﬁl using renaming. An appropriate notation for
this will be introduced later.
C. Extension operator
Deﬁnition 3: (Extension operator)
Let P be a pattern, V be a set of variable declarations that
are disjoint with P’s component variables (i.e., V ars(P) ∩
V = ∅), and c be a predicate with variables in V ars(P)∪V .
The extension of pattern P with components V and linkage
condition c, written as P#(V • c), is deﬁned as follows.
1) V ars(P#(V • c)) = V ars(P) ∪ V ;
2) Pred(P#(V • c)) = Pred(P) ∧ c. ⊓⊔
D. Flatten operator
Deﬁnition 4: (Flatten Operator)
Let P be a pattern, V ars(P) = {x : P(T ), x1
:
T1, · · · , xk : Tk} and Pred(P) = p(x, x1, · · · , xk), and
x′ ̸∈ V ars(P). The ﬂattening of P on variable x, written
P ⇓ x\x′, is the pattern that has the following property.
1) V ars(P ⇓ x\x′) = {x′ : T, x1 : T1, · · · , xk : Tk};
2) Pred(P ⇓ x\x′) = p′(x′, x1, · · · , xk),
where p′(x′, x1, · · · , xk) = p({x′}, x1, · · · , xk). That is, the
predicate p′ is obtained by replacing all free occurrences of
variable x with expression {x′}. ⊓⊔
Note that, P(T ) denotes the power set of T . For example,
in the speciﬁcation of Composite pattern, the component
variable Leaves ⊆ classes is a subset of classes. Its type
is P(classes).
For example, the single-leaf variant of Composite pattern
Composite1 can also be deﬁned as follows.
Composite1 = Composite ⇓ Leaves\Leaf
As an immediate consequence of this deﬁnition, we have
the following property. For x1 ̸= x2 and x′
1 ̸= x′
2,
(P ⇓ x1\x′
1) ⇓ x2\x′
2 = (P ⇓ x2\x′
2) ⇓ x1\x′
1.
(2)
Therefore, we can overload the ⇓ operator to a set of com-
ponent variables. Let X be a subset of P’s component vari-
ables all of power set type, i.e., X = {x1 : P(T1), · · · , xn :
P(Tn)} ⊆ V ars(P), n ≥ 1 and X′ = {x′
1, · · · , x′
n} such
that X′ ∩ V ars(P) = ∅. We write P ⇓ X\X′ to denote
P ⇓ x1\x′
1 ⇓ · · · ⇓ xn\x′
n.
Note that our pattern speciﬁcations are closed formulae,
containing no free variables. Although the names given to
component variables greatly improve readability, they have
no effect on semantics so, in the sequel, we will often omit
new variable names and write simply P ⇓ x to represent
P ⇓ x\x′.
E. Generalisation operator
Deﬁnition 5: (Generalisation operator)
Let P be a pattern, x ∈ V ars(P) = {x : T, x1 :
T1, · · · , xk : Tk}. The generalisation of P on variable x,
written P ⇑ x\x′, is deﬁned as follows.
1) V ars(P ⇑ x\x′) = {x′ : P(T ), x1 : T1, · · · , xk : Tk},
2) Pred(P ⇑ x\x′) = ∀x ∈ x′ · Pred(P).⊓⊔
For example, we can deﬁne the Composite pattern as a
generalisation of the single-leaf variant Composite1, i.e.,
Composite = Composite1 ⇑ Leaf\Leaves
We will use the same syntactic sugar for ⇑ as we do for ⇓.
We will often omit the new variable name and write P ⇑ x.
Thanks to an analogue of Equation 2, we can and also will
promote the operator ⇑ to sets.
F. Lift operator
The lift operator was ﬁrst introduced in our previous
work [11]. This time, we decompose the deﬁnition of a
pattern slightly differently, into the existentially quantiﬁed
class components CV ars(P) and the remainder of the
predicate OPred(P), which includes the declarations of the
operations, existentially quantiﬁed at the outermost. Then we
can deﬁne lifting as follows.
Deﬁnition 6: (Lift Operator)
Let P be a pattern and CV ars(P) = {x1 : T1, · · · , xn :
Tn}, n > 0 and OPred(P) = p(x1, · · · , xn). Let X =
{x1, · · · , xk}, 1 ≤ k < n, be a subset of the variables in the
pattern. The lifting of P with X as the key, written P ↑ X,
is the pattern deﬁned as follows.
1) CV ars(P ↑ X) = {xs1 : PT1, · · · , xsn : PTn},
2) OPred(P ↑ X) = ∀x1 ∈ xs1 · · · ∀xk ∈ xsk·∃xk+1 ∈
xsk+1 · · · ∃xn ∈ xsn · p(x1, · · · , xn). ⊓⊔
Where the key set is singleton, we omit the set brackets for
simplicity, so we write P ↑ x instead of P ↑ {x}.
For example, Figure 3 is the pattern deﬁned by expression
Adapter ↑ T arget.
Informally, lifting a pattern P results in a pattern P ′ that
contains a number of instances of pattern P. For example,
Adapter ↑ T arget is the pattern that contains a number of
T argets of adapted classes. Each of these has a dependent
Adapter and Adaptee class conﬁgured as in the original
Adapter pattern. In other words, the component T arget in
the lifted pattern plays a role similar to the primary key in
a relational database.
3
PATTERNS 2010 : The Second International Conferences on Pervasive Patterns and Applications
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-111-3

Speciﬁcation 3: (Lifted Object Adapters Pattern)
Components
1) T argets,Adapters,Adaptees ⊆ classes,
Conditions
1) ∀Adaptee ∈ Adaptees · ∃specreqs ∈ Adaptee.opers,
2) ∀T arget ∈ T argets · ∃requests ∈ T arget.opers,
3) ∀T arget ∈ T argets · CDR(T arget),
4) ∀T arget ∈ T argets ·
∃Adapter ∈ Adapters,Adaptee ∈ Adaptees·
a) Adapter −−▷ T arget,
b) Adapter −→ Adaptee,
c) ∀o ∈ T arget.requests ·
∃o′ ∈ Adaptee.specreqs · (calls(o, o′)))
Figure 3.
Speciﬁcation of Lifted Object Adapter Pattern
IV. EXAMPLE
The composition of patterns is often represented graph-
ically with Pattern:Role annotations [13]. An example is
Figure 4, taken from [13] (p131). It is composed from
ﬁve patterns: Command, Command Processor, Strategy,
Composite, and Memento. The composition can be easily
expressed as an expression in the operators of this paper.
First though, we must introduce a notation for renaming
the variables in one pattern to make them disjoint from those
in another. Let x ∈ V ars(P) be a component of pattern P
and x′ /∈ V ars(P). The systematic renaming of x to x′ is
written as P[x′ := x]. Obviously, the renaming does not
affect model satisﬁability. (Formally, for all models m, we
have m |= P ⇔ m |= P[x′ := x].) Let P[v := x = y] be
syntactic sugar for P[x = y][v := x][v := y], i.e., both x and
y are renamed and equated to v. Similarly, let P[v := x ∈ y]
abbreviate P[x ∈ y][v := x].
Then we can translate each annotation group as a single
restriction, representing the diagram with the following
expression:
(Command ∗ CommandProcessor ∗ Strategy∗
Composite ∗ Memento)
[commandProcessor := context]
[command := CPcommand = component ∈ caretakers]
[(composite ∈ caretakers)
∧ (composite ∈ concreteCommands)]
[concreteCommand := composite]
[concreteCommands := leaf ∈ caretakers]
[Logging := strategy]
[ConcreteLoggingStrategies := concreteStrategies]
Note that compositions such as this, representable in a
graphical form with annotations, can always be represented
using the restriction and superposition operators, but not all
the examples in the next section, so the graphical notation is
not expressive enough, nor are the two operators when used
on their own.
V. CASE STUDY
In the GoF book, the documentation for each pattern
concludes with a brief section entitled Related Patterns.
As the title suggests, it compares and contrasts patterns,
but more importantly, it makes suggestions for how other
patterns may be used with the one under discussion. These
suggestions are summarised in a diagram on the back cover.
Our case study is to formalise them all as expressions with
the operators from this paper and predicates specifying the
patterns; the latter can be found in [6]. For example, on page
106 of the GoF book, it is stated that “A Composite is what
the builder often builds”. This can be formally speciﬁed as
follows.
(Builder ∗ Composite)[Product = Component].
Figure 5 shows our coverage of these relationships, based
on the aforementioned GoF diagram, with each numbered
relationship summarised in the corresponding row of Table
II. Composite1 is as deﬁned in Section III (any of the
equivalent deﬁnitions can be used) and the notation P.x
denotes the variable x in pattern P.
Five new arrows have been added to the diagram and
numbered in bold font. These relationships were discussed
in GoF but omitted from its version of diagram. We were
still able to formalise them because GoF contained the
information we needed to do so. On the other hand, four
arrows from the original diagram have been kept but la-
belled with asterisks in place of numbers. These are the
relationships that do not represent compositions and thus
could not be formalised as expressions. In particular, it is a
specialisation relation that links Composite and Interpreter,
which can be formally proved; see [14]. The relationship
between Decorator and Strategy is a comparison of the two,
not a composition suggestion, so is the relationship between
Strategy and Template Method. That between Iterator and
Visitor, on the other hand, has not been formalised for the
different reason that it is mentioned in GoF only on the
diagram, and not expanded upon in the main text.
The case study has demonstrated that the operators deﬁned
in this paper are expressive to deﬁne compositions of design
patterns.
VI. CONCLUSION
In this paper, we proposed a set of operators on design
patterns that enable compositions to be formally deﬁned
with ﬂexibility. We illustrated the operators with examples.
We also reported a case study of the relationships between
design patterns suggested by GoF [1]. It demonstrated
the expressiveness of the operators in the composition of
patterns.
Formal reasoning about both design patterns and their
compositions can be naturally supported by formal deduction
in ﬁrst-order logic. This activity is well understood, and well
supported by software tools such as theorem provers. In the
case study, we have noticed that some pattern compositions
can be represented in different but equivalent expressions.
For example, we have seen in Section III that Composite1
4
PATTERNS 2010 : The Second International Conferences on Pervasive Patterns and Applications
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-111-3

Command Processor: command processor
Strategy: context
Strategy: strategy
Memento: memento
Client
Command
Processor
Logging
Command
Concrete 
Logging 
Strategy B
Concrete 
Logging 
Strategy A
Memento
Concrete 
Command A
Concrete 
Command B
Composite 
Command
Application
Memento: originator
Command: concrete command
Composite: leaf
Memento: caretaker
Command: concrete command
Composite: composite
Memento: caretaker
Strategy: concrete strategy
Command Processor: command
Command: command
Composite: component
Memento: caretaker
Figure 4.
Example of pattern composition represented in the form of Pattern:Role annotation
* Defining 
grammar
* Defining 
traversal
* Changing Skin 
versus guts
(25) Sharing 
strategies
(24)
(23) Sharing 
states
(21) Complex 
dependency 
management
(22) 
(20) Saving 
state of iteration
(19)
(18)
(17) Avoiding 
hysteresis
(16) Single 
instance
(15)
(14) 
(13) Often 
uses
(12) Single 
instance
(11) Configure 
factory dynamically
(10) Implement 
using
(9) Adding 
operations
(8) Sharing 
terminal symbols
(7) Composed 
using
(6) Adding 
operations
(2) Defining 
the chain
(4) Sharing
composites
(1) Creating 
composites
Composite
Iterator
Builder
Decorator
Strategy
Flyweight
Interpreter
Visitor
Memento
Command
Chain of 
Responsibility
Observer
Mediator
Template 
Method
Factory
Method
Abstract
Factory
Singleton
Prototype
Bridge
Proxy
Adapter
(5) Enumerating 
children
(3) Adding 
responsibilities
to objects
Facade
State
* Defining 
algorithm 
steps
Figure 5.
Case Study on Formalising Relationships between GoF Patterns
5
PATTERNS 2010 : The Second International Conferences on Pervasive Patterns and Applications
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-111-3

Table II
FORMAL DEFINITIONS OF THE COMPOSITIONAL RELATIONSHIPS BETWEEN PATTERNS
No.
Deﬁnition of the compositional relationship
1
(Builder ∗ Composite)[P roduct = Component]
2
(Composite ∗ ChainOfResponsibility)[Handler = Component ∧ Operation = Handle ∧ multiplicity = 1]
3
(Composite1 ∗ Decorator)[Composite1.Component = Decorator.Component∧
Composite1.Operation = Decorator.Operation ∧ ConcreteComponent = Leaf ∧ Decorator = Composite1]
4
(Composite ∗ F lyweight)[Leafs = {ConcreteF lyweight, UnsharedConcreteF lyweight}]
5
(Composite ∗ Iterator′)[ConcreteAggregate = Component]
6
(Composite ∗ V isitor)[Element = Component ∧ Operation = Accept(v) ∧ ConcreteElements = {Leaf, Composite}]
7
(Composite ∗ Command)[Command = Component ∧ execute = operation ∧ ConcreteCommand = Leaf]
8
(Interpreter ∗ F lyweight)[TerminalExpression = F lyweight]
9
(Interpreter ∗ V isitor)[Element = AbstractExpression ∧ Interpret = Accept(v)∧
ConcreteElements = {NonTerminalExpression,TerminalExpression}]
10
(AbstractF actory ∗ ((F actoryMethod ↑ P roduct) ⇑ F actoryMethod))[Creator = AbstractF actory∧
#AnOperations = 1 ∧ createMethods ⊆ F actoryMethods ∧ ConcreteCreators = ConcreteF actories∧
P roducts = AbstractP roducts ∧ AbstractF actory.ConcreteP roducts = F actoryMethod.ConcreteP roducts]
11
(AbstractF actory ∗ (P rototype ↑ Client))[ConcreteF actories ⊆ Clients∧
CreateP roductOperations ⊆ Operations ∧ AbstractP roducts ⊆ P rototypes]
12
(AbstractF actory ∗ (Singleton ↑ {Singleton}))[Singletons ⊆ ConcreteF actories]
13
(TemplateMethod ∗ F actoryMethod)[AbstractClass = Creator ∧ TemplateMethod = AnOperation]
14
(AbstractF actory ∗ F acade)[AbstractF actory = F acade]
15
(AbstractF actory ∗ Bridge)[AbstractP roducts = {Abstraction, Implementor}]
16
(F acade ∗ Singleton)[F acade = Singleton]
17
(Command ∗ Memento)[Originator = Command]
18
(Command ∗ P rototype)[Command = P rototype]
19
(Iterator ∗ F actoryMethod)[Creator = Aggregate ∧ P roduct = Iterator ∧ ConcreteCreator = ConcreteAggregate∧
ConcreteP roduct = ConcreteIterator ∧ AnOperation = CreateIterator]
20
(Memento ∗ Iterator)[ConcreteAggregate = Originator]
21
(Mediator ∗ Observer)[ConcreteColleagues = {ConcreteSubject, ConcreteObserver}]
22
(Mediator ∗ Singleton)[ConcreteMediator = Singleton]
23
(F lyweight ∗ State)[F lyweight = State ∧ Handle = Operation(extrinsicState)]
24
(State ∗ (Singleton ⇑ Singleton))[Singletons ⊆ ConcreteStates]
25
(Strategy ∗ F lyweight)[Strategy = F lyweight ∧ algorithmInterface = Operation(extrinsicState)]
can be expressed either using the restriction operator or
using the ﬂatten operator, and these two expressions are
equivalent. We are now investigating the algebraic laws that
the operators obey. This will lead us to a calculus of pattern
composition to enable us to reason about the equivalence of
such expressions.
REFERENCES
[1] E. Gamma, R. Helm, R. Johnson, and J. Vlissides, Design
Patterns - Elements of Reusable Object-Oriented Software.
Addison-Wesley, 1995.
[2] D. Alur, J. Crupi, and D. Malks, Core J2EE Patterns: Best
Practices and Design Strategies, 2nd ed. Prentice Hall, 2003.
[3] T. Mikkonen, “Formalizing design patterns,” in Proc. of
ICSE’98. IEEE CS, April 1998, pp. 115–124.
[4] T. Taibi, D. Check, and L. Ngo, “Formal speciﬁcation of
design patterns-a balanced approach,” Journal of Object Tech-
nology, vol. 2, no. 4, July-August 2003.
[5] E. Gasparis, A. H. Eden, J. Nicholson, and R. Kazman,
“The design navigator: charting Java programs,” in Proc. of
ICSE’08, Companion Volume, 2008, pp. 945–946.
[6] I. Bayley and H. Zhu, “Formal speciﬁcation of the variants
and behavioural features of design patterns,” Journal of
Systems and Software, vol. 83, no. 2, pp. 209–221, Feb. 2010.
[7] D. Hou and H. J. Hoover, “Using SCL to specify and check
design intent in source code,” IEEE TSE, vol. 32, no. 6, pp.
404–423, June 2006.
[8] N. Nija Shi and R. Olsson, “Reverse engineering of design
patterns from JAVA source code,” in Proc. of ASE’06, Sept.
2006, pp. 123–134.
[9] D. Mapelsden, J. Hosking, and J. Grundy, “Design pattern
modelling and instantiation using dpml,” in Proc. of CRPIT
’02. Australian Computer Society, Inc., 2002, pp. 3–11.
[10] T. Taibi, “Formalising design patterns composition,” Software,
IEE Proceedings, vol. 153, no. 3, pp. 126–153, June 2006.
[11] I. Bayley and H. Zhu, “On the composition of design pat-
terns,” in Proc. of QSIC’08, IEEE CS, pp. 27–36.
[12] H. Zhu, “On the theoretical foundation of meta-modelling
in graphically extended bnf and ﬁrst order logic,” in Proc.
of TASE 2010. IEEE CS, Aug. 2010, (in press), Available
online at http://cms.brookes.ac.uk/staff/HongZhu/Publications
/TASE2010.pdf
[13] F. Buschmann, K. Henney, and D. C. Schmidt, Pattern-
Oriented Software Architecture: On Patterns and Pattern
Languages. John Wiley & Sons Ltd., 2007, vol. 5.
[14] I. Bayley and H. Zhu, “Formalising design patterns in predi-
cate logic,” in Proc. of SEFM’07. IEEE CS, Sept. 2007, pp.
25–36.
6
PATTERNS 2010 : The Second International Conferences on Pervasive Patterns and Applications
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-111-3

