Selection of Computing Elements for Energy Efﬁciency in Wireless Sensor
Networks using a Statistical Estimation Method
Steven Corroy▷
Jan Beiten▷◦
Junaid Ansari◦
Heribert Baldus▷
Petri M¨ah¨onen◦
▷Philips Research, Distributed Sensor Systems
HTC 37-51, NL-5656AE, Eindhoven, The Netherlands, steven.corroy@philips.com
◦Department of Wireless Networks, RWTH Aachen University
Kackertstrasse 9, D-52072, Aachen, Germany, jan@mobnets.rwth-aachen.de
Abstract
A wide range of wireless sensor network applications
are characterized by local processing of the sensed data
and only meager data communication requirements. Since
sensor nodes are battery powered and wireless commu-
nication bears a high energy cost, data transmission can
be traded for on-node-computing in order to extend the
lifetime of a node as well as the network. Furthermore,
the energy consumption can be reduced signiﬁcantly by
selecting and realizing the application on an appropriate
processing element.
In this article, we propose a new
statistical technique for energy consumption estimation
for a speciﬁc application on various platforms. We have
empirically veriﬁed the methodology on various classes
of embedded processors commonly used for sensor nodes.
The methodology is also applicable to multiprocessor
platforms. Our solution is not only capable of achieving
high degree of accuracy but also facilitates the application
developer to evaluate different platforms without actually
implementing the application on each of these platforms.
Our experimental evaluation results on different platforms
will help understand the implications of using different
processing elements and their effects on the lifetime of a
wireless sensor network.
Keywords: Wireless sensor networks; energy efﬁciency;
energy consumption estimation.
1
Introduction
Wireless Sensor Networks (WSNs) have a wide range
of applications with long operational lifetime requirements.
Since WSN nodes are generally battery operated, achieving
long lifetime just by changing batteries is either too cum-
bersome or impossible. Therefore, efﬁcient use of the avail-
able battery source becomes an important issue in WSNs. A
sensor node essentially includes a microcontroller, a radio
transceiver and a few sensors. The usage of all the compo-
nents needs to be optimized for battery conservation. Ra-
dio communication exhibits the highest energy consump-
tion budget in many applications while others are dominated
by computations. Low power MAC protocols are designed
to optimize the use of radio resource by periodically turning
on/off the radio in order to save energy, while the radio is
inactive. One class of MAC protocols is the common sched-
ule based protocols like S-MAC [17] and its variants. These
protocols coordinate the active periods of the nodes so that
messages are sent only when all the nodes are active at a
common wake-up period. Another common class of MAC
protocols is the preamble sampling MAC protocols like B-
MAC [13] and its variants, where nodes sleep and wake-up
asynchronously and rely on long preambles to signal the
upcoming data.
While MAC protocols play an important role in appli-
cations where data communication is dominant in terms of
energy consumption, these have little inﬂuence in computa-
tionally intensive applications with meager communication
requirements. In order to meet the computing requirements,
many types of microcontrollers with different characteris-
tics are used. These include ASIC (Application Speciﬁc
Integrated Circuit), ASIP (Application Speciﬁc Integrated
Processor), RISC (Reduced Instruction Set Computer) and
CISC (Complex Instruction Set Computer). A DSP (Digi-
tal Signal Processor) is an ASIP specialized in digital signal
processing. RISCs and CISCs are both GPPs (General Pur-
pose Processors). Each of these different classes of process-
ing elements suits better to different application demands.
For instance, a DSP is more suitable for performing sig-
nal processing, e.g. computing Fast Fourier Transformation
(FFT), while it is inefﬁcient for controlling Serial Periph-
eral Interface (SPI) communication. In order to select the
most power efﬁcient processor, it is necessary to determine
53
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

the anticipated energy consumption of a processing element
executing the application.
Code execution depends on several factors such as ac-
quiring sensor data or other external inputs. Thus the en-
ergy consumed can only be measured at runtime. For a
runtime measurement, the application needs to be imple-
mented on the WSN platform. The implementation efforts
are relatively high due to different instruction sets and pro-
cessing element speciﬁcs. It is neither cost nor time efﬁcient
to implement an application on all the available WSN plat-
forms in order to determine the optimal one. The number
of implementations required can be lowered with the expe-
rience of a code developer, but still the number of possible
platforms remains relatively high. Therefore, a technique
to determine power consumption estimation without actual
implementation effort is desirable.
Simulators such as a circuit simulator cannot produce
accurate results for energy consumption, since they cannot
completely simulate the wireless sensor node environment.
Furthermore, simulators are hardware speciﬁc and are not
available for each platform. The effort required to imple-
ment an application on a simulator is very similar to the
effort required to implement the application on a real hard-
ware platform. Therefore, it is easier to estimate energy
consumption on a higher level independent from the actual
implementation. The next higher level of abstraction that al-
lows energy estimation is the code level. We describe in the
following a methodology for estimating energy consump-
tion of a speciﬁc application on a speciﬁc WSN platform at
the code level. Our method is also applicable to platforms
with multiple processors as we describe in the later sections.
This article is an extended version of earlier paper [1], pub-
lished in the International Conference on Sensor Technolo-
gies and Applications, SENSORCOMM 2008.
The rest of the article is organized as follows: Section 2
presents the related work in this area, Section 3 and 4 detail
our solution, Section 5 presents the results that we obtained
by applying our methodology on a single processing ele-
ment on two different classes of application requirements.
Section 6, describe the methodology applicable on multi-
processor architecture. Finally, in Section 7 we conclude
the article.
2
Related Work
The energy consumption of a speciﬁc application de-
pends on the hardware platform.
The suitability of the
hardware to the required software functionality allows to
achieve energy efﬁciency. The energy consumption estima-
tion for computing elements has been an on-going research
issue [3, 5, 9]. However these studies concentrate on deter-
mining the energy consumption on one speciﬁc platform for
a speciﬁc application.
Feinstein et al. [5] have developed a method to mea-
sure power consumption using a single measurement point.
Their method assigns a unique ID to each process and logs
in the corresponding real time power consumption and the
execution time of the task. Although this approach enables
a precise estimation of the energy consumption at the task-
level, it requires a sensor node, for carrying out the measure-
ments and an implementation of the application on each of
the target platforms.
Bircher et al. [3] proposes to use event counters (e.g.,
DMA accesses or interrupts) for modeling the power con-
sumption of a whole computing platform. From speciﬁc
events to the microcontroller, their approach derives values
for the rest of the platform e.g. I/O power consumption.
Similar to the method by Feinstein et al. [5], this approach
also requires the implementation of the application on each
target platform.
PowerTOSSIM [14] is a tool for estimating the power
consumption of applications developed in the TinyOS op-
erating system environment for the supported platforms.
Since it is a high level power consumption estimator, the
accuracy is not high enough. PowerTOSSIM is based on
the TinyOS simulator TOSSIM, which lacks the ability to
model the simulations accurately owing to its inability to
handle preemption of tasks and lackness of precise timings
the execution of different functions [7], PowerTOSSIM also
remains inaccurate.
A. Dunkels et al. [4] developed a software based tech-
nique for measuring online power consumption of a certain
application developed for Contiki operating system running
on Moteiv Inc.’s TmoteSky sensor node platform. Since
the power consumption of the node in each state is known
beforehand, a sensor node can estimate its own energy con-
sumption by time-stamping each of its states. This tech-
nique however requires a full implementation of the appli-
cation on the supported platform and hence makes it a time-
taking and tedious job for the code developer.
Circuit simulators for energy consumption can give cy-
cle accurate results but require long execution time. Niar et
al. [9] proposes to combine statistical simulation to circuit
simulation. It generates a short synthetic program repre-
senting the original application using statistical values, e.g.,
instruction distribution or cache miss rate. It then simulates
the short synthetic program, giving substantial speed gains
with only an average error of 3.8%.
The work by H. Joe et al. [6] aims at designing an accu-
rate instruction level power estimator for sensor networks.
They developed a power estimation tool using a machine
instruction level simulator and correspondingly an energy
consumption estimation module. The energy consumption
estimation module is instructed by the instruction level sim-
ulator for proﬁling the energy consumption during the run
time of the application. A post-processing module handles
54
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

the adjustments for the function call/returns and the I/O
accesses to estimate the per node energy consumption in
function calls and hardware components. Again this pro-
vides a very low level power consumption estimation which
requires a pre-implementation of the application. Further-
more, for large simulation of sensor network applications,
this approach is very slow.
In contrast to the approaches described above for power
consumption estimation, we aim at estimating and evaluat-
ing the power consumption of a particular application on
different platforms without implementing it. We trade-off
estimation precision for ease of use. In order to evaluate and
verify our work, we used three different microcontrollers in
our experiments which represent the three different classes
of computing elements. This includes the 8051 architec-
ture [8], the MSP430 architecture [16] and the Coolﬂux ar-
chitecture [10].
The 8051 is an 8-bit CISC type processor with Harward
architecture as part of the CC2430 [15]. It was one of the
ﬁrst embedded processors that included CPU, RAM, ROM,
I/O, interrupt logic and timers in a single package. Despite
its design age, 8051 is still in use for many embedded sys-
tem applications. The MSP430 is a 16-bit RISC with von
Neumann processor architecture. Its design was speciﬁcally
developed as a RISC architecture with very low power con-
sumption. There is a wide selection of MSP430s in the mar-
ket, providing different combinations of peripherals.
The NXP CoolFlux is a 24-bit DSP with features such as
pipelining, MMU, register ﬁle structure and a very efﬁcient
Multiplication/Accumulation (MAC) implementation.
3
Methodologies for Power Consumption Es-
timation
Calculating the required number of instructions for a
speciﬁc application and analyzing the required energy con-
sumption enables to compare the energy efﬁciency of differ-
ent computing elements. While considering different pro-
cessing platforms, the operating clock frequencies vary sig-
niﬁcantly from one platform to another. It implies that the
possible number of executable instructions within a certain
time-frame varies correspondingly. For all the processing
elements, Million Instructions Per Second (MIPS) can be
calculated and is used as the common performance refer-
ence. However, the computational power consumption of
a single instruction differs much from one platform to an-
other. Certain instructions may require only one cycle on a
RISC platform and take several hundred cycles on a CISC
platform. Therefore, MIPS is not a reliable means to de-
rive energy comparison. Other benchmarks are not widely
available for embedded systems and are bound to only a
small set of applications due to a different combination of
instructions. So a new approach needs to be devised in order
to analyze the energy consumption with a wider focus than
conventional benchmarking. In the following, we present
a method for estimating power consumption of an applica-
tion utilizing the code level. It consists of two steps. First
the code of a new application is divided in short blocks of
code. We call weight a physical measure applying to a block
of code, e.g., run time or energy consumption. In the fol-
lowing we explain the methodology restraining the meaning
of weight to energy consumption for clarity purpose. Sec-
ond, the empirical weight of the blocks of code is multiplied
with their number of occurrence which gives an estimate of
the overall power consumption of the application. Next we
explain how to choose the relevant blocks for splitting the
application and how to calculate their weights.
3.1
Blocks of Code Granularity
A high level programming language is composed of dif-
ferent instructions. An application is a sequence of instruc-
tions. The shortest atomic element of an application is thus
an instruction. But an application can also be described as
a sequence of different combination of instructions. For es-
timating an application we split it up into a large number of
blocks of code. A block of code is a combination of instruc-
tion. The size of a block of code is determined by the num-
ber of instructions it contains. When splitting an application
all blocks of code have the same size. The ﬁrst step of our
approach is to identify the relevant blocks independently.
The granularity of the blocks is decisive for the accuracy
and the complexity of the estimation. Long blocks of code
give more accurate results because they contain more dy-
namic effects, like for instance compiler optimization. On
the other side, increasing the length of the blocks of code
increases quadratically the complexity of the method. As-
sume l is the length of the blocks of code and k the number
of possible blocks (all different combination of instructions
of size l), increasing to 2l the length of the blocks increases
to k2 the number of possible blocks. Our experiments show
that single instructions (l = 1) such as additions, jumps and
explicit memory accesses are ﬂexible and efﬁcient process-
ing blocks for multiple platforms.
3.2
Blocks of Code Weight
The second step is to determine the weights assigned to
blocks of code. A simple approach is to measure the energy
consumption of all single blocks on each platform. We im-
plement a program for each block of code (e.g. an addition
or jump instruction) containing a sequence of the block in a
row. We measure the energy expended by this program and
derive the energy consumption of the block of code. Apply-
ing the calculated weights to real world WSN applications
show that the results have a 95% conﬁdence interval within
55
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

micro-controllers
Figure 1. Overall system for optimal comput-
ing element selection.
[-27% 23%]. The imprecision of the results is caused by
the compiler optimizations and runtime effects. In order to
improve the accuracy of the results, a statistical approach
is introduced which decreases the inﬂuence of the compiler
optimizations.
3.2.1
System Description
It is assumed that the effects of the compiler optimizations
in reducing the energy consumption are statistically foresee-
able. Instead of using the measured energy consumption of
constant-sized-blocks-of-code to determine the weights of
the blocks, we measure the energy consumption of several
representative WSN applications and derive statistically the
cost of each block of code. This approach has the advantage
of taking into account much of the dynamic effects occur-
ring due to compiler optimizations while keeping shorter
blocks of code for fast and ﬂexible power estimation. Our
overall system is illustrated in Figure 1. We implement on
P platforms N applications {prog1,...,progN} such as sim-
ple instructions concatenation and also more sophisticated
algorithms such as FFT or ﬁeld calculations. The power
consumption and the runtime of those applications are em-
pirically measured. We maintain a database with tables T1
and T2 for storing:
1. The runtime tnp and the energy consumption enp of
each application for each platform with n ∈ [1, N] and
p ∈ [1, P].
T1 =




(t11, e11)
(t12, e12)
...
(t1P , e1P )
(t21, e21)
(t22, e22)
...
(t2P , e2P )
...
...
...
...
(tN1, eN1)
(tN2, eN2)
...
(tNP , eNP )




2. The number of occurrence ckn of each blocks of code
in each application (assuming K possible blocks of
code) with k ∈ [1, K] and n ∈ [1, N].
T2 =




c11
c12
...
c1K
c21
c22
...
c2K
...
...
...
...
cN1
cN2
...
cNK




We use a linear programming solver to ﬁnd the weights wkp
of each block of the code on each platform with k ∈ [1, K]
and p ∈ [1, P]. The problem to solve has the following form
for energy consumption:
for each n ∈ [1, N], p ∈ [1, P],
K
X
k=1
ckn.we
kp = e′
np
(1)
and for run time
for each n ∈ [1, N], p ∈ [1, P],
K
X
k=1
ckn.wt
kp = t′
np
(2)
where e′
np is the statistical energy consumption and t′
np the
statistical run time of a speciﬁc program on a speciﬁc plat-
form (e′
np ≥ enp because compiler optimizations tend to
remove or regroup instructions, thus making the code more
efﬁcient and more compact than originally written). We put
the following constraints which represent the fact that the
energy consumption of one operation must be positive:
for each k ∈ [1, K], p ∈ [1, P], we
kp > 0, wt
kp > 0
(3)
Finally, we minimize the sum of the squared relative error
between e′
np and enp among all the applications:
for each p ∈ [1, P],
N
X
n=1
e′
np
enp
− 1
2
(4)
Respectively, we minimize the error in terms of time
for each p ∈ [1, P],
N
X
n=1
t′
np
tnp
− 1
2
(5)
From now on, if one wants to estimate the power consump-
tion (respectively the run time) of a new application, one
just needs to count the number of occurrences of each block
of the code in the program (e.g., with a parser) and to multi-
ply them with their statistical cost. We maintain a database
table T3 for the weights of the form
T3 =




(wt
11, we
11)
(wt
12, we
12)
...
(wt
1P , we
1P )
(wt
21, we
21)
(wt
22, we
22)
...
(wt
2P , we
2P )
...
...
...
...
(wt
K1, we
K1)
(wt
K2, we
K2)
...
(wt
KP , we
KP )




56
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

Figure 2. Overview of estimation methodol-
ogy.
Instruction
8051 8 bit
8051 16 bit
8051 ﬂoat
CF 24 bit
Summation
16.17
53.79
158.07
0.01
Subtraction
21.12
49.5
816.42
0.10
Multiplication
31.68
86.46
611.49
0.85
Division
76.23
127.05
712.80
2.27
IF Then
4.95
42.24
273.57
0.62
IF Then ELSE
138.93
111.21
2749.89
0.00
Loop Repetition
5.61
4.95
28.38
0.00
Array access
9.57
0.00
106.26
0.10
Assignment
20.13
29.70
130.68
0.00
Modulo
667.92
714.78
113.85
0.61
Table 1. Statistical energy consumption of
processing elements in nano Joules.
We illustrate a global overview of the methodology in Fig-
ure 2 The left part of the schema illustrates how the esti-
mation system is built. This computation work is processed
only once to generate all the statistical weights. The right
part illustrates the work which take place when estimating
a new application, this is the part that needs to be fast and
simple.
3.2.2
Results
The results for ﬁnding the weight of blocks of code are
shown in Table 1 (note that only a subset of all possible
blocks of code is presented). Using those weights, we es-
timated the energy consumption of several other applica-
tions (two of them are presented in more detail in Section
5) and veriﬁed the results with measurements. Our method
shows signiﬁcantly better results for all the platforms as
shown in Table 2. The algorithm is reliable and accurate
for both computational time and computational energy con-
sumption.
3.2.3
Multiprocessor Approach
The evaluation method that we developed is not only capa-
ble to forecast energy consumption for a single computing
element but also for a multi-processor platform. We assume
a proper mapping of the application on the different pro-
Processing element
Word-Width
95% Conﬁdence interval
8051
8
[-13 %;13 %]
8051
16
[-14 %;14 %]
MSP430
16
[-13 %;13 %]
Coolﬂux
24
[-8,3 %; 8,3 %]
Table 2. Conﬁdence intervals for energy esti-
mation on 8051, MSP430 and Coolﬂux.
cessors. We estimate the energy consumption of the code
running on each processing element separately. Then, we
calculate the power required for communication between all
processors (more details in Section 4) and add it to the pre-
viously estimated processor consumptions. This approach
enables to ﬁnd the optimal WSN platform for a speciﬁc ap-
plication when it requires more than one processor (the case
study in Section 5.2 highlights it). For example combining
a CISC for controlling the peripherals and a DSP for com-
puting may be beneﬁcial as long as the overhead in terms
of internal communication and double-powering does not
counter-balance the gains in terms of processing efﬁciency.
4
WSN platform Power Consumption
In Section 3, we presented a method to determine the
power consumption of a speciﬁc application on a speciﬁc
computing element. Because our main interest is in WSN
applications, we propose a method to estimate the energy
consumption of the whole WSN platform using the forecast
for the computing element. We ﬁrst indicate the dominant
factors for WSN platforms with respect to power consump-
tion.
4.1
Power Consumption Factors in WSN
Platforms
Data Acquisition is the sampling of data from a sensor
of the processing element. It contains the power consump-
tion of the sensor (taken from the data sheet or measured
once) and the energy needed by the processing element to
control the communication interface. This last value can be
measured one time for each platform and reuse for any new
application to be benchmarked.
Computation is evaluated as described in Section 3.
Power Mode Change is the action for the processing ele-
ment to go from active mode to sleep mode (and vice-versa).
It is speciﬁc for each platform, but only have to be measured
once for each platform.
Power Down Mode or Sleep Mode represents the en-
ergy consumed by the processing element while sleeping.
Usually processing elements provide a set of power down
modes, diverging with available peripherals, timers and
memory. Each power mode was measured once per plat-
form.
57
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

Task
Coolﬂux
8051
MSP 430
Data acquisition
654
306
170
Computation
0.05
291
46
Power mode changes
0.00
585
158
Idle power
1211
565
794
Overall
1866
1747
1167
Table 3. Power consumption of the ﬁrst case
(in µJ) on the evaluated platforms.
Wireless Communication is predicted using methods de-
scribed in [2] [11].
4.2
Methodology
In order to evaluate the total power consumption of a
WSN platform, we add the individual power consumption
of all those factors together. In order to predict the time that
an application spends in sleep mode or to foresee the num-
ber of power mode changes, we use a periodic model which
is used in most of the WSN applications and consists of six
phases: 1) Power-up mode, 2) Sample data from the sensor,
3) Process data, 4) Transmit data, 5) Power down mode and
6) Sleep mode. The total period of one cycle is chosen by
the programmer and the sleep time is determined by sub-
tracting the foreseen time for data sampling, computation,
transmission and power mode change.
5
Case Studies
In this section, we describe the performance results ob-
tained from our implementation. We carried out the imple-
mentation and evaluation of two very typical sensor network
applications and discuss their energy efﬁciency on different
processing elements. We consider single processor as well
as multiprocessor solutions in this regard.
5.1
Applications with Moderate Compu-
tational Requirements
In order to provide a concrete example on how to apply
our method, the ﬁrst application that we consider is acceler-
ation sensing. An accelerometer acquires 16 bit values at a
frequency of 50Hz. If the values are greater than a speciﬁc
threshold, an alert is transmitted to a hub. The computing
element is shut-down between each sample. Table 3 shows
the break-down of power consumption of the application on
various platforms (over 1s). In the following, we describe
the various sources of energy consumption in the sample
application.
5.1.1
Data Acquisition
Out of the previously described classes of processing el-
ements, GPPs are the most efﬁcient for data acquisition.
Since GPP platforms have integrated peripheral interfaces
such as UART and SPI, these can communicate with the
sensors very efﬁciently. Both MSP430 and 8051 have an in-
tegrated SPI. The activation of the interface consumes only
60 µW of power, which is insigniﬁcant compared to the ac-
tive power consumption of the two processors. In the sam-
ple application, the processing elements cannot utilize the
idle time during the data acquisition for computations as
there is only a single task running. Furthermore, energy
savings cannot be obtained just by switching into the sleep
mode as the time interval is too short.
Coolﬂux platform requires a signiﬁcant amount of en-
ergy for data acquisition owing to the absence of a dedicated
serial interface and can only emulate the serial protocol in
the software (bit-banging). This causes very high acquisi-
tion time and current consumption on Coolﬂux. Therefore,
a Coolﬂux is the least efﬁcient processing element during
data acquisition.
5.1.2
Computation
From the computational point of view, Coolﬂux is the
most energy and time efﬁcient processor element in our
study.
Coolﬂux contains two Arithmetic Logical Units
(ALUs) and can therefore execute multiple instructions in
a single cycle. In the 16-bit data processing application,
Coolﬂux can work on its 24-bit native word-width. 8051
and MSP430 require a comparable run-time for computa-
tions. 8051 has an 8 bit ALU. Therefore, it requires addi-
tional cycles for each 16 bit operation. MSP430 as a RISC
processor, is more cycle effective and additionally can work
at its native word-width. Therefore, the power consumed by
MSP430 is signiﬁcantly lower for this application. Overall,
Coolﬂux is magnitude times more energy and time effective
than the CC2430 and the MSP430.
5.1.3
Power Mode Changes
8051 requires a signiﬁcant amount of energy for a single
power mode change. For a sampling rate of 50 Hz, the en-
ergy spent in mode transitions is more than the computation
itself. 8051 spends about 94 % of its time in power down
mode and 4 % of time in power mode changes, but through
the low energy consumption in power down mode, most of
the energy is spent in the mode changes. MSP430 requires
about the same time to switch to sleep mode, but through
its lower current, the energy consumption for that is sig-
niﬁcantly lower. Contrary to the GPPs, Coolﬂux platform
decouples the clock network and does it within a few cy-
cles. The energy consumed for the power mode change is
only 0.16 nW.
58
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

5.1.4
Energy Consumption in Sleep Mode
Coolﬂux can change its power mode very fast. On the other
hand, the power down mode itself is less effective. Coolﬂux
consumes about 25 % of its active power in sleep mode.
By spending a long time in sleep mode, the overall power
spent in sleep mode exceeds the power spent in all the other
operations in the sample application.
The power down modes of MSP430 and 8051 consume
about the same amount of energy. 8051 also supports more
effective power modes than the chosen power mode in our
application, but only supports half of its memory. MSP430
also supports other power down modes but since it has a
relatively large switching time, these are not used in our
sample application.
5.1.5
Efﬁciency depending on the Sampling Rate
We change the accelerometer sampling rate to understand
its impact on the overall energy efﬁciency.
Results are
shown in Figure 3. Note that CC2430 relates to a platform
containing a 8051. If the sample rate is very low, 8051 turns
out to be the most energy efﬁcient processing element, be-
cause of its low power consumption in power down mode.
MSP430 is more effective in data acquisition and power
mode changes. Therefore, starting at a sample rate of 18
Hz, MSP430 becomes more efﬁcient for our sample appli-
cation.
It may be noted that Coolﬂux becomes more power efﬁ-
cient than 8051 beyond a certain sampling rate. Although
the Coolﬂux is less effective in data acquisition, its ability
for computation and energy effective power mode changes
compensates it. Overall, the MSP430 is relatively the most
preferred processing element for high sampling rates.
The maximum supported sampling rates are 1310 Hz for
Coolﬂux, 2564 Hz for 8051 and 3322 Hz for MSP430. A
lower maximum sampling frequency of Coolﬂux is caused
by its inability for higher data acquisition rate. The differ-
ence between 8051 and MSP430 is caused by the computa-
tional ability of MSP430.
5.1.6
Efﬁciency depending on the Computation
Depending upon the computational power, the efﬁciency
of the processing elements is also evaluated. We modify
the number of calculations in the application.
Figure 4
shows the energy consumption depending on the propor-
tion of computations compared to the initial application. It
allows estimating, how much computation would make it
worth to implement the algorithm on another processing el-
ement. 8051 becomes less effective than Coolﬂux for the
application if the number of computations is doubled. If
the amount of computation is increased by a factor of 20,
Coolﬂux becomes more efﬁcient than MSP430.
0
500
1000
1500
2000
2500
3000
3500
0
7
14
21
28
35
42
49
56
63
70
77
84
91
98
Sampling Frequency
Energy consumption in μJ
MSP430
CC2430
Coolflux
Figure 3. Inﬂuence of the sensor sampling
rate on the energy consumption of the 8051
(inside CC2430), MSP430 and Coolﬂux.
0
5000
10000
15000
20000
25000
30000
35000
0,1
1
10
100
1000
Computation factor to sample application
Energy consumption in µJ
MSP430
CC2430
Coolflux
Figure 4. Inﬂuence of the computational load
on the energy consumption of the 8051 (in-
side CC2430), MSP430 and Coolﬂux.
In conclusion, the presented example highlights the at-
tributes of different classes of processing elements. As a
DSP is more effective for calculations, GPPs are more ef-
fective during data acquisition. The sample application con-
sidered above is very simple and requires only a very lim-
ited number of computations. Also, the number of compu-
tations required are clearly dominated by conditional jumps
and not by arithmetic operations. Therefore, a simple pro-
cessor efﬁciently supporting fast switching modes and low
energy consumption in power down mode is the best choice
for this kind of application. Multiprocessor concepts are
not suitable, since the complexity of the algorithm is low
and the energy spent in power down mode exceeds all the
possible energy improvements.
5.2
Applications
with
High
Computa-
tional Requirements
A second study case is the recognition of heart rate from
ECG data using a real-time algorithm. The heart rate must
59
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

Task
8051
MSP430
MSP430+Coolﬂux
Data acquisition
7.5
3.0
3.0
Computation
6
3.9
0.1
Wireless communication
1.2
1.3
1.2
Serial communication
0.1
Power mode changes
5.9
2.4
2.4
Idle power
0.0
0.2
1.3
Overall
20.6
10.8
8.1
Table 4. Power consumption of the second
case (in mJ) on the evaluated platforms.
be sampled at high frequency to obtain reliable results. The
amount of computations is high because of the real-time na-
ture of the algorithm. The heart rate calculation is sent reg-
ularly to a hub. We evaluated an in-house developed heart
rate analysis code using a sampling rate of 500 Hz. It cal-
culates the heart beat using an algorithm described in [12].
This algorithm does not store all the heart beat samples and
therefore requires little memory.
The algorithm is dom-
inated by comparison operations and 32 bit calculations.
The application is divided into data acquisition, computa-
tion and wireless communication.
A comparison of a platform combining MSP430 and
Coolﬂux is shown in Table 4 (over 1s).
A stand alone
Coolﬂux solution is not appropriate, because of its ineffec-
tive data acquisition. On the combined platform, data ac-
quisition is done on MSP430 because there is no ADC on
Coolﬂux. Due to the high sampling rate, it takes a signiﬁ-
cant amount of time and energy. The multiprocessor solu-
tion has the advantage to allow higher sampling rates than
the single processor solution. The computations are very ef-
fective on Coolﬂux DSP. Indeed the 12-bit data gets double
after multiplication and ﬁts very well to the 24-bit architec-
ture of Coolﬂux unlike MSP430 or 8051. Therefore, the
Coolﬂux is magnitude times more effective than MSP430
or 8051. Altogether with the multiprocessor approach, the
power consumption is reduced by a factor of 28%. The pro-
posed multiprocessor solution beneﬁts from the strenghs of
both classes of processing elements, namely the computa-
tional ability of DSPs and the fast data acquisition of GPPs,
but this at the expense of size and complexity.
6
Multi-processor Scheduling
It is evident from the previous section that in some cases,
an application can be implemented more energy efﬁciently
on multiple specialized processing elements rather than on
a single multi-purpose processing element. This leads to
ﬁnding the best combination of the selected hardware. Si-
multaneously, it is required to split-up the application into
tasks that are can be assigned to the selected hardware. The
hardware selection and the correspondingly task scheduling
is done mostly manually, which remains inefﬁcient. With
a wider range of energy efﬁcient processing elements and
furthermore their distributed nature such as in wireless sen-
sor networks, the task becomes increasingly complex and
unmanageable.
In Section 3, we have developed an approach that can be
used to support power efﬁcient implementation of a given
application on multi-processor hardware.
Tasks such as
data acquisition, performing calculations, data communi-
cation, power mode switching and energy consumption in
idle mode are the fundamental blocks of the overall energy
consumption on a sensor node. In our approach, after the
system designer speciﬁes an application, the code is broken
down to granular blocks and weights are calculated for each
of the block on all the processing elements under considera-
tion. In addition to the application related facts, the designer
also speciﬁes timing and data dependency of the application
tasks. The hardware and software requirements are formu-
lated as conditions. Each combination of hardware with the
regarding scheduling has to meet all the conditions. The
sum of the weights of each block shows the total energy
consumption of a working solution. The minimum of this
sum shows the most energy efﬁcient solution of the evalu-
ated hardware.
The solution space for the described conditions grows
exponentially with the number of considered processing el-
ements and tasks. In order to calculate the energy consump-
tion of a wide range of possible solutions, NP solvers are
used. Integer Linear Programming (ILP) solvers can di-
rectly be used to calculate the most energy efﬁcient solution.
In the following, we describe the detailed formulation of the
multi-processing scheduling problem to be solved through
ILP.
6.1
Attributes of the Tasks
Each task requires a set of constraints in order to describe
their behaviour and to allow the formulation of equations
for their scheduling.
Eβ,γ
Energy consumed by task β on
hardware γ
Tβ,γ
Average time required per second for
task β on node γ
Tβ
Average maximum execution time
required for task β
Cβ1,β2
Number of exchangeable bits from
task β1 to β2
Ξ
Number of all tasks to be scheduled
Oβ
Average number occurrence of task β
Eβ,γ describes the energy consumed by task β on hard-
ware γ. Also the run-time of a task Tβ,γ on a certain hard-
ware has to be ascertained.
It is referenced against the
60
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

scaled real-time constraint Tβ. These values are scaled to
the required time per second. This allows to consider the
number of occurrences and the elapsed time on the hard-
ware simultaneously. If the number of exchangeable bits
Cβ1,β2 for a task is greater than zero, both parts are depen-
dent on each other. Additionally, this value is used to cal-
culate the energy consumption cost of the communication
task.
6.2
Attributes of the Networked Nodes
The networked nodes require a set of attributes in order
to distribute the hardware according to the speciﬁcation.
Sα,β,γ,δ
Task β is scheduled on node α on
hardware γ with ID δ
Υ
Available sensor nodes
∆
Available hardware IDs
The variable Sα,β,γ,δ describes the scheduling of task β on
hardware γ with hardware ID δ to the node α. Furthermore,
the scheduling implicitly contains a hardware selection γ.
It is possible to have multiple instances of γ in the network
node and these instances are numbered with δ.
6.3
Attributes of the Hardware
The hardware requires attributes in order to describe the
hardware for the solver and checking the suitability of spe-
ciﬁc tasks. The hardware attributes optimize the hardware
for the constraints given by the tasks and the network nodes’
attributes.
EIγ
Energy consumed by hardware γ
in idle mode
CCα1,α2,γ1,γ2,δ1,δ2 Communication cost between
hardware γ1 and γ2
Γ
Available hardware
ECγ
Energy consumption of power mode
change on hardware γ
The idle state energy consumption EIγ becomes signiﬁcant
when a processing element is used very rarely. Each hard-
ware has certain available peripherals APγ,ϵ. The commu-
nication cost of two hardware elements CCα1,α2,γ1,γ2,δ1,δ2
depends on hardware location. ECγ describes the energy
required to change power mode on hardware γ.
6.4
Computing the Overall Energy Con-
sumption
Integer Linear Programming requires an objective func-
tion that is either maximized or minimized. The term to
be minimized in our case is the energy consumption of the
overall network. It consists of the energy consumption of
all the tasks running on different nodes. The run-time and
real-time constraints are applied to the summed energy con-
sumption formulation in order to obtain the optimum.
Sα,β1,γ,δ1 is used as Boolean including the scheduled el-
ements. The ﬁrst sum describes the energy consumption of
the tasks.
X
tasks
=
X
αϵΥ,βϵΞ,γϵΓ,δϵ∆
Sα,β,γ,δEβ,γ.
(6)
The second sum contains the energy consumed in idle
mode. Therefore the average run-time in idle mode is cal-
culated by subtracting the time spent in active mode. This
is multiplied by the energy of the elements in idle mode
X
idle
=
X
αϵΥ,γϵΓ,δϵ∆
(1 −
X
βϵΞ
Sα,β,γ,δTβ,γ)EIγ.
(7)
The next sum is the communication costs between the tasks.
Again Sα,β1,γ,δ1 is used as Boolean to exclude not sched-
uled tasks, whereas Cβ1,β2 describes the amount of commu-
nication and CCα1,α2,γ1,γ2,δ1,δ2 the communication costs
X
com
=
X
αϵΥ,β1ϵΞ,β2ϵΞ,γϵΓ,δ1ϵ∆,δ2ϵ∆
Cβ1,β2Sα,β1,γ,δ1∗
Sα,β2,γ,δ2CCα1,α2,γ1,γ2,δ1,δ2.
(8)
The last sum describes the energy spent on task mode
changes. The assumption of diverging sample rates of the
different applications does not allow to combine tasks to
save energy through a decrease of power mode changes.
X
changes
=
X
αϵΥ,βϵΞ,γϵΓ,δϵ∆
Sα,β2,γ,δ2OβECγ.
(9)
All considered energy consumptions can be summed to-
gether in
X
total
=
X
tasks
+
X
idle
+
X
com
+
X
changes
(10)
The implementations constraints need to be formulated. For
example equation 11 describes the real-time constraints of
the problem. It is necessary to be sure, that the run-time
of all scheduled tasks on the hardware is smaller than the
real-time constraint of the task.;
X
αϵΥ,γϵΓ,δϵ∆
Sα,β,γ,δTβ,γ ≤ Tβ.
(11)
Additional constraints are required for computational re-
strictions, ﬁxed hardware assignments, identiﬁcation of
hardware in a speciﬁc node and hardware restrictions.
These are formulated analogously.
61
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

This formulation as ILP of minimization of the global
energy consumption of the network, although not allready
solved, provides some understanding of the problem.
It
highlights the trade-off between computation, communica-
tion, power mode changes and idle mode that need to be
take in account to reach an optimal solution.
7
Conclusions and Future Work
In this article, we described a new method for estimating
the power consumption of a particular application on differ-
ent wireless sensor node platforms. The method involves
slicing down a whole application into smaller granular
blocks of code. We use a linear programming solver to de-
termine the weights associated for each of the code block on
each platform. Through a detailed case study, we analyzed
the trade-offs among CISC, RISC and DSP approaches for
WSN nodes and showed empirically that our method is ac-
curate. We carried out the evaluation of our methodology
on 8051, MSP430 and Coolﬂux processors, representing the
three processor classes. Our method provides easy way to
estimate the power consumption but trades-off the accuracy.
However, it is worth noticing that our method achieved a
worst-case accuracy of 86%. We evaluated an application
with meager computing requirements as well as a compu-
tationally intensive application. Our scheme requires just a
single code implementation of the application for determin-
ing the most power efﬁcient computing element, which will
help code developers easily select the most suitable plat-
form. The presented scheme also allows efﬁcient bench-
marking of the processing elements and determining the
most energy efﬁcient element, thereby saving costs and im-
plementation efforts. We have also presented an extension
of the scheme to multi-processor architectures. We have ap-
plied linear programming approach to efﬁciently schedule
different tasks on a multi-processor platform. Real world
applications are typically realized on a number of network
nodes rather than just on a single node. Therefore, a local
energy optimal solution may not necessary be the global en-
ergy optimal solution. In order to ﬁnd a globally optimized
estimate, a system wide hardware selection and scheduling
is required. It is possible to build up a system of linear
conditions, which represent the restrictions for a practical
WSN. Using linear programming, the global energy opti-
mal implementation of a network can be calculated based
on the local estimation provided by our methodology.
Acknowledgments
We would like to thank the ﬁnancial support from E.U.
(project IST-034963-WASP), Philips Research, Deutsche
Forschungsgemeinschaft through the UMIC-excellence
cluster and RWTH Aachen University.
References
[1] S. Corroy, J. Beiten, J. Ansari, H. Baldus, and P. M¨ah¨onen.
Energy efﬁcient selection of computing elements in wire-
less sensor networks. In International Conference on Sen-
sor Technologies and Applications (SENSORCOMM 2008),
pages 312–318, 2008.
[2] M. Achir and L. Ouvry. QoS and energy consumption in
wireless sensor networks using CSMA/CA. Technical re-
port, Electronics and Information Technology Laboratory
Atomic Energy Commission, 2005.
[3] W. Bircher and L. John. Complete system power estimation:
A trickle-down approach based on performance events. In
IEEE International Symposium on Performance Analysis of
Systems & Software, April 2007.
[4] A. Dunkels, F. ¨Osterlind, N. Tsiftes, and Z. He. Software-
based sensor node energy estimation. In Proceedings of the
5th international conference on Embedded networked sen-
sor systems, pages 409–410, 2007.
[5] D. Feinstein, M. Thornton, and F. Kocan. System-on-chip
power consumption reﬁnement and analysis. In 6th IEEE
Dallas Circuits and Systems Workshop on SoC, 2007.
[6] H. Joe, J. Park, C. Lim, D. Woo, and H. Kim. Instruction-
level power estimator for sensor networks. ETRI Journal,
30(1):47–58, February 2008.
[7] O. Landsiedel, H. Alizai, and K. Wehrle. When timing mat-
ters: Enabling time accurate and scalable simulation of sen-
sor network applications. In Proceedings of the 7th interna-
tional conference on Information processing in sensor net-
works, pages 344–355, 2008.
[8] I. S. MacKenzie. The 8051 Microcontroller, volume 4th Edi-
tion. Prentice Hall, 2001.
[9] S. Niar and N. Inglart. Rapid performance and power con-
sumption estimation methods for embedded system design.
In 7th IEEE Int. Workshop on Rapid System Prototyping,
pages 47–53, June 2006.
[10] NXP, http://www.coolﬂuxdsp.com. Coolﬂux DSP, 2004-05.
[11] L. Ouvry and M. Achir. Probabilistic model for energy esti-
mation in wireless sensor networks. Lecture Notes in Com-
puter Science, 3121/2004:157–170, 2004.
[12] J. Pan and W. Tompkins. A real time QRS detection algo-
rithm. IEEE Trans. On Biomedical Engineering, 32, 1985.
[13] J. Polastre, J. Hill, and D. Culler. Versatile low power me-
dia access for wireless sensor networks. In Proc. of SenSys,
pages 95–107, 2004.
[14] V. Shnayder, M. Hempstead, B. rong Chen, G. W. Allen, and
M. Welsh. Simulating the power consumption of large-scale
sensor network applications. In Proceedings of the 2nd in-
ternational conference on Embedded networked sensor sys-
tems, pages 188–200, 2004.
[15] Texas
Instrument,
http://focus.ti.com/docs/prod/folders/
print/cc2430.html. CC2430, 1995-2007.
[16] Texas
Instruments,
http://focus.ti.com/docs/prod/folders/
print/msp430f1611.html. TI MSP430x1611 - Mixed Signal
Microcontroller, 2005.
[17] Y. Wei, J. Heidemann, and D. Estrin. Medium access con-
trol with coordinated adaptive sleeping for wireless sensor
networks. IEEE Trans. on Net., 12(3):493–506, June 2004.
62
International Journal On Advances in Networks and Services, vol 2 no 1, year 2009, http://www.iariajournals.org/networks_and_services/

