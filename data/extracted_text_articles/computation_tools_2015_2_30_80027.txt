A New Refutation Calculus With Logical
Optimizations for PLTL
Mauro Ferrari
DiSTA
Universit`a degli Studi dell’Insubria
Email: mauro.ferrari@uninsubria.it
Camillo Fiorentini
DI
Universit`a degli Studi di Milano
Email: ﬁorentini@di.unimi.it
Guido Fiorino
DISCo
Universit`a degli Studi di Milano-Bicocca
Email: guido.ﬁorino@unimib.it
Abstract—Propositional Linear Temporal Logic (PLTL) is a tool
for reasoning about systems whose states change in time. We
present an ongoing work on a new proof-search procedure for
Propositional Linear Temporal Logic and its implementation. The
proof-search procedure is based on a one-pass tableau calculus
with a multiple-conclusion rule treating temporal-operators and
on some logical optimization rules. These rules have been devised
by applying techniques developed by the authors for logics with
Kripke semantics and here applied to the Kripke-based semantics
for Propositional Linear Temporal Logic.
Keywords–Propositional Linear Temporal Logic; Tableaux; Sat-
isﬁability checking.
I.
INTRODUCTION
In recent years, while studying proof-search procedures
for non classical logics, we have introduced new tableau
calculi and logical optimization rules for propositional Intu-
itionistic Logic (INT) [1] and propositional G¨odel-Dummett
Logic (DUM) [2]. As an application of these results, we
have implemented theorem provers for these logics [2][3]
that outperform their competitors. The above quoted calculi
and optimizations are the result of a deep analysis of the
Kripke semantics of the logic at hand. In this paper, we show
how such semantical analysis can also be fruitfully applied to
other non-classical logics with a Kripke-based semantics, by
analyzing the case of PLTL. In particular, we present a new
refutation tableau calculus and logical optimizations for PLTL
and we brieﬂy discuss a prototype Prolog implementation of
the resulting proof-search procedure.
As for related works, our tableau calculus for PLTL lies
in the line of the one-pass calculi based on sequents and
tableaux of [4][5][6], whose features are suitable for automated
deduction. We also cite as related the approaches based on
sequent calculi discussed in [7][8] and the natural deduction
based proof-search technique discussed in [9]. The results
in [10][11] are based on resolution, thus they are related less
to our approach.
The paper is organized as follows. Section II provides
the core of our logical characterization for PLTL, Section III
describes some optimization rules based on replacement of
formulas, Section IV gives an account of the performances
of the Prolog prototype under development, ﬁnally Section V
summarizes the work with a short discussion.
II.
A NEW LOGICAL CHARACTERIZATION OF PLTL
We restrict ourselves to the temporal connectives Until U
and Next ◦. Entering more in details, our ﬁrst contribution is
a new logical characterization of PLTL by means of a tableau
calculus whose distinguished feature is the multiple-conclusion
rule Lin, that is a rule whose number of conclusions depends
on the number of U-formulas in the premise. The rule Lin is
inspired by the multiple-conclusion rules we have developed
in [2][12] to logically characterize the logic DUM. As a matter
of fact, PLTL and DUM are semantically characterized by
Kripke models based on linearly ordered states (we recall
that PLTL and DUM have different languages and a different
interpretation of the connective →).
We give an account of rule Lin by means of an example
which also introduces the argument to prove its correctness.
Figure 1 contains the version for the language restricted
to the temporal connectives U and ◦. Let us suppose that
at time t a PLTL model K satisﬁes the set of formulas
S = {◦A, ◦(BUC), ◦(DUE)} (in formulas t ⊩ S), where
the main connective of A is not U. This implies that: (i)
t + 1 ⊩ A holds; (ii) there exists t1 > t such that t1 ⊩ C
and, for every t < t′ < t1 , t′ ⊩ B hold; (iii) there exists
t2 > t such that t2 ⊩ E and, for every t < t′ < t2,
t′ ⊩ D hold. The possible relationships among t + 1, t1
and t2 are the following: (1) t + 1 < t1, t2. In this case,
t+1 ⊩ {A, B, D, ◦(BUC), ◦(DUE)} holds; (2) t+1 = t1 and
t1 ≤ t2. Hence t + 1 ⊩ {A, C, (DUE)} holds; (3) t + 1 = t2
and t1 > t2. So we get t + 1 ⊩ {A, B, ◦(BUC), E} holds.
Summarizing rule Lin handles ◦-formulas introducing in the
conclusion one branch for every formula of the kind ◦(AUB)
and one branch for all the other kind of ◦-formulas. In Figure 2
we show the tableau tree for the example.
At ﬁrst sight, rule Lin does not seem helpful to perform
automated deduction, since it can generate an huge number
of branches. However, as discussed in [2] for DUM, theorem
provers using the multiple-conclusion rules as Lin can be
effective. Moreover, a theorem prover can beneﬁt from some
further formulas (we call them side formulas) that we can
insert in the conclusions of Lin. The side formulas represent
correct information which is not necessary to handle to get
the completeness. Let us suppose that neither (1) nor (2) hold.
Then we can also prove that t + 1 ⊩ ¬(D ∧ ◦E) holds. When
D = ⊤ (that is DUE coincides with ⋄E), then we can prove
that for every t′ ≥ t+2, t′ ⊩ ¬E holds. This information is not
necessary to the deduction but it can be exploited to perform
automated deduction. In particular, when the eventuality DUE
31
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-394-0
COMPUTATION TOOLS 2015 : The Sixth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

◦A1, . . . , ◦An, ◦(B1UC1), . . . , ◦(BmUCm)
S, B1, . . . , Bm, ◦(B1UC1), . . . , ◦(BmUCm)|S, C1, B2UC2, . . . , BmUCm|H2| . . . |Hm
Lin
where, S = {A1, . . . , An} and for i=2,...,m
Hi = ((S ∪{◦(B1UC1), . . . , ◦(BmUCm)})\{◦(BiUCi), . . . , ◦(BmUCm)})∪{B1, . . . , Bi−1, Ci, ¬(Bi∧◦Ci), Bi+1UCi+1, . . . , BmUCm}
Figure 1. The multiple-conclusion rule Lin
◦A, ◦(BUC), ◦(DUE)
A, B, D, ◦(BUC), ◦(DUE)
C, DUE
C, E
C, ◦(DUE)
E
Lin
U
◦(BUC), E
C
Lin
Lin
A, C, DUE
A, C, E
A, C, ◦(DUE)
E
Lin
U
A, ◦(BUC), E
C
Lin
Lin
where U denotes the application of rule
AUB
B|◦(AUB)
U
Figure 2. Example of application of rule Lin
coincides with ⋄E we get that from the time t+2 the formula
E coincides with ⊥. As a consequence, we have that if there is
a loop, then t and t+1 are not part of the loop and a theorem
prover can reset the history information. Moreover, since E is
equivalent to ⊥, it is correct to replace all the occurrences of
the formula E with ⊥. Rules based on replacement of formulas
with logical constants have been proved effective both for
INT [1] and for DUM [2].
III.
REPLACEMENTS RULES
In this section, we consider □ in the language. We write
S[B/A] to denote the set of formulas obtained by replacing
in S every occurrence of A with B. The rules Replace-□ and
Replace-□¬ given below are the analogous of rules Replace-T
and Replace-T¬ given in [1][13]:
S, □A
S[⊤/A], □A
Replace-□,
S, □¬A
S[⊥/A], □¬A
Replace-□¬.
A special case of Replace-□ and Replace-□¬ are the rules
S, A
S{⊤/A}, A
Replace-cl,
S, ¬A
S{⊥/A}, ¬A
Replace-cl-¬.
where S{B/A} (note the curly braces) denotes the set of
formulas obtained by replacing with B the occurrences of A
in S that are not under the scope of any temporal connective.
In [1], we have introduced some variants of Replace-□ and
Replace-□¬ based on the Kleene sign property. We exploit
some conditions under which we can replace a propositional
variable p applying the rules Replace-□ and Replace-□¬ also
when neither □p nor □¬p explicitly occur in the premise of
the rule. The condition for the applicability of these rules is
based on the notion of polarity of p: p can be eliminated
from a set of formulas S (replaced with ⊤ or ⊥) if all the
occurrences of p in S have the same polarity. The notion of
polarity can be easily explained in the framework of PLTL
where formulas of the kind A → B are written as ¬A ∨ B
and Negation Normal Form is applied: a propositional variable
p occurs with positive (resp. negative) polarity in a set S,
denoted with p⪯+ S (resp. p⪯− S) iff no occurrence (resp.
every occurrence) of p in S is of the kind ¬p. The following
are replacement rules of propositional variables fulﬁlling the
notion of positive or negative occurrence in a set that can be
computed in linear time on S:
S
S[⊤/p]
⪯+ , provided p⪯+ S;
S
S[⊥/p]
⪯− , provided p⪯− S.
In Figure 3 we show a piece of deduction for the formula
acacia-demo-v3_1, where also we apply some obvious
boolean simpliﬁcations.
IV.
PRELIMINARY RESULTS
We have developed a Prolog prototype to perform some
experiments on the benchmark formulas for PLTL. The devel-
opment of the prover is at the very early stage. We have only
focused on the implementation of the logical calculus with
rule Lin in its ﬁrst simpliﬁed version (without side formulas)
and the optimization rules provided in Section III. The part of
the prover related to the history construction, loop-checking
and loop-satisfaction is very naive. Thus, in general, the
known provers outperform our implementation. However, there
are some remarks related to the proposed optimizations that
deserve a comment. First, all the optimizations rules we have
described are effective in speeding-up the deduction. Second,
the rules ⪯+ and ⪯−
apply to the benchmark formulas
acacia-demo-v3, alaska-szymanski, rozier (some
subfamilies), O1-schuppan and trp (some subfamilies)
without requiring any deduction step. On our Mac OS X
(2.7 GHz, Core i7, 8GB), in less than 10 (often in less
that 1) seconds, the prototype decides the families acacia,
alaska-lift
(except
for
the
non-negated
l
vari-
ant), alaska-szymanski, anzu-amba, anzu-amba_c
and anzu-amba_cl in negated version, forobotsr1f0
(many formulas in the negated version and in a few
cases also the non-negated versions), rozier-formulas,
rozier-patterns,
schuppan-O1
and
trp
(some
cases). Without the described optimizations timings would be
greater by some order of magnitudes.
32
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-394-0
COMPUTATION TOOLS 2015 : The Sixth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

H ≡ ⊤ U (canc ∧ ◦¬go) ∨ (□(¬req ∨ ◦grt ∨ ◦◦grt ∨ ◦◦◦grt) ∧ □(¬grt ∨ ◦¬grt) ∧ □(¬canc ∨ ◦(¬grt U go)))
⊤ U (canc ∧ ◦¬go) ∨ (□(¬⊥ ∨ ◦grt ∨ ◦◦grt ∨ ◦◦◦grt) ∧ □(¬grt ∨ ◦¬grt) ∧ □(¬canc ∨ ◦(¬grt U go)))
⊤ U (canc ∧ ◦¬go) ∨ (□(⊤ ∨ ◦grt ∨ ◦◦grt ∨ ◦◦◦grt) ∧ □(¬grt ∨ ◦¬grt) ∧ □(¬canc ∨ ◦(¬grt U go)))
H′ ≡ ⊤ U (canc ∧ ◦¬go) ∨ (□(⊤) ∧ □(¬grt ∨ ◦¬grt) ∧ □(¬canc ∨ ◦(¬grt U go)))
⊤ U (canc ∧ ◦¬go) ∨ (□(⊤) ∧ □(¬⊥ ∨ ◦¬⊥) ∧ □(¬canc ∨ ◦(¬⊥ U go)))
⊤ U (canc ∧ ◦¬go) ∨ (□(⊤) ∧ □(⊤ ∨ ◦⊤) ∧ □(¬canc ∨ ◦(⊤ U go)))
⊤ U (canc ∧ ◦¬go) ∨ (□(⊤) ∧ □(⊤) ∧ □(¬canc ∨ ◦(⊤ U go)))
⊤ U (canc ∧ ◦¬go) ∨ □(¬canc ∨ ◦(⊤ U go))
bool
bool
bool
⪯− , grt⪯− H′
bool
bool
⪯− , req⪯− H
Figure 3. Example of application of rule ⪯− to the formula acacia-demo-v3_1
V.
CONCLUSION AND FUTURE WORK
We have presented our ongoing research on automated
deduction for PLTL. We face the problem along different
lines. In this note we have discussed two of them: Section II
provides some ideas for a new proof-theoretical characteriza-
tion of PLTL based on a multiple-conclusion rule; Section III
describes logical rules to cut the size of the proofs. In addition
to the given results, an important part of the future work is to
exploit the notions of local formula [3] and evaluation [14] to
develop an advanced strategy to avoid some rule application.
ACKNOWLEDGMENT
The third author acknowledges the support of the MIUR
PRIN 2010-2011 grant “Automi e Linguaggi Formali: Aspetti
Matematici e Applicativi”, code 2010LYA9RH.
REFERENCES
[1]
M. Ferrari, C. Fiorentini, and G. Fiorino, “Simpliﬁcation rules for
intuitionistic propositional tableaux,” ACM Trans. Comput. Logic,
vol. 13, no. 2, Apr. 2012, pp. 14:1–14:23. [Online]. Available:
http://doi.acm.org/10.1145/2159531.2159536
[2]
G. Fiorino, “Refutation in Dummett logic using a sign to express the
truth at the next possible world,” in IJCAI, T. Walsh, Ed. IJCAI/AAAI,
2011, pp. 869–874.
[3]
M. Ferrari, C. Fiorentini, and G. Fiorino, “fCube: An efﬁcient prover for
intuitionistic propositional logic,” in LPAR (Yogyakarta), ser. Lecture
Notes in Computer Science, C. G. Ferm¨uller and A. Voronkov, Eds.,
vol. 6397.
Springer, 2010, pp. 294–301.
[4]
K. Br¨unnler and M. Lange, “Cut-free sequent systems for temporal
logic,” J. Log. Algebr. Program., vol. 76, no. 2, 2008, pp. 216–225.
[5]
J. Gaintzarain, M. Hermo, P. Lucio, M. Navarro, and F. Orejas, “Dual
systems of tableaux and sequents for PLTL,” J. Log. Algebr. Program.,
vol. 78, no. 8, 2009, pp. 701–722.
[6]
S. Schwendimann, “A new one-pass tableau calculus for PLTL,” in
Tableaux’98, 1998, pp. 277–291.
[7]
R. Pliuskevicius, “Investigation of ﬁnitary calculus for a discrete linear
time logic by means of inﬁnitary calculus,” in Baltic Computer Science,
ser. Lecture Notes in Computer Science, J. Barzdins and D. Bjørner,
Eds., vol. 502.
Springer, 1991, pp. 504–528.
[8]
B. Paech, “Gentzen-systems for propositional temporal logics,” in CSL,
ser. Lecture Notes in Computer Science, E. B¨orger, H. K. B¨uning, and
M. M. Richter, Eds., vol. 385.
Springer, 1988, pp. 240–253.
[9]
A. Bolotov, O. Grigoriev, and V. Shangin, “Automated natural deduction
for propositional linear-time temporal logic,” in TIME. IEEE Computer
Society, 2007, pp. 47–58.
[10]
M. Fisher, C. Dixon, and M. Peim, “Clausal temporal resolution,” ACM
Trans. Comput. Log., vol. 2, no. 1, 2001, pp. 12–56.
[11]
M. Suda and C. Weidenbach, “Labelled superposition for PLTL,”
in LPAR, ser. Lecture Notes in Computer Science, N. Bjørner and
A. Voronkov, Eds., vol. 7180.
Springer, 2012, pp. 391–405.
[12]
G. Fiorino, “Tableau calculus based on a multiple premise rule,”
Information Sciences, vol. 180, no. 19, 2010, pp. 371–399.
[13]
F. Massacci, “Simpliﬁcation: A general constraint propagation tech-
nique for propositional and modal tableaux,” in Proc. International
Conference on Automated Reasoning with Analytic Tableaux and
Related Methods, Oosterwijk, The Netherlands, ser. LNCS, H. de Swart,
Ed., vol. 1397.
Springer-Verlag, 1998, pp. 217–232.
[14]
M. Ferrari, C. Fiorentini, and G. Fiorino, “An evaluation-driven decision
procedure for G3i,” TOCL, in press.
33
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-394-0
COMPUTATION TOOLS 2015 : The Sixth International Conference on Computational Logics, Algebras, Programming, Tools, and Benchmarking

