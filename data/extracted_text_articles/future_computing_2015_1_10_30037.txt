FUTURE COMPUTING 2015 : The Seventh International Conference on Future Computational Technologies and Applications
Copyright (c) IARIA, 2015. ISBN: 978-1-61208-389-6
1
Ternary Arithmetic Pipeline Architectures using multi-bit Memristors
Dietmar Fey
Friedrich-Alexander-University Erlangen-N¨urnberg (FAU)
Department Computer Science 3, Chair for Computer Architecture
Email: dietmar.fey@fau.de
Abstract—The paper addresses the possibilities exploiting the
multi-bit storing features of memristor cells for balanced ternary
signed-digit (SD) arithmetic pipelines realising addition, sub-
traction and multiplication. Different pipeline schemes using
memristors as pipeline registers are shown in overview. Their
functionality was veriﬁed on digital level by SystemC simulations
and their performance is comparatively evaluated using analytic
methods. In a ternary SD number system the digits of the
operands can be assigned not only to 0 and 1 but also to minus 1.
Such an SD representation has the great advantage that additions
and subtractions can be carried out in O(1) step, i.e., the run time
is independent from the word length N. However, this requires
a physical memory cell that allows to store reliably not only
two but at least three states and in addition such a device has
to offer fast access times and must be compatible with CMOS
logic. All these constraints are fulﬁlled by memristors. Using
memristor based pipeline registers offers different alternatives
for implement fast arithmetic architecture circuits that differ
from conventional ones. In particular, they allow to use more
homogeneous pipelines for realising addition, subtraction and
multiplication than current superscalar pipelines, which use for
different operations also different pipeline paths. However, for
the realisation of a homogeneous pipeline using memristors there
are different possibilities. Those were evaluated in this paper
concerning latency and hardware effort measured in number of
required logic elements for computing and memristors for storing.
Keywords–Memristive computing; Ternary logic, Signed-digit
arithmetic.
I.
INTRODUCTION
Since the invention of a nano-device in the HP labs in
2008 by a team around Williams [1] that shows the speciﬁc
behaviour prognosticated by Leon Chua in a paper of 1971
[2], and which was called by Leon Chua memristor, a lot of
research launched in the community to use such new devices
for digital and analogue logic operations. A memristor is
an electronic device that can sustainably change its internal
electrical resistance due to a change of an applied magnetic
ﬂux generated by electronic charge. Normally, this change
of the magnetic ﬂux and charge is generated indirectly by
applying a voltage at the poles of a two-terminal memristor
device to produce a current ﬂow through it, if the memristor
is connected to a circuit. Chua claimed, that if the current-
voltage curve of such a device shows hysteresis behaviour and
runs through the origin (see Figure 4), then it is a memristor
(”if it’s pinched, then it’s a memristor”). Depending on the
direction of the current the changing of the device’s resistance
can be made reversible. For example, it is possible to mimic
the strength of a synaptic interconnect that is controlled by
the time difference of two currents arriving at the two poles
of the device to realise analogue neuromorphic processing
based on the spike time dependent plasticity (STDP) model
[3]. Furthermore, complete memristor networks were proposed
for digital processing. In such networks targeted changing of
the memristors’ resistance, called memristance, was induced
in speciﬁc memristors to realise fundamental digital Boolean
logic elements [4][5][6].
In some works, the research was also focused on the
multi-bit storing feature of a memristor, i.e., the capability to
store different resistance levels produced by periodic voltage
excitations at the memristor poles. That multi-bit feature is
also the topic in this paper. The idea, that was ﬁrst published
in [8], is to use memristors as elementary ternary storing cells
for registers in a ternary arithmetic unit. This unit is based
on a number system, in which the addition is accelerated by
using a balanced ternary representation, i.e., each digit can be
assigned to 1, 0, and −1 (in the following denoted as ¯1).
Based on that addition, further arithmetic circuits like a
multiplication can be built up in a pipeline structure. Mem-
ristors are to use as multi-bit pipeline registers to store the
ternary digits, called trits. There are different possibilities for
the exact structure of such a pipeline, e.g., to process directly
two numbers in signed-digit (SD) representation or a hybrid
arithmetic structures operating an SD number and a binary
number. All theses alternatives cause different realisation ef-
forts on the logic side, i.e., the number of used gates, and on
the storage side, i.e., the number of necessary memristors and
transistors for the interface circuitry to convert trits, stored in
a single memristor cell, to bits and vice versa. In this paper,
some of the different alternatives are shown and are evaluated
among each other to select the best for a future memristor-
based ternary computer.
The rest of the paper is structured as follows. In Section
II, the fundamentals of a memristor and the possibility to
store multi-bits in such a single physical storage cell are
explained. In Section III, the principal Boolean equations and
beneﬁts of SD arithmetic are illustrated. In particular, it is
shown why a ternary arithmetic unit is to favour. Afterwards
in Section IV, computer arithmetic and memristor technology
are brought together by presenting different solutions for
arithmetic pipelines using memristor-based registers. These
different proposals are evaluated in Section V, in terms of
latency, bandwidth and hardware effort. Finally, Section VI
summarizes the most important statements of the paper.
II.
MEMRISTOR
The core of a memristor is a so-called transfer oxidation
metal, like e.g., TiO2. This metal oxide layer is sandwiched
with a ionized layer of the metal oxide, TiO2−x, between
two metal plates (see Figure 1). Inside this two-terminal

FUTURE COMPUTING 2015 : The Seventh International Conference on Future Computational Technologies and Applications
Copyright (c) IARIA, 2015. ISBN: 978-1-61208-389-6
2
Figure 1. Structure of a two-terminal memristor cell
device electro-chemical processes of oxidation and reduction
are taking place to move ions along the interface of the metal
oxide and the ionized layer. This moving can be caused by
an electrical ﬁeld applied at the two metal poles. The change
of voltage, V (t), and current, I(t), over time generates a
magnetic ﬂux, ϕ, and a charge, q, which both determine
the memristance M of the device according to Leon Chua’s
assumption, expressed in (1) and (2).
dϕ = Mdq
(1)
M(q(t)) = dϕ/dt
dq/dt = V (t)
I(t)
(2)
This ion transfer is responsible for the sustainable changing
of the resistive features of such an element. The electron
depleted ionized layer (TiO2−x) has a much lower resistance
than the metal oxide layer. Both layers determine with different
weights according to their lengths the resistance of the whole
device (3). ROF F is the resistance if the device is switched off,
i.e., no ionized layer is available. RON holds for the contrast,
i.e., the device contains of a complete ionized layer. Since
the depletion zone can be shifted in both directions according
to the direction, where the voltage is applied, the changing of
the resistance is reversible. Therefore it can be memorized and
this kind of reversible resistance with memory effect is called
memristance.
RMEM(x) = RON · x + ROF F · (1 − x),
(3)
where x = w
D ϵ (0, 1)
The ratio of the length of ionized layer, w, to the total
length of the two layers, D, is called the state variable x. The
changing of this state variable in dependence on the time is
expressed in (4),
dx
dt = η · µD · RON
D2
I(t),
(4)
where µD corresponds to the drift mobility of the ions, η
is equal to 1 or −1, resp. The last parameter expresses the
direction of the applied voltage causing either an expanding
or a shrinking of the depletion zone.
The most elaborate presentation of the mathematical
derivation of the behaviour of memristors based on ion transfer
can be found in [11]. The paper derives a discretization of
the differential equation (4), which is shown here by (5) to
(8). These equations allow to calculate the changing of the
parameters between two discrete time steps ti and ti+1.
Figure 2. Modelling non-linearity with Biolek’s window function for
different parameters p = 1, 5, and 7. Considered is also I(t) < 0, the curve
starting at Fp(0) = 1.
M(x(ti)) = RON · (x(ti)) + ROF F · (1 − x(ti)) ,
(5)
I(ti+1) =
V (ti+1)
M(x(ti+1)),
(6)
x(ti+1)/dt = η · µD · RON
D2
I(ti) · Fp(x(ti)),
(7)
x(ti+1) = x(ti+1)/dt · [ti+1 − ti] + x(ti)
(8)
The comparatively simple mathematical modelling assumes
a linear drifting of the ions according to (4). However, real
memristors show a different drift behaviour the nearer the
ions are located at the boundaries of the device, where the
drifting is slower. This non-linearity is modelled by a so-
called window function Fp in (7). Different window functions
are proposed in literature [9][10]. In this paper, the window
function from Biolek [10], see (9), was selected since it simpli-
ﬁes convergence issues at the device boundaries compared to
other window functions. Figure 2 shows the graph for Biolek’s
window function.
Fp(x) = 1 − [x − u(−I)]2p ,
(9)
where u(I) =
1, ifI ≥ 0
0, ifI < 0
To investigate the memristor’s behaviour more detailed in
this paper a numerical simulation program was written in C to
implement (5) to (9). The outputs of the simulation program
are shown in the following ﬁgures. Figure 3 shows the applied
input voltage over time. First two positive voltage oscillations
are applied at the two terminals of the memristor device. Then,
this process is reversed by changing the polarization. Figure
4 shows the I-U behaviour. The typical hysteresis loops for
memristors are arising. After each voltage oscillation the level
of memristance is changed and another hysteresis loop is valid.
Figure 5 displays the value of the state variable x. The
multi-state or multi-bit feature of a memristor can be clearly
detected. With each excited voltage oscillation the state vari-
able x was shifted to another level. Even if the values are not
completely constant and the transition between the levels is
smooth each level corresponds to some amount to a discrete
memristance level. The level starts not at zero, the initial value

FUTURE COMPUTING 2015 : The Seventh International Conference on Future Computational Technologies and Applications
Copyright (c) IARIA, 2015. ISBN: 978-1-61208-389-6
3
Figure 3. Input excitation with two voltage oscillations
Figure 4. The memristor hysteresis loop, generated for D = 41nm,
x(0) = 0.11, and p = 7. For each excited voltage oscillation another
hysteresis behaviour is generated
for x was assumed as 0.11. It expresses an arbitrary assumed
ratio between doped and undoped zone at the beginning
determined by the memristor’s manufacturing process. Further,
two levels were injected and then this process was withdrawn
by the applied inverted voltage levels. Each of these three
levels corresponds to one of the three signed digits, 1, 0, and
¯1, which are stored in one nano-sized physical cell. Such a
cell is the base for pipeline registers used in the proposed SD
arithmetic circuits proposed in the next section.
III.
SD-ARITHMETIC
As already mentioned in the introduction the great ad-
vantage of arithmetic circuits using SD numbers is that the
execution time of an addition has a complexity of O(1),
i.e., it is independent of the operands’ word length N [12].
Conventional adders which are executing binary operands like
a carry-look-ahead adder or a conditional-sum adder show a
run time complexity in O(logN), or in O(N) like a ripple-
carry adder. In order to avoid the generation of carry chains
in an addition, a balanced number representation is used in
an SD adder. That means that the number of negative digits
is the same as the number of positive digits. Since in this
Figure 5. The course of the state variable x of a memristor cell
paper the focus is not on the computer arithmetic side, the
functionality of an SD addition is explained by words, by
presenting the basic formulae to execute a carry-free addition,
and by examples to demonstrate the principle.
First, we investigate roughly the cost of an addition of two
SD numbers. The addition is carried out in two steps. In the
ﬁrst step an intermediate sum vector, z, and a carry vector, c,
is calculated. In the second step the two vectors, z and c, are
post-processed to determine the ﬁnal sum vector, s, which is
also given in an SD number representation.
Adding two SD numbers requires a base r ≥ 3. For the
digits, sdi, 0 ≤ i < N, of a N digit long SD number holds
sdi ϵ {−(r − 1) , −(r − 2), ..., 0, ..., r − 2, r − 1}. Equation
(10) shows the calculations that have to be performed in each
digit position i to determine the vectors z and s for two SD
input operands x and y. The term ci · ri in (10) is a so-called
correction term. That correction term secures that zi ≤ |r−2|.
This prevents that the possible addition of a carry bit will
cause an additional carry to the left neighboured position. To
compensate the addition/subtraction with ci · ri it is necessary
that a carry bit, either +1 or -1, has to be added in the next
left neighboured digit position i + 1.
zi = xi + yi − ci · r
ci =



+1,
if (xi + yi) > r − 2
−1,
if (xi + yi) < −(r − 2)
0,
if − (r − 2) ≤ (xi + yi) ≤ r − 2
(10)
si = zi + ci−1
Table I shows an example calculation to a base r = 3
with a word length N = 4. The two SD numbers to add
are 1 · 33 + (−2) · 32 + 1 · 31 + 0 · 30 = 12 and 0 · 33 +
(−1) · 32 + 1 · 31 + 1 · 30 = −5. The correction term for the
second and the ﬁrst digit positions are +3 and −3, resp., since
x2+y2 = −3 < −(r−2) = −1 and x1+y1 = 2 > (r−2) = 1.
In Table I the carry vector, ci−1, is already shifted to left for
a better illustration of the ﬁnal addition in (10). As expected
the sum is s = 0 · 33 + 1 · 32 + (−1) · 31 + 0 · 30 = 7.
An evaluation of this addition scheme to a base r = 3 and
a realisation with memristors yields the following statements.

FUTURE COMPUTING 2015 : The Seventh International Conference on Future Computational Technologies and Applications
Copyright (c) IARIA, 2015. ISBN: 978-1-61208-389-6
4
TABLE I. ADDING TWO SD NUMBERS x AND y IN TWO STEPS.
1
-2
1
0
= 12
x
0
-1
1
1
= −5
y
step1
1
0
-1
1
z
-1
+1
0
.
ci−1 shifted to left
step 2
0
+1
-1
1
= 7
s
For the required signed digits, sdi, holds sdi ϵ [−2, 2] That
means ﬁve levels are to store in a single physical memristor
cell. That is not impossible in principle but there are two
more states to realise than in a ternary computer making
the interface circuitry to the memristor cells more difﬁcult to
realise. Furthermore a larger effort for the coding is necessary.
Three bits are required to code the ﬁve possible values,
yielding

FUTURE COMPUTING 2015 : The Seventh International Conference on Future Computational Technologies and Applications
Copyright (c) IARIA, 2015. ISBN: 978-1-61208-389-6
5
Figure 7. Schematic for adding/subtracting two SD numbers using
memristors as pipeline register
IV.
MEMRISTOR BASED PIPELINE STRUCTURES
An addition between two SD numbers, SD1 and SD2, can
be decomposed in two steps, in which in the ﬁrst step SD1
is processed with the positive channel of SD+
2 and in the
second step the negative channel is subtracted from the result
of the addition (13). In the case of a subtraction the signs of
the operators signs have to be inverted (+ becomes - and vice
versa).
SD1 ± SD2 = ((SD1 ± SD+
2 ) ∓ SD−
2 )
(13)
Figure 7 shows the schematic for a corresponding arith-
metic circuit. Two of the addsub modules shown in Figure 6
are necessary with an appropriate interface circuitry, not shown
in Figure 7, to store the ﬁrst result in a memristor register. This
allows to pipeline the calculation before the second addsub
module comes to execution.
Figure 8 shows a scheme for a multiplication of a SD
number a with a binary number B. A multiplication of
operands with N digits is reduced back to N subsequent
additions/subtractions. Each addsub module forms a pipeline
with memristors to store the partial product digits. In the ﬁrst
three steps the product digits, P[0] to P[3], are produced before
in the last pipeline step the ﬁnal product digits P[4] to P[7]
appear at the output of the last addsub module and all digits
can be stored in a memristor register ﬁle. The digits of the SD
operand a[i] determine in each pipeline stage, i, if either an
addition (a[i]− = 0) or a subtraction (a[i]− = 1) has to be
carried out with the partial product and the binary number B,
or if in case a[i] = 0 no addition takes place.
Multiplication of two SD numbers, SD1 · SD2 can be
traced back to a hybrid operation scheme that executes a
SD number and a binary number (14) as it was done for
the addition/subtraction, see Figure 9. First, two intermediate
products, Prod1 and Prod2, are generated with two concur-
rently operating circuits from Figure 8. Afterwards these two
products, given in SD number representation, are subtracted
with a two step circuit analogue to the addition/subtraction
shown in Figure 7. If no multiplication has to be carried out
Figure 8. Memristor-based pipelining for the multiplication of a SD number,
a, and a binary number B
the two multiplier pipelines can be used for two concurrent
additions/subtractions. Therefore, Figure 9 represents the core
of a future memristor multi-threading architecture, which the
author intends to realise with largely homogeneous pipeline
structures.
SD1 · SD2 = (SD1 · SD+
2 ) − (SD1 · SD−
2 )
(14)
= Prod1 − Prod2
V.
EVALUATION OF MEMRISTOR-BASED PIPELINE
STRUCTURES
The functionality of all proposed pipeline architectures was
veriﬁed by simulations in SystemC. In this section the pipeline
architectures are compared with regard to latency, expressed
in gate delays, achievable throughput, and necessary hardware
effort, which is measured in numbers of necessary transistors
and memristors (Table V).
First, the add/sub pipeline from Figure 7 is analysed. If
∆ corresponds to one gate delay, according to (11) an add-
sub module requires 4∆ plus the time, tconv, for converting
the digital signals by a number of voltage oscillations (see
Figs. 3 and 5) to store the SD adder outputs in multi-bit
memristor cells at the end of the ﬁrst pipeline stage. In [8],
N · 62 transistors were determined for the used SD adder,
shown in Figure 6. Additionally, the number of transistors
for the conversion, transconv, is to add for each of the N
memristors. An adder that adds directly two SD numbers using

FUTURE COMPUTING 2015 : The Seventh International Conference on Future Computational Technologies and Applications
Copyright (c) IARIA, 2015. ISBN: 978-1-61208-389-6
6
TABLE V. Evaluation of the memristor-based pipeline architectures. Time to write back to MEMRIST regﬁle is not considered
latency
# memristors
# transistors
Addition/Subtraction
4∆ + tconv
N
N · (124 + transconv)
SD-binary multiplier
N · (4∆ + tconv)
N 2
N 2 · (62 + transconv)
SD-SD multiplier
(N + 2) · (4∆ + tconv)
2N 2 + 4N
(2N 2 + 4N) · (62 + transconv)
Figure 9. Memristor-based pipelining for the multiplication of two SD
numbers with a digit length of four.
a base r = 3 would show a latency of only 2∆. However, it is
to expect that this requires much more transistors for logic and
conversion, since ﬁve and not three multiple memristor states
have to be stored. Therefore, the conclusion is drawn that the
double latency time of a SD-binary adder is acceptable.
Counting the number of memristors and addsub modules
of the SD-binary multiplier in Figure 8 for the case N = 4 and
deducing from that the generic case yields the numbers shown
in Table V for latency and hardware effort. The SD-SD multi-
plier consists of two multipliers and two further SD adders with
2N digit length leading to the values entered in the last row
of Table V. The throughput for all architectures is equal to the
reciprocal of the latency in one stage, 1/(4∆ + tconv). Access
times for memristors in the range of 0.3 ns make realistic to
achieve a clock frequency of more than 1 GHz.
VI.
CONCLUSION
Memristors and their capabilities to store multi-bits in a
single cell allow the set-up of fast CMOS compatible carry-
free arithmetic circuits. The presented analysis shows that the
effort for the realisation of ALUs with the proposed hybrid SD-
binary multiplier pipeline approach and pipeline memristors
is quite moderate and to prefer versus a pure SD-SD adder
arithmetic. The half latency time of the hybrid solution is
offset against the pure SD approach that would cost much more
hardware. Future work requires the design of a corresponding
control unit to feed the pipeline with a stream of instructions
and a detailed analysis how to realise efﬁciently an interface
circuit to the memristors.
ACKNOWLEDGMENT
The author thanks Jonathan Martschinke who wrote the
numerical simulation program of memristor’s behaviour that
was used to generate Figs. 3 to 5.
REFERENCES
[1]
D. B. Strukov, G. S. Snider, D. R. Stewart, and R. Stanley Williams,
The missing memristor found. Nature, vol. 453, 2008, pp. 80–83.
[2]
L. Chua, Memristor-the missing circuit element. Circuit Theory, IEEE
Transactions on, vol. 18, no. 5, September, 1971, pp. 507–519.
[3]
B. Linares-Barranco and T. Serrano-Gotarredona,
Memristance can
explain spike-time-dependent plasticity in neural synapses.
Nature
Precedings, March, 2009, hdl:10101/npre.2009.3010.1.
[4]
S. Kvatinsky, A. Kolodny, U. C. Weiser, and E. G. Friedman,
Memristor-based IMPLY logic design procedure.
Proc. 29th IEEE
International Conference on Computer Design (ICCD), October, 2011,
pp.142-147.
[5]
S. Kvatinsky, N. Wald, G. Satat, A. Kolodny, U. C. Weiser, and E. G.
Friedman,
Memristor-based MRL
Memristor ratioed logic.
Proc.
13th International Workshop on Cellular Nanoscale Networks and Their
Applications (CNNA), August, 2012, pp. 1-6.
[6]
I. Vourkas and G. Ch. Sirakoulis,
Memristor-based combinational
circuits: A design methodology for encoders/decoders. Microelectronics
Journal , vol. 45, no. 1, January, 2014, pp. 59–70.
[7]
L. Zheng, S. Shin, and S.-M. S. Kang,
Memristor-based ternary
content addressable memory (mTCAM) for data-intensive computing.
Semiconductor Science and Technology, vol. 29, no. 10, 2014, 104010
(10pp).
[8]
D. Fey, Using the multi-bit feature of memristors for register ﬁles in
signed-digit arithmetic units. Semiconductor Science and Technology,
vol. 29, no. 10, 2014, 104008 (13pp).
[9]
Y. N. Joglekar and S. J. Wolf, The elusive memristor: properties of
basic electrical circuits. Eur. J. Phys., vol.30, no. 661, January, 2009,
pp. 1-24, arXiv:0807.3994 v2 [cond-mat.meshall].
[10]
Z. Biolek, D. Biolek, and V. Biolkov, SPICE model of memristor with
nonlinear dopant drift. Radioengineering, vol. 18,no. 2, June, 2009, pp.
210-214.
[11]
N. R. McDonald, R. E. Pino, P. J. Rozwood, and B. T. Wysocki,
Analysis of dynamic linear and non-linear memristor device models
for emerging neuromorphic computing hardware design. IEEE IJCNN,
2010, pp. 1-5.
[12]
A. F. Gonz´alez and P. Mazumder, Redundant arithmetic, algorithms
and implementations. INTEGRATION, the VLSI journal, vol. 30, no.
1, 2000, pp. 13-53.
[13]
J. Duprat and J.-M. Muller. Fast VLSI implementation of CORDIC
using redundancy. in E.F. Depreterre, and A.-J. van der Veen (eds.):
Algorithms and Parallel VLSI architectures, Elsevier, vol. B, June, 1991,
pp. 155-164.

