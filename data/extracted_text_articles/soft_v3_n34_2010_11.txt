Privacy by Flexible Parameterization with Erlang Active Objects
Andreas Fleck
Software Engineering Group
Technische Universit¨at Berlin, Germany
Email: andreasﬂeck@web.de
Florian Kamm¨uller
Middlesex University, London UK and
Technische Universit¨at Berlin, Germany
Email: f.kammueller@mdx.ac.uk
Abstract—Functional active objects are a new paradigm for
the implementation of services. They offer safe distributed
evaluation with futures and immutable objects guaranteeing
efﬁcient implementation of privacy while offering veriﬁed
quality assurance based on the functional paradigm and a
development in an interactive theorem prover. In this paper,
we present a novel and highly performant implementation of
functional active objects in Erlang. Besides outlining the guid-
ing principles of the interpreter, we show how secure services
can be realized based on the classical service triangle and prove
its security based on a formal deﬁnition of information ﬂow
security for functional active objects.
Keywords-Active object, future, Erlang, privacy, service com-
puting
I. INTRODUCTION
The free lunch is over – as Sutter describes so vividly in
his famous paper [24]. In all realms of modern computing,
we need to distribute to keep up performance. Active objects
combine the successful concept of object-orientation with
the necessary concepts of concurrent processes to make them
ﬁt for this distributed world.
We present an implementation of the novel language
ASPfun for functional active objects in the programming
language Erlang. ASPfun is an computation model that can
be seen as a descendant of the actor model, or more precisely
active objects. Its main specialty is the use of futures to avoid
blocking states while invoking asynchronous methods. Since
no data is shared between active objects, concurrent method
invocation can be simply used without fear of racing. These
features are very similar to the features of services. Hence,
it is possible to formalize complex services in ASPfun and
this fact allows us to transfer ASPfun properties to services.
The Erlang implementation of ASPfun enables a prompt
transfer from an ASPfun conﬁguration to executable code
and so the ”real behavior” can be tested. Besides the highly
performant parallelization of Erlang, this approach supports
privacy enhancing implementations for services. The main
contributions presented in this paper are as follows.
• Functional active objects enable a deadlock free evalu-
ation that implies service invocation in a higher order
fashion. That is, a customer can invoke a service
without needing to provide his private data.
• The use of futures as the machinery behind method
invocation enables a ﬂexible reply to method requests.
In particular, this reply mechanism supports the privacy
enhancing result acquisition described in the previous
point.
• Using Erlang as implementation language we present
a novel future implementation concept where each
future is represented as a process. Thereby, we can
abstract from different future update strategies; the
Erlang ASPfun interpreter stays close to the original
semantics (see Section II-A): since it is functional it
is not forced to sacriﬁce generality for the sake of
operationality.
• We offer a formal deﬁnition of information ﬂow secu-
rity and illustrate its use for the proof of security on
the service triangle – our running example.
In this paper we ﬁrst provide the prerequisites of this
project: brief introductions to the language ASPfun, currying
in ASPfun, and Erlang (Section II). From there, we develop
the concepts of our implementation of active objects in
Erlang (Section III). We then illustrate how the language
can be efﬁciently used to implement secure services on
three examples from privacy reﬂecting our contribution
(Section IV). A formal security deﬁnition enables the proof
of privacy for ﬂexible parameterization (Section V). We
ﬁnally offer conclusions, position our work, and give an
outlook on further plans (Section VI). This paper extends
the original conference contribution [13] by further details
on the implementation concepts and a formal deﬁnition of
security and proof of privacy for the service triangle using
ﬂexible parameterization.
II. PREREQUISITES
In this section, we present the formal deﬁnitions of the
language ASPfun and a brief introduction in the concepts
behind Erlang.
A. Functional Active Objects
The language ASPfun [12] is a computation model for
functional active objects. Its local object language is a simple
ς-calculus [1] featuring method call t.l(s), and method
update t.l := ς(x, y)b on objects (ς is a binder for the
self x and method parameter y). Objects consist of a set
461
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

conﬁguration
request queue
t
activity
active object
α
...
...
...
E [fk]
request queue
t'
β
...
...
...
t'.l(s)
Figure 1.
ASPfun: a conﬁguration
of labeled methods [li
= ς(x, y)b]i∈1..n (attributes are
considered as methods with no parameters). ASPfun now
simply extends this basic object language by a command
Active(t) for creating an activity for an object t. A simple
conﬁguration containing just activities α and β within which
are so-called active objects t and t′ is depicted in Figure
1. This ﬁgure also illustrates futures, a concept enabling
asynchronous communication. Futures are promises for the
results of remote method calls, for example in Figure 1,
fk points to the location in activity β where at some point
the result of the method evaluation t′.l(s) can be retrieved
from. Futures are ﬁrst class citizen but they are not part
of the static syntax of ASPfun, that is, they cannot be
used by a programmer. Similarly, activity references, e.g.
α, β, in Figure 1, are references and not part of the static
syntax. Instead, futures and activity references constitute
the machinery for the computation of conﬁgurations of
active objects. Syntactically, we write conﬁgurations as
α[Rα, tα] ∥ β[Rβ, tβ] ∥ . . . . For example, the conﬁguration
of Figure 1 would be syntactically expressed as α[f0 7→
E[fk] :: Rα, t] ∥ β[fk 7→ t′.l(s) :: Rβ, t′].
B. Informal Semantics of ASPfun
Local (ς-calculus) and parallel (conﬁguration) semantics
are given by a set of reduction rules informally described as
follows.
• LOCAL: the local reduction relation →ς is based on the
ς-calculus.
• ACTIVE: Active(t) creates a new activity α[∅, t] for
new name α, empty request queue, and with t as active
object.
• REQUEST: method call β.l creates new future fk in
future-list of activity β (see Figure 1).
• REPLY: returns result, i.e. replaces future fk by the
referenced result term s (possibly not fully evaluated).
• UPNAME-AO: activity upname creates a copy of the
activity and upnames the active object of the copy –
the original remains the same (functional active objects
are immutable).
C. Formal ASPfun semantics
We use a concise contextual description with contexts E
deﬁned as usual. Classically we deﬁne contexts as expres-
sions with a single hole (•).
E ::= • | [li = ς(x, y)E, lj = ς(xj, yj)tj∈(1..n)−{i}
j
] | E.li(t) |
s.li(E) | E.li := ς(x, y)s | s.li := ς(x, y)E| Active(E)
E[s] denotes the term obtained by replacing the single hole
by s. The semantics of the ς-calculus for (local) objects is
simply given by the following two reduction rules for calling
and updating a method (or ﬁeld) of an object.
CALL
li ∈ {lj}j∈1..n
E

[lj = ς(xj, yj)bj]j∈1..n.li(b)

→ς
E

bi{xi ← [lj = ς(xj, yj)bj]j∈1..n, yj ← b}

(1)
UPDATE
li ∈ {lj}j∈1..n
E

[lj = ς(xj, yj)bj]j∈1..n.li := ς(x, y)b

→ς
E
h
[li = ς(x, y)b, lj = ς(xj, yj)bj∈(1..n)−{i}
j
]
i
(2)
The semantics of ASPfun is built over the local semantics
of the ς-calculus as a reduction relation →∥ that we call the
parallel semantics (see Table I).
D. A Running Example from Service Computing
In the following example (an extension of the motivating
example of [11]), a customer uses a hotel reservation service
provided by a broker. This simple example is representative
for service oriented architectures; we refer to it also as
the service triangle. In this triangle, the three activities
hotel, broker, and customer are composed by ∥ into a
conﬁguration. To simplify this example the broker’s search
for a hotel is omitted and we always consider the same hotel
and in addition we abstract from the computation in hotel
that produces the booking reference for the customer. We
concentrate on the message passing implemented in futures
to highlight the actual ﬂows of information in the following
evaluation sequence.
customer[f0 7→ broker.book(date), t]
∥ broker[∅, [book = ς(x, (date))hotel.room(date), . . .]]
∥ hotel[∅, [room = ς(x,date)bookingref, . . .]]
The following step of the semantic reduction relation →∗
∥
creates the new future f1 in broker following rule REQUEST.
According to LOCAL, this call is reduced and the original
call in the customer becomes f1.
customer[f0 7→ f1, t]
∥ broker[f1 7→ hotel.room(date), . . .]
∥ hotel[∅, [room = ς(x,date)bookingref, . . .]]
The parameter x representing the self is not used but the call
to hotel’s method room with parameter date creates again
by rule REQUEST a new future in the request queue of the
462
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

LOCAL
s →ς s′
α[fi 7→ s::Q, t] :: C →∥ α[fi 7→ s′ ::Q, t] :: C
(3)
ACTIVE
γ /∈ (dom(C) ∪ {α})
noFV(s)
α[fi 7→ E[Active(s)]::Q, t] :: C →∥ α[fi 7→ E[γ]::Q, t] :: γ[∅, s] :: C
(4)
REQUEST
fk fresh
noFV(s)
α [fi 7→ E[β.l(s)]::Q, t] :: β[R, t′] :: C →∥ α [fi 7→ E[fk]::Q, t] :: β

fk 7→ t′.l(s)::R, t′
:: C
(5)
SELF-REQUEST
fk fresh
noFV(s)
α [fi 7→ E[α.l(s)]::Q, t] :: C →∥ α [fk 7→ t.l(s) :: fi 7→ E[fk]::Q, t] :: C
(6)
REPLY
β[fk 7→ s::R, t′] ∈ α[fi 7→ E[fk]::Q, t] :: C
α[fi 7→ E[fk]::Q, t] :: C →∥ α[fi 7→ E[s]::Q, t] :: C
(7)
UPDATE-AO
γ /∈ (dom(C) ∪ {α})
noFV(ς(x, y)s)
β[Q, t′] ∈ (α[fi 7→ E[β.l := ς(x, y)s] :: Q, t] :: C)
α[fi 7→ E[β.l := ς(x, y)s] :: Q, t] :: C →∥ α[fi 7→ E[γ] :: Q, t] :: γ[∅, t′.l := ς(x, y)s] :: C
(8)
Table I
ASPFUN SEMANTICS
hotel activity that is immediately reduced due to LOCAL to
bookingreference where the index indicates that date has
been used.
customer[f0 7→ f1, t]]
∥ broker[f1 7→ f2, . . .]
∥ hotel[f2 7→ bookingref⟨date⟩, . . .]
Finally, the result bookingreference is returned to the client
by two REPLY-steps: ﬁrst the future f2 is returned from
the broker to the customer and then this client receives the
bookingreference via f2 directly from the hotel.
customer[f0 7→ bookingref⟨date⟩, t]
∥ broker[f1 7→ f2, . . . ]
∥ hotel[f2 7→ bookingref⟨date⟩, . . .]
This conﬁguration can be considered as the ﬁnal one; at
least the service has been ﬁnished. From the perspective of
privacy, it is actually here that we would like to end the
evaluation. Unfortunately, the future f2 is also available to
the broker. So, in an ﬁnal step the broker can serve himself
the bookingreference as well.
customer[f0 7→ bookingref⟨date⟩, t]
∥ broker[f1 7→ bookingref⟨date⟩, . . . ]
∥ hotel[f2 7→ bookingref⟨date⟩, . . .]
The abstract general semantics of ASPfun allows this privacy
breach.
We introduce now a general way of enforcing privacy
by not disclosing private data in the ﬁrst place. We show
that relying on the ASPfun paradigm guarantees that ﬂexible
parameterization can be used to use services in a private
manner.
E. Currying for ASPfun
The contribution of this paper is a concept more generally
useful for privacy: ﬂexible parameterization – enabling the
use of service functions while not supplying all parame-
ters. For example, in the European project SENSORIA the
COWS calculus has been designed as an extension to the Pi-
calculus to realize correlation, a similarly dynamic service
concept [4].
We have implemented this technique in our Erlang pro-
totype for ASPfun (see Section III) as a pragmatic extension
of the base language. However, as we will show now,
this feature on ﬂexible parameterization can be constructed
conservatively in ASPfun using currying.
Currying is a well known technique in functional pro-
gramming to render functions with several parameters par-
tially applicable. That is, the parameters of a curried function
may be supplied one after the other, in each step returning
a new function.
Recall the deﬁnition of curry and its inverse uncurry in
the λ-calculus.
curry
≡
λ f p. f(fst p)(snd p)
uncurry
≡
λ f a b. f(a, b)
Here, (a, b) denotes the product and fst and snd the corre-
sponding projections on a and b respectively. This datatype
is itself deﬁnable in terms of simpler λ-terms as follows.
(a, b)
≡
λ f. f a b
fst p
≡
(λ x y. x)
snd p
≡
(λ x y. y)
463
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

We recall these classic deﬁnitions in order to prepare the
less intuitive deﬁnition of currying for the ς-calculus and
hence for ASPfun. In comparison to the ς-calculus, the base
objects of ASPfun differ in that we explicitly introduce a
second parameter to each method in addition to the self-
parameter x. Therefore, when we emulate functions in our
version of the ς-calculus we proﬁt from this parameter
and avoid roundabout ways of encoding parameters.1 As a
prerequisite for having several parameters, we need products.
Compared to the above presented encoding of pairs in the λ-
calculus, pairs in the ς-calculus can make use of the natural
record structure of objects thus rendering a more intuitive
notion of product as follows.
(a, b)
≡
[ fst = ς(x, y)a, snd = ς(x, y)b ]
fst p
≡
p.fst
snd p
≡
p.snd
We simulate currying of a method f of an object o that
expects a pair p of type α × β as second parameter, i.e.
o = [ f = ς(x, p).t ]
by extending this object o with a second method fC as
follows.
curry o
≡
[ f = ς(x, p)o.f(p),
fC = ς(x, a)[f ′ = ς(y, b)x.f(a, b)] ]
F. Erlang
Erlang is a concurrent-oriented functional programming
platform for open distributed telecommunication (OTP) sys-
tems developed by Ericsson corporation. It implements the
actor paradigm by providing message passing as strategy
for communication between several actors implemented as
processes. Processes run fully parallel in Erlang. Each
process has a mailbox where arriving messages are stored.
The programmer can use pattern matching for message
selection. Hence, the behavior of an actor is controllable. If a
process needs an answer its process identiﬁer (PID) has to be
passed through the message. Since memory sharing does not
exist, neither locks nor mutexes are necessary. The code is
grouped in modules which are referred to by their name. So
modulname:functionname(args). starts a function from
a speciﬁc module.
A process is created by the spawn-command supplying it
with the process’ function and initial arguments. Erlang sup-
ports also named processes. Using register(Name,PID)
the PID is registered in a global process registry and the
process can be called by its name.
PID = spawn(Func,Args),
1In the ς-calculus the parameter has to be simulated by updating a
separate ﬁeld in an objects and that consequently needs to be attached
to each object.
PID!Message,
Func(Args)...
receive
Pattern1 [when Guard1] -> Expression1;
Pattern2 [when Guard2] -> Expression2;
...
end.
Above, we show the basics of distribution in Erlang. First,
we start a new process which runs the function Func. Then,
we send a Message to the new process which is identiﬁed
by PID. The function Func implements several patterns
for incoming messages. Now, the system tries to match
the arrived message against Pattern1 (and the guard if it
exists). In case of success, Expression1 is evaluated. If the
ﬁrst pattern fails, the second will be used and so on. Another
fundamental feature of Erlang is the single assignment, as
in algebra, meaning that Erlang variables are immutable.
The main data types are (untyped) lists and records,
called tuple, for example {green, apple} and atoms which
represent different non-numerical constant values. Any lower
case name is interpreted as an atom, any higher case name is
a variable. In addition, there are modules for interoperability
to other programming languages like C, Java or databases.
III. AN ASPFUN INTERPRETER IN ERLANG
Active objects bridge the gap between parallel processes
and object-orientation. Intuitively, we want an object to be
a process at the same time; unfortunately the two concepts
are not identical. Hence, activities are introduced as a new
notion of process containing an active object together with
its current method execution(s).
In this section we describe how the concepts of activities,
active objects and futures are realized on the infrastructure
of Erlang; each concept resides in a separate module.
A. Activity
The ﬁrst module describes the functionality of an activ-
ity. An activity encapsulates a functional active object to
prevent direct access to it and manage requests simultane-
ously. In a functional language there is no need to make
a sequential plan for execution in contrast to imperative
active objects [6]. All requests are executed in parallel and
run in individual processes. In our Erlang interpreter, the
activity is implemented as a separate process. Following
the ASPfun semantics, an activity contains a request-queue
and the functional active object which are dedicated to the
process. We use the Erlang built-in functionality for send and
receive. This comes in quite naturally to model asynchronous
communication of activities. In fact – as we will see when
implementing futures (see Section III-C) – message passing
is the correct foundation for asynchronous communication
with futures.
To keep the activity alive, the process is called again
after each receive. Any request has to be sent as a tuple
{Caller_PID,request,RequestFunction,Args} where
464
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Caller_PID is the PID or registered name of the calling
process (see Section III-C), the constant request which
is used as pattern in the receive evaluation, the name of
a requested function, and optionally the arguments as tuple
or nil. An activity is now started in Erlang by
ActiveObject_PID = activeObject:start(),
activity:start(Identifier,ActiveObject_PID).
where ActiveObject_PID is the process identiﬁer of the
functional active object to be introduced next.
B. Functional Active Object
The second module speciﬁes the functionality of func-
tional active objects. The active object stores the ς-calculus
methods in an list, where they can identify by a given name.
Deviating from the original notion of immutable objects of
ASPfun, our Erlang implementation is a dynamic ASPfun-
interpreter: ς-calculus methods can be added or deleted on
the ﬂy. Methods can also be declared at runtime or even
be speciﬁed in separate modules. In our implementation,
a functional active object is also a process which commu-
nicates with its activity by message passing. The activity
requests a function using its name and the functional active
object replies the function to the activity if it exists. This
fact allows additionally separate distribution of the activity
and the active object. To start an empty functional active
object in our Erlang active object interpreter, we just call
the following function.
ActiveObject_PID = activeObject:start().
To add functionality to this initial functional active object
one can deﬁne own functions or use existing Erlang modules.
Foo = fun(Self,{arg1,arg2,...})
-> some calculation, return value
end.
ActiveObject_PID!{add_func,functionname, Foo}.
where functionname is the name which one can use in
other activities. To enable functions as return values, it is
important to add a Self-Parameter. This parameter is set
automatically by our system when distributing functions.
C. Future
The last module represents the implementation of futures.
Futures act traditionally as placeholder for later results
calculated in parallel [6]. In the ASPfun computation model
there is no need to describe the fashion of updating a future
with the calculated value. Furthermore, the evaluation of a
future is possible at any time. This means, the result can be
an value or the current state of the function evaluation. These
facts have to be considered while implementing ASPfun. For
example, the ”on demand evaluation” can be implemented
in Erlang by a watching process for each calculation which
stores the current state. This is not very efﬁcient and in most
cases unnecessary. For the future updating process there exist
activity α
activity γ
request queue
activity β
request queue
future β
future γ
t'
t''
t
p: parallel process which calculates a 
speciﬁc function for a request and response
the result
request
response
scope of α
p
Figure 2.
ASPfun-Erlang: communication ﬂow
several approaches, such as message-based or forward-based
updates [16]. These strategies have in common that they
need to store the relations between activities and futures
[27]. We decided to expand the functionality by implement-
ing the future as a process which also stores the ﬁnal value.
This concept makes allows a complete separation from the
activity in a parallel manner and presents several advantages.
First, the future is more active and allows the use of message
passing and the distribution by its network identiﬁer. So a
future is unique in the entire conﬁguration and therefore,
there is no need to plan the update-process because other
activities can call the future directly by its network identiﬁer
to get the value. The second advantage is the location of
future creation. In our implementation, the future is created
by the enquiring activity and not by the requested activity.
This augments the privacy of activities by using the future
as a kind of “proxy for communication” between activities.
No activity has to announce itself to others when remote
calculation is needed. The future asks the remote activity
for the requested calculation and waits for the response: it
is a “proxy for communication”. In Figure 2, we illustrate
this communication ﬂow. In our opinion, this approach is the
consequent continuation of an asynchronous communication
concept (cf [5]). In some existing approaches [6], a future is
created and immediately returned by the called activity (in
pseudo-code).
Future localfuture = activity_anywhere_in_www.foo()
However, this call is not really asynchronous because the re-
mote activity might not respond immediately or the message
is lost. As a result, the local activity also blocks. A really
asynchronous solution must therefore use messages instead
of return-values [5]. Our approach works as follows.
Future localfuture = new Future,
localfuture.start(activity_anywhere_in_www.foo())
First, the future is created in the scope of a calling activity
and, then, the communication with the remote activity starts
through the future by messages in an asynchronous manner.
A new future-activity-request in Erlang may be started as
465
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

follows.
newfuture = future:start(activity,functionname,args)
This function call creates a new future, sends a request
message with the identiﬁer of the new future, the function’s
name and the arguments to activity (see Section III-D).
The ﬁnal value of this local function is the process identiﬁer
of the future. A next advantage is the enforcement of security
policies at the point of communication. The circumstance
that the future is created by the calling activity and stores
the ﬁnal value (see Section IV-D) allows to enforce security
policies of this activity for requests and responses at one
single point.
D. Function Execution and Evaluation
All functions which are invoked in activities are running
completely parallel in their own processes. By contrast,
imperative active object systems like ProActive or others [9]
use a sequentializing process and the execution runs in the
thread of the activity. A further beneﬁt is that activities do
not freeze in case a function execution blocks. If a function
blocks, only the future evaluation blocks. Therefore, we
have built a second argument into our evaluation function
representing the maximal evaluation time. After that time
span the evaluation returns nil. If and when the result is
ready, the requested activity, that is, the calculating process,
sends a message with the result to the calling future. The
future get the result, stores it and waits for the evaluation
by the activity which starts by
Result = future:evaluate(Future, 10).
Since the evaluation can occur at any time, we have imple-
mented two different cases:
• if the result is ﬁnished, it will be returned,
• and, if the result is not ready, the evaluation-process
blocks until the future is updated (wait-by-necessity and
ﬁnished after the update).
The result for self can be an ordinary value (tuple, atom,
variable, etc.), a function (higher-order), an activity (a PID
or name) or again a future. In the ﬁrst three cases, the result
is returned. If the result is itself a future, the evaluation
function evaluate this future and returns this result.
IV. SECURE SERVICES IN ASPFUN
In this section, we will now come back to the running
example of a hotel-broker-service and show that our Er-
lang active object interpreter can model different possible
scenarios. Note, that these scenarios are consistent with
the ASPfun semantics given in Section II. They deﬁne just
different strategies corresponding to various privacy goals.
We ﬁrst show the classical evaluation order where service
results ﬂow back via the invocation structure to the customer.
We then additionally sketch two reﬁnements, where ﬁrst
the actual service is passed to the customer so he can
communicate directly with the hotel without passing private
data through the broker. Next, we show that our Erlang active
object interpreter makes full use of the functional support:
a customer can use a service by only providing partial
information. Thereby, he can guard private information and
still get some (information about the) service.
Thus, our Erlang active object interpreter2 represents an
implementation of ASPfun in its broadest sense. Various
different more “operational” semantics corresponding to
different security policies can be easily implemented in our
Erlang active object framework. For professional use, the
basic machinery presented in this paper needs to be equipped
with a mechanism for a simpliﬁed control over the different
strategies.
A. Classic Service Evaluation
First, we show how the ASPfun example from Section II
looks in “standard” form. Therefore, we deﬁne a function
Room where we use the ordinary Erlang syntax including the
named speciﬁcations.
Room=fun(Self,{Date})->
BookingRef= database:any_database_call(Date),
BookingRef
end.
This function calls a function at a local database module.
This can take some time. Next, we create a new active object,
add the created function, and instantiate an activity named
hotel which encapsulates the active object.
AO_Hotel = activeObject:start(),
AO_Hotel!{add_func,room,Room},
activity:start(ActHotel,AOHotel),
Thereafter, we deﬁne the broker in the same manner, with
the exception that the book function uses the Room function
of hotel and returns a future.
Book = fun(Self,{Date})->
... ﬁnd a hotel by Date -> return an activity hotel
FutBookingRef=future:start(hotel,room,{Date}),
FutBookingRef
end,
The newly created future sends a message to hotel and
waits for an answer with result. Finally, we deﬁne the
customer’s wish.
FutBookHotelRoom =
future:start(broker,book,{Mydate}),
BookingRef = future:evaluate(FutBookHotelRoom)
The arguments is the date on which he wants to book a
room. The created future FutBookHotelRoom sends a mes-
sage to the activity broker which runs the function book.
The function book also creates a future FutBookingRef
to communicate with hotel and returns this to the fu-
ture of customer – similar to the ﬁrst application of
the rule REPLY in the ASPfun example. After the Room
function has ﬁnished, the future FutBookingRef is up-
dated. The evaluation of FutBookHotelRoom additionally
2For the sources http://www.users.cs.tu-berlin.de/~flokam
466
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

calls an evaluate at FutBookingRef which returns the
BookingRef. These two steps represent the second appli-
cation of the rule REPLY in the ASPfun example. In the
case that FutBookingRef is not updated yet, a wait-by-
necessity occurs until FutBookingRef is ready. As in the
original ASPfun example, the broker can evaluate the future
FutBookingRef too because it is in the same scope. This
means that the result is not passed directly to the broker but
there is a potential risk that he can retrieve it.
B. Private Customer Negotiation
In the ﬁrst extension, the customer has an additional
parameter Name, which should not be shared with the
broker. So in the relation between this special customer
and the untrusted broker our goal is to prevent the untrusted
broker to read the private data. For another customer, the
same broker could be a trusted partner. This behavior can
be deﬁned in individual security policies. To make these
scenarios possible we change the book function and add a
case analysis.
Book = fun(Self,{Date,Name})->
case (Name == nil) of
true ->
whereis(hotel);
false ->
...ﬁnd a hotel by Date -> return an activity hotel
FutBookingRef=future:start(hotel,room,{Date,Name}),
FutBookingRef
end
end,
So, if the argument Name is missing, the function returns
the network identiﬁcation of the activity hotel. Now, the
customer can communicate directly with the services of the
hotel.
FutBookHotelRoom =
future:start(broker,book,{mydate,nil}),
ActHotel =future:evaluate(FutBookHotelRoom),
FutBookingRef =
future:start(ActHotel,room,{mydate,myname}),
BookingRef = future:evaluate(FutBookingRef),
The evaluation of the future FutBookHotelRoom returns
now an activity. The customer uses this activity to call
the function Room directly with his private data. In this
example, the broker cannot read the private argument of
the customer. This strategy is simple and intuitive but needs
the knowledge of the inner structure of the web-service. So
the programmer needs to know the interfaces of actually
hidden services. The difﬁculty grows with the complexity
of the web-service.
C. Privacy by Partial Services
In the second extension, we show another way to im-
plement privacy, now with distributed functions. This time,
the customer also shares the date with the broker and the
date and the name with the hotel. However, the function
book is not modiﬁed and calls the function Room with one
argument missing. In the deﬁnition of Room, we use a local
database function. This fact does not allow to distribute this
function. To make it again possible, we change the code
slightly using our Self-operator and add a case analysis
because Erlang does not implement currying. Using existing
implementations of currying functors, the following code
could be further improved.
Room=fun(Self,{Date,Name})->
case Name == nil of
true ->
NewFun = fun(MissingName) ->
Args ={Date,MissingName},
future:start(Self,room,Args)
end;
false ->
BookingRef= database:any_database_call(Date,Name),
BookingRef
end
end.
In case argument Name is missing, a new function is deﬁned
which uses the existing argument Date and needs the
missing Name. This function returns a new future which
communicates also with hotel and uses both arguments
the private Name and the public Date. The customer’s wish
looks now as follows.
FutBookHotelRoom =
future:start(broker,book,{Mydate,nil}),
FunctionRoomByName=future:evaluate(FutBookHotelRoom),
FutBookingRef = FunctionRoomByName(myname),
BookingRef = future:evaluate(FutBookingRef),
The evaluation of FutBookHotelRoom returns the function
NewFun which is deﬁned in Room and awaits Name as
argument. The execution of this function returns a new
future which is evaluated by customer and returns the
bookingreference.
D. Subsumption
The three different examples show how privacy can be
implemented by using futures and active objects. As shown
above there are the possibilities to use intermediary activi-
ties, which return futures of others requests. Furthermore, the
result can be an activity allowing to break up the communi-
cation ﬂow. In the last example, we show how functionality
can be transferred/delegated. These basic concepts allow – in
the context of web-services – to implement private services
in a new manner. The concept of partial services is the base
of a new kind of using complex partially trusted services.
The fact that the name is just shared with hotels (or one
of them) and that the date is public can be speciﬁed by the
customer in an individual security policy. The implementa-
tion of an active future, the evaluation behavior of futures
and the idea of currying allow to enforce these policies
by using ﬂexible parameterization in the future. The future
knows the current communication partner and can share the
arguments on the basis of the actual security policy. If the
current call is untrusted, private data will not be shared.
467
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[book = ς(x,date)
hotel.room(date)]
[room = ς(x,date)
n → bookingref]
broker.book(date)(n)
t
...
customer
broker
hotel
Figure 3.
Private service scenario using currying
Then the behavior of currying will take effect and the result
is a new function of a new communication partner and the
description of them. So, the evaluation will run again and
call the function with the required arguments, depending
on the policy. For the case of the evaluation of a future
by another activity, the future can also check the policy
before returning the result. Another challenge is to avoid an
information ﬂow between requests inside an activity. This is
prevented by Erlang through the no data sharing concept and
in ASPfun through the rule UPDATE. For example, the use
of one generic service which can be cloned and loaded with
private data by clients allows to create a one-to-one relation
between a client and his “private” web service. The generic
service and other private services are then excluded from
the communication of one speciﬁc service client relationship
[11].
E. Service Triangle with Currying
To prepare a rigorous privacy analysis, we generalize
the service triangle in an abstract fashion summarizing the
various possible extensions seen above to a “bare bones”
privacy scenario. Now, the function room in hotel has
one additional parameter n for name besides date. This
is to emphasize the privacy issue; wishing to keep your
name n private seems natural; date, by contrast, can be
considered as irrelevant, i.e. low. See Figure 3 for the setup
conﬁguration of this privacy scenario.
Now in the curried version, room can be called just
supplying the ﬁrst date parameter. The broker still delegates
the partially instantiated request to the hotel (see Figure 4).
Thereby, the customer can then directly access a function
in hotel – via the futures f1 and f2 – that calculates his
bookingref on supplying the missing parameter name (see
Figure 5).
This intuitive idea of a curried version looks in the ASPfun
representation as follows.
[find = ς(x,date)
hotel.room(date)]
[room = ς(x,date)
n → bookingref]
f1(n)
t
...
customer
broker
hotel
hotel.room(date)
Figure 4.
Partially instantiated request is delegated.
[find = ς(x,date)
hotel.room(date)]
[room = ς(x,date)
  n → bookingref]
f1(n)
t
...
customer
broker
hotel
f2
n → bookingref
Figure 5.
Customer may retrieve ”bookingref”-function.
data[∅, [id = hugo]]
∥ customer[f0 7→ broker.bookC(d).room’(data.id), t]
∥ broker[∅, [bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[∅, [room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
It can reduce according to the semantics as shown in the
subsequent conﬁgurations.3 First, f1 is created in data.
data[f1 7→ hugo, [id = hugo]]
∥ customer[f0 7→ broker.bookC(d).room’(f1), t]
∥ broker[∅, [bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[∅, [room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
The call to bookC creates future f2,
3Clearly, there are also other possibilities to reduce, e.g. instead of
evaluating data.id in the ﬁrst step we could ﬁrst reduce the call to bookC,
thereby duplicating data.id. Since ASPfun is conﬂuent up to identical copies,
we always end with the same result.
468
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

data[f1 7→ hugo, [id = hugo]]
∥ customer[f0 7→ f2.room’(f1), t]
∥ broker[f2 7→ hotel.roomC(d),
[bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[∅, [room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
which in turn produces a future f3 in hotel where A is an
abbreviation for the active object of hotel.
data[f1 7→ hugo, [id = hugo]]
∥ customer[f0 7→ f2.room’(f1), t]
∥ broker[f2 7→ f3, [bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[f3 7→ [room’ = ς(x′, n)A.room(d, n)],
[room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
Now, we choose to reply ﬁrst f3 to customer,
data[f1 7→ hugo, [id = hugo]]
∥ customer[f0 7→ f3.room’(f1), t]
∥ broker[f2 7→ f3, [bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[f3 7→ [room’ = ς(x′, n)A.room(d, n)],
[room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
whereby the customer can serve himself by f3 the result-
ing object containing the room’ method from hotel.
data[f1 7→ hugo, [id = hugo]]
∥ customer[f0 7→ [room’ =
ς(x′, n)A.room(d, n)].room’(f1), t]
∥ broker[f2 7→ f3, [bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[f3 7→ [room’ = ς(x′, n)A.room(d, n)],
[room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
Finally, the customer receives by the rule REPLY the id
hugo contained in f1 (see Table I),
data[f1 7→ hugo, [id = hugo]]
∥ customer[f0 7→ [room’ =
ς(x, n)A.room(d, n)].room’(hugo), t]
∥ broker[f2 7→ f3, [bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[f3 7→ [room’ = ς(x′, n)A.room(d, n)],
[room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
and we locally reduce the future f0 in several steps with
the rule for CALL of the ς-reduction (see Section II-A).
data[f1 7→ hugo, [id = hugo]]
∥ customer[f0 7→ bookingref⟨hugo⟩, t]
∥ broker[f2 7→ f3, [bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[f3 7→ [room’ = ς(x′, n)A.room(d, n)],
[room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
It is crucial to observe that, even if the broker would have
served himself the content of future f3 he would not be able
to produce the result bookingref⟨hugo⟩. Thus, the program
with currying is secure with respect to a security assignment
that marks broker as low, or an outsider, and thus protects
the privacy of customer. Although the acquired privacy effect
might now seem obvious, it is necessary to ﬁnd a way
to ascertain it rigorously. Therefore, we introduce in the
following section a formal notion of security for ASPfun and
use it to analyze the security of the server triangle.
V. FORMAL SECURITY PROOF
In this section, we present a formal analysis of security for
the service triangle. We show that the classical solution is
insecure while the one with currying is secure. These formal
proofs apply a formal security deﬁnition for ASPfun to show
that no information ﬂows from the private domain of the
client to the public server.
A. Noninterference Deﬁnition for ASPfun
Intuitively, noninterference [26] means that an attacker
cannot learn anything about private data by regarding public
parts of a program. To arrive at a formal expression of this
idea for ASPfun, we ﬁrst deﬁne a relation of indistinguisha-
bility, often also called L-equivalence because in this relation
L-terms have to be equal.
We use here the notion of types informally because this
sufﬁces to disambiguate the following bijection. Indeed,
ASPfun has a safe type system [11] that can serve here but
is omitted for brevity.
Deﬁnition 5.1 (Typed Bijection): A typed bijection is a
ﬁnite partial function σ on activities α (or futures fk
respectively) such that
∀ a : dom(σ). ⊢ a : T ⇒ ⊢ σ(a) : T
(where T is given by an activity type Γact(α) or a future
type Γfut(fk) respectively).
The intuition behind typed bijections is that dom(σ) desig-
nates all those futures or activity references that are or have
been visible to the attacker. We cannot assume the names in
different runs of programs, even for low elements, to be the
same. Hence, we relate those names via a pair of bijections.
These bijections are typed because they relate activities and
futures that might need to be structurally equivalent, in case
they are low. The following deﬁnition of indistinguishability
uses the typed bijection in this sense.
We deﬁne (low)-indistinguishability as a relation ∼σ,τ
parameterized by two typed bijections one over activity
names and one over futures. It is a heterogeneous relation
as it ranges over elements of different types, for example
activities and request queues. We leave out the types as they
are indicated by our notational convention. By t =σ,τ t′ we
denote the equality of terms up to replacing all occurrences
of activity names α or futures fk by their counterparts τ(α)
469
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

or σ(fk), respectively. The local reduction with →ς of a term
t to a value te (again up to future and activity references)
is written as t ⇓ te.
Deﬁnition 5.2 (Indistinguishability): An
indistinguisha-
bility relation is a heterogeneous relation ∼σ,τ, parameter-
ized by two isomorphisms σ and τ whose differently typed
subrelations are as follows.
t ∼σ,τ t′
≡
t ⇓ te ∧ t′ ⇓ t′
e
∧ te =σ,τ t′
e
α ∼σ,τ β
≡
τ(α) = β
fk ∼σ,τ fj
≡
σ(fk) = fj
[Rα, tβ] ∼σ,τ [Rα, tα]
≡
Rβ ∼σ,τ Rβ ∧ tα ∼σ,τ tβ
Rα ∼σ,τ Rβ
≡
dom(σ) ⊆ dom(Rα) ∧ ran(σ) ⊆ dom(Rβ)
∧∀ fk ∈ dom(σ). Rα(fk) ∼σ,τ Rβ(σ(fk))
C0 ∼σ,τ C1
≡
dom(τ) ⊆ dom(C0) ∧ ran(τ) ⊆ dom(C1)
∧∀ α ∈ dom(τ). C0(α) ∼σ,τ C1(τ(α))
The high part of the program is ignored for the above
L-indistinguishability. That is, it is not part of the typed
bijections σ and τ. Indistinguishability is for H-elements
really something like “indistinguishability undeﬁned”.
Using indistinguishability we deﬁne now noninterference
as preservation of “low”-indistinguishability between pairs
of conﬁgurations. This is equivalent to saying that the
indistinguishability relation is a (weak low)-bisimulation
[19] over the conﬁguration semantics. “Low” is the set of
all elements (activities and futures) identiﬁed as low by the
security assignment and hence in the domain of σ and τ.
The deﬁnition of security of an ASPfun conﬁguration is given
with the following deﬁnition of noninterference.
Deﬁnition 5.3 (Noninterference): Two ASPfun conﬁgura-
tions C0 and C1 are called non-interfering with respect to a
security assignment sp represented by σ, τ, if whenever they
are indistinguishable, i.e. C0 ∼σ,τ C1 and C0 →∥ C′
0 there
exists a conﬁguration C′
1 that C1 →∗
∥ C′
1 and C′
0 ∼σ,τ C′
1. A
conﬁguration C is now called secure for sp if C and C1 are
non-interfering for all conﬁgurations C1 with C ∼σ,τ C1.
B. Classical Service Triangle is Insecure
Let us now show how the formal deﬁnition of information
ﬂow security, i.e. noninterference, is applied by reconsider-
ing our running example of a service triangle.
C0 ≡
data[∅, [id = hugo]]
∥ customer[f0 7→ broker.book(d, data.id), t],
∥ broker[∅, [book = ς(x, (d, n))
hotel.room(d, n), . . .]]
∥ hotel[∅, [room = ς(x, (d, n))bookingref, . . .]]
We want to protect the customer’s privacy against the
broker as reﬂected in the following security assignment sp.
sp ≡ ({data, customer, hotel} 7→ H, broker 7→ L}, {f0 7→ L})
According to the above assumption, the name hugo in
data is thus conﬁdential. To show that the above conﬁgura-
tion, say C0, is secure with respect to sp, we have to prove
according to Deﬁnition 5.3, that all other conﬁgurations C1
that are indistinguishable with respect to σ, τ containing sp,
remain so under evaluation – or – fail in the attempt. In fact,
as this example is insecure, we must fail. Let us consider an
arbitrary conﬁguration C1 with C0 ∼σ,τ C1 as follows.
C1 ≡
δ[∅, [id = ianos]]
∥ γ[g0 7→ β.book(d, δ.id), t],
∥ β[∅, [book = ς(x, (d, n))
α.room(d, n), . . .]]
∥ α[∅, [room = ς(x, (d, n))bookingref, . . .]]
Since C1 is low-indistinguishable to C0 with respect to
sp, we can deﬁne σ and τ as a bijection of the low future
and activity references of sp.
τ
≡
{broker 7→ β}
σ
≡
{f0 7→ g0}
Now, in three steps of evaluation of C0 we reach the
following conﬁguration C′
0.
C′
0 ≡
data[f1 7→ hugo, [id = hugo]]
∥ customer[f0 7→ f2, hugo), t],
∥ broker[f2 7→ hotel.room(d, hugo),
[book = ς(x, (d, n)) α.room(d, n), . . .]]
∥ hotel[∅, [room = ς(x, (d, n))bookingref, . . .]]
A conﬁguration C′
1 can be reached similarly from C1.
C′
1 ≡
δ[g1 7→ ianos, [id = ianos]]
∥ γ[g0 7→ g2, t],
∥ β[g2 7→ α.room(d, ianos),
[book = ς(x, (d, n))α.room(d, n), . . .]]
∥ α[∅, [room = ς(x, (d, n))bookingref, . . .]]
Since the future f0 and g0 are low, the new futures f2
and g2 are low, while the call to the high object data and
δ has created the new futures f1, g1 as high. Now, σ can
only be extended to σ′ = σ ∪ (f2 7→ g2) since it must
remain a bijection of the low futures. However, differing
from the deﬁnition of indistinguishability we have for the
request queues
RC′
0(f2) = hotel.room(d, hugo) ̸= RC′
1(g2) = α.room(d, ianos)
whereby ¬(C′
0∼σ,τC′
1). Since no further reduction of
C′
1 can remedy this, we know by Deﬁnition 5.3 that the
conﬁguration C0 is not secure.
470
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

C. Curried Service Triangle is Secure
Now, we reconsider the same example but this time
using the curried call to the booking function in the bro-
ker activity. We use the same security assignment sp =
({data, customer, hotel} 7→ H, broker 7→ L}, {f0 7→ L})
and abbreviate again date by d.
C0 ≡
data[∅, [id = hugo]]
∥ customer[f0 7→ broker.bookC(d).room’(data.id), t]
∥ broker[∅, [bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[∅, [room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
Now, any other indistinguishable conﬁguration, say C1,
would have at least elements corresponding to the low
elements f0 and broker of C0 because otherwise the bi-
jections σ and τ with f0 ∈ dom(σ) and broker ∈ dom(τ)
were undeﬁnable. In addition, the methods that are called
in the low parts of C1 must be deﬁned even if they are
contained in its high part. So, the least structure we have in
an indistinguishable conﬁguration C1 is up to renaming as
follows, unknown parts marked by dots.
C1 ≡
δ[. . . , [id = . . . ]]
∥ . . . [g0 7→ β.bookC(d).room’(δ.id), . . . ]
∥ β[∅, [bookC = ς(x, d)α.roomC(d), . . .]]
∥ α[. . . , [. . . , roomC = ς(x, d)[room’ = ς(x′, n) . . . ]]
The typed bijections are now σ = {f0 7→ g0} and τ =
{broker 7→ β}. The conﬁguration C0 can now make the
steps we have seen in Section IV-E arriving at the following
conﬁguration C′
0.
C′
0 ≡
data[f1 7→ hugo, [id = hugo]]
∥ customer[f0 7→ [room’ =
ς(x′, n)A.room(d, n)].room’(hugo), t]
∥ broker[f2 7→ f3, [bookC = ς(x, d)hotel.roomC(d), . . .]]
∥ hotel[f3 7→ [room’ = ς(x′, n)A.room(d, n)],
[room = ς(x, (d, n))bookingref,
roomC = ς(x, d)[room’ = ς(x′, n)x.room(d, n)]]]
For any arbitrary C0-indistinguishable conﬁguration C1
described above we know that we can arrive in a similar
conﬁguration C′
1, where ˆα denotes α’s active object.
C′
1 ≡
δ[g1 7→ “value of id” :: . . . , [id = . . . ]]
∥ . . . [g0 7→ [room’ = ς(x′, n) . . . ].room’(g1), . . . ]
∥ β[g2 7→ g3, [bookC = ς(x, d)ˆα.roomC(d), . . .]]
∥ α[g3 7→ [room’ = ς(x′, n) . . . ] :: . . . ,
[. . . , roomC = ς(x, d)[room’ = ς(x′, n) . . . ]]
This parallel reduction C1 →∥ C′
1 might have taken some
more steps than C0 →∥ C′
0 but this is legal for a weak
bisimulation. The bijection τ is updated to τ ′ ≡ τ ∪ {f2 7→
g2}; σ′ = σ. Since
RC′
0(f2) = f3 ∼σ′,τ′ g3 = RC′
1(g2)
we see that the resulting conﬁgurations are low-bisimilar,
i.e.
C′
0 ∼σ′,τ ′ C′
1.
That is, the service triangle based on ﬂexible parameteriza-
tion using currying is secure with respect to the security
assignment sp, i.e. preserves the privacy of customer’s
identity from the service broker.
D. Discussion
Concerning the enforcement of privacy policies in dis-
tributed application, the most successful and well-known
approach is the Decentralized Label Model (DLM) of A. C.
Myers [21]. It enables role based enforcement of program
security. In the DLM, explicit labels are used to annotate
elements of programs. These labels specify the principals
that own those program elements as well as who has access
to them. The DLM model is founded as our approach on the
idea of information ﬂow control; the labels serve as types
in a noninterference type systems for static analysis of the
allowed information ﬂows. The main criticism to the DLM
is that it assumes that all principals respect the DLM. We
also consider this as a weakness in particular in distributed
applications where assumptions about remote parties seems
inappropriate. To illustrate this difference: in our example
above the DLM would have assumed that the customer’s
call of book to the broker would also be high and thus be
treated conﬁdentially. Contrarily to this strong assumption
of the DLM, we do not make any assumptions about the
low site. In particular the customer can see everything in his
request queue, be it marked high or low.
Following the earlier paper [15], we follow the philosophy
that private information must not leave the trusted site.
However, this is often too strong an assumption. Consider
again our example as analyzed in this section. The additional
parameter d for the date is considered to be low, thus
not relevant to the security analysis. However, to avoid
invalidating our security analysis, date needs to be constant
in all applications! Otherwise, the broker would note a
difference between changes on the high data. It might seem
from this example that our notion of low-indistinguishability
is too strict. However, in principle, it is correct to reject the
application example if date can differ: since it is a parameter
set by high, its visibility in broker represents a ﬂow of
information from high to low. To overcome this problem,
we should consider a possibility to mark certain terms from
high as “don’t care” in our security model. That is, they are
treated as low values, but their actual value is abstracted to
make them admissible to low-equality. This represents a kind
of down-grading of high values; in our example a “real” date
of arbitrary value would be downgraded by anonymizing it
to a default constant d before passing it on to the broker (this
only for the analysis, the program remains unchanged). Then
the call would pass as before as indistinguishable.
471
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

VI. CONCLUSIONS
We have introduced functional active objects, their im-
plementation in Erlang, and how the Erlang active object
framework can be employed to support privacy in web-
services: using ﬂexible parameterization by currying, we
could prevent illegal information ﬂows of private data. This
claim has been formally justiﬁed using a formal deﬁnition
for noninterference for ASPfun functional active objects.
A. Related work
In earlier work, we have used Erlang to support privacy
for data enquiries [15]. The current work follows the same
basic philosophy used in this earlier paper as a na¨ıve solution
to the privacy problem in distributed settings: never let the
private data leave the trusted home environment, instead
import all data and search at home. We already discussed
in [15] the implications for the more general setup of
distributed active objects – now ﬁnally treated here.
Our implementation of futures is – in comparison – the
most natural as we base it on message passing. Similar to the
ideas recently expressed in Ambient Talk [5], the future is
created by the asynchronous send. In other implementations,
the future is the result of a remote method invocation and
therefore not completely asynchronous: blocking can occur.
The next difference to other future implementations is the
fact that our future is more active. This means that the future
is the active communicator between activities. In addition,
this augments privacy: in the example above, the customer
is always invisible for broker and hotel. In our current
implementation, we decided to declare the future explic-
itly to show the concrete communication and information
ﬂows. Although possible for little examples, it represents a
source of fault for complex programs. The idea to hide the
complete asynchronous communication can be implemented
as a further step. For the time being, it should be seen as a
playground for evaluating different strategies. We believe our
functional parallel approach even allows us to run activities
with circular references without deadlock (because the circle
is formed to a helix).
As already discussed in Section IV, when presenting our
different strategies to support privacy, there is need to enable
users to specify these strategies and consequently to enforce
these privacy requirements based on our implementation.
Concepts similar to Myers’ Decentralized Label Model
(DLM) [20] and the related Java implementation JIF based
on type systems for information ﬂow control are an adequate
means to specify security policies for Java programs and
make them amenable for (mostly) static analysis. However,
as a prerequisite, a formal proof that typing implies the
semantical notion of security, usually noninterference, is
necessary. Myers has only lately come up with (partial) proof
of soundness of JIF [25].
B. Positioning
For
open
communication
systems,
such
as
web-
application and web-services where data and the computa-
tion are commonly distributed, there exist several approaches
to enforce privacy, in particular the protection of private data.
In the scope of local computation, information ﬂow control
[8], [7] – an approved method to protect data sharing in
operating systems – is used more an more. This method,
originally a centralized form of mandatory access control,
has more recently been extended by decentralized aspects
to concern distributed data. A practical implementation is
Myer’s JIF [21] that tags variables by labels represent-
ing owners and readers. The information of a variable is
governed by the security policy that is expressed by these
labels. A special compiler enforces the security policy by
verifying that a program respects its policy. Between veriﬁed
programs privacy is secured. As pointed out in Section
V, we doubt that in a distributed setting it is reasonable
to assume that activities stick to the rules. Therefore, our
security model uses much weaker assumptions, and still
enforces privacy using computational methods, like currying,
to enforce data protection. The formal model of currying
presented in Section II-E has already been presented in
[14] but the notion of security presented there has been
further reﬁned in this paper. Here, it is a precise general
bisimulation.
Another approach, which goes one step further, is the use
of cryptographic protocols such as blind signatures and zero
knowledge proof to hide or masquerade real private data. So
data can be protected not just against outsider attacks but
also against attacks caused by the communication partners.
To conﬁrm the cryptographic token a centralized veriﬁer
is needed. We consider this technique an important step
forward because it can be used in addition to techniques
as we use them to support the kind of “downgrading” we
consider as necessary based on the security analysis in
Section V. In that respect, work on integration of typing
techniques for a static security analysis with cryptographi-
cally masked ﬂows, e.g. [18], [17] serves the same purpose
as our approach of protecting conﬁdential parameters via
ﬂexible parameterization.
Complex distributed systems and the provided services
are characterized by being often not completely veriﬁed.
A centralized instance to enforce policies is not always
possible or desired and sometimes sharing of private data
is necessary. In the scope of intercommunication between
the parts of a service, there are trusted and untrusted parts.
Of course, programmers can differentiate between trusted
and untrusted parts and split the communication process.
But with the complexity level of the system, this task
becomes more complicated. Our approach tries to implement
privacy without a centralized policy instance, splitting com-
munication processes but sharing private data with trusted
472
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

parties. For the enforcement of these policies inside the local
computation we can rely on existing components like JIF.
Nevertheless, being based on a formal computation model,
i.e. ASPfun, even distributed systems might be amenable to
statically provable security as illustrated in a ﬁrst approxima-
tion in this paper. With this goal in mind, our further plans
are to deﬁne a security type system enabling static analysis
of privacy of an ASPfun program as seen in this paper.
The semantic security deﬁnition for ASPfun presented in this
paper can be used as the basis for proving the correctness
of this type system.
REFERENCES
[1] M. Abadi and L. Cardelli. A Theory of Objects. Springer,
New York, 1996.
[2] J. Armstrong. Programming Erlang – Software for a
Concurrent World. The Pragmatic Bookshelf, 2007.
[3] H. Baker and C. Hewitt. The Incremental Garbage Col-
lection of Processes. Symposium on Artiﬁcial Intelligence
Programming Languages. SIGPLAN Notices 12, 1977.
[4] J. Bauer, F. Nielsen, H. Ries-Nielsen, and H. Pilegaard.
Relational analysis of correlation. In Static Analysis, 15th
International Symposium, SAS’08, volume 5079 of LNCS,
pages 32–46. Springer, 2008.
[5] E. Boix, T. Van Cutsem, J. Vallejos, W. De Meuter, and T.
D’Hondt. A Leasing Model to Deal with Partial Failures
in Mobile Ad Hoc Networks TOOLS, 2009.
[6]
D. Caromel and L. Henrio.
A Theory of Distributed
Objects. Springer-Verlag, 2005.
[7] D. E. Denning and P. J. Denning. Certiﬁcation of programs
for secure information ﬂow. Communications of the ACM,
20(7), 1977.
[8] D. E. Denning. Lattice model of secure information ﬂow.
Communications of the ACM, 19(5):236–242, 1976.
[9] T. Gurrock. A Concurrency Abstraction Implemented for
C# and .NET. Bachelor Thesis. Universit¨at. Paderborn,
2007.
[10] L. Henrio and F. Kamm¨uller. Functional active objects:
Noninterference and distributed consensus.
Technical
Report 2009/19, Technische Universit¨at Berlin, 2009.
[11] L. Henrio and F. Kamm¨uller. Functional Active Objects:
Typing and Formalisation. 8th International Workshop on
the Foundations of Coordination Languages and Soft-
ware Architectures, FOCLASA’09. Satellite to ICALP’09.
ENTCS 255:83–101, Elsevier, 2009.
[12] L. Henrio, F. Kamm¨uller, and B. Lutz. ASPfun: A Func-
tional Active Object Calculus. Science of Computer Pro-
gramming, Elsevier. In print, 2011.
[13] A. Fleck and F. Kamm¨uller. Implementing privacy with
Erlang active objects. The 5th International Conference
on Internet Monitoring and Protection, ICIMP’10. IEEE,
2010.
[14] F. Kamm¨uller. Privacy Enforcement and Analysis for
Functional Active Objects. Fifth International Workshop
on Data Privacy Management, DPM’10. Satellite to ES-
ORICS’10. LNCS 6514, Springer, 2011.
[15] F. Kamm¨uller and R. Kamm¨uller. Enhancing Privacy Im-
plementations of Database Enquiries. The Fourth Interna-
tional Conference on Internet Monitoring and Protection.
IEEE, 2009. Extended version: Security Analysis of Pri-
vate Data Enquiries in Erlang. Int. Journal on Advances
in Security, 2(2+3), 2009.
[16] M. Uzair Khan and L. Henrio. First class futures: a study
of update strategies. Research Report RR-7113, INRIA,
2009.
[17] P. Laud. On the computational soundness of cryptograph-
ically masked ﬂows. 35th Symposium on Principles of
Programming languages, POPL’08. ACM 2008.
[18] P. Laud and V. Vene. A type system for computationally
secure information ﬂow. FCT’05, volume 3623 of LNCS,
Springer, 2005.
[19] Robin Milner.
Communication and Concurrency.
In-
ternational Series in Computer Science. Prentice-Hall,
Englewood Cliffs, New Jersey, 1989. SU Fisher Research
511/24.
[20] A. C. Myers.
Jﬂow: Practical mostly-static information
ﬂow control. In 26th ACM Symposium on Principles of
Programming Languages, POPL’99, 1999.
[21] A. C. Myers and B. Liskov. Protecting Privacy using
the decentralized label model. Transaction on Software
Engineering and Methodology, TOSEM 9:410–442, IEEE
2000.
[22] L. Paulson. ML for the Working Programmer. Cambridge
University Press, 1995.
[23] R. G. Lavender and D. C. Schmidt. An Object Behavioral
Pattern for Concurrent Programming [Online] Available:
http://www.cs.wustl.edu/∼schmidt/PDF/Act-Obj.pdf
[24] H. Sutter. The Free Lunch Is Over – A Fundamental Turn
Toward Concurrency in Software. Dr. Dobb’s Journal,
30(3), 2005.
[25] L. Zheng and A. C. Myers. Dynamic security labels and
static information ﬂow control. International Journal of
Information Security, 6(2–3), 2007.
[26] J. Goguen and J. Meseguer. Security Policies and Secu-
rity Models. Proceedings of Symposium on Security and
Privacy, SOSP’82, pages 11-22. IEEE Computer Society
Press, 1982.
[27] Muhammad Uzair Khan. A Study of First Class Futures:
Speciﬁcation, Formalisation, and Mechanised Proofs Uni-
versity of Nice, PhD Thesis, 2011.
473
International Journal on Advances in Software, vol 3 no 3 & 4, year 2010, http://www.iariajournals.org/software/
2010, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

