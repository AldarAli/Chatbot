Organic Programming of Real-Time Operating Systems
Lial Khaluf1 and Franz Josef Rammig2
Heinz Nixdorf Institute
University of Paderborn
Paderborn, Germany
Email1: klial@hni.uni-paderborn.de
Email2: franz@upb.de
Abstract—Self-adaptability
and
self-management
have
become nowadays challenging properties of real-time operating
systems. Since the evolution of these systems as a response to
environmental changes is restricted due to real-time constraints,
it becomes more difﬁcult for the system to adapt itself and
manage its stability at run time. This paper introduces a new
approach, which applies the organic programming concept to
real-time operating systems. The approach enables to deﬁne
a self-adaptable and self-management real-time operating system.
Keywords-cell; task; scheduling; real-time
I. INTRODUCTION
Real-time operating systems serve a set of tasks with
respect to real time constraints. However, this set may grow
and change over time. To allow this evolution, the real-time
operating system must be able to adapt itself to the new
circumstances and to manage its data in order to preserve
all real time constraints. To achieve this goal, this paper
introduces a new approach, which allows the tasks in a real-
time application to behave like objects do in our real world.
Objects in the real world can be adapted to serve a speciﬁc
goal. Also creatures can change their behavior according to a
set of inﬂuential factors. Similarly, there are a lot of situations
encountered by real-time applications, where a modiﬁcation
of structure or behavior is needed (as a result of a task arrival
or update). E.g., in a rescue system, if a robot task is deﬁned
to run toward a burning building using its wheels, and at run
time it is decided by the system developer to get use of the
wind factor. This change aims to fasten the robot movement
or save some energy. In this case, the system must be able to
modify the task structure (adding the wind factor) and the task
behavior (consider the wind factor in the task functionality). In
addition, if this task modiﬁcation results in violating real-time
constraints when an acceptance test is made for the updated
task together with the other system tasks, then the system must
have the ability to modify the structure or behavior of the other
tasks at run time to increase the time capacity of the system.
The new capacity may in turn allow the adaptation of the new
changes with respect to real-time constraints. This ability is
called organic programming [1]. In this paper, a new approach
is provided to turn a real-time operating system (RTOS) into
a self-adaptable and self-managing system. Here, the Organic
Reconﬁgurable Operating System (ORCOS) [2] is used as an
example for an underlying RTOS. The approach introduces
the concept of real-time cells, and deﬁnes their structure and
behavior aiming at increasing the time capacity of the system
for accepting new task arrivals and updates. The following
section gives an overview of the related work. Section 3
describes the structure and behavior of real-time cells, and
Section 4 shows the adapting algorithm of the system. Finally,
a conclusion of the approach and a summary of possible future
work are pointed out in Section 5.
II. RELATED WORK
Self-adaptation and self-management are properties, which
many approaches have aimed to realize, e.g., Ercatons in
[1] have realized the concept of a true thing, which is able
to adapt new changes at run time. However, this adaptation
cannot be done under real-time constraints. In the real-time
area, some systems [3][4] were developed to adapt themselves
to a larger processing capacity at run time, but the used
techniques may result in a large unbounded time overhead.
The approach in [5], being by our knowledge one of the most
recent and closest approaches to ours, has deﬁned different
proﬁles with different resource requirements for each task
and allowed to choose the best combination of proﬁles at
run time to adapt the system to certain situations. However,
these proﬁles are developed ofﬂine, and new ones cannot
be added to the systems at run time, which decreases the
system adaptation ability. The approach in this paper applies
the concept of organic programming on ORCOS to turn it
into a self-adaptable and self-managing system. This is done
by giving the ability to modify and develop the tasks online
in a way that preserves all real-time constraints.
III. STRUCTURE AND BEHAVIOR OF REAL-TIME CELLS
A real-time cell, referred to as RTC, is a system component
mapped to a piece of memory to which a task is assigned.
There are two kinds of RTCs, controlling RTCs and controlled
RTCs. The ﬁrst kind cannot change its behavior at run time
and it is assigned a task before the system starts running. The
second kind can change its structure and behavior at run time,
and it is assigned a task online after the system starts running.
At the moment, the presented approach is restricted only on
periodic tasks scheduled by EDF [6]. However, the approach
may be extended later to support in addition aperiodic tasks
using an appropriate server like Total Bandwidth Server [7]. A
task is usually deﬁned by its data and functionality. The task
in the proposed approach is similar to the usual task model
but with an additional set of meta data.
57
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-257-8
ICAS 2013 : The Ninth International Conference on Autonomic and Autonomous Systems

The meta data differs between the tasks that can be assigned
to controlling cells, called controlling tasks, and tasks that can
be assigned to controlled cells, called controlled tasks. The
meta data of both controlling and controlled tasks is used by
the functionality of controlling tasks to be able to modify the
controlled RTCs at run time. A controlled task is assumed to
exist by mean of various versions (similar to proﬁles in [5]),
called members in this paper to avoid confusion with the clas-
sical versioning model. All members of a task can accomplish
the same basic functionality. However, the characteristics in
various dimensions (memory requirements, precision, power
dissipation, execution time,...) can vary. For simplicity reasons
in this paper, it is assumed that all objectives other than
execution time can be expressed by a single parameter, called
Cost, so a cell is characterized by (cost, execution time). A
new member may be added from the outside at any time.
The adaptation process described in Section 4 is affecting
controlled task members, which are currently in the system.
An RTC is active when its current task instance is executing
(i.e., ready or running) and is non-active otherwise. The
approach here deﬁnes only one controlling RTC, called the
Engine-RTC. Its controlling task, called the Engine-Task, is
responsible for accepting a new RTC or changing the structure
and behavior of already existing controlled RTCs at run time.
In this context, a controlled RTC is changed by changing its
associated task. The new controlled task should accomplish
the same basic functionality, which was expected from the
old one. Whenever replacing a task member as part of the
dynamic change test (see Section 4), this should also increase
the time capacity of the system sufﬁciently, e.g., it may include
functions or procedures with time characteristics different from
the older ones. To allow this, other parameters usually have
to be modiﬁed as well, e.g., the precision of calculations may
be reduced. In other words, the system may have the ability
to adapt itself to any new circumstances through choosing
possible alternatives of the currently executing controlled
tasks. As there might be a variety of choices that provide
sufﬁcient additional processor capacity, the goal is to ﬁnd
the solution, which came with the minimal costs concerning
all other parameters. The meta data of each controlled task
consists of the following information:
• ID/Member
ID/Member; id ∈ {1, 2, ...}
and
Member ∈ {0, 1, 2, ...}
ID is a unique number to differentiate between the con-
trolled tasks. Member is a number to point to a controlled
task alternative. ID/Member is read by the Engine-RTC
whenever a new controlled task arrives to realize if it is
a new task (its ID does not exist in the system) or an
update of an existing controlled task (its ID exists in the
system, but the Member number does not exist for this
ID).
• CriticalityDegree
CriticalityDegree ∈ {1, 2, ...}
CriticalityDegree is a number to express how critical a
controlled task is. It has the same value for all members
of this task. Criticality increases whenever the Criticali-
tyDegree decreases and vice versa.
• UpdatingPoints
UpdatingPoints ∈ {(i, RelativeTimePoint − i);
i ∈ {0, 1, 2, ...}}
UpdatingPoints are certain points in the functionality
code of the controlled task where replacing this task with
another member of it is possible. Each updating point is
deﬁned with a number i, and the time RelativeTimePoint-
i at which the replacement can take place. E.g., if the
execution time equals 10 time units, and the controlled
task has two updating points (0,0),(1,9), this means
that the controlled task can be replaced before it starts
executing or after 9 time units. The replacement of a con-
trolled task at some updating point means modifying the
controlled RTC to which this controlled task is assigned
(switching to another task member). The release time of
a next instance of a periodic task constitutes a natural
updating point. In this paper, the adapting algorithm is
ﬁrst dedicated only for natural updating points and then
reﬁned for intermediate updating points.
• Location
Location ∈ {(x, y);
x ∈ {ComputeNode0, ComputeNode1, ...}
and
y ∈ {MemoryAddress0, MemoryAddress1, ...}
Location is deﬁned by ComputeNodei, the com-
pute node on which the controlled task resides, and
MemoryAddressi, its memory address on that speciﬁc
compute node. Location is used by the Engine-RTC to
fetch the controlled task from its compute node to the
compute node of ORCOS (ComputeNode0).
• ArrivalTime is the time at which the current instance of
the controlled task should start executing. ArrivalTime
might not exist in the meta data of a controlled task, in
which case, ORCOS is informed that this task might be
needed in the future for replacing a certain controlled task
for which it is an alternative.
• DeadlineTime is the period of time within which the
controlled task execution should be completed.
• FetchingTime is the time required to fetch a controlled
task from the compute node where it resides to the
compute node where ORCOS resides.
• Dependency
Dependency ∈ {true, false}
Dependency is true when the controlled task depends on
the completion of other controlled tasks execution, oth-
erwise Dependency is false. For simplicity, the adapting
algorithm in this paper assumes an independent task set,
which means that Dependency is false.
58
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-257-8
ICAS 2013 : The Ninth International Conference on Autonomic and Autonomous Systems

• RelatedTasks
RelatedTasks ∈ {{(id0/M0, L0, FT0),
(id1/M1, L1, FT1), ...};
idi/Mi ∈ {ID/Member}; Li ∈ Location
and
FTi
is
the
FetchingTime
of
the
controlled
taski}
RelatedTasks determines the identity, location and fetch-
ing time of the controlled tasks on which the execution of
the controlled task depends. RelatedTasks is used by the
Engine-RTC to get information about these tasks, since
the new controlled task is only accepted in the system
if its RelatedTasks can also be accepted. Please note
that for simplicity reasons within this paper, the set of
RelatedTasks is assumed to be empty.
• ExecutionTime = time required to execute the controlled
task + ExecutionTime of the RelatedTasks + time required
to register the UpdatingPoints in the meta data of the
Engine-RTC whenever an updating point is reached at
run time.
The previous deﬁnition assumes that all RelatedTasks
have not started execution before the controlled task does.
The ExecutionTime of any controlled task is bounded
since all its factors are bounded. The reason is that the
time required to execute any controlled task and the
number of the UpdatingPoints for any controlled task are
deﬁned ofﬂine.
The Engine-Task is responsible for:
• registering the meta data of newly arrived controlled tasks
or newly arrived members.
• making an acceptance test at new arrivals to the set of
controlled tasks, the new arrival, and the Engine-task with
respect to its worst case execution time. The approach
here assumes the EDF scheduling algorithm, where all
tasks are periodic and their period is equal to their Dead-
lineTime. Thus the acceptance test is Pn
i=1 Ci/Ti ⩽ 1,
where n is the number of tasks, Ci is the execution time,
and Ti is the DeadlineTime.
• making a dynamic change test. This test is made in
case the new arrival cannot be accepted to the currently
existing system (a set of controlled tasks). The test
veriﬁes if changing the structure and behavior of RTCs
according to certain rules (see the next section) can enable
the acceptance of the new arrival.
• making a dynamic change, which means changing the
structure and behavior of RTCs selected by the previous
test. This includes fetching the controlled tasks, which
are going to replace the controlled task of the selected
RTCs from their compute nodes. In addition, it includes
fetching the new controlled task or the new upgrading
controlled task member, for which the dynamic change
test is done.
• assigning the new controlled task or the new upgrading
member (if it is accepted) to a controlled RTC.
• updating the meta data of the Engine-Task. This is
important to evaluate the worst case execution time of
the Engine-Task.
The meta data of the Engine-Task consists of the following:
• ID=0, differentiates the Engine-Task from other tasks in
the system.
• Location
Location ∈ {(ComputeNode0, MemoryAddressi);
i ∈ {0, 1, 2, ...}}
Location deﬁnes the memory address of the Engine-Task
on the compute node where ORCOS resides.
• DeadlineTime is the period of time within which the
execution of the current instance of the Engine-Task has
to be completed. This time is updated whenever the
WorstCaseExecutionTime of the Engine-Task is updated.
• TaskArray
TaskArray = {vi,j;
vi,j
is
a
memberi
of
a
controlled
taskj}
TaskArray is an array dedicated to store controlled tasks
members. Each column represents a controlled task, and
includes elements representing the registered members of
this controlled task. Each element includes the meta data
of the member. Each column also includes three addi-
tional elements, the ﬁrst one holds the last updating point
registered by the controlled task, which is represented
by this column. The second one indicates the number of
elements currently stored for this task and the third one
holds the identity ID/Member of the currently executed
member of the controlled task represented by this column.
• NumberOfTasks equals the number of columns in
TaskArray.
• WorstCaseExecutionTime (WCET) = registration time +
acceptance test time + worst case dynamic change test
time + worst case dynamic change time + worst case
assigning time + time for updating the meta data.
The WorstCaseExecutionTime is bounded since all its
factors are bounded, even those, which depend on the
number of controlled tasks and the number of their mem-
bers. These numbers are updated with each execution of
the Engine-Task, and since the WCET is calculated after
each execution of the Engine-Task, this means that the
numbers are updated and the WCET of these factors can
be predicted.
IV. THE ADAPTING ALGORITHM OF THE SYSTEM
The approach assumes EDF to be the scheduling algorithm
used. Whenever the Engine-RTC becomes active, the Engine-
Task is assigned the highest priority. This is done by assigning
a reserved fraction of the processor capacity to the Engine-
Task, where this fraction can vary over time, but is always
known. At the start of the system, the Engine-RTC is non-
active. Whenever a new controlled task or a new member of
59
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-257-8
ICAS 2013 : The Ninth International Conference on Autonomic and Autonomous Systems

a controlled task is added to a compute node, the node sends
the meta data of this task to ORCOS. If the Engine-RTC is
non-active, a system call is made to make it active. If the meta
data includes an arrival time, two cases are to be considered:
1) Arrival of a new controlled task:
The
Engine-task
performs
an
acceptance
test
Pn
i=1 Ci/Ti ⩽ 1 on all tasks including the newly
arriving one;
Ci = ExecutionTime of the ith task.
Ti = DeadlineTime of the ith task.
The
Engine-task
with
its
WCET
is
taken
into
consideration when making the acceptance test to
ensure enough time capacity for its execution when a
new arrival happens after this one. I.e., the adaptation of
the processor bandwidth dedicated to the Engine-Task
is considered as well.
If this arrival can be accepted, the Engine-Task fetches
the new controlled Task and assigns it to a Controlled
RTC. Otherwise, a dynamic change test must be run.
The goal is to replace some of the current controlled
tasks with alternative members, so that the acceptance
test succeeds. In other words, the Engine-task searches
for the controlled tasks members of minimal Cost,
which can substitute the current utilizations Ci/Ti with
smaller ones. Thus, the dynamic change test is executed
as follows:
Let the columns of the TaskArray have the search
order starting from the column, which represents the
controlled task with the smallest remaining execution
time to the controlled task with biggest remaining
execution time. I.e., we want to provide the closest
possible acceptance time. If several tasks have the
same remaining execution time the task with highest
CriticalityDegree is to be looked at ﬁrst. For the next
column j in the TaskArray{
a) Let Vj be the currently executing controlled task
member of the column j.
b) Let Fj = Cj/Tj be the processor utilization for Vj.
c) For each member Vi,j{
• calculate the utilization Fi,j:
Fi,j = Ci,j/Ti,j; where
Ci,j is the Execution-Time of Vi,j
Ti,j is the Deadline-Time of Vi,j
• Gaini,j = Fj - Fi,j
• If Gaini,j is positive, extract the respective
member’s cost: Costi,j
• Add Vi,j with (Gaini,j,Costi,j) to a set of
candidate members.}
d) Select the subset of candidate members of mini-
mal accumulated cost whose accumulated gain is
sufﬁcient to accept the new task.
e) If the accumulated gain is sufﬁcient: break; else
inspect next task until all tasks have been visited.}
If the new task set is not schedulable, i.e., the maximal
accumulated gain is not sufﬁcient, then refuse the newly
arrived controlled task.
Otherwise, replace every selected Vj by the respective
selected Vi,j.
2) Arrival of a new update member of a controlled task:
The same previous procedure is followed, and the new
update starts executing at the next natural updating point
of the current executing instance of the controlled task.
The adapting algorithm could be reﬁned to consider up-
dating points other than natural ones. In this case, the pre-
vious two cases follow the same steps with one difference.
The columns of the TaskArray must have the search order
starting from the column, which represents the controlled task
with the smallest execution time remaining to reach the next
updating point to the controlled task with biggest execution
time remaining to reach the next updating point. If two tasks
have the same execution time remaining to reach the next
updating point, the task with the highest CriticalityDegree is
to be searched ﬁrst.
V. CONCLUSION AND FUTURE WORK
This paper has introduced an approach to develop a self-
adapted and self-management RTOS. This was done by apply-
ing the concept of organic programming on RTOS (ORCOS
in this case). Further work in this area could be done by,
e.g., generalizing the approach to be applied to a larger set of
scheduling algorithms, or considering other factors that may
have inﬂuence on the time capacity, e.g., the non critical tasks,
the communication between tasks, memory and other kinds of
resources. Currently, we are pursuing to make an experimental
evaluation of the principle approach on the RTOS ORCOS.
REFERENCES
[1] F. Langhammer, O. Imbusch, and G. von Walter, ”Ercatons and Organic
Programming: Say Good-Bye to Planned Economy,” Organic Computing
- Controlled Emergence, Vol. 06031, 2006.
[2] <https://orcos.cs.uni-paderborn.de/orcos>, [retrieved: January, 2013].
[3] J. A. Stankovic and K. Ramamritham, ”The Spring Kernel: A New
Paradigm for Real Time Operating Systems,” Operating Systems Review
(SIGOPS), Vol. 23, no. 3, February.1989, pp. 54-71.
[4] K. Ramamritham and J. A. Stankovic, ”Scheduling Algorithms and
Operating Systems Support for Real Time Systems,” Proceedings of the
IEEE, Vol. 82, no. 1, January.1994, pp. 55-67.
[5] S. Oberth¨ur, L. Zaramba, and H. Lichte, ”Flexible Resource Management
for Self-X Systems: An Evaluation,” in Proceedings of ISORCW’10,
May.2010, pp. 1-10.
[6] W. A. Horn, ”Some Simple Scheduling Algorithms,” Naval Research
Logistics Quaterly, Vol. 21, no. 1, March.1974, pp. 177-185.
[7] G. C. Butazzo, ”Hard Real-Time Computing Systems. Predictable
Scheduling Algorithms and Applications,” Springer Science+Business
Media, LLC, 2nd rev.ED, 2004.
60
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-257-8
ICAS 2013 : The Ninth International Conference on Autonomic and Autonomous Systems

