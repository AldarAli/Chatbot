Undecidable Case and Decidable Case of Joint
Diagnosability in Distributed Discrete Event Systems
Lina Ye and Philippe Dague
INRIA, Grenoble-Rhˆone-Alpes, lina.ye@inria.fr
LRI, Univ. Paris-Sud, philippe.dague@lri.fr
Abstract—Diagnosability is an important property that deter-
mines at design stage how accurate any diagnosis algorithm can
be on a partially observable system. Most existing approaches
assumed that each observable event in the system is globally
observed. Considering the cases where there is no global in-
formation, one of our recent work proposed a new framework
to check diagnosability in a system where each component can
only observe its own observable events to keep the internal
structure private in terms of observations. However, we assumed
that the local paths in each component can be exhaustively
enumerated, which is not suitable in a general case where there
are embedded cycles. In this paper, we get some new results
about diagnosability in such a system in a general case, i.e.,
what we call joint diagnosability in a self-observed distributed
system. First, we prove the undecidability of joint diagnosability
with unobservable communication events by reducing the Post’s
Correspondence Problem to joint diagnosability problem. We also
propose an algorithm to check a sufﬁcient but not necessary
condition of joint diagnosability, which is then adapted when the
assumption of all communication events being unobservable is
relaxed, i.e., communication events could be either observable or
unobservable. Then, we discuss about the decidable case where
communication events are all observable and develop a new
efﬁcient algorithm to test it. Finally, we also provide an important
property of joint diagnosability after analyzing its relationship
with classical diagnosability.
Keywords—joint diagnosability, self-observed systems, ﬁnite state
machine, Post’s Correspondence Problem, undecidability.
I.
INTRODUCTION
O
VER the latest decades, with the advancement of tech-
nologies, systems are becoming more and more complex
since more performance requirements are imposed on them,
which causes more errors that they are subject to. However, it
is not realistic to manually detect faults for complex systems.
Automated diagnosis mechanisms are therefore required to
monitor large distributed applications such as transportation
systems, communication networks, manufacturing systems,
web services, spatial systems and power systems. Thus, it is
crucial for a complex system to perceive that it is not operating
correctly and then without human intervention, to detect and
isolate original faults, which will be restored by repair plans
to normality.
Generally speaking, diagnosis reasoning is to detect possible
faults that can explain the observations. The possibility to
achieve such a diagnosis reasoning depends on the diagnos-
ability of the system. Diagnosability is an important property
that determines at design stage how accurate any diagnosis
algorithm can be on a partially observable system, which has
signiﬁcant economic impact on the improvement of perfor-
mance and reliability of complex systems. The diagnosability
analysis problem has received considerable attention in the
literature, both in centralized and distributed ways.
In this paper, we study diagnosability problem for dis-
tributed systems where a component cannot observe the ob-
servable events in other components, which are called self-
observed systems. We make several contributions by extend-
ing the conference article [1]. The ﬁrst one is to extend
diagnosability of globally observed systems to what we call
joint diagnosability of self-observed systems before proving
its undecidability in the case where communication events
are unobservable. This is done by reducing the Post’s Cor-
respondence Problem to joint diagnosability problem, which
is inspired from the undecidability result of joint observability
[2]. The second one is to propose an algorithm for testing a
sufﬁcient condition of joint diagnosability with unobservable
communication events. To do so, we ﬁrst obtain pairs of local
trajectories in the faulty component, such that for each pair,
only one trajectory contains the fault but both trajectories have
the same enough local observations. Their global consistency
is then checked through two phases. We prove that it is a
sufﬁcient condition and point out why it is not necessary.
Afterwards, we adapt this algorithm when the assumption
of communication events being unobservable is relaxed, i.e.,
communication events could be observable or unobservable.
The third one is to discuss about the decidable case where
communication events are observable and to develop an ef-
ﬁcient algorithm to test it. Finally, we provide an important
property of joint diagnosability after analyzing its relationship
with classical diagnosability.
This article extends our recent works [1] and [3] in the
following aspects.
•
We add detailed proofs for Theorem 1 and Lemma 2,
which make our approach more convincing in terms of
correctness.
•
We deﬁne a new structure called local twin checker
for a normal component to make the presentation more
clear and the algorithm more efﬁcient. The reason is
that a local twin checker contains no fault information
since it is constructed for a normal component without
fault. Then we provide new complexity analysis for the
proposed sufﬁcient algorithm to test joint diagnosability
when communication events are unobservable.
•
We generalize the sufﬁcient algorithm to test joint di-
287
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

agnosability when the assumption is relaxed such that
communication events could be either observable or
unobservable, which is presented in Section V-D.
•
In Section VI, we provide more details about why joint
diagnosability is decidable when communication events
are all observable and then develop a new algorithm to
test it.
•
We provide a new important property of joint diag-
nosability after analyzing its relationship with classical
diagnosability in Section VII.
The paper is organized as follows. In the next section,
we talk about related works in the literature. In Section
III, we model self-observed distributed systems and recall
classical diagnosability and joint diagnosability. Section IV
presents undecidability analysis for joint diagnosability when
communication events are unobservable. An algorithm to test a
sufﬁcient condition is proposed in Section V with complexity
analysis, which is then adapted when communication events
could be either unobservable or observable. In Section VI,
we discuss about decidable case for joint diagnosability, i.e.,
when communication events are observable, before giving an
algorithm to test it. Finally, we compare joint diagnosability
and classical diagnosability to ﬁnd out their relationship in
Section VII before giving the conclusion in Section VIII.
II.
RELATED WORK
In the literature, three types of systems are under investiga-
tion for diagnosis problem: continuous systems, discrete event
systems and hybrid systems ([4], [5], [6], [7], [8], [9], [10],
[11], [12]). In this paper, the dynamic systems studied are
discrete event systems (abbreviated DES hereafter). Given a
system, if its state space is naturally described by a discrete set
and if state transitions only occur at discrete points in time, we
associate these transitions with events and this system is called
a DES. The reason why we choose DES for investigation is that
most of the man-made systems are DES and that continuous
systems can be abstracted to be DES. Nowadays, lots of works
have been studied on control of DES, including diagnosis
algorithm, diagnosability analysis, predictability analysis, etc.
([13], [14], [15], [16], [17], [18], [19]).
Some existing works analyzed diagnosability problem in a
centralized way ([20], [21] and [22]), i.e., the knowledge of the
monolithic model of a given system is hypothesized, which is
the very powerful information for diagnosability analysis and
leads to an unrealistic combinatorial explosion of the search
space. This is why very recently distributed approaches for
diagnosability began to be investigated ([23], [24] and [25]),
relying on local objects. More precisely, in these distributed ap-
proaches, original diagnosability information can be obtained
from the components where faults may occur and then the
global decision is calculated by checking its global consistency.
However, all these approaches assumed that each observable
event in the system can be observed by all components, i.e.,
globally observed. However, in reality, there are some cases
where it is not possible to obtain global information. For
example, networked control systems are characterized by the
fact that multiple distributed components possess their own
X0
X1
X2
X3
X4
X5
O1
C1
O1
F
U1
O2
O1
C2
O2
Y0
Y2
Y3
Y4
O3
O3
C1
O4
O5
C2
X6
C2
Y1
U2
Fig. 1: A system with two components G1 (left) and G2 (right).
part of available information instead of a global knowledge.
Then one of our recent work [26] proposed a new framework
to check diagnosability in a system where each component
can only observe its own observable events to keep the
internal structure private in terms of observations. However,
we assumed that the local paths in each component can be ex-
haustively enumerated, which is not suitable in a general case
where there are embedded cycles. In this paper, we generalize
this work to get some new results about the diagnosability of
what we call self-observed distributed systems, i.e., systems
where locally observable events can only be observed by their
own component.
III.
PRELIMINARIES
In this section, we show how to model self-observed dis-
tributed DESs and then recall classical diagnosability and joint
diagnosability.
A. System Model
We consider a self-observed distributed DES composed of
a set of components {G1, G2,..., Gn} that communicate with
each other by communication events. Each component can
only observe its own observable events and thus keeps its
internal structure private in terms of observations. Such a
system is modeled by a set of ﬁnite state machines (FSM),
each one representing the local model of one component.
Deﬁnition 1: (Local Model). The local model of a compo-
nent Gi is a FSM, denoted by Gi = (Qi, Σi, δi, q0
i ), where
•
Qi is the set of states;
•
Σi is the set of events;
•
δi ⊆ Qi × Σi × Qi is the set of transitions;
•
q0
i is the initial state.
The set of events Σi is partitioned into four disjoint subsets:
Σio, the set of locally observable events that can be observed
only by their own component Gi; Σiu, the set of unobservable
normal events; Σif , the set of unobservable fault events; and
Σic, the set of communication events shared by at least one
other component, which are the only shared events between
components. Figure 1 depicts a self-observed distributed sys-
tem with two components: G1 (left) and G2 (right), where Oi
denotes a locally observable event, F denotes an unobservable
fault event, Ui denotes an unobservable normal event and Ci
denotes a communication event.
We denote the synchronized FSM of components G1, ..., Gn
by ∥(G1, ..., Gn), where the synchronized events are the shared
events between components and each one of them always
occurs simultaneously in all components that deﬁne it. The
288
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

state space of the synchronized FSM is the Cartesian product
of the state spaces of components. The monolithic model
(also called global model in the following) of the entire
system is implicitly deﬁned as the synchronized FSM of all
components based on their shared events, i.e., communication
events. However, the global model will not be calculated in
this paper since in a self-observed distributed system, the
global occurrence order of observable events is not accessible.
In the following, we call the synchronization of a subset of
components of G, i.e., ∥(Gs1, ..., Gsm), as subsystem of G,
where {s1, ...sm} ⊆ {1, ...n}. Note that one component or the
entire system can also be considered as a subsystem.
Given a system model G = (Q, Σ, δ, q0), the set of words
produced by the FSM G is a preﬁx-closed language L(G)
that describes the normal and faulty behaviors of the system.
Formally, L(G) = {s ∈ Σ∗|∃q ∈ Q, (q0, s, q) ∈ δ}, where the
transition δ has been extended from events to words. In the
following, we call a word of L(G) a trajectory in the system
G and a sequence q0σ0q1σ1... a path in G, where σ0σ1... is
a trajectory and for all i, we have (qi, σi, qi+1) ∈ δ. Given
s ∈ L(G), we denote the post-language of L(G) after s by
L(G)/s and denote the projection of s to observable events
of G (resp. Gi) by P(s) (resp. Pi(s)). For example, if s =
O1.U2.O3∗, then we have P(s) = O1.O3∗, where Oi denotes
an observable event. These notations are also appropriate for
local components. We adopt the assumption described in [23],
i.e., the projection of the global language on each local model
is observable live, in particular there is no unobservable cycle
in any component. For the sake of simplicity, our approach
is illustrated by dealing with only one fault, which can be
extended to the case with multiple faults.
B. Diagnosability and Joint Diagnosability
We now recall classical diagnosability for centralized DESs.
Informally speaking, the existence of two indistinguishable
behaviors, i.e., holding the same enough observations with
exactly one of them containing the given fault F, violates
diagnosability property. The diagnosability approaches consist
in checking the existence of such indistinguishable behaviors.
In other words, a fault F is diagnosable in a system G iff its
occurrence is determinable when enough events are observed
from G after the occurrence of F, which is formally deﬁned
as follows [20], where sF denotes a trajectory ending with F.
Deﬁnition 2: (Diagnosability). A fault F is diagnosable in
a system G iff
∀sF ∈ L(G), ∃k ∈ N, ∀t ∈ L(G)/sF , |t| ≥ k ⇒
(∀p ∈ L(G), P(p) = P(sF .t) ⇒ F ∈ p).
The above deﬁnition states that if F is diagnosable, then
for each trajectory sF in G, for each t that is an extension
of sF with sufﬁcient events, every trajectory p in G that is
observation equivalent to sF .t should contain F. We call a pair
of trajectories p and p′ satisfying the following conditions as
a critical pair:
•
p contains F and p′ does not;
•
p has arbitrarily long events after the occurrence of F;
•
P(p) = P(p′).
It has been proved that the existence of critical pairs violates
Deﬁnition 2 and thus witnesses non-diagnosability [21]. For
distributed systems, the analysis of the above classical diag-
nosability requires global observations, which is not suitable
for self-observed distributed systems where observable events
can only be observed by their own component. Now we give
the deﬁnition of joint diagnosability that only requires local
observations without considering their global occurrence order
[26].
Deﬁnition 3: (Joint diagnosability). A fault F is jointly
diagnosable in a self-observed distributed system G composed
of components {G1, ...Gn}, iff
∀sF ∈ L(G), ∃k ∈ N, ∀t ∈ L(G)/sF , (∀i ∈
{1, ..., n}, |Pi(t)| ≥ k)⇒ (∀p ∈ L(G)
(∀i ∈ {1, ..., n}, Pi(p) = Pi(sF .t)) ⇒ F ∈ p).
Joint diagnosability of a fault F means that for each trajectory
sF in G, for each t that is an extension of sF with enough
locally observable events in all components, every trajectory p
in G that is equivalent to sF .t for local observations in each
component should contain in it F. In a self-observed system,
we call a pair of trajectories p and p′ satisfying the following
conditions an (global) indeterminate pair:
•
p contains F and p′ does not;
•
p has arbitrarily long local observations in all compo-
nents after the occurrence of F;
•
∀i ∈ {1, ..., n}, Pi(p) = Pi(p′).
Here arbitrarily long local observations can be considered as
inﬁnite local observations. Now we have the following theorem
[26].
Theorem 1: Given a self-observed distributed system G, a
fault F is jointly diagnosable in G iff there is no (global)
indeterminate pair in G.
Proof:
(⇒) Suppose that F is jointly diagnosable in a system G and
that there exists an indeterminate pair p and p′ with only p
containing the fault F. Now let sF denote the subpart of p
that is ending with F and let t denote the rest part of p, i.e.,
p = sF .t. Since p and p′ are an indeterminate pair, from its
deﬁnition, we have that p has arbitrarily long local observations
for each component Gi after the occurrence of F, and that for
each component Gi, p and p′ have the same local observations,
i.e., Pi(p) = Pi(p′). However, p′ does not contain F. This
contradicts the deﬁnition of joint diagnosability, where any
trajectory with the same enough local observations in each
component as sF .t should also contain F. So F is not jointly
diagnosable in G, which contradicts the assumption.
(⇐) Now suppose that there is no indeterminate pair in
G and F is not jointly diagnosable in G. From the non
joint diagnosability of F and Deﬁnition 3, we deduce that
∃sF ∈ L(G), such that there exists at least one extension t with
enough local observations (represented by inﬁnite paths with
cycles) in all components, for which there must exist at least
one other trajectory p containing the same local observations
as sF .t for each component but without fault. Since the enough
local observations of sF .t and p come from inﬁnite paths with
cycles, sF .t and p can be prolonged arbitrarily long. It follows
that sF .t and p are an indeterminate pair since they satisfy
three conditions of the deﬁnition of an indeterminate pair,
289
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

S0
O1
C2
SFK+1
C1
SFK
CK
F
C1
Z1
C2
Z2
CK
ZK
S1
S2
SK
SK+1
O1
O1
C1
C2
CK
C1
V1
C2
V2
CK
VK
T0
T1
O2
T2
A2
TK+1
A1
TK
AK
TK+2
O2
A1
C1
A2
C2
AK
CK
S 1
F
SF2
SFK+2
SK+2
Fig. 2: A system with two components G1 (top) and G2 (bottom) for
proving undecidability of joint diagnosability.
which contradicts the assumption that there is no indeterminate
pair.
Another important notation that will be used in joint diag-
nosability analysis is reconstructibility [27], which is rephrased
as follows.
Deﬁnition 4: (Reconstructibility). Given a system G that is
composed of several subsystems, i.e., G = ∥(Gs1, ..., Gsm),
let ρ be a trajectory in G, the set of trajectories obtained
by projecting ρ on these subsystems, i.e., denoted by ρ1 =
P ′
Gs1(ρ), ..., ρm = P ′
Gsm(ρ), where P ′
Gsi (ρ) is the projection
of ρ on the subsystem Gsi, is said to be reconstructible with
respect to G.
Lemma 1: In a system G, given two subsystems GS and
G′
S, if ΣSc ∩ ΣS′c = ∅, then ∀(s, s′), s ∈ L(GS), s′ ∈ L(G′
S),
s and s′ are reconstructible.
Lemma 1 means that if there is no common communication
event between two subsystems, then any trajectory in one
subsystem and any one in the other one are reconstructible.
IV.
UNDECIDABLE CASE
To discuss about joint diagnosability, we consider two cases:
communication events being unobservable and observable. In
this section, we ﬁrst consider the case where all communica-
tion events are unobservable.
Theorem 1 implies that checking joint diagnosability boils
down to check the existence of indeterminate pairs that wit-
nesses non joint diagnosability. Before discussing about how
to test this, it is very important to check whether the problem
is decidable or not. Inspired from [2], where undecidability of
joint observability is proved by reducing the Post’s Correspon-
dence Problem (PCP) to an observation problem, we now prove
that joint diagnosability is not decidable with communication
events being unobservable.
Theorem 2: Given a self-observed distributed system where
communication events are unobservable, checking joint diag-
nosability of a given fault is undecidable.
Proof:
1) PCP: given a ﬁnite alphabet Σ, two sets of words
v1, v2, ..., vk and z1, z2, ..., zk over Σ, then a solution to PCP is
a sequence of indices (im)1≤m≤n with n ≥ 1 and 1 ≤ im ≤ k
for all m such that vi1vi2...vin = zi1zi2...zin.
2) Now consider the example depicted in Figure 2, where the
system is composed of two components G1 and G2. In G1,
each one of V i, i ∈ {1, ..., k}, or each one of Zi, i ∈ {1, ..., k},
denotes a sequence of observable events all different from
the observable event O1, and C1, ..., Ck are unobservable
communication events, then F denotes a fault event. In G2,
each one of Ai, i ∈ {1, ..., k}, denotes an observable event
different from the observable event O2, and C1, ..., Ck are
unobservable communication events. Then the observations in
G1 can be described as V i1V i2...V inO1∗ without fault or
Zi1Zi2...ZinO1∗ with fault, where ∀ij, j ∈ {1, ..., n}, ij ∈
{1, ..., k}. In G2, the observations are Ai1Ai2...AinO2∗.
3) With the observation of O1, the local observations are
wO1+ for G1 and Ai1Ai2...AinO2∗ for G2, where w =
V i1V i2...V in when there is no fault or w = Zi1Zi2...Zin
when there is a fault. Clearly, if PCP has a solution, i.e.,
∃(im)1≤m≤n such that V i1V i2...V in = Zi1Zi2...Zin, we
have two trajectories p and p′ such that the observations of
p in G1 are V i1V i2...V inO1+, which is a trajectory without
fault, while the observations of p′ in G1 are Zi1Zi2...ZinO1+,
which is a trajectory with a fault. And both p and p′ have
the same observations for G2, i.e., Ai1Ai2...AinO2∗. Thus
we get that p and p′ have the same observations for both
G1 and G2, i.e., V i1V i2...V inO1+=Zi1Zi2...ZinO1+ for G1
and Ai1Ai2...AinO2∗ for G2, then the fault is not jointly
diagnosable.
4)
On
the
other
hand,
if
the
fault
is
not
jointly
diagnosable,
then
we
obtain
at
least
one
indetermi-
nate
pair,
denoted
by
p
and
p′
such
that
the
pro-
jection
of
p
on
G1
is
Ci1V i1Ci2V i2...CinV inO1∗,
on
G2
is
Ai1Ci1Ai2Ci2...AinCinO2∗
and
that
of
p′
on
G1
is
Cj1Zj1Cj2Zj2...CjmZjmFO1∗
and
on
G2
is Aj1Cj1Aj2Cj2...AjmCjmO2∗. From the fact that p
and
p′
have
the
same
observations
for
G2,
we
get
Ai1Ai2...AinO2∗ = Aj1Aj2...AjmO2∗ and thus we have
m = n and i1 = j1, ..., in = jn. And then from the same
observations of p and p′ on G1, we get V i1V i2...V inO1∗ =
Zi1Zi2...ZinO1∗, i.e., V i1V i2...V in = Zi1Zi2...Zin, which
means that there is a solution for PCP.
5) From above, we get that checking the existence of a
solution for PCP is equivalent to checking the existence of
an indeterminate pair. Since PCP is an undecidable problem,
checking joint diagnosability is also undecidable.
There are two major differences between joint diagnosability
in our framework and joint observability in [2]. One is that
the former assumes that local observers are attached to local
components that are synchronized by common communication
events to get a global model while the latter separates arbi-
trarily the observable events in the global model into several
sets. The other one is that joint diagnosability consists in
separating inﬁnite trajectories while joint observability consists
in separating ﬁnite ones. Thus, if any communication event
is assumed to be unobservable, joint diagnosability checking
boils down to inﬁnite PCP. But this one has been proved to be
undecidable [28].
290
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

V.
ALGORITHM TO TEST A SUFFICIENT CONDITION
We have proved that joint diagnosability in self-observed
distributed systems with unobservable communication events
is undecidable. We can nevertheless propose an algorithm
to test a sufﬁcient condition, which is still quite useful in
some circumstances. The ﬁrst step is to construct the local
diagnoser for the faulty component, which allows one to get
fault information after any local trajectory. Then we show
how to build the corresponding local twin plant based on
the local diagnoser to obtain the original information about
indeterminate pairs (also called local indeterminate pairs in the
following). The next step is to check the global consistency,
i.e., whether the local indeterminate pairs can be extended into
(global) indeterminate pairs, whose existence veriﬁes non joint
diagnosability. We give an algorithm to test a sufﬁcient but not
necessary condition for global consistency.
A. Original Diagnosability Information
From Theorem 1, we know that joint diagnosability ver-
iﬁcation consists in checking the existence of indeterminate
pairs in the system. In the distributed framework, we use the
structure called local twin plant, initially deﬁned in [21], to
analyze joint diagnosability. In particular, the considered fault
is assumed to only occur in one component, denoted by GF .
Then the local twin plant for GF contains original information
for indeterminate pairs: this twin plant is a FSM that compares
every pair of local trajectories to search for the pairs with the
same arbitrarily long local observations, but exactly one of the
two containing a fault, which are called local indeterminate
pairs. First, we deﬁne an operation called delay closure with
respect to a subset Σd of Σ to preserve all information about
the events in Σd by abstracting away other parts.
Deﬁnition 5: (Delay
Closure).
Given
a
FSM
G
=
(Q, Σ, δ, q0), its delay closure with respect to Σd
⊆ Σ
is ∁Σd(G) = (Q, Σd, δd, q0) where (q, σ, q′) ∈ δd, σ ∈ Σd iff
∃s ∈ (Σ\Σd)∗, (q, sσ, q′) ∈ δ.
We now describe how to construct the local diagnoser for a
given component, based on which we build the local twin plant.
Deﬁnition 6: (Local Diagnoser). Given a component model
Gi, its local diagnoser is the nondeterministic FSM Di =
(QDi, ΣDi, δDi, q0
Di), where QDi ⊆ Qi × 2Σif is the set
of states, ΣDi = Σic ∪ Σio is the set of events, δDi ⊆
QDi × ΣDi × QDi is the set of transitions, and q0
Di = (q0
i , N)
is the initial state of the diagnoser. The transitions of δDi are
those ((q, l), e, (q′, l′)) with (q, l) reachable from the initial
state q0
Di, and satisfying the following condition: there is a
transition path p = (q
u1
−→ q1...
um
−−→ qm
e−→ q′) in G,
with uk ∈ Σiu ∪ Σif , ∀k ∈ {1, ..., m}, e ∈ Σio ∪ Σic and
ℓ′ = ℓ ∪ ({u1, ...um} ∩ Σif ).
Without loss of generality, we give the deﬁnition of local
diagnoser for the set of faults in the component Gi, which
is perfectly suitable to deal with single fault when we run
our algorithm each time for one fault since twin plant method
has exponential complexity with the number of faults. A
diagnoser constructed as above shows fault information after
any sequence of communication events and observable events
in the faulty component. Figure 3 shows the local diagnoser
X0 N
X4 N
X2 N
X3 F
O1
 C2
O2
O1
X1 N
 C1
O1
X5 N
  O1
X3 N
O1
C2
O2
Fig. 3: Local diagnoser for G1 of the system in Figure 1.
for the component G1 of the system depicted in Figure 1.
Given a diagnoser, its corresponding twin plant is obtained by
synchronizing this diagnoser with itself, called left and right
instances (denoted by Dl
i and Dr
i , respectively), based on the
set of observable events. From Deﬁnition 6, we know that a
diagnoser keeps observable events as well as communication
events. However, since the local twin plant is to obtain all
pairs with the same observations to search for local indeter-
minate pairs, only observable events should be synchronized.
Since shared events are the only synchronized events, the
non-synchronized events are distinguished between the two
instances by the preﬁx L (R): in Dl
i (Dr
i ), each communication
event c ∈ Σic from Di is renamed by L : c (R : c). The names
of all locally observable events remain the same. The deﬁnition
of local twin plant is shown as follows.
Deﬁnition 7: (Local Twin Plant). Given a diagnoser Di, the
corresponding local twin plant is obtained by synchronizing its
left instance with its right instance based on the set of observ-
able events, denoted by Ti = (QTi, ΣTi, δTi, q0
Ti) = Dl
i∥Dr
i .
Each state of a local twin plant is a pair of local diagnoser
states providing two possible diagnoses with the same local
observations. Given a local twin plant state ((ql, ll)(qr, lr)),
where (ql, ll) and (qr, lr) are two diagnoser states and each one
contains both a system state and a fault label. If the considered
fault F ∈ ll ∪ lr but F
/∈ ll ∩ lr, which means that the
occurrence of F is not certain up to this state, then this state
is called an ambiguous state with respect to the fault F. An
ambiguous state cycle is a cycle containing only ambiguous
states. In a local twin plant, if a path contains an ambiguous
state cycle with at least one locally observable event, then it
is called a local indeterminate path, which corresponds to
a local indeterminate pair. Note that local indeterminate paths
contain original diagnosability information and can be obtained
only in the local twin plant of the component GF . If a local
indeterminate pair can be extended into a global indeterminate
pair, then we say that its corresponding local indeterminate
path is globally consistent. Figure 4 presents the left and right
instances of the local diagnoser for the component G1 (top left
and top right) as well as part of the corresponding local twin
plant (bottom). The gray node represents an ambiguous state
since the fault label is only contained in one of two diagnoser
states. Thus, we can see that the corresponding path in this
local twin plant is a local indeterminate path since it contains
an ambiguous state cycle with a locally observable event.
We know that the function of the local twin plant is to
obtain the original diagnosability information, i.e., all local
indeterminate paths. From Figure 4, we can see that a local
twin plant constructed as described above normally has a large
291
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

X0 N
X4 N
X2 N
X3 F
O1
 L:C2
O2
O1
X1 N
 L:C1
O1
X5 N
  O1
X3 N
O1
L:C2
O2
X0 N
X4 N
X2 N
X3 F
O1
 R:C2
O2
O1
X1 N
 R:C1
O1
X5 N
  O1
X3 N
O1
R:C2
O2
X0 N
X0 N
X0 N
X1 N
X4 N
X5 N
X2 N
X5 N
X2 N
X3 N
X3 F
X3 N
X1 N
X0 N
O1
R:C1
L:C2
R:C2
L:C1
O2
O1
O1
X2 N
X4 N
X2 N
X2 N
X3 F
X3 F
O1
R:C2
O1
X4 N
X4 N
X5 N
X5 N
X3 N
X5 N
X3 N
X3 N
O1
X1 N
X1 N
X1 N
X0 N
O2
O2
L:C2
L:C1
R:C1
L:C2
R:C2
Fig. 4: Two instances of the diagnoser for G1 (top) and part of the
corresponding local twin plant (bottom).
X0 N
X4 N
X2 N
X1 N
X3 F
O1
L:C1
O1
O1
O2
L:C2
X0 N
X1 N
X5 N
X3 N
O1
O1
R:C2
R:C1
O2
X0 N
X0 N
X0 N
X1 N
X4 N
X5 N
X2 N
X5 N
X2 N
X3 N
X3 F
X3 N
X1 N
X0 N
O1
R:C1
L:C2
R:C2
L:C1
O2
O1
O1
Fig. 5: Two reduced instances of the diagnoser for G1 (top) and part
of the corresponding reduced local twin plant (bottom).
redundant part, which is useless for a global decision, e.g.,
all paths without ambiguous state cycles. Furthermore, there
could be several local indeterminate paths that correspond to
the same pair of local trajectories in the local diagnoser. To
simplify the local twin plant, we propose one way to reduce
the two instances of the local diagnoser: Dl
i is obtained by
retaining only paths with at least one fault cycle and Dr
i
is reduced by retaining only paths with at least one cycle
without fault state. This reduction keeps all necessary original
diagnosability information since what we are interested in here
are only local indeterminate pairs. Figure 5 shows the left and
right reduced instances of the local diagnoser for the faulty
component G1 of Figure 1 (top) as well as part of the reduced
local twin plant (bottom) that corresponds to the part of non-
reduced local twin plant shown in the bottom part of Figure 4.
In this way, the state space of the local twin plant constructed
from reduced instances can be considerably reduced, which is
called reduced local twin plant.
Lemma 2: The local twin plant corresponds to the same set
of local indeterminate pairs as the reduced local twin plant.
Proof:
As described before, the local twin plant is constructed by
synchronizing the non-reduced left and non-reduced right
instances of the local diagnoser while the reduced one is
constructed by synchronizing the reduced left and reduced
right instances. For the sake of clarity, in the non-reduced
left instance, we denote the set of paths with only fault state
cycles by Λl
f, the set of paths without fault state cycle by
Λl
¬f, and then the set of paths with both fault state cycles
and cycles without fault state by Λl
both. Similarly, in the non-
reduced right instance, we denote the set of paths with only
fault state cycles by Λr
f, the set of paths without fault state
cycle by Λr
¬f, and the set of paths with both fault state cycles
and cycles without fault state by Λr
both. Then the local twin
plant is constructed by (Λl
¬f∪Λl
f∪Λl
both) ∥ (Λr
¬f∪Λr
f∪Λr
both).
On the other hand, the reduced left instance retains the paths
with at least one fault state cycle and the reduced right
instance retains the paths with at least one cycle without fault
state. Then the reduced local twin plant is constructed by
(Λl
f ∪Λl
both) ∥ (Λr
¬f ∪Λr
both). The local twin plant construction
can be expressed by the addition of the synchronized results
of nine cases: 1) (Λl
¬f) ∥Σio (Λr
¬f); 2)(Λl
¬f) ∥Σio (Λr
f);
3)(Λl
¬f) ∥Σio (Λr
both) 4)(Λl
f) ∥Σio (Λr
¬f); 5) (Λl
f) ∥Σio (Λr
f);
6) (Λl
f) ∥Σio (Λr
both); 7)(Λl
both) ∥Σio (Λr
¬f); 8) (Λl
both) ∥Σio
(Λr
f) and 9) (Λl
both) ∥Σio (Λr
both). In the same way, the
reduced local twin plant construction can be expressed by the
addition of the synchronized results of four cases in the above,
which are (case 4 + case 6 + case 7+ case 9). So compared
to the reduced local twin plant, the local twin plant has ﬁve
more synchronized results (case 1 + case 2 + case 3 + case 5
+ case 8). Now consider case 4 and case 2, which are actually
symmetrical. We can see that the part in left instance of case
2 is the same as the part in right instance of case 4 and the
part in right instance of case 2 is the same as the part in left
instance of case 4. It is easy to prove that the synchronized
result of case 2 corresponds to the same set of local trajectory
pairs in the local diagnoser as the synchronized result of case
4 does. In the same way, case 6 has the same result as case
8 and case 7 has the same result as case 3. Now the local
twin plant has two more synchronized results (case 1 + case
5) than the reduced local twin plant. However, case 1 and
case 5 can never get any local indeterminate pair. The reason
is that in case 1, any path in Λl
¬f and in Λr
¬f has no fault
state cycle, then the synchronized result has no ambiguous
state cycle, which means that there is no corresponding local
indeterminate pair. And in case 5, any path in Λl
f and in Λr
f has
only fault state cycles. So their synchronization cannot obtain
local indeterminate pair. Now we can say that the local twin
plant corresponds to the same set of local indeterminate pairs
as the reduced local twin plant does, which proves Lemma 2.
In our approach, we only construct the reduced local twin
plant in the following, which is, from now on, called local
twin plant for the sake of simplicity.
B. Global Consistency Checking
We obtain the set of local indeterminate paths in the local
twin plant for the faulty component. However, up to now, its
communication with the neighborhood in the whole system is
not yet taken into account. Recall that if a local indeterminate
pair can be extended into a global indeterminate pair, its
corresponding local indeterminate path is said to be globally
292
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

L:C1
O5
O3
L:C2
O5
Y0
Y0
Y3
Y0
Y2
Y1
Y2
Y2
Y4
Y4
Y2
Y4
O4
R:C2
Fig. 6: Part of local twin checker for G2 of the system in Figure 1.
consistent. In other words, joint diagnosability veriﬁcation
consists in checking the existence of globally consistent local
indeterminate paths, whose existence proves non joint diag-
nosability. To check the global consistency, we consider now
two important issues:
•
the global consistency of the corresponding left trajec-
tories of the local indeterminate paths in the local twin
plant, shortly called left consistency checking in the
following;
•
the global consistency of the corresponding right trajec-
tories of the local indeterminate paths in the local twin
plant, shortly called right consistency checking.
Now we deﬁne another structure called local twin checker
for a normal component, which is used to be synchronized
with local twin plant for checking the global consistency.
With similar idea as local twin plant, local twin checker is to
obtain all pairs of local trajectories with the same observations,
which has no fault information since it is deﬁned for a normal
component. Given a normal component, we ﬁrst perform delay
closure to keep only observable events and communication
events. Then the left instance of the component is obtained
by adding the preﬁx of L to non-synchronized events, i.e.,
communication events, and the right instance is acquired by
adding the preﬁx of R to communication events, denoted by
Gl
i and Gr
i , respectively.
Deﬁnition 8: (Local twin checker). Given a normal compo-
nent Gi, its local twin checker is the FSM Ci = Gl
i∥Gr
i .
Figure 6 shows a part of the local twin checker for the
component G2 of the system depicted in Figure 1, where
there is no fault information. To check left consistency and
right consistency of local indeterminate paths, we deﬁne two
consistent structures as follows.
Deﬁnition 9: (Left (Right) consistent plant). Given a sub-
system GS composed of Gi1, ..., Gim, including the faulty
component, and their corresponding local twin plant and local
twin checkers, to obtain a left (right) consistent plant with
respect to the subsystem GS, denoted by T l
f (T r
f ), we perform
the following two steps:
•
Distinguish right (left) communication events between
local twin plant and local twin checkers by renaming
them with the preﬁx of component ID. For example,
R:C2 (L:C2) in the local twin checker of G2 is renamed
as G2:R:C2 (G2:L:C2).
•
Note that observable events do not intersect between
components and non-synchronized right (left) commu-
nication events are distinguished by the preﬁx of com-
ponent ID. Now the renamed local twin plant and local
twin checkers are synchronized, where the synchro-
X0 N
X0 N
X0
O1
G1:R:C1
L:C2
G1:R:C2
L:C1
O2
O1
O1
L:C1
O5
G2:R:C2
O4
O3
L:C2
O5
X0 Y0
L:C1
O1
O3
G1:R:C2
L:C2
O4
O2
G1:R:C1
G1:R:C2
G2:R:C2
O5
O1, O5
X0 N
X1 N
X1
X4 N
X5 N
X2
X2 N
X5 N
X4
X2 N
X3 N
X5
X3 F
X3 N
X6
X1 N
X0 N
X3
Y0
Y0
Y0
Y3
Y0
Y1
Y2
Y1
Y2
Y2
Y2
Y5
Y4
Y4
Y3
Y2
Y4
Y4
X3 Y1
X4 Y1
X4 Y2
X5 Y2
X5 Y5
X6 Y5
X1 Y0
X2 Y0
X2 Y3
X4 Y4
X5 Y4
O5
O1
Fig. 7: Part of the renamed local twin plant for G1 (top), part of
renamed local twin checker for G2 (middle) and part of the left
consistent plant T l
f (bottom).
nized events are the common left (right) communication
events.
In the left (right) consistent plant with respect to a subsystem
GS, each path p corresponds to a set of paths pi1, ..., pim in
the local twin plant and local twin checkers of all components
in GS such that the set of left (right) trajectories of pi1, ..., pim
are reconstructible with respect to GS. Given a state in a left
or right consistent plant, if it contains an ambiguous state in
the local twin plant for the faulty component, then this plant
state is also called an ambiguous state. For our example, the
bottom part of Figure 7 shows a part of the left consistent
plant T l
f, which is obtained by synchronizing the renamed local
twin plant of G1 and the renamed local twin checker of G2
(top and middle parts of Figure 7) based on the common left
communication events. In the bottom part of this ﬁgure, the
gray node (X6Y 5) is an ambiguous state of the plant since
it contains the local twin plant state X6 that is an ambiguous
one.
C. Algorithm
Algorithm 1 presents the procedure to verify a sufﬁcient
condition of joint diagnosability. As shown in the pseudo-
code, algorithm 1 performs as follows. Given the set of
component models as well as the fault F that may occur
in the component GF as input, we initialize the parameters
as empty, i.e., Gl
checking and Gr S, the subsystem for the left consistency
S, the subsystem for the right consistency
checking. The procedure of the algorithm can be separated
into two parts: left consistency checking and right consistency
checking.
293
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Algorithm 1 Algorithm to check a sufﬁcient condition of joint
diagnosability
1: INPUT: the system model G = (G1, ..., Gn); the fault F
and the faulty component GF
2: Initializations: Gl
S ← ∅ (subsystem for left consistency
checking); Gr
S ← ∅ (subsystem for right consistency
checking)
3: T l
f ← ConstructLTP(GF )
4: Gl
S ← GF
5: while T l
f ̸= ∅ and DirectCC(G, Gl
S) ̸= ∅ do
6:
Gi ← SelectDirectCC(G, Gl
S)
7:
Ci ← ConstructLTC(Gi)
8:
T l
f ← T l
f∥Ci
9:
Gl
S ← Add(Gl
S, Gi)
10:
T l
f ← RetainConsisPaths(T l
f)
11: end while
12: if T l
f = ∅ then
13:
return ”F is jointly diagnosable in G”
14: else
15:
T r
f ← AbstractRight(GF , T l
f)
16:
Gr
S ← GF
17:
while T r
f ̸= ∅ and Gl
S ̸= Gr
S do
18:
Gi ← SelectDirectCC(Gl
S, Gr
S)
19:
T r
f ← T r
f ∥AbstractRight(Gi, T l
f)
20:
Gr
S ← Add(Gr
S, Gi)
21:
T r
f ← RetainConsisPaths(T r
f )
22:
end while
23:
if T r
f = ∅ then
24:
return ”F is jointly diagnosable in G”
25:
else
26:
return ”Joint diagnosability cannot be determined”
27:
end if
28: end if
•
Left consistency checking begins with the local twin
plant construction of GF , the subsystem Gl
S being now
GF (line 3-4). As long as both the left consistent
plant T l
f with respect to the current left subsystem
Gl
S and DirectCC(G, Gl
S) are not empty (line 5),
where DirectCC(G, Gl
S) is the set of directly con-
nected components to the subsystem Gl
S (a directly
connected component being one sharing at least one
common communication event with the subsystem) the
algorithm repeatedly performs the following steps to
further check left consistency in an extended subsystem:
1)
Select one directly connected component Gi to the
subsystem Gl
S and construct its local twin checker
Ci (line 6-7).
2)
Synchronize T l
f with Ci to obtain left consistent
plant for this extended subsystem based on the
set of common left communication events (line
8). To do so, the set of non-synchronized right
communication events are distinguished by the
preﬁx of component ID.
3)
Update the subsystem Gl
S by adding Gi and
reduce the newly obtained T l
f by retaining only
paths with ambiguous state cycles containing ob-
servable events for all components in Gl
S, which
are called consistent paths with respect to Gl
S (line
9-10).
If the left consistent plant T l
f is empty, then there
is no local indeterminate path that corresponds to a
set of paths in the local twin plant and local twin
checkers of all components in the subsystem such that
their corresponding left trajectories are reconstructible.
This follows that there is no globally consistent local
indeterminate path. In this case, joint diagnosability
information is returned (line 12-13). Otherwise, if T l
f
is not empty (line 14), then we proceed to check right
consistency of the corresponding paths in T l
f that have
already been veriﬁed to be left consistent in the whole
system.
•
Right consistency checking begins with the function
AbstractRight(GF , T l
f) (line 15), which performs de-
lay closure with respect to the set of right communica-
tion events and observable events of GF . In this way,
what we obtain does not contain left communication
events, which are useless for right consistency checking.
Then the subsystem Gr
S is assigned as GF (line 16). As
long as the right consistent plant T r
f for the current right
subsystem Gr
S is not empty and Gl
S ̸= Gr
S (line 17), we
repeatedly perform the following steps to check right
consistency in an extended subsystem (note that since
left consistency checking does explore all connected
components, during right consistency checking, we only
need to consider the subsystem Gl
S instead of the whole
system):
1)
Select a directly connected component Gi to Gr
S
from Gl
S (line 18).
2)
Perform the function AbstractRight(Gi, T l
f),
which has already been described above, and
then synchronize with T r
f based on the set of
common right communication events (line 19).
To do this, we rename the right communication
events by removing the preﬁx of component ID,
e.g., Gi:R:C2 renamed as R:C2.
3)
Update the subsystem Gr
S by adding Gi and
reduce the newly obtained T r
f by retaining only
paths with ambiguous state cycles containing ob-
servable events for all components in Gr
S, i.e.,
consistent paths (line 20-21).
If the right consistent plant T r
f is empty, then there is
no local indeterminate path that corresponds to a set of
paths in the local twin plant and local twin checkers
such that their left trajectories and right trajectories
are reconstructible respectively, i.e., there is no glob-
ally consistent local indeterminate path. In this case,
the algorithm returns joint diagnosability information
(line 23-24). Otherwise, if T r
f is not empty, we cannot
determine whether the fault is jointly diagnosable or
not. Then the algorithm returns the information about
294
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

X0 Y0
X0 Y0
R:C2
O1
O1
X0 Y0
O1
G1:R:C2
O2
G1:R:C1
G1:R:C2
O1
X4 Y1
X5 Y2
X6 Y5
X1 Y0
X2 Y0
X5 Y4
X0 Y0
O3
O5
O4
G2:R:C2
O5
X4 Y2
X5 Y5
X2 Y3
X4 Y1
X0 Y0
X4 Y1
X2 Y3
O4
X5 Y2
X5 Y5
O5
X6 Y5
X5 Y5
O1
O1, O5
O1
Fig. 8: FSM after delay closure on the left consistent plant (Figure 7)
for G1 (top left) and for G2 (top right) and part of the right consistent
plant (bottom).
the indetermination of joint diagnosability (line 25-
26). In other words, empty left consistent plant T l
f or
empty right consistent plant T r
f is a sufﬁcient but not a
necessary condition of joint diagnosability.
Theorem 3: In algorithm 1, if the left consistent plant T l
f or
the right consistent plant T r
f is empty, then the fault is jointly
diagnosable, but the reverse is not true.
Proof:
(⇒) Suppose that T l
f or T r
f is empty and that the fault is not
jointly diagnosable. From non joint diagnosability, it follows
that there exists at least one globally consistent local indeter-
minate path. Since global consistency of a local indeterminate
path implies both left consistency and right consistency, from
algorithm 1, we know that, after left and right consistency
checking, this local indeterminate path must correspond to a
path both in T l
f and in T r
f . Thus, neither T l
f nor T r
f is empty,
which contradicts the assumption.
(⇍) Now we explain why if both T l
f and T r
f are not empty,
it does not necessarily imply that the fault is not jointly
diagnosable. Suppose that the left consistent plant T l
f is not
empty and that it contains two paths, denoted by ρ1 and ρ2,
corresponding to two local indeterminate paths. ρ1 corresponds
to a set of paths ρ1
i , 1 ≤ i ≤ n in the local twin plant and
local twin checkers of all components and ρ2 corresponds
to a set of paths ρ2
i , 1 ≤ i ≤ n. Note that since the two
sets of paths come from left consistent plant, then it is only
guaranteed that the corresponding left trajectories of each set
are reconstructible. Now suppose that the right trajectories of
the set of paths ρ1
i , 1 ≤ i ≤ n are not reconstructible and the
same for that of the set of paths ρ2
i , 1 ≤ i ≤ n. It follows
that the two local indeterminate paths cannot be extended into
global indeterminate pairs and thus are not globally consistent.
Then we further suppose that the right trajectories of the set
of paths ρ1
1, ..., ρ1
n−1, ρ2
n are reconstructible and the same for
the set of paths ρ2
1, ..., ρ2
n−1, ρ1
n. From algorithm 1, it follows
that ﬁnally the right consistent plant T r
f is not empty. In this
case, both T l
f and T r
f are not empty but there is no globally
consistent local indeterminate paths, i.e., the fault is jointly
diagnosable.
Now illustrate on our example that this condition is not
necessary. The top parts of Figure 8 show the results of
performing delay closure with respect to the set of right
communication events and locally observable events both
for G1 and G2 on the left consistent plant depicted in the
bottom part of Figure 7. Then, to check right consistency, we
rename again the right communication events by removing the
component ID such that they can be synchronized. Finally, the
bottom part of Figure 8 shows a part of the right consistent
plant, which is not empty. Now both left and right consistent
plants are not empty, but this does not imply the existence of
global indeterminate pairs that witness non joint diagnosability.
Actually, the part of the left consistent plant depicted here
corresponds to two local indeterminate pairs in G1 with
their corresponding left consistent pairs in G2, i.e., one local
indeterminate pair is ((C1.O1.F.O1∗), (O1.C2.O1∗)) in G1
with its left consistent pair ((C1.O3.O5∗), (O3.U2.O5∗))
in
G2
and
the
other
local
indeterminate
pair
is
((O2.U1.C2.F.O1∗), (C1.O2.C2.O1∗))
in
G1
with
its
left
consistent
pair
((O4.C2.O5∗), (O4.C2.O5∗))
in
G2.
While
the
right
consistent
plant
shown
here
corresponds to one local indeterminate pair in G1, which is
((C1.O1.F.O1∗), (O1.C2.O1∗)), with its corresponding right
consistent pair in G2, i.e., ((O4.C2.O5∗), (O4.C2.O5∗)).
Thus we can see that the same local indeterminate pair,
i.e., ((C1.O1.F.O1∗), (O1.C2.O1∗)) does not correspond to
the same consistent pair in G2 in the left consistent plant
and in the right consistent plant, which means that this
local indeterminate pair cannot be extended into a global
indeterminate pair. In fact, our algorithm gives indeterminate
information for joint diagnosable systems that satisfy the
following condition: for any set of paths, i.e., one path
in the local twin checker of each component and one
in the local twin plant for faulty component being a local
indeterminate path, that are left consistent and right consistent,
respectively, and their corresponding local trajectories in the
components cannot constitute an indeterminate pair through
synchronization.
Theorem 4: Algorithm 1 has polynomial complexity with
the number of system states, exponential complexity with the
number of faults and exponential complexity with the number
of components.
Proof: From their construction, for a component Gi, the
maximum number of states and transitions of the local diag-
noser are (|Qi|×2|Σif |) and (|Qi|2×22|Σif |×(|Σio|+|Σic|)),
respectively, where |Qi| is the number of the component states,
|Σif | is the number of faults in Gi and |Σio| (|Σic|) is
the number of observable events (communication events) in
Gi. The maximum number of states and transitions of its
local twin plant (local twin checker) are (|Qi|2 × 22|Σif |)
and (|Qi|4 × 24|Σif | × (|Σio| + |Σic|)), respectively. In the
worst case, the global consistency checking (both left and
right ones) consists in synchronizing local twin plant and
local twin checkers of all components. Thus, we can conclude
that Algorithm 1 has polynomial complexity with the number
of system states, exponential complexity with the number
of faults and exponential complexity with the number of
components.
Note that the exponential complexity with the number of faults
is for the case where we handle all faults in one component
simultaneously. To reduce the complexity, our algorithm is
illustrated by dealing with one fault each time.
295
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

D. Relaxation of Assumption
In our approach, we have the assumption that all communi-
cation events are unobservable, which is a more difﬁcult case
than that where communication events are observable. Now we
relax this assumption by dividing the set of communication
events into two disjoint parts: Σio
c, the set of observable
communication events and Σiu
c , the set of unobservable com-
munication events. In other words, communication events may
be observable or unobservable. Algorithm 1 can be reused for
this relaxed case after the following modiﬁcations.
•
For the local component GF , we construct its local diag-
noser by preserving the information about all observable
events as well as all communication events, including
observable and unobservable ones, and then append to
each retained state with fault information, which is the
same as that described in Section V-A.
•
In this local diagnoser, for each unobservable commu-
nication event, we distinguish it between two instances
by adding the preﬁx of L (for left instance, σ being
L : σ) and R (for right instance, σ being R : σ).
Then we reduce the instances as described before and
construct local twin plant by synchronizing the two
reduced instances based on the set of observable events
and the set of observable communication events.
•
For other connected normal components, we construct
their local twin checker in the same way except that the
preﬁxes should be added only to unobservable commu-
nication events in the left and right instances such that
the two instances are synchronized based on the set of
observable events and observable communication events.
•
During left (right) consistent plant construction, unob-
servable right (left) communication events are distin-
guished between the local twin plant and local twin
checkers by the preﬁx of component ID. Then the
renamed local twin plant and local twin checkers are
synchronized based on unobservable left (right) commu-
nication events and observable communication events.
VI.
DECIDABLE CASE
We have proved the undecidability of joint diagnosability
when communication events are unobservable. If we assume
their observability, then this problem becomes decidable. The
reason is that, when all communication events are observable,
in the local twin plant and local twin checkers of all compo-
nents, we obtain all pairs of local trajectories with the same
observations, including the same observable communication
events. In other words, each path in the local twin plant
or local twin checkers corresponds to a pair of local trajec-
tories with the same sequence of communication events. It
follows that to check global consistency of local indeterminate
paths, the two separate phases for left and right consistency
checking becomes only one phase. While in Algorithm 1, the
consistency checking separated into two different phases is
the reason why it gives only a sufﬁcient but not necessary
condition for joint diagnosability. Actually, the observability
of communication events makes joint diagnosability equivalent
to classical diagnosability since only one phase of global
consistency checking implies the same global occurrence order
of observations for global indeterminate pairs.
Algorithm 2 presents the procedure to check joint diag-
nosability when communication events are assumed to be
observable. Taking the system model and the fault occurring in
the faulty component as input, the parameter, i.e., the current
subsystem GS, is initialized as empty. Then the algorithm
begins with the construction of the local twin plant of the
faulty component GF , the current subsystem becoming GF
(line 3-4). Here we emphasize that, due to the observability
of communication events, the local twin plant should be
constructed by synchronizing two reduced instances based on
the set of observable events and the set of communication
events, i.e., here communication events do not need to be
distinguished by adding preﬁxes. As long as both current local
twin plant Tf and DirectCC(G, GS) are not empty (line 5),
the following steps are repeatedly performed:
•
Select one component Gi directly connected to the
current subsystem GS and then construct its local twin
checker Ci, which is obtained by ﬁrst operating delay
closure with respect to the set of communication events
and observable events and then by synchronizing the two
instances based on all events, i.e., the set of communi-
cation events and observable events. (line 6-7)
•
Synchronize the current local twin plant Tf and Ci based
on the common communication events of GS and Gi,
where the newly synchronized FSM is also called the
local twin plant for the extended subsystem. (line 8)
•
Update the current subsystem by adding this selected
component and keep only the paths in the newly ob-
tained FSM that contain ambiguous state cycles with
observations for all involved components. (line 9-10)
During this procedure, if the local twin plant Tf for the
current subsystem happens to be empty, which means that
there is no path that contains ambiguous state cycle with
observations for all concerned components. In this case, there
is no local indeterminate path that is globally consistent and
the algorithm returns joint diagnosability information (line 12-
13). Otherwise, if at the end the ﬁnal FSM is not empty,
it is returned by the algorithm as non joint diagnosability
information (line 14-15), where any path in it corresponds to a
globally consistent local indeterminate path. The reason is that
if the communication events are observable, then any path in
the local twin plant or a local twin checker corresponds to a
pair of local trajectories with the same observations, including
the same communication events. So with the assumption of
observability of communication events, joint diagnosability
checking becomes decidable.
VII.
COMPARISON AND DISCUSSION
In this section, we compare joint diagnosability for self-
observed distributed systems with classical diagnosability for
distributed systems where observable events can be globally
observed. In other words, in the latter one, diagnosability
analysis requires the global occurrence order of observable
events, which is not the case for the former one. Before this
296
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Algorithm 2 Algorithm for checking joint diagnosability with
observable communication events
1: INPUT:
the system model G = (G1, ..., Gn);
the fault F and the faulty component GF
2: Initializations:
GS ← ∅ (subsystem considered for current checking)
3: Tf ← ConstructLTP(GF )
4: GS ← GF
5: while Tf ̸= ∅ and DirectCC(G, GS) ̸= ∅ do
6:
Gi ← SelectDirectCC(G, GS)
7:
Ci ← ConstructLTC(Gi)
8:
Tf ← Tf∥Ci
9:
GS ← Add(GS, Gi)
10:
Tf ← RetainConsisPaths(Tf)
11: end while
12: if Tf = ∅ then
13:
return ”F is jointly diagnosable in G”
14: else
15:
return Tf
16: end if
comparison, we brieﬂy recall classical diagnosability deﬁnition
as follows [20].
Deﬁnition 10: (Diagnosability). A fault F is diagnosable in
a system G iff
∀sF ∈ L(G), ∃k ∈ N, ∀t ∈ L(G)/sF , |t| ≥ k ⇒
(∀p ∈ L(G), P(p) = P(sF .t) ⇒ F ∈ p).
The above deﬁnition states that if F is diagnosable, then for
each trajectory ending with the fault sF in G, for each t that is
an extension of sF in G with sufﬁcient events, every trajectory
p in G that is observation equivalent to sF .t should contain in it
F. Informally speaking, the existence of two indistinguishable
behaviors, i.e., holding the same enough observations with
exactly one of them containing the given fault F, violates di-
agnosability property. The diagnosability analysis approaches
check the existence of such indistinguishable behaviors. With
similar idea to indeterminate pairs for joint diagnosability, we
call a pair of trajectories p and p′ satisfying the following
conditions as a critical pair:
•
p contains F and p′ does not;
•
p has arbitrarily long observations after the occurrence
of F;
•
P(p) = P(p′).
The existence of critical pairs violates Deﬁnition 10 and thus
witnesses non-diagnosability.
We can prove that joint diagnosability is stronger than
diagnosability for systems with global observations.
Lemma 3: Given two systems G composed of G1, ...Gn and
G′ composed of G′
1, ...G′
n such that for each i ∈ {1, ..., n},
components Gi and G′
i have the same structure except that all
observable events in the component Gi can only be observed
by Gi while each observable event in the component G′
i can
be observed by all components of G′. In other words, G is a
self-observed distributed system and G′ is the one with global
observations. Then we have the following result: if the fault
O3
Y1
Y0
Y2
C2
Y4
Y3
O3
C1
O4
U1
C1
X1
X0
X2
O1
X3
O2
O1
X4
F
C2
Fig. 9: A simple system model with two components: G1(left) and
G2(right).
F is jointly diagnosable in G, then it is diagnosable in G′.
Proof:
Suppose that the fault F is jointly diagnosable in G and that F
is not diagnosable in G′. From the non diagnosability of F in
G′ and G′ is a system with global observations, we know that
there exists at least one global critical pair of trajectories p1′
and p2′ in G′, i.e., p1′ and p2′ satisfying three conditions: 1)
only one of them contains F, suppose p1′; 2) p1′ has enough
observations after the occurrence of F in all components; 3)
P(p1′) = P(p2′), the projection of p1′ to observable events of
G′ is the same as that of p2′, which means that they have the
same observations from a global point of view. Now in the self-
observed system G, let p1 and p2 denote the corresponding
trajectories of p1′ and p2′. If we do not consider the difference
that each observable event in p1 and p2 can only be observed
by its own component while each observable event in p1′ and
p2′ can be observed by all components, then we have p1 = p1′
and p2 = p2′. It follows that the fault F is contained in p1 but
not in p2 and after the occurrence of F, p1 has enough local
observations in each component. Furthermore, note that p1 and
p2 have the same observations, then from the fact that there is
no intersection of observable events between components, we
can deduce that ∀k ∈ {1, ..., n}, Pk(p1) = Pk(p2). Clearly,
p1 and p2 are an indeterminate pair and thus F is not jointly
diagnosable in G, which contradicts the assumption that F is
jointly diagnosable in G.
If the fault F is diagnosable in G′, it is not necessarily
jointly diagnosable in G. Actually, if F is diagnosable in G′,
this means that there is no critical pair in G′. However, this
does not imply that there is no indeterminate pair in G. Sup-
pose that there is an indeterminate pair p1 and p2 in G with p1
containing the fault. Then we have ∀k ∈ {1, ..., n}, Pk(p1) =
Pk(p2). Now in the system with global observations G′, let
p1′ and p2′ denote the corresponding trajectories of p1 and
p2. Then we have ∀k ∈ {1, ..., n}, Pk(p1′) = Pk(p2′). This
does not mean that we can get P(p1′) = P(p2′), which is
however one condition of a critical pair. So there does not
necessarily exist a critical pair in G′. In other words, if two
trajectories in G have the same enough local observations in
all components, their corresponding trajectories in G′ may
have different observations from global point of view. Thus
the existence of indeterminate pairs in G does not imply the
existence of critical pairs in G′.
Figure 9 shows a very simple system with two components,
G1 (left) and G2 (right). Suppose that it is a distributed
system with global observations. Intuitively, we can see that
for any faulty trajectory, the occurrence of observable event
O1 is before the occurrence of observable event O3. While
297
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

for any normal trajectory, the occurrence of O3 is before
that of O1. In other words, there is no critical pair and
thus the fault is diagnosable in this system. Now suppose
that this system is a self-observed distributed system, i.e.,
the observable events can only be observed by their own
component. It is easy to ﬁnd an indeterminate pair. Consider
the pair of trajectories ρ = (O3, C1, O1, (O2, O4, U1)∗) and
ρ′ = (O1, F, C2, O3, (O2, O4, U1)∗). Only ρ′ is a faulty
trajectory and both of them have the same sufﬁcient obser-
vations for each component. Thus the fault is not jointly
diagnosable. Here we can see that the global occurrence order
of observable events makes the fault F diagnosable. While
since joint diagnosability does not require global occurrence
order of observations, so the fault is not jointly diagnosable.
VIII.
CONCLUSION
In this paper, we consider self-observed distributed systems
where observable events can only be observed by their own
components. Clearly, the monolithic model of the system is
not required, thus the distributed and private (w.r.t. observa-
tion) nature of real systems is taken into account. Then we
prove the undecidability of checking joint diagnosability when
communication events are unobservable, before proposing an
algorithm to test a sufﬁcient condition. To check whether there
exist indeterminate pairs in the system, we start from local
indeterminate paths in the local twin plant and then we check
both in sequence left consistency and right consistency. Note
that, due to the observation-privacy, the global occurrence
order of observable events between different components is
not known, which is taken into account through constructing
left and right consistent plants separately. At the opposite,
in the approaches for DES with globally observable events,
twin plant is constructed by incrementally synchronizing local
twin plants via both left and right communication events at
the same time, which means that in their case, knowledge
of the global occurrence order is required. Similar to the
distributed algorithms for classical diagnosability ([23], [25],
[29], etc.), our algorithm has to construct some part of a global
structure, but much less than that in the centralized approach
(in particular the components not involved in the algorithm
have their model completely not disclosed) and this is normally
unavoidable for off-line diagnosability analysis. Afterwards,
we adapt this sufﬁcient algorithm for a more relaxed case, i.e.,
communication events could be unobservable and observable.
Then we discuss the decidable case where communication
events are observable by giving a formal algorithm to check
joint diagnosability. However, the decidable case in [26] is
not the same as that in this paper. The former also deals with
unobservable communication events, which becomes decidable
because of the assumption of exhaustive enumeration about
local paths. While here the decidable case is thanks for the
observability of communication events. Finally, we prove that
joint diagnosability of self-observed systems is stronger than
classical diagnosability of globally observed systems with
an illustrated example. We see that there is a gap between
the decidable and undecidable cases. Next interesting work
is to investigate where is the frontier between these two
cases, i.e., to study the decidability of joint diagnosability
for partial observability of communication events. Another
future work is to study the extension of our approach to deal
with predictability [30], i.e., the property of the system to be
able to predict the fault with certainty before its occurrence
considering that in some critical cases, it is very expensive to
recover the system after fault occurrence.
ACKNOWLEDGMENT
This work has been supported by the STIC-AmSud DATE
project, which is funded by the regional program STIC-AmSud
(No.13STIC-04).
REFERENCES
[1]
L. Ye and P. Dague, Diagnosability analysis for self-observed distributed
discrete event systems, Proceedings of the 4th International Conference
on Advances in System Testing and Validation Lifecycle (VALID-12),
2012, pp. 93-98.
[2]
S. Tripakis, Undecidable problems of decentralized observation and
control on regular languages, Information Processing Letters, vol. 9,
no. 1, 2004, pp. 21-28.
[3]
L. Ye and P. Dague, New results for joint diagnosability of self-observed
distributed discrete event systems, Proceedings of the 23rd International
Workshop on Principles of Diagnosis (DX-12), 2012.
[4]
M. Bayoudh, L. Trav´e-Massuy`es, and X. Olive, Hybrid systems diag-
nosability by abstracting faulty continuous dynamics, Proceedings of the
17th International Workshop on Principles of Diagnosis (DX-06), Burgos,
Spain, 2006.
[5]
M. Bayoudh, L. Trav´e-Massuy`es, and X. Olive, Coupling continuous
and discrete event system techniques for hybrid system diagnosability
analysis, Proceedings of the 18th European Conference on Artiﬁcial
Intelligence (ECAI-08), Patras, Greece, 2008, pp. 219-223.
[6]
M.-O. Cordier, L. Trav´e-Massuy`es, and X. Pucel, Comparing diagnos-
ability in continuous and discrete-event systems, Proceedings of the
17th International Workshop on Principles of Diagnosis (DX-06), 2006,
pp. 55-60.
[7]
M. Daigle, X. Koutsoukos, and G. Biswas, An event-based approach
to hybrid systems diagnosability, Proceedings of the 19th International
Workshop on Principles of Diagnosis (DX-08), Blue Mountains, Aus-
tralia, 2008.
[8]
E. Fabre, A. Benveniste, C. Jard, L. Ricker, and M. Smith, Distributed
state reconstruction for discrete event systems, proceedings of the
38th IEEE Control and Decision Conference (CDC-00), Sydney, 2000,
pp. 2252-2257.
[9]
R. Debouk, S. Lafortune, and D. Teneketzis, Coordinated decentralized
protocols for failure diagnosis of discrete event systems, Journal of
Discrete Event Dynamical Systems: Theory and Application 10 (1-2),
2000, pp. 33-86.
[10]
R. Debouk, R. Malik, and B. Brandin, A modular architecture for
diagnosis of discrete event systems, Proceedings of the 41st IEEE
Conference on Decision and Control (CDC-02), Las Vegas, NV, USA,
2002, pp. 417-422.
[11]
A. Grastien, J. R. Anbulagan, and E. Kelareva, Diagnosis of discrete-
event systems using satisﬁability algorithms, Proceedings of the 22th
American National Conference on Artiﬁcial Intelligence (AAAI-07),
2007, pp. 305-310.
[12]
S. Haar, A. Benveniste, E. Fabre, and C. Jard, Partial order diagnosabil-
ity of discrete event systems using petri nets unfoldings, Proceedings of
the 42nd IEEE Conference on Decision and Control (CDC-03), Hawaii,
USA, 2003, pp. 3748-3753.
[13]
S. Bavishi and E. Chong, Automated fault diagnosis using a discrete
event systems framework, Proceedings of the 9th IEEE International
Symposium on Intelligent Control, 1994 pp. 213-218.
298
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[14]
A. Benveniste, E. Fabre, S. Haar, and C. Jard, Diagnosis of asyn-
chronous discrete event systems, a net unfolding approach, IEEE Trans-
actions on Automatic Control, 48(5), 2003 pp. 714-727.
[15]
C. G. Cassandras and S. Lafortune, Introduction To Discrete Event
Systems, Second Edition. Springer, New York, 2008.
[16]
R. Cieslak, C. Desclaux, A. Fawaz, and P. Varaiya, Supervisory control
of discrete-event processes with partial observations, IEEE Transactions
on Automatic Control, 33(3), 1988, pp. 249-260.
[17]
O. Contant, S. Lafortune, and D. Teneketzis, Diagnosis of modular
discrete event systems, Proceedings of the 7th International Workshop
on Discrete Event Systems (WODES-04), Reims, France, 2004.
[18]
O. Contant, S. Lafortune, and D. Teneketzis, Failure diagnosis of
discrete event systems: The case of intermittent faults, Proceedings of
the 41st IEEE Conference on Decision and Control (CDC-02), 2002,
pp. 4006-4011.
[19]
E. Fabre, A. Benveniste, and C. Jard, Distributed diagnosis for large
discrete event dynamic systems, Proceedings of the IFAC world congress,
2002, pp. 237-256.
[20]
M. Sampath, R. Sengupta, S. Lafortune, K. Sinnamohideen, and D.
Teneketzis, Diagnosability of discrete event system, IEEE Transactions
on Automatic Control, 40(9), 1995, pp. 1555-1575.
[21]
S. Jiang, Z. Huang, V. Chandra, and R. Kumar, A polynomial time
algorithm for testing diagnosability of discrete event systems, IEEE
Transactions on Automatic Control 46(8), 2001, pp. 1318-1321.
[22]
A. Cimatti, C. Pecheur, and R. Cavada, Formal veriﬁcation of diagnos-
ability via symbolic model checking, Proceedings of the 18th International
Joint Conference on Artiﬁcial Intelligence (IJCAI-03), 2003, pp. 363-
369.
[23]
Y. Pencol´e, Diagnosability analysis of distributed discrete event systems,
Proceedings of the 16th European Conference on Articiﬁal Intelligent
(ECAI04), 2004, pp. 43-47.
[24]
Y. Pencol´e, Assistance for the design of a diagnosable component-based
system, Proceedings of the 17th IEEE International Conference on Tools
with Artiﬁcial Intelligence (ICTAI05), 2005, pp. 549-556.
[25]
A. Schumann and Y. Pencol´e, Scalable diagnosability checking of
event-driven systems, 20th International Joint Conference on Artiﬁcial
Intelligence (IJCAI-07), 2007, pp. 575-580.
[26]
L. Ye and P. Dague, Diagnosability analysis of discrete event systems
with autonomous components, Proceedings of the 19th European Con-
ference on Artiﬁcial Intelligence (ECAI-10), 2010, pp. 105-110.
[27]
R. Cori and Y. M´etivier, Recognizable subsets of some partially abelian
monoids, Theoretical Computer Science, vol. 35, 1985, pp. 179-189.
[28]
V. Halava and T. Harju, Undecidability of inﬁnite post correspondence
problem for instances of Size 9, Theoretical Informatics and Applications
- ITA, vol. 40, no. 4, 2006, pp. 551-557.
[29]
A. Schumann and J. Huang, A scalable jointree algorithm for di-
agnosability, Proceedings of the 23rd AAAI Conference on Artiﬁcial
Intelligence (AAAI-08), 2008, pp. 535-540
[30]
L. Ye, P. Dague, and F. Nouioua, Predictability analysis of distributed
discrete event systems, Proceedings of the 52nd IEEE Conference on
Decision and Control (CDC-13), 2013, pp. 5009-5015.
299
International Journal on Advances in Systems and Measurements, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/systems_and_measurements/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

