Behind the Skyline
Markus Endres
University of Augsburg
Augsburg, Germany
Email: markus.endres@acm.org
Timotheus Preisinger
DEVnet Holding GmbH
Gr¨unwald, Germany
Email: t.preisinger@devnet.de
Abstract—A Skyline query selects those tuples from a dataset
that are optimal with respect to a set of designated preference
attributes. However, in some cases, not only the Pareto frontier
is of interest, but also the stratum behind the Skyline. In this
paper, we extend the deﬁnition of the Skyline to form multi-level
Skyline sets. We propose an algorithm for multi-level Skyline
computation and apply this concept for efﬁcient top-k Skyline
evaluation. Given a dataset, a top-k Skyline query returns the k
most interesting elements of the Skyline query based on some kind
of user-deﬁned preference. We demonstrate through extensive
experimentation on synthetic and real datasets that our algorithm
can result in a signiﬁcant performance advantage over existing
techniques.
Keywords–Skyline; Preferences; Multi-level; Top-k.
I.
INTRODUCTION
The Skyline operator [1] has emerged as an important
and popular technique for searching the best objects in multi-
dimensional datasets. A Skyline query selects those objects
from a dataset D that are not dominated by any others. An
object p having d attributes (dimensions) dominates an object
q, if p is strictly better than q in at least one dimension and not
worse than q in all other dimensions, for a deﬁned comparison
function. Without loss of generality, we consider subsets of Rd
in which we search for Skylines w.r.t. the natural order ≤ in
each dimension.
The most cited example on Skyline queries is the search
for a hotel that is cheap and close to the beach. Unfortunately,
these two goals are conﬂicting as the hotels near the beach tend
to be more expensive. In Figure 1, each hotel is represented
as a point in the two-dimensional space of price and distance
to the beach. Interesting are all hotels that are not worse than
any other hotel in both dimensions. The hotels p6, p7, p9, p10
are dominated by hotel p3. The hotel p8 is dominated by p4,
while the hotels p1, p2, p3, p4, p5 are not dominated by any
other hotels and build the Skyline S. From the Skyline, one
can now make the ﬁnal decision, thereby weighing the personal
preferences for price and distance.
Unfortunately, the size of the Skyline S can be very small
(e.g., in low-dimensional spaces). Hence, a user might want to
see the next best objects behind the Skyline. In our example
above maybe ﬁve hotels are not enough, so we have to present
the next stratum called S1
ml (Skyline, multi-level 1, dashed line
in Figure 1): p6, p7, p8. Also, the third best result set S2
ml might
be of interest: p9, p10.
Distance to the beach [km]
Price [Euro]
50
100
150
200
0.0
0.5
1.0
1.5
2.0
p5
p4
p3
p2
p1
p7
p6
p8
p9
p10
S0
ml
S1
ml
S2
ml
Figure 1. Skyline example.
Furthermore, in the presence of high-dimensional Skyline
spaces, the size of the Skyline S can still be very large,
making it unfeasible for users to process this set of objects
[2]. Hence, a user might want to see the top-k objects. That
means a maximum of k objects out of the complete Skyline
set if |S| >= k, or for |S| < k to use the Skyline set plus
the next best objects such that there will be k results. In the
previous example a top-3 Skyline query would identify, e.g.,
p1, p2, and p3, whereas in a top-10 query it is necessary to
consider the second and third stratum to identify p6, p7, p8, p9,
and p10 as additional Skyline points.
In this work we generalize the well-known Skyline queries
to multi-level Skylines Sml. We present an efﬁcient algorithm
to compute the l-th stratum of a Skyline query exploiting
the lattice structure constructed over low-cardinality domains.
Following [2] many Skyline applications involve domains with
small cardinalities – these cardinalities are either inherently
small (such as star ratings for hotels), or can naturally be
mapped to low-cardinality domains (such as price ranges on
hotels). In addition, we propose an evaluation strategy for top-k
Skyline queries, which is based on the multi-level approach. To
our best knowledge, until now there are no efﬁcient algorithms
that are specialized on ﬁnding multi-level Skyline sets or top-k
Skylines. Motivated by this fact, this paper addresses this issue.
The remainder of this paper is organized as follows: In
Section II we present the formal background. Based on this
background we will discuss multi-level Skyline computation in
Section III and top-k Skyline computation in Section IV. We
conduct an extensive performance evaluation on synthetic and
real datasets in Section V. Section VI contains some related
work. Section VII contains our concluding remarks.
141
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

II.
SKYLINE QUERIES REVISITED
In this section, we revisit the problem of Skyline compu-
tation and shortly describe the Lattice Skyline approach, since
this is the basis of our algorithms.
A. Skyline Queries
The aim of a Skyline query is to ﬁnd the best objects in a
data set D, i.e., S(D). Note that Skylines are not restricted to
numerical domains [3]. More formally:
Deﬁnition 1 (Skyline). Assume a set of vectors D ∈ Rd. We
deﬁne the so called Pareto ordering for all x = (x1, ..., xd),
y = (y1, ..., yd) ∈ D:
x <⊗ y
⇐⇒
∀j ∈ {1, ..., d}
:
xj ≤ yj
∧
∃i ∈ {1, ..., d}
:
xi < yi
(1)
The Skyline S of D is deﬁned by the maxima in D according
to the ordering <⊗, or explicitly by the set
S(D) = {t ∈ D | ∄u ∈ D : u <⊗ t}
(2)
In this sense we prefer the minimal values in each domain and
write x <⊗ y if x is better than y.
In general, algorithms of the block-nested-loop class (BNL)
[1] are probably the best known algorithms for computing Sky-
lines. They are characterized by a tuple-to-tuple comparison-
based approach, hence having a worst case complexity of
O(n2), and a best case complexity of the order O(n); n
being the number of input tuples, cf. [4]. The major advantage
of a BNL-style algorithm is its simplicity and suitability for
computing the maxima of arbitrary partial orders. Furthermore,
a multitude of optimization techniques [4][5] and parallel
variants [6][7][8][9] have been developed in the last decade.
B. Lattice Skyline Revisited
Lattice-based algorithms depend on the lattice structure
constructed by a Skyline query over low-cardinality domains.
Examples for such algorithms are Lattice Skyline [10] and
Hexagon [11], both having a worst case linear time complex-
ity. Both algorithms follow the same idea: the partial order
imposed by a Skyline query constitutes a lattice. This means
if a, b ∈ D, the set {a, b} has a least upper bound and a greatest
lower bound in D. Visualization of such lattices is often done
using Better-Than-Graphs (BTG) [12], graphs in which edges
state dominance. The nodes in the BTG represent equivalence
classes. Each equivalence class contains the objects mapped
to the same feature vector of the Skyline query. All values in
the same equivalence class are considered substitutable.
An example of a BTG over a 2-dimensional space is shown
in Figure 2 where [0..2]×[0..4] describes a domain of integers
where attribute A1 ∈ {0, 1, 2} and A2 ∈ {0, 1, 2, 3, 4} (abbr.
[2; 4]). The arrows show the dominance relationship between
elements of the lattice. The node (0, 0) presents the best node,
i.e., the least upper bound, whereas (2, 4) is the worst node.
The bold numbers next to each node are unique identiﬁers (ID)
for each node in the lattice, cp. [11]. Nodes having the same
level in the BTG are indifferent, i.e. for example, that neither
the objects in the node (0, 4) are better than the objects in (1, 3)
nor vice versa. A dataset D does not necessarily contain tuples
for each lattice node. In Figure 2, the gray nodes are occupied
(non-empty) with elements from the dataset whereas the white
nodes have no element (empty).
2(0, 2)
3(0, 3)
4(0, 4)
1(0, 1)
9(1, 4)
0(0, 0)
6(1, 1)
7(1, 2)
8(1, 3)
14(2, 4)
5(1, 0)
13(2, 3)
10(2, 0)
11(2, 1)
12(2, 2)
Figure 2. Lattice over [0..2] × [0..4].
The method to obtain the Skyline can be visualized using
the BTG. The elements of the dataset D that compose the
Skyline are those in the BTG that have no path leading to
them from another non-empty node in D. In Figure 2, these
are the nodes (0, 1) and (2, 0). All other nodes have direct
or transitive edges from these both nodes, and therefore are
dominated.
Lattice based algorithms exploit these observations to ﬁnd
the Skyline of a dataset over the space of vectors drawn from
low-cardinality domains and in general consist of three phases:
1) Phase 1: The Construction Phase initializes the data
structures. The lattice is represented by an array in main
memory. Each position in the array stands for one node ID
in the lattice. Initially, all nodes of the lattice are marked
as empty and not dominated.
2) Phase 2: In the Adding Phase the algorithm determines
for each element t ∈ D the unique ID and therefore the
node of the lattice that corresponds to t. This node will be
marked as non-empty.
3) Phase 3: After all tuples have been processed, in the Re-
moval Phase dominated nodes are identiﬁed. The nodes of
the lattice that are marked as non-empty and which are not
reachable by the transitive dominance relationship from any
other non-empty node represent the Skyline values. Nodes
that are non-empty but are reachable by the dominance
relationship are marked dominated to distinguish them from
present Skyline values.
From an algorithmic point of view this is done by a
combination of breadth-ﬁrst traversal (BFT) and depth-ﬁrst
traversal (DFT). The nodes of the lattice are visited level-
by-level in a breadth-ﬁrst order (the dashed line in Figure
2). Each time a non-empty and not dominated node is
found, a DFT will start. The DFT does not need to explore
branches already marked as dominated. The BFT can stop
after processing a whole level not containing empty nodes
hence marking the end of Phase 3.
For example, the node (0, 1) in Figure 2 is not empty.
The DFT recursively walks down and marks all dominated
nodes as dominated (thick black arrows). After the BFT
has ﬁnished, the non-empty and not dominated nodes (here
(0, 1) and (2, 0)) contain the Skyline objects.
142
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

III.
MULTI-LEVEL SKYLINE COMPUTATION
In some cases it is necessary to return not only the best
tuples as in common Skyline computation, but also to retrieve
tuples directly dominated by those of the Skyline set (the
second stratum), i.e., the tuples behind the Skyline. Following
this method transitively, the input is partitioned into multiple
levels (strata) in a way resembling the elements’ quality
w.r.t. the search preferences. In this section, we introduce the
concept of multi-level Skylines and present an algorithm for
efﬁcient computation of iterated preferences in linear time.
A. Background
We extend Deﬁnition 1 of the Skyline by a level value to
form multi-level Skyline (Sml) sets.
Deﬁnition 2 (Multi-Level Skyline). The multi-level Skyline set
of level l (i.e., the l-th stratum) for a dataset D is deﬁned as
Sl
ml := S
 
D \
l−1
[
i=0
Si
ml(D)
!
(3)
Thereby S0
ml(D) is identical to the standard Skyline S(D)
from Deﬁnition 1, and Slmax
ml
denotes the non-empty set with
the highest level.
Lemma 1. For each tuple t in a ﬁnite dataset D, there is
exactly one Sl
ml set it belongs to:
∀t ∈ D :

by the number of Skyline dimensions as for each of them
not more than one node can be dominated and we only visit
directly dominated nodes (so the DFT ends at depth 1). The
actual complexity of ﬁnding each of the directly dominated
nodes or a node’s successor in the BFT is speciﬁc to the
representation of the BTG in memory, but can be assumed
as O(1) [10][11]. For all direct dominated nodes compute the
tmpml value as the equation above (line 11–13). Afterward,
if the node n contains elements from the input dataset, we
retrieve for Si
ml the level i the elements belongs to (line 16)
and add all elements of the node n to the Si
ml building up the
multi-level Skyline sets (line 18). We continue with the next
node in the BFT (line 20) until the end of the BTG is reached
(line 21). The result is a list of Si
ml sets.
Example 1. Figure 3 shows an example of Algorithm 1.
S0
ml
S1
ml
S2
ml
S3
ml
2(0, 2)
3(0, 3)
4(0, 4)
1(0, 1)
9(1, 4)
0(0, 0)
6(1, 1)
7(1, 2)
8(1, 3)
14(2, 4)
5(1, 0)
13(2, 3)
10(2, 0)
11(2, 1)
12(2, 2)
Figure 3. Multi-level Skylines Sl
ml.
Since node 0 is empty, the ﬁrst relevant node is 1. Therefore
we set tmpml[1] = 0 and add 1 to all direct dominated
nodes, i.e. tmpml[2] = tmpml[6] = 1. We continue with node
5 which does not affect anything (the offset for the node is
0 and hence the tmpml values for the dominated nodes 6
and 10 remain unchanged). Since node 2 is empty, we set
tmpml[3] = tmpml[7] = 1. Node 6 has already tmpml[6] = 1.
The next node is 10, which still has tmpml[10] = 0. Node 3
sets tmpml[4] = tmpml[8] = 2, and so on. After the BFT has
ﬁnished we have 4 Sml sets.
IV.
TOP-K SKYLINE COMPUTATION
The concept of top-k ranking is used to rank tuples
according to some score function and to return a maximum
of k objects [13]. On the other hand, Skyline retrieves tuples
where all criteria are equally important concerning some user
preference [1]. However, the number of Skyline answers may
be smaller than required by the user, for whom k are needed.
Therefore, top-k Skyline was deﬁned as a uniﬁed language to
integrate them [14][15].
A. Background
Top-k Skyline allows to get exactly the top k from a
partially ordered set stratiﬁed into subsets of non-dominated
tuples. The idea is to partition the set into subsets (strata, multi-
level Skyline sets) consisting of non-dominated tuples and to
produce the top-k of these partitions.
In general, existing solutions calculate the ﬁrst stratum with
some sort of post-processing [14][15][16]. That means, after
identifying the ﬁrst stratum S0
ml(D), they remove the contained
objects from the original input dataset D and continue Skyline
computation on the reduced data. Hence, the second stratum
is S1
ml = S (D \ S(D)). This workﬂow is continued until k
objects are found. More formally:
Deﬁnition 3 (Top-k Skyline). A top-k Skyline query Sk
tk(D)
on an input dataset D computes the top k elements with respect
to the Skyline preferences. Formally:
1) If |S(D)| > k, then return only k tuples from S(D),
because not all elements can be returned due to result
set size limitations. Any k tuples are a correct choice.
2) If |S(D)| = k, then Sk
tk(D) = S(D). That means return
all tuples of S0
ml(D). In this case there is no difference
between the Skyline set and the top-k result set.
3) If |S(D)| < k, then the elements of S(D) are not enough
for an adequate answer. We have to ﬁnd a value j which
meets the following criterion:

j−1
[
i=0
Si
ml(D)
 < k ≤

j[
i=0
Si
ml(D)

(6)
That means, not only all elements of S(D) = S0
ml(D) are
returned, but also some of S1
ml(D), and if the number of
result tuples is still less than k, then S2
ml(D), and so
on. Note that from Sj
ml(D) exactly k −
Sj−1
i=0 Si
ml(D)

elements will be returned, which might not be all of it.
B. The Top-k Lattice Skyline Algorithm (TkLS)
In this section, we adapt the concept of multi-level Skyline
computation in Section III to the computation of top-k Skylines.
Algorithm 1 returns a set of all Si
ml sets, hence the ﬁrst
k elements of these sets correspond to the top-k elements.
However, in a top-k approach it is not necessary to compute
all strata. It is enough to compute l multi-levels such that
k ≤

l[
i=0
Si
ml(D)

(7)
For this, we append a simple break condition after line 19 in
Algorithm 1 which checks the above equation. Afterward, we
can return the top-k elements.
One may criticize that picking the top-k results from the
different equivalence classes (nodes of the BTG) is arbitrary in
some manner, especially if a multi-level set Sj
ml only partially
belongs to the top-k result set. In this case we have to pick
some arbitrary elements out of this Sj
ml set to ﬁll up the top-k
elements. To handle this “problem” we can think about some
kind of ordering or sorting before returning the top-k elements.
Whichever additional conditions and characteristics are used,
the top-k results can be taken then from the nodes coming
ﬁrst in the new order. We omit the discussion of the effects of
different ordering strategies here as wrt. the original Skyline
query, all candidates in Sj
ml are equally good results.
We have seen that in spite of being developed for Skyline
queries, our multi-level Skyline algorithm can easily be applied
to top-k Sykline queries as well. Its greatest advantage remains:
the linear runtime complexity in the number of input tuples
and size of the BTG.
144
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

 0
 2
 4
 6
 8
 10
 12
1
5
10
Runtime (sec)
Input size x 10k
TkLS
EBNL
ESFS
(a) Runtime: anti, d = 5, top-500.
 0
 0.5
 1
 1.5
 2
 2.5
1
5
10
Runtime (sec)
Input size x 10k
TkLS
EBNL
ESFS
(b) Runtime: corr, d = 5, top-500.
 0
 1
 2
 3
 4
 5
 6
 7
 8
 9
 10
1
5
10
Runtime (sec)
Input size x 10k
TkLS
EBNL
ESFS
(c) Runtime: ind, d = 5, top-500.
 0
 1
 2
 3
 4
 5
 6
 7
TkLS
EBNL
ESFS
Runtime (sec)
d=3
d=5
d=7
|S0d=3(D)|=290
|S1d=3(D)|=5254
|S0d=5(D)|=114
|S1d=5(D)|=202
|S2d=5(D)|=225
|S0d=7(D)|=279
|S1d=7(D)|=568
(d) Dimension: anti, d = 3, 5, 7, top-500.
 0
 2
 4
 6
 8
 10
 12
TkLS
EBNL
ESFS
Runtime (sec)
top-100
top-500
top-1000
top-25000
|S0(D)|=114
|S1(D)|=202
|S2(D)|=225
|S3(D)|=292
|S4(D)|=355
|S5(D)|=368
|S6(D)|=399
|S7(D)|=461
|S8(D)|=459
|S9(D)|=497
(e) Different k: anti, d = 5, n = 50K.
 0
 2
 4
 6
 8
 10
 12
 14
 16
TkLS
EBNL
ESFS
Runtime (sec)
top-100
top-5000
top-10000
|S0(D)|=95
|S1(D)|=3806
|S2(D)|=6069
|S3(D)|=8347
(f) Zillow data. d = 4, n = 2M.
Figure 4. Experimental results.
V.
EXPERIMENTS
This section provides our benchmarks on synthetic and real
data to reveal the performance of the outlined algorithms. The
concept of MLLS is the basis of TkLS, hence the performance
of our top-k approach reﬂects the power of our multi-level
Skyline algorithm. And since there is no competitor for MLLS,
we only compared our approach TkLS to the state-of-the-art
algorithms in generic top-k Skyline computation, Extended
Block-Nested-Loop (EBNL) and Extended Sort-Filter-Skyline
(ESFS) [15]. EBNL is a variant of the standard BNL algo-
rithm [1] with the modiﬁcation that each computed stratum is
removed from the dataset and the Skyline is computed again.
ESFS is an extension of SFS [5] exploiting some kind of data
pre-sorting. In the worst-case EBNL and ESFS have a time
complexity of O(n2). The algorithms have been implemented
in Java 7.0. TkLS follows the implementation details given in
[9] and [11]. The experiments were performed on a machine
running Debian Linux 7.1 equipped with an Intel Xeon 2.53
GHz processor.
For our synthetic datasets we used the data generator
commonly used in Skyline research [1]. We generated anti-
correlated (anti), correlated (corr), and independent (ind)
distributions and varied (1) the data cardinality n, and (2) the
data dimensionality d. For the experiments on real-world data,
we used the well-known Zillow dataset from www.zillow.com.
This dataset contains more than 2M entries about real estate in
the United States. Each entry includes number of bedrooms and
bathrooms, living area in sqm, and age of the building. The
Zillow dataset also serves as a real-world application which
requires ﬁnding the Skyline on data with a low-cardinality
domain.
Figures 4a – 4c present the runtime of all algorithms on
a 5 dimensional anti-correlated, correlated, and independent
distributed dataset. We used a top-500 query on different data
cardinality. The low-cardinality domain was constructed by
[2; 3; 5; 10; 100]. For all Skyline sets it holds that |S(D)| < 500
to get the effect of computing more than the 0-stratum.
Figure 4d shows the runtime of all algorithms on 3,
5, and 7 dimensions having anti-correlated data (up to
[2; 3; 5; 10; 10; 10; 100]). The underlying data cardinality is
n = 50000 and the target was to ﬁnd the top-500 elements.
We also present the size of the different multi-level Skylines.
For example, if d = 3 we have |S0
ml(D)| = 290 and the ﬁrst
stratum has |S1
ml(D)| = 5254 objects. This is also the reason
why ESFS in this case is worse than for d = 5 or d = 7. ESFS
has to compare all objects of the ﬁrst stratum to all others, not
yet dominated tuples.
Figure
4e
visualizes
the
effect
of
different
values
of k. Therefore we computed top-k elements for k
∈
{100, 500, 1K, 25K} using 5 dimensions (as in Figures 4a –
4c) and a data cardinality of n = 50000. The runtime for
TkLS for all ks is very similar. This is due to the lattice based
approach, where no tuple-to-tuple comparison is necessary, but
only the construction of the BTG. Since the BTG for all ks is
the same, the runtime for all top-k queries is quite similar. In
the top-100 query only the Skyline S(D) has to be computed.
For k = 500 we have to compute stratum 0, 1, and 2. For
top-1000 the ﬁrst ﬁve strata are necessary, and for k = 25K
we need 41 strata to answer the query. We also see in this
experiment that ESFS exploiting some pre-sorting is worse
than EBNL. This is due the reordering of the elements.
145
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

Figure 4f presents our results on real data, i.e., the Zillow
dataset (domain [10; 10; 36; 46]). Again, we compute the top-
k elements for k ∈ {100, 5000, 10000} to show the effect of
computing different strata. TkLS clearly outperforms EBNL
and ESFS. Again, since our algorithm is based on the lattice
of a Skyline query the runtimes for the different ks are quite
similar. EBNL and ESFS have to compute four strata to fulﬁll
the k = 10000 query which results in a long runtime and hence
bad performance.
VI.
RELATED WORK
The idea of multi-level Skylines was already mentioned
by Chomicki [3] under the name of iterated preferences.
However, Chomicki has never presented an algorithm for
their computation. Apart from that there is no other work on
computing the i-th stratum of a Skyline query.
Regarding top-k [13] and Skyline [2] queries, there are
some approaches that combine these both paradigms to top-
k Skyline queries. In [14] and [15] the authors calculate the
ﬁrst stratum of the Skyline with some sort of post-processing.
Afterward, they deﬁne the k best objects or continue Skyline
computation without the ﬁrst stratum. The authors of [16]
abstract Skyline ranking as a dynamic search over Skyline
subspaces guided by user-speciﬁc preferences. In [17][18]
and [19] an index based approach is used for top-k Skyline
computation. However, index based algorithms in general
cannot be used if there is a join or Cartesian product involved
in the query. Su et al. [20] considers top-k combinatorial
Skyline queries, and Zhang et al. [21] discuss a probabilistic
top-k Skyline operator over uncertain data. Top-k queries are
also of interest in the computation of spatial preferences [22],
where the aim is to retrieve the k best objects in a spatial
neighborhood of a feature object. Yu et al. [23] consider the
problem of processing a large number of continuous top-
k queries, each with its own preference. Although there is
some related work, the problem of efﬁciently evaluating top-k
Skylines is still an open issue.
VII.
CONCLUSION AND FUTURE WORK
We have found a promising algorithm for the iterated
evaluation of a Skyline query. After a single run through a
set of input tuples, we are able to return not only the Pareto
frontier, but also the tuples that are directly dominated by
them, and so on. Our approach supports multi-level and top-
k Skyline computation without computing each stratum of
the Skyline query individually. Although multi-level Skyline
sets have been introduced some years ago, no algorithms
specialized on this problem have been proposed. Furthermore,
our TkLS algorithm also provides an efﬁcient way to compute
top-k Skylines. The only restriction we suffer from are low-
cardinality domains. Since this is a huge restriction to Skyline
computation, we want to adjust our algorithms as suggested
in [24]. They use some kind of down-scaling of the domain.
Furthermore, on the basis of [9] we want to develop a parallel
algorithm for top-k Skyline computation. But this remains for
future work.
REFERENCES
[1]
S. B¨orzs¨onyi, D. Kossmann, and K. Stocker, “The Skyline Operator,”
in Proceedings of ICDE ’01.
Washington, DC, USA: IEEE, 2001, pp.
421–430.
[2]
J. Chomicki, P. Ciaccia, and N. Meneghetti, “Skyline Queries, Front
and Back,” SIGMOD, vol. 42, no. 3, 2013, pp. 6–18.
[3]
J. Chomicki, “Preference Formulas in Relational Queries,” in TODS
’03: ACM Transactions on Database Systems, vol. 28, no. 4.
New
York, NY, USA: ACM Press, 2003, pp. 427–466.
[4]
P. Godfrey, R. Shipley, and J. Gryz, “Algorithms and Analyses for
Maximal Vector Computation,” The VLDB Journal, vol. 16, no. 1, 2007,
pp. 5–28.
[5]
J. Chomicki, P. Godfrey, J. Gryz, and D. Liang, “Skyline with Presort-
ing,” in Proceedings of ICDE ’03, 2003, pp. 717–816.
[6]
J. Selke, C. Loﬁ, and W.-T. Balke, “Highly Scalable Multiprocessing
Algorithms for Preference-Based Database Retrieval,” in Proceedings
of DASFAA ’10, ser. LNCS, vol. 5982.
Springer, 2010, pp. 246–260.
[7]
S. Park, T. Kim, J. Park, J. Kim, and H. Im, “Parallel Skyline
Computation on Multicore Architectures,” in Proceedings of ICDE ’09.
Washington, DC, USA: IEEE Computer Society, 2009, pp. 760–771.
[8]
S. Liknes, A. Vlachou, C. Doulkeridis, and K. Nørv˚ag, “APSkyline:
Improved Skyline Computation for Multicore Architectures,” in Pro-
ceedings of DASFAA ’14, 2014, pp. 312–326.
[9]
M. Endres and W. Kießling, “High Parallel Skyline Computation over
Low-Cardinality Domains,” in Proceedings of ADBIS ’14.
Springer,
2014, pp. 97–111.
[10]
M. Morse, J. M. Patel, and H. V. Jagadish, “Efﬁcient Skyline Compu-
tation over Low-Cardinality Domains,” in Proceedings of VLDB ’07,
2007, pp. 267–278.
[11]
T. Preisinger and W. Kießling, “The Hexagon Algorithm for Evaluating
Pareto Preference Queries,” in Proceedings of MPref ’07, 2007.
[12]
T. Preisinger, W. Kießling, and M. Endres, “The BNL++ Algorithm for
Evaluating Pareto Preference Queries,” in Proceedings of MPref ’06,
pp. 114–121.
[13]
I. F. Ilyas, G. Beskales, and M. A. Soliman, “A Survey of Top-k Query
Processing Techniques in Relational Database Systems,” ACM Comput.
Surv., vol. 40, no. 4, Oct. 2008, pp. 11:1–11:58.
[14]
M. Goncalves and M.-E. Vidal, “Top-k Skyline: A Uniﬁed Approach,”
in OTM Workshops, 2005, pp. 790–799.
[15]
C. Brando, M. Goncalves, and V. Gonz´alez, “Evaluating Top-k Skyline
Queries over Relational Databases,” in DEXA ’07: Proceedings of
the 18th International Conference on Database and Expert Systems
Applications, ser. LNCS, vol. 4653.
Springer, 2007, pp. 254–263.
[16]
J. Lee, G. w. You, and S. w. Hwang, “Personalized Top-k Skyline
Queries in High-Dimensional Space,” Information Systems, vol. 34,
no. 1, Mar. 2009, pp. 45–61.
[17]
Y. Tao, X. Xiao, and J. Pei, “Efﬁcient Skyline and Top-k Retrieval in
Subspaces,” IEEE Transactions on Knowledge and Data Engineering,
vol. 19, no. 8, 2007, pp. 1072–1088.
[18]
M. Goncalves and M.-E. Vidal, “Reaching the Top of the Skyline: An
Efﬁcient Indexed Algorithm for Top-k Skyline Queries,” in Database
and Expert Systems Applications, ser. LNCS.
Springer, 2009, vol.
5690, pp. 471–485.
[19]
P. Pan, Y. Sun, Q. Li, Z. Chen, and J. Bian, “The Top-k Skyline Query in
Pervasive Computing Environments,” in Joint Conferences on Pervasive
Computing (JCPC).
IEEE, 2009, pp. 335–338.
[20]
I.-F. Su, Y.-C. Chung, and C. Lee, “Top-k Combinatorial Skyline
Queries,” in Database Systems for Advanced Applications.
Berlin,
Heidelberg: Springer Berlin Heidelberg, Jan. 2010, pp. 79–93.
[21]
Y. Zhang, W. Zhang, X. Lin, B. Jiang, and J. Pei, “Ranking Uncertain
Sky: The Probabilistic Top-k Skyline Operator,” Information Systems,
vol. 36, no. 5, Jul. 2011, pp. 898–915.
[22]
J. B. Rocha-Junior, A. Vlachou, C. Doulkeridis, and K. Nørv˚ag, “Efﬁ-
cient Processing of Top-k Spatial Preference Queries,” in Proceedings
of the VLDB Endowment, vol. 4, no. 2, 2010, pp. 93–104.
[23]
A. Yu, P. K. Agarwal, and J. Yang, “Processing a Large Number of
Continuous Preference Top-k Queries,” in Proceedings of the 2012
ACM SIGMOD International Conference on Management of Data.
ACM, 2012, pp. 397–408.
[24]
M. Endres, P. Roocks, and W. Kießling, “Scalagon: An Efﬁcient Skyline
Algorithm for all Seasons,” in DASFAA ’15: Proceedings of the 20th
international conference on Database systems for advanced applications,
2015, in press.
146
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-408-4
DBKDA 2015 : The Seventh International Conference on Advances in Databases, Knowledge, and Data Applications

