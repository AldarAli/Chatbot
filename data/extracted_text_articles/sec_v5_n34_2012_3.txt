94
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
Securing Access to Data in Business Intelligence Domains
Ahmad Altamimi
Department of Computer Science
Concordia University
Montreal, Canada
Email: a alta@cs.concordia.ca
Todd Eavis
Department of Computer Science
Concordia University
Montreal, Canada
Email: eavis@cs.concordia.ca
Abstract‚ÄîOnline Analytical Processing (OLAP) has become
an increasingly important and prevalent component of Decision
Support Systems. OLAP is associated with a data model known
as a cube, a multi-dimensional representation of the core
measures and relationships within the associated organization.
While numerous cube generation and processing algorithms
have been presented in the literature, little effort has been made
to address the unique security and authorization requirements
of the model. In particular, the hierarchical nature of the cube
allows users to bypass - either intentionally or unintentionally
- partial constraints deÔ¨Åned at alternate aggregation levels. In
this paper, we present an authorization framework that builds
upon an algebra designed speciÔ¨Åcally for OLAP domains. It is
Object-Oriented in nature and uses query re-writing rules to
ensure consistent data access across all levels of the conceptual
model. For the most part, the process is largely transparent
to the user. We demonstrate the scope of our framework
with a series of common OLAP query case studies, as well
as an experimental performance analysis using a common
OLAP benchmark. The end result is an intuitive but powerful
approach to database authorization that is uniquely tailored to
the OLAP domain.
Keywords-Data warehouses; Data security; Query processing
I. INTRODUCTION
Data warehousing (DW) and On-Line Analytical Process-
ing (OLAP) play a pivotal role in modern organizations.
Designed to facilitate the reporting and analysis required in
decision making environments, OLAP builds upon a multi-
dimensional data model that intuitively integrates the vast
quantities of transactional level data collected by contempo-
rary organizations. Ultimately, this data is used by managers
and decision makers in order to extract and visualize broad
patterns and trends that would otherwise not be obvious to
the user.
One must note that while the data warehouse serves as
a repository for all collected data, not all of its records
should be universally accessible. SpeciÔ¨Åcally, DW/OLAP
systems almost always house conÔ¨Ådential and sensitive data
‚Äî identiÔ¨Åcation information, medical data or even religious
beliefs or ideologies ‚Äî that must, by deÔ¨Ånition, be restricted
to authorized users. As a result, various pieces of legislation
designed to protect individual privacy have been proposed.
One can consider, for example, the United States HIPAA-
Health Insurance Portability and Accountability Act, which
regulates the privacy of personal health care information,
the GLBA (Gramm-Leach-Bliley Act, also known as the
Financial Modernization Act), the Sarbanes-Oxley Act, and
the EU‚Äôs Safe Harbour Law. These laws usually require strict
technical security measures for guaranteeing privacy, with a
failure to comply possibly leading to signiÔ¨Åcant penalties.
In this context, organizations must be able to guarantee the
correct administration, security and conÔ¨Ådentiality of the
information they collect and store.
The administrator of the warehouse is ultimately re-
sponsible for deÔ¨Åning roles and privileges for each of the
possible end users. In fact, a number of general warehouse
security models have been proposed in the literature. Several
authors deÔ¨Åne frameworks that are likely too restrictive for
production warehouses. For example, security models have
been based upon the notion of user-speciÔ¨Åc authorization
views that allow access only to selected data. However,
the administration of these views becomes quite complex
when a security policy is added, changed, or removed.
Moreover, complex roles can be difÔ¨Åcult to implement in
practice, and models of this type tend not to scale well
with a large number of users. Conversely, other researchers
have focused on the design process itself, including the
use of UniÔ¨Åed Modeling Language (UML) proÔ¨Åles for the
deÔ¨Ånition of security constraints. Here, however, the phys-
ical implementation of the underlying authorization system
remains undeÔ¨Åned.
In a recent paper, we presented an authorization model
for OLAP environments that is based on a query rewriting
technique [1]. The model enforces distinct data security poli-
cies that, in turn, may be associated with user populations of
arbitrary size. In short, our framework rewrites queries con-
taining unauthorized data access to ensure that the user only
receives the data that he/she is authorized to see. Rewriting
is accomplished by adding or changing speciÔ¨Åc conditions
within the query according to a set of concise but robust
transformation rules. Because our methods speciÔ¨Åcally target
the OLAP domain, the query rules are directly associated
with the conceptual properties and elements of the OLAP
data model itself. A primary advantage of this approach is
that by manipulating the conceptual data model, we are able
to apply query restrictions not only on direct access to OLAP

95
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
elements, but also on certain forms of indirect access.
In the current paper, we expand upon the original work
in two ways. First, we discuss the data structures and
algorithms utilized by the functions that manipulate the
hierarchical elements of the conceptual data model. The
performance of the transformation process is closely asso-
ciated with these mechanisms. To underscore the practical
viability of the proposed methods, we have also added an
experimental section that highlights the processing overhead
relative to the execution costs of the underlying query. In
addition to these core enhancements, we update the paper
with a deeper treatment of the internal representation of the
intermediate query, as well as a broader discussion of the
work related to this research domain. Finally, an appendix
has been included in order to provide the reader with a clear
description of the query test cases.
The paper is organized as follows. In Section II, we
present an overview of related work. Section III describes the
core OLAP data model and associated algebra, and includes
a discussion of the object-oriented query structure for which
the proposed security model has been designed. The OLAP
query rewriting model and its associated transformation
rules, including the extended section on query representation
and hierarchy processing, are then presented in detail in
Section IV. Experimental results are discussed in Section V,
with Ô¨Ånal conclusions offered in Section VI.
II. RELATED WORK
The need for strong security mechanisms has long been
recognized in the context of relational database management
systems. A variety of Access Control techniques have in
fact been proposed to restrict access to the appropriate
authorized users. Each such technique aims to limit users
and/or processes to performing only those table or column
operations (i.e., read, write, or execute) for which they are
actually authorized. The relevant control then either allows
or disallows the execution of the speciÔ¨Åc operation to be
performed.
During the early stages of database security research, the
primary focus was on Discretionary Access Controls (DACs)
[2]. The basic form of DAC authorization consists of a
triple (s, o, a), such that a set of security subjects s can
execute actions a on a set of security objects o. The earliest
DAC model was the Access Matrix, whereby authorization is
represented in an |s |‚àó|o | matrix in which rows are subjects,
columns are objects and the mapping of subject and object
pairs results in the set of rights the subject s has over the
object o. A primary beneÔ¨Åt associated with the use of a DAC
is that it can be implemented relatively easily. However,
in practice, large organizations give rise to extremely large
access matrices. Maintaining matrix contents can be difÔ¨Åcult
as the matrix needs to be updated with each update to the
subjects (e.g., addition of users) or objects (e.g., addition of
columns).
In the 1980‚Äôs the focus moved to Mandatory Access
Controls (MACs) [3]. The most common form of MAC is the
multilevel security policy, which secures data by assigning
security labels to subjects and objects, and subsequently
compares these labels to the level of sensitivity at which
a user is operating. The access controls in MACs restrict
subjects from accessing information labeled with a higher
level. In other words, a user can access the data in his/her
security level or in a lower security level(s) but not in a
higher level(s). MAC is relatively straightforward from a
design perspective and is considered a good model either
for systems in which conÔ¨Ådentiality is a primary access
control concern, or in which the objects being protected
are valuable. That being said, MAC systems can also be
expensive to implement due to the necessity for applications
to be rewritten to adhere to MAC labels and properties. Also,
MACs do not provide each user with a distinct authorization
context (i.e., access to only their own data address), nor Ô¨Åne-
grained least privilege mechanisms.
An alternative approach was introduced in the 1990‚Äôs [4].
This new model is known as Role Based Access Control
(RBAC). RBAC consists of roles, permissions, and users.
Roles are created for various job functions, with permissions
for speciÔ¨Åc operations then assigned to these roles. Users
are assigned particular roles, and through those role assign-
ments acquire permissions to perform particular operations.
The consolidation of access control for many users into a
single role entry allows for much easier management of
the overall system and much more effective veriÔ¨Åcation of
security policies. However, in large systems, role inheritance
‚Äî and the need for Ô¨Åner-grained customized privileges‚Äî
makes administration potentially unwieldy. Additionally, it
is inappropriate for multi-dimensional data modeling due to
the fact that it is based on relational concepts (i.e., tables,
columns, rows, and cells), and thus, cannot be implemented
directly on top of the multi-dimensional model.
In contrast to the Access Control paradigm, a number of
security models that restrict data warehouse access have also
been proposed in the literature, including those that focus
strictly on the design process. Extensions to the UniÔ¨Åed
Modeling Language to allow for the speciÔ¨Åcation of multi-
dimensional security constraints has been one approach that
has been suggested [5]. In fact, a number of researchers have
looked at similar techniques for setting access constraints at
an early stage in the OLAP design process [6], [7]. Others
have developed security requirements for the entire Data
Warehouse life cycle [8]‚Äì[10]. In this case, they Ô¨Årst propose
a model (agent-goal-decision-information) to support the
early and late requirements for the development of DWs,
then extend that model to capture security aspects in order
to prevent illegitimate attempts to access the warehouse.
Such models have great value of course, particularly if one
has the option to create the warehouse from scratch. That
being said, their focus is not on authorization algorithms

96
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
per se, but rather on design methodologies that would most
effectively use existing technologies, including the Model
Driven Architecture (MDA) and the standard Software Pro-
cess Engineering Metamodel SpeciÔ¨Åcation (SPEM) from the
Object Management Group (OMG).
In terms of true authorization models, several researchers
have attempted to augment the core Database Management
System (DBMS) with authorizations views [11]‚Äì[13]. Typ-
ically, alternate views of data are deÔ¨Åned for each distinct
user or user group. A query Q is inferred to be authorized if
there is an equivalent query Q‚Äô which uses only authorized
views. The end result is often the generation of a large
number of such views, all of which must be maintained
manually by the system administrator. Clearly, this approach
does not scale terribly well, and would be impractical in a
huge, complex DW environment.
Query rewriting has also been explored in DBMS envi-
ronments in a variety of ways, with search and optimization
being common targets [14]. Beyond that, however, rewrit-
ing has also been utilized to provide Ô¨Åne grained access
control in Relational databases [15]. Oracle‚Äôs Virtual Private
Database (VPD) [16], for example, limits access to row level
data by appending a predicate clause to the user‚Äôs SQL
statement. Here, the security policy is encoded as policy
functions deÔ¨Åned for each table. These functions are used
to return the predicate, which is then appended to the query.
This process is done in a manner that is entirely transparent
to the user. That is, whenever a user accesses a table that
has a security policy, the policy function returns a predicate,
which is appended to the user‚Äôs query before it is executed.
In the Truman model [15], on the other hand, the database
administrator deÔ¨Ånes a parameterized authorization view
for each relation in the database. Note that parameterized
views are normal views augmented with session-speciÔ¨Åc
information, such as the user-id, location, or time. The query
is modiÔ¨Åed transparently by substituting each relation in the
query by the corresponding parameterized view to make sure
that the user does not get to see anything more than his/her
own view of the database. In this model, the user can also
write queries on base relations by plugging in the values
of session parameters such as user-id or time before the
modiÔ¨Åed query is executed.
We note, however, that the mechanisms discussed above
(e.g., Oracle‚Äôs VPD) are not tailored speciÔ¨Åcally to the
OLAP domain and, as such, either have limited ability to
provide Ô¨Åne grained control of the elements in the conceptual
OLAP data model or, at the very least, would make such
constraints exceedingly tedious to deÔ¨Åne. Some commercial
tools, such as Microsoft‚Äôs Analysis Services [17], do in fact
provide some support for OLAP-level security speciÔ¨Åcation.
Here, however, there is virtually no formal basis for the
application of authorization logic and little can be said about
the actual scope or limitations of the relevant subsystems.
This is in contrast to the work discussed in this paper, where
Figure 1.
A simple three dimensional data cube
the primary contribution is a query rewriting technique
that not only transparently supports indirect authorization,
but does so on the basis of an explicit policy/rule model.
Moreover, the mechanisms are not tightly connected to a
speciÔ¨Åc DBMS product but can be applied to virtually any
standard data management system.
III. THE CONCEPTUAL DATA MODEL
We consider analytical environments to consist of one
or more data cubes. Each cube is composed of a series
of d dimensions ‚Äî sometimes called feature attributes ‚Äî
and one or more measures [18]. The dimensions can be
visualized as delimiting a d-dimensional hyper-cube, with
each axis identifying the members of the parent dimension
(e.g., the days of the year). Cell values, in turn, represent the
aggregated measure (e.g., sum) of the associated members.
Figure 1 provides an illustration of a very simple three
dimensional cube on Store, Time and Product. Here,
each unique combination of dimension members represents
a unique aggregation on the measure. For example, we can
see that Product OD923 was purchased 78 times at Store
MQ15 in January (assuming a Count measure).
Note, as well, that each dimension is associated with
a distinct aggregation hierarchy. Stores, for instance, are
organized in Country ‚Üí Province ‚Üí City groupings.
Referring again to Figure 1, we see that Product Number
is the lowest or base level in the Product dimension. In
practice, data is physically stored at the base level so as
to support run-time aggregation to coarser hierarchy levels.
Moreover, the attributes of each dimension are partially
ordered by the dependency relation ‚™Ø into a dependency
lattice [19]. For example, Product Number ‚™Ø Type ‚™Ø
Category within the Product dimension. More formally,
the dependency lattice is expressed in DeÔ¨Ånition 1.
DeÔ¨Ånition 1: A dimension hierarchy Hi of a dimension
Di, can be deÔ¨Åned as Hi = (L0, L1, . . . , Lj) where L0 is
the lowest level and Lj is the highest. There is a functional

97
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
dependency between Lh‚àí1 and Lh such that Lh‚àí1 ‚™Ø Lh
where (0 ‚â§ h ‚â§ j).
Finally, we note that there are in fact many variations on
the form of OLAP hierarchies [20] (e.g., symmetric, ragged,
non-strict). Regardless of the form, however, traversal of
these aggregation paths ‚Äî typically referred to as rollup
and drill down ‚Äî is perhaps the single most common query
form. It is also central to the techniques discussed in this
paper.
A. Native Language Object Oriented OLAP Queries
The cube representation, as described above, is common
to most OLAP query environments and represents the user‚Äôs
conceptual view of the data repository. That being said, it
can be difÔ¨Åcult to implement the data cube using standard
relational tables alone and, even when this is possible, per-
formance is usually sub-par as relational DBMSs have been
optimized for transactional processing. As a result, most
OLAP server products either extend conventional relational
DBMSs or build on novel, domain speciÔ¨Åc indexes and
algorithms.
In our own case, the authorization methods described in
this paper are part of a larger project whose focus is to
design, implement and optimize an OLAP-speciÔ¨Åc DBMS
server. A key design target of this project is the integration
of the conceptual cube model into the DBMS itself. This
objective is accomplished, in part, by the introduction of
an OLAP-speciÔ¨Åc algebra that identiÔ¨Åes the core operations
associated with the cube (SELECT, PROJECT, DRILL DOWN,
ROLL UP, etc). In turn, these operations are accessible to the
client side programmer by virtue of an Object Oriented API
in which the elements of the cube (e.g., cells, dimensions,
hierarchies) are represented in the native client language as
simple OOP constructs. (We note that our prototype API
uses Java but any contemporary OO language could be
used). To the programmer, the cube and all of its data ‚Äî
which is physically stored on a remote server and may be
Gigabytes or Terabytes in size ‚Äî appears to be nothing
more than a local in-memory object. At compile time, a
fully compliant Java pre-parser examines the source code,
creates a parse tree, identiÔ¨Åes the relevant OLAP objects,
and re-writes the original source code to include a native
DBMS representation of the query. At run-time, the pre-
compiled queries are transparently delivered to the back
end analytics server for processing. Results are returned and
encapsulated within a proxy object that is exposed to the
client programmer.
As a concrete example, Listing 1 illustrates a simple SQL
query that summarizes the total sales of Quebec‚Äôs stores
in 2011 for the data cube depicted in Figure 1. Typically,
this query would be embedded within the application source
code (e.g., wrapped in a JDBC call). Conversely, Listing 2
shows how this same query could be written in an Object-
Oriented manner by a client-side Java programmer. Note
S e l e c t
Store . province , SUM( s a l e s )
From
Store ,
Time ,
Sales
Where Store . store ID = Sales . store ID AND
Time . time ID = Sales . time ID AND
Time . year = 2011 AND
Store . province = ‚Äô Quebec ‚Äô
Group by
Store . province
Listing 1.
Simple SQL OLAP Query
Class
SimpleQuery
extends OLAPQuery{
Pu blic
boolean
s e l e c t ( ) {
Store
s t o r e = new Store ( ) ;
DateDimension
time = new TimeDimension ( ) ;
return
( time . getYear ( )
== 2011 &&
s t o r e . g e t P r o v i n c e ( )
==
‚Äô Quebec ‚Äô ) ;
}
Pu blic
Object [ ]
p r o j e c t ( ) {
Store
s t o r e = new Store ( ) ;
Measure
measure = new Measure ( ) ;
Object [ ]
p r o j e c t i o n s = {
s t o r e . g e t P r o v i n c e ( ) ,
measure . g e t S a l e s ( ) };
return
p r o j e c t i o n s ;
}}
Listing 2.
An Object Oriented OLAP Query
that each algebraic operation is encapsulated within its own
method (in this case, SELECT and PROJECT), while the
logic of the operation is consolidated within the return
statement. It is the job of the pre-parser to identify the
relevant query methods and then extract and re-write the
logic of the return statement(s). Again, it is important
to understand that the original source code will never be
executed directly. Instead, it is translated into the native
operations of the OLAP algebra and sent to the server at
run-time.
While it is outside the scope of this paper to discuss the
motivation for native language OLAP programming (a de-
tailed presentation can be found in a recent submission [21]),
we note that such an approach not only simpliÔ¨Åes the
programming model, but adds compile time type checking,
robust re-factoring, and OOP functionality such as query
inheritance and polymorphism. Moreover, query optimiza-
tion is considerably easier on the backed as the DBMS
natively understands the OLAP operations sent from the
client side. In the context of the current paper, however,
the signiÔ¨Åcance of the query transformation process is that
the authorization elements (e.g. roles and permissions) will
be directly associated with the operations of the algebra. In
fact, it is this algebraic representation that forms the input
to the authorization module presented in the remainder of
the paper.

98
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org


	

	


	





	







	







	

	
	


	




	







	


 



	
	!
		

Figure 2.
The Authorization DB.
IV. AUTHENTICATION AND AUTHORIZATION
Without sufÔ¨Åcient security countermeasures, open access
to the OLAP repository becomes a powerful tool in the
hands of malicious or unethical users. Access Control is the
process that restricts unauthorized users from compromising
protected data. This process can be thought of as occurring
in two basic phases: Authentication and Authorization.
Authentication is a form of identity veriÔ¨Åcation that attempts
to determine whether or not a user has valid credentials to
access the system. In contrast, Authorization refers to the
process of determining if the user has permission to access
a speciÔ¨Åc data resource. In this section, we will describe our
general framework, giving a detailed description of its two
primary components and the relationship between them.
A. The Authentication Module
The authentication component is responsible for verifying
user credentials against a list of valid accounts. These ac-
counts are provided by the system administrator and are kept
‚Äî along with their constituent permissions ‚Äî in a backend
database (i.e., the Authorization DB). The Authorization DB
consists of a set of tables (users, permissions, and
objects) that collectively represent the meta data required
to authenticate and authorize the current user. For example,
the users table stores basic user credentials (e.g., name,
password), while the permissions table records the fact
that a given user(s) may or may not access certain controlled
objects. Figure 2 illustrates a slightly simpliÔ¨Åed version
of the Authorization DB schema. In the current prototype,
storage and access to the Authorization DB is provided by
the SQLite toolkit [22]. SQLite is a small, open source C
language library that is ideally suited to tasks that require
basic relational query facilities to be embedded within a
larger software stack.
Figure 3.
An XML query segment.
Internally, the user‚Äôs transformed OLAP query is rep-
resented in XML format (embedded within the re-written
source code). To validate the received XML query, the
system relies on a Document Type Declaration (DTD)
grammar [23] that is used to describe the structure of the
expected XML query (We note that the somewhat more
expressive XMLSchema can also be used for this purpose).
The grammar itself is quite large but, ultimately, its purpose
is to represent the functionality of the analytics queries
one would expect to see in a Business Intelligence context.
Figure 3 shows an XML-encoded segment of the query
depicted in Listing 2. With a little effort one can see how
the ‚Äútotal sales in 2011 for Quebec stores‚Äù is captured by
the sequence of nested XML
The user query itself can be divided into three main
parts: CUBE NAME, OPERATION LIST, and USER CRE-
DENTIALS. As one would expect, the CUBE NAME ele-
ment simply indicates the cube from which data is to be
retrieved (the DBMS would likely store multiple cubes).
The OPERATION LIST element contains one or more OP-
ERATION elements, with PROJECTION and SELECTION
being by far the most common (other analytics operations in-
clude CHANGE LEVEL, CHANGE BASE, PIVOT, DRILL
ACROSS, UNION, DIFFERENCE, and INTERSECTION).
In short, the PROJECTION element lists all attributes and
measures the user wants to retrieve (e.g., Store.Province, and
SUM(Sales)). The SELECTION element, in turn, limits or
Ô¨Ålters the data fetched from the data cube. Each SELEC-
TION element consists of one or more criteria combined by

99
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
Data Query
Selection
Condition
User Credentials
Measure
Customer
Sales
Province
Customer
Time
Province =
ÕöY∆µƒûƒèƒûƒêÕõ
Year = 2010
User Name
Password
John
J86mn
Furniture
Sales
Cube Name
Figure 4.
A small Parse Tree fragment.
a LOGICAL OP element (e.g., Store.Province = ‚ÄôQuebec‚Äô
AND Time.Year = 2011). Finally, the USER CREDEN-
TIALS element, as the name indicates, contains the user‚Äôs
authentication identiÔ¨Åers (i.e., the user name and password).
Of course, in order to properly authenticate the query,
it must Ô¨Årst be parsed and decomposed into its algebraic
components. In fact, the parsing is done in two phases. First,
the DOM parser utility is used to produce a DOM tree that
represents the raw contents of the XML document. In this
phase, the parser not only builds the tree but also veriÔ¨Åes
that the received query has valid syntax corresponding to
the DTD query grammar. An XML document is considered
as valid if it contains only those elements deÔ¨Åned in the
DTD. If the query is syntactically valid, the query proceeds
to the second phase. Otherwise, a parsing error message is
returned to the user.
Figure 4 shows the node tree corresponding to the query
depicted in Figure 3. We can easily see that the content of
this parse tree is equivalent to the OLAP query represented
in the XML format. SpeciÔ¨Åcally, it is executed against the
cube Furniture Sales and consists of two OLAP operations
(Projection and Selection). The projection operation returns
the dimension attribute Customer.Province, as well as one
measure attribute ‚Äî Sales. The Selection operation Ô¨Ålters
the returned information via two conditions on the dimen-
sions Customer (i.e., Province = Quebec) and Time (Year
= 2010). The user name ‚ÄúJohn‚Äù and the password ‚ÄúJ86mn‚Äù
represent the user credentials.
In the second phase of the process, the DOM tree is
converted into a simpliÔ¨Åed data structure. This ‚ÄúQuery
Object‚Äù is cached in memory and contains all the query
elements (i.e., returned attributes, query conditions along
with its dimensions and attributes, and user credentials).
The purpose of this Ô¨Ånal conversion process is to transform
the user query into a simple, minimal data structure that
represents the query in a compact but expressive form.
Once the parsing is completed, the Authentication module
extracts the user credentials to verify them against a valid
account stored in the Authorization DB. If the veriÔ¨Åcation
is successful, the DBMS proceeds with the authorization
process. Otherwise, the query is rejected and the user/pro-
Figure 5.
Authentication and Authorization.
grammer is notiÔ¨Åed. The upper part of Figure 5 depicts the
processing logic of the Authentication module. As a Ô¨Ånal
note, we add that the prototype for the authentication and
authorization modules has been designed as a third party
component that can interact with existing DBMS products.
As such, it does not maintain connection-oriented session
data and thus requires authentication information to be
provided for each query. That being said, this has a very
limited impact on performance as the bulk of the processing
logic is associated with the authorization module, which
must assess user privileges on a query by query basis.
B. The Authorization Module
The second ‚Äî and more signiÔ¨Åcant ‚Äî phase is autho-
rization, the process of determining if the user has permis-
sion to access speciÔ¨Åc data elements. SpeciÔ¨Åcally, when a
user requests access to a particular resource, the request
is validated against the permitted resource list assigned to
that user in the backend database. If the requested resource
produces a valid match, the user request is allowed to
execute as originally written. Otherwise, the query will
either be rejected outright or modiÔ¨Åed according to a set
of Ô¨Çexible transformation rules. To decide if the query will
be modiÔ¨Åed or not, we rely on a set of authorization objects
against which the rules will be applied. The rules themselves
will be discussed in Section IV-E. The lower portion of

100
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 5 graphically illustrates the Authorization module and
indicates its interaction with the Authentication component.
C. Specifying Authorization Objects
Authorization is the granting of a right or privilege that
enables a subject (e.g., users or user groups) to execute an
action on an object. In order to make authorization decisions,
we must Ô¨Årst deÔ¨Åne the authorization objects. Note that the
objects in the OLAP domain are different from those in
the relational context. In a relational model, objects include
logical elements such as tables, records within those tables,
and Ô¨Åelds within each record. In contrast, OLAP objects
are elements of the more abstract conceptual model and
include the dimensions of the multi-dimensional cube, the
hierarchies within each dimension, and the aggregated cells
(or facts). In practice, this changes the logic or focus of the
authorization algorithm. For instance, a user in a relational
environment may be allowed direct access to a speciÔ¨Åc
record (or Ô¨Åeld in that record), while an OLAP user may be
given permission to dynamically aggregate measure values
at/to a certain level of detail in one or dimension hierarchies.
Anything below this level of granularity would be considered
too sensitive, and hence should be protected. In fact, the
existence of aggregation hierarchies is perhaps the most
important single distinction between the authorization logic
of the OLAP domain versus that of the relational world.
We note that in the discussion that follows, we assume
an open world policy, where only prohibitions are speciÔ¨Åed.
In other words, permissions are implied by the absence of
any explicit prohibition. We use the open world approach for
the simple reason that, in contrast to the users in operational
database settings, OLAP users are typically drawn from a
relatively small pool of enterprise decision makers. As such,
these more senior employees generally require broad access
to data. It therefore makes sense to use an open world
policy that deÔ¨Ånes a relatively small set of constraints, rather
than a closed world approach that would require extensive
‚Äúpositive‚Äù privileges to be deÔ¨Åned. That being said, there is
no theoretical barrier to the use of a closed world strategy.
Before discussing the authorization rules themselves, we
Ô¨Årst look at a pair of examples that illustrate the importance
of proper authorization services in the OLAP domain. We
begin with the deÔ¨Ånition of a policy for accessing a speciÔ¨Åc
aggregation level in a data cube dimension hierarchy.
Example 1: An employee, Alice, is working in the Mon-
treal store associated with the cube of Figure 1. The policy
is simple: Alice should not know the sales totals of the
individual provinces.
Clearly, Alice is prohibited from reading or aggregating
data at the provincial level in the Store dimension hierarchy.
However, in the absence of any further restrictions, it would
still be possible for her to compute the restricted values from
the lower hierarchies levels (e.g., City or Store Number).
Province
City
Customer Number
(a) The Below Function
(b) The Under Function
Quebec
Montreal
Laval
MQ21
MQ51
LQ58
Below(Province)
Under(Quebec)
Country
Ontario
Canada
Figure 6.
The Below and Under functions.
Ideally, the warehouse administrator should not be respon-
sible for identifying and manually ensuring that all implied
levels be included in the policy. Instead, our model assumes
this responsibility and can, if necessary, restrict access to
all child levels through the use of the Below function. As
the name implies, this function returns a list consisting
of the speciÔ¨Åed level Li and all the lower levels of the
associated dimension hierarchy. Figure 6(a) illustrates an
example using a Below(Province) instantiation. Here, all
levels surrounded by the dashed line are considered to be
Authorization Objects, and thus should be protected. The
formalization of the Below function is given by DeÔ¨Ånition 2.
DeÔ¨Ånition 2: In any dimension Di with hierarchy Hi, the
function Below(Li) is deÔ¨Åned as Below(Li) = {Lj : such
that Lj ‚™Ø Li holds}, where Li is the prohibited dimension
level.
As shown in Example 1, a policy may restrict the user
from accessing any of the values of a given level or
levels. However, there are times when this approach is too
coarse. Instead, we would like to also have a less restrictive
mechanism that would only prevent the user from accessing
a speciÔ¨Åc value within a level(s). For instance, suppose we
want to alter the policy in Example 1 to make it more
speciÔ¨Åc. The new policy might look like the following:
Example 2: Alice should not know the sales total for the
province of Quebec.
In Example 2, we see that Alice may view sales totals
for all provinces other than Quebec. However, Alice can
still compute the Quebec sales by summing the sales of
individual Quebec cities, or by summing the sales of Que-
bec‚Äôs many stores. In other words, she can use the values
of the lower levels to compute the prohibited value. Hence,
all these values should also be protected. To determine the
list of restricted member values, our model adds the Under
function, which is formalized in DeÔ¨Ånition 3. Figure 6 (b)
provides an example using Under(Quebec). Here, all the
values surrounded by the dashed line should be protected.

101
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
Quebec
Montreal
Laval
MQ21
MQ51
LQ58
Ontario
Canada
Exception
Figure 7.
An Authorization Exception.
DeÔ¨Ånition 3: For any dimension hierarchy level Li, and
any attribute value Vi, the function Under(Li, Vi) is deÔ¨Åned
as Under(Li, Vi) = {Vj : such that Vj ‚™Ø Vi holds}, where
Li is the prohibited dimension level and V is the root value
of the restriction.
Finally, it is also possible that exceptions to the general
authorization rule are required. For instance, Alice should
not know the sales of stores in the province of Quebec except
for the stores in the city/region she manages (e.g., Montreal).
Figure 7 graphically illustrates this policy. In this case, the
circled members represent the values associated with the
exception that would, in turn, be contained within a larger
encapsulating restriction. Note that a user may have one or
more exceptions on a given hierarchy. The formalization of
the exception object is given in in DeÔ¨Ånition 4.
DeÔ¨Ånition 4: For any prohibited level Li, there may be
an Exception E such that E contains a set Ev of values
belonging to Under(Li). That is, Ev ‚àà values of Under(Li).
To summarize, authorization objects consist of the values
of the prohibited level and all the levels below it, excluding
zero or more exception value(s). We formalize the concept
of the Authorization Object in DeÔ¨Ånition 5.
DeÔ¨Ånition 5: An Authorization Object O = {v : v ‚àà
Under(Li) - Ev}, where Li is the prohibited level, and Ev
is the exception value.
D. Implementing Below and Under Functions
To efÔ¨Åciently implement Below and Under functions, a
number of additional algorithms and data structures are
needed in order to manipulate dimension hierarchies and to
retrieve attribute values. These structures are initialized once
the server receives a query and are subsequently exploited
by the DBMS engine during query resolution. Below, we
describe the core structures, along with the methods required
to implement the associated functions efÔ¨Åciently.
1) Implementation of the Below Function: We begin by
giving a brief description of the primary data structures
utilized during function execution. The mapGraph is a suite
Figure 8.
(a) The sorted data of the Store Dimension Table, (b) The
corresponding mapGraph.
of algorithms and data structures for the manipulation of at-
tribute hierarchies in ‚Äúreal time‚Äù [24]. mapGraph builds upon
the notion of hierarchy linearity [25]. BrieÔ¨Çy, a hierarchy is
considered linear if there is a contiguous range of values
Rj on dimension attribute Aj that may be aggregated into a
contiguous range Ri. Informally, this implies that the totals
for a range of values within a child aggregation level are
equivalent to those of some range of values at the parent
level. As a concrete example, the combined sales totals
for the individual months of January, February, and March
would be exactly equivalent to those of the Ô¨Årst quarter
of the calendar year. To establish the linearity of each
dimension hierarchy a sorting technique is employed, with
data subsequently stored at the Ô¨Ånest level of granularity.
If a Time hierarchy is present, for instance, transactional
data would be stored at the Day level rather than at the Year
level. A compact, in-memory lookup structure is then used to
support efÔ¨Åcient real time transformations between arbitrary
levels of the dimension hierarchy. For example, Figure 8(a)

102
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
S e l e c t
Product . Name ,
Store . province ,
Sum( s a l e s )
From Product ,
Store ,
Sales
Where Product . product ID = Sales . product ID
AND Store . store ID = Sales . store ID AND
Store . Contry = ‚Äô Canada ‚Äô AND
( Product . Name = ‚ÄôLN‚àó ‚Äô AND
Product . p r i c e >= 24000)
Group by Product . Name ,
Store . province
Order by Product . Name ,
Store . province
Listing 3.
Simple SQL OLAP Query
depicts the sorted data of the Store dimension table for the
data cube depicted in Figure 1, while Figure 8(b) illustrates
the corresponding mapGraph for the Store dimension hier-
archy.
Each record in the mapGraph consists of two values ‚Äî a
native attribute representation (e.g., values of attribute Type
in the Store dimension) and an integer value that represents
the corresponding maximum encoded value in the primary
attribute. We will look at a concrete example. While the
city of Timmins has two stores, Store 1 and Store 2, the
city of Montreal has four stores, Store 3 through Store 6.
Using this structure, one can easily, and efÔ¨Åciently, perform
a mapping from the most detailed encoded level value (i.e.,
Store Number) to the corresponding sub-attribute value (i.e.,
attribute level values), and vice versa. For instance, Store 13
is located in the city of Anchorage and, as a consequence, in
the State of Alaska in the USA (Alaska and the USA have
a maximum Store Number = 14).
While a number of commercial products and several
research papers do support hierarchical processing for simple
hierarchies, speciÔ¨Åcally those that can be represented as a
balanced tree, mapGraph is unique in that it can enforce
linearity on unbalanced hierarchies (i.e., optional nodes), as
well as hierarchies deÔ¨Åned by many-to-many parent/child
relationships. The end result is that users may intuitively
manipulate complex cubes at arbitrary granularity levels and
can navigate easily through dimension levels.
Now recall the policy in Example 1. Suppose that Alice
sent the query in Listing 3, which summarizes the total sales
of stores in Canada for products of price 24K or more, and
whose names start with ‚ÄúLN‚Äù. To deÔ¨Åne the authorization
objects, the Below function is invoked, taking the prohibited
level (i.e., Store.Province) as an argument and using the
mapGraph to retrieve a list consisting of the speciÔ¨Åed
level and all the lower levels of the associated dimension
hierarchy (i.e., Province, City, and Store Number). Clearly,
the prohibited level is in the returned list, and as a result the
query should be rejected.
2) Implementation of the Under Function: The Under
function is invoked when the policy is less restrictive, as
is the case in Example 2. Suppose that Alice now resends
the query in Listing 3, assuming this less restrictive policy.
Figure 9.
The bitMap of Product Price and Product Name.
To answer or reject the query, we have to determine if the
user has requested access to the authorization objects. We
note that the user query has two dimension conditions, the
Ô¨Årst on Product (Product.Name = ‚ÄòLN*‚Äô AND Product.price
‚â• 24000) and the second on Store (i.e., Store.Country =
‚ÄòCanada‚Äô). The Ô¨Årst condition will be ignored, since there
is no restriction on the Product dimension in the current
policy. For the second condition, we need to determine if the
province of Quebec is in Canada (i.e., if Quebec is Under
Canada). If so, we can say that the user has attempted to
access a restricted data element and, as a consequence, the
query should be rejected. By using the Under function, we
retrieve the encoded values of Canada and Quebec from the
mapGraph structure. If there is an intersection between the
two, we know that Quebec is Under Canada. In our example,
Canada has stores encoded with identiÔ¨Åers 1 through 11, and
Quebec has stores encoded as 3 through 11. Clearly, there
is an intersection between them, which means that the user
has requested access to restricted data.
DeÔ¨Ånition 6: If
there
is
an
intersection
between
Under(Li) values ‚Äî where Li is the prohibited level ‚Äî
and Under(Ej) values ‚Äî where Ej is the requested level
‚Äî then the query should not be executed directly.
As noted, the mapGraph is very useful when hierarchical
attribute levels are involved in the OLAP query. However, in
some cases, it is a non-hierarchical attribute that is restricted
(e.g., the Name or Price attributes of Product). In this case,
the FastBit [26] bitmap index structure allows us to easily
Ô¨Ånd those records that contain speciÔ¨Åc values on a given
attribute in the dimension. For example, suppose the Product
dimension has four records (i.e., four products), numbered
1 through 4, and a non-hierarchy attribute (Product Price) is
added to the Product dimension attributes. The bitmap index
for the Product Price attribute is illustrated in Figure 9(a),
while Figure 9(b) illustrates the bitmap index for the Product
Name. Each index consists of four bit strings (number of
products), each of length four. In each string, the 1‚Äôs indicate
the encoded values for the primary key.

103
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
S e l e c t i o n :
Product . Name ,
Store . province , Sum( s a l e s )
Condition :
Store . Province = ‚Äô Quebec ‚Äô AND
( Product . Name = ‚ÄôLN‚àó ‚Äô AND
Product . p r i c e >= 24000)
From :
Sales
Listing 4.
A Query in Simple Form
Now, suppose that Alice is restricted from accessing all
products whose names start with ‚ÄúLN‚Äù. Further, we will
assume that she resends the query in Listing 3. Since the
Product Price and the Product Name are non-hierarchical
attributes, we use their bitmap indexes to retrieve the base
level numbers for those products, and then determine if there
is an intersection between the two. Figure 9 illustrates how to
identify those products whose Name starts with ‚ÄúLN‚Äù AND
whose price ‚â• 24K. The array at the lower left represents
the products of price ‚â• 24K, in this case Products 2, 3,
and 4. The array in the center represents the products with
names starting with ‚ÄúLN‚Äù. Products 1 and 2 are identiÔ¨Åed
in this case. The AND operator determines the intersection
between them, with the Ô¨Ånal result shown in the last array.
As we can see, there is in fact a non-empty intersection (i.e.,
Product Number 2 has a price ‚â• 24K and a name starts with
‚ÄúLN‚Äù); thus, the query should be rejected.
Algorithm 1 summarizes the logic of the checking pro-
cess. In short, we determine if the attributes within the selec-
tion predicate(s) are hierarchical in nature. For example, a
restriction on a time value (e.g., Day-Month-Year) would be
hierarchical in nature, while a restriction on an attribute such
as colour or weight would not be associated with any form
of hierarchy. Based upon this understanding, query values
would be analyzed relative to the information contained
in the mapGraph data structure (which stores hierarchical
relationship information) or bitmap indexes.
E. Authorization Rules
We now turn to the query authorization process itself.
As noted above, pre-compiled queries are encoded inter-
nally in XML format. For the sake of simplicity (and
space constraints), we will depict the received queries in
a more compact form in this section. For example, Listing 4
represents the same query shown in Listing 3. Note that
the query is divided into three elements: the SELECTION
element, the CONDITION element, and the FROM element.
The SELECTION element lists all attributes and measures
the user wants to retrieve. The CONDITION element, in turn,
limits or Ô¨Ålters the data we fetch from the cube. Finally, the
FROM element indicates the cube from which data is to be
retrieved.
In the discussion that follows, we will assume the ex-
istence of a cube corresponding to Figure 1. That is, the
input : The policy condition S, and the Query Q
output: Returns True if Q is valid, False otherwise
Initialize the mapGraph (hM) and the bitMap (fB)
if they have not already been initialized;
Let QA be the query attributes;
if S has a hierarchy attribute then
Let SR be the range of S using hM;
end
else
Let SR be the range of S using fB;
end
foreach attribute ai in QA do
if ai is hierarchy attribute then
Get the range of ai QR using hM;
if QR ‚à© SR Ã∏= ‚àÖ then
Return False;
end
end
else if ai is non-hierarchy attribute then
Get the range of ai QR using fB;
if QR ‚à© SR Ã∏= ‚àÖ then
Return False;
end
end
end
Return True;
Algorithm 1: The procedure of Policy Class 2
cube has three dimensions (Product, Store, and Time).
Dimension hierarchies include Product Number ‚™Ø Type ‚™Ø
Category for Product, Store Number ‚™Ø City ‚™Ø Province ‚™Ø
Country for Store, and Month ‚™Ø Year for Time. Selection
operations correspond to the identiÔ¨Åcation of one or more
cells associated with some combination of hierarchy levels.
One of the advantages of building directly upon the
OLAP conceptual model and its associated algebra is that it
becomes much easier to represent, and subsequently assess,
authorization policies. SpeciÔ¨Åcally, we may think of policy
analysis in terms of Restrictions, Exceptions, and Level
Values that form a bridge between the algebra and the
Authorization DB. There are in fact four primary policy
classes, as indicated in the following list:
1) Li Restriction + No Exception
2) Li Restriction + Exception
3) Restriction on a speciÔ¨Åc value P of level Li + no
Exception
4) Restriction on a speciÔ¨Åc value P of level Li + Excep-
tion
As mentioned, the query must be validated before execu-
tion. If validation is successful, then it can be executed as
originally speciÔ¨Åed. Otherwise, the query is either rejected
or rewritten according to a set of transformation rules. In
the remainder of this section, we describe the four policy

104
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
S e l e c t i o n :
Store . City ,
Product . Type , SUM( s a l e s )
Condition :
Time . year = 2011 AND
Store . Country = ‚Äô Canada ‚Äô AND
Product . Category = ‚Äô F u r n i t u r e ‚Äô
From :
Sales
Listing 5.
Authorization Strategy as per Rule 1
classes and the processing logic relevant to each.
1) Policy Class 1: Li Restriction + No Exception: If a
user is prohibited from accessing level Li and the user has
no exception(s), then the authorization objects consist of the
values of level Li and all the levels below it. In short, this
means that if the user query speciÔ¨Åes level Li or any of its
children in the SELECTION element, then the query should
simply be rejected. Moreover, if any value belonging to the
Li level or any of its children is speciÔ¨Åed in the CONDITION
element of the query, the query should also be rejected. The
formalization of the rule and an illustrative example is given
below.
Rule 1. If a user is prohibited from accessing the values of
level Li, and there is no exception, then the Authorization
Objects (O) = {v : v ‚àà Below(Li) }.
Example 3: If Alice sends the query depicted in Listing 5,
which summarizes the total sales of Canada‚Äôs stores in 2011
for furnitures products, and she is restricted from access-
ing/reading provincial sales, the query should be rejected.
Why is this query rejected? Recall that Alice is restricted
from accessing provincial sales. Consequently, we see that
an implicitly prohibited child level (i.e., City) is a component
of the SELECTION element. So, if we allow this query, Alice
can in fact compute the provincial sales by summing the
associated city sales.
2) Policy Class 2: Li Restriction + Exception: In this
case, the authorization objects that should be protected
consist of the prohibited level value and all values below it,
except of course for the value of the exception or any value
under it. Let us Ô¨Årst formalize this case, before proceeding
with a detailed description.
Rule 2. If a user is restricted from accessing the values of
level Li, and the user has an exception E, then the
Authorization Objects (O) = {v : v ‚àà Below(Li) -
Under(Ev) }.
As such, when a user is prohibited from accessing the Li
level ‚Äî excluding the exception values ‚Äî then the query
can be (i) allowed to execute, or (ii) modiÔ¨Åed before its
execution. Let‚Äôs look at these two cases now.
Rule 3. The query will be allowed to execute without
modiÔ¨Åcation if the prohibited level value Lv or any of its
S e l e c t i o n :
Store . province ,
Product . Type , SUM( s a l e s )
Condition :
Time . year = 2011 AND
Store . City = ‚Äô Montreal ‚Äô AND
Product . Category = ‚Äô F u r n i t u r e ‚Äô
From :
Sales
Listing 6.
Authorization Strategy as per Rule 4
more granular level values in (Below(Li)) exists in the
CONDITION element AND is equal to the exception value
(Ev) or any of its implied values in (Under(Ev)).
Example 4: Suppose that we have the following policy:
Alice is restricted from accessing provincial sales except the
sales for Canadian provinces. If Alice resubmits the query
in Listing 4, it will now be executed without modiÔ¨Åcation
because the prohibited value (e.g., Quebec) is under the
exception value (e.g., Under(Canada)).
But what if Alice has an exception value only for a more
detailed child level of Li (e.g., the city of Montreal)? In
this case, if Alice submits the previous query, it should now
be modiÔ¨Åed by replacing the restricted value (e.g., Quebec)
in the CONDITION element with the exception value (e.g.,
Montreal). In this example, Alice gets only the values that
she is allowed to see. The modiÔ¨Åed query is depicted in
Listing 6. Rule 4 gives the formalization of this case.
Rule 4. If the prohibited level value Lv or any of its more
granular level values (Under(Lv)) exists in the
CONDITION element, and the exception value belongs to
this set of values, then the query should be modiÔ¨Åed by
replacing the prohibited value with the exception value.
In addition to the scenario just described, the query
can also be modiÔ¨Åed by adding a new predicate to the
CONDITION element when the prohibited level or any of
its child levels exists in the SELECTION element only.
Rule 5. If the prohibited level Lv or any of its more
granular levels (Below(Li)) exists in the SELECTION
element only, then the query should be modiÔ¨Åed by adding
the exception E as a new predicate to the query.
Example 5: Suppose that Alice sends the query depicted
in Listing 7. In this case, the query will be modiÔ¨Åed by
adding a new predicate (i.e., Store.Province = ‚ÄôQuebec‚Äô),
because the prohibited level (i.e., City) exists in the SELEC-
TION element. After the modiÔ¨Åcation, Alice will see only the
cities of Quebec. The modiÔ¨Åed query is depicted in Listing 8.
The complete processing logic for Policy Class 2 (i.e.,
Rule 3, Rule 4, and Rule 5) is encapsulated in Algorithm 2.
Essentially, the algorithm takes the prohibited level Li
and the exception E as input and produces as output an
authorization decision to execute or modify the query. The

105
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
S e l e c t i o n :
Store . City ,
Product . Type , SUM( s a l e s )
Condition :
Time . Year = 2011 AND
Product . Type = ‚Äô Indoor ‚Äô
From :
Sales
Listing 7.
Simple OLAP Query 2
S e l e c t i o n :
Store . City ,
Product . Type , SUM( s a l e s )
Condition :
Time . Year = 2011 AND
Product . Type = ‚Äô Indoor ‚Äô AND
Store . Province = ‚Äô Quebec ‚Äô
From :
Sales
Listing 8.
Authorization Strategy as per Rule 5
process is divided into two main parts or conditions. In the
Ô¨Årst case, we are looking at situations whereby the prohibited
level Lj exists in the query CONDITION element. Here, the
query can either be allowed to execute directly or further
modiÔ¨Åed. It executes directly if the prohibited value Lv is
equal to the exception value Ev or any value under Ev.
However, if the exception value Ev is equivalent to any
value under Lv, then the query is modiÔ¨Åed by replacing the
prohibited level with the exception level AND the prohibited
level value with the exception value.
In the second case, we target the scenario whereby the
prohibited level Lj exists in the SELECTION element only.
Here, we modify the original query by adding the exception
E as a new condition.
3) Policy Class 3: Restriction on a speciÔ¨Åc value P of
level Li + no Exception: We now turn to the classes in
which speciÔ¨Åc values at a given level are restricted, as
opposed to all members at a given level. We begin with
the simplest scenario.
Rule 6. If a user is prohibited from accessing a speciÔ¨Åc
value P of level Li, and the user has no exceptions, then
the Authorization Objects(O)= {v : v ‚àà P ‚à™ Under(P)
where P is the prohibited value}.
Here, the prohibited value P, or some value under P,
exists in the query CONDITION element. As per Rule 6,
the query should simply be rejected. But what if Li exists
in the SELECTION element only? In this case, the query
should be modiÔ¨Åed by adding the prohibited value as a new
predicate to the query CONDITION element. Let‚Äôs look at
the following example.
Example 6: Suppose that Alice is restricted from ac-
cessing Quebec‚Äôs sales. If Alice sends the query depicted
in Listing 9, the query should be modiÔ¨Åed as shown in
Listing 10.
input : The prohibited level Li and the exception E
output: Decision to directly execute or modify
Let Ev = E value;
foreach level Lj ‚àà Below(Li) do
if Lj exists in the query CONDITION element
then
Let Lv = Lj value;
if Lv == Ev OR Lv ‚àà Under(Ev) then
Allow the query to execute without
modiÔ¨Åcation;
end
else if Ev ‚àà Under(Lv) then
Replace E by Lj, and Ev by Lv, then
inform the user, and allow the query to
execute;
end
end
else if Lj exists only in the query SELECTION
element then
Add E as new condition to the user query,
inform the user, and allow the query to
execute;
end
end
Algorithm 2: The procedure of Policy Class 2
S e l e c t i o n :
Store . Province , SUM( s a l e s )
Condition :
Time . year = 2011 AND
Product . Type = ‚Äô Outdoor ‚Äô
From :
Sales
Listing 9.
Simple OLAP Query 3
The associated query summarizes the sales of provinces
in 2011 for outdoor products. As noted, the SELECTION
element contains the prohibited level (Province), so instead
of rejecting the query we modify it by adding a new
predicate to the condition. The modiÔ¨Åed query returns only
the sales that Alice is allowed to see. The logic is formalized
in Rule 7 below.
Rule 7. If the prohibited level Li exists in the SELECTION
element only, then the query should be modiÔ¨Åed by adding
a new predicate to the query CONDITION element.
4) Policy Class 4: Restriction on a speciÔ¨Åc value P
of level Li + Exception: Finally, we add an exception
to the queries described by Class 3. Here, the relevant
authorization objects consist of the prohibited value (P),
minus the exception values.
Rule 8. If a user is restricted from accessing a value P of
level Li, and the user has an exception E, then the

106
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
S e l e c t i o n :
Store . Province , SUM( s a l e s )
Condition :
Time . year = 2011 AND
Product . Type = ‚Äô Outdoor ‚Äô AND
Store . Province
!=
‚Äô Quebec ‚Äô
From :
Sales
Listing 10.
Authorization Strategy as per Rule 7
S e l e c t i o n :
Store . City ,
Product . Type , SUM( s a l e s )
Condition :
Store . City = ‚Äô Montreal ‚Äô AND
Product . Type = ‚Äô Indoor ‚Äô AND
Time . Year = 2011
From :
Sales
Listing 11.
Authorization Strategy as per Rule 9
Authorization Objects(O)= {v : v ‚àà (P ‚à™ Under(P)) - (Ev
‚à™ Under(Ev))} where P is the prohibited value and E is
the exception.
In this scenario, the query can either be allowed to execute
or modiÔ¨Åed according to the following associated rules.
Rule 9. The query will be allowed to execute, if the
prohibited value Lv exists in the CONDITION element AND
is equal to the exception value Ev or any value Under(Ev).
Example 7: Suppose that Alice is restricted from access-
ing the sales of Canadian provinces, except for the sales of
Quebec. If Alice sends the Query depicted in Listing 11, the
query will be allowed to execute since the prohibited value
(i.e., Montreal) is under the exception value (i.e., Quebec).
Rule 10. If the prohibited level Li exists in the query
SELECTION element only, the query will be modiÔ¨Åed by
adding the exception E as a new predicate. In principle,
this rule is similar to Rule 4.
Rule 11. When Lv exists in the query CONDITION element
AND Lv is under Ev, the query is modiÔ¨Åed by replacing
the prohibited level Li by the exception level E AND the
prohibited level value Lv by the exception value Ev.
Algorithm 3 illustrates the full processing logic for Policy
Class 4 (Rule 8, Rule 9, Rule 10, and Rule 11). In short,
the authorization module takes the prohibited level value
P and the exception E as input and gives as output an
authorization decision to execute or modify the query. The
algorithm is again divided into two main parts. The Ô¨Årst
component targets the case whereby the prohibited value P
exists in the query CONDITION element. Here, the query
can be modiÔ¨Åed or executed directly. If the prohibited value
belongs to the set of values under E , the query is modiÔ¨Åed
by replacing the condition that contains the prohibited value
by a new one containing the exception. Conversely, the query
is allowed to execute directly if the prohibited level value
Lv belongs to the values Under(P) AND Lv is equal to the
exception value Ev OR Ev belongs to the values Under(Lv).
In the second case, a new condition (exception E) is added
to the query CONDITION element when the prohibited level
Lv or any level below it Below(Lv) exists in the SELECTION
element only.
input : The prohibited value P of level Li and the
exception E
output: Decision to directly execute or modify
Let Ev = E value;
foreach level Lj ‚àà Below(Li) do
if Lj exists in the query CONDITION element
then
Let Lv = Lj value;
if (Lv == P) AND (P ‚àà Under(Ev)) then
Add E as a new condition instead of the
condition that contains Lj, inform the
user, and allow the query to execute;
end
else if (Lv ‚àà Under(P)) AND (Lv == Ev
OR Ev ‚àà Under(Lv)) then
Allow the query to execute without
modiÔ¨Åcation;
end
end
else if Lj exists only in the query SELECTION
element then
Add E as new condition to the user query,
inform the user, and allow the query to
execute;
end
end
Algorithm 3: The procedure of Policy Class 4
F. Authorization Rule Summary
The preceding sections have formalized the authoriza-
tion framework in terms of four policy classes and their
associated transformation rules. Below, we summarize the
authorization decision in terms of its three possible outcomes
‚Äî Execute, Modify, Reject:
1) The query is allowed to execute without modiÔ¨Åcation
in two situations:
‚Ä¢ Level Li is restricted and there is an exception E:
a) If any upper level exists in the SELECTION or
PROJECTION query element, OR
b) If the Li value or any value from the levels
below it exists in the CONDITION element
AND this value is equal to the exception value
Ev or any value under it.

107
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
‚Ä¢ A speciÔ¨Åc value of Li is restricted and there is an
exception E:
a) If the prohibited value Lv or any value under
it exists in the CONDITION element AND it is
equal to the exception value Ev OR any value
under it.
2) The query is modiÔ¨Åed in one situation:
‚Ä¢ A level Li is restricted and there is an exception
E:
a) If level Li or any value from the levels below
it exists in the query SELECTION element
only, then we add the exception E as a new
condition, OR
b) If the exception value Ev belongs to the values
under Lv, then we replace the prohibited level
in the CONDITION element by the exception
E.
3) The query is rejected in two situations:
‚Ä¢ A level Li is restricted, and there is no exception:
a) If level Li or any value from a lower level
exists in the SELECTION element only, OR
b) If level Li or any value from the levels below
it exists in the CONDITION element.
‚Ä¢ A speciÔ¨Åc value P is restricted, and there is no
exception:
a) If P or any value under it exists in the CON-
DITION element.
V. EXPERIMENTAL RESULTS
Because of the potential to impact overall query resolution
time, considerable effort has been made to ensure the efÔ¨Å-
ciency of the authorization logic, including the exploitation
of compact data structures such as mapGraph and the FastBit
bitmap indexes. Moreover, the analysis of policy classes
is based primarily upon a restricted set of IF/ELSE cases
that, in turn, manipulate a small in-memory Authentication
Database. Given the motivation to include OLAP-aware
authorization mechanisms within fully functional database
management systems, however, it is important to actually
verify that our checking approach does not in fact seriously
degrade query performance. As noted earlier, the authoriza-
tion framework has been incorporated into a DBMS proto-
type speciÔ¨Åcally designed for OLAP storage and analysis.
For testing purposes, however, this integrated environment
is not necessarily ideal as it is difÔ¨Åcult for the reader to
determine if the balance between checking and execution
is reÔ¨Çective of current systems. Furthermore, it may not be
obvious that our authorization model has the potential for
integration with standard database servers.
For this reason, we have coupled our framework with
MonetDB, a popular open source database management
system [27]. MonetDB is a column store DBMS, as opposed
to the more familiar row-based systems. Column stores
are particularly well suited to OLAP workloads as the
ability to efÔ¨Åciently extract only the columns of interest
can signiÔ¨Åcantly improve IO performance. Note that in this
case, the job of MonetDB is simply to provide execution
services ‚Äî all authorization services are provided by the
subsystems deÔ¨Åned in this paper. In the current case, we
utilize the Star Schema Benchmark (SSB) [28], a variation
of the original TPC-H benchmark augmented for OLAP
settings. In short, SSB consist of a central Fact Table and
four dimension tables, with a set of 13 analytics queries
executed against the data. Queries are divided into four
query categories, with each category providing increasingly
sophisticated restrictions on the associated dimensions. A
full listing of the queries can be found in the Appendix.
The SSB is particularly valuable in the current context as it
provides a common mechanism by which to assess the kinds
of queries ‚Äî in terms of both form and complexity ‚Äî that
one would actually expect to encounter in OLAP settings. As
a Ô¨Ånal note, we stress that Monet does not provide an internal
OLAP-aware conceptual model. To ensure compatibility
with the mechanisms described throughput this paper, it
was necessary to develop SQL conversion middleware, a
signiÔ¨Åcant research effort of its own. The details of the
middleware architecture are the subject of an upcoming
submission.
For the following tests, we have used the SSB generator
(with default settings) to produce a Fact table of 180 million
records, with each dimension housing between 60,000 and
one million records. The experiments themselves were run
on a 12-core AMD Opteron server with a CPU core fre-
quency of 2100 MHz, L1/L2 cache size of 128K and 512K
respectively, and a shared 12MB L3 cache. The server was
equipped with 24 GB of RAM, and eight 1TB Serial ATA
hard drives in a RAID 5 conÔ¨Åguration. The supporting OS
was CentOS Linux Release 6.0. All OS and DBMS caches
were cleaned between runs.
A set of four simple but typical authorization policies was
created, as follows. We generated one constraint across a
full dimension (i.e., the Product.Part is restricted), a second
constraint on an attribute, along with an exception (i.e., the
attribute s region is restricted with an s province exception),
a third constraint on an attribute value with an exception
value (i.e., d year < 2009 is restricted except d year = 2005
or 2006), and the last constraint prohibits access to a cuboid
as a whole. Essentially, policies were designed in keeping
with the logic of Section IV, but adapted to the speciÔ¨Åc
attributes of the SSB schema.
In terms of the results, we have isolated each of the four
query classes and show authorization processing versus the
subsequent query execution time in Figure 10, Figure 11,
Figure 12, and Figure 13. We note that all queries violated
one or more security policies and that these violations were
identiÔ¨Åed and appropriately processes by the authorization
module (each authorization decision was manually veriÔ¨Åed

108
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
for correctness). For those that were not candidates for re-
writing (i.e., they were simply rejected), the query execution
time is still listed so as to give the reader a better sense of
the relative balance between checking and execution. A few
additional points are also worth noting. First, the ratio of
checking time to execution time varies considerably, depend-
ing on the speciÔ¨Åcation of the underlying query. In particular,
many OLAP queries are very expensive to execute, given the
amount of sorting and aggregation involved. In this case,
Query Classes 1 and 3 have restrictive selection constraints
(with the exception of the Query 3.1), thereby reducing the
size of intermediate results and, in turn, dramatically limiting
aggregation costs. Overall, execution times range from about
half a second for Query Class 3 to more than 30 seconds
for Query Class 2, where large intermediate results produce
massive aggregation costs. As the database gets larger, of
course, these execution times will continue to grow.
Second, the checking costs are quite modest, in the range
of 100-400 milliseconds. More importantly, the size of the
underlying database has no effect upon the checking costs,
as only the cube meta data is inspected. In other words, it
does not matter that 180 million records exist in the database
as authorization decisions are not based upon this data.
Rather, only schema information (e.g., cubes, dimensions,
hierarchies) and policy speciÔ¨Åcations (i.e., restrictions and
exceptions) are required during this process. In practice, it
is extremely unlikely that, from an end user‚Äôs perspective,
authorization costs would have a tangible impact on database
access and analysis.
As a Ô¨Ånal point, we re-iterate that column stores are well
suited to this environment, given their ability to minimize
I/O costs. The execution times for traditional row store
database servers can be one to two orders of magnitude
larger [29]. The authors have, in fact, evaluated the current
test cases on the open source row-based PostgreSQL DBMS
and validated these ratios. In such environments, the ratio
of checking to execution costs would be far more extreme,
with execution costs being dozens or even hundreds of times
larger than checking costs.
VI. CONCLUSIONS AND FUTURE WORK
In this paper, we have discussed a query re-writing
model to provide access control in multi-dimensional OLAP
environments. We began by deÔ¨Åning a conceptual model
that focused on the data cube and its constituent dimen-
sion hierarchies. From there we introduced the notion of
authorization objects designed to identify and constrain the
relationships between parent/child aggregation levels. We
then presented a series of rules that exploited the autho-
rization objects to decide whether user queries should be
rejected, executed directly, or dynamically and transparently
transformed. In the latter case, we identiÔ¨Åed a set of minimal
changes that would allow queries to proceed against a subset
of the requested data.
Figure 10.
Performance for SSB schema, Query 1 category
Figure 11.
Performance for SSB schema, Query 2 category
Figure 12.
Performance for SSB schema, Query 3 category

109
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 13.
Performance for SSB schema, Query 4 category
While the authentication and authorization framework
has been integrated into a prototype DBMS that provides
OLAP-speciÔ¨Åc indexing and storage, we believe that the
general principles are broadly applicable to any contem-
porary DBMS product. To this end, we combined the
framework with MonetDB, an open source DBMS that
provides efÔ¨Åcient column oriented services. Using the Star
Schema Benchmark, we showed that for common OLAP
queries, authentication and authorization services represent a
negligible impact on overall query execution and, in fact, that
there is no relationship between authorization and execution
costs. For this reason, we believe that our methods are viable
for not only OLAP-speciÔ¨Åc database management systems,
but more conventional platforms as well.
Finally, it is important to point out that the framework
presented in this paper cannot block all attempts to access re-
stricted data. In particular, it is possible for a user possessing
some degree of external knowledge to combine the results of
multiple valid queries to obtain data that is itself meant to be
protected. We refer to such exploits as inference attacks. We
are currently working on inference detection mechanisms
that will piggy back on top of the core authentication and
authorization framework to provide an even greater level of
security for OLAP data.
REFERENCES
[1] T. Eavis and A. Altamimi, ‚ÄúOLAP authentication and au-
thorization via query re-writing,‚Äù in The Fourth International
Conference on Advances in Databases, Knowledge, and Data
Applications (DBKDA), 2012, pp. 130‚Äì139.
[2] P. P. GrifÔ¨Åths and B. W. Wade, ‚ÄúAn authorization mechanism
for a relational database system,‚Äù ACM Transactions on
Database Systems, vol. 1, no. 3, pp. 242‚Äì255, Sep. 1976.
[3] Biba, ‚ÄúIntegrity considerations for secure computer systems,‚Äù
MITRE Co., technical report ESD-TR 76-372, 1977.
[4] R. Sandhu, D. Ferraiolo, and R. Kuhn, ‚ÄúThe NIST model
for role-based access control: towards a uniÔ¨Åed standard,‚Äù in
Proceedings of the Ô¨Åfth ACM workshop on Role-based access
control, ser. RBAC ‚Äô00, 2000, pp. 47‚Äì63.
[5] E. Fern¬¥andez-Medina, J. Trujillo, R. Villarroel, and M. Pi-
attini, ‚ÄúDeveloping secure data warehouses with a UML
extension,‚Äù Information Systems, vol. 32, pp. 826‚Äì856, 2007.
[6] C. Blanco, I. G.-R. de Guzman, D. Rosado, E. Fernandez-
Medina, and J. Trujillo, ‚ÄúApplying QVT in order to implement
secure data warehouses in SQL Server Analysis Services,‚Äù
Journal of Research and Practice in Information Technology,
vol. 41, pp. 135‚Äì154, 2009.
[7] J. Trujillo, E. Soler, E. Fern¬¥andez-Medina, and M. Piattini,
‚ÄúAn engineering process for developing secure data ware-
houses,‚Äù Information and Software Technology, vol. 51, pp.
1033‚Äì1051, 2009.
[8] K. Khajaria and M. Kumar, ‚ÄúModeling of security require-
ments for decision information systems,‚Äù SIGSOFT Software
Engineering Notes, vol. 36, no. 5, pp. 1‚Äì4, Sep. 2011.
[9] M. Kumar, A. Gosain, and Y. Singh, ‚ÄúStakeholders driven
requirements engineering approach for data warehouse de-
velopment,‚Äù JIPS, vol. 6, no. 3, pp. 385‚Äì402, 2010.
[10] Y. Singh, A. Gosain, and M. Kumar, ‚ÄúFrom early require-
ments to late requirements modeling for a data warehouse,‚Äù
Networked Computing and Advanced Information Manage-
ment, International Conference on, vol. 0, pp. 798‚Äì804, 2009.
[11] N. Katic, G. Quirchmay, J. Schiefer, M. Stolba, and A. Tjoa,
‚ÄúA prototype model for data warehouse security based on
metadata,‚Äù in DEXA, 1998, pp. 300‚Äì308.
[12] A. Rosenthal and E. Sciore, ‚ÄúView security as the basic
for data warehouse security,‚Äù in International Workshop on
Design and Management of Data Warehouse, 2000, pp. 8.1‚Äì
8.8.
[13] ‚Äî‚Äî, ‚ÄúAdministering permissions for distributed data: factor-
ing and automated inference,‚Äù in Proceedings of the Ô¨Åfteenth
annual working conference on Database and application
security, ser. Das‚Äô01, 2002, pp. 91‚Äì104.
[14] A. Deshpande, Z. Ives, and V. Raman, ‚ÄúAdaptive query
processing,‚Äù Foundations and Trends in Databases, vol. 1,
pp. 1‚Äì140, 2007.
[15] S. Rizvi, A. O. Mendelzon, S. Sudarshan, and P. Roy,
‚ÄúExtending query rewriting techniques for Ô¨Åne-grained access
control,‚Äù in ACM Special Interest Group on the Management
of Data, ser. SIGMOD ‚Äô04, 2004, pp. 551‚Äì562.
[16] ‚ÄúThe Virtual Private Database,‚Äù June 2012, http://www.oracle.
com/technetwork/database/security/index-088277.html.
[17] ‚ÄúMicrosoft
Analysis
Services,‚Äù
June
2012,
http://www.
microsoft.com/sqlserver/2008/en/us/analysis-services.aspx.
[18] J. Gray, A. Bosworth, A. Layman, D. Reichart, and H. Pira-
hesh, ‚ÄúData cube: A relational aggregation operator general-
izing group-by, cross-tab, and sub-totals,‚Äù Data Mining and
Knowledge Discovery, vol. 1, pp. 29‚Äì53, 1997.

110
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
[19] V. Harinarayan, A. Rajaraman, and J. Ullman, ‚ÄúImplementing
data cubes efÔ¨Åciently,‚Äù in ACM Special Interest Group on the
Management of Data, ser. SIGMOD ‚Äô96, 1996, pp. 205‚Äì227.
[20] E. Malinowski and E. Zim¬¥anyi, ‚ÄúHierarchies in a multi-
dimensional model: from conceptual modeling to logical
representation,‚Äù Data and Knowledge Engineering, vol. 59,
pp. 348‚Äì377, 2006.
[21] T. Eavis, H. Tabbara, and A. Taleb, ‚ÄúThe NOX framework: na-
tive language queries for business intelligence applications,‚Äù
in Data Warehousing and Knowledge Discovery (DaWak),
2010, pp. 172‚Äì189.
[22] ‚ÄúSQL database engine,‚Äù June 2012, http://www.sqlite.org.
[23] ‚ÄúDeÔ¨Ånition of the XML document type declaration from
Extensible Markup Language (XML) 1.0 (Fifth Edition),‚Äù
June 2012, http://www.w3.org/TR/xml/.
[24] T. Eavis and A. Taleb, ‚ÄúMapgraph: efÔ¨Åcient methods for
complex olap hierarchies,‚Äù in Proceedings of the sixteenth
ACM conference on Conference on information and knowl-
edge management, ser. CIKM ‚Äô07, 2007, pp. 465‚Äì474.
[25] V. Markl, R. Bayer, B. Forschungszentrum, and R. Bayer,
‚ÄúProcessing relational OLAP queries with UB-Trees and
multidimensional hierarchical clustering,‚Äù in In Proceedings
of DMDW 2000, 2000, pp. 5‚Äì6.
[26] M. Zaker, S. Phon-amnuaisuk, and S. cheng Haw, ‚ÄúAn ade-
quate design for large data warehouse systems: Bitmap index
versus B-tree index,‚Äù 2008.
[27] ‚ÄúMonetDB column store database engine,‚Äù June 2012, http:
//www.monetdb.org.
[28] P. O‚ÄôNeil, E. O‚ÄôNeil, X. Chen, and S. Revilak, ‚ÄúPerformance
evaluation and benchmarking,‚Äù R. Nambiar and M. Poess,
Eds., 2009, ch. The Star Schema Benchmark and Augmented
Fact Table Indexing, pp. 237‚Äì252.
[29] D. J. Abadi, S. R. Madden, and N. Hachem, ‚ÄúColumn-stores
vs. row-stores: how different are they really?‚Äù in Proceedings
of the 2008 ACM SIGMOD international conference on
Management of data, ser. SIGMOD ‚Äô08, 2008, pp. 967‚Äì980.
APPENDIX
Below, we provide a listing of the 13 queries found in the
Star Schema Benchmark.
1.
select sum(lo extendedprice*lo discount) as revenue
from lineorder, date
where lo orderdate = d datekey and
d year = 1993 and
lo discount between 1 and 3
and lo quantity < 25
1. 1)
select
sum(lo extendedprice*lo discount)
as
revenue
from lineorder, date
where lo orderdate = d datekey and
d yearmonthnum = 199401 and
lo discount between 4 and 6 and
lo quantity between 26 and 35
1. 2)
select
sum(lo extendedprice*lo discount)
as
revenue
from lineorder, date
where lo orderdate = d datekey and
d weeknuminyear = 6 and
d year = 1994 and
lo discount between 5 and 7 and
lo quantity between 26 and 35
2.
select sum(lo revenue), d year, p brand1
from lineorder, date, part, supplier
where lo orderdate = d datekey
and lo partkey = p partkey and
lo suppkey = s suppkey and
p category = ‚ÄòMFGR#12‚Äô and
s region = ‚ÄòAMERICA‚Äô
group by d year, p brand1
order by d year, p brand1
2. 1)
select sum(lo revenue), d year, p brand1
from lineorder, date, part, supplier
where lo orderdate = d datekey and
lo partkey = p partkey and
lo suppkey = s suppkey and
p brand1
between
‚ÄòMFGR#2221‚Äô
and
‚ÄòMFGR#2228‚Äô and
s region = ‚ÄòASIA‚Äô
group by d year, p brand1
order by d year, p brand1
2. 2)
select sum(lo revenue), d year, p brand1
from lineorder, date, part, supplier
where lo orderdate = d datekey and
lo partkey = p partkey and
lo suppkey = s suppkey and
p brand1 = ‚ÄòMFGR#2221‚Äô and
s region = ‚ÄòEUROPE‚Äô
group by d year, p brand1
order by d year, p brand1
3.
select c city, s city, d year, sum(lo revenue) as
revenue
from customer, lineorder, supplier, date
where lo custkey = c custkey and
lo suppkey = s suppkey and
lo orderdate = d datekey and
c nation = ‚ÄòUNITED STATES‚Äô and
s nation = ‚ÄòUNITED STATES‚Äô and

111
International Journal on Advances in Security, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/security/
2012, ¬© Copyright by authors, Published under agreement with IARIA - www.iaria.org
d year >= 1992 and
d year <= 1997
where c city, s city, d year
where d year asc, revenue desc
3. 1)
select
c nation,
s nation,
d year,
sum(lo revenue) as revenue
from customer, lineorder, supplier, date
where lo custkey = c custkey and
lo suppkey = s suppkey and
lo orderdate = d datekey and
c region = ‚ÄòASIA‚Äô and
s region = ‚ÄòASIA‚Äô and
d year >= 1992 and
d year <= 1997
group by c nation, s nation, d year
order by d year asc, revenue desc
3. 2)
select c city, s city, d year, sum(lo revenue) as
revenue
from customer, lineorder, supplier, date
where lo custkey = c custkey and
lo suppkey = s suppkey and
lo orderdate = d datekey and
(c city=‚ÄòUNITED
KI1‚Äô
or
c city=‚ÄòUNITED
KI5‚Äô) and
(s city=‚ÄòUNITED
KI1‚Äô
or
s city=‚ÄòUNITED
KI5‚Äô) and
d year >= 1992 and
d year <= 1997
group by c city, s city, d year
group by d year asc, revenue desc
3. 3)
select c city, s city, d year, sum(lo revenue) as
revenue
from customer, lineorder, supplier, date
where lo custkey = c custkey and
lo suppkey = s suppkey and
lo orderdate = d datekey and
(c city=‚ÄòUNITED
KI1‚Äô
or
c city=‚ÄòUNITED
KI5‚Äô) and
(s city=‚ÄòUNITED
KI1‚Äô
or
s city=‚ÄòUNITED
KI5‚Äô) and
d yearmonth = ‚ÄòDec1997‚Äô
group by c city, s city, d year
order by d year asc, revenue desc
4.
select d year, s nation, p category, sum(lo revenue -
lo supplycost) as proÔ¨Åt
from date, customer, supplier, part, lineorder
where lo custkey = c custkey and
lo suppkey = s suppkey and
lo partkey = p partkey and
lo orderdate = d datekey and
c region = ‚ÄòAMERICA‚Äô and
s region = ‚ÄòAMERICA‚Äô and
(d year = 1997 or d year = 1998) and
(p mfgr = ‚ÄòMFGR#1‚Äô or p mfgr = ‚ÄòMFGR#2‚Äô)
group by d year, s nation, p category
order by d year, s nation, p category
4. 1)
select
d year,
c nation,
sum(lo revenue
-
lo supplycost) as proÔ¨Åt
from date, customer, supplier, part, lineorder
where lo custkey = c custkey and
lo suppkey = s suppkey and
lo partkey = p partkey and
lo orderdate = d datekey and
c region = ‚ÄòAMERICA‚Äô and
s region = ‚ÄòAMERICA‚Äô and
(p mfgr = ‚ÄòMFGR#1‚Äô or p mfgr = ‚ÄòMFGR#2‚Äô)
group by d year, c nation
order by d year, c nation
4. 2)
select d year, s city, p brand1, sum(lo revenue
- lo supplycost) as proÔ¨Åt
from date, customer, supplier, part, lineorder
where lo custkey = c custkey and
lo suppkey = s suppkey and
lo partkey = p partkey and
lo orderdate = d datekey and
c region = ‚ÄòAMERICA‚Äô and
s nation = ‚ÄòUNITED STATES‚Äô and
(d year = 1997 or d year = 1998) and
p category = ‚ÄòMFGR#14‚Äô
group by d year, s city, p brand1
order by d year, s city, p brand1

