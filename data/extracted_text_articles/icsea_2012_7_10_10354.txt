Automated Test Code Generation Based on
Formalized Natural Language Business Rules
Christian Bacherler, Ben Moszkowski
Software Technology Research Lab
DeMontfort University
Leicester, UK
christian.bacherler@email.dmu.ac.uk, benm@dmu.ac.uk
Christian Facchi, Andreas Huebner
Institute of Applied Research
Ingolstadt University of Applied Sciences
Ingolstadt, Germany
{christian.facchi|andreas.huebner}@haw-ingolstadt.de
Abstract—The paper addresses two fundamental problems
in requirements engineering. First, the conﬂict between un-
derstandability for non-programmers and a semantically well-
founded representation of business rules. Second, the veriﬁca-
tion of productive code against business rules in requirements
documents. As a solution, a language to specify business rules
that are close to natural language and at the same time for-
mal enough to be processed by computers is introduced. For
more domain speciﬁc expressiveness, the language framework
permits customizing basic language statements, so called atomic
formulas. Each atomic formula has a precise semantics by means
of predicate and Interval Temporal Logic. The customization
feature is demonstrated by an example from the logistics domain.
Behavioral business rule statements are speciﬁed for this domain
and automatically translated to an executable representation of
Interval Temporal Logic. Subsequently, the example is utilized
to illustrate the veriﬁcation of requirements by automated test
generation based on our formalized natural language business
rules. Thus, our framework contributes to an integrated software
development process by providing the mechanisms for a human
and machine readable speciﬁcation of business rules and for a
direct reuse of such formalized business rules for test-cases.
Keywords-Requirements engineering; business rules; natural
language; testing; logic.
I. INTRODUCTION
In software development, different stakeholders with dif-
ferent knowledge and intention cooperate, typically domain
experts and developers. Requirements engineers are acting as
negotiators between these two worlds and prepare require-
ments speciﬁcations in a way that can be understood by
both sides. Nonetheless, unstructured natural language in re-
quirements documents does not ensure identical interpretations
by different readers, which has always been a fundamental
problem in software engineering [1]. Moreover, machine-
readability of a requirements document can be a big asset but
requires a formal syntax that is not provided by unstructured
natural language [2].
By the introduction of AtomsPro Rule Integration Language
(APRIL) [3], we propose a means to develop a formalized ver-
sion of business rules speciﬁcations by precise semantics that
support human- as well as machine-readability. The APRIL
statements representing business rules are easy to design and
can be customized by the construction of tailored statements, a
feature, which we introduce via a novel combination of pattern
building mechanisms. In this paper, we show how to extend
APRIL’s expressiveness using atomic formulas that constitute
the link between statements that are like natural language and
formal frameworks.
Formal speciﬁcations enhance the established software de-
velopment process (V-Model). As a general advantage, such
speciﬁcations allow consistency checking of business rules
(e.g., reveal conﬂicts or proof properties). The aspect we want
to focus on in this work is based on the fact that in the
established software development process, code and corre-
sponding tests are developed based on the natural language
speciﬁcation. In order to reduce complexity of the development
process, we support automated creation of tests based on
formal APRIL statements representing business rules. With
our method, human understandable formal speciﬁcations can
be used to directly generate formal logical conditions and
behavior speciﬁcations for testing. This approach shifts the
creation of the test code from the developer to the requirements
engineer, which helps to improve test-driven development
projects [4] [5].
The paper is structured as follows: The next Section II will
give an impression of the context and the facets of the work
presented. Section III presents the framework for our language
to describe business rules close to natural language. After
laying down the fundamentals, we demonstrate in Sec. IV
the transformation of example statements in our language into
computer processable test code. After the discussion of related
work (Section V), a conclusion will be drawn and future work
will be presented (Section VI)
II. OVERVIEW
The APRIL framework can be embedded into standard
software development processes. As an example, the seamless
integration into the V-Model is shown in Figure 1. Aspects
that will be detailed in this paper are highlighted in dark grey.
Our Framework aims at supporting the generation of com-
puter executable test code from formal speciﬁcations that are
close to natural language and thus enable the veriﬁcation of
the productive code against the original user speciﬁcation. In
Section III, a detailed explanation of the substantial concepts
of the APRIL language is given, exemplifying the formaliza-
tion of business rules as APRIL statements in Section III-A.
165
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Fig. 1.
Overview of the software development process using APRIL.
The treatment of complex real-world business rules using mix-
ﬁx notation and decomposition into reusable sub-statements
(APRIL-Deﬁnitions) is presented in Section III-B. Section
III-C deals with support for customizing parts of the language
using so-called atomic formulas. These are verbalized versions
of operations on sets, predicate-logic formulas and special
common constraints. Atomic formulas provide a precise se-
mantics for APRIL Deﬁnitions.
Tests based on APRIL statements can be generated to check
conditions using invariants, pre- and post-conditions in the
Object Constraint Language (OCL) [6] notation. Checking
process behavior is done by the use of a subset of Interval
Temporal Logic (ITL) called Tempura. The rationale for
applying our testing-framework is laid down in Section IV-A.
Section IV-B presents the testing-framework by example, tak-
ing into account the signiﬁcant concepts for deﬁning a custom
atomic formula for modeling a simple example-process and the
relation to the semantic frameworks presented in Section III-D.
This section will also include a presentation of the automated
test generation for behavior testing using Tempura. Due to
space limitations, the detailed presentation of generating OCL-
statements is omitted. Some translation examples are shown
alongside the introduction of the APRIL language.
After the discussion of related work (Section V), a conclu-
sion will be drawn and future work will be sketched (Section
VI).
III. THE APRIL FRAMEWORK - SPECIFYING BUSINESS
RULES IN FORMAL NATURAL LANGUAGE
Business rules are restrictions of certain object constella-
tions and behaviors based on domain models [2]. Typically in
software development, requirements engineers produce busi-
ness rules in natural language and hand them to develop-
ers along with the respective domain-models to enable the
development of a software-system compliant to these input
artifacts. Mostly, those natural language business rules are
informal and suffer from ambiguity and imprecision. APRIL
supports the speciﬁcation of business rules that are formal
enough to be processed by computers, but still close enough to
natural language to ensure readability and comprehensibility
for humans.
A. Business Rules in APRIL
In general, the different types of business rules in the
industrial practice are: Integrity Rules, Derivation Rules and
Rules to describe behavior [7]. Despite the fact that there are
fundamental intentional differences, these rule types have one
aspect in common: The projection of the semantics of parts
of the real world into formal representations by means of
logic. In APRIL we use UML-class models [8] to formally
represent business domain models. The reason is that the
UML-class model is widely used for representing conceptual
schemas and is easily understood by people. APRIL requires
UML-class models as the domain of discourse to specify
business rules as constraints, which are of the following
types: invariant, pre-, post-condition and behavioral rules.
Invariants describe allowed system states that must not be
violated during any point in time. This is unlike the pre-
and post-conditions, which have a restricted scope right before
and after a transition. The fourth rule type describes behavior
explicitly. Behavioral rules can describe operations lasting over
multiple state transitions [2], which is not possible with a
single pair of pre- and post-condition.
In Figure 2, a simple domain model of a car-rental system,
with the basic concepts Car, Rental and Customer, is shown
as UML-class model. As an example of APRIL usage on
the class-model, the corresponding statement for the invariant
underageCustomers can be seen in Listing I.
1
Invariant underageCustomers concerns Rental:
2
aaaAll underage customers who rent a Porsche must pay
3
aaaplus 150 percent.
Listing I
TOP-LEVEL RULE, COMPOSED OF SEVERAL APRIL DEFINITIONS.
The header (line 1) of a rule contains its name (under-
ageCustomers) and the token after the keyword concerns,
which represents the context set (represented by the class
name Rental) of the business rule to which the formula after
the colon applies. With respect to UML-models, the context
in invariant rules is represented by a class name and by a
qualiﬁed method name in the case of pre- and post-conditions
respectively. The rule body (lines 2-3) contains the actual
business rule. In order to use a natural language sentence in the
needed formal way, a couple of deﬁnitions have to be installed,
which are explained in Section III-B continuing this example.
Fig. 2.
UML-model of the car rental example.
166
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Moreover, a detailed speciﬁcation of APRIL including default
logic- and set- operators, is given in [3].
B. APRIL-Deﬁnitions
APRIL Deﬁnitions are special mix-ﬁx operators, which
allow the intuitive construction of patterns that decompose
large business rules into smaller, comprehensible and reusable
sub-statements. Mix-ﬁx is a particularly useful technique to
form natural language statements [9]. Mix-ﬁx operators allow
to compose an operator’s constants and placeholders in ar-
bitrary order. The design of the APRIL-Deﬁnition’s headers
is based on sequences of static name parts and placeholders.
Both static name parts and placeholders can be arbitrarily
composed to express a business statement reﬂected as a natural
language sentence pattern. This makes them particularly easy
to construct for humans [1].
Despite the convenience that mix-ﬁx operators provide to
humans, it is quite challenging to implement the parser logic
[10], especially for nested deﬁnition calls. The problem is that
the parser has to recognize a deﬁnition call embedded inside
an ID-token sequence in what is in the grammar speciﬁcation
another deﬁnition call (see highlighted EBNF-grammar rules
in Listing II). As a consequence, a context free grammar
provides only insufﬁcient means to specify sub ID-token
streams with a different semantics to their embedding ID-
token streams. To overcome this, we use the ANTLR v3 [11]
parser-/compiler-generator framework. The framework allows
to specify semantic annotations [12], which are actually user
deﬁned code snippets (e.g., in Java) that get inserted into the
proper positions of the grammar to guide parser decisions
based on the semantics of tokens. Consider Listing II, where
the Boolean return-values of the semantic annotations indi-
cated by α0 and α1 inﬂuence the generated parsers resolution
algorithm. The semantic annotations indicated by the symbols
αn represent java code that gets integrated into the parser.
The implemented logic performs the link between syntax and
semantics. E.g., when a token with the value Rental gets
recognized, the semantic annotation allows to conclude on
further decision steps for the parser. Or also trigger some type-
checking mechanism. However, for parsing mix-ﬁx operators,
we limit the nesting depth to three, which was shown to be
sufﬁcient in our preliminary case study.
deﬁnition::= ’Deﬁnition’ nameSignature ’yielding’
deﬁnition::= typeDef ’is deﬁned as’ ruleBody ’.’
nameSignature::= (ID | parameterDef)+
parameterDef::= ’(’ name=ID ’as’ type=ID ’)’;
typeDef::= ID | ID ’(’ typeDef ’)’;
ruleBody::= statement+ ;
statement::= ... | referenceOrDeﬁnitionCall | ...;
referenceOrDeﬁnitionCall::= {α0}modelReference
referenceOrDeﬁnitionCall:: |{α1} deﬁnitionCall | ...;
deﬁnitionCall::= ID (ID | referenceOrDeﬁnitionCall)* ;
Listing II
GRAMMAR SNIPPET FOR APRIL DEFINITIONS
Given the car rental example from Section III-A, the
APRIL-Deﬁnitions (D.1)-(D.3) decompose the business rule
statement from Listing I into reusable and easy to deﬁne sub-
statements with a signature in mix-ﬁx notation.
(D.1)
Deﬁnition All (customers as Collection(Customer)) must
pay plus (ratio as Number) per cent yielding Boolean is
deﬁned as every customer satisﬁes that contracts.amount
= contracts.car.regularPrise * (1 + ratio).
(D.2)
Deﬁnition underage customers who rent (type as Integer)
yielding Collection(Customer) is deﬁned as each cus-
tomer in all instances of Customer where customer.age
< 21 and customer.contracts.car.typeNumber=type.
(D.3)
Deﬁnition a Porsche yielding Integer is deﬁned as 911.
In (D.1), the exact offset ratio is mapped to a set of
customers. On the other hand, (D.2) is a set-comprehension on
the set of all customers deﬁning, what an underage customer
is that rents a certain car type. Furthermore, (D.3) maps an
identiﬁer-constant (911) of type integer to a name representing
the intended car type.
In order to provide a precise semantics to the Deﬁni-
tions, APRIL atomic formulas are used. They are verbal-
ized versions of operations on sets, predicate-logic formulas
and special common constraints sketched by Halpin [9]. For
example, the every-satisﬁes-that-statement of Deﬁnition (D.1)
is an atomic formula in APRIL that constitutes a universal
quantiﬁcation that is by default incorporated into the language.
Some more operators are described in [3]. Default atomic
formulas are for maintaining sufﬁcient expressive power and
straight-forward translation into executable representations.
Therefore, APRIL uses OCL as target language for translating
invariants and pre-and post conditions. Behavioral rules are
translated into Tempura, which is brieﬂy explained later.
In order to extend APRIL’s expressiveness over general pur-
pose operators provided by OCL, we allow the customization
of atomic formulas that can be tailored to a certain domain.
Moreover, this approach delegates the design of the atomic
formulas as natural language statements to the human user,
who is still the best choice for this creative task.
C. Extending APRIL with Custom Atomic Formulas
Like Deﬁnitions, customizable atomic formulas are deﬁned
using textual business patterns (bp). Here, a requirements
engineer can, e.g., reuse his already existing, informal textual
business patterns [1], which, unlike the more abstract Deﬁni-
tions, express a very basic business rule- or business process
pattern that regulates the business concepts and facts under
consideration. For example if a requirements engineer wants
to verbalize business process statements which specify that in
a warehouse all elements in a goods-stock move to a dedicated
truck-loading bay and have to pass a certain gate on their way,
she would have to specify parts of the grammar. Therefore,
a state of practice language implementation mechanism de-
scribed by Parr [12] is used. First, a formal production rule of
the new atomic formula must be speciﬁed. Formal production
rules are parts of a context-free grammar [13] and are used to
generate text recognition algorithms of a parser that processes
167
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

statements of a language to generate a parse tree. Second,
a parse tree rewrite rule has to be speciﬁed along with the
production rule. Parse tree rewrite rules are instructions for
the parser on how to construct the abstract syntax tree (AST)
from the parse tree.
The AST is a condensed version of the parse tree that can
be inﬂuenced by semantic considerations to form a concise
and expressive logical representation of the parsed statements.
For APRIL the AST provides the necessary ﬂexibility to
incorporate user deﬁned language parts and also makes it
particularly easy to extract the necessary parameters for the
compiler. For clariﬁcation, Listing III sketches the language
extension mechanisms that APRIL provides. It formalizes the
example operator that reﬂects the scenario mentioned above.
In line 1 the production rule with the name of the atomic
formula moveTo is introduced. The deﬁnition of the new
atomic formula’s regular syntax is deﬁned in the lines 2-7.
Here, the non-terminal referenceOrDeﬁnitionCall is similar to
that in Listing II. It can either refer to an element of the related
domain model (e.g., to class names Store, Bay, Gate) or to
values in the scope of the parent rule or deﬁnition, in which
the formula is used. The references to the parse tree nodes
of type referenceOrDeﬁnitionCall in the lines 3, 5 and 7 are
stored one by one in the local variables source, target and
routeNode. Line 9 concludes the speciﬁcation of the grammar
rule with the parse tree rewrite rule. It is delimited from the
syntax rule by the ”→” sign. It tells the parser to construct
a tree with the MOVETO-terminal as root node having three
leaves: source, target and routeNode.
The grammar rule and the parse tree rewrite rule in Listing
III get injected into dedicated areas of the APRIL core
grammar. Parameterization of the APRIL-compiler is straight
forward, which is depicted in Figure 3. In the second pass
a so called tree parser interprets the AST (of the rewrite
rule MOVETO) and decides, which target language template
to apply to the AST of the atomic formula. It then passes
the values of the leaf-nodes (here the values of the variables
$source, $target and $routeNode) to the parameters of the
respective template. The instantiated template is the actual
Fig. 3.
Translation example of the atomic operator moveTo.
1
moveTo :
2
’all elements in’
3
source=referenceOrDeﬁnitionCall
4
’move to’
5
target=referenceOrDeﬁnitionCall
6
’over’
7
routeNode=referenceOrDeﬁnitionCall
8
9
→ ˆa(MOVETO $source $target $routeNode);
Listing III
GRAMMAR RULE AND PARSE TREE REWRITE RULE FOR THE OPERATOR
MOVETO IN ANTLR 3.0.
translation of the atomic formula.
D. APRIL’s Target Languages
APRIL makes use of the logical frameworks OCL and
Tempura to underpin its language constituents with a well
deﬁned semantics. Both languages are brieﬂy introduced in
the subsequent sections.
1) OCL: OCL 2.3.1 is the target language for APRIL-
invariants, pre- and post- conditions. For the sake of brevity,
we give a rudimentary introduction to OCL because it is well
known. The interested reader should consult the literature on
OCL. The speciﬁcation of OCL 2.3.1 can be found on [6].
OCL restricts UML-class models using predicate logic
and operations on sets. Arithmetic-, Boolean- and relational
operators are used in the conventional way. The well known
existential and universal quantiﬁers allow to quantify on
propositions holding on an object population derived from a
class model. In order to give an idea of the OCL syntax, we
provide in Listing IV a translation into OCL of the car-rental
example mentioned earlier in Listing I and the deﬁnitions from
(D.1)-(D.3). Here, we used OCL’s decomposition mechanisms
to cater to an improved readability.
context Rental inv underageCustomers:
Customer::
All customers must pay plus ratio per cent(
aaCustomer::underage customers who rent type(
aaaaCar::a Porsche),150)
context Customer def:
All customers must pay plus ratio per cent(
aacustomers:Collection(Customer), ratio:integer) :
aaaaBoolean = customers→forAll(customer|
aaaaaacustomer.contracts.amount =
aaaaaacustomer.contracts.car.regularPrise *
aaaaaa(1+ratio))
context Customer def:
underage customers who rent type(
aatype:integer) : Collection(Customer) =
aaallInstances()→select(customer: Customer |
aaaacustomer.age < 21 and customer
aaaacontracts.car.typenumber = type)
context Car def: attr a Prosche : integer = 911
Listing IV
OCL-TRANSLATION OF THE INTRODUCTORY CAR-RENTAL-EXAMPLE
168
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

2) Tempura: Tempura is an executable subset of Interval
Temporal Logic (ITL) [14]. Like some other temporal logics,
ITL enhances predicate calculus with with a notation of dis-
crete time and associated operators. A key feature of ITL and
Tempura is that the states of a predicate are grouped together
as nonempty sequences of states called intervals σplus. They
are called intervals. For example the shortest interval (of states)
σ on a predicate P can be represented by < s > with length σ
:= |σ| = 0, which is generally the number of states in σ minus
1. The semantics of ITL keeps the interpretations of function
and predicate symbols independent of intervals. Thus, well
known operators like {+, -, *, and, or, not,...} are interpreted
in the usual way. The characteristic operator for ITL is the
operator chop ( ; ). Conventional temporal logic operators
such as next (#) and always (□) examine an interval’s sufﬁx
subintervals whereas chop splits the interval into two parts
and tests both. Furthermore, Moszkowski [14] shows how to
derive operators such as always and sometimes from chop. In
ITL, the formula w := w1; w2 is true if I⟨σ0..σi⟩ Jw1K and
I⟨σi..σ|σ|⟩ Jw2K are true in the respective sub-formulas. Note
that w1 and w2 share the same subinterval σi. We adopt some
examples from [14], which are as follows:
σ
P
R
s
1
2
t
2
1
u
3
1
The lenght of interval σ is expressed by |σ| and is deﬁned
as the number of the states in σ minus one. Thus, in our
example, |σ| = 2.
The following formulas on the predicates P and R are true
on the interval < stu >:
• P = 1. The initial value of P is 1.
• #(P) = 2 and #(#(P)) = 3. The next value of P is 2
and the next next value of P is 3.
• P = 1 and P gets P + 1. The initial value of P is 1 and
P gets increased by 1 in each subsequent state.
• R = 2 and #(□(R)) = 1 The initial value of R is 2 and
R is always 1 beginning from the next state.
• P ← 1 ; P ← P + 1 ; P ← P + 1. The formula e2 ←
e1 is true on an interval if σ0(e1) equals σ|σ|(e2). Thus,
← is called temporal assignment.
We adopt Tempura because it is able to model operations
lasting over multiple state transitions, which would not be
possible with a single pair of OCL pre- and post-conditions.
Moreover, the reader will recognize similarities with the
rationale of the test-deﬁnitions given in Section IV-A.
IV. GENERATING TEST CODE FROM APRIL
STATEMENTS
This section clariﬁes the connection between APRIL and
its target languages utilizing the moveTo-operator example
introduced earlier. Section IV-A describes the basic rationale
that inﬂuence the test framework presented in Section IV-B.
The test framework is applied to an application, which helps to
track movements of goods in a logistics centre. For testing the
correct routing, we use the example operator moveTo described
in Section III-C.
A. Testing
For generating proper test-code based on APRIL statements,
the classiﬁcation of different test types into black- and white-
box testing has to be clariﬁed. Our deﬁnition of the test types
is as follows: Each function fi in the set of functions F ::=
{f0 to fn} of a component under test (CUT) triggers a state
transition and obeys a predeﬁned signature. This signature
requires a tuple of input values (fIN) and yields a tuple of
output values (fOUT ). A signature of a function is an interface
describing a contract [15] with IN- and OUT-data, which is
speciﬁed in UML-class models. We assume that a composite
function gik is a conglomerate of some functions fi to fk, for
some natural numbers 0 <= i < k <= n. Then, any OUT-
signature of a proceeding function fj must correspond to the
IN-signature of the succeeding function fj+1, for some natural
numbers k < j <= i. This convention of the inner structure
can be formalized by OUT(fj) == IN(fj+1), which we want
to abbreviate with Dj. It represents an element of a function
sequence. Moreover, the following holds IN(gik) == IN(fi)
and OUT(gik) == OUT(fk).
A white-box test necessitates the knowledge of the entire
sequence of DD0,...,Dn as the internal structure of g (gik),
which is normally the case as the user knows the source code.
If D(g) is unknown, tests are limited to reason on the data
given by IN(g) and OUT(g), they are called black-box tests.
In APRIL black-box tests are issued to the invariants, pre- and
post-conditions.
For the speciﬁcation of behavioral models, we extend our
recent deﬁnition of white-box tests beyond reasoning on D.
We use Interval Temporal Logic (ITL) [14] for modeling
behavior in white-box-tests. Therefore, we introduce behav-
ioral constraints in APRIL, which we regard as orthogonal
to the invariants as well as pre- and post-conditions. Assume
D represents a state σ1 that maps a set of values to their
corresponding variables at one certain point in time. Then
let σ be an ordered set of states σ0 to σn, each of which
describes a different D at different subsequent, discrete points
in time. In our understanding, the knowledge of σ is sufﬁcient
for applying white-box-tests, which we want to utilize in our
framework.
B. Test Framework and Case Study
In this section, we build a representative example around
the behavioral all-elements-move-to-operator introduced in
Section III-C. The Deﬁnitions of the previous section are used
in our test framework, which deals with logistic processes
to handle the material ﬂow in a warehouse. It consists of a
simple 3-tier architecture with RFID-readers and light sensors
at the ﬁeld-level and an ERP-system at the top level. Between
these two levels, we use an RFID-middleware -Riﬁdi [16]- for
information exchange and ﬁltering.
169
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

The connection between a speciﬁcation in Tempura and a
function in the productive code is the test data. Therefore,
the user has to provide initial test data IN(f0), constituting
an important part of a test-case. The productive code affects
the data OUT(fi) in the memory for each invocation of fi,
which marks a new interval at the same time. Thus, each time a
function under test fi gets invoked a snapshot of the input data
(fIN) prior to the invocation and output data (fOUT ) when fi
is left gets generated. The test data for the Tempura-statements
is provided by recorded history-data that is stored in a properly
formatted log-ﬁle containing a condensed version of the data-
snapshots. The retrieval of the test data from the running
system is achieved via AspectJ [17]. Therefore, AspectJ point-
cut statements are generated based on the reference-nodes (see
Listing III) to class-attributes found in the AST of an APRIL
statement. The use of AspectJ permits us to leave the original
code of the productive system untouched.
The use case for the earlier mentioned example with the
behavioral operator moveTo formalized in Listing III is as
follows: Imagine a warehouse that has a high-bay storage
and a loading bay for lorries. Both, storage and lorry-bay are
connected with a conveyor belt. Each of the three components
is equipped with one RFID-reader that can detect tagged-goods
in its near ﬁeld to allow tracking whether the correct thing
takes the right path in the right direction. For a customer
order, all goods in store contained in the order must go from
the store to the lorry-bay via the conveyor belt. For simplicity
we assume that each good will be detected by exactly one
of the three RFID-readers at a time. This simpliﬁcation is
an abstraction of the real world, which does not inﬂuence
considerations regarding the presented methodology.
The described scenario can be reﬂected by a log ﬁle as
depicted in Table I, if the actual memories of the readers
holding the IDs of the tags can be accessed in the productive
application via the following reference-IDs: STORE for the
RFID-reader observing the near-ﬁeld of the storage, GATE1
for the conveyor and BAY for the lorry-bay. The data in the log
ﬁle is formatted as array with the symbolic name OUTPUT.
OUTPUT
σI
STORE
GATE1
BAY
I=1
”a”,”b”
I=2
”b”
”a”
I=3
”b”
”a”
I=4
”b”
”a”
I=5
”a”,”b”
TABLE I
REPRESENTATION OF LOG-FILE RECORDED FOR EXAMPLE-OPERATOR
With regard to the model, the Tempura statements in Listing
V hold. They are actually an instantiation of a template that
is used by the APRIL-compiler for translating the move-to-
operator if used in an APRIL statement like in Listing VI. The
formatting of the statements is according to String-Template
described by Parr [18] and contains generic parts that get ﬁlled
according to the parameters of the operator in Listing VI.
deﬁne store moves to Bay over Gate1 () = {
aalen(|OUTPUT|-1) and
aaI = 0 and
aaI gets I+1 and
aamoveAtoB(OUTPUT[I][Store], OUTPUT[I][Gate1]) and
aamoveAtoB(OUTPUT[I][Gate1], OUTPUT[I][Bay]) and
aaOUTPUT[|OUTPUT|-1] [Bay] ← OUTPUT[0] [Store]
}.
deﬁne moveAtoB (A,B) = {
aaif (|A| > 0) then {
aaaaﬁrst(A) gets last(B) and skip
aa}
}.
Listing V
TEMPLATE FOR THE ALL-ELEMENTS-MOVE-TO OPERATOR.
all elements in Store move to Bay over Gate1.
Listing VI
USAGE OF THE ALL-ELEMENTS-MOVE-TO OPERATOR.
V. RELATED WORK
SBVR-Structured-English (SE) and similarly RuleSpeak
[19] are so-called controlled languages to express business
rules in a restricted version of natural language. Both are
based on SBVR, which deﬁnes semantic parts, e.g., terms
and facts to determine business concepts and their relations.
The syntactic representation of these parts is achieved by
text formatting and coloring, which could be used to aid
parsing SE-statements. From our viewpoint, mixing technical
information with the textual representation is problematic
because formalized and natural language semantics have to
be maintained in one and the same statement. However,
natural language does not utilize text formatting information
for transporting semantics.
Nevertheless, SE is used for model representation, which
Kleiner et al. [20] utilize as a starting point for translating
schema descriptions (in SE) into UML-class models, which
is helpful for software development. Unfortunately, they leave
the treatment of business rules for further work. Regarding the
customizability aspect of business statements, the approach of
Sosunovas et al. [21] presents another way, utilizing regular
patterns. They pursue a three-step approach to constructing
business rule templates that are ﬁrst deﬁned on an abstract
level and then tailored to ﬁt a speciﬁc domain with every
further reﬁnement step. Therewith, they provide precise meta-
model-based semantics to the template elements but -as they
admit- not to the business rule resulting from using the
template.
Another interesting approach in generating tests from re-
quirements speciﬁcations is introduced by Nebut et al. [22].
They utilize UML use-case models combined with contracts
represented by pre- and post- conditions to specify sequences
of state transitions. Based on these contracts, they simulate the
modeled behavior by intentionally ”instantiating” the use case
model. This approach could be a worthy extension to ours,
which uses historical data that could also be generated by
170
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

simulation. Moreover, Nebut et al. show how to generate test-
cases from sequence diagrams and test objectives, that cater
to a deﬁned test coverage.
VI. CONCLUSION AND FUTURE WORK
With APRIL we want to provide a customizable and seman-
tically well-founded notation that is close to natural language
and suitable for humans as well as for computers. A core
design principle of APRIL is the ability to deﬁne abstract
mix-ﬁx operators that are particularly useful to deﬁne natural
language expressions as reusable patterns. We consider this
pattern building technique as sufﬁciently intuitive even for
untrained persons. The semantic underpinning of the mix-ﬁx
operators is achieved by customizable atomic formulas. The
syntax of atomic formulas can be tailor-made for any domain.
This is exempliﬁed by a new atomic formula taken from
the logistics domain to model behavior. We extend APRIL’s
grammar and present a mapping to the interpretation function
based on Interval Temporal Logic. With the use of the new
atomic formula and the transformation into the instantiated
Tempura statement, executable test code is generated. This
way our framework contributes to an integrated software
development process by providing unambiguous and under-
standable business rules that can be reused for automatically
generating tests.
From the current viewpoint, some issues are still open.
Further evaluation is needed to determine wether the speci-
ﬁcation of the grammar rules and their corresponding rewrite
rules are suitable to a typical requirements engineer. Also,
the use of OCL and especially Tempura, for creating the
templates requires a considerable amount of skills. Moreover,
using APRIL requires a basic understanding of logic and set-
theory. It has to be discovered if the aforementioned challenges
are manageable by the typical requirements engineer. Hence,
future work will target on reﬁning the presented approach with
a focus on methodologies to improve APRIL’s usability.
ACKNOWLEDGEMENTS
The authors are greatful for many hours of inspiring dis-
cussion and feedback received from Hans-Michael Windisch.
REFERENCES
[1] C. Rupp, Requirements-Engineering und -Management: Professionelle,
iterative Anforderungsanalyse f¨ur die Praxis, 5th ed.
M¨unchen and
Wien: Hanser, 2009.
[2] A. van Lamsweerde, Requirements engineering: from system goals to
UML models to software speciﬁcations.
Chichester: Wiley, 2009.
[3] C. Bacherler, C. Facchi, and H.-M. Windisch. (2010) Enhancing
Domain Modeling with Easy to Understand Business Rules. HAW-
Ingolstadt. [retrieved: 09,2012]. [Online]. Available: http://www.haw-
ingolstadt.de/ﬁleadmin/daten/allgemein/dokumente/Working
Paper/ABWP 19.pdf
[4] K. Beck, Test-driven development: by example.
Addison-Wesley
Professional, 2003.
[5] P. Liggesmeyer, Software-Qualit¨at.
Spektrum, Akad. Verl, 2002.
[6] Object
Management
Group.
(2010)
OCL
Speciﬁcation:
version
2.3.1.
[retrieved:
09,2012].
[Online].
Available:
http://www.omg.org/spec/OCL/2.3.1/PDF/
[7] J. Cabot, R. Pau, and R. Ravent´os, “From UML/OCL to SBVR speci-
ﬁcations: A challenging transformation,” Information Systems, vol. 35,
no. 4, pp. 417–440, 2010.
[8] Object Management Group. (2010) UML Speciﬁcation: version 2.2.
[retrieved: 09,2012]. [Online]. Available: www.omg.com/uml
[9] T. A. Halpin, “Verbalizing Business Rules: Part 14,” Business Rules
Journal, vol. 7, no. 4, 2006.
[10] N. Danielsson and U. Norell, “Parsing mixﬁx operators,” Proceedings
of the 20th International Symposium on the Implementation and Appli-
cation of Functional Languages (IFL 2008), 2009.
[11] T. Parr. (2012) ANTLR v3. [retrieved: 09,2012]. [Online]. Available:
http://www.antlr.org/
[12] ——, The Deﬁnitive ANTLR Reference.
Pragmatic Bookshelf, 2007.
[13] A. Aho, M. Lam, R. Sethi, and J. Ullman, Compilers: principles,
techniques, and tools.
Pearson/Addison Wesley, 2007.
[14] B. Moszkowski, Executing Temporal Logic Programs.
Cambridge,
1986.
[15] B. Meyer, “Applying Design by Contract,” Computer, vol. 25, no. 10,
pp. 40–51, 1992.
[16] Riﬁdi
Community.
(2012)
Riﬁdi-Platform.
[retrieved:
09,2012].
[Online]. Available: http://www.transcends.co/community
[17] Eclipse Open Plattform Community. (2012) AspectJ: Version 1.7.0.
[retrieved: 09,2012]. [Online]. Available: http://www.eclipse.org/aspectj/
[18] T. Parr. (2012) String Template: Version 4.0. [retrieved: 09,2012].
[Online]. Available: http://www.stringtemplate.org/
[19] Object
Management
Group.
(2008)
SBVR
Speciﬁcation:
version
1.0.
[retrieved:
09,2012].
[Online].
Available:
http://www.omg.org/spec/SBVR/1.0/
[20] M. Kleiner, P. Albert, and J. B´ezivin, “Parsing SBVR-Based Controlled
Languages,” in Model Driven Engineering Languages and Systems,
ser. Lecture Notes in Computer Science, A. Sch¨urr and B. Selic, Eds.
Springer Berlin / Heidelberg, 2009, vol. 5795, pp. 122–136.
[21] S. Sosunovas and O. Vasilecas, “Precise notation for business rules
templates,” Databases and Information Systems, 2006 7th International
Baltic Conference on, pp. 55–60, 2006.
[22] C. Nebut, F. Fleurey, Y. Le Traon, and J. J´ez´equel, “Automatic test
generation: A use case driven approach,” Software Engineering, IEEE
Transactions on, vol. 32, no. 3, pp. 140–155, 2006.
171
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

