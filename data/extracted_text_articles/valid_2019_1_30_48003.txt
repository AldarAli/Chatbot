Chameleon: The Gist of Dynamic Programming Languages
Samuele Buro
Dept. of Computer Science
University of Verona
Email: samuele.buro@univr.it
Michele Pasqua
Dept. of Computer Science
University of Verona
Email: michele.pasqua@univr.it
Isabella Mastroeni
Dept. of Computer Science
University of Verona
Email: isabella.mastroeni@univr.it
Abstract—Dynamic programming languages, such as JavaScript
and PHP, are widespread and heavily used. They provide very
useful “dynamic” features, like run-time type inference, dynamic
method calls, and built-in dynamic data structures. This makes
it hard to build static analyzers, for automatic errors discovery.
Yet, exploiting harmful behaviors in such programs, especially
in web applications, can have signiﬁcant impacts. In this paper,
we present Chameleon, a core programming language summa-
rizing the main features of the dynamic programming paradigm.
Chameleon can be useful in deﬁning, testing and comparing static
analyses, aiming at preventing bugs and errors in programs
written in dynamic programming languages. With Chameleon,
static analysis experts could deﬁne and test control mechanisms
without the burden to take in consideration the technical details
characterizing a speciﬁc real-world programming language.
Keywords–Programming language design; Dynamic program-
ming languages; Program static analysis.
I.
INTRODUCTION
In the last years, dynamic programming languages, such as
JavaScript or PHP, exponentially enhanced their popularity and
nowadays are deeply used in a very wide range of applications.
For instance, JavaScript is the de facto standard for client-side
web programming, while, on the server-side, PHP, Python, and
Ruby are the most common used languages. This success is
mainly due to the several features that such languages provide
to developers, making the writing of programs easier and faster.
Although there is no black and white distinction between
static and dynamic programming languages, the latter basi-
cally follows two main paradigms: The ﬁrst, justifying also
the adjective dynamic, is the lack of a static type system.
Dynamic programming languages still have types, but they are
checked at run-time, rather than compile-time. The absence of
strict static checks promotes the second aspect of dynamic
languages, namely a greater ﬂexibility at run-time. The basic
idea is that operations which may be statically forbidden or not
expressible in other languages should be allowed and given
some semantics, and the program execution should continue
whenever possible.
The beneﬁt of these design choices is that programmers
have a high ﬂexibility in writing code. The downside is that
errors occur at run-time and little or no information is available
for developer tools to prevent these errors statically. A static
analyzer is a tool which abstractly executes the program,
i.e., approximates all its possible behaviors. The computed
approximation is then used to detect bugs or to provide useful
information to developer tools. Examples of static analysis
comprise data-ﬂow analysis [1], invariants analysis [2] and
model-checking [3].
Due to the dynamic nature of these languages, it is, indeed,
very hard for static analysis experts to develop such control
mechanisms. In addition to the aforementioned issues, there is
the heterogeneity problem: it is not necessarily the case that
an analysis designed for a programming language works also
for the others.
Many authors [4]–[6] deﬁne their own toy language, in
order to present the analysis they are introducing or improving.
This is surely a burden for authors and, more importantly, it
does not allow comparisons between similar static analyses,
since the underling language is different.
To overcome these issues, we propose a core programming
language, called Chameleon (also typesetted as
hameleon),
summarizing the main features of dynamic programming lan-
guages. It abstracts the implementation details characterizing
each language, allowing to focus on the analysis of the
dynamic features only. Indeed, building static analyzers for
real programming languages is a very complex and time-
consuming engineering task. Having a simple language, yet
sufﬁciently expressive to model the main dynamic features,
allows to deﬁne new static analyses faster and easier.
Furthermore, Chameleon could be used as a common
ground for the deﬁnition and comparison, of static analysis
techniques, aiming at reasoning about programs written in
dynamic programming languages, without being restricted to
a particular language. Ideally, when an analysis has been
sufﬁciently tested on Chameleon, then it could be ported to the
target real-world programming language with just engineering
efforts and without losing theoretical solidity.
Outline: In Section II we describe the Chameleon lan-
guage, ﬁrst its syntax (Subsection II-A) and then its semantics
(Subsection II-B). Finally, we draw conclusions, in Section III.
II.
THE
HAMELEON LANGUAGE
Chameleon is a programming language designed speciﬁ-
cally to ease the deﬁnition of static analyses, with the focus
on dynamic features of programming languages. Its core
consists in a classic imperative language with assignments,
conditionals and iterative constructs. This latter is extended
with functions/procedures and with non-determinism. Non-
determinism is modeled by means of an input construct,
allowing programs to receive input values during execution.
Chameleon is equipped with standard basic values (booleans,
integers, rationals and strings), as well as inductive data-
structures, such as ﬁnite lists of values and ﬁnite dictionaries
(i.e., identiﬁer-value associations).
13
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

⟨prog⟩ ::= ⟨fundef⟩; ⟨com⟩
⟨fundef⟩ ::= function ⟨id⟩ ( ⟨exp⟩, ) { ⟨com⟩ }
⟨com⟩ ::=
|
skip
|
⟨id⟩ := ⟨exp⟩
|
⟨id⟩ [ ⟨exp⟩ ] := ⟨exp⟩
|
if ⟨exp⟩ then { ⟨com⟩ } else { ⟨com⟩ }
|
while ⟨exp⟩ do { ⟨com⟩ }
|
⟨com⟩ ; ⟨com⟩
|
return ⟨exp⟩
|
⟨exp⟩
⟨exp⟩ ::=
|
( ⟨exp⟩ )
|
⟨value⟩
|
⟨id⟩
|
⟨id⟩ ( ⟨value⟩, )
|
⟨exp⟩ [ ⟨exp⟩ ]
|
( ⟨type⟩ ) ⟨exp⟩
|
eval ⟨exp⟩
|
input()
|
size ( ⟨exp⟩ )
|
concat ( ⟨exp⟩ , ⟨exp⟩ )
|
charat ( ⟨exp⟩ , ⟨exp⟩ )
|
substr ( ⟨exp⟩ , ⟨exp⟩ , ⟨exp⟩ )
|
not ⟨exp⟩
|
- ( ⟨exp⟩ )
|
⟨exp⟩ ⟨bop⟩ ⟨exp⟩
⟨bop⟩ ::= * | / | + | - | <= | >= | < | > | == | not | and | or
⟨type⟩ ::= bool | int | rat | str
|
[ ]
|
[ ⟨type⟩, ]
|
[ ⟨id : type⟩, ]
⟨value⟩ ::=
|
⊥
|
b ∈ B
|
i ∈ Z
|
q ∈ Q
|
s ∈ S
|
⟨collection⟩
⟨collection⟩ ::= [ ] | [ ⟨exp⟩, ] | [ ⟨id : exp⟩, ]
⟨id⟩ ::= x ∈ X
Figure 1. The syntax of Chameleon
Concerning properly dynamic features, Chameleon is not
statically typed and it applies type coercion when needed. The
language has a (limited) reﬂection mechanism, implemented
with an eval construct. Finally, Chameleon expressions can
have side-effects.
A. Syntax
The syntax of Chameleon is speciﬁed by the context-
free grammar depicted in Figure 1. A program P ∈ ⟨prog⟩
is a list of function deﬁnitions
˙f ∈ ⟨fundef⟩; followed by
a command c ∈ ⟨com⟩, which in turn can be a standard
statement of an imperative language (like, in order, the do-
nothing command, the assignment of a variable, a list element,
or a ﬁeld, the conditional statement, the conditional loop, and
the composition), a return statement (which can be used either
to leave the execution of a function with a value or to terminate
the program when employed outside of functions body), or an
expression e ∈ ⟨exp⟩.
An expression e in Chameleon is inductively deﬁned by
the syntactic category ⟨exp⟩. Its smallest building block are
identiﬁers x ∈ ⟨id⟩ = X = { a, b, . . . , z }∗, and simple
values which consist of the undeﬁned value ⊥, the booleans
b ∈ B = { true, false }, the integers i ∈ Z, the ﬂoats
q ∈ Q, the strings s ∈ S (a string of the language is a
sequence of characters over the alphanumeric alphabet en-
closed by double quotes, e.g., , “foo”, “bar”, etc., and we
assume the Java-like syntax for characters escaping), and the
empty list []. Compound expressions are built inductively: If
e is an expression, then (e) is a parenthesized expression; If
e0, . . . , en and x0, . . . , xn are a sequence of expressions and
a sequence of identiﬁers, respectively, then [e0, . . . ,en] is a
non-empty list and [x0 :e0, . . . ,xn : en] is a dictionary; If
f ∈ X is a function name, then f(e0, . . . ,en) is a function
call with actual parameters e0, . . . , en ∈ ⟨exp⟩, whereas f() is
a function call with no arguments; If c ∈ ⟨collection⟩ is a list
or a dictionary (i.e., a collection), then c[e] is the access of an
element in c, namely, a list access or a ﬁeld access depending
on the nature of c; If t is a type, then (t) e is a cast to the type
t. The rest of the rules of the grammar are self-explanatory
and their purpose can be easily recovered by the semantic
rules given in the next section. Brieﬂy, they include the eval
statement, the input() function, and several operators for the
most common operations between values (the precedence rules
for the binary operators in ⟨bop⟩ are the standard ones, and
the associativity is always left to right).
In the following, we refer to the set of all terms T deﬁned
as the union of the sets of terms generated by each syntactic
category of the Chameleon grammar.
B. Semantics
In this section, we formally describe the operational seman-
tics of Chameleon. We start by deﬁning the concepts of ground
values, types, and state during an arbitrary step of computation,
then we provide a small-step operational semantics.
1) Ground Values and Types: Let V be the set of ground
values (with metavariable v) inductively deﬁned as the smallest
set such that { ⊥ } ∪ B ∪ Z ∪ Q ∪ S ∪ { [] } ⊆ V, and if
v0, . . . , vn ∈ V and x0, . . . , xn ∈ X, then [v0, . . . ,vn] and
[x0 : v0, . . . ,xn : vn] belong to V. Moreover, we deﬁne the
set C = L ∪ D of ground collections, where L = { l ∈ V | l =
[v0, . . . ,vn] } ∪ { [] } of ground lists and the set D = { d ∈
V | d = [x0 : v0, . . . ,xn : vn] } of ground dictionaries.
The type of a value is inductively deﬁned by the function
τ : V → ⟨type⟩⊥ as follows (see the previous section for
the meaning of the metavariables employed in the deﬁnition):
τ(⊥) = ⊥, τ(b) = bool, τ(i) = int, τ(f) = rat, and
τ(s) = str. Moreover, if l = [v1, . . . ,vn] is a (potentially
empty) ground list, then τ(l) = [τ(v1), . . . ,τ(vn)] is the type
of l, and if d = [x0 : v0, . . . ,xn : vn] is a ground dictionary,
then τ(d) = [x0 : τ(v0), . . . ,xn : τ(vn)] is the type of d. If
t, t′ ∈ τ(D), we deﬁne the equivalence relation t ∼ t′ if and
only if t′ is a permutation of t.
In the following, we refer to ⊥, bool, int, rat, and str as
simple types, and to the other as compound types. Moreover, if
14
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

t = [t0, . . . ,tn] or t = [x0 : t0, . . . ,xn : tn] is a compound
type, we deﬁne the length of t as |t| = n+1, and if t = [] then
|t| = 0. Finally, we deﬁne the partial order relation ≼ between
types: ⊥ ≼ t ≼ t for each type t, and bool ≼ int ≼ rat ≼ str;
if t = [t1, . . . ,tn] and t′ = [t′
0, . . . ,t′
n], then t ≼ t′ if and
only if ti ≼ t′
i for each i = 0 . . . n; If t = [x0 : t0, . . . ,xn : tn]
and t′ = [x0 : t′
0, . . . ,xn : t′
n], then t ≼ t′ if and only if
ti ≼ t′
i for each i = 0 . . . n or there are ˆt and ˆt′ such that
t ∼ ˆt ≼ ˆt′ ∼ t′.
2) State: Let Σ = X → V be the set of environments, and
let P = X →

⟨π, e⟩ → ⟨π′, e′⟩
PAREXP
⟨π, (e)⟩ → ⟨π′, (e′)⟩
−
PAREXP-B
⟨π, (v)⟩ → ⟨π, v⟩
−
ID
⟨π, x⟩ → ⟨π, π(x)⟩
⟨π, ei+1⟩ → ⟨π′, e′
i+1⟩
FUNCALL
⟨π, f(v1, . . . , vi, ei+1, . . . , en)⟩ → ⟨π′, f(v1, . . . , vi, e′
i+1, . . . , en)⟩
−
FUNCALL-B1
ρ(f) = ⊥
⟨π, f(v1, . . . , vn)⟩ → ⟨π, ⊥⟩
−
FUNCALL-B2
ρ(f) = ((x1, . . . , xm), c) ∧ n ≥ m
⟨π, f(v1, . . . , vn)⟩ → ⟨π ◃ { x1
7→
v1, . . . , xm
7→
vm }, c⟩
−
FUNCALL-B3
ρ(f) = ((x1, . . . , xm), c) ∧ n < m
⟨π, f(v1, . . . , vn)⟩ → ⟨π ◃ { x1
7→
v1, . . . , xn
7→
vn }, c⟩
⟨π, e⟩ → ⟨π′, e′⟩
CAST
⟨π, (t) e⟩ → ⟨π′, (t) e′⟩
−
CAST-B
⟨π, (t) v⟩ → ⟨π, ,→t (v)⟩
⟨π, e⟩ → ⟨π′, e′⟩
EVAL
⟨π, eval e⟩ → ⟨π′, eval e′⟩
−
EVAL-B1
∃ ˆP ∈ ⟨prog⟩ . v = “P ”
⟨π, eval v⟩ → ⟨π, ˆP⟩
−
EVAL-B2
∄ ˆP ∈ ⟨prog⟩ . v = “P ”
⟨π, eval v⟩ → ⟨π, ⊥⟩
−
INPUT
∀s ∈ S
⟨π, input()⟩ → ⟨π, s⟩
Figure 2. Small-step semantics of Chameleon expressions.
ﬂow from one type to another when needed. Suppose that
⊗ ∈ ⟨bop⟩ is deﬁned for integers and rationals and let us
denote by ⊗int : V2
int → Vint and ⊗rat : V2
rat → Vrat the typed
versions of ⊗. Consider the expression v⊗v′ for two arbitrary
ground values: The goal is to get a value v′′ = v ⊗ v′ in
a way that depends only on the set of types on which ⊗ is
deﬁned. For instance, if ⊗ = *, we want to provide a meaning
to expressions like (true * “a”), (5 * false), etc. Note that
computing v′′ is not a trivial task, especially when seeking a
general method.
The strategy implemented in the Chameleon interpreter is
based on the previously deﬁned partial order ≼ on types. The
algorithm for the computation of v′′ is described as follows:
1)
We compute the set of types on which ⊗ is deﬁned,
namely dom(⊗) = { ⊥ }∪{ int, rat }∪τ(L)∪τ(D).
By this deﬁnition, every operator is deﬁned on the
undeﬁned type in a vacuous manner, and inductively
on compound types. More precisely, this means that
⊥ ⊗ v = v ⊗ ⊥ = ⊥, and if v0, v′
0 . . . , vn, v′
n is a se-
quence of values, then [v0, . . . ,vn]⊗[v′
0, . . . ,v′
n] =
[v0 ⊗ v′
0, . . . ,vn ⊗ v′
n] and similarly for dictionary
values;
2)
We reﬁne dom(⊗) in order to get all the types
greater than τ(v) or τ(v′), namely dom(⊗) = { t ∈
dom(⊗) | t ≥ τ(v) ∨ t ≥ τ(v′) }, and the types
lower than τ(v) or τ(v′), namely dom(⊗) = { t ∈
dom(⊗) | t ≤ τ(v) ∨ t ≤ τ(v′) };
3)
We compute the least upper bound between (i)
the greatest lower bound of dom(⊗) and (ii)
the least upper bound of dom(⊗), namely t =
W{ ∧ dom(⊗), ∨ dom(⊗) };
4)
The result of the computation is deﬁned as v′′ =
v ⊗t v′.
The rules for computing the result of a binary operation are
now trivial. Firstly, we evaluate left-to-right the expressions in
the operation until values are obtained:
⟨π, e1⟩ → ⟨π′, e′
1⟩
EXP-L
⟨π, e1 ⊗ e2⟩ → ⟨π′, e′
1 ⊗ e2⟩
⟨π, e2⟩ → ⟨π′, e′
2⟩
EXP-R
⟨π, v ⊗ e2⟩ → ⟨π′, v ⊗ e′
2⟩
Then, we compute the result applying the algorithm described
above:
−
EXP-B
⟨π, v ⊗ v′⟩ → ⟨π′, v′′⟩
where v′′ = v ⊗t v′ and t = W{ ∧ dom(⊗), ∨ dom(⊗) }.
16
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

Commands
and
Return
Statement:
Since
most
of
Chameleon commands are common to the majority of the
imperative languages, we only discuss here the rule of the
return statement, and we redirect the reader to [8] for a detailed
explanation of the other commands.
When a return e statement is met, the expression e is
evaluated in order to obtain a value v:
⟨π, e⟩ → ⟨π′, e′⟩
RET
⟨π, return e⟩ → ⟨π′, return e′⟩
Then, the following rule returns the value v and restores
the bindings existing previously of the function call:
−
RET-B
⟨π, return v⟩ → ⟨π, v⟩
III.
CONCLUSION
In this paper, we have presented Chameleon, a minimal
language capturing the main features of dynamic programming
languages. In particular, it is an imperative non-deterministic
language with functions/procedures and built-in inductive data-
structures, such as ﬁnite lists and ﬁnite dictionaries. Concern-
ing the dynamic features, Chameleon is not statically typed,
with a mechanism for type coercion. It supports (limited)
reﬂection, implemented by means of an eval-like construct,
and expressions can have side-effects.
The aim of Chameleon is to provide a common ground
for static analyses developers, in order to easily deﬁne and
test their control mechanisms. To build an analyzer for a real-
world programming language is a complex engineering task.
Chameleon abstracts all the technical details characterizing
each language, allowing developers to focus on the analysis
of dynamic features only and, hence, to deﬁne new analyses
in a faster and simpler way. Furthermore, comparing similar
control mechanisms, but built for different languages, is tricky.
With Chameleon, is it possible to solve also this issue, since
the analyses share the same underling language.
As
a
ﬁnal
remark,
the
interested
reader
can
ﬁnd
the implementation of Chameleon at the following link:
https://github.com/samueleburo93/chameleon.
REFERENCES
[1]
G. A. Kildall, “A uniﬁed approach to global program optimization,” in
Proceedings of the 1st Annual ACM SIGACT-SIGPLAN Symposium on
Principles of Programming Languages, ser. POPL ’73, 1973, pp. 194–
206.
[2]
P. Cousot and R. Cousot, “Abstract interpretation: A uniﬁed lattice model
for static analysis of programs by construction or approximation of ﬁx-
points,” in Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium
on Principles of Programming Languages, ser. POPL ’77, 1977, pp. 238–
252.
[3]
E. M. Clarke, E. A. Emerson, and A. P. Sistla, “Automatic veriﬁcation
of ﬁnite-state concurrent systems using temporal logic speciﬁcations,”
ACM Trans. Program. Lang. Syst., vol. 8, 1986, pp. 244–263.
[4]
V. Arceri and S. Maffeis, “Abstract domains for type juggling,” Electr.
Notes Theor. Comput. Sci., vol. 331, 2017, pp. 41–55.
[5]
S. Buro and I. Mastroeni, “Abstract code injection - A semantic ap-
proach based on abstract non-interference,” in Proceedings of the 19th
International Conference on Veriﬁcation, Model Checking, and Abstract
Interpretation, ser. VMCAI ’18, 2018, pp. 116–137.
[6]
I. Mastroeni and M. Pasqua, “Statically analyzing information ﬂows: An
abstract interpretation-based hyperanalysis for non-interference,” in Pro-
ceedings of the 34th ACM/SIGAPP Symposium on Applied Computing,
ser. SAC ’19, 2019, pp. 2215–2223.
[7]
G. D. Plotkin, “A structural approach to operational semantics,” Journal
of Logic and Algebraic Programming, vol. 60-61, 2004, pp. 17–139.
[Online]. Available: http://dx.doi.org/10.1016/j.jlap.2004.05.001
[8]
M. Hennessy, The Semantics of Programming Languages: An Elemen-
tary Introduction Using Structural Operational Semantics.
New York,
NY, USA: John Wiley & Sons, Inc., 1990.
[9]
G. D. Plotkin, “A powerdomain for countable non-determinism,” in Pro-
ceedings of the 9th International Colloquium on Automata, Languages
and Programming, 1982, pp. 418–428.
17
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-755-9
VALID 2019 : The Eleventh International Conference on Advances in System Testing and Validation Lifecycle

