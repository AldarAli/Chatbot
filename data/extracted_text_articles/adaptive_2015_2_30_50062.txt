A Conceptual Framework for Guiding the Development of Feedback-Controlled Bulk
Data Processing Systems
Martin Swientek
Paul Dowland
School of Computing and Mathematics
Plymouth University
Plymouth, UK
e-mail: {martin.swientek, p.dowland}@plymouth.ac.uk
Bernhard Humm
Udo Bleimann
Department of Computer Science
University of Applied Sciences Darmstadt
Darmstadt, Germany
e-mail: {bernhard.humm, udo.bleimann}@h-da.de
Abstract—The design, implementation and operation of an adap-
tive enterprise software system for bulk data processing differs
from common approaches to implement enterprise systems.
Different tasks and activities, different roles with different skills
and different tools are needed to build and operate such a system.
This paper introduces a conceptual framework that describes the
development process of how to build an adaptive software for bulk
data processing. It deﬁnes the needed roles and their skills, the
necessary tasks and their relationship, artifacts that are created
and required by different tasks, the tools that are needed to
process the tasks and the processes, which describe the order of
tasks.
Keywords–adaptive middleware; software development process
I.
INTRODUCTION
Enterprise Systems for bulk data processing are increas-
ingly required to provide near-time processing of data to
support new service offerings.
Traditionally, enterprise systems for bulk data processing
are implemented as batch processing systems [1]. Batch pro-
cessing delivers high throughput but cannot provide near-time
processing of data, that is the end-to-end latency of such a
system is high.
A lower end-to-end latency can be achieved by using
single-event processing, for example by utilizing a message-
oriented middleware for the integration of the services that
form the enterprise system. While this approach is able to
deliver near-time processing, it is hardly capable for bulk data
processing due to the additional communication overhead for
each processed message. Therefore, message-based processing
is usually not considered for building a system for bulk data
processing requiring high throughput [2].
The processing type is usually a ﬁxed property of an
enterprise system that is decided when the architecture of
the system is designed, prior to implementing the system.
This choice depends on the non-functional requirements of
the system. These requirements are not ﬁxed and can change
over time.
Additionally, enterprise systems often need to handle load
peaks that occur infrequently. When the system faces moderate
load, a low end-to-end latency of the system is preferable.
During the peak load, it is more important that the system
can handle the load at all. A low end-to-end latency is not
as important as an optimized maximum throughput in this
situation.
For example, a billing system for a telecommunication
carrier with moderate load over most of the time, but there
are certain events with very high load such as New Year’s
Eve. Most of the time, a low end-to-end latency of the system
is preferable when the system faces moderate load. During the
peak load, it is more important that the system can handle the
load at all. A low end-to-end latency is not as important as an
optimized maximum throughput in this situation.
In [2], we have introduced the concept of a middleware
that is able to adapt its processing type ﬂuently between batch
processing and single-event processing. By adjusting the data
granularity at runtime, the system is able to minimize the end-
to-end latency for different load scenarios.
The design, implementation and operation of such a system
differs from common approaches to implement enterprise
systems:
•
There are speciﬁc activities or tasks needed to imple-
ment the feedback-control subsystem.
•
There are roles needed with different skills.
•
There are different tools needed to aid the design and
development of such a system.
Developing software is a complex process, the quality of a
software product depends on the people, the organization and
procedures used to create and deliver it [3].
This paper introduces a conceptual framework to guide the
design, implementation and operation of an adaptive system
for bulk data processing. It deﬁnes views, roles, tasks and their
dependencies, and processes to describe the necessary steps for
design, implementation and operation of an adaptive system for
bulk data processing.
Figure 1 shows an overview of the conceptual framework.
It is organized among the phases plan, build and run. Each
phase contains tasks, which are relevant for each phase:
37
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

•
Plan
The plan phase contains tasks relevant for the analysis
and design of the system, such as the deﬁnition of
the service interfaces, deﬁnition of the integration
architecture and deﬁnition of performance tests.
•
Build
The build phase contains tasks relevant for the imple-
mentation of the system, such as the implementation
of services, implementation of the integration layer
and the implementation of the feedback-control sub-
systems.
•
Run
The run phase contains tasks relevant to the operation
of the developed system, such as monitoring, setup
and tuning.
Plan
Test
Project Management
Business Architecture
Service 
Deﬁnitions
Aggregation 
Rules
System Architecture
Integration 
Architecture
Routing Rules
Controller 
Design
Training
Build
Integration
Tuning
Run
Monitoring
Setup
Performance 
Management
Performance 
Tests
Evaluation
Stafﬁng
Tuning
Project 
Environments
Services
Routing
Aggregation
Feedback 
Control
Figure 1.
Overview of Conceptual Framework
The conceptual framework only describes concepts that
are speciﬁc to the design and implementation of an Adaptive
Middleware as described in the previous chapter. It does not
describe common concepts for software development.
The remainder of this paper is organized as follows. Section
II brieﬂy introduces the concept of an adaptive middleware for
bulk data processing. The conceptual framework is presented
in Section III. Section IV gives an overview of other work
related to this research. Finally, Section V concludes the paper
and gives an outlook to the next steps of this research.
II.
BACKGROUND
This section brieﬂy introduces the concept of an adaptive
middleware, which is able to adapt its processing type ﬂuently
between batch processing and single-event processing.
The middleware continuously monitors the load of the
system and controls the message aggregation size. Depending
on the current aggregation size, the middleware automatically
chooses the appropriate service implementation and transport
mechanism to further optimize the processing [2].
Figure 2 shows an overview of the adaptive middleware
and its components.
The components of the middleware are based on the
Enterprise Integration Patterns described by [4], as shown in
Table I.
TABLE I
COMPONENTS OF THE ADAPTIVE MIDDLEWARE. WE ARE USING THE
NOTATION DEFINED BY [4]
Symbol
Component
Description
Message
A single message representing a
business event.
Message Aggregate
A set of messages aggregated by the
Aggregator component.
Queue
Storage
component
which
stores
messages using the FIFO principle.
Aggregator
Stateful ﬁlter which stores correlated
messages until a set of messages is
complete and sends this set to the
next processing stage in the messag-
ing route.
Router
Routes messages to the appropriate
service endpoint.
Service
Endpoint
Service Endpoint
Represents a business service.
To control the level of message aggregation at runtime, the
middleware uses a closed feedback loop with the following
properties (see Figure 3):
•
Input (u): Current aggregation size
•
Output (y): Change of queue size measured between
sampling intervals
•
Set point (r): The change of queue size should be
zero.
Preliminary tests show that the proposed middleware solu-
tion is viable and is able to optimize the end-to-end latency of
a data processing system for different load scenarios [2].
III.
CONCEPTUAL FRAMEWORK
The design, implementation and operation of a system
based on the adaptive middleware introduced in Section II
differs from common approaches to implement enterprise
systems. We have therefore developed a conceptual framework
to describe a development process how to build such a system.
A. Metamodel
The conceptual framework consists of the following enti-
ties, as shown in Figure 4:
•
Phase
Phases correspond to the different phases of a software
development lifecycle, such as design, implementation
and operations and contain the relevant tasks.
•
Task
Tasks represent the activities of the development pro-
cess. A task
38
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

S1
Endpoint A
S1
Endpoint B
Aggregator
Router
Queue
Queue
Queue
Messages
Message
Aggregate
Figure 2.
Overview of the adaptive middleware for bulk data processing [2]
◦
is contained in a phase
◦
is processed by a role
◦
produces and requires artifacts
◦
uses tools
•
Role
Roles represent types of actors with the needed skills
to process speciﬁc tasks.
•
Artifact
An artifact represents the result of a tasks. Addition-
ally, an artifact is a requirement of a tasks.
•
Tool
A tool is used by a tasks to produce its artifact.
•
Process
A process contains an ordered list of tasks that need
to be processed in a certain order.
B. Roles
Roles represent the actors, which process tasks, that is,
they describe who does something. The description of a role
contains its responsibilities and needed skills. A role is not the
same as a person, a single person can have multiple roles and
change the role according to the context of the current task.
The conceptual framework deﬁnes the following roles:
•
Business Architect
The Business Architect is responsible for designing
the business architecture of the system, including the
deﬁnition of services and aggregation rules.
•
System Architect
The System Architect is responsible for designing
the technical architecture of the system, including the
integration and controller architecture.
•
Software Engineer
The Software Engineer is responsible for the imple-
mentation of the system, including the implementation
and tuning of the feedback-control loop.
Controller
System
y = Net change of queue size
r = 0
e = r-y
u = Aggregation size
Figure 3.
Feedback loop to control the aggregation size
•
Test Engineer
The Test Engineer is responsible for deﬁning and
performing the performance tests of the system.
•
Operations Engineer
The Operations Engineer is responsible for operating
the system, including setup, deployment and monitor-
ing.
•
Project Manager
The Project Manager is responsible for the project
coordination, including the stafﬁng and planing of the
required environments.
A role is described by the following attributes:
•
Name
The name of the role.
•
Description
Description of the responsibilities of the role.
•
Tasks
The tasks the role is responsible to process.
•
Needed skills
The skills the role has to have in order to successfully
process its tasks.
Task
Role
Artifact
Phase
Tool
processes
uses
contains
1..*
1..*
1..*
1..*
1..*
1..*
1
1
1..*
1..*
produces
requires
Process
1..*
1..*
contains
Figure 4.
Metamodel
C. Tasks
Tasks are the main entities of the conceptual framework. A
Tasks describes what should be done, why should it be done,
39
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

and who should do it. Additionally, it describes the required
and produced artifacts, the tools that should be used to process
the task and the expected challenges.
Tasks depend on each other, some tasks must be processed
in a certain order. A task can have multiple subtasks.
The Conceptual Framework only describes tasks that are
speciﬁc to the design and implementation of an Adaptive
Middleware for Bulk Data Processing as described in [2]. It
does not describe common tasks or activities that are needed
for every software system.
Figure 5 shows an overview of the tasks grouped by the
different phases of the Conceptual Framework.
Plan
Project Management
Business Architecture
Deﬁne
Service 
Interfaces
Deﬁne
Aggregation 
Rules
System Architecture
Deﬁne
Integration 
Architecture
Deﬁne
Routing 
Rules
Deﬁne
Controller 
Architecture
Deﬁne
Training 
Concept
Build
Implement 
Integration 
Architecture
Implement 
Service 
Interfaces
Implement 
Routing 
Rules
Implement 
Aggregation 
Rules
Implement 
Feedback-
Control
Perform 
Controller 
Tuning
Run
Setup 
Monitoring 
Infrastructure
Setup Test 
Environment
Perform 
Performance 
Tests
Test
Deﬁne
Performance 
Tests
Evaluate Test 
Results
Perform 
Stafﬁng
Source 
Project 
Environments
Figure 5.
Overview of tasks
A Task is described by the following attributes:
•
Name
The name of the task.
•
What
Describes the content of the task.
•
Why
Describes the purpose of the task.
•
Who
Describes the roles, that are responsible for processing
the task.
•
Input
The required artifacts of the task.
•
Output
The artifacts produced by the task.
•
Tools
The tools that are needed to process the task.
•
Challenges
Describes the expectable challenges when processing
the task.
D. Processes
A process contains an ordered list of tasks that are
concerned with the implementation of a certain feature of
the software system. Processes are modeled using Uniﬁed
Modelling Language (UML) activity diagrams. The conceptual
framework describes the following processes:
•
Implement Integration
•
Implement Aggregation
•
Implement Feedback-Control
1) Implement Integration: This process describes the nec-
essary tasks to implement the integration layer and the in-
tegrated service interfaces, as shown in the UML activity
diagram in Figure 6.
Figure 6.
UML Activity Diagram: Implement Integration
2) Implement Aggregation: This process is concerned with
the implementation of the message aggregation, as shown in
the UML activity diagram in Figure 7.
Figure 7.
UML Activity Diagram: Implement Aggregation
3) Implement Feedback-Control:
This process contains
tasks that are concerned with the design, implementation and
tuning of the feedback-control loop, as shown in Figure 8.
40
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

Build
Plan
Implement 
Feedback-
Control
Measure 
System 
Characteristics
Perform 
Static Tests
Perform Step 
Tests
Perform 
Controller 
Tuning
<includes>
<includes>
<includes>
<includes>
Deﬁne Input/
Output 
Variables
Deﬁne 
Control 
Problem
Deﬁne 
Control 
Architecture
<includes>
<includes>
<includes>
Implement 
Control 
Architecture
<includes>
Implement 
Controller
Implement 
Sensors
Implement 
Actuator
<includes> <includes> <includes>
Perform 
System 
Identiﬁcation 
and Modelling
<includes>
Figure 8.
Tasks for implementing the feedback-control loop
There are two options for implementing the feedback-
control loop:
•
Using a system model for performing the controller
tuning, as shown in the UML activity diagram in
Figure 9.
•
Without using a model, the control architecture needs
to be implemented prior to the controller tuning, as
shown in the UML activity diagram in Figure 10.
E. Artifacts
An artifact is a result of a task. It is an intermediate result,
that is needed for development of the software, but not the
software product itself. Additionally, it can also be prerequisite
of another task.
The conceptual framework deﬁnes the following artifacts:
•
Performance Requirements
Deﬁnes the requirements regarding the performance of
the system, such as required maximum throughput, re-
quired maximum latency or desired minimum latency.
Deﬁnes the workload scenarios of the system.
•
Service Interface Deﬁnition
Deﬁnes the structure of input and output data. Does
not include informations about the technical format,
such as Extended Markup Language (XML) or
JavaScript Object Notation (JSON), and the integra-
tion style, such SOAP or Representional State Transfer
(REST).
•
Aggregation Rules
Deﬁnes how events should be correlated with each
other by the Aggregator.
•
Integration Architecture
Deﬁnes the technical integration of the business ser-
vices, including Middleware technology or product,
transports, such as Java Messaging Service (JMS),
SOAP or File Transfer Protocol (FTP), Technical
format of the input and output data, such as XML
or JSON, Comma Separated Values (CSV) or binary
formats.
Figure 9.
UML Activity Diagram: Implement Feedback-Control Loop using
a model
•
Routing Rules
Deﬁnes which service endpoint should be called by
the Router for a given aggregation size.
•
System Model
The system model is used to build a simulation of
the system which can be used for implementing the
controller.
•
Controller Conﬁguration
The controller conﬁguration speciﬁes the parameter of
the Controller.
•
Training Concept
Deﬁnes the training concept, including the audience,
the content and the type of training. Additionally it
contains a time-plan, learning modules and needed
facilities to conduct the training.
•
Stafﬁng Plan
Deﬁnes the required team members and their utiliza-
tion over the project time (stafﬁng curve), the required
41
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

Figure 10.
UML Activity Diagram: Implement Feedback-Control Loop without using a model
roles and their assignment to team members and a
skill matrix that shows the required skills and the
knowledge of each team member.
An artifact is described by the following attributes:
•
Name
The name of the artifact.
•
Description
A description of the artifact.
•
Task
The task that produces the artifact.
•
Role
The role that is responsible for producing the artifact.
IV.
RELATED WORK
This section discusses work related to the conceptual
framework presented in this paper. It introduces the terms Soft-
ware Process and Software Process Modelling and discusses
approaches to model the software process using UML.
A. Software Process
“The software process is a partially ordered set of activ-
ities undertaken to manage, develop and maintain software
systems.” [5]
McChesney [6] describes the software process as “col-
lection of policies, procedures, and steps undertaken in the
transformation of an expressed need for a software product
into a software product to meet that need.”.
Another similar deﬁnition comes from Fugetta [3]. He
deﬁnes the software process as the “coherent set of policies, or-
ganizational structures, technologies, procedures, and artifacts
that are needed to conceive, develop, deploy, and maintain a
software product.”
It is necessary to differentiate between the terms software
process and software lifecycle. A software lifecycle describes
the states through which the software passes from the start of
the development until the operation and ﬁnally the retirement.
[7] Examples of software lifecycle models are the waterfall
model [8] or the spiral model [9].
42
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

B. Software Process Modelling
Software process modelling describes the creation of soft-
ware development models [5]. A software process model is
“an abstract representation of a process architecture, process
design or process deﬁnition, where each of these describe, at
various levels of detail, an organization of process elements
of either a completed, current or proposed software process”
[10].
Process models are described using Process Modelling
Languages (PMLs). A PML is deﬁned in terms of a nota-
tion, a syntax and semantics, often suitable for computational
processing [11].
Typical elements of PMLs are (see for example [12] [5]
[3] [13]):
•
Agent or Actor
•
Role
•
Activity
•
Artifact or Product
•
Tools
Process Models commonly use different perspectives to
describe the software process [13]:
•
Functional: what activities are being performed
•
Behavioral: In which order (when) are activities per-
formed
•
Organizational: where and by whom is an activity
performed
•
Informational: the entities produced by the process
Examples of software process models include the IEEE
and ISO standards IEEE 1974-1991, ISO/IEC 12207 and the
Rational Uniﬁed Process (RUP).
C. Software Process Modelling using UML
UML is commonly used for modelling software processes.
UML for Software Process Modelling (UML4SPM) is an
UML-based metamodel for software process modelling [11]
[14]. It takes advantages of the expressiveness of UML 2.0
by extending a subset of its elements suitable for process
modelling. UML4SPM contains two packages. The process
structure package, which contains the set of primary process
elements and the foundation package, which contains the
subset of UML 2.0 concepts extended by this process elements
to provide concepts and mechanisms for the coordination and
execution of activities.
Software & System Process Modelling Metamodel (SPEM)
2.0 is a metamodel for modeling software development pro-
cesses and a conceptual framework, which provides concepts
for for modeling, documenting, presenting, managing, inter-
changing, and enacting development methods and processes
[15]. It provides a clear separation between method content, for
example deliverables and key roles, and workﬂows supporting
different software lifecycle models. The SPEM 2.0 metamodel
consists of seven main metamodel packages, with each pack-
age extending the package it depends on.
Both approaches, UML4SPM and SPEM 2.0 extend the
UML 2.0 notation with additional elements, which does not
allow the usage of standard UML tools.
[16] use UML 2.0 for modelling software processes at
Siemens AG. According to the authors, the usage of standard
UML 2.0 notation, which is supported by standard modelling
tools, increases readability of processes for software developers
since UML is also used for modelling the software itself. They
describe four distinct process views, that are described by
UML activity diagrams, class diagrams and use-case diagrams:
process-oriented, activity-oriented, product-oriented, and role-
oriented. The following UML diagram types are used by their
approach:
The conceptual framework for feedback-controlled systems
for bulk data processing presented in this chapter is based on
the properties of the described approaches in this section for
modelling the software development process. It uses standard
UML use-case and activity diagrams for describing tasks and
processes for the following reasons:
•
Understandability
Using standard UML 2.0 notation elements and dia-
grams facilitate the understanding of the conceptual
framework since they are commonly used by software
engineers for the design of the software system itself.
•
Tool support
Standard UML 2.0 notation elements and diagrams are
supported by a wide range of modelling tools.
Standard metamodels for software process modelling such
as SPEM 2.0 have not been used because they seemed to
heavyweight for the intended purpose.
D. Software Processes for Adaptive Software Systems
It has been understood that software processes need to be
reconceptualised to engineer self-adaptive software systems
(see for example [17] [18] [19] [20]). Self-adaptive systems
adjust their behavior automatically to respond to changes in
their context and requirements. Activities that are traditionally
done at development-time need to be shifted to run-time.
Additionally, some activities that are previously performed by
software engineers are now performed by the system itself. In a
way, the role of the human software engineer is to some extend
shifted from operational to strategic. The engineer implements
the adaption mechanisms, the adaption itself is performed by
system.
[20] extend the SPEM metamodel to specify which
activities should be performed off-line and on-line and the
dependencies between them. They distinguish between off-
line activities, manual activities that are performed externally
at development-time and on-line activities, that are performed
internally at run-time, by the system itself, for example evo-
lution and adaption activities performed by the adaption logic
of the system. The authors argue, that on-line activities must
be explicitly reﬂected in software process models, since they
are not independent from off-line activities. In addition to on-
line activities, on-line roles and work products also need to be
43
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

addressed by process models. To meet this requirements, they
extend the SPEM metamodel with
•
On-line and off-line stereotypes to deﬁne whether an
activity should be performed on-line or off-line
•
Dependencies to relate two or more arbitrary process
elements
•
Elements to describe the costs and beneﬁts of per-
forming an activity on-line in contrast to perform it
off-line.
[21] describe a process methodology to support the de-
velopment of context-aware adaptive applications. It consists
of four different activities: Explore, Integrate, Validate and
Evolve:
•
Exploration Phase
Exploits a feature library containing the implementa-
tion and corresponding requirements description.
•
Integration phase
Uses these features to produce a feature-diagram to
describe the space of system changes, called variants.
•
Validation phase
Validates the variants by using context analysis and
model checking.
•
Evolution phase
Reconﬁgures the system by switching to the new
conﬁguration.
[22] propose a conceptual model for self-adaptation which
uses the ITIL Change Management process as a starting
point. It consists of a reference process, activities, roles and
responsibilities and artifacts. The reference process consists of
two processes that interact iteratively, the adaption process and
the evolution process:
•
The inner Adaption Process relates to the feedback-
loop of a single adaptable element of the system and
is comprised of the activities Sense, Trigger, Select
Adaption Rules and Change. All these activities are
fully automated.
•
The Evolution Process is executed for a single or
multiple occurrences of the inner adaptive process. It
consists of the activities Aggregate Metrics, Analyze,
Evolve Adaption Rules, Adjust and Synchronize, and
Reﬂect. Theses tasks might require human involve-
ment.
The related work on process models for adaptive systems
is focused on generic adaptation mechanisms to evolve and
adapt a system, which are carried out at run-time. In contrast,
the conceptual framework presented in this chapter is aimed
to guide the design, development and operation of a speciﬁc
system, that is, an adaptive system for bulk data processing,
which provides a speciﬁc adaptation mechanism, that is, the
adaption of the aggregation size at run-time depending on the
current load of the system.
V.
CONCLUSION
In this paper, we have presented a conceptual framework
to guide the design, implementation and operation of an
enterprise system that implements the adaptive middleware for
bulk data processing as described in [2].
The conceptual framework consists of the entities phases,
roles, tasks, artifacts and tools. It describes:
•
The needed roles and their skills for the design,
implementation and operation.
•
The necessary tasks and their relationships for the
design, implementation and operation.
•
The artifacts that are created and required by the
different tasks.
•
The tools that are needed to process the different tasks.
•
The processes that describe the order of tasks to
implement a certain feature of the software system.
It should be noted that software processes are not ﬁxed
during their lifetime, they need to be continuously improved.
[3] The conceptual model can therefore be tailored to speciﬁc
projects requirements, it does not have to be followed strictly.
The next step of this research is the evaluation of the
conceptual framework by using quantitative research meth-
ods, such as expert interviews and its application in real-life
projects.
REFERENCES
[1]
J. Fleck, “A distributed near real-time billing environment,” in Telecom-
munications Information Networking Architecture Conference Proceed-
ings, 1999. TINA ’99, 1999, pp. 142–148.
[2]
M. Swientek, B. Humm, U. Bleimann, and P. Dowland, “An Adaptive
Middleware for Near-Time Processing of Bulk Data,” in ADAPTIVE
2014, The Sixth International Conference on Adaptive and Self-
Adaptive Systems and Applications, Venice, Italy, May 2014, pp. 37–41.
[3]
A. Fuggetta, “Software process: a roadmap.” ICSE - Future of SE Track,
2000, pp. 25–34.
[4]
G. Hohpe and B. Woolf, Enterprise Integration Patterns: Designing,
Building, and Deploying Messaging Solutions.
Boston, MA, USA:
Addison-Wesley Longman Publishing Co., Inc., 2003.
[5]
S. T. Acuña and X. Ferré, “Software process modelling.” in ISAS-SCI
(1), 2001, pp. 237–242.
[6]
I. McChesney, “Toward a classiﬁcation scheme for software process
modelling approaches,” Information and Software Technology, vol. 37,
no. 7, 1995, pp. 363–374.
[7]
S. T. Acuña and X. Ferre, “The software process: Modelling, evaluation
and improvement,” Handbook of Software Engineering and Knowledge
Engineering, vol. 1, 2001, pp. 193–237.
[8]
W. W. Royce, “Managing the Development of Large Software Systems:
Concepts and Techniques.” ICSE, 1987, pp. 328–339.
[9]
B. W. Boehm, “A Spiral Model of Software Development and Enhance-
ment.” IEEE Computer (), vol. 21, no. 5, 1988, pp. 61–72.
[10]
P. Feiler and W. Humphrey, “Software process development and enact-
ment: concepts and deﬁnitions,” in Software Process, 1993. Continuous
Software Process Improvement, Second International Conference on
the, Feb 1993, pp. 28–40.
[11]
R. Bendraou, M.-P. Gervais, and X. Blanc, “UML4SPM: A UML2.0-
Based Metamodel for Software Process Modelling,” in Model Driven
Engineering Languages and Systems.
Berlin, Heidelberg: Springer
Berlin Heidelberg, 2005, pp. 17–38.
44
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

[12]
K. Benali and J. C. Derniame, “Software processes modeling: What,
who, and when,” in Software Process Technology.
Berlin/Heidelberg:
Springer Berlin Heidelberg, Jan. 1992, pp. 21–25.
[13]
B. Curtis, M. I. Kellner, and J. Over, “Process modeling,” Communi-
cations of the ACM, vol. 35, no. 9, Sep. 1992, pp. 75–90.
[14]
R. Bendraou, M.-P. Gervais, and X. Blanc, “UML4SPM: An Executable
Software Process Modeling Language Providing High-Level Abstrac-
tions,” in Enterprise Distributed Object Computing Conference, 2006.
EDOC ’06. 10th IEEE International, Oct 2006, pp. 297–306.
[15]
OMG, “Software Process Engineering Metamodel SPEM 2.0,” Object
Management Group, Technical Report ptc/08-04-01, 2008.
[16]
S. Dietrich, P. Killisperger, T. Stückl, N. Weber, T. Hartmann, and
E.-M. Kern, “Using uml 2.0 for modelling software processes at
siemens ag,” in Information Systems Development, R. Pooley, J. Coady,
C. Schneider, H. Linger, C. Barry, and M. Lang, Eds.
Springer New
York, 2013, pp. 561–572.
[17]
G. Blair, N. Bencomo, and R. France, “Models@ run.time,” Computer,
vol. 42, no. 10, Oct 2009, pp. 22–27.
[18]
P. Inverardi and M. Tivoli, “The Future of Software: Adaptation and
Dependability.” ISSSE, vol. 5413, no. Chapter 1, 2008, pp. 1–31.
[19]
R. De Lemos, H. Giese, H. A. Müller, and M. Shaw, “Software
engineering for self-adaptive systems: A second research roadmap,”
Software Engineering for . . . , 2013.
[20]
J. Andersson, L. Baresi, N. Bencomo, R. de Lemos, A. Gorla,
P. Inverardi, and T. Vogel, “Software engineering processes for
self-adaptive systems,” in Software Engineering for Self-Adaptive
Systems II, ser. Lecture Notes in Computer Science, R. de Lemos,
H.
Giese,
H.
Müller,
and
M.
Shaw,
Eds.
Springer
Berlin
Heidelberg,
2013,
vol.
7475,
pp.
51–75.
[Online].
Available:
http://dx.doi.org/10.1007/978-3-642-35813-5_3
[21]
P. Inverardi and M. Mori, “A Software Lifecycle Process to Support
Consistent Evolutions.” Software Engineering for Self-Adaptive Sys-
tems, vol. 7475, no. Chapter 10, 2010, pp. 239–264.
[22]
C. Gacek, H. Giese, and E. Hadar, “Friends or foes?: a conceptual
analysis of self-adaptation and it change management.” SEAMS, 2008,
pp. 121–128.
45
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

