Strongly Possible Keys in Incomplete Databases with Limited Domains
Munqath Alattar
Department of Computer Science and
Information Theory
Budapest University of Technology and Economics
Budapest, Hungary
Email: m.attar@cs.bme.hu
Attila Sali
Alfr´ed R´enyi Institute of Mathematics
Hungarian Academy of Sciences
Budapest, Hungary
Email: sali.attila@renyi.mta.hu
Abstract—Missing values that may occur in the key attributes of
a database table is an extensive problem and handling it is an
important and challenging task, as the records need to contain
distinct and total values in their key part. The existing effective
approaches include an imputation operation for each occurrence
of a null in the key part of the data. In this paper, we assume the
situation when the attributes domains are not known. For that, a
new concept of keys called strongly possible keys in databases with
null values is introduced. It lies between possible keys and certain
keys introduced by K¨ohler et. al. earlier. The deﬁnition uses only
information extractable from the database table. Furthermore, an
approximation concept of the strongly possible key is provided.
Keywords–Strongly possible keys; null values; approximation of
keys.
I.
INTRODUCTION
A basic approach to treat null values in keys of relational
databases is an imputation operation for each occurrence of a
null in the key part of the data with a value from the attribute
domain as explained by [1]. We investigate the situation when
the attributes’ domains are not known. For that, we only
consider what we have in the given data and extract the values
to be imputed from the data itself for each attribute so that
the resulting complete dataset after the imputation would not
contain two tuples having the same value in their key. K¨ohler
et al. [1] used possible worlds by replacing each occurrence of
a null with a value from the corresponding attribute’s (possibly
inﬁnite) domain. They deﬁned a possible key as a key that is
satisﬁed by some possible world of a non total database table
and a certain key as a key that is satisﬁed by every possible
world of the table. In many cases, we have no proper reason
to assume existence of any other attribute value than the ones
already existing in the table. Such examples could be types
of cars, diagnoses of patients, applied medications, dates of
exams, course descriptions, etc. We deﬁne a strongly possible
key as a key that is satisﬁed by some possible world that is
obtained by replacing each occurrence of null value from the
corresponding attribute existing values. We call this kind of a
possible world a strongly possible world. This is a data mining
type approach; our idea is that we are given a raw table with
nulls and we would like to identify possible key sets based on
the data only.
The remainder of the paper is organized as follows. In
Section 2, some deﬁnitions are stated. In Section 3, strongly
possible keys, their discovery, and characterization of the
implication problem of systems of strongly possible keys are
provided. Approximation measures are studied in Section 4.
Section 5 presents concluding remarks and future research
directions.
II.
DEFINITIONS
Let R = {A1, A2, . . . An} be a relation schema. The set of
all the possible values for each attribute Ai ∈ R is called
the domain of Ai and referred as Di = dom(Ai) for i =
1,2,. . . n. And if X ⊆ R then DX =
Q
∀Ai∈K
Di. An instance
T = (t1,t2, . . . ts) over R is a set of tuples that each tuple is a
function t : R → S
Ai∈R dom(Ai) and t[Ai] is in the dom(Ai)
for all Ai in R. For a tuple tr ∈ T, let tr[Ai] be the restriction
of the rth tuple of T to Ai.
In practice, data models may contain an unknown infor-
mation about the value of some tuple tj[Ai] for j = 0,1,. . . s
that is denoted by ⊥. t1 and t2 are weakly similar on X ⊆ R
denoted as t1[X] ∼w t2[X] as deﬁned by K¨ohler [1] if:
∀A ∈ X
(t1[A] = t2[A] or t1[A] = ⊥ or t2[A] = ⊥)
Furthermore, t1 and t2 are strongly similar on X ⊆ T
denoted by t1[X] ∼s t2[X] if:
∀A ∈ X
(t1[A] = t2[A] ̸= ⊥)
For the sake of convenience, we write t1 ∼w t2 if t1 and t2
are weakly similar on R and the same for strong similarity. For
a null-free table, a set of attributes K ⊂ R is a key if there are
no two distinct tuples in the table that share the same values
in all the attributes of K:
ta[K] ̸= tb[K] ∀ 0 ≤ a, b ≤ s such that a ̸= b
The concepts of possible and certain keys were deﬁned
by K¨ohler et al [1]. Let T ′ = (t′
1, t′
2, . . . t′
s) be a table that
represents a total version of T which is obtained by replacing
the occurrences of ⊥ in all attributes t[Ai] with a value from
the domain Di different from ⊥ for each i. T ′ is called a
possible world of T. In a possible world T ′, t′
i is weakly similar
to ti and T ′ is completely null-free table. A possible key K
denoted as p ⟨K⟩, is a key for some possible world T ′ of T,
so that:
t′
1[K] ̸= t′
2[K], ∀ t′
1, t′
2 ∈ T ′
Similarly, a certain key K referred as c ⟨K⟩, is a key
for every possible world T ′ of T. The visible domain of an
46
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-715-3
DBKDA 2019 : The Eleventh International Conference on Advances in Databases, Knowledge, and Data Applications

attribute A (V DA) is the set of all distinct values except ⊥
that are already used by tuples in T:
V Di = {t[Ai] : t ∈ T}\{⊥} for Ai ∈ R
The term visible domain refers to the data that already exist
in a given dataset. For example, if we have a dataset with no
information about the attributes’ domains deﬁnitions, then we
use the data itself to deﬁne their own structure and domains.
This may provide more realistic results when extracting the
relationship between data so it is more reliable to consider
only what information we have in a given dataset.
A possible world T ′ is called strongly possible world if
T ′ ⊆ V D1 × V D2 × . . . × V Dn.
A subset K ⊆ R is a
strongly possible key (in notation
sp ⟨K⟩) in T if ∃ a strongly possible world T ′ ⊆ V D1 ×
V D2 × . . . × V Dn such that K is a key in T ′.
III.
RESULTS
Table I implies sp ⟨AB⟩ as a strongly possible key because
there is a strongly possible world in Table II where AB is a
key. On the other hand, Table I implies neither sp ⟨AC⟩ nor
sp ⟨BC⟩ because there is no strongly possible world T ′ that
has AC or BC as keys.
TABLE I. A DATASET WITH NULLS
A
B
C
D
3
2
⊥
0
15
1
2
10
⊥
2
2
⊥
TABLE II. A STRONGLY POSSIBLE WORLD OF TABLE I
A
B
C
D
3
2
2
0
15
1
2
10
15
2
2
10
Let Σ be a set of strongly possible keys and θ a single
strongly possible key over a relation schema R. Σ logically
implies θ, denoted as Σ |= θ if for every instance T over R
satisfying every strongly possible key in Σ we have that T
satisﬁes θ.
Theorem 1: Σ |= sp ⟨K⟩ ⇐⇒ ∃Y ⊆ K s.t. sp ⟨Y ⟩ ∈ Σ.
Proof: ⇐: ∃T ′ s.t. t′
i[Y ] ̸= t′
j[Y ], ∀i ̸= j, so t′
i[K] ̸=
t′
j[K], ∀i ̸= j holds, as well.
⇒:
Suppose indirectly that sp ⟨Y ⟩
/∈ Σ ∀Y
⊆ K.
Consider the following instance consisting of two tuples t1 =
(0, 0, . . . , 0), t2[K]
=
(⊥, ⊥, . . . , ⊥), and t2[R \ K]
=
(1, 1, . . . 1) as in Table III . Then, the only possible t′
2
in T ′ is t′
2(0, 0, . . . , 0, 1, 1, . . . , 1). Furthermore, ∀Z where
sp ⟨Z⟩ ∈ Σ, there must be z ∈ Z \ K, thus t′
1[Z] ̸= t′
2[Z] but
t′
1[K] = t′
2[K] showing that (t1, t2) satisﬁes every strongly
possible key constraints from Σ, but does not satisfy sp ⟨K⟩.
TABLE III. INCOMPLETE DATA INSTANCE
K
R \ K
t1
0 0 0 0
00000000
t2
⊥⊥⊥⊥
11111111
Note 1: If Σ |= ¬sp ⟨K⟩ and Y ⊆ K then Σ |= ¬sp ⟨Y ⟩.
Note 2: If Σ |= sp ⟨K⟩, then Σ |= p ⟨K⟩ but the reverse
is not necessarily true, since DK ⊇ V DK could be proper
containment so K could be made a key by imputing values
from DK \ V DK. For example, in Table III, it is shown that
¬sp ⟨K⟩ holds, but p ⟨K⟩ may hold in some T ′ if there is at
least one other value in the domain of K rather than the zeros
to be placed instead of the nulls in the second tuple so that
t′
1[K] ̸= t′
2[K] results.
Note 3: If Σ |= c ⟨K⟩, then Σ |= sp ⟨K⟩. As certain keys
hold in any possible world, they hold also if this possible world
is created using visible domain.
Note 4: For a single attribute A, sp ⟨A⟩
⇐⇒
t[A] ≁w
t′[A] ∀t, t′ s.t. t ̸= t′, i.e., if there are no nulls occurrences in
A.
In other words, a single attribute with a null value cannot
be a strongly possible key. That is because replacing an
occurrence of null with a visible domain value results in
duplicated values for that attribute.
Let us consider a schema R = {A1, A2, . . . , An} and
let K = {K1, K2, . . . Kp} be a collection of attribute sets
and T
=
{t1, t2, . . . , ts} be an instance with possible
null occurrences. Our main question here is whether Σ =
{sp ⟨K1⟩ , sp ⟨K2⟩ , . . . , sp ⟨Kp⟩} holds in T? Let Ei = {t′ ∈
V D1 ×V D2 ×. . .×V Dn : t′ ∼w ti}. Let S ⊆ V D1 ×V D2 ×
. . . × V Dn be the union S = E1 ∪ E2 ∪ . . . ∪ Es and deﬁne
bipartite graph G = (T, S; E) by {t, t′} ∈ E ⇐⇒ t ∼w t′
for t ∈ T and t′ ∈ S. Let (S, M0) be the transversal matroid
(see [2]) deﬁned by G on S, that is a subset X ⊆ S satisﬁes
X ∈ M0 if X can be matched into T. Furthermore, consider
the partitions
S = Sj
1 ∪ Sj
2 ∪ . . . ∪ Sj
pj
(1)
induced by Kj for j = 1, 2, . . . , p such that Sj
i ’s are maximal
sets of tuples from S that agree on Kj. Let (S, Mj) be the
partition matroid given by (1). We can formulate the following
theorem.
Theorem 2: Let T be an instance over schema R =
{A1, A2, . . . , An} and let K = {K1, K2, . . . Kp} be a col-
lection of attribute sets. Σ = {sp ⟨K1⟩ , sp ⟨K2⟩ , . . . , sp ⟨Kp⟩}
holds in T if and only if the matroids (S, Mj) have a common
independent set of size |T| for j = 0, 1, . . . p
Proof: An independent set T ′ of size |T| in matroid
(S, M0) means that tuples in T ′ form a strongly possible world
for T. That they are independent in (S, Mj) means that Kj
is a key in T ′, that is sp ⟨Kj⟩ holds.
Conversely, if Σ
=
{sp ⟨K1⟩ , sp ⟨K2⟩ , . . . , sp ⟨Kp⟩}
holds in T, then there exists a strongly possible world T ′ =
{t′
1, t′
2, . . . , t′
s} ⊆ V D1×V D2×. . .×V Dn such that ti ∼w t′
i.
This means that T ′ ⊆ S and that T ′ is independent in
transversal matroid (S, M0). sp ⟨Kj⟩ holds implies that tuples
t′
i are pairwise distinct on Kj, that is T ′ is independent in
partition matroid (S, Mj).
Unfortunately, Theorem 2 does not give a good algorithm
to decide the satisfaction of a system Σ of strongly possible
keys, because as soon as Σ contains at least two constraints,
then we would have to calculate the size of the largest common
independent set of at least three matroids, known to be an NP-
complete problem [3].
47
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-715-3
DBKDA 2019 : The Eleventh International Conference on Advances in Databases, Knowledge, and Data Applications

In case of a single strongly possible key sp ⟨K⟩ constraint,
Theorem 2 requires to compute the largest common indepen-
dent set of two matroids, which can be solved in polynomial
time [4]. However, we can reduce the problem to the somewhat
simpler problem of matchings in bipartite graphs.
If we want to decide whether sp ⟨K⟩ holds or not, we
can forget about the attributes that are not in K since we need
distinct values on K as a matching from V DA1×V DA2×. . .×
V DAb to T = {t1, t2 . . . tr}|K where K = {A1, A2 . . . Ab}.
Thus, we may construct a table T ′ that is formed by ﬁnding
all the possible combinations of the visible domains of T|K
that are weakly similar to some tuple in T|K.
T ′ = {t′ : ∃t ∈ T : t′[K] ∼w t[K]} ⊆ V D1×V D2×. . .×V Db
Finding the matching between T and T ′ that covers all the
tuples in T (if it exists) will result in the set of tuples in T ′
that needs to be replaced in T so that K is a strongly possible
key.
Let cv(A) denote the number of tuples that have value v
in attribute A, that is cv(A) = |{t ∈ T : t[A] = v}|. Next are
some necessary conditions to have a strongly possible key.
Proposition 1: Let K ⊆ R be a set of attributes. If sp ⟨K⟩
holds, then
1)
No two tuples ti, tj are strongly similar in K.
2)
|T| ≤
Q
∀A∈K
|V DA|.
3)
∀B
∈
K,
number
of
nulls
in
B
≤
P
∀v∈V DB
 Q
∀A∈K |V DA|
|V DB|
− cv(B)

.
4)
For all v ∈ V DB we have cv(B) ≤
Q
∀A∈K |V DA|
|V DB|
Proof: The ﬁrst condition is obviously required so that K
is a strongly possible key, where the strong similarity means
that the two tuples are total and equal to each other in the key
part and this violates the general key deﬁnition. In addition to
that, for any set of attributes, the maximum number of distinct
combination of their values is the size of the multiplication of
their visible domain, and this proves (2). Moreover, to prove
conditions (3) and (4), when K is sp ⟨K⟩ in T then there
should exist a T ′ with no two tuples having the same values
in all K attributes after ﬁlling all their nulls. So for each set
of tuples S that has the same value v in the attribute B, the
number of distinct combinations of the other attributes is the
multiplication of their V D’s, means the number of tuples in S
should not be more than Q
∀A∈(K\B) V DA. Thus, the number
of times value v can be used to replace a null in attribute B
is at most
Q
∀A∈K |V DA|
V DB
− cv(B).
Note that sp ⟨K⟩ holds if a matching covering T exists in
the bipartite graph G = (T, T ′; E) deﬁned as above, {t, t′} ∈
E
⇐⇒
t[K] ∼w t[K]′. We can apply Hall’s Theorem to
obtain
∀X ⊆ T, we have |N(X)| ≥ |X|
for N(X) = {t′ : ∃t ∈ X such that t[K]′ ∼w t[K]}
IV.
STRONGLY POSSIBLE KEYS APPROXIMATION
To measure the degree of how much a strongly possible key
holds in a given dataset, we use the g3 measure introduced in
[5]. g3 is based on the idea that the degree to which ASP key is
approximate is determined by the minimum number of tuples
that need be removed from T so that K becomes an ASP
key. To ﬁnd the tuples that we need to remove, we suggest to
construct the maximum matching in graph G = (T, T ′; E).
g3(K) = |T| − ν(G)
|T|
where ν(G) denotes the maximum size of a matching in graph
G.
Let M be the collection of connected components in graph
G that hold the strongly possible key condition, i.e., there is a
matching cover all T tuples in that set (∀M∈M ∄X ⊆ M ∩ T
such that |X| > N(X)). Let C ⊆ G be deﬁned as C =
G\S
∀M∈M M and let M′ be the set of connected components
of C. In addition to that, we use the term VM to denote the
set of vertices of T in a component M. So, the maximum
matching can be written as P
M∈M(|VM|)+P
∀M ′∈M′ ν(M ′).
Therefore we can reformulate the g3 measure as:
g3(K) = |T| − (P
M∈M(|VM|) + P
M ′∈M′ ν(M ′))
|T|
Figure 2 shows 7 tables that represent the key part only of the
data where each table has more than one attribute. Tables A,
B and C have 2n tuples, tables E and F have n tuples, and
table D has n + l tuples while table G has kn tuples. Table D
includes a variable 0 ≤ β ≤ n
2 . We intend to use these cases
to illustrate the differences and give a bound of g3/gc
3 where
it is always true that g3 − gc
3 ≥ 0. The graphs show the weak
similarity relationship between the data tuples and the visible
domains combinations. The visible domains combinations are
shown on Figure 1. For example, in table A, the ﬁrst two
tuples of T in the left side of the graph can have a unique
weakly similar tuples in T ′ for each, while for the rest, every
two tuples in T form a connected component that have only
one weakly similar tuple in T ′. On other hand, all the tuples
of table E form connected component of size n that have a
weakly similar relation (matching) to one tuple in T ′.
Measuring the strongly possible keys approximation can
be more appropriate by take into consideration the effect of
each connected component in the graph on the matching.
More speciﬁcally, M represents the sets of tuples that do not
require any tuple to be removed to get a strongly possible
key, while the components of M′ represent the sets of tuples
that contain some tuples which need to be removed to have
a strongly possible key. We consider the components of M to
get their effect doubled in the approximation measure because
they represent a part of the data that is not affected by any
tuples removal. So, we propose a derived version of g3 measure
named gc
3 that considers the effects of these components.
gc
3(K) = |T| − (P
M∈M(|VM|) + P
M ′∈M′ ν(M ′))
|T| + P
M∈M |VM|
Theorem 3: For any table T and set of attributes K we
have either g3(K) = gc
3(K) or 1 < g3(K)/gc
3(K) < 2. Fur-
thermore, for any rational number 1 ≤ p
q < 2 there exist tables
of arbitrarily large number of tuples with g3(K)/gc
3(K) = p
q .
Proof: g3(K) and gc
3(K) are different only in the de-
nominator part. The number of tuples of the components in
M can’t be more than the total number of tuples in the table,
so 0 ≤ P
M∈M |VM| ≤ |T| and P
M∈M |VM| = |T| iff every
48
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-715-3
DBKDA 2019 : The Eleventh International Conference on Advances in Databases, Knowledge, and Data Applications

(A)
t′
i = (i − 1, 0) i = 1, 2, . . . , n + 1
(B)
t′
i = (i − 1, 0) i = 1, 2, . . . , n + 1
(C)
t′
i = (i − 1, 0) i = 1, 2, . . . , n + 1
(D)
t′
i = (i, 0, 0) for i = 1, 2, . . . , n − β, and t′
n−β+j = (0, 0, j − 1) for j = 1, 2, . . . , l + 1
(E)
t′
1 = (0, 0)
(F)
t′
i = (i, 0) i = 1, 2, . . . , n − 1
(G)
t′
jn+i = (jn + i + j, 0) for i = 1, 2, . . . , n − j − 1 and j = 0, 1, . . . , k − 1
Figure 1. Visible Domains Combinations of Tables of Figure 2
tuple is a member of some connected component in M. In
the latter case g3(K) = gc
3(K), otherwise the denominator of
gc
3(K) is less than twice the denominator of g3(K) that proves
the inequlaties of the ratio. Table E proves that g3(K) = gc
3(K)
can hold for arbitrarily large tables. Now let 1 < p
q < 2 be
given with p
q = 1 + p′
q′ . Consider Table D where
g3(K)/gc
3(K) =
β − 1
n + l

/
 β − 1
n + 2l

which can simply be written as 1 +
l
n+l. Now taking n =
α(q′ − p′), l = αp′ and any β between 2 and ⌊ n
2 ⌋ we obtain
that
g3(K)/gc
3(K) = 1 + p′
q′ .
Note that g3(K) ranges between 1/n and 1/2 depending
on the choice of β.
V.
CONCLUSION AND FUTURE DIRECTIONS
The main contributions of this paper are as follows:
•
We introduced and deﬁned strongly possible keys over
database relations that contain some occurrences of
nulls.
•
We provided some properties, observations, and num-
ber of necessary conditions so that a strongly possible
key holds in a given dataset. We show that deciding
whether a given set of attributes is a strongly possible
key can be done by application of matchings in bipar-
tite graph, so Hall’s condition is naturally applied.
•
We showed that deciding whether a given system of
sets of attributes is a system of possible keys for a
given table can be done using matroid intersection.
However, we need at least three matroids, and matroid
intersection of three or more matroids is NP-complete,
which suggests that our problem is also NP-complete.
•
We studied systems of strongly possible keys and we
gave characterization of the implication problem.
•
An approximation concept of the strongly possible key
was introduced to measure how close approximation
of a strongly possible key holds in a data relation,
using g3 measure. We derived the measure gc
3 from g3
and gave bounds of the two measures.
Strongly possible keys are special cases of possible keys of
relational schemata with each attribute having ﬁnite domain.
So, future research is needed to decide what properties of
implication, axiomatization of inference remain valid in this
setting. Note that the main results in [1] consider that at least
one attribute has inﬁnite domain.
We plan to extend our research from keys to functional
dependencies. Weak and strong functional dependencies were
introduced in [6]. A wFD X →w Y holds if there is a
possible world T ′ that satisﬁes FD X → Y , while sFD
X →s Y holds if every possible world satisﬁes FD X → Y .
Our strongly possible world concept naturally induces an
intermediate concept of functional dependency. Future research
on possible keys of ﬁnite domains might extend our results on
strongly possible keys.
Finally, Theorem 2 deﬁnes a matroid intersection problem.
It would be interesting to know whether this particular question
is NP-complete, which we strongly believe it is.
REFERENCES
[1]
H. K¨ohler, U. Leck, S. Link, and X. Zhou, “Possible and certain keys
for sql,” The VLDB Journal, vol. 25, 2016, pp. 571–596.
[2]
D. Welsh, Matroid Theory.
Academic Press, New York, 1976.
[3]
M. Garey and D. Johnson, Computers and Intractability. A Guide to the
Theory of NP-Completeness.
Freeman, New York, 1979.
[4]
E. Lawler, “Matroid intersection algorithms,” Mathematical Program-
ming, vol. 9, 1975, pp. 31–56.
[5]
J. Kivinen and H. Mannila, “Approximate inference of functional depen-
dencies from relations,” Theoretical Computer Science, vol. 149, 1995,
pp. 129–149.
[6]
G. L. Mark Levene, “Axiomatisation of functional dependencies in
incomplete relations,” Theoretical Computer Science, vol. 206, 1998.
49
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-715-3
DBKDA 2019 : The Eleventh International Conference on Advances in Databases, Knowledge, and Data Applications

t1
t2
t3
t4
t5
t6
t2n−1
t2n
t′
1
t′
2
t′
3
t′
4
t′
n+1
. . .
. . .
(A)
A1 A2
0
0
1
⊥
2
⊥
2
⊥
3
⊥
3
⊥
...
...
n
⊥
n
⊥
t1
t2
tn
tn+1
tn+2
t2n
t′
1
t′
2
t′
3
t′
n+1
. . .
. . .
. . .
(B)
A1 A2
0
0







n
0
⊥
0
⊥
...
...
0
⊥
1
⊥
2
⊥
...
...
n
⊥
t1
t2
t3
t4
tn−1
tn
tn+1
tn+2
t2n
t′
1
t′
2
t′n
2
t′n
2 +1
t′n
2 +2
t′
3n
2
. . .
. . .
. . .
. . .
(C)
A1
A2
0
0
0
⊥
1
⊥
1
⊥
...
...
n/2
⊥
n/2
⊥
n/2 + 1
⊥
n/2 + 2
⊥
...
...
3n/2
⊥
t1
t2
tn − 1
tn
tn+1
tn+2
tn+l
t′
1
t′
2
t′
n−β
t′
n−β+1
t′
n−β+2
t′
n−β+3
t′
n−β+l+1
. . .
. . .
. . .
. . .
(D)
A1
A2 A3
1
⊥
0
2
⊥
0
...
...
...
n − β
⊥
0
⊥
0
0


β
⊥
0
0
...
...
...
⊥
0
0
0
⊥
1
0
⊥
2
...
...
...
0
⊥
l
t1
t2
tn
t′
1
. . .
(E)
A1 A2
0
0


n
0
⊥
...
...
0
⊥
t1
t2
t3
tn
t′
1
t′
2
t′
n−1
. . .
. . .
(F)
A1
A2
1
0
1
⊥
2
⊥
...
...
n − 1
⊥
t1
t2
t3
tn−1
tn
tn+1
tn+2
t2n−2
t(k−1)n
t(k−1)n+1
t(k−1)n+2
tkn
t′
1
t′
2
t′
n−1
t′
n
t′
n+1
t′
2n−2
t′
(k−1)n
t′
(k−1)n+1
t′
kn−k
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
(G)
A1
A2
1
0
1
⊥
2
⊥
...
...
n − 1
⊥
n + 1
0
n + 1
⊥
n + 2
⊥
...
...
2n − 1
⊥
...
...
n(k − 1) + 1
0
n(k − 1) + 1
⊥
n(k − 1) + 2
⊥
...
...
kn − 1
⊥
Figure 2. Sample Tables for Comparison Results
TABLE IV. MAIN COMPARISON RESULTS
A
B
C
D
E
F
G
g3
n−1
2n
n−1
2n
1
4
β−1
n+l
n−1
n
1
n
1
n
gc
3
n−1
2n+2
n−1
3n
1
6
β−1
n+2l
n−1
n
1
2n−2
1
2n−2
50
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-715-3
DBKDA 2019 : The Eleventh International Conference on Advances in Databases, Knowledge, and Data Applications

