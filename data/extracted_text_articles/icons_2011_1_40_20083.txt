Event Driven Programming for Embedded Systems - A Finite State Machine Based
Approach
Nrusingh Prasad Dash∗, Ranjan Dasgupta†, Jayakar Chepada‡ and Arindam Halder§
Innovation Lab, Tata Consultancy Services Ltd. Kolkata, 700091, India
E-Mail:∗nrusingh.dash@tcs.com,†ranjan.dasgupta@tcs.com, ‡jayakar.ch@tcs.com, §arindam.halder@tcs.com
Abstract—The paper gives a brief overview of event driven
program and its relationship with ﬁnite state machine (FSM).
It proposes a FSM-based framework implemented in C
programming
language.
In
Microcontroller
Unit
(MCU)
based tiny embedded system, FSM based software design and
event-driven programming techniques are efﬁcient in handling
concurrent and asynchronous events usually occur. Finally, the
paper states and demonstrates a solution of a system power
sequence problem using the same framework as a case study.
Keywords - Event Driven Programming; FSM; States; State
Transitions; MCU.
I. INTRODUCTION
Most of the tiny embedded systems respond to external
or internal events in some or other way. The external event
can be an interrupt, or change of signal level at I/O pins,
a message packet coming from other part of the system
through some interface, e.g., serial peripheral interface(SPI),
inter-integrated circuit(I2C), two wire interface(TWI), or
simply an expiry of internal timer. This paper initially
discusses the prior art on software implementation of FSM in
Section II, subsequently provides the theoretical background
of event driven programming paradigm and how the event
driven programming problems can be solved using ﬁnite
state machines(FSM) in Sections III, and IV respectively.
In Section V, the paper proposes a FSM framework and
narrates a case study where, the same framework has been
used to implement an event driven application efﬁciently and
easily on a TI MSP430F1232 MCU based system. Finally,
the paper discusses the performance ﬁgures of the case study
in Section VI
II. STATE OF THE ART
There are various approaches taken for the software
implementation of ﬁnite state machines (FSM). The works
presented in [1] and [3] are switch-case driven FSM imple-
mentations where, several comparisons are required before
execution of the event handler. The number of comparison
increases with the number of states and events. The more
is the number of comparisons the more CPU cycle is
consumed. In the work [4] a table driven event handler
hashing approach has been taken to implement the FSMs,
but does not separate out the FSM framework and FSM im-
plementation, therefore lacks re-usability. The works [2] and
[5], emphasize on model driven FSM generation techniques,
but, to maintain the genericness and re-usability, generated
code for FSM would require high memory foot-print as well
as more CPU cycles and therefore may not be suitable for the
embedded systems with very tight memory and cpu horse-
power budget. The current work aims at an re-usable, simple
and compact FSM framework, which takes minimal CPU
cycles and less memory foot-print to implement an FSM
problem.
III. EVENT DRIVEN PROGRAMMING
The events are mostly generated when user actions are
done on a system. The user actions can be a press of a push
button or a key pad, touch a touch screen, move or click of
a mouse. The events can also be generated from the sensors
or devices connected to a system (may be through interrupts
or may be form of message packets through a physical
interface). Sometimes event may be generated internally,
e.g., timeout event or a software exception. Irrespective of
the source or type of events, the event driven programming
talks about a programming paradigm in which the ﬂow
of the program is determined by the events. The actual
implementation of event driven programming can be done
with any programming language, like C/C++ etc. Broadly
these implementations have following sections of programs.
• Event Capture Section
• Event Despatch Section
• Event Handlers Section
Figure 1.
Sections of Event Driven Program
19
ICONS 2011 : The Sixth International Conference on Systems
Copyright (c) IARIA, 2011              ISBN:978-1-61208-114-4

A. Event Capture Section
This section of program is responsible for capturing the
events, do pre-processing and identifying the event type.
The event capture section can be at one place or may be
distributed across several interrupt handlers and the main
background loop.
B. Event Despatch Section
The responsibility of the dispatcher is to map the events
with the respective handler and calls the handler. If there is
no associated handler with an event, dispatcher either drops
the event or raises an exception.
C. Event Handlers Section
The event handlers implement the activities; those should
take place on occurrence of an event.
Many event driven programs are state less, which means
when any application ﬁnishes processing an event, the appli-
cation does not require to maintain its earlier event. When
the event occurs, the respective handler is just executed.
It means it is a state less event driven program where the
execution ﬂow is not dependent on the earlier events. On the
contrary the other category of event driven programs, where
the execution ﬂow is dependent on not only the current event
but also the sequence of prior events, called as state full
event driven programs. This article discusses about the latter
category and how FSM can be used to solve state full event
driven programming problems.
IV. FINITE STATE MACHINE (FSM)
Finite State Machine (FSM) is a model behavior com-
posed of a ﬁnite number of states, transitions between those
states, and actions.
Finite state machines (FSM) consist of 4 main elements:
• States - Deﬁne behavior and may produce actions
• State Transitions - Switching of state from one to
another
• Conditions - Set of rules which must be met to allow
a state transition
• Input Events - Triggers which are either externally
or internally generated, which may possibly invoke
conditions and upon fulﬁlling the conditions lead to
state transition.
Every FSM has an initial state, which is the starting point.
The input events act as triggers, which cause an evaluation
of the conditions imposed. On fulﬁlling those, the current
state of the system switches to some other state, which is
called as state transition. State transitions, may happen along
with the associated actions in most of the cases. The actions
can happen, before entering to a state or at exiting the state
or while being in the state itself.
V. CASE STUDY - A SYSTEM POWER ON/OFF
SEQUENCE
Problem Statement - There is a power key in a system.
Initially the system is assumed to be off. When the system
is off, if the power key is pressed for 2 seconds, it switches
on. When the system is on, if power key is pressed for 2
seconds it switches off. But if the key press time is less than
2 seconds while system is either on or off state, it remains
in same state which means there is no state transition. The
Fig. 2 is the uniﬁed modeling language(UML) state chart
representation of the problem stated above.
Figure 2.
UML State Chart
The problem stated above can be very easily implemented
using a FSM framework, that has been proposed in this
work.
A. The FSM Framework Implementation
The C program Listing 1 in the appendix is a state
transition table-driven implementation of FSM framework,
which can be used for a quick and easy implementation of a
FSM problem. The framework exposes following interfaces
for programmer.
sm declare states(fsm name, list of states) - Interface
for declaring states. The ﬁrst parameter is the name of the
state machine and the rest of the parameters are the list of
states separated by coma.
sm declare events(fsm name, list of events) - Inter-
face for declaring events. The ﬁrst parameter is the name
of the state machine and the rest of the parameters are are
the list of events separated by coma.
sm declare state machine(fsm name,
initial state,
list of state handlers) - Interface for declaring the state
transition table and initializing the state to initial state.
sm handle event(fsm name, event) - Interface is used
for handling the event after the event is captured.
sm set state(fsm context, state) - Interface is used in-
side the event handlers to set the next state.
sm set private data(fsm context, private data) - In-
terface is used inside the event handlers to set the problem
speciﬁc private data.
20
ICONS 2011 : The Sixth International Conference on Systems
Copyright (c) IARIA, 2011              ISBN:978-1-61208-114-4

sm get private data(fsm context) - Interface is used
inside the event handlers to obtain the reference to the
problem speciﬁc private data.
sm deﬁne handle event(fsm name) - This is not an
interface for the programmer. This macro deﬁnes the state
machine handling function for the events. Note: It is cus-
tomary to use this macro without putting a semicolon after
it.
sm declare handle event(fsm name) - This is not an
interface for the programmer. This macro declares the state
machine handling function. It is customary to use this macro
in the header ﬁle of the actual state machine implementation
ending with a semicolon.
B. FSM Implementation of System Power ON/OFF Se-
quence
The FSM framework described in previous subsection is
used to implement the FSM problem of system power on/off
sequence described earlier.
The
program
Listing
2
in
the
appendix
demon-
strates how easily the states and the events can be
declared.
It
is
just
a
matter
of
using
two
macros,
i. e., sm declare states(fsm name,
list of states) and
sm declare events(fsm name,
list of events).
In
this
case the states are OFF, ON IN PROGRESS, ON,
OFF IN PROGRESS and the events are KEY PRESS,
and TIMER EXPIRY.
The
program
Listing
3
in
the
appendix
demon-
strates
the
implementation
of
the
state
transition
ta-
ble
and
the
event
handlers.
The
initial
state
set-
ting and the state transition table deﬁnition is done
with sm declare state machine(fsm name, initial state,
list of state handlers) interface. The guard conditions,
e.g., the check for the key is still pressed at the timer expiry
or not is implemented as a condition check within the event
handlers. The transition to next state is also done inside event
handler using sm set state(fsm context, state) interface.
The event capture sections are distributed. In the current
problem the event KEY PRESS is captured as polling
of the respective pin in the main background loop and
the event TIMER EXPIRY is captured in timer inter-
rupt context as timer expiry callback function. The event
capture and despatch is demonstrated in program List-
ing 4 in the appendix. After the events are captured
they are despatched to respective event handles using
sm handle event(fsm name, event).
Note: The timer implementation and the power key state
check program listings are not included or described to
maintain the focus on the FSM implementation.
The FSM framework presented in this paper has theoret-
ical commonality with the FSMs presented in [1] and [3]
but has novelty in its implementation. It uses a pre-hashed
event handling approach where, the current state and event
are used as hash-keys to fetch the event handler from table,
without requiring comparisons and saves the CPU cycles
consumed. Unlike [4], the work presented in this paper
separates out the FSM framework and FSM implementation,
enhancing the re-usability of the framework. The Listing 1
in the appendix implements a reusable framework, which
can be reused for implementing other FSM problems. The
CPU cycle consumption and memory foot-print ﬁgures are
very minimal as discussed in Section VI which proves its
suitability for embedded systems applications.
However, the framework presented in this paper is suitable
for the FSM problems where, the most of the state and event
combinations are handled. Otherwise, the respective table
entry consumes memory without doing any useful activity.
VI. CONCLUSION
The FSM framework discussed is not only a very quick
and easy way to implement a FSM problem, but also the
memory footprint of the generated code is very less and
being a function table driven event handling implementation,
the execution is pretty fast. These characteristics make the
framework very much suitable for the tiny embedded sys-
tems application where the memory and processor resources
are very scarce. The framework is used for the power se-
quence problem described in the paper on a MSP430F1232
MCU and the memory footprint is as below.
• 164 bytes of code memory
• 8 bytes of data memory
• 24 bytes of constant memory
The FSM consumes approximately 18 instruction cycles
between the event despatch and the event handler is called.
The above ﬁgures are reported using IAR Workbench [6]
v4.
REFERENCES
[1] Miro Samek, Practical UML Statecharts in C/C++, 2nd Edi-
tion, Newnes.
[2] Ilija Basicevic, Miroslav Popovic, and Ivan Velikic ”Use of
Finite State Machine Based Framework in Implementation of
Communication Protocols
A Case Study” Sixth Advanced
International Conference on Telecommunications, May 9 - 15,
2010
[3] Andrei Drumea and Camelia Popescu, ”Finite State Machines
and their applications in software for industrial control”,
27th International Spring Seminar on Electronics Technology:
Meeting the Challenges of Electronics Technology Progress,
May 13 -16, 2004
[4] Johannes Weidl, Ren6 R. Klosch, Georg Trausmuth, and
Harald Gall, ”Facilitating program comprehension via generic
components for state machines”, Fifth Iternational Workshop
on Program Comprehension, March 28 - 30, 1997
[5] Chung-Shyan Liu, and Kuo-Hua Su, ”An FSM-Based Program
Generator for Communication Protocol Software”, Eighteenth
Annual International Computer Software and Applications
Conference, November 9-11, 1994
21
ICONS 2011 : The Sixth International Conference on Systems
Copyright (c) IARIA, 2011              ISBN:978-1-61208-114-4

[6] http://www.iar.com/website1/1.0.1.0/220/1/
APPENDIX
Listing 1.
FSM framework
1 # i f n d e f _SM_FRAMEWORK_H_
2 # define _SM_FRAMEWORK_H_
3 /*
4 File:sm_framework.h
5 Description: A framework for finite state
machine implementations
6 */
7 typedef
s t r u c t sm_context sm_context_t;
8 typedef
void (*sm_handler_t) (sm_context_t *);
9
10 # define sm_declare_states(name, ...)
\
11 typedef enum {
\
12
__VA_ARGS__,
\
13
name##_STATE_COUNT
\
14 } name##_state_e
15
16 # define sm_declare_events(name, ...)
\
17 typedef enum {
\
18
__VA_ARGS__,
\
19
name##_EVENT_COUNT
\
20 } name##_event_e
21
22
23 # define sm_declare_state_machine(name, st_init,
...) \
24 s t r u c t sm_context { \
25
void
*priv; \
26
name##_state_e
state; \
27
name##_event_e
event; \
28
sm_handler_t
*handler; \
29 }; \
30
s t a t i c
const
unsigned
i n t \
31 name##_handler[name##_EVENT_COUNT][name##
_STATE_COUNT] = {__VA_ARGS__}; \
32
s t a t i c sm_context_t name##_context \
33 = {0, st_init, (name##_event_e) 0, (
sm_handler_t *)name##_handler}
34
35 # define sm_set_state(c, s) (c)->state
= (s)
36 # define sm_set_private_data(c, p) (c)->priv = (
p)
37 # define sm_get_private_data(c) (c)->priv
38
39 # define sm_define_handle_event(name) \
40 void name##_handle_event(name##_event_e ev) \
41 {
sm_context_t *c = &name##_context; \
42
c->event = (ev); \
43
c->handler[c->event * name##_STATE_COUNT +
c->state](c); \
44
return; \
45 }
46
47 # define sm_declare_handle_event(name) \
48 void name##_handle_event(name##_event_e ev)
49
50 # define sm_handle_event(name, ev) name##
_handle_event(ev)
51
52 # endif /*_SM_FRAMEWORK_H_*/
Listing 2.
Events and states declaration
1 # i f n d e f __POWER_STATE_MACHINE__
2 # define __POWER_STATE_MACHINE__
3 # include "sm_framework.h"
4 /*
5 * File: power_state_machine.h
6 * Description: States and events declared
7 */
8 sm_declare_states(power,
9
OFF,
10
ON_IN_PROGRESS,
11
ON,
12
OFF_IN_PROGRESS
13
);
14
15 sm_declare_events(power,
16
KEY_PRESS,
17
TIMER_EXPIRY
18
);
19
20 sm_declare_handle_event(power);
21
22 # endif /*__POWER_STATE_MACHINE__*/
Listing 3.
Power state machine
1 # include <power_state_machine.h>
2
s t a t i c
void no_action_handler(sm_context_t *
context);
3
s t a t i c
void on_key_press_when_off(sm_context_t
*context);
4
s t a t i c
void on_timer_expiry_when_on_in_progress
(sm_context_t *context);
5
s t a t i c
void on_key_press_when_on(sm_context_t *
context);
6
s t a t i c
void
on_timer_expiry_when_off_in_progress(
sm_context_t *context);
7 sm_declare_state_machine(power,
8 /* initial state */
9 OFF,
10 /* event = KEY_PRESS state = OFF */
11 (unsigned
i n t ) on_key_press_when_off,
12 /* event = KEY_PRESS state = ON_IN_PROGRESS */
13 (unsigned
i n t ) no_action_handler,
14 /* event = KEY_PRESS state = ON */
15 (unsigned
i n t ) on_key_press_when_on,
16 /* event = KEY_PRESS state = OFF_IN_PROGRESS */
17 (unsigned
i n t ) no_action_handler,
18 /*
19 * event = TIMER_EXPIRY
20 * state = OFF
21 */
22 (unsigned
i n t ) no_action_handler,
23 /*
24 * event = TIMER_EXPIRY
25 * state = ON_IN_PROGRESS
26 */
27 (unsigned
i n t )
on_timer_expiry_when_on_in_progress,
28 /*
29 * event = TIMER_EXPIRY
30 * state = ON
31 */
32 (unsigned
i n t ) no_action_handler,
33 /*
34 * event = TIMER_EXPIRY
35 * state = OFF_IN_PROGRESS
36 */
37 (unsigned
i n t )
on_timer_expiry_when_off_in_progress);
38
39 /*don’t put semicolon at the end of the line
bellow*/
40 sm_define_handle_event(power)
22
ICONS 2011 : The Sixth International Conference on Systems
Copyright (c) IARIA, 2011              ISBN:978-1-61208-114-4

41
42
s t a t i c
void no_action_handler(sm_context_t *
context)
43 {
44
return;
45 }
46
s t a t i c
void on_key_press_when_off(sm_context_t
*context)
47 {
48
timer_start(TIMER_ID);
49
sm_set_state(context, ON_IN_PROGRESS);
50
return;
51 }
52
s t a t i c
void on_timer_expiry_when_on_in_progress
(sm_context_t *context)
53 {
54
i f (is_power_key_pressed())
55
{
56
sm_set_state(context, ON);
57
}
58
e l s e
59
{
60
sm_set_state(context, OFF);
61
}
62
return;
63 }
64
s t a t i c
void on_key_press_when_on(sm_context_t *
context)
65 {
66
timer_start(TIMER_ID);
67
sm_set_state(context, OFF_IN_PROGRESS);
68
return;
69 }
70
s t a t i c
void
on_timer_expiry_when_off_in_progress(
sm_context_t *context)
71 {
72
i f (is_power_key_pressed())
73
{
74
sm_set_state(context, OFF);
75
}
76
e l s e
77
{
78
sm_set_state(context, ON);
79
}
80
return;
81 }
Listing 4.
Event capture and dispatch
1 # include <power_state_machine.h>
2 /*
3 * File: main.c
4 */
5 # define TIMER_ID
1
6 # define TIMER_DURATION
2
7 /*
8 * Timer handler called in interrupt context
9 * captures the timer expiry event
10 */
11 void power_key_timer(void *data)
12 {
13
sm_handle_event(power, TIMER_EXPIRY);
14 }
15 /*
16 * Background loop for capturing key press event
17 */
18 i n t main(void)
19 {
20
timer_init(TIMER_ID,
21
TIMER_DURATION,
22
TIMER_ONE_SHOT,
23
power_key_timer,
24
NULL);
25
while(1) {
26
i f (is_power_key_pressed()) {
27
sm_handle_event(power, KEY_PRESS);
28
}
29
}
30 }
23
ICONS 2011 : The Sixth International Conference on Systems
Copyright (c) IARIA, 2011              ISBN:978-1-61208-114-4

