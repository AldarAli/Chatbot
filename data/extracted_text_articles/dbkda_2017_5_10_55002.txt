The Absolute Consistency Problem of Graph Schema Mappings
with Uniqueness Constraints
Takashi Hayata∗, Yasunori Ishihara∗ and Toru Fujiwara∗
∗Graduate School of Information Science and Technology
Osaka University, Suita, Japan
Email: {t-hayata, ishihara, fujiwara}@ist.osaka-u.ac.jp
Abstract—A schema mapping is a formal representation of
the correspondence between source and target data in a data
exchange setting. Schema mappings have been extensively studied
so far in relational and XML databases. However, in graph
databases, they have not received much attention yet. A given
schema mapping is said to be absolutely consistent if every source
data instance has a corresponding target data instance. Absolute
consistency is an important property because it guarantees that
data exchange never fails for any source data instance. In
this paper, we deﬁne schema mappings for graph databases
with uniqueness constraints. Our graph databases consist of
nodes, edges, and properties, where a property is a key-value
pair and gives detailed information to nodes. A uniqueness
constraint guarantees the uniqueness of speciﬁed properties in
the whole graph database, and therefore, is useful for realizing
the functionality of primary keys in graph databases. Then, in
this paper, we propose ﬁve classes of graph schema mappings for
which absolute consistency is decidable in polynomial time.
Keywords–graph database; property; uniqueness constraint;
schema mapping; absolute consistency.
I.
INTRODUCTION
In recent years, graph-structured data has become perva-
sive. For example, route information of transportation and
communication network, connection of people on social net-
working services and so on are often cited. These data
originally have a graph structure, and it is natural to store
and manipulate them on a database while keeping the graph
structure. Because of these backgrounds, graph databases have
attracted attention in recent years. Graph-structured data has
a feature of being ﬂexible. This means that we can ﬂexibly
change the graph structure. Figure 1 illustrates ﬂight route
map between airports, where airports are represented by nodes.
Each node has a unique node id (1–6) and a property (a key-
value pair such as Airport : ORY ). Figure 2 is a graph which
represents direct ﬂight information between countries. We can
obtain this graph by integrating nodes whose countries are
the same. In this way, you may want to obtain abstract data
rather than concrete data. Also, considering big data analysis,
it may be possible to discover new features by extracting only
data having certain characteristics. Schema mappings are the
foundation of such data exchange.
A schema mapping represents the correspondence between
source databases and target databases. It is useful for formaliz-
ing data exchange between systems with different schemas and
schema evolution caused by system change. Schema mappings
have been extensively studied in relational databases [1]–
[3] and XML databases [3]–[5]. On the other hand, schema
mappings for graph databases have not been actively studied
yet. Schema mappings of graph databases without properties is
!"#$%#& ' ()*
!+",- ' .!)
/"&0 ' .,#"-
/%12&#03 4#,256
!
!"#$%#& ' 7/8
/"&0 ' 7,#56+%2,
/%12&#03 9$,"2
!"#$%#& ' /:;
!+",- ' .!)
/"&0 ' .,#"-
/%12&#03 4#,256
!"#$%#& ' </=
/"&0 ' <62"56
/%12&#03 >&,+0
!"#$%#& ' 8)?
!+",- ' ?*(
/"&0 ' 8,#"&,
/%12&#03 @,$,2
!"#$%#& ' A8:
!+",- ' ?*(
/"&0 ' ?%B0%
/%12&#03 @,$,2
!4
>7
!4
!4
!C
!C
@D
"
#
$
%
&
Figure 1. Flight route map between airports.
!"#$%&'( )*+,$
!
!"#$%&'( -&+$./
"
!"#$%&'( 0%+1'
#
!"#$%&'( 2+*+$
$%
31,45%
31,45%
31,45%
31,45%
31,45%
31,45%
Figure 2. Flight information between countries.
discussed in [6]. A study of schema mappings from a relational
schema to a graph schema is reported in [7].
In considering schema mappings, it is important to check
the absolute consistency [4] of schema mappings. In XML
databases, complexity of the absolute consistency problem
has been studied [4], [8]. A schema mapping is absolutely
consistent if any source database has a corresponding target
database. Absolute consistency guarantees that data exchange
based on the schema mapping never fails. Figure 3 illustrates
ﬂight information between IATA codes. We can compute this
ﬁgure by applying a speciﬁc schema mapping to Figure 1
(see Example 5 for details). However, if there is a constraint
that IATA codes are unique, this mapping does not satisfy the
absolute consistency because a source graph in Figure 1 has
103
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-558-6
DBKDA 2017 : The Ninth International Conference on Advances in Databases, Knowledge, and Data Applications

!"#" $ %&'
()*+ $ ,-.)/
!"#" $ 0(1
()*+ $ 02.342.56-
!"#" $ (78
()*+ $ ,-.)/
!"#" $ 9(:
()*+ $ 926)42
!"#" $ 1&#
()*+ $ 1-.)*-
!"#" $ ;17
()*+ $ #5<+5
!"#" $ ,"&
()*+ $ ,-.)/
!"#" $ ,"&
()*+ $ ,-.)/
!"#" $ #'%
()*+ $ 1-.)*-
!"#" $ #'%
()*+ $ #5<+5
!"
!!
!#
!$
!%
!&
!'
!(
!)
"*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
=3)>?*
Figure 3. Flight information between IATA codes.
!"#$%&'()!*+)%&'!
*+$,&*'()!*+)%&'"
!%-&.+'.+//(),'#
0#&$1'$
Figure 4. The the general setting of data exchange [3].
not a corresponding target graph.
The purpose of this paper is twofold. The ﬁrst purpose is to
deﬁne schema mappings for graph databases with properties.
As stated above, the existing study [6] focuses on graph
schema mappings without properties. However, properties en-
rich the expressive power of graph databases. In our study,
we target graph databases such that nodes have properties.
In addition, we introduce constraints on properties called
uniqueness constraints, which are adopted by Neo4j [9]. A
uniqueness constraint guarantees the uniqueness of a node with
the speciﬁed property in the whole graph database. Then we
deﬁne schema mappings for graph databases with properties
and uniqueness constraints. The other purpose is to investigate
classes of schema mappings for which absolute consistency
is tractable. In this paper, we propose three classes whose
member is always absolutely consistent. Then we propose two
more classes for which absolute consistency is decidable in
polynomial time.
II.
RELATED WORK
Data exchange is a problem of ﬁnding an instance of a
target schema, given an instance of a source schema and a
speciﬁcation of the relationship between the source and the
target. Such a target instance should correctly represent infor-
mation from the source instance under the constraints imposed
by the target schema, and it should allow one to evaluate
queries on the target instance in a way that is semantically
consistent with the source data. Figure 4 shows the image
of the general setting of data exchange. In this ﬁgure, we
have ﬁxed source and target schemas, an instance I of the
source schema, and a schema mapping M that speciﬁes the
relationship between the source and the target schemas. The
goal is to construct an instance J of the target schema, based
on I and M, and answer queries against the target data in a
way consistent with the source data. Such a target instance
is called a solution for the given source instance. As can be
seen from Figure 4, a schema mapping is an important concept
underlying data exchange.
In the relational scenario, schema mappings and data
exchange have been studied in much literature (e.g., [1]–
[3]). They deﬁne schema mappings and address the problem
of materializing target instances and the problem of query
answering.
In the XML scenario, schema mappings and data exchange
have been studied in much literature (e.g., [3]–[5], [8]).
Compared to the relational model, the tree model gives more
opportunities for expressing structural properties of data even
with simple queries based on patterns. On the other hand,
schemas impose strong conditions on the structure of source
and target instances, entering into complex interactions with
source-to-target dependencies. These strong conditions cause
consistency problem which is one of the central issues in
XML data exchange. In [4], [8], they address the consis-
tency and absolute consistency problems of XML schema
mappings. A schema mapping is consistent if some source
instance has a corresponding target instance. Also, a schema
mapping is absolutely consistent if any source instance has a
corresponding target instance. In XML schema mappings, it
has been proved that the consistency problem is undecidable
if we consider the comparison of data values [3]. Without
considering the comparison of data values, it has been proved
that the consistency problem is solvable in exponential time
[3]. It has been proved that the absolute consistency problem
for schema mappings based on downward navigation is de-
cidable in EXPSPACE and NEXPTIME-hard [3], [4]. Some
tractability results on consistency and absolute consistency
problems between restricted schemas are reported in [8], [10].
In the graph scenario, schema mappings and data exchange
have not been actively studied yet. In [6], they deﬁne schema
mappings for graph data and address some problems of data
exchange. Like relational and XML databases, they address the
problem of materializing solutions and the problem of query
answering. But they focus on graph schema mappings without
properties and constraints such as uniqueness constraints, and
hence schema mappings are always absolutely consistent in
their setting.
Bidirectional transformations refer to a mechanism that
maintains consistency through conversion between two sources
of information. As one approach to bidirectional transfor-
mations, Triple Graph Grammars (TGGs) are well known,
which deﬁne the correspondence between two different types
of models in a declarative way [11]–[13]. A rule in a TGG
is a triple of a source graph, a correspondence graph, and a
target graph, and by applying rules to an axiom, both models
are generated simultaneously. In TGGs, it is easy to deﬁne the
correspondence between two different types of models, but it
is not trivial to ﬁnd the corresponding target instance when
a source instance is given, as considered in data exchange.
That is because TGGs grow a source graph, a correspondence
graph, and a target graph in parallel, so it is ﬁrst necessary
to ﬁnd how to apply rules to an axiom to obtain the source
instance.
104
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-558-6
DBKDA 2017 : The Ninth International Conference on Advances in Databases, Knowledge, and Data Applications

III.
DEFINITIONS
A. Graph Databases
A graph schema S is a tuple (Σ, K), where
•
Σ is a ﬁnite set of edge labels, and
•
K is a ﬁnite set of keys.
Let ﬁx a countable set O of values. A property (of a node)
is a pair of a key in K and a value in O. A graph database G
over a graph schema S = (Σ, K) is a tuple (N, E, f), where
•
N is a ﬁnite set of node ids,
•
E ⊆ N × Σ × N is a ﬁnite set of labeled edges, and
•
f : N × K → O is a partial function which binds
node ids and properties.
When f(n, k) is undeﬁned, it is interpreted that node n does
not have a property with key k, and we write f(n, k) = ⊥. In
this paper, it is assumed that edges have no properties.
Example 1: Let ﬁx O as {ORY, BCN, CDG, V CE,
HND, NRT, PAR, TY O, Paris, Barcelona, V enice,
Tokyo, Narita, France, Spain, Italy, Japan}. Consider a
graph schema S = (Σ, K), where Σ = {IB, AF, AZ, JL}
and K = {Airport, Alias, City, Country}. Figure 1 illus-
trates a graph database G = (N, E, f) over S, where
•
N = {1, 2, 3, 4, 5, 6},
•
E = {(1, AF, 2), (2, IB, 1), (3, AF, 2), (3, AF, 5),
(4, AZ, 2), (4, AZ, 6), (6, JL, 4)}, and
•
f(1, Airport) = ORY , f(1, Alias) = PAR,
f(1, City) = Paris, f(1, Country) = France,
f(2, Airport) = BCN, f(2, City) = Barcelona,
f(2, Country) = Spain, f(3, Airport) = CDG,
f(3, Alias) = PAR, f(3, City) = Paris,
f(3, Country) = France, and so on.
B. Uniqueness Constraitnts
A uniqueness constraint is speciﬁed as a set of keys and
ensures that properties of the speciﬁed keys are unique in a
graph database. In other words, there should not be different
nodes with the same value for the speciﬁed keys.
Deﬁnition 1 (Uniqueness Constraints): A uniqueness con-
straint U over a graph schema S = (Σ, K) is a subset of K.
A graph database G = (N, E, f) satisﬁes U if the following
condition holds:
∀n, n′ ∈ N, ∀k ∈ U,
(f(n, k) ̸= ⊥) ∧ (f(n′, k) ̸= ⊥) ∧ (f(n, k) = f(n′, k))
⇒ n = n′.
Example 2: The graph database shown in Figure 3 does
not
satisfy
U
=
{IATA}
because
f(12, IATA)
=
f(15, IATA) and f(18, IATA) = f(20, IATA). On the
other hand, the graph database shown in Figure 2 satisﬁes
U = {Country} because for each value o ∈ O, there is at
most one node n such that f(n, Country) = o.
C. Graph Patterns
Graph patterns represent a part of a graph database and
can be used as queries for a given graph database. We also
use graph patterns for describing mapping rules in schema
mappings for graph databases.
Let ﬁx a countable set X of variables representing values.
A graph pattern π over a graph schema S = (Σ, K) is a tuple
(θ, µ, λ), where
•
θ is a ﬁnite set of node variables,
•
µ ⊆ θ × REG(Σ) × θ is a ﬁnite set of path patterns,
where REG(Σ) is the set of regular expressions over
Σ, and
•
λ ⊆ {v.k == x | v ∈ θ, k ∈ K, x ∈ X} is a ﬁnite set
of equalities such that if two equalities (v.k == x)
and (v.k == y) are in λ, then x and y are the same
variable.
We assume that no node variables are shared by different graph
patterns, although variables in X are shared in general, as in
mapping rules deﬁned later.
We deﬁne the semantics of a graph pattern π in terms of
homomorphisms. Let g : X → O be a mapping that assigns a
value to each variable. Let G = (N, E, f) be a graph database.
A graph pattern π = (θ, µ, λ) is modeled by (G, h, g) if
homomorphism h : π → G satisﬁes the following conditions:
1)
for each node variable v ∈ θ, h(v) ∈ N,
2)
for each path pattern (v, L, u) ∈ µ, there is a
path from h(v) to h(u) in G such that the edge
label sequence along the path matches the regular
expression L, and
3)
for each equality (v.k == x) ∈ λ, f(h(v), k) =
g(x).
We write (G, h, g) |= π if π is modeled by (G, h, g). The
semantics of π under S and g is deﬁned as follows:
[[π]]S,g = {G over S | (G, h, g) |= π for some h}.
Example 3: Let ﬁx X as {x} and O as {A, B}. Let V =
{s, t, u, v} be a ﬁnite set of node variables. Consider a graph
schema S = (Σ, K), where Σ = {a, b} and K = {k}. Figure 5
illustrates a graph pattern π = (θ, µ, λ) over S, where
•
θ = {s, t, u, v},
•
µ = {(s, a, t), (u, b, v)}, and
•
λ = {(s.k == x), (t.k == x)}.
Figure 6 illustrates a graph database G = (N, E, f) over S,
where
•
N = {1, 2, 3, 4},
•
E = {(1, a, 2), (3, a, 4), (3, b, 1), (2, c, 4)}, and
•
f(1, k) = A, f(2, k) = A, f(3, k) = A, and f(4, k) =
B.
As shown in Figure 7, a homomorphism h such that
(G, h, g) |= π maps s into 1, t into 2, u into 3, and v into 1.
We can conﬁrm that the graph pattern π represents a part of
the graph database G.
105
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-558-6
DBKDA 2017 : The Ninth International Conference on Advances in Databases, Knowledge, and Data Applications

! " #
$
%&
! " #
'
(&
)&&&
*&&&
Figure 5. A graph pattern π.
! " #
$
!
! " #
"
! " #
#
! " %
$
$
&
'
Figure 6. A graph database G.
!
"
#
#
#
#
! " #
$
%&
! " #
'
(&
)&&&
*&&&
! " #
$
!
! " #
"
! " #
#
! " %
$
$
&
'
Figure 7. A homomorphism h : π → G.
D. Schema Mappings
Schema mappings represent the correspondence between
source databases and target databases. We deﬁne schema
mappings for graph databases with properties from now.
Let SS be a source graph schema and ST a target graph
schema. Let US and UT be uniqueness constraints over SS
and ST , respectively. A schema mapping M from SS to ST
is a tuple ((SS, US), (ST , UT ), ∆), where ∆ is a ﬁnite set of
mapping rules of the form πS → πT . Here, πS = (θS, µS, λS)
and πT = (θT , µT , λT ) are graph patterns over SS and ST ,
respectively. Each λS must be linear with respect to variables
in X, that is, each variable in X appears at most once in λS.
Deﬁnition 2 (Solutions): Let
M
=
((SS, US), (ST , UT ), ∆) be a schema mapping. Let GS
be a graph database over SS satisfying US, and GT a graph
database over ST satisfying UT . A pair (GS, GT ) satisﬁes M
if the following condition holds: For each (πS → πT ) ∈ ∆
and for any gS : X → O, there exists gT : X → O such that
1)
gS(x) = gT (x) for each variable x ∈ X appearing in
both πS and πT ; and
2)
if GS ∈ [[πS]]SS,gS, then GT ∈ [[πT ]]ST ,gT .
If a pair (GS, GT ) satisﬁes M, we write (GS, GT ) |= M,
and GT is called a solution for GS under M. Let SolM(GS)
denote the set of solutions for GS under M.
Without loss of generality, we assume that no variables in
X are shared by different mapping rules.
Example 4: Let SS = (ΣS, KS) and ST = (ΣT , KT ) be
graph schemas such that
•
ΣS = {IB, AF, AZ, JL},
•
KS = {Airport, Alias, City, Country},
•
ΣT = {flight}, and
•
KT = {Country}.
Also, let
•
US = {Airport},
•
UT = {Country}, and
•
∆ = {πS → πT },
where πS = (θS, µS, λS) and πT = (θT , µT , λT ) are graph
patterns such that
•
θS = {v1, v2},
•
µS = {(v1, (IB|AF|AZ|JL), v2)},
•
λS = {(v1.Country == x), (v2.Country == y)},
•
θT = {u1, u2},
•
µT = {(u1, flight, u2)}, and
•
λT = {(u1.Country == x), (u2.Country == y)}.
Then, the graph database in Figure 2 is a solution for that in
Figure 1 under M = ((SS, US), (ST , UT ), ∆).
Deﬁnition 3 (Absolute Consistency): A schema mapping
M
= ((SS, US), (ST , UT ), ∆) is absolutely consistent if
SolM(GS) ̸= ∅ for every graph database GS over SS satisfying
US.
Example 5: Let M
=
((SS, US), (ST , UT ), ∆) be a
schema mapping, where SS = (ΣS, KS) and ST = (ΣT , KT )
be graph schemas such that
•
ΣS = {IB, AF, AL, JL},
•
KS = {Airport, Alias, City, Country},
•
ΣT = {flight}, and
•
KT = {IATA, City}.
Also, let
•
US = {Airport},
•
UT = {IATA}, and
•
∆ = {πS1 → πT1, πS2 → πT2, πS3 → πT3, πS4 →
πT4},
where πS1 = (θS1, µS1, λS1), πT1 = (θT1, µT1, λT1), πS2 =
(θS2, µS2, λS2), πT2 = (θT2, µT2, λT2), πS3 = (θS3, µS3, λS3),
πT3 = (θT3, µT3, λT3), πS4 = (θS4, µS4, λS4), and πT4 =
(θT4, µT4, λT4) are graph patterns such that
•
θS1 = {u1, u2},
•
µS1 = {(u1, (IB|AF|AZ|JL), u2)},
•
λS1 = {(u1.City == x1), (u1.Airport == y1),
(u2.City == z1), (u2.Airport == w1)},
•
θT1 = {v1, v2},
•
µT1 = {(v1, flight, v2)},
•
λT1 = {(v1.City == x1), (v1.IATA == y1),
(v2.City == z1), (v2.IATA == w1)},
•
θS2 = {u3, u4},
•
µS2 = {(u3, (IB|AF|AZ|JL), u4)},
106
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-558-6
DBKDA 2017 : The Ninth International Conference on Advances in Databases, Knowledge, and Data Applications

•
λS2 = {(u3.City == x2), (u3.Airport == y2),
(u4.City == z2), (u4.Alias == w2)},
•
θT2 = {v3, v4},
•
µT2 = {(v3, flight, v4)},
•
λT2 = {(v3.City == x2), (v3.IATA == y2),
(v4.City == z2), (v4.IATA == w2)},
•
θS3 = {u5, u6},
•
µS3 = {(u5, (IB|AF|AZ|JL), u6)},
•
λS3 = {(u5.City == x3), (u5.Alias == y3),
(u6.City == z3), (u6.Airport == w3)},
•
θT3 = {v5, v6},
•
µT3 = {(v5, flight, v6)},
•
λT3 = {(v5.City == x3), (v5.IATA == y3),
(v6.City == z3), (v6.IATA == w3)},
•
θS4 = {u7, u8},
•
µS4 = {(u7, (IB|AF|AZ|JL), u8)},
•
λS4 = {(u7.City == x4), (u7.Alias == y4),
(u8.City == z4), (u8.Alias == w4)},
•
θT4 = {v7, v8},
•
µT4 = {(v7, flight, v8)}, and
•
λT4 = {(v7.City == x4), (v7.IATA == y4),
(v8.City == z4), (v8.IATA == w4)}.
Given a graph in Figure 1 as a source instance and this
schema mapping, we can compute a graph in Figure 3,
if we do not consider UT . However, taking into account
UT , the graph in Figure 3 does not satisfy UT because
f(18, IATA) = f(20, IATA). That is, this schema mapping
M is not absolutely consistent.
The
size
|M|
of
a
schema
mapping
M
=
((SS, US), (ST , UT ), ∆) is the sum of the sizes of SS,
US, ST , UT , and ∆. The size of a schema S = (Σ, K) is the
sum of the numbers of elements in Σ and K. The size of a
uniqueness constraint U is the number of elements in U. The
size of ∆ is the sum of the sizes of graph patterns appearing
in ∆. The size of a graph pattern π = (θ, µ, λ) is the sum of
the numbers of elements in θ, µ, and λ.
IV.
TRACTABLE CLASSES OF SCHEMA MAPPINGS FOR
ABSOLUTE CONSISTENCY
Let M = ((SS, US), (ST , UT ), ∆) be a schema mapping,
where SS = (ΣS, KS) and ST = (ΣT , KT ). In this section,
we show that the absolute consistency of M is decidable in
polynomial time if M belongs to one of the following ﬁve
classes:
1)
KS is empty;
2)
UT is empty;
3)
KT is a singleton;
4)
US is empty; and
5)
∆ is a singleton and the mapping rule is projecting,
where πS → πT is projecting if the set of variables
for values appearing in πT is a subset of those
appearing in πS.
For example, the schema mapping shown in Example 4 be-
longs to not only the third class but also the ﬁfth class because
∆ is a singleton and the set {x, y} of variables appearing in
πT is the same as that in πS.
A. Three Easy Classes
In this section, we show that M is always absolutely
consistent if M belongs to one of the ﬁrst three classes. First,
we show the following lemma, which states the existence of a
graph database G0 that matches any graph pattern.
Lemma 1: Let S = (Σ, K) be a graph schema and U be
a uniqueness constraint over S. There is a graph database G0
over S satisfying U such that for any graph pattern π over S,
there is g : X → O such that G0 ∈ [[π]]S,g.
Proof: Deﬁne G0 = (N0, E0, f0) as follows:
•
N0 = {n},
•
E0 = {(n, a, n) | a ∈ Σ}, and
•
f0(n, k) is the same value for all k ∈ K.
It is easy to see that G0 satisﬁes the lemma.
Theorem 1: M is absolutely consistent if KS is empty.
Proof: We show that G0 introduced in the proof of
Lemma 1 is a solution for any GS over S. Suppose that
GS ∈ [[πS]]SS,gS for some (πS → πT ) ∈ ∆ and gS : X → O.
Since KS is empty, λS is also empty, and hence πS has no
variable in X. Therefore, the ﬁrst condition of Deﬁnition 2
holds for any gT
: X
→ O. By Lemma 1, we have
G0 ∈ [[πT ]]ST ,g for some g.
The next lemma says that each graph pattern is matched
by a graph database with the “same shape.”
Lemma 2: Let S = (Σ, K) be a graph schema and π =
(θ, µ, λ) be a graph pattern over S. For any g : X → O,
[[π]]S,g is not empty.
Proof: Consider the following graph database Gπ =
(Nπ, Eπ, fπ):
•
Nπ contains θ, where node variables are regarded as
node ids,
•
for each (v0, L, vn) ∈ µ, Eπ contains (v0, a1, v1),.. .,
(vn−1, an, vn) such that a1 · · · an matches L and
v1,..., vn−1 are not in θ, and
•
fπ(v, k) = x for each (v.k == x) ∈ λ, where variable
x is regarded as a value.
It is easy to see that such Gπ is well deﬁned and Gπ ∈ [[π]]S,id,
where id(x) = x for every variable x.
Now, consider a graph database Gπ,g obtained by replacing
each value x in Gπ with g(x). Then, Gπ,g ∈ [[π]]S,g.
Theorem 2: M is absolutely consistent if UT is empty.
Proof: Let GS be a source graph database over SS
satisfying US. Consider a target graph database GT over ST
that contains GπT ,gS as its subgraph for all gS : X → O
such that GS ∈ [[πS]]SS,gS for some (πS → πT ) ∈ ∆, where
GπT ,gS is the same graph database as in the proof of Lemma 2.
Such GT always exists since UT is empty. Also, GT is a
solution for GS because GπT ,gS ∈ [[πT ]]ST ,gS.
Theorem 3: M is absolutely consistent if KT is a single-
ton.
Proof: Consider again the target graph database GT in
the proof of Theorem 2. Since UT ⊆ KT , we have UT = ∅
or UT = KT . In either case, GT satisﬁes UT . Actually, if UT
and KT are the same singleton sets, each node of GT has at
most one property, and the nodes with the same property can
be an identical node.
107
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-558-6
DBKDA 2017 : The Ninth International Conference on Advances in Databases, Knowledge, and Data Applications

B. No Uniqueness Constraints for Source Databases
Now, we consider the case where US = ∅. In this case, the
variables appearing in the graph patterns for source databases
can have independent, arbitrary values. Hence, we can stati-
cally analyze M based on abstract interpretation, where the
variable names represent abstract values.
Let XS and XT be the sets of variables for values ap-
pearing in πS and πT , respectively, for some mapping rule
(πS → πT ) ∈ ∆. Let X = XS ∪ XT . Deﬁne
ΛT
=
∪
(πS→(θT ,µT ,λT ))∈∆
λT .
Deﬁne ∼ as the least equivalence relation on X satisfying the
following condition: x ∼ y if v.k == x and v.k′ == y are in
ΛT for some k ∈ UT , k′ ∈ KT , and z ∈ XS such that x ∼ z.
Roughly speaking, the condition in the following theorem
says that if a target node has a key k in UT and the value of
k is dependent on a value in the source database, then all the
other keys of the node must be dependent on the same value.
Theorem 4: M
= ((SS, ∅), (ST , UT ), ∆) is absolutely
consistent if and only if there are no distinct variables x,
y ∈ XS such that x ∼ y.
Proof: (Only if part.) Suppose that x ∼ y for some distinct
variables x, y ∈ XS. It can be shown that (v.k == z) and
(v.k′ == y) in ΛT such that x ∼ z and k ∈ UT .
For the simplest case, let us consider the case where
(v.k == x) and (v.k′ == y) in ΛT for some k ∈ UT .
Consider two mappings g1 and g2 such that g1(x) = g2(x)
but g1(y) ̸= g2(y). There is a source database GS such
that GS ∈ [[πS]]SS,g1 and GS ∈ [[πS]]SS,g2 because the
uniqueness constraints for source databases is empty. Now,
a solution GT
= (NT , ET , fT ) for GS must satisfy the
following conditions:
•
GT has a node n1 such that fT (n1, k) = g1(x) and
fT (n1, k′) = g1(y); and
•
GT has a node n2 such that fT (n2, k) = g2(x) and
fT (n2, k′) = g2(y).
Since k ∈ UT , n1 and n2 must be the same node, but that
contradicts the assumption that g1(y) ̸= g2(y).
The general cases can be shown in a similar way.
(If part.) Let GS be a source graph database over SS. Let
GT = (NT , ET , fT ) be a target graph database containing
all GπT ,gπS ,gS deﬁned below, such that GS ∈ [[πS]]SS,gS for
some (πS → πT ) ∈ ∆ and gS : XS → O. We will show that
GT is a solution for GS and UT can be satisﬁed by GT .
First, we deﬁne GπT ,gπS ,gS . Suppose that GS ∈ [[πS]]SS,gS
for some (πS → πT ) ∈ ∆ and gS : XS → O. For each of
such pairs of πS and gS, we choose gπS,gS : XT → O so that
gπS,gS(x) =
{
gS(y)
if x ∼ y for some y ∈ XS,
oπS,gS,x
otherwise,
where oπS,gS,x is a unique, distinct value in O determined by
πS, gS, and x. gπS,gS is well deﬁned because each equivalence
class derived by ∼ has at most one variable in XS. Now,
GπT ,gπS ,gS ∈ [[πT ]]ST ,gπS ,gS is the graph database introduced
in the proof of Lemma 2.
It is obvious that GT is a solution for GS because GT
contains all GπT ,gπS,gS ∈ [[πT ]]ST ,gπS ,gS . Let n ∈ NT be a
node id of some GπT ,gπS ,gS . Suppose that fT (n, k) = o for
some key k ∈ UT and value o ∈ O. There must be an equality
v.k == x in πT . We consider the following two cases:
1)
If x ∼ y for some y ∈ XS, then by the deﬁnitions
of ∼ and gπS,gS, we have fT (n, k′) = o for any
k′ ∈ KT such that fT (n, k′) is deﬁned. Therefore,
all such nodes n ∈ NT with fT (n, k) = o can be an
identical node.
2)
If there is no y ∈ XS such that x ∼ y, then o must
be a unique value in GT , hence the existence of n
does not violate UT .
In summary, UT can be satisﬁed by GT .
The equivalence relation ∼ can be computed in O(|M|3)
time. Hence we have the following theorem:
Theorem 5: The absolute consistency of M is decidable in
polynomial time if US is empty.
C. A Single Projecting Rule
Now, we consider the case where ∆ = {πS → πT } and
πS → πT is projecting. Let X be the set of variables for
values appearing in πS. Since US is not empty, the values of
the variables in X are not independent. For example, suppose
that πS has the following equalities: v.k == x, u.k == y,
v.k′ == z, and u.k′ == w. If k ∈ US, equality between
x and y causes equality between z and w. To capture this
phenomenon, below we introduce a function EπS,US(EQ)
which returns, for a given set of equalities on X, all the
resultant equalities caused by π and U.
Formally, let π = (θ, µ, λ) be a graph pattern with variables
in X, and U ⊆ K be a uniqueness constraint. For EQ ⊆
X × X, deﬁne Eπ,U(EQ) ⊆ X × X as the least equivalence
relation such that
1)
EQ ⊆ Eπ,U(EQ), and
2)
for any pair (x, y) ∈ Eπ,U(EQ) and any node vari-
ables v, u ∈ θ, if (v.k == x), (u.k == y) ∈ λ for
some key k ∈ U, then (z, w) ∈ Eπ,U(EQ) for every
z, w ∈ X such that (v.k′ == z), (u.k′ == w) ∈ λ
for some k′ ∈ K.
Let EQg denote the equivalence relation on variables
induced by g : X → O, i.e., (x, y) ∈ EQg if and only if
g(x) = g(y). The following two lemmas say that EQg is a
ﬁxpoint of Eπ,U if and only if there are G, h, and g such that
(G, h, g) |= π and G satisﬁes U.
Lemma 3: Suppose that (G, h, g) |= π and G satisﬁes a
uniqueness constraint U. Then, EQg = Eπ,U(EQg).
Proof: Since EQg ⊆ Eπ,U(EQg) by deﬁnition, it sufﬁces
to show that g(z) = g(w) for any pair (z, w) ∈ Eπ,U(EQg).
Consider the shortest proof P(z,w) of the membership of an
arbitrary (z, w) ∈ Eπ,U(EQg), i.e., an application sequence
of reﬂexivity, symmetry, transitivity, and the two rules of the
deﬁnition of Eπ,U. We show g(z) = g(w) by the induction on
the length of P(z,w).
For the basis, there are two cases. If (z, w) is in Eπ,U(EQg)
by reﬂexivity, then z and w are the same variable. If (z, w) is
in Eπ,U(EQg) by the ﬁrst rule of the deﬁnition of Eπ,U, then
(z, w) must be in EQg. In both cases, we have g(z) = g(w).
For the induction step, there are three cases. If (z, w) is
in Eπ,U(EQg) by symmetry, we must already have (w, z) ∈
108
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-558-6
DBKDA 2017 : The Ninth International Conference on Advances in Databases, Knowledge, and Data Applications

Eπ,U(EQg). Then, we have g(z) = g(w) by the inductive
hypothesis. If (z, w) is in Eπ,U(EQg) by transitivity, we can
show that g(z) = g(w) in a similar way to the symmetry case.
Now, suppose that (z, w) is in Eπ,U(EQg) by the second rule
of the deﬁnition of Eπ,U. Then, there are some pair (x, y) ∈
Eπ,U(EQg), node variables v, u ∈ θ, and keys k ∈ U and k′ ∈
K such that (v.k == x), (u.k == y), (v.k′ == z), (u.k′ ==
w) ∈ λ. Since (G, h, g) |= π, we have f(h(v), k) = g(x),
f(h(u), k) = g(y), f(h(v), k′) = g(z), and f(h(u), k′) =
g(w), where G = (N, E, f). It holds that g(x) = g(y) by the
inductive hypothesis. Since G satisﬁes uniqueness constraint
U and U contains k, we have h(v) = h(u). Hence, g(z) =
f(h(v), k′) = f(h(u), k′) = g(w).
Lemma 4: Suppose that EQ = Eπ,U(EQ). Then, there are
G, h, and g such that G satisﬁes the uniqueness constraint U,
(G, h, g) |= π, and EQ = EQg.
Proof: Suppose that EQ = Eπ,U(EQ), where π =
(θ, µ, λ). Choose an arbitrary g : X → O such that EQg =
EQ.
Let θ/EQ be the ﬁnest equivalence classes of node vari-
ables such that if there are (x, y) ∈ EQ and k ∈ U such that
(v.k == x), (u.k == y) ∈ λ, then v and u are in the same
equivalence class in θ/EQ. Let [v] denote the equivalence
class which v belongs to.
Similarly to Gπ in the proof of Lemma 2, consider a graph
database G = (N, E, f) such that
•
N contains θ/EQ, where the equivalence classes are
regarded as node ids,
•
for each (v0, L, vk) ∈ µ, E contains (n0, a1, n1),...,
(nk−1, ak, nk) such that a1 · · · ak matches L, n0 =
[v0], nk = [vk], and v1,.. . , vk−1 are not in θ/EQ,
and
•
f([v], k′) = g(x) for each (v.k′ == x) ∈ λ.
To see that G is well deﬁned, consider the shortest proof P(v,u)
of that [v] = [u], i.e., an application sequence of reﬂexivity,
symmetry, transitivity, and the deﬁnition of θ/EQ. We show
f([v], k′) = f([u], k′) for all k′ ∈ K by the induction on the
length of P(v,u).
For the basis, there are two cases. If [v] = [u] by reﬂexivity,
then v = u, and hence f([v], k′) = f([u], k′). If [v] = [u] by
the deﬁnition of θ/EQ, there are (x, y) ∈ EQ and k ∈ U such
that (v.k == x), (u.k == y) ∈ λ. Since EQ is a ﬁxpoint
of Eπ,U, we have (z, w) ∈ EQ for every z, w ∈ X such
that (v.k′ == z), (u.k′ == w) ∈ λ, by the second rule of
the deﬁnition of Eπ,U. Hence, f([v], k′) = g(z) = g(w) =
f([u], k′).
The induction step is trivial. If [v] = [u] by symmetry,
then we have [u] = [v], and by the inductive hypothesis,
f([u], k′) = f([v], k′) for all k′ ∈ K. The case of transitivity
can be shown in a similar way.
Now, we have to show that G satisﬁes U. Assume con-
trarily that G does not satisfy U. There would be v, u ∈ θ
and k ∈ U such that [v] ̸= [u] and f([v], k) = f([u], k).
Hence, there would be v′ ∈ [v], u′ ∈ [u], x, y ∈ X such that
(v′.k == x), (u′.k == y) ∈ λ and (x, y) ∈ EQ. However,
by the deﬁnition of θ/EQ, we must have [v′] = [u′]. This is
a contradiction.
Theorem 6: Let M = ((SS, US), (ST , UT ), {πS → πT })
be a schema mapping such that πS → πT is projecting. M is
absolutely consistent if and only if every ﬁxpoint of EπS,US is
also a ﬁxpoint of EπT ,UT .
Proof: Immediate from Lemmas 3 and 4 since πS → πT
is projecting.
In what follows, we show that the condition in Theorem 6
can be checked in polynomial time. The condition seems to
require the computation of EπS,US and EπT ,UT for exponen-
tially many EQs. Surprisingly, by the following two lemmas,
such computation can be reduced to the computation for only
EQs that are singletons.
Lemma 5: The followings are equivalent:
1)
Every ﬁxpoint of EπS,US is also a ﬁxpoint of EπT ,UT .
2)
EπT ,UT (EQ) ⊆ EπS,US(EQ) for each subset EQ ⊆
X × X.
Proof: (1 ⇒ 2) Let EQ ⊆ X × X. Let EQS =
EπS,US(EQ) and EQT
= EπT ,UT (EQ). Since EQS is a
ﬁxpoint of EπS,US, it is also a ﬁxpoint of EπT ,UT , i.e.,
EQS = EπT ,UT (EQS). Since EQ is a subset of EQS, we
have EQT = EπT ,UT (EQ) ⊆ EπT ,UT (EQS) = EQS.
(2
⇒
1) Let EQ be a ﬁxpoint of EπS,US. Then,
EπT ,UT (EQ) ⊆ EπS,US(EQ) = EQ. On the other hand, by
the deﬁnition of EπT ,UT (EQ), we have EQ ⊆ EπT ,UT (EQ).
Hence EQ = EπT ,UT (EQ).
Lemma 6: The followings are equivalent:
1)
EπT ,UT (EQ) ⊆ EπS,US(EQ) for each subset EQ ⊆
X × X.
2)
EπT ,UT ({(x, y)}) ⊆ EπS,US({(x, y)}) for each pair
(x, y) ∈ X × X.
Proof:
Let
EQS
=
EπS,US(EQ)
and
EQT
=
EπT ,UT (EQ). The part (1 ⇒ 2) is obvious. To show the part
(2 ⇒ 1), consider the shortest proof P(z,w) of the membership
of an arbitrary (z, w) in EQT , i.e., an application sequence
of reﬂexivity, symmetry, transitivity, and the two rules of the
deﬁnition of Eπ,U. We show (z, w) ∈ EQS by the induction
on the length of P(z,w).
For the basis, there are two cases. If (z, w) is in EQT by
reﬂexivity, then it is also in EQS by reﬂexivity. If (z, w) is
in EQT by the ﬁrst rule of the deﬁnition of Eπ,U, then (z, w)
must be in EQ and hence it is also in EQS by the same rule.
For the induction step, there are three cases. If (z, w) is in
EQT by symmetry, we must already have (w, z) ∈ EQT .
Then, we have (w, z) ∈ EQS by the inductive hypothe-
sis, and hence, (z, w) ∈ EQS. If (z, w) is in EQT by
transitivity, we can show that (z, w) ∈ EQS in a similar
way to the symmetry case. Now, suppose that (z, w) is in
EQT by the second rule of the deﬁnition of Eπ,U. Then,
we have (z, w)
∈
EπT ,UT ({(x, y)}). By the assumption
that EπT ,UT ({(x, y)}) ⊆ EπS,US({(x, y)}), (z, w) is also in
EπS,US({(x, y)}). Hence, (z, w) ∈ EQS since (x, y) ∈ EQS
by the inductive hypothesis.
Eπ,U({(x, y)}) can be computed in O(|M|6) time (by a
very naive algorithm). So, the second condition of Lemma 6
can be checked in O(|M|8) time.
Theorem 7: The absolute consistency of M is decidable
in polynomial time if ∆ = {πS → πT } is a singleton and
πS → πT is projecting.
109
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-558-6
DBKDA 2017 : The Ninth International Conference on Advances in Databases, Knowledge, and Data Applications

V.
CONCLUSION
In this paper, we have deﬁned schema mappings for graph
databases with properties. In considering graph databases with
properties, we have introduced uniqueness constraints, which
are constraints on properties. Then, we have proposed ﬁve
classes of schema mappings for which absolute consistency
is decidable in polynomial time.
There still are remaining tasks. We are going to examine
the complexity of the absolute consistency problem for schema
mappings not belonging to the ﬁve classes because these
classes seem restrictive from the practical point of view.
Also, we plan to implement a program to check the absolute
consistency problem for these ﬁve classes. It is also necessary
to consider schema mappings for graph databases whose edges
have properties as well as nodes.
ACKNOWLEDGMENT
We thank Professor Soichiro Hidaka at Hosei University
for his kind introduction to bidirectional transformations and
TGGs. We would like to thank all the reviewers for their
valuable comments on our paper.
REFERENCES
[1]
P. Barcel´o, “Logical foundations of relational data exchange,” SIGMOD
Record, vol. 38, no. 1, 2009, pp. 49–58.
[2]
R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa, “Data exchange:
semantics and query answering,” Theor. Comput. Sci., vol. 336, no. 1,
2005, pp. 89–124.
[3]
M. Arenas, P. Barcel´o, L. Libkin, and F. Murlak, Relational and XML
Data Exchange, ser. Synthesis Lectures on Data Management. Morgan
& Claypool Publishers, 2010.
[4]
S. Amano, L. Libkin, and F. Murlak, “XML schema mappings,” in
Proceedings of the Twenty-Eigth ACM SIGMOD-SIGACT-SIGART
Symposium on Principles of Database Systems, 2009, pp. 33–42.
[5]
M. Arenas and L. Libkin, “XML data exchange: Consistency and query
answering,” J. ACM, vol. 55, no. 2, 2008, pp. 7:1–7:72.
[6]
P. Barcel´o, J. P´erez, and J. L. Reutter, “Schema mappings and data
exchange for graph databases,” in Joint 2013 EDBT/ICDT Conferences,
ICDT ’13 Proceedings, 2013, pp. 189–200.
[7]
I. Boneva, A. Bonifati, and R. Ciucanu, “Graph data exchange with
target constraints,” in Proceedings of the Workshops of the EDBT/ICDT
2015 Joint Conference (EDBT/ICDT), 2015, pp. 171–176.
[8]
H. Kuwada, K. Hashimoto, Y. Ishihara, and T. Fujiwara, “The consis-
tency and absolute consistency problems of XML schema mappings
between restricted DTDs,” World Wide Web, vol. 18, no. 5, 2015, pp.
1443–1461.
[9]
J. J. Miller, “Graph database applications and concepts with Neo4j,”
in Proceedings of the Southern Association for Information System
Conference, Atlanta, GA, USA, March 23-24th, 2013, 2013.
[10]
Y. Ishihara, H. Kuwada, and T. Fujiwara, “The absolute consistency
problem of XML schema mappings with data values between restricted
dtds,” in Database and Expert Systems Applications - 25th International
Conference, DEXA 2014, Munich, Germany, September 1-4, 2014.
Proceedings, Part I, 2014, pp. 317–327.
[11]
A. Sch¨urr, “Speciﬁcation of graph translators with triple graph gram-
mars,” in Graph-Theoretic Concepts in Computer Science, 20th Inter-
national Workshop, WG ’94, Herrsching, Germany, June 16-18, 1994,
Proceedings, 1994, pp. 151–163.
[12]
F. Hermann, H. Ehrig, F. Orejas, and U. Golas, “Formal analysis of
functional behaviour for model transformations based on triple graph
grammars,” in Graph Transformations - 5th International Conference,
ICGT 2010, Enschede, The Netherlands, September 27 - - October 2,
2010. Proceedings, 2010, pp. 155–170.
[13]
E. Kindler and R. Wagner, “Triple graph grammars: Concepts, ex-
tensions, implementations, and application scenarios,” Department of
Computer Science, University of Paderborn, Technical Report tr-ri-07-
284, 2007.
110
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-558-6
DBKDA 2017 : The Ninth International Conference on Advances in Databases, Knowledge, and Data Applications

