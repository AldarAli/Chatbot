Advanced Space Filtering for the Construction of
3D Additively Weighted Voronoi Diagram
Michal Zemek, Martin Maˇn´ak, Ivana Kolingerov´a
Department of Computer Science and Engineering
University of West Bohemia
Pilsen
mzemek@kiv.zcu.cz, manak@kiv.zcu.cz, kolinger@kiv.zcu.cz
Abstract—Spatial relationships among 3D spheres can be
described by an additively weighted Voronoi diagram and
this diagram can be used for advanced spatial analysis. The
diagram can be constructed by an edge tracing algorithm.
The problem is that tracing an edge is a time consuming
operation, where many spheres are tested. Former approaches
make it faster by using space ﬁlters and searching for spheres
intersecting the ﬁlter. But they are inefﬁcient when the spheres
have very different radii. Our approach presented in this paper
is designed to be fast even on this kind of data. It is based on
modiﬁed space ﬁlters and the search for spheres intersecting
the ﬁlter is performed in a power diagram.
Keywords-computational
geometry,
additively
weighted
Voronoi diagram, geometric ﬁlter
I. INTRODUCTION
Space partitioning schemes are often used in the analysis
of space among 3D spheres. The analysis can include but is
not limited to the computation of the volume and surface
occupied by their union, inspecting the free volume or
ﬁnding internal voids. This is especially important in the
study of molecules or granular materials. To solve these
tasks effectively, it is fundamental to have a good space
partitioning scheme. Several kinds of Voronoi diagrams and
their dual triangulations have been used in this area [1].
A diagram partitions the space into regions and each region
belongs to a generator (in our case - a sphere). Especially
aw-Voronoi diagrams (additively weighted) turned out to be
useful [2], because they describe spatial relationships among
spheres very well. But their regions can have non-linear
boundaries, so their computation is not so easy as in the
case of diagrams with linear boundaries.
The aw-Voronoi diagram can be constructed by the edge
tracing algorithm [3], which we will describe later in Sec-
tion IV-B. The basic variant of the algorithm is slow (at least
quadratic time complexity), therefore, ﬁltering approaches
have been devised to decrease the number of spheres tested
in the algorithm by considering only the spheres intersecting
some ﬁlter (e.g., the union of a ﬁlled sphere and a half-
space). Previous ﬁltering approaches have been devised pri-
marily for molecular data, where spheres have very similar
radii and cannot be too close or too far. But in general data,
there can be very large spheres as well as very small and the
distribution of their positions can be nonuniform. Previous
approaches are inefﬁcient on such data.
A. Contribution
In this paper we will present another ﬁltering approach.
The main idea is to compute a simpler power diagram for the
input spheres in a preprocessing step and then use it in the
construction of the aw-diagram when spheres intersecting
a ﬁlter need to be found. Our ﬁlters are a modiﬁcation of
previous ﬁlters described in [4]. Both these ﬁlters perform
well on non-uniformly distributed data, which is an advan-
tage over the previous grid based ﬁltering approach [5]. In
contrast to [4], ﬁlters proposed in this paper are not affected
by the size of the largest sphere in the input data. This is
possible, because we use power diagrams and our improved
version of a method for intersection detection [6] to search
our ﬁlters for intersecting spheres. This way smaller and thus
more effective ﬁlters than in the previous approaches can be
used, but there is also some additional cost of searching in
the power diagram. On some datasets, e.g., for spheres with
very similar radii, our approach is slower than the previous
approaches, but on dense sets of spheres with various radii,
it substantially outperforms its predecessors.
B. Paper Outline
Section II summarizes the work related to the acceler-
ation of the edge tracing algorithm. Section III describes
intersection detection based on power diagrams. Section IV
is dedicated to aw-Voronoi diagrams, the edge tracing algo-
rithm and space ﬁlters. Our new ﬁltering approach, which
combines the ﬁlters and the intersection detection method,
is described in Section V. Experimental results are given in
Section VI and Section VII concludes the paper.
II. RELATED WORK
There are several algorithms for the construction of an aw-
Voronoi diagram [3], [7], [8], [9], [10], [11] or its approxi-
mation [12]. The edge tracing and similar algorithms [3],
[7], [8] are less complex and easier to implement than
the others. They are based on a simple idea of tracing
37
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-172-4
ADVCOMP 2011 : The Fifth International Conference on Advanced Engineering Computing and Applications in Sciences

Voronoi edges [13], which has been also used to construct
the Voronoi diagram of convex objects [14].
Because the basic variant of the edge tracing algorithm [3]
is slow, space ﬁlters are used to make it faster [5]. The
basic idea is to compute a space ﬁlter, which limits the
spheres tested by the edge tracing algorithm to the spheres
intersecting the ﬁlter. In [5], a ﬁlter is the union of a ﬁlled
sphere and a half-space. In the preprocessing, all input
spheres are stored in a regular grid. To search the ﬁlter
for intersecting spheres, grid cells covering the ﬁlter are
visited and spheres associated to these cells are tested for an
intersection with the ﬁlter. The grid based approach is lim-
ited to uniformly distributed input data. Another approach
overcomes this problem by using Delaunay triangulation to
search the ﬁlter [4]. The idea is to compute the Delaunay
triangulation of sphere centers in the preprocessing and
expand the size of each ﬁlter by the radius of the greatest
sphere. The search for spheres intersecting the ﬁlter is
performed in the triangulation and is limited to spheres
having their centers inside the ﬁlter. The ﬁlter reduces its
volume during the search. This approach can be inefﬁcient
for data with spheres of very different sizes.
III. POWER DIAGRAMS FOR SPACE FILTERING
Our approach for the intersection detection between
spheres and aforementioned ﬁlters (thoroughly described in
Section IV-C) utilizes power diagrams and it is based on
a method [6] (it is used as a black-box for the intersection
detection in Section V, its details are not necessary for
understanding the rest of the paper, but are inevitable for the
implementation). First, let us remind the concept of power
diagrams, then we will describe the idea of the intersection
detection.
Let S = {s1, ..., sn} be a set of spheres in R3, where
each sphere si has a center ci ∈ R3 and a non-negative
radius ri. Let ||x−y|| denote the Euclidean distance between
points x, y ∈ R3. Power diagrams employ a so called power
distance. The power distance of a point x from a sphere
si is deﬁned as dpow(si, x) = ||ci − x||2 − ri2. The power
region of si ∈ S is the set of points PR(si) = {x ∈ R3 :
dpow(si, x) ≤ dpow(sj, x), ∀sj ∈ S, sj ̸= si}. We say that si
is the generator of PR(si). If PR(si) is empty, si is called
redundant. The power diagram of S is the set of all power
regions and is denoted by PD(S). A power region PR(si)
is a convex polyhedron (possibly unbounded). If two power
regions PR(si) and PR(sj) share a face, we say that they
are neighbouring and si is a neighbor of sj.
A. Intersection Detection
The detection of intersections between spheres and a gen-
eral object using power diagrams is discussed in [6], but we
have slightly improved the described approach. The idea is
as follows. A power diagram is traversed a region by region,
for each explored region a decision is made, which of its
neighbors have to be also scheduled and explored. Step by
step, the explored area is enlarged until a certain condition,
guaranteeing that there is no unknown sphere intersecting
Q, is fulﬁlled. Now let us formalize this condition.
We assume Q ⊂ R3 is a solid without cavities. Such
Q will be referred to as a query object Q. Let us have
PD(S) and a query object Q and let R be a subset of
faces of PD(S) forming one or more bounded or unbounded
polygonal surfaces without holes, such that these surfaces do
not intersect Q. Then the set R will be referred to as the
rampart of Q, RQ for short (see Figure 1). The interior of
RQ is the part of R3 bounded by RQ and containing Q. The
exterior of RQ is R3\(RQ∪ interior of RQ). The generators
of all non-empty power regions, which are adjacent to RQ
and lie in the interior of RQ, are the guardians of RQ. The
generators of all non-empty power regions, which lie in the
exterior of RQ, are the invaders of RQ.
Q
Figure 1.
A rampart of Q – a thick black polyline, guardians – shaded
circles (2D analogy).
Lemma 1: Given a set of spheres S and a query object
Q. Let RQ be a rampart of Q such that each guardian si of
RQ fulﬁlls at least one of these conditions:
• si does not intersect Q, or
• si does not intersect any of its neighboring invaders.1
Then no invader of RQ intersects Q.
Proof: is an analogy to the proof described in [6] and,
for a sake of brevity, it is omitted here.
This lemma leads to the following algorithm. At the
beginning, all the regions are supposed to be unknown.
Starting with a region containing some point of Q, the
power diagram is traversed by a breadth-ﬁrst search. Each
time an unknown region PR(si) is explored, it is marked
as known and its generator and the faces shared with its
unknown neighbors are tested. Let f be a face shared by the
known region PR(si) and its unknown neighbor PR(sj).
The region PR(sj) is not scheduled if and only if both the
following conditions are met:
• Q ∩ f = ∅,
• Q ∩ si = ∅ or si ∩ sj = ∅.
1This condition is the difference from the original lemma in [6]. It
reduces the size of explored area for a minimal additional cost.
38
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-172-4
ADVCOMP 2011 : The Fifth International Conference on Advanced Engineering Computing and Applications in Sciences

This is done repeatedly until no scheduled region remains.
In the end, the faces shared by the known and unknown
regions make up the rampart RQ satisfying Lemma 1 and
all spheres intersecting Q have been found.
This algorithm does not deal with redundant generators.
This issue is discussed in [6].
IV. CONSTRUCTION OF AW-VORONOI DIAGRAM
In this section, we will deﬁne the additively weighted
Voronoi diagram, mention an algorithm for its construction
and then describe ﬁlters that will help the algorithm to run
faster. These ﬁlters are based on [4], but are smaller and
thus more effective.
A. Additively Weighted Voronoi Diagram
The aw-distance of a point x ∈ R3 from si ∈ S is deﬁned
as daw(si, x) = ||ci−x||−ri. The aw-Voronoi region of si ∈
S is the set of points VR(si) = {x ∈ R3 : ∀sj ∈ S, sj ̸=
si, daw(si, x) ≤ daw(sj, x)}. The aw-Voronoi diagram of
S is the set of regions VD(S) = {VR(s1), . . . , VR(sn)}.
These terms are illustrated on a 2D analogy in Figure 2(a).
In 3D, the boundary of a region consists of faces, their
boundary consists of edges and the boundary of edges
consists of vertices. An example of a region with boundary
edges is shown in Figure 2(b). Without further restrictions,
some regions, faces and edges can be unbounded, because
they continue to inﬁnity. This would complicate diagram
representation and algorithms, therefore we will always
assume this is handled, e.g., by a virtual sphere representing
inﬁnity. Under this assumption, all regions, faces and edges
are bounded, with the only exception of pure elliptic edges.
x
si
daw(si,x)
ri
ci
VR(si)
(a) 2D aw-Voronoi diagram and
aw-distance
s4
s4
s3
s3
e3
e3
s1
s1
VR(s1)
VR(s1)
v2
v2
v1
v1
e1
e1
e2
e2
s2
s2
(b) 3D aw-Voronoi region VR(s1),
its boundary edges e1, e2, e3 and their
bounding vertices v1 and v2
Figure 2.
Additively weighted Voronoi diagram
From the geometric point of view, each face is a part
of a plane or a hyperboloid, each edge is a part of a line,
a hyperbola or an ellipse and each vertex is a point. But
the geometrical interpretation of boundary elements is not
so important. What matters is the information which input
spheres deﬁne their geometry. Each region is given by one
input sphere, each face by two, each edge by three and each
vertex by four spheres. We will always assume that this
information (which spheres deﬁne the geometry) is available
for each boundary element. Only edges and vertices are
necessary to describe the diagram. Faces can be determined
from edges. This simpliﬁes the representation of a diagram
to a graph of vertices and edges.
B. Diagram Construction Algorithm
The graph of Voronoi vertices and edges can be con-
structed by the edge tracing algorithm [3], [7], which works
as follows. First, an initial vertex is found and four edges
incident to this vertex are pushed onto a stack. Then, until
the stack is empty, edges are popped from the stack and for
each edge, the second bounding vertex is found. If it is a
new vertex, three more edges are pushed onto the stack.
The algorithm ﬁnds the whole component of edge con-
nectivity. Finding an initial vertex [7], elliptic edges without
bounding vertices, handling inﬁnity and discovering all com-
ponents of the diagram is not necessary for understanding
our paper. Important is to know how an edge is traced for
the second bounding vertex, so let us describe it now.
When an edge is pushed onto a stack, only one of its two
bounding vertices is known - the start vertex vs. From the
position of vs and its four deﬁning spheres, three spheres
deﬁning the edge and the direction of the edge can be
determined. A candidate to the other bounding vertex can
be found by taking a sphere and, together with the three
spheres, computing its position. The candidate, which has
its position closest to vs, creates the other bounding vertex
- the end vertex ve. Comparing distances along edge can be
realized via angular distance shown in Figure 3.
vs
s1
s1
p1
s2
s2
+
+
+p2
(a) 2D example
p1
p2
<
vs
vs
+
+
+
+
(b) 3D example
Figure 3.
Comparing distances along an edge via angular distance θ - the
point p1 is closer to the vertex vs than the point p2
C. Space Filters
In a brute force approach, the end vertex is found by
trying all spheres except the three spheres deﬁning the edge,
computing vertex candidates corresponding to these spheres
and taking the one with minimal angular distance. This can
be improved by using spatial ﬁlters. The idea [5] is to limit
the space, which the sphere for the end vertex must intersect.
Each ﬁlter is deﬁned individually for an edge from the
knowledge of the start vertex vs, the end vertex candidate
ve and the three spheres deﬁning the geometry of the edge.
Let us ﬁrst deﬁne an ideal ﬁlter L(ve). Its 2D analogy
is shown in Figure 4(a). Each point x of the edge is the
center of a ﬁlled ball s(x) tangent to the deﬁning spheres
(or a half-space if x is at inﬁnity). The ideal ﬁlter is
39
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-172-4
ADVCOMP 2011 : The Fifth International Conference on Advanced Engineering Computing and Applications in Sciences

deﬁned as the union of all such ﬁlled balls with centers
x ∈ [vs, ve] on the edge without the ball at the start vertex:
L(ve) = S
x∈edge[vs,ve] s(x)\s(vs). The ball s(vs) cannot be
intersected by any sphere since vs is a true Voronoi vertex.
If L(ve) is not intersected by another sphere, then ve is the
true end vertex, else the sphere intersecting L(ve) deﬁnes a
candidate v′
e closer to vs and another L(v′
e) ⊂ L(ve).
Because the shape of L(ve) is not trivial, we will cover
it by a bigger ﬁlter F(ve), which is simpler. Let us ﬁrst
describe the ﬁlter for a non-elliptic edge with 2D analogy
depicted in Figure 4(b). It is the union of two ﬁlters F(ve) =
F1 ∪ F2(ve). The ﬁrst ﬁlter F1 is computed (in 3D) from
supporting planes tangent to the spheres deﬁning the edge
as the ﬁlled ball passing through the corresponding tangent
points, cut off by the supporting planes. The ﬁlter F1 is static
- it does not depend on ve. The second ﬁlter F2(ve) = s(ve)
is the ﬁlled ball centered at the end vertex candidate ve or
a half-space if ve is at inﬁnity. When the edge is an ellipse,
we compute F(ve) as the smallest ball enclosing the union
S
x∈ellipse s(x). In this case, the ﬁlter is also static.2
(a) Ideal ﬁlter L(ve)
s2
s2
s1
s1
s3
s3
s4
s4
F2(ve)
F2(ve)
F1F1
vsvs
ve
ve
+
+
(b) Filter F(ve) = F1 ∪ F2(ve)
that covers L(ve)
Figure 4.
2D analogy of ﬁlters for the given edge – s1 and s2 deﬁne
the geometry of the edge, vs is the start vertex and ve is the end vertex
candidate.
The situation in 3D is similar to the 2D analogy. The
ﬁlter F2 is a sphere or a half-space, the ﬁlter F1 is a sphere
without two half-spaces. Notice that the center of the sphere
may or may not be included in F1 as shown in Figure 5.
+ F1F1
(a) F1 includes the center
+
F1F1
(b) F1 does not include the center
Figure 5.
Two possible cases of F1 in 3D
2Unlike the original ﬁlters [4], the proposed ﬁlters F1, F2 are not
expanded by the radius of the biggest sphere of S. Another improvement
is the reduction of the volume of F1 by the two cutting planes.
V. PROPOSED METHOD
Here we will describe our ﬁltering approach for end
vertex search. It combines the aforementioned ﬁlters with
the described method for the intersection detection.
First, a power diagram of S is computed in a preprocess-
ing step. Then, during the construction of VD(S), a ﬁlter
F(ve) is created for each end vertex search. Using PD(S)
and the method for intersection detection described in III-A,
a search for spheres intersecting F(ve) is performed. If such
a sphere is not found, then ve is the real end vertex. But if
some sphere si intersecting F(ve) is found, it must be tested
whether it deﬁnes a candidate v′
e closer to vs than ve. This
is done by computing the positions of possible end vertex
candidates v′
e and testing their angular distance against the
angular distance of ve. If v′
e is closer, this means that L(ve)
is intersected by si, so F(ve) is replaced by F(v′
e), possibly
reducing the space to be further searched.
Now let us describe this processing of a ﬁlter F(ve) in
detail. The ﬁlter consists of two parts, of ﬁlters F1 and
F2, and the search for spheres intersecting them is done
independently of each other (with one exception – if a sphere
intersects both ﬁlters F1 and F2, its corresponding end vertex
candidate is computed only once). A ﬁlter F1 is static, it
does not change during one end vertex search. A ﬁlter F2 is
dynamic – if a sphere intersecting F1 or F2 is found and it
deﬁnes a closer end vertex candidate v′
e (i.e. with a smaller
angular distance), the ﬁlter F2 is updated. Its center is moved
into the new vertex candidate v′
e and its radius is reduced so
the resulting F2 is tangent to the spheres deﬁning v′
e. Let us
note that although F2 changes during its processing, the used
algorithm for intersection detection still works correctly.3
Let us show the algorithm on an example in Figure 6.
For the sake of simplicity, it is just a 2D analogy. The
initial conﬁguration is shown in Figure 6(a). There is a set
of generators {s1, . . . , s12}, an edge e and a start vertex
vs. The start vertex vs is given by a set of three (in
3D four) generators {s1, s2, s3} and a sphere inscribed to
these generators. The edge e is given by a set of two
(in 3D three) generators {s1, s2} and the orientation. The
task is to ﬁnd another generator, different from s1 and
s2, which, together with s1 and s2, creates the end vertex
ve, i.e., the vertex candidate on e closest (in terms of the
angular distance) to vs. The generator will be found among
generators intersecting appropriate space ﬁlters. The initial
ﬁlter F(v∞) = F1 ∪ F2(v∞) can be computed from the
initial conﬁguration. The ﬁlter F1 is static, so it can be
searched through ﬁrst. In Figure 6(b), the search through F1
starts from a region intersecting F1, e.g., the region PR(s1),
3 The main idea of the proof of this claim is as follows. If a sphere si
causes an update of a ﬁlter, the updated F2 is tangent to si. If F2 intersects
some sphere, then there must be a neighbor sj of si such that either F2
intersects the face generated by si and sj, or si ∩ sj ̸= ∅ and thus the
region of sj, intersecting F2, is to be scheduled and F2 cannot ‘run off”
the searched area.
40
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-172-4
ADVCOMP 2011 : The Fifth International Conference on Advanced Engineering Computing and Applications in Sciences

and explores generators s1, . . . , s5. Although s4 ∩ F1 = ∅,
s4 is explored because PR(s4) ∩ F1 ̸= ∅. Although the
other explored generators intersect F1, none of them can
create a suitable vertex candidate to reduce the dynamic
ﬁlter. Next in Figure 6(c), the search through the dynamic
ﬁlter F2(v∞) starts from a region intersecting F2(v∞). We
have selected PR(s6) for this example, but the real selection
should be based on some heuristic, which will be discussed
later. So s6 is the ﬁrst generator scheduled for exploring. In
Figure 6(d), s6 is explored. Because s6 intersects F2(v∞),
it is used to compute a vertex candidate v1 ∈ e. The angular
distance of v1 from vs is less than the angular distance of
v∞ from vs, therefore the ﬁlter is updated to F2(v1). This
is a big reduction - from a half-space to a sphere. From
now on it is sufﬁcient to check only generators intersecting
F2(v1). Because PR(s6)∩F2(v1) = ∅ and s6 ∩F2(v1) ̸= ∅,
only neighbors of s6 intersecting s6 must be scheduled for
exploring - at least one of them will have its power region
intersecting F2(v1). In this case, only s9 is scheduled. Next
in Figure 6(e), s9 is explored, a closer vertex candidate
v2 computed and the ﬁlter updated to F2(v2). Neighbors
s10 and s11 are scheduled, because the edge (face in 3D)
between s9 and s10 and between s9 and s11 intersect F2(v2).
Neither s10 nor s11 intersects F2(v2), therefore they cannot
create a closer end vertex candidate. Exploring s10 and s11
results in scheduling s4, s12, and s2. Next in Figure 6(f),
s4 is explored, a closer end vertex candidate v3 computed
and the ﬁlter updated to F2(v3). The remaining generators
s12, s2, s1 and s3 are explored, but none of them creates a
closer candidate, therefore v3 is the end vertex ve.
Because a sphere intersecting F1 can cause a reduction
of F2, but not vice versa, it is better to process the ﬁlter F1
ﬁrst and then F2. It is also possible that F2 becomes fully
absorbed by F1 after a ﬁlter update. In such a case the rest of
the processing of F2 can be skipped, the current end vertex
candidate is the real end vertex. So it is useful to perform
the O(1) test whether F2 ⊆ F1 before the processing of F2
and after each update of F2 during its processing.
Still, ﬁlters F2 are often very big at the beginning of their
processing. We have developed two simple heuristics, each
of them quickly and substantially reduces the size of F2. One
of them tests the intersections between F2 and all neighbors
of the three spheres generating the current edge. Often, some
of these neighbors intersect F2 and thus reduce it.
The other heuristic localizes the center of F2 in PD(S)
by traversing from a region to region, using a visibility
walk [15]. The walk starts in the region of one of the spheres
generating the current edge and locates the region containing
the center of F2. A generator of each region explored during
the walk is tested, whether it intersects F2. If so, F2 is
updated, the destination point is changed to the new center
of F2 and the walk continues from the lastly explored region.
A performance of both heuristics is similar in practice.
e
s1
s1
s7
s7
s2
s2
s3
s3
s4
s4
s5
s5
s6
s6
s8
s8
s9
s9
s10
s10
s11
s11
s12
s12
++
vs
vs
(a) The initial conﬁguration with a
start vertex vs given by {s1, s2, s3}
and
with
an
edge
e
given
by
{s1, s2}. We want to ﬁnd the end
vertex ve ∈ e closest to vs.
F1
F1
s1
s1
s7
s7
s2
s2
s3
s3
s4
s4
s5
s5
s6
s6
s8
s8
s9
s9
s10
s10
s11
s11
s12
s12
++
vs
vs
(b) The search through F1 explores
s1, s2, s3, s4, and s5, but no suit-
able end vertex candidate is found.
F2(v
8
)
F2(v
8
)
s1
s1
s7
s7
s2
s2
s3
s3
s4
s4
s5
s5
s6
s6
s8
s8
s9
s9
s10
s10
s11
s11
s12
s12
+
vs
vs
(c) The the search through F2(v∞)
starts from, e.g., PR(s6), so s6 is
scheduled for exploring.
+v1
v1
F2(v1)
F2(v1)
s1
s1
s7
s7
s2
s2
s3
s3
s4
s4
s5
s5
s6
s6
s8
s8
s9
s9
s10
s10
s11
s11
s12
s12
+
vs
vs
(d) When s6 is explored, a candidate
v1 ∈ e is computed and the ﬁlter
updated to F2(v1).
+v2
v2
F2(v2)
F2(v2)
s1
s1
s7
s7
s2
s2
s3
s3
s4
s4
s5
s5
s6
s6
s8
s8
s9
s9
s10
s10
s11
s11
s12
s12
+
vs
vs
(e) When s9 is explored, a candidate
v2 ∈ e is computed and the ﬁlter
updated to F2(v2). Neighbors s10
and s11 are scheduled, then explored
and s4, s12, and s2 scheduled.
+v3
v3
F2(v3)
F2(v3)
s1
s1
s7
s7
s2
s2
s3
s3
s4
s4
s5
s5
s6
s6
s8
s8
s9
s9
s10
s10
s11
s11
s12
s12
+
vs
vs
(f) When s4 is explored, a candi-
date v3 is computed and the ﬁlter
updated to F2(v3). No closer candi-
date is found after exploring genera-
tors s12, s2, s1, and s3, so ve = v3.
Figure 6.
Algorithm example in 2D
VI. EXPERIMENTS AND RESULTS
We
compared
the
proposed
method
against
the
method [4], based on Delaunay triangulation (hence it
will be referred to as Delaunay method), because it is the
best competitive method for general input data. We did
not compare it against the brute force method [3], because
it is too slow to be interesting. Both implementations
are written in C# 3.5 and the experiments were done on
Intel Core i7, 3.07GHz with 6GB RAM running Windows
7. We were interested in the running time consumed by
the construction of aw-Voronoi diagrams and the average
number of generators explored during one end vertex
search. We distinguish a touched generator and a tested
generator. To touch a generator means to ﬁnd out whether
the generator is already known (which takes O(1) time).
To test a generator means to compute its intersection with
one part of a ﬁlter. Moreover in the proposed method,
41
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-172-4
ADVCOMP 2011 : The Fifth International Conference on Advanced Engineering Computing and Applications in Sciences

it also includes a check of a local neighborhood of the
generator, as described in III-A. For datasets used in our
experiments, this additional check runs in O(1) time in
average case. But the hidden multiplicative constant is
big – the test of one generator in the proposed method
is roughly 10 times slower in comparison with Delaunay
method. In consequence, for sets of spheres with similar
radii and for sparse sets of spheres, the proposed method
is roughly 2 times slower than Delaunay method. But with
increasing differences in radii and increasing density of
spheres, the ﬁlters used in Delaunay method (as well as
the regular grid-based ﬁltering approach mentioned in II)
become ineffective, while the performance of the proposed
method is almost unaffected.
This is illustrated in the following two experiments. In the
ﬁrst experiment, the density of the dataset is constant and the
difference of radii changes. The used dataset contains 10000
points randomly scattered in a unit box and one sphere
lying outside the box. The radius r of the sphere changes
from 0 to 1. Figure 7 shows dependency of the construction
time of the aw-Voronoi diagram on r, Figure 8 the average
number of performed tests per one edge of the diagram.
For a small value of r, Delaunay method outperforms the
proposed method. But while the running time (as well as
the number of tests) of the proposed method is minimally
affected by r, the ﬁlters used in Delaunay method become
inefﬁcient for increasing r.
In the second experiment, the difference of radii is con-
stant and the density changes. The dataset is formed by
a unit box containing 10 congruent spheres with a radius
0.1 and n points, where n ∈ ⟨100, 64000⟩. Figure 9 shows
that while the construction based on the proposed method
runs approximately in O(n1.2) time, the construction based
on Delaunay method runs in O(n1.9). Note that the proposed
method outperforms Delaunay method starting at n = 250.
This corresponds with the average numbers of performed
tests per one edge, shown in Figure 10. On the given range
of n, the numbers of generators tested and touched by the
proposed method increase less than 3 times, whereas the
growth for Delaunay method is more than 500 times.
Now let us mention datasets, which are suitable neither for
the proposed, nor for the previous ﬁltering approaches. The
ﬁltering approaches are inefﬁcient for datasets with many
mutually intersecting spheres. The dataset used in the last
experiment consists of n unit spheres with centers randomly
scattered in a unit box and of one point. This point prevents
the improving of the performance with a trick, where the
radius of each sphere is reduced by the minimal radius.
In consequence, ﬁlters are intersected by almost all spheres
and the diagram construction runs approximately in O(n2),
regardless of the used ﬁltering approach. Here the original
edge tracing algorithm outperforms the ﬁlter-based methods,
nevertheless, it also runs in quadratic time. Recall that our
ﬁlter is an approximation encapsulating the ideal ﬁlter.
0
100
200
300
400
500
600
700
800
900
1000
1100
1200
1300
0,0
0,1
0,2
0,3
0,4
0,5
0,6
0,7
0,8
0,9
1,0
CPU Seconds
Radius
Delaunay Method
Proposed Method
Figure 7.
Aw-Voronoi diagram computation time – 10000 random points
in a unit box and one sphere of the given radius.
Figure 8.
Average number of tests per one aw-Voronoi edge – 10000
random points in a unit box and one sphere of the given radius.
Another example of data unsuitable for our ﬁltering
approach is data with high probability that the power region
of a sphere intersects the approximation ﬁlter but the sphere
does not intersect the ideal ﬁlter. In this case many spheres
will be explored but only a few of them will actually reduce
the ﬁlter.
Our implementation runs in only one CPU thread. When
a diagram is being constructed, many edges must be traced.
With the increasing number of computation cores in modern
hardware, it might pay off to trace more edges in parallel,
using our ﬁltering approach to speed up the tracing.
VII. CONCLUSION
We have proposed a new ﬁltering approach for a con-
struction of aw-Voronoi diagrams. The proposed approach
combines ﬁlters based on [4] and a method for the in-
tersection detection [6]. We have slightly improved both
these two techniques. We have shown that on dense sets of
42
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-172-4
ADVCOMP 2011 : The Fifth International Conference on Advanced Engineering Computing and Applications in Sciences

Figure 9. Aw-Voronoi diagram computation time – 10 spheres with a radius
0.1 together with an increasing count of points in a unit box.
Figure 10.
Average number of tests per one aw-Voronoi edge – 10 spheres
with a radius 0.1 together with an increasing count of points in a unit box.
spheres with various radii the proposed ﬁltering approach
signiﬁcantly outperforms the previous Delaunay approach.
As a future work, we recommend to investigate a hybrid
method combining the proposed and Delaunay approaches
together with the original edge tracing algorithm. First,
a simple statistic on an input set of spheres would be
computed and according to its result, the most suitable
technique would be chosen for the diagram construction.
Another open problem is to design ﬁlters suitable for a set
of mutually intersecting spheres.
ACKNOWLEDGMENT
This work has been supported by the Czech Science Foun-
dation under the project P202/10/1435 and by the University
of West Bohemia under the project SGS-2010-028.
REFERENCES
[1] A. Poupon, “Voronoi and Voronoi-related tessellations in
studies of protein structure and interaction,” Current Opinion
in Structural Biology, vol. 14, no. 2, pp. 233 – 241, 2004.
[2] D.-S. Kim, “A beta-complex solves all geometry problems in
a molecule,” in The 6th International Symposium on Voronoi
Diagrams in Science and Engineering, 2009, pp. 254–260.
[3] D.-S. Kim, Y. Cho, and D. Kim, “Euclidean Voronoi diagram
of 3d balls and its computation via tracing edges,” Computer-
Aided Design, vol. 37, pp. 1412–1424, 2005.
[4] M. Manak and I. Kolingerova, “Fast discovery of Voronoi
vertices in the construction of Voronoi diagram of 3d balls,”
International Symposium on Voronoi Diagrams in Science
and Engineering, vol. 0, pp. 95–104, 2010.
[5] Y. Cho, D. Kim, H.-C. Lee, J. Y. Park, and D.-S. Kim,
“Reduction of the search space in the edge-tracing algorithm
for the Voronoi diagram of 3d balls,” in ICCSA (1), 2006,
pp. 111–120.
[6] M. Zemek and I. Kolingerov´a, “Power diagrams and inter-
section detection,” in ICCSA, vol. 3, 2011, pp. 163–173.
[7] N. N. Medvedev, V. P. Voloshin, V. A. Luchnikov, and M. L.
Gavrilova, “An algorithm for three-dimensional Voronoi S-
network,” Journal of Computational Chemistry, vol. 27,
no. 14, pp. 1676–1692, 2006.
[8] D.-S. Kim, D. Kim, Y. Cho, and K. Sugihara, “Quasi-
triangulation and interworld data structure in three dimen-
sions,” Computer-Aided Design, vol. 38, no. 7, pp. 808–819,
2006.
[9] J.-D. Boissonnat and C. Delage, “Convex hull and Voronoi
diagram of additively weighted points,” in ESA, 2005, pp.
367–378.
[10] D. Kim, Cho, and D.-S. Kim, “Region expansion by ﬂipping
edges for Euclidean Voronoi diagrams of 3d spheres based
on a radial data structure,” in ICCSA (1), 2005, pp. 716–725.
[11] D. Kim and D.-S. Kim, “Region-expansion for the Voronoi
diagram of 3d spheres,” Computer-Aided Design, vol. 38, pp.
417–430, 2006.
[12] E. Yaffe and D. Halperin, “Approximating the pathway axis
and the persistence diagram of a collection of balls in 3-
space,” in SCG ’08: Proceedings of the twenty-fourth annual
symposium on Computational geometry.
New York, NY,
USA: ACM, 2008, pp. 260–269.
[13] M. Tanemura, T. Ogawa, and N. Ogita, “A new algorithm for
three-dimensional Voronoi tessellation,” Journal of Compu-
tational Physics, vol. 51, no. 2, pp. 191 – 207, 1983.
[14] V. A. Luchnikov, N. N. Medvedev, L. Oger, and J.-P. Troadec,
“Voronoi-delaunay analysis of voids in systems of nonspher-
ical particles,” Phys. Rev. E, vol. 59, no. 6, pp. 7205–7212,
Jun 1999.
[15] O. Devillers, S. Pion, and M. Teillaud, “Walking in a triangu-
lation,” Internat. J. Found. Comput. Sci, vol. 13, pp. 106–114,
2001.
43
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-172-4
ADVCOMP 2011 : The Fifth International Conference on Advanced Engineering Computing and Applications in Sciences

