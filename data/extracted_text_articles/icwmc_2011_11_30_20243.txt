Secure, Privacy-Preserving, and Context-Restricted Information Sharing for
Location-based Social Networks
Michael D¨urr, Philipp Marcus, and Kevin Wiesner
Mobile and Distributed Systems Group
Department for Informatics
Ludwig-Maximilians-University Munich
80538 Munich, Germany
Email: {michael.duerr,philipp.marcus,kevin.wiesner}@iﬁ.lmu.de
Abstract—Today, Online Social Network (OSN) providers
like Facebook or Google provide their users with web-based
Location-based Services (LBSs) like Facebook Places or Google
Latitude. To facilitate proactive LBS, most OSN providers also
offer Location-based Social Network Services (LB-SNSs) for
mobile platforms like the iPhone, Android, or Symbian. A
multitude of LB-SNSs focus on proximity detection of nearby
friends. However, at present almost non of these implementa-
tions guarantees a sufﬁcient degree of information security and
privacy as well as location integrity for its users. In this paper,
we address these shortcomings in two ways. We deﬁne a set of
requirements we deem indispensable to enable LB-SNSs that
facilitate secure and privacy-preserving information sharing
and guarantee for location integrity at the same time. We then
present an extension to our decentralized OSN architecture
Vegas which incorporates these requirements and therefore
supports the secure, privacy-preserving, and location-restricted
provision of LB-SNSs.
Keywords-Online Social Networks; Proximity Detection; Lo-
cation Integrity; Privacy; Security.
I. INTRODUCTION
At present we observe a remarkable increase of Location-
based Social Network Services (LB-SNSs) for mobile plat-
forms like Android, Blackberry, or the iPhone operating sys-
tem. One reason for this development represents a steadily
increasing participation in Online Social Networks (OSNs)
like Facebook Places, Foursquare, Gowalla, or Google Lat-
itude. However, it is the implementation of such services for
mobile platforms that provokes the rocketing success of such
services. Powerful and easy-to-use location APIs for mobile
phones as well as their precise positioning technologies like
GPS can be used to implement a multitude of Location-
based Services (LBSs). This also facilitates proximity de-
tection, a frequently implemented concept in the ﬁeld of
proactive LBS. An example are buddy trackers that generate
an event in case a friend is located within a predeﬁned
distance.
To detect proximity of friends, a user has to reveal
information about his current location. Unfortunately, most
people are not aware of the implications and threats caused
by the distribution of location information. However, recent
studies [1], [2] have shown that, as people gain a deeper
knowledge about how LB-SNSs work, their demand for
security and privacy increases signiﬁcantly. In association
with LB-SNSs that focus on proximity detection of nearby
persons, one has to consider the following aspects:
1) Friendship Relevance: Although some OSN providers
like Facebook support ﬁne-grained privacy settings, most of
their users do not understand how to properly apply them.
Once enabled friends automatically get access to location
information although the relevance of this relationship can
change over time. Therefore, location information can be-
come accessible to a multitude of persons that are considered
outdated friends for a long time.
2) Third Party Providers: Most OSN providers take the
role of a trusted third party. However, even in case OSN
providers promise secure and conﬁdential application of
personal data, they cannot guard against security holes
caused by software bugs or data abuse by employees with
criminal intent. Becoming the victim of a crime due to the
unsolicited dissemination of location information must not
be possible at all.
3) Location Integrity: At present, a user that partici-
pates in a LB-SNS focusing on proximity detection cannot
verify that location information has not been forged. This
security hole could be exploited for location data mining.
For instance, an adversary could distribute forged location
information and thereby trigger proximity alerts at another
user A. Assuming a LB-SNS requires two users A and B
to share their information, the proximity alert at A would
trigger the distribution of his shared information to B. The
question that has not been answered yet is the following:
How can a user restrict his participation in an LB-SNS such
that only persons whose physical proximity he can verify
are able to get access to any of his shared information?
In this paper we address these problems in the scope of
LB-SNSs that focus on the detection of nearby persons with
similar interest and that want to share a certain type of
information. An example of such a service is location-based
ride sharing which allows its subscribers to ﬁnd each other
at a railway station to share a train ticket. Another example
243
ICWMC 2011 : The Seventh International Conference on Wireless and Mobile Communications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-140-3

is a location based coupling service which allows its users to
receive proﬁles of each other when visiting the same single
party.
Generalizing these examples of LB-SNSs, we aim at a
solution to share any kind of information within a predeﬁned
proximity in a secure, privacy-preserving, and location-
restricted way.
The contribution of our paper is twofold. We present
a) a requirements analysis for secure, privacy-preserving,
and location-restricted LB-SNS, and b) an extension to our
decentralized OSN architecture Vegas [3] which facilitates
the implementation of LB-SNS that comply with our re-
quirements for location integrity.
The paper is organized as follows. We present our re-
quirements analysis in Section II and a detailed use case
in Section III. Section IV gives a short overview of Vegas
and details our extension for LB-SNS provision. Section V
discusses our approach. Related work is presented in Section
VI and Section VII concludes the paper.
II. REQUIREMENTS
In our previous work [3], we identiﬁed four major require-
ments a secure and privacy-preserving OSN has to fulﬁll.
These requirements encompass a user’s informational self-
determination, strong trust relationships between friends,
anywhere and anytime proﬁle availability, and transparent
mobility support. However, to provide for secure, privacy-
preserving, and location-restricted LB-SNSs, we must con-
sider further requirements speciﬁc to location.
A. Context-Dependent LB-SNS Provision
LB-SNSs like Facebook Places allow their users to receive
push notiﬁcations on their mobile device as soon as a friend
initiates a check-in event. A check-in event is generated each
time a friend registers his current location within his Face-
book proﬁle. Unfortunately, virtually no LB-SNS (including
Facebook Places) offers a mechanism that allows its users
to validate location information of friends. This facilitates
an easy violation of location integrity as an adversary could
easily trigger unsolicited LB-SNS alerts by pretending to be
located at an arbitrarily chosen place. We therefore identify
the requirement of Context-Dependent LB-SNS Provision: It
must be possible to restrict LB-SNS provision by location-
restricted context information. Communication between two
participants must not be activated until both are located
within their predeﬁned proximity and mutually proved their
physical presence. This proof could be based on frequently
alternating context information exclusively available to par-
ticipants at the given location. As a user can restrict LB-
SNS provision to a speciﬁc context, an adversary physically
absent lacks this information. Hence, he is no longer able
to pretend proximity.
B. User-Selective LB-SNS Provision
A repeatedly criticized aspect of LB-SNSs are inadequate
capabilities to restrict access to shared information. Face-
book Places represents an extreme example, as it allows
even a user to publish private location information of his
friends. Hence, a user looses control over his informational
self-determination [3] as well. Even in case this feature
was disabled, a user cannot selectively restrict access to his
location information to certain friends and has no inﬂuence
on how these friends distribute his location information. To
address such problems we deﬁne the requirement of User-
Selective LB-SNS Provision. In order to increase privacy,
user must be able to deﬁne a certain persons or a subset
of persons in advance to restrict the provision of LB-SNS
services.
C. Decentralized LB-SNS Provision
At present, virtually every LB-SNS is operated in a
centralized way. Although most providers guarantee com-
pliance with more or less restrictive privacy policies, we
observe recurring privacy leaks due to unconscious software
development or employees’ criminal intent. To eliminate this
problem, personal information must be under control of its
originator. This also implies that each user should be able
to control when to trigger the provision of a LB-SNS. We
formulate the requirement for Decentralized LB-SNS Provi-
sion as unsolicited distribution of personal data by a third
party must not be possible. It is obvious that this requirement
also helps to achieve compliance with requirement II-A as
each user is responsible for the distribution of his shared
information.
III. USE CASE
To better understand our design principles, we describe
a sophisticated LB-SNS usage scenario that we reference
throughout this paper.
A university organizes a conference that focuses on secu-
rity and privacy aspects in mobile networks. In conjunc-
tion with the obligatory registration process, the confer-
ence committee decides to offer a voluntary subscription to
their conference LB-SNS. They want to provide interested
conference participants with a location-based business card
browser for mobile devices. The idea of the browser service
is to allow conference participants to browse each other’s
business card information. The browser service should be
location-restricted i.e it only displays present participants
and dynamically updates visible proﬁle information of re-
cently arriving participants.
To meet the aforementioned requirements we deﬁne fur-
ther constraints:
• The browser service must not be usable anywhere else
except at the conference location (req. II-A).
244
ICWMC 2011 : The Seventh International Conference on Wireless and Mobile Communications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-140-3

• Business cards are broadcasted automatically as a par-
ticipant arrives at the conference (req. II-A and req.
II-C).
• The visibility of business cards must be restricted to
subscribers only (req. II-B).
• Apart from the subscription process, the browser ser-
vice should work in a decentralized way (req. II-C).
IV. SYSTEM ARCHITECTURE
In the following, we present our extension in order to im-
plement secure, privacy-preserving, and location-restricted
LB-SNSs. We decided to build our solution on top of Vegas,
a decentralized secure and privacy-aware OSN that has been
developed on the design principles of our previous work
[3]. We ﬁrst review some parts of Vegas that are relevant
to understand the functionality of our approach, before we
delve into the details of our design.
A. Vegas Design
Vegas represents an OSN architecture that focuses on its
users’ security and privacy-demands. Its design was moti-
vated by a set of requirements that we identiﬁed as inevitable
in a secure and privacy preserving OSN. These requirements
encompass a user’s informational self-determination, strong
trust relationships between friends, anywhere and anytime
proﬁle availability, and transparent mobility support.
The Vegas core concept does not support communication
between participants that are not directly connected by an
edge of the underlying social graph. This restriction is
motivated by a problem we termed social network pollution.
To give but a few examples of social network pollution,
present OSNs offer the possibility for search operations on
their social graphs, provide unsolicited friendship recom-
mendations, and offer support for non-authorized linkage
of a friend’s friends. This causes a multitude of unwanted
friendship establishments, i.e., links in the social graph
which not necessarily represent a real friendship.
Figure 1 illustrates the fundamental communication prin-
ciples and components of Vegas. In Vegas each user interacts
with the OSN through one or more mobile or stationary
clients. In order to support delay-tolerant network com-
munication, we apply an asynchronous message exchange
scheme based on the concept presented in [4]. We rely on
well known services like email, SMS, or instant messaging
which can be exploited to implement the exchanger instance.
An exchanger represents the abstract concept of a message
queue which is used to transmit messages or any other kind
of content. Any two Vegas friends A and B are aware of
one or more such exchanger addresses of each other. In
addition, since a user cannot be expected to be permanently
online, we introduced the datastore component. A datastore
represents the abstract concept of a user-writable storage
space with world-readable access. A datastore can be simply
implemented through some simple-to-administer and cost-
free web space. Each user provides one or more datastores
to place his user proﬁle encrypted and signed for each of
his friends. As we will see in the next section, any kind of
Client A
Client B
Datastore A
Datastore B
Exchanger A
Exchanger B
Store Profile
Store Profile
Load Profile
Load Profile
Send Message
Send Message
SendMessage
Send Message
Figure 1.
In Vegas any piece of information exchanged between users
is encrypted and signed. Each user maintains one or more client instances
and performs encrypted messaging over one or more exchanger instances. A
user publishes individual proﬁles for each friend at one or more datastores.
information ﬂow in Vegas is subject to cryptographic oper-
ations. Every message as well as each proﬁle are separately
encrypted for each friend.
B. Vegas Operation
In a nutshell, Vegas messaging and proﬁle distribution
works as follows: Any two Vegas friends A and B generate
a unique public key pair which must not be applied for
messaging and proﬁle generation except in the context of
A and B. In the following, we term such a key pair a
link-speciﬁc key pair. As user A holds a unique key pair
K−
A→Xi/K+
A→Xi(i ∈ 1, . . . , n) for each of his n friends
X1, ..., Xn, a key pair represents nothing else than a directed
edge in the overall social graph. The notion of a key K[−|+]
A→Xi
means that this key is a private/public key generated by A for
exclusive communication with Xi. A utilizes Xi’s public key
K+
Xi→A to encrypt messages as well as proﬁle information
intended for Xi. In order to allow Xi to map a received
message to its originator A, a ﬁngerprint of A’s public key
K+
A→Xi is included into each message sent to Xi. In case
A wants to send a message to Xi, A applies Xi’s public
key K+
Xi→A to encrypt the message content. After signing
the message with K−
A→Xi, A sends this message to one
of Xi’s exchangers. Now Xi can fetch this messages and
identify sender A through his attached public key ﬁngerprint.
Since Xi is the only user that knows about the mapping of
the included ﬁngerprint, Xi represents the only user that is
able to map this ﬁngerprint to the identity of A. In case
A considers the mapping of a public key to Xi’s identity
compromised, A can trigger a key refresh operation in order
to replace all former key pairs shared with Xi.
We apply the same Vegas operations for the placement
and update of proﬁle information which we use to send
245
ICWMC 2011 : The Seventh International Conference on Wireless and Mobile Communications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-140-3

messages. In case user A wants to update his proﬁle, A
re-encrypts the corresponding information for each of his
friends X1, ..., Xn and places this information at the cor-
responding datastores. As A utilizes the same key material
to encrypt messages as well as proﬁle information for Xi,
Xi can simply perform an interval-based read operation at
A’s data store in order to receive pending updates. As an
alternative, A can trigger such an update by sending each of
his friends a corresponding notiﬁcation.
It should be stressed that a user A can cancel a friendship
with user Xi by simply deleting the link-speciﬁc key pair.
Hence, key revocation does not involve complex mainte-
nance and distribution of key revocation lists.
C. Directory Buddies
Our architecture already includes the basic functionality
necessary to support reactive LBSs comparable to those
provided by Gowalla, Foursquare, Google Latitude, or Face-
book Places. Such LBSs can be easily implemented by
extending proﬁle descriptions with location information and
introducing location-dependent proﬁle updates. To enable
sophisticated LB-SNS applications like a location-based ride
sharing, location-based coupling, or location-based business
card browsing, we have to extend Vegas as it disallows
the distribution of information to other users except Vegas
friends.
To guarantee compliance with the requirements formu-
lated in section II, we decided to extend Vegas by the
concept of directory buddies. A directory buddy represents a
special kind of Vegas friend that supports the establishment
of obfuscated connections between all participants of a LB-
SNS. Although not a requirement, it is likely that a directory
buddy is not operated by a single person but an institution or
a company that can provide additional contents. In essence,
it is the task of a directory buddy to provide for anonymous
connections between foreign persons. Figure 2 details how a
directory buddy integrates into Vegas. A Vegas user Xi that
wants to subscribe for a LB-SNS L ﬁrst has to establish
a friendship with a directory buddy C associated with L.
Xi and C require a (semi-) trusted out-of-band (OOB)
channel to exchange their public keys (K+
Xi→C, K+
C→Xi),
their exchanger addresses (ExXi, ExC), and their datastore
addresses (DSXi, DSC) (1). In case C does not require
detailed proﬁle information of Xi to support the provision
of L, exchanger and datastore addresses of Xi need not
necessarily to be exchanged. A secure exchange of this
information is out of scope of this paper. An example for the
application of an email-based OOB channel for this purpose
can be found in [3]. Considering our use case from section
III, the establishment of a friendship with C corresponds to
the subscription process with L.
A LB-SNS provider determines a certain point in time
at which C initiates its service provision for currently reg-
istered users (2). Assuming n users X1, . . . , Xn registered
Secure Channel based on KXiXj
1
2
Xi
key_ex(K+
Xi
C,DSXi,ExXi)
3
bc(T(C|Xi))
bc(T(C|Xj))
C
T(C) = gen_tickets()
put_tickets(TC,LTc(C), DSC)
(T(C|Xj), LTc(C)) =
get_tickets(Xj, DSC)
(T(C|Xj), LTc(C)) =
get_tickets(Xj, DSC)
s(XjXi) = decode(K-
Xi
C,T(C|Xi))
KXiXj = gen_key(s(XjXi),CIt)
s(XiXj) = decode(K-
Xj
C,T(C|Xi))
KXiXj = gen_key(s(XjXi),CIt)
{X1,...,Xn}\{Xi}
key_ex(K+
Xj
C,DSXj,ExXj)
key_ex(K+
C
Xj,DSC,ExC)
key_ex(K+
C
Xi,DSC,ExC)
Figure 2. Message exchange between a directory buddy and its subscribers.
After users have registered (1) the directory buddy generates all necessary
tickets and places them for pickup at his datastore (2). As a users location
task activates the LB-SNS, he broadcasts his tickets (3). Each user can
decrypt tickets encrypted with his public key and create a secure channel.
for L, C calls the gen tickets() function to generate a set
of tickets T(C) = {t(XiXj)|1 ≤ i, j ≤ n ∧ i ̸= j} for each
ordered combination of users Xi and Xj. A ticket t(XiXj) =
K+
Xj→C(s(XiXj)||cs(s(XiXj))) includes some unique piece
of information s(XiXj) (where s(XiXj) = s(XjXi)) which is
generated by C to provide two registered users Xi and Xj
with a common secret. cs(s(XiXj)) represents the checksum
of s(XiXj). C generates a location task LTc(C) for each
user Xi. A location task corresponds to the description
of some context c a user Xi has to observe before Xi
initiates his active participation in the corresponding LB-
SNS. Referring to our use case, LTc(C) could be deﬁned as
the geographic dimensions of the conference building. In this
example each participant would receive the same location
task. Now C calls the put tickets() function to place disjoint
subsets T(C|Xi) = {t(XiXj)|1 ≤ j ≤ n ∧ i ̸= j} ⊂ T(C) and
the location task LTc(C) individually encrypted based on
K+
Xi→C for each user Xi at datastore DSC. Dependent of a
preconﬁgured interval, Xi calls the get tickets() function to
receive his private subset of tickets T(C|Xi) and the location
task LTc(C) from DSC.
When Xi observes the occurrence of LTc(C), Xi starts
to broadcast T(C|Xi) (3). For instance, in case of our usage
scenario from section III, the context c corresponds to the
arrival at the conference building. Any other registered user
Xj (i ̸= j) who already observed the occurrence of LTc(C)
also broadcasts his ticket subset T(C|Xj). When Xi receives
a broadcast from Xj, Xi calls the decode() function to
decode the secret s(XiXj) shared between Xi and Xj. In
case there exists a ticket t(XiXj) ∈ T(C|Xj), Xi can extract
the secret s(XiXj) by applying his private key K−
Xi→C to
t(XiXj). As Xi has no previous knowledge about the public
key that was used to encrypt a certain ticket, Xi has to
246
ICWMC 2011 : The Seventh International Conference on Wireless and Mobile Communications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-140-3

calculate the checksum of an encrypted secret in order to
determine that this secret corresponds to s(XiXj). Section V
discusses this process in detail. It should be stressed that,
although Xi and Xj now share a common secret, C is
always able to decrypt information which was previously
encrypted based on s(XiXj).
Although Xi and Xj cannot trigger their participation in a
LB-SNS before they were able to exchange their tickets, i.e.,
before they are located within the same broadcast domain,
the shared secret s(XiXj) does not sufﬁce to give evidence
for the occurrence of LTc(C). For instance, a fraudulent user
M could pretend to be located within the broadcast domain
physically restricted by LTc(C). M could connect to the
corresponding subnetwork by establishing a VPN tunnel link
or driving a wormhole attack. To generate a secret key from
s(XiXj) that cannot be determined before Xi and Xj share
the same broadcast domain and are physically located at an
area described by LTc(C), we require an additional context
information CIt which cannot be determined except at the
location described by LTc(C). Referring to our use case,
such additional context information could be an identiﬁable
but randomly chosen and frequently alternating essid of the
wireless conference network. A shared secret key K(XiXj)
could then be generated by the gen key() function based on
the shared secret s(XiXj) and a context information CIt. As
decryption could fail due to the application of an outdated
CIt for the generation of K(XiXj), Xi and Xj temporarily
store recently expired keys. This facilitates the decryption of
messages that were encrypted with a predecessor of K(XiXj)
although K(XiXj) represents the present key.
It is worth mentioning that the generation and distribution
of tickets in step (2) of Figure 2 is not necessarily bound to a
ﬁxed point in time. This process can be executed incremen-
tally. In case a new participant subscribes with the LB-SNS,
C updates all ticket subsets T(C|Xi) for each participant
Xi on demand and places them at DSC. Eventually, Xi
receives this update in dependence of his pre-conﬁgured
update interval.
V. DISCUSSION
Our concept of directory buddies provides the foundation
for secure, privacy-preserving, and context-restricted LB-
SNSs. In this section we discuss compliance with our
requirements from section II. Furthermore we give some
notes on performance and security.
A. Compliance with Our Requirements
In this work we extended the existing OSN architecture
Vegas which already meets the requirements to provide for
a secure and privacy-preserving OSN [3]. In the following,
we only discuss requirements II-A, II-B, and II-C.
As the provision of a LB-SNS is based on a location task
LT(C), no information is shared before a user observes the
occurrence of LT(C). Furthermore, LB-SNS provision is re-
strict to participants that have knowledge of some predeﬁned
additional context information. To share information, two
users have to provide each other with an evidence that they
fulﬁll LT(C), i.e., they are located within physical proximity.
Hence, our approach meets the requirement for Context-
Dependent LB-SNS Provision. It should be mentioned, that
our requirement for Context-Dependent LB-SNS Provision
impedes security attacks as an adversary has to be physically
present or at least needs an in situ accomplice.
Each user that wants to participate in a LB-SNS has to
subscribe with a directory buddy in advance. This compo-
nent only serves for the establishment of anonymous links
between users which they can use to provide each other
with encrypted information, i.e., no identities are revealed.
As each link is secured with a separate secret, a user can
provide another user with additional information only shared
between both of them. Therefore, we achieve User-Selective
LB-SNS Provision.
As each subscriber has control over the point in time
when to trigger his LB-SNS participation, he has also full
control over the provision of shared information. As all
information is broadcasted by each user himself, we achieve
a completely decentralized, fully meshed communication
scheme. Therefore, our solution adheres to the requirement
for Decentralized LB-SNS Provision.
B. Comments on Performance
As mentioned before, our design applies one ticket per
anonymous link. In case a user Xi receives a ticket broadcast
T(C|Xj) from Xj, Xi has to apply his private key K−
Xi→C
to each included ticket in order to determine the shared
secret s(XiXj). Hence, the process to decrypt each ticket
s(XiXj) for all subscribers Xj ∈ {X1, . . . , Xn} \ {Xi}
has a complexity of O(n2). However, we can decrease the
complexity to O(n) if we add an identiﬁer to each ticket.
For instance C could determine a set of unique identiﬁers
for each ticket t(XiXj), add one identiﬁer to each ticket, and
announce relevant identiﬁers within each subscriber’s proﬁle
information at DSC.
Except the necessity of a single broadcast domain, LB-
SNSs are completely independent of the underlying network.
Nevertheless it should be mentioned that, in case of an ad
hoc network, a LB-SNS could suffer from packet loss due
to frequent ticket broadcasts. Dependent of the MAC layer,
subscribers should carefully choose a suitable broadcast
interval.
C. Comments on Security
Since tickets are distributed via broadcast, it takes an
adversary no effort to replay once received ticket broadcasts.
However, this does not represent a security problem as a
ticket t(XiXj) cannot be replayed before Xj sent the ticket
for the ﬁrst time. Since Xi maintains a list of all decrypted
247
ICWMC 2011 : The Seventh International Conference on Wireless and Mobile Communications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-140-3

tickets, replayed tickets are simply ignored as soon as Xi
received t(XiXj) for the ﬁrst time. As long as a directory
buddy can be trusted, our solution facilitates secure, privacy-
preserving, and location-restricted LB-SNSs.
VI. RELATED WORK
A plethora of research has been conducted in the ﬁeld of
secure and privacy-aware LBS. In the following, we review
related work from the area of privacy-aware proximity
detection and location-based access control as we consider
it the most relevant ﬁelds in our context.
Many proposals have been published for privacy-aware
proximity detection for LBS. (e.g., [5]–[7]). However, it has
been shown [8] that enabling privacy-awareness for LBSs is
a challenging task. Recently, ˇSikˇsnys et al. presented their
vicinitylocator [9], a proposal for private and ﬂexible prox-
imity detection in mobile social networks. Their architecture
supports proximity detection by checking for inclusion of
one user’s location inside another user’s vicinity. A server
instance attempts to map encrypted proximity regions (gran-
ules) presented by one user with the granules presented
by another one. Although this scheme facilitates a better
degree of privacy, proximity detection is still performed
server-sided, i.e. a user cannot validate location integrity
due to the lack of a common context. Zhong et al. devel-
oped different protocols [10] to support privacy-preserving
proximity-detection of nearby friends. However, even in case
they apply a trusted third-party to avoid situations where
friends learn locations of users that must no longer be
considered nearby, their approach cannot guarantee location
integrity. A paper recently published by Puttaswamy et al.
[11] probably shares most similarities with our approach.
It describes a decentralized approach to enable privacy-
preserving location-based mobile social applications. Mobile
devices place their encrypted location data at third-party
servers. Participants of the social network may download
and decrypt that information in case they share a secret key
with the data originator. Although their approach facilitates
decentralized proximity detection it does not adhere to our
requirement for location integrity. Users can preserve privacy
but they cannot prove location integrity.
Some work published by Sastry et al. [12] focuses on
the secure in-region veriﬁcation problem. Their approach is
related to our location integrity problem, as a prover has
to prove its claimed location to a veriﬁer. To address this
problem the authors measure emitted ultrasound signals to
verify a location. As recent mobile devices are not equipped
with ultrasound measurement facilities, their approach will
not be applicable in the near future.
VII. CONCLUSION
We presented our approach for secure, privacy-preserving,
and location-restricted location-based services for social
networks (LB-SNS) that focus on information sharing with
nearby persons. We ﬁrst elaborated a set of requirements we
deem indispensable to provide for the provision of LB-SNSs.
We presented the concept of directory buddies, an extension
to our decentralized, secure, and privacy-preserving OSN
architecture Vegas and illustrated its application in context
of LB-SNSs by exemplifying a location-based business card
browser. We showed that this design fully complies with our
requirements.
Our future work will focus on the evaluation of our
design in a realistic setup. Furthermore, we will investigate
novel possibilities to infer context information to provide for
location integrity from environmental impacts.
REFERENCES
[1] J. Tsai, P. Kelley, L. Cranor, and N. Sadeh, “Location-sharing
technologies: Privacy risks and controls,” ISJLP, vol. 6, pp.
119–317, 2010.
[2] K. Tang, J. Lin, J. Hong, D. Siewiorek, and N. Sadeh, “Re-
thinking location sharing: exploring the implications of social-
driven vs. purpose-driven location sharing,” in Proceedings of
UbiComp’10.
ACM, 2010, pp. 85–94.
[3] M. D¨urr, M. Werner, and M. Maier, “Re-Socializing Online
Social Networks,” in Proc. of CPSCom’10. IEEE, Dec 2010.
[4] M. Werner, “A Privacy-Enabled Architecture for Location-
Based Services,” in Proc. of MobiSec ’10, 2010.
[5] P. Ruppel, G. Treu, A. K¨upper, and C. Linnhoff-Popien,
“Anonymous User Tracking for Location-Based Community
Services,” in Location- and Context-Awareness, ser. LNCS.
Springer Berlin/Heidelberg, 2006, vol. 3987, pp. 116–133.
[6] A. K¨upper and G. Treu, “Efﬁcient proximity and separation
detection among mobile targets for supporting location-based
community services,” SIGMOBILE Mob. Comput. Commun.
Rev., vol. 10, pp. 1–12, July 2006.
[7] S. Mascetti, C. Bettini, and D. Freni, “Longitude: Central-
ized Privacy-Preserving Computation of Users Proximity,” in
Secure Data Management, ser. LNCS.
Springer Berlin/Hei-
delberg, 2009, vol. 5776, pp. 142–157.
[8] A. Khoshgozaran and C. Shahabi, “Blind evaluation of near-
est neighbor queries using space transformation to preserve
location privacy,” in Proc. of SSTD ’07. Springer Berlin/Hei-
delberg, 2007, pp. 239–257.
[9] L. ˇSikˇsnys, J. Thomsen, S. ˇSaltenis, and M. Yiu, “Private and
Flexible Proximity Detection in Mobile Social Networks,” in
Proc. of MDM 2010.
IEEE, 2010, pp. 75–84.
[10] G. Zhong, I. Goldberg, and U. Hengartner, “Louis, Lester and
Pierre: three protocols for location privacy,” in Proc. of PET
’07.
Springer Berlin/Heidelberg, 2007, pp. 62–76.
[11] K. P. N. Puttaswamy and B. Y. Zhao, “Preserving privacy in
location-based mobile social applications,” in Proc. Hotmo-
bile ’10.
New York, NY, USA: ACM, 2010, pp. 1–6.
[12] N. Sastry, U. Shankar, and D. Wagner, “Secure veriﬁcation
of location claims,” in Proc. of WiSe ’03.
New York, NY,
USA: ACM, 2003, pp. 1–10.
248
ICWMC 2011 : The Seventh International Conference on Wireless and Mobile Communications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-140-3

