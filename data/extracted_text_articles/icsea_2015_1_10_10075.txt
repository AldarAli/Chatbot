Patterns for Specifying Bidirectional Transformations in UML-RSDS
K. Lano,
S. Yassipour-Tehrani
Dept. of Informatics
King’s College London
London, UK
Email: kevin.lano@kcl.ac.uk,
s.yassipour-tehrani@kcl.ac.uk
S. Kolahdouz-Rahimi
Dept of Software Engineering
University of Isfahan
Isfahan, Iran
Email: sh.rahimi@eng.ui.ac.ir
Abstract—In this paper, we identify model transformation spec-
iﬁcation and design patterns, which support the property of
transformation bidirectionality: the ability of a single speciﬁcation
to be applied either as a source-to-target transformation or as
a target-to-source transformation. In contrast to previous work
on bidirectional transformations (bx), we identify the important
role of transformation invariants in the derivation of reverse
transformations, and show how patterns and invariants can be
used to give a practical means of deﬁning bx in the UML-RSDS
transformation language.
Keywords — Bidirectional transformations; transformation
design patterns; UML-RSDS
I.
INTRODUCTION
Bidirectional transformations (bx) are considered important
in a number of transformation scenarios:
•
Maintaining consistency between two models which
may both change, for example, if a UML class dia-
gram and corresponding synthesised Java code both
need to be maintained consistently with each other, in
order to implement round-trip engineering for model-
driven development.
•
Where a mapping between two languages may need to
be operated in either direction for different purposes,
for example, to represent behavioural models as either
Petri Nets or as state machines [12].
•
Where inter-conversion between two different repre-
sentations is needed, such as two alternative formats
of electronic health record [3].
Design patterns have become an important tool in software
engineering, providing a catalogue of ‘best practice’ solutions
to design problems in software [7]. Patterns for model transfor-
mations have also been identiﬁed [14], but patterns speciﬁcally
for bx have not been deﬁned.
In this paper, we show how bx patterns can be used to
obtain a practical approach for bx using the UML-RSDS
language [11].
Section II deﬁnes the concept of a bx. Section V de-
scribes related work. Section III describes UML-RSDS and
transformation speciﬁcation in UML-RSDS. Section IV gives
a catalogue of bx patterns for UML-RSDS, with examples.
Section VI gives a conclusion.
II.
CRITERIA FOR BIDIRECTIONALITY
Bidirectional transformations are characterised by a binary
relation R : SL ↔ TL between a source language (metamodel)
SL and a target language TL. R(m, n) holds for a pair of
models m of SL and n of TL when the models consist of
data which corresponds under R. It should be possible to
automatically derive from the deﬁnition of R both forward and
reverse transformations
R→ : SL × TL → TL
R← : SL × TL → SL
which aim to establish R between their ﬁrst (respectively
second) and their result target (respectively source) models,
given both existing source and target models.
Stevens [16] has identiﬁed two key conditions which bidi-
rectional model transformations should satisfy:
1)
Correctness: the forward and reverse transforma-
tions derived from a relation R do establish R:
R(m, R→(m, n))
and
R(R←(m, n), n)
for each
m : SL, n : TL.
2)
Hippocraticness: if source and target models already
satisfy R then the forward and reverse transformations
do not modify the models:
R(m, n) ⇒ R→(m, n) = n
R(m, n) ⇒ R←(m, n) = m
for each m : SL, n : TL.
The concept of a lens is a special case of a bx satisfying these
properties [16].
III.
BX SPECIFICATION IN UML-RSDS
UML-RSDS is a hybrid model transformation language,
with a formal semantics [10] and an established toolset [11].
Model transformations are speciﬁed in UML-RSDS as UML
use cases, deﬁned declaratively by three main predicates,
expressed in a subset of OCL:
1)
Assumptions Asm, which deﬁne when the transfor-
mation is applicable.
2)
Postconditions Post, which deﬁne the intended effect
of the transformation at its termination. These are an
ordered conjunction of OCL constraints (also termed
rules in the following) and also serve to deﬁne a
procedural implementation of the transformation.
3)
Invariants Inv, which deﬁne expected invariant prop-
erties which should hold during the transformation
execution. These may be derived from Post, or spec-
iﬁed explicitly by the developer.
From a declarative viewpoint, Post deﬁnes the conditions
which should be established by a transformation. From an
1
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

implementation perspective, the constraints of Post also deﬁne
intended computation steps of the transformation: each com-
putation step is an application of a postcondition constraint to
a speciﬁc source model element or to a tuple of elements.
For example, an elementary transformation speciﬁcation
τa2b on the languages S consisting of entity type A and T
consisting of entity type B (Figure 1) could be:
(Asm) :
B→forAll(b | b.y ≥ 0)
(Post) :
A→forAll(a | B→exists(b | b.y = a.x→sqr()))
(Inv) :
B→forAll(b | A→exists(a | a.x = b.y→sqrt()))
The computation steps α of τa2b are applications of
B→exists(b | b.y = a.x→sqr()) to individual a : A. These
consist of creation of a new b : B instance and setting its y
value to a.x ∗ a.x. These steps preserve Inv: Inv ⇒ [α]Inv.
Figure 1. A to B Transformation τa2b
This example shows a typical situation, where the invariant
is a dual to the postcondition, and expresses a form of min-
imality condition on the target model: that the only elements
of this model should be those derived from source elements
by the transformation. In terms of the framework of [16],
the source-target relation Rτ associated with a UML-RSDS
transformation τ is Post and Inv. As in the above example,
Rτ is not necessarily bijective. The forward direction of τ is
normally computed as stat(Post): the UML activity derived
from Post when interpreted procedurally [10]. However, in
order to achieve the correctness and hippocraticness properties,
Inv must also be considered: before stat(Post) is applied to the
source model m, the target model n must be cleared of elements
which fail to satisfy Inv.
In the a2b example, the transformation τ ×
a2b with postcon-
dition constraints:
(CleanTarget1) :
B→forAll(b | not(b.y ≥ 0) implies
b→isDeleted())
(CleanTarget2) :
B→forAll(b | not(A→exists(a | a.x = b.y→sqrt()))
implies b→isDeleted())
is applied before τa2b, to remove all B elements which fail to
be in Ra2b with some a : A, or which fail to satisfy Asm.
This is an example of the Cleanup before Construct pattern
(Section IV). Additionally, the E→exists(e | P) quantiﬁer in
rule succedents should be procedurally interpreted as “create a
new e : E and establish P for e, unless there already exists an
e : E satisfying P”. That is, the Unique Instantiation pattern
[14] should be used to implement ‘check before enforce’ se-
mantics. The forward transformation τ → is then the sequential
composition τ ×; τ of the cleanup transformation and the
standard transformation (enhanced by Unique Instantiation).
In the reverse direction, the roles of Post and Inv are
interchanged: elements of the source model which fail to
satisfy Asm, or to satisfy Post with respect to some element
of the target model should be deleted:
(CleanSource2) :
A→forAll(a | not(B→exists(b | b.y = a.x→sqr()))
implies a→isDeleted())
This cleanup transformation is denoted τ ∼×
a2b . It is followed by
an application of the normal inverse transformation τ ∼
a2b which
has postcondition constraints Inv ordered in the corresponding
order to Post. Again, Unique Instantiation is used for source
model element creation. The overall reverse transformation is
denoted by τ ← and is deﬁned as τ ∼×; τ ∼.
In the case of separate-models transformations with type 1
postconditions (Constraints whose write frame is disjoint from
their read frame), Inv can be derived automatically from Post
by syntactic transformation, the CleanTarget and CleanSource
constraints can also be derived from Post, and from Asm. This
is an example of a higher-order transformation (HOT) and is
implemented in the UML-RSDS tools.
In general, in the following UML-RSDS examples, τ
is a separate-models transformation with source language S
and target language T, and postcondition Post as an ordered
conjunction of constraints of the form:
(Cn) :
Si→forAll(s | SCond(s) implies
Tj→exists(t | TCond(t) and Pi,j(s, t)))
and Inv is a conjunction of dual constraints of the form
(Cn∼) :
Tj→forAll(t | TCond(t) implies
Si→exists(s | SCond(s) and P∼
i,j(s, t)))
where the predicates Pi,j(s, t) deﬁne the features of t from those
of s, and are invertible: an equivalent form P∼
i,j(s, t) should
exist, which expresses the features of s in terms of those of t,
and such that
Si→forAll(s | Ti→forAll(t | Pi,j(s, t) = P∼
i,j(s, t)))
under the assumptions Asm. Table I shows some examples
of inverses P∼ of predicates P. The computation of these
inverses are all implemented in the UML-RSDS tools (the
reverse option for use cases). More cases are given in [11].
The transformation developer can also specify inverses for
particular Cn by deﬁning a suitable Cn∼ constraint in Inv,
for example, to express that a predicate t.z = s.x + s.y should
be inverted as s.x = t.z − s.y.
Each CleanTarget constraint based on Post then has the
form:
(Cn×) :
Tj→forAll(t | TCond(t) and
not(Si→exists(s | SCond(s) and Pi,j(s, t))) implies
t→isDeleted())
Similarly for CleanSource.
2
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

TABLE I. EXAMPLES OF PREDICATE INVERSES
P(s,t)
P∼(s, t)
Condition
t.g = s.f
s.f = t.g
Assignable features f, g
t.g = s.f→sqrt()
s.f = t.g→sqr()
f, g non-negative attributes
t.g = K ∗ s.f + L
s.f = (t.g − L)/K
f, g numeric attributes
Numeric constants K, L, K ̸= 0
t.rr = s.r→including(s.p)
s.r = t.rr→front() and
rr, r ordered association ends
t.rr = s.r→append(s.p)
s.p = t.rr→last()
p 1-multiplicity end
t.rr = s.r→sort()
s.r = t.rr→asSet()
r set-valued, rr ordered
t.rr = s.r→asSequence()
R(s, t) and Q(s, t)
R∼(s, t) and Q∼(s, t)
t.rr = TRef[s.r.idS]
s.r = SRef[t.rr.idT]
rr association end with
idS primary key of SRef,
element type TRef,
idT primary key of TRef
r association end with
element type SRef
t.g = s.r.idS
s.r = SRef[t.g]
idS primary key of SRef,
Attribute g
r association end with
element type SRef
Tj[s.idS].rr = TRef[s.r.idSRef]
Si[t.idT].r = SRef[t.rr.idTRef]
idS, idSRef primary
r has element type SRef,
keys of Si, SRef
rr has element type TRef
idT, idTRef primary
keys of Tj, TRef
IV.
PATTERNS FOR BX
In this section, we give a patterns catalogue for bx, and
give pattern examples in UML-RSDS.
A. Auxiliary Correspondence Model
This pattern deﬁnes auxiliary entity types and associations
which link corresponding source and target elements. These
are used to record the mappings performed by a bx, and to
propagate modiﬁcations from source to related target elements
or vice-versa, when one model changes.
Figure 2 shows a typical schematic structure of the pattern.
Figure 2. Auxiliary Correspondence Model pattern
Beneﬁts:
The pattern is a signiﬁcant aid in change-
propagation between models, and helps to ensure the correct-
ness of a bx. Feature value changes to a source element s can
be propagated to changes to its corresponding target element,
and vice-versa, via the links. Deletion of an element may imply
deletion of its corresponding element.
Disadvantages:
The correspondence metamodel must be
maintained (by the transformation engineer) together with the
source and target languages, and the necessary actions in creat-
ing and accessing correspondence elements adds complexity to
the transformation and adds to its execution time and memory
requirements.
Related Patterns:
This pattern is a specialisation of the
Auxiliary Metamodel pattern of [14].
Examples:
This mechanism is a key facility of Triple
Graph Grammars (TGG) [1][2], and correspondence traces are
maintained explicitly or implicitly by other MT languages such
as QVT-R [15].
In UML-RSDS, the pattern is applied by introducing aux-
iliary attributes into source and target language entity types.
These attributes are primary key/identity attributes for the
entity types, and are used to record source-target element corre-
spondences. Target element t : Tj is considered to correspond
to source element(s) s1 : S1, ..., sn : Sn if they all have the
same primary key values: t.idTj = s1.idS1, etc. The identity
attributes are String-valued in this paper. The correspondence
between a source entity Si and a target entity Tj induced by
equality of identity attribute values deﬁnes a language mapping
or interpretation χ of Si by Tj in the sense of [13]:
Si 7−→ Tj
with Si→collect(idSi) = Tj→collect(idTj).
The existence of identity attributes facilitates element
lookup by using the Object Indexing pattern [14], which
deﬁnes maps from String to each entity type, permitting
elements to be retrieved by the value of their identity attribute:
Tj[v] denotes the Tj instance t with t.idTj = v if v is a
single String value, or the collection of Tj instances t with
v→includes(t.idTj) if v is a collection. The last three cases in
Table I show inverse predicates derived using this approach to
correspondence models. Note that Tj[x.idTj] = x for x : Tj.
The pattern can be used to deﬁne source-target propaga-
tion and incremental application of a transformation τ. For
3
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

postconditions Cn of the form
Si→forAll(s | SCond(s) implies
Tj→exists(t | TCond(t) and Pi,j(s, t)))
derived constraints Cn∆ can be deﬁned for the incremental
application of Cn to model increments (ﬁnite collections of
creations, deletions and modiﬁcations of model elements).
The incremental version τ ∆ of a transformation τ is deﬁned
to have postconditions formed from the constraints Cn∆ for
each postcondition Cn of τ, and ordered according to the
order of the Cn in the Post of τ. In a similar way, target-
source change propagation can be deﬁned. Change propagation
is implemented in UML-RSDS by the incremental mode of use
case execution.
B. Cleanup before Construct
This pattern deﬁnes a two-phase approach in both forward
and reverse transformations associated with a bx with relation
R: the forward transformation R→ ﬁrst removes all elements
from the target model n which fail to satisfy R for any element
of the source m, and then constructs elements of n to satisfy
R with respect to m. The reverse transformation R← operates
on m in the same manner.
Beneﬁts:
The pattern is an effective way to ensure the
correctness of separate-models bx.
Disadvantages:
There may be efﬁciency problems because
for each target model element, a search through the source
model for possibly corresponding source element may be
needed. Elements may be deleted in the Cleanup phase only
to be reconstructed in the Construct phase. Auxiliary Corre-
spondence Model may be an alternative strategy to avoid this
problem, by enforcing that feature values should change in
response to a feature value change in a corresponding element,
rather than deletion of elements.
Related Patterns:
This pattern is a variant of the Construc-
tion and Cleanup pattern of [14].
Examples:
An example is the Composers bx [4]. Im-
plicit deletion in QVT operates in a similar manner to this
pattern, but can only modify models (domains) marked as
enforced [15]. In UML-RSDS, explicit cleanup rules Cn×
can be deduced from the construction rules Cn, for mapping
transformations, as described in Section III above. If identity
attributes are used to deﬁne the source-target correspondence,
then Cn× can be simpliﬁed to:
Tj→forAll(t | TCond(t) and
Si→collect(sId)→excludes(t.tId) implies
t→isDeleted())
and
Tj→forAll(t | TCond(t) and
Si→collect(sId)→includes(t.tId) and s = Si[t.tId]
and not(SCond(s)) implies t→isDeleted())
In the case that TCond(t) and SCond(s) hold for corresponding
s, t, but Pi,j(s, t) does not hold, t should not be deleted, but
Pi,j(s, t) should be established by updating t:
Si→forAll(s | Tj→collect(tId)→includes(s.sId) and
t = Tj[sId] and SCond(s) and
TCond(t) implies Pi,j(s, t))
For a transformation τ, the cleanup transformation τ × has the
above Cn× constraints as its postconditions, in the same order
as the Cn occur in the Post of τ. Note that τ → is τ ×; τ, and
τ ∆ is τ ×; τ incrementally applied.
C. Unique Instantiation
This pattern avoids the creation of unnecessary elements
of models and helps to resolve possible choices in reverse
mappings. It uses various techniques such as traces and unique
keys to identify when elements should be modiﬁed and reused
instead of being created. In particular, unique keys can be used
to simplify checking for existing elements.
Beneﬁts:
The pattern helps to ensure the Hippocraticness
property of a bx by avoiding changes to a target model if it is
already in the transformation relation with the source model.
It implements the principle of ‘least change’ [17].
Disadvantages:
The need to test for existence of elements
adds to the execution cost. This can be ameliorated by the use
of the Object Indexing pattern [14] to provide fast lookup of
elements by their primary key value.
Examples:
The key attributes and check-before-enforce
semantics of QVT-R follow this pattern, whereby new elements
of source or target models are not created if there are already
elements, which satisfy the speciﬁed relations of the transfor-
mation [16]. The E→exists1(e | P) quantiﬁer in UML-RSDS is
used in a similar way. It is procedurally interpreted as “create
a new e : E and establish P for e, unless there already exists
an e : E satisfying P” [11]. For bx, the quantiﬁer exists should
also be treated in this way. If a transformation uses identity
attributes (to implement Auxiliary Correspondence Model), the
quantiﬁer E→exists(e | e.eId = v and P) can be interpreted as:
“if E[v] exists, apply stat(P) to this element, otherwise create
a new E instance with eId = v and apply stat(P) to it”. This
ensures Hippocraticness.
D. Phased Construction for bx
This pattern deﬁnes a bx τ by organising Rτ as a union of
relations RSi,Tj which relate elements of entities Si and Tj which
are in corresponding levels of the composition hierarchies of
the source and target languages. Figure 3 shows the typical
schematic structure of the pattern. At each composition level
there is a 0..1 to 0..1 relation (or more specialised relation)
between the corresponding source and target entity types.
Figure 3. Phased Construction pattern
4
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

Beneﬁts:
The pattern provides a modular and extensible
means to structure a bx.
Examples:
The UML to relational database example of [15]
is a typical case, where Package and Schema correspond at
the top of the source/target language hierarchies, as do Class
and Table (in the absence of inheritance), and Column and
Attribute at the lowest level.
In UML-RSDS a transformation deﬁned according to this
pattern has its Post consisting of constraints Cn of the form
Si→forAll(s | SCond(s) implies
Tj→exists(t | TCond(t) and Pi,j(s, t)))
where Si and Tj are at corresponding hierarchy levels, and Inv
consists of constraints Cn∼ of the form
Tj→forAll(t | TCond(t) implies
Si→exists(s | SCond(s) and P∼
i,j(s, t)))
No nested quantiﬁers or deletion expressions x→isDeleted()
are permitted in SCond, TCond or Pi,j, and Pi,j is restricted to
be formed of invertible expressions.
Each rule creates elements t of some target entity type
Tj, and may lookup target elements produced by preceding
rules to deﬁne the values of association end features of
t: t.tr = TSub[s.sr.idSSub] for example, where TSub is lower
than Tj in the target language composition hierarchy (as in
Figure 3) and there are identity attributes in the entities to
implement a source-target correspondence at each level. Both
forward and reverse transformations will conform to the pattern
if one direction does. The assignment to t.tr has inverse:
s.sr = SSub[t.tr.idTSub].
Two UML-RSDS bx τ : S → T, σ : T → U using
this pattern can be sequentially composed to form another bx
between S and U: the language T becomes auxiliary in this
new transformation. The forward direction of the composed
transformation is τ →; σ→, the reverse direction is σ←; τ ←.
E. Entity Merging/Splitting for bx
In this variation of Phased Construction, data from multiple
source model elements may be combined into single target
model elements, or vice-versa, so that there is a many-one
relation from one model to the other. The pattern supports
the deﬁnition of such bx by including correspondence links
between the multiple elements in one model which are related
to one element in the other.
Beneﬁts:
The additional links enable the transformation to
be correctly reversed.
Disadvantages:
Additional auxiliary data needs to be added
to record the links. The validity of the links between elements
needs to be maintained. There may be potential conﬂict
between different rules which update the same element.
Related Patterns:
This uses a variant of Auxiliary Cor-
respondence Model, in which the correspondence is between
elements in one model, in addition to cross-model correspon-
dences. The attributes used to record intra-model correspon-
dences may not be primary keys.
Examples:
An example of Entity Merging is the Col-
lapse/Expand State Diagrams benchmark of [6]. The UML to
RDB transformation is also an example in the case that all
subclasses of a given root class are mapped to a single table
that represents this class. The Pivot/Unpivot transformation of
[3] is an example of Entity Splitting.
In the general case of merging/splitting, the inverse of Cn:
Si1→forAll(s1 | ...
Sin→forAll(sn | SCond(s1, ..., sn) implies
Tj1→exists(t1 | ...
Tjm→exists(tm | TCond(t1, ..., tm) and
P(s1, ..., sn, t1, ..., tm))...)) ...)
is Cn∼:
Tj1→forAll(t1 | ...
Tjm→forAll(tm | TCond(t1, ..., tm) implies
Si1→exists(s1 | ...
Sin→exists(sn | SCond(s1, ..., sn) and
P∼(s1, ..., sn, t1, ..., tm))...))...)
In UML-RSDS, correspondence links between elements in
the same model are maintained using additional attributes. All
elements corresponding to a single element will have the same
value for the auxiliary attribute (or a value derived by a 1-1
function from that value).
F. Map Objects Before Links for bx
If there are self-associations on source entity types, or other
circular dependency structures in the source model, then this
variation on Phased Construction for bx can be used. This
pattern separates the relation between elements in target and
source models from the relation between links in the models.
Beneﬁts:
The speciﬁcation is made more modular and
extensible. For example, if a new association is added to
one language, and a corresponding association to the other
language, then a new relation relating the values of these
features can be added to the transformation without affecting
the existing relations.
Disadvantages:
Some features of one entity type are treated
in separate relations.
Examples:
In UML-RSDS a ﬁrst phase of such a transfor-
mation relates source elements to target elements, then in a
second phase source links are related to corresponding target
links. The second phase typically has postcondition constraints
of the form Si→forAll(s | Tj[s.idS].rr = TRef[s.r.idSRef]) to
deﬁne target model association ends rr from source model
association ends r, looking-up target model elements Tj[s.idS]
and TRef[s.r.idSRef] which have already been created in
a ﬁrst phase. Such constraints can be inverted to deﬁne
source data from target data as: Tj→forAll(t | Si[t.idT].r =
SRef[t.rr.idTRef]). The reverse transformation also conforms
to the Map Objects Before Links pattern.
An example of this pattern is the tree to graph transforma-
tion [9], Figure 4.
A ﬁrst rule creates a node for each tree:
Tree→forAll(t | Node→exists(n | n.label = t.label))
A second rule then creates edges for each link between parent
and child trees:
Tree→forAll(t |
Tree→forAll(p | t.parent→includes(p) implies
Edge→exists(e | e.source = Node[t.label] and
e.target = Node[p.label])))
5
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

Figure 4. Tree to graph metamodels
The corresponding invariant predicates, deﬁning the reverse
transformation, are:
Node→forAll(n | Tree→exists(t | t.label = n.label))
and
Edge→forAll(e |
Tree→exists(t | Tree→exists(p |
t.parent→includes(p) and
t.label = e.source.label and
p.label = e.target.label)))
Inv is derived mechanically from Post using Table I, and pro-
vides an implementable reverse transformation, since stat(Inv)
is deﬁned.
V.
RELATED WORK
There are a wide range of approaches to bx [8]. Cur-
rently the most advanced approaches [2][5] use constraint-
based programming techniques to interpret relations P(s, t)
between source and target elements as speciﬁcations in both
forward and reverse directions. These techniques would be a
potentially useful extension to the syntactic inverses deﬁned in
Table I, however the efﬁciency of constraint programming will
generally be lower than the statically-computed inverses. The
approach also requires the use of additional operators extend-
ing standard OCL. Further techniques include the inversion of
recursively-deﬁned functions [18], which would also be useful
to incorporate into the UML-RSDS approach.
In [13] we identify the role of language interpretations
χ : S → T in specifying transformations. Interpretations are
closely related to transformation inversion: at the model level a
mapping Mod(χ) : Mod(T) → Mod(S) from the set of models
of T to those of S can be deﬁned based on χ: the interpretation
of an S language element E in Mod(χ)(n) for n : Mod(T) is
that of χ(E) in n. Syntactically, the inverse of a transformation
τ speciﬁed by a language morphism χ can be derived from χ:
the value of a feature f of source element s of source entity
E is set by s.f = t.χ(E :: f) in the case of an attribute, and
by s.r = SRef[t.χ(E :: r).idTRef] in the case of a role with
element type SRef.
Considerable research has been carried out on the theory
of bx. One principle which has been formulated for bx is the
principle of least change [17]. This means that a bx which
needs to modify one model in order to re-establish the bx
relation R with a changed other model, should make a minimal
possible such change to the model. In our approach, Post in
the forward direction, and Inv in the reverse direction, express
the necessary minimal conditions for the models to be related
by R. The synthesised implementation of these constraints as
executable code carries out the minimal changes necessary to
establish Post and Inv, and hence satisﬁes the principle of least
change.
VI.
CONCLUSION
We have deﬁned a declarative approach for bidirectional
transformations based on the derivation of forward and reverse
transformations from a speciﬁcation of dual postcondition
and invariant relations between source and target models.
The approach enables a wide range of bx to be deﬁned,
including cases of many-to-one and one-to-many relations
between models, in addition to bijections. We have described
transformation patterns which may be used to structure bx. The
derivation of reverse transformations has been implemented in
the UML-RSDS tools [11].
REFERENCES
[1]
A. Anjorin and A. Rensink, “SDF to Sense transformation”, TU
Darmstadt, Germany, 2014.
[2]
A. Anjorin, G. Varro, and A. Schurr, “Complex attribute manipulation
in TGGs with constraint-based programming techniques”, BX 2012,
Electronic Communications of the EASST vol. 49, 2012.
[3]
M. Beine, N. Hames, J. Weber, and A. Cleve, “Bidirectional transfor-
mations in database evolution: a case study ‘at scale’”, EDBT/ICDT
2014, CEUR-WS.org, 2014.
[4]
J. Cheney, J. McKinna, P. Stevens, and J. Gibbons, “Towards a reposi-
tory of bx examples”, EDBT/ICDT 2014, 2014, pp. 87–91.
[5]
A. Cicchetti, D. Di Ruscio, R. Eramo, and A. Pierantonio, “JTL: a
bidirectional and change propagating transformation language”, SLE
2010, LNCS vol. 6563, 2011, pp. 183–202.
[6]
K. Czarnecki, J. Nathan Foster, Z. Hu, R. Lammel, A. Schurr, and J.
Terwilliger, “Bidirectional transformations: a cross-discipline perspec-
tive”, GRACE workshop, ICMT, 2009.
[7]
E. Gamma, R. Helm, R. Johnson, and J. Vlissides, “Design Patterns:
Elements of Reusable Object-Oriented Software”, Addison-Wesley,
1994.
[8]
Z. Hu, A. Schurr, P. Stevens, and J. Terwilliger (eds.), “Report from
Dagstuhl Seminar 11031”, January 2011, www.dagstuhl.de/11031.
[9]
D. S. Kolovos, R. F. Paige, and F. Polack, “The Epsilon Transformation
Language”, ICMT, 2008, pp. 46–60.
[10]
K. Lano and S. Kolahdouz-Rahimi, “Constraint-based speciﬁcation of
model transformations”, Journal of Systems and Software, vol. 88, no.
2, February 2013, pp. 412–436.
[11]
K.
Lano,
The
UML-RSDS
Manual,
www.dcs.kcl.ac.uk/staff/kcl/uml2web/umlrsds.pdf, 2015.
[12]
K. Lano, S. Kolahdouz-Rahimi, and K. Maroukian, “Solving the Petri-
Nets to Statecharts Transformation Case with UML-RSDS”, TTC 2013,
EPTCS, 2013, pp. 101–105.
[13]
K. Lano and S. Kolahdouz-Rahimi, “Towards more abstract speciﬁca-
tion of model transformations”, ICTT 2014.
[14]
K. Lano and S. Kolahdouz-Rahimi, “Model-transformation Design
Patterns”, IEEE Transactions in Software Engineering, vol 40, 2014,
pp. 1224–1259.
[15]
OMG, MOF 2.0 Query/View/Transformation Speciﬁcation v1.1, 2011.
[16]
P. Stevens, “Bidirectional model transformations in QVT: semantic
issues and open questions”, SoSyM, vol. 9, no. 1, January 2010, pp.
7–20.
[17]
Theory of Least Change, groups.inf.ed.ac.uk/bx/, accessed 3.9.2015.
[18]
J. Voigtlander, Z. Hu, K. Matsuda, and M. Wang, “Combining syntactic
and semantic bidirectionalization”, ICFP ’10, ACM Press, 2010, pp.
181–192.
6
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

