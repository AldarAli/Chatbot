Multi-Relay Cooperative NB-LDPC Coding with
Non-Binary Repetition Codes
David Declercq
ETIS ENSEA/UCP/CNRS UMR 8051
95000 Cergy-Pontoise, France
email: declercq@ensea.fr
Valentin Savin
CEA-LETI, MINATEC
38054 Grenoble, France
email: valentin.savin@cea.fr
Stephan Pﬂetschinger
Centre Tecnolgic de Telecom. de Catalunya
7, Av. Carl Friedrich Gauss, 08860 Castelldefels, Spain
email: stephan.pﬂetschinger@cttc.es
Abstract—In this paper, we propose a system based on non-
binary Low-Density Parity-Check (LDPC) codes to communicate
efﬁciently over the multiple-relay fading channels, with a simple
joint decoding strategy at the receiver end. The particularity
of our approach is to rely on non-binary LDPC codes at the
source, coupled with multiplicative non-binary local codes at the
relays, such that the joint decoding complexity is not increased
compared to a system without relays, while preserving the coding
gain brought by the re-encoding of the sequence at the relays.
We show by simulations on simple conﬁgurations that this
cooperative scheme is superior to other techniques proposed in
the literature, and close to the Gaussian relay channel capacity,
even at moderate codeword lengths.
Index Terms—Non-binary LDPC; Coopertive coding; Relay
networks.
I. INTRODUCTION
In wireless communication systems, the spatial diversity
brought by the existence of relays, which can broadcast
modiﬁed re-encoded versions of the source streams, helps
to improve greatly the global information throughput and its
error rates. Those improvements are impacted by the use of
cooperative diversity [1], [2], which has been proposed in the
literature for wireless relay channels and their multi-terminal
extensions. A relay channel is a multi-terminal network con-
sisting of a source, a destination, and a collection of relays
which could be of different nature, as depicted on Figure 1
for the case of two relays. The communication system acts as
follows: the source broadcasts a message to both relays and
destination, while the relays forward the message or modiﬁed
versions of it to the destination. Subsequently, different authors
have proposed cooperation protocols for the relay channel,
which can be classiﬁed into three major categories, namely the
amplify-and-forward (AF) relays, the compress-and-forward
(CF) relays and ﬁnally the decode-and-forward (DF) relays [3].
In AF protocols, the relays simply amplify the received signals
and forward them to the destination, while in CF protocols
the received noisy signals at the relays are quantized and
forwarded. The DF protocol allows each relay to decode the
received signal, re-encode it, and forward it to the destination.
The forwarded message can either be identical to, or part of the
initial transmission (repetition coding), or it can be obtained
by using a dedicated coding scheme at the relays (cooperative
coding). In the repetition coding case the destination combines
received signals from both source and relays, which results
in an improved signal-to-noise ratio (SNR) on the received
transmission. In the cooperative coding case, the receiver at
the destination uses the global knowledge of the cooperative
coding (namely all code structures corresponding to the source
and the relays), to jointly decode the received signals from
both source and relays.
Fig. 1.
Example of wireless relay channel with two relays.
In the simple case of repetition coding, there is no extra cod-
ing gain brought by the relay transmissions since the protocol
does not change the Forward Error Correcting (FEC) code, and
impacts only on the SNR improvement. On the other hand the
receiver at the destination has the same low complexity as
if no relays where used. In the case of distribution coding
however, a proper design of the system aims at maximizing
the coding gain brought by the relays to get closer to the
relay channel capacity. This comes however at the cost of
an extra decoding complexity at the receiver end, while joint
decoding of the source and the relays are necessary to take
advantage of the cooperative coding. In this paper, we propose
a scheme which aims at having both advantages, namely an
extra coding gain at no extra decoding cost. Distributed coding
using parallel turbo-codes [4] or binary LDPC codes [5], [6],
[7], [8], [9], has already been proposed in the literature. The
existing approaches are either based on serial or parallel code
concatenation, such that the graph of the LDPC code broad-
casted from the source is a only subgraph of the destination
decoding graph, or based on punctured rate-compatible LDPC
codes. In a recent publication a cooperative LDPC code design
which uses a turbo-like decoder at the receiver to jointly
205
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

decode the different sub-graphs of the source and the relays is
proposed [10]. All these methods suffer from the large increase
of decoding complexity at the receiver and the fact that they
are not robust when the number of relays is larger than one, i.e.
the coding gain using several relays is less and less important
when the number of relays increases.
In this paper, we propose a new approach to the problem of
distributed coding for cooperation in the case of multiple re-
lays. The approach is based on non-binary LDPC (NB-LDPC)
codes and the recently introduced technique of multiplicative
non-binary coding [11], [12], which will be referred to as non-
binary repetition coding. In our setting, the source transmits a
codeword issued from a NB-LDPC code to the destination
and the relays. When the relays successfully decode the
received codeword, extra parity symbols are computed at the
relays through optimized non-binary repetition codes, and are
broadcasted to the destination. The receiver then collects the
original received codeword from the source and the non-binary
extra symbols from the relays and combines them before the
iterative decoding. The iterative decoding complexity is the
same in the presence or the absence of relays, while the
combining of the codeword and the additional non-binary
repetition symbols from the relays brings an effective coding
gain. The paper is organized as follows. In Section II, we
recall the basics about NB-LDPC codes and decoders and we
present the concept of non-binary repetition coding coupled
with NB-LDPC codes. In Section III, we describe our pro-
posed cooperative system and discuss its advantages. We also
propose in Section IV an optimization for the design of NB-
LDPC codes and non-binary repetition codes for maximizing
the coding gain, and ﬁnally, we present some simulation results
on simple relay channels in Section V.
II. NON-BINARY LDPC CODES AND DECODING
A. Non-Binary LDPC codes
A Low Density Parity Check (LDPC) code is deﬁned by
a very sparse random parity check matrix H, which consists
of N − K rows and N columns, where K is the information
block length and N is the codeword length; the code rate
is deﬁned by R ≤ K
N . LDPC codes are nowadays used and
proposed for a large number of communication and storage
applications and standards, as their performance under low
complexity iterative decoding approach the capacity for a large
variety of channels. Binary LDPC codes can be generalized
to non binary LDPC codes (NB-LDPC). The parity-check
equations are written using symbols in a Galois ﬁeld of order
q, denoted GF(q), where q = 2 is the particular binary
case. Throughout the paper, the Galois ﬁeld elements will
be denoted

0, α0, α1, . . . , α(q−2)	
, where α is a primitive
element of the Galois ﬁeld. The parity check matrix deﬁning
a NB-LDPC code has only a few nonzero coordinates hij
which belong to GF(q), and a single parity equation involving
dc codeword symbols follows:
dc
X
j=1
hi,j.cj = 0
(1)
where {hi,j} are the nonzero values of the i − th row of H,
and c = {c1, . . . , cN} is the notation used for the NB-LDPC
codeword.
NB-LDPC codes are usually preferred to their binary coun-
terparts when the blocklength is small to moderate [13], [14],
or when the order of the symbols sent through channel are not
binary [15], which is the case for high-order modulation (M-
QAM) or for Multiple-antennas channels [16]. As a matter
of fact, when the LDPC code is build in a ﬁeld with order
q equal or higher than the modulation order M, the non-
binary LDPC decoder is initialized with uncorrelated vector
messages, which helps the decoder to be closer to Maximum
Likelihood Decoding than in the binary case. Recently, another
advantage of NB-LDPC codes has been identiﬁed [17], [12].
The authors have shown in these papers that one can design
ﬂexible coding transmission in a very simple, though efﬁcient
way. The proposed approach is to concatenate non-binary
multiplicative codes to a mother NB-LDPC, which leads to
extra redundancy built from non-binary repetition symbols.
When the repetition coding is properly designed, it results
that the coding gain is greatly increased compared to binary
repetition coding, expecially when the ﬁeld order is sufﬁciently
large GF(q), with q ≥ 64. In this paper, we make use of the
concatenation of NB-LDPC codes and non-binary repetition
codes to design our distributed coding scheme, as presented
in Section III.
B. Brief presentation of NB-LDPC decoders
The performance improvement of NB-LDPC codes is
achieved at the expense of increased decoding complexity.
As in all practical coding schemes, an important feature is
the complexity/performance tradeoff, it is very important to
try to reduce the decoding complexity of NB-LDPC codes,
especially for high order ﬁelds GF(q) with q ≥ 64. The base
decoder of NB-LDPC codes is the Belief-Propagation (BP)
decoder over the Tanner graph representation of the code [18].
The Tanner graph of an NB-LDPC code is drawn on Figure 2.
The nonzero values of the parity-check matrix are put as labels
for the edges connected to the non-binary parity check nodes.
In this ﬁgure, we have represented all four parity-check nodes
with the same labels {h1, h2, h3, h4, h5}, and the information
symbols are represented in red (left side of the codeword)
while the redundancy symbols are drawn in blue (right side of
the codeword). The number of edges connected to the nodes
is constant throughout the Tanner graph, and furthermore the
number of edges for the symbol nodes is minimum, equal to
dv = 2. This Tanner graph corresponds to a regular and ultra-
sparse NB-LDPC code, with code rate R = 1 − dv
dc = 3
5.
The main difference with the binary BP decoder is that
for GF(q) LDPC codes, the messages from variable nodes
to check nodes and from check nodes to variable nodes are
deﬁned by q probability weights, or q − 1 log-density-ratios.
As a result, the complexity of NB-LDPC decoders scales as
O(q2) per check node [19], which prohibits the use of codes
build in high order ﬁelds.
206
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

Interleaver
Codeword Symbols
h
h
h
h
h
h
h
h
h
h
h
h
h4
h4
h4
h5
h5
h5
h5
h4
1
1
1
2
2
2
3
3
3
1
3
2
Fig. 2.
Tanner graph of an ultra-sparse NB-LDPC code, with (dv, dc) =
(2, 5) and R = 3/5.
Sub-optimum decoders based on generalization of the min-
sum decoder have been developed [19], [20], with the goal of
reducing the decoding complexity at the check-node side. In
particular, the EMS algorithm presented in [21] proposes the
best complexity/performance tradeoff found in the literature,
as the complexity scales as O(nm.q) with nm << q. We do
not present with more details the EMS non-binary decoder
in this paper and refer to the cited article for a complete
description and analysis. Only the computation of the Log-
Likelihood ratios (LLR) used for the initialization of the
decoder are presented in the next section.
C. Computation of the LLR vectors
For transmission over a general wireless channel, the code
symbols deﬁned in GF(q) have to be mapped to M−QAM
symbols, where M is a power of two, including M ∈ {2, 4}
for BPSK and QPSK. The information message u ∈ GF(q)K
is encoded into a codeword c ∈ GF(q)N, which is passed
to the modulator and then transmitted over a continuous-
valued fading channel. At the receiver, the soft demapper
computes log-likelihood values (LLR-values), which constitute
a sufﬁcient statistic of the received signal y and form the
initialization of the channel decoder.
To obtain a bijective mapping, we have to map m1 code
symbols to m2 QAM symbols such that qm1 = M m2. We
denote the QAM alphabet by χM, and the mapping function
by µ, i.e.
µ : GF(q)m1 → χm2
M
(2)
The code symbols b = (b1, b2, . . . , bm1) belong to the same
codeword c = (c1, c2, . . . , cN) and are mapped to a vector of
QAM symbols,
x = [x1, . . . , xm2] = µ(b) = [µ1(b), . . . , µm2(b)]
(3)
For binary codes (i.e. for q = 2), we always have m2 = 1,
while for codes in higher order Galois ﬁelds, for many mod-
ulations m1 = 1, which is quite beneﬁcial for the demapping,
as we will see below. The soft demapper computes the LLR-
vector Li = [Li,0, Li,1, . . . , Li,q−1]T, which corresponds to
the code symbol bi , and whose components are given by, for
i = 1, . . . , m1 and g ∈ GF(q)
Li,g ≜ ln P[bi = g|y]
P[bi = 0|y]
where we identify, with a slight abuse of notation, the elements
of GF(q) by their indices g = 0, 1, . . . , q − 1.
For a memoryless channel and assuming that all code
symbols are equiprobable, we obtain
Li,g = ln
P
b∈Bg
i
Qm2
j=1 p (yj|b)
P
b∈B0
i
Qm2
j=1 p (yj|b),
i = 1, . . . , m1
g = 0, . . . , q − 1
(4)
where Bg
i ≜ {b ∈ GF(q)m1 : bi = g} is the set of all code
symbol vectors whose i-th component is ﬁxed to g.
The mapping and in particular the demapping simpliﬁes
signiﬁcantly for m1 = 1, which means that exactly one code
symbol b ∈ GF(q) is mapped to a vector of QAM symbols.
In this case, we can drop the index i in (4), and since the sets
Bg
i reduce to one element, we can write
Lg = ln
Qm2
j=1 p (yj|b = g)
Qm2
j=1 p (yj|b = 0)
(5)
For a ﬂat fading channel given by yj = aj · xj + wj with
wj ∼ CN(0, N0), the conditional pdf is given by p(yj|b =
g) =
1
πN0 exp

− |yj−ajµj(g)|2
N0

. With this, and noting that a
BP decoder is typically insensitive to additive constants of the
LLR vectors, we can further simplify (5) to
Lg = − 1
N0
m2
X
j=1
|yj − ajµj(g)|2 + ℓ0
(6)
where ℓ0 is an arbitrary additive constant which does not
depend on g.
As we can see from the LLR computations, using NB-
LDPC codes with m1 = 1 results in a signiﬁcant complexity
reduction of the demodulator (without any approximation)
with respect to binary demappers, since no marginalization is
required. This is the case if the number of bits per code symbol
is a multiple of the number of bits per QAM symbol, i.e.
log2(q) = m2 ·log2(M). For instance, codes in GF(64) allow
a simple LLR computation for log2(M) ∈ {1, 2, 3, 6}, which
corresponds to BPSK, QPSK, 8-QAM and 64-QAM. Note that
more options are possible by mapping code symbols separately
to the I or Q component, i.e. by considering real-valued PAM
constellations. This does not incur any performance penalty,
but allows e.g. to easily combine 16-QAM with a GF(64)
code by mapping the 6 bits of one code symbol to three 4-
PAM symbols.
III. PROPOSED COOPERATIVE TRANSMISSION SCHEME
A. Channel Model and System Description
Throughout the paper, we will assume that the source
broadcasts a NB-LDPC codeword to the destination and a
given number Nr of relays. All wireless channels in the system
are either Rayleigh fading channels, or memoryless additive
white Gaussian noise (AWGN) channels, depending on the
type of relay (ﬁxed or mobile). For sake of simplicity in the
presentation, we restrict the model description to AWGN chan-
nels, but without loss of generality since the LLR computation
presented in the preceding section does not change for AWGN
or Rayleigh fading. The different channels will make use of
the following notations:
207
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

• The link between source and destination uses MSD−QAM
signalling with signal-to-noise ratio equals to γSD,
• The link between source and the i-th relay uses MSRi −
QAM constellations with signal-to-noise ratio equals to
γSRi,
• Finally, the link between the i-th relay and the destination
uses MRiD−QAM constellations with signal-to-noise ratio
γRiD.
Note that since relays and destination receive the same
modulated signals, we have by construction MSD − QAM =
MSRi − QAM, although the SNRs could be different.
Now, let us discuss the channel and transmission protocol
assumptions that we use in our work. First we assume that the
direct link between the source and the destination is weak and
that the relays links are stronger, both from source to relay
and from relay to destination, which is a usual assumption in
relay channels. It follows that γSRi ≥ γSD and γRiD ≥ γSD,
∀i. The improved SNRs of the relay channels implies that
either higher-order modulations would be used for the relay-
to-destination channel, or higher rate cooperative coding. The
optimization of the modulation order or of the cooperative
coding rates requires that channel fading estimation and a
link adaptation strategy is performed on the relay channel.
We leave this issue for future research, and in this paper, we
will assume ﬁxed values for the modulation orders and coding
rates, and measure the performance by the gap of error rates
to the capacity of the relay channel.
Now, we must make an assumption regarding the non-
propagation of errors through the relays. Since the relays are
decode-and-forward nodes in the network, we can reasonably
assume that the relay can detect if it decodes the received
codeword from the source or not. We will then assume that
when the relay fails to decode to a valid codeword, it does
not transmit any information to the destination, which prevents
unavoidable decoding failures at the destination.
Given this model and assumption, our proposed cooperative
coding scheme can be described as follows:
• The source encodes the packet of information bits, generat-
ing a NB-LDPC codeword c of the parity check matrix H,
with rate R. The source modulates c with the MSD−QAM
constellation and broadcasts the modulated symbols x to
both relays and destination.
• Each relay i decodes the received signal, correcting the
transmission errors on c. The relays then generate a new
sequence c(i) of non-binary symbols using the repetition
coding, as depicted on Figure 3 in the case of 2 relays.
Note that the size of the vectors c(i) are not necessarily the
same as the original codeword c, since the coding rates for
the links relay-destination are typically higher. The encoding
procedure and the optimization of the repetition codes are
presented in the next section. The vectors c(i) of non-binary
repetition symbols are then transmitted from the relays to
the destination using MRiD − QAM constellations.
• Thus, the destination receives noisy versions of x and
x(i) (from both the source and the relay), which can be
jointly decoded using the only the matrix H, and the LLR
computation presented in Section II-C.
NB−REPEAT
NB−REPEAT
DECODE
AND
MERGE
Fig. 3.
Cooperative coding scheme using non-binary repetition coding.
The proposed distributed scheme relies mainly on the way
the repetition symbols are generated and taken into account in
the joint decoding at the destination. We explain in details in
the next section why the non-binary repetition symbols bring
a signiﬁcant coding gain, at no extra encoding or decoding
cost.
B. Non-Binary Repetition coding and Joint Decoding
As mentioned in the previous section, we assume in this
paper that the parameters of the transmission system for each
link are ﬁxed, namely the constellation orders {MSD, MRiD}
and the coding rates {RSD, RRiD} are ﬁxed a priori. Now
let us present how the non-binary repetition symbols are
generated.
The i−th relay is supposed to receive and decode correctly
the broadcasted codeword c (otherwise, relay i does not
transmit anything). From the N symbols in c, the relay needs
to build Ni = N. RSD
RRiD
repetition symbols, which represents
the coded block that relay i has to send to the destination.
For example, if RSD = 1/2 and RRiD = 3/4, Ni = N.2
3
repetition symbols have to be encoded at relay i. The repetition
encoding is performed as follows for relay i:
• Select Ni non-binary symbols
n
ck(i)
l
o
l=1...Ni
inside the
codeword c, the Ni symbols could be chosen arbitrarily,
so either a random selection or a selection based on the
knowledge of the transmitted NB-LDPC code are possible,
• For each selected symbol ck(i)
l
∈ GF(q), generate a new
symbol c(i)
l
= h(i)
l .ck(i)
l , with h(i)
l
∈ GF(q) being the non-
zero ﬁeld value corresponding to the local repetition code.
The vector c(i) of size Ni is then sent from relay i to the
destination.
We can easily see that this repetition encoding procedure is
extremely simple, as it requires only Ni Galois ﬁeld operations
after a successful decoding at the relay. Note also that a sub-
case of the proposed scheme corresponds to the particular
choice of h(i)
l
= 1, ∀l, and which reduces to the usual decode-
and-forward strategy, where the same codeword is sent both
208
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

from the source and the relays. In our case, with a very limited
extra complexity, we allow the use of non-binary repetitions
with h(i)
l
̸= 1, which provides a non-negligible coding gain,
as explained in Section IV.
Now let us discuss how the collection of received symbols
are jointly treated at the destination. For some particular code
symbol c ∈ GF(q), we denote by x the QAM symbols build
from c transmitted by the source and by y(0) the corresponding
received value at the destination. We also denote by x(i)
the QAM symbols transmitted by the relays corresponding
to the same code symbol c, and y(i) the corresponding
channel outputs. Note that here we dropped the index of the
symbol in the codewords to simplify the notations, and we
just assume that the received values correspond indeed to
the same symbol c. So, the symbol c receives the channel
values
n
y(0), y(1)
l
, . . . , y(I)
l
o
, from the source and I active
relays according to one row in Figure 3 at the destination.
The destination needs to compute the joint-LLR vector L =
{Lg}g=1...q, which merges the sufﬁcient statistics of all active
links. Like in Section II-C, we deﬁne the LLR vector up to
an additive constant as
Lg ≜ ln P[c = g|y(0) . . . y(I)] + ℓ1
∀g
(7)
Using Bayes’ theorem and the fact that the source-
destination and relay-destination channels are conditionally
independent, we obtain
P[c = g|y(0) . . . y(I)] ∝ p

y(0)|c = g

IY
i=1
p

y(i)|c(i) = h(i).g

(8)
where h(i) is the non-zero value used for the non-binary
repetition encoding of symbol c at relay i.
We deﬁne then the LLR vectors corresponding to each
separated channel, for the source (i = 0) and for the relay
transmissions (i > 0) as
λ(i)
g
≜ ln p

y(i)|c(i) = g

+ℓ2 = − 1
N0
m2
X
j=1
y(i)
j
− a(i)
j µj(g)

2
(9)
With h(0) = 1 and (8), we ﬁnally obtain the joint-LLR
vector components as the sum of the partial L-values:
Lg =
I
X
i=0
λ(i)
h(i).g
∀g
(10)
We thus combine the L-values of the main transmission
and the relay transmissions into one joint-LLR vector per code
symbol and feed the joint-LLR vectors to the decoder. In other
words, the repetition scheme is transparent to the decoder and
therefore does not affect the decoding complexity.
The process is depicted on Figure 4, which shows the factor
graph used for the joint decoding of the NB-LDPC code
from the source and the repetition codes from the relays. We
considered on this ﬁgure the case of 3 relays, each of them
sending Ni = N.2
3 extra repetition symbols. The repetition
symbols are equally distributed among the codeword, i.e., we
have selected the repetition locations {ckl}l=1...Ni at each
relay, such that the destination receives 3 LLR measures for
each coded symbol: one from the source, and two from the
relays. This is a completely arbitrary choice and shows only
the case of 3 relays with coding rates RRiD = 3/4. Our
cooperative scheme is more general than the example of Figure
4 as the decoder can be initialized with joint-LLR vectors build
from a different number of channel measurements for each
coded symbol. We will discuss this issue in more details in
the optimization Section IV.
Since the non-binary repetition codes impact only the the
joint-LLR computation, it follows that the decoder complexity
is the same, for any number of relays, which is a great
feature of our cooperative coding scheme. Indeed, most of
the cooperative coding schemes proposed in the literature
require a joint decoding of the source and relays codes in
an iterative turbo-decoding fashion [4], [10]. So the existing
approaches ﬁrstly increase the receiver decoding complexity,
but also prevents the use of multiple relays since the turbo-
decoders with more than 2 component codes are very difﬁcult
to design so that they approach the capacity of the channel
[22].
In our scheme, the decoding complexity does not depend on
the number of relays — only the computation of joint-LLR
vectors depends linearly on the number of relays — and more
importantly, if the non-zero values for the repetition codes are
well designed at the different relays, each relay brings an extra
coding gain.
Interleaver
Repetitions Relay 3
Repetitions Relay 1
Repetitions Relay 2
Source Codeword
h
h
h
h
h
h
h
h
h
h
h
h
h4
h4
h4
h5
h6
h5
h5
h5
h6
h6
h6
h4
1
1
1
2
2
2
3
3
3
1
3
2
Fig. 4.
Tanner graph of the joint-receiver at the destination. Case of 3 relays.
IV. OPTIMIZATION OF THE COOPERATIVE NB-LDPC
CODES
In this section, we propose a ﬁne optimization of the NB-
LDPC cooperative coding scheme, which aims at having the
best possible performance for the practical case of short to
moderate codeword lengths. Both the NB-LDPC code used at
the transmitter and the non-binary repetition codes at the relays
have to be properly optimized. The source NB-LDPC code will
be chosen so as to have the best performance in the waterfall
region, to ensure that the successful decoding rates at the relays
are large enough (remember that the relays are transmitting
to the destination only if they successfully decode the word
received from the source). Also, we propose a speciﬁc quasi-
cyclic protograph construction of the Tanner graph of the NB-
LDPC such that the relays can chose efﬁciently the locations at
209
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

which they should build the repetition symbols. As for the NB-
repetition codes at the relays, we will propose the optimization
of the non-zero ﬁeld values such that the coding gain at the
receiver is maximized.
A. NB-LDPC code Optimization at the Transmitter: Compo-
nent Codes
For codes deﬁned over GF(q), when addressing ﬁnite length
design, it has been shown in [14] that selecting carefully the
non binary entries of the parity-check matrix can improve the
overall performance of the code when compared to randomly
chosen coefﬁcients. The selection of the non zero values can
impact both on the waterfall and the on error ﬂoor. The
observed performance gains are dependent of both the ﬁeld
order and the code rate.
In the waterfall region, selecting the edges label row-wise
is critical. It is shown in [14] that best rows are selected
according to their equivalent binary minimum distance and
multiplicity of the minimum distance. The Binary Component
Code of a non-binary parity check is build from the transpose
of the companion matrices Hij of the non-zero values hij
composing the parity check. Using binary matrix images for
the non-zero values of the check and binary vector images cj
for the codeword symbols, one get the following parity-check
equation in a vector form, corresponding to the non-binary
parity-check equation (1):
dc
X
j=1
Hij.cj = 0p
in GF(2)p
where p = log2(q) is the number of bits per symbol of the
Galois ﬁeld.
The binary image of a non-binary parity-check in GF(q)
for q = 64 is explained in Figure 5, and it can be easily
seen that it acts as a binary component code of size (N −
K, N) = (p, p.dc). The better is the component code in terms
of minimum distance, the better will be the error decoding
performance in the waterfall region.
1
1
0
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
0
0
0
1
1
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
1
1
0
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
i4
i3
c
c
i−th  NB−parity−check
Hi3
Hi1
Hi2
i4
H
Fig. 5.
Binary image of a non-binary parity-check equation in GF(64)
In this paper, we generalize the approach proposed in [14],
and propose a new criterion selection for the non-zero values
which compose a parity-check. In existing approaches, it is
advised to maximize the strength of the component code, and
then choose the non-zero ﬁeld values such that the binary
image has the maximum minimum Hamming distance (Dmin),
together with the minimum multiplicity of codewords with
Hamming weight Dmin. Although locally optimal, this strat-
egy is not optimal when used in a message passing iterative
decoder, where extrinsic vector messages are propagated along
edges, i.e. between component codes. A better strategy, which
is especially efﬁcient when the code is a strictly regular ultra-
sparse code with dv = 2, is to optimize the balance between
sub-codes of the component code.
Let us describe here this new idea. Since the message-
passing decoder will propagate dc extrinsic messages com-
puted from the incoming message at each iteration, it is
better to build extrinsic messages which statistically behave
equally. In other words, the extrinsic messages should have
their quantity of mutual information as close as possible to
their average. Indeed, increasing the mutual information of
one particular extrinsic output will result in decreasing the
mutual information for other extrinsic messages, therefore
propagating worse messages to the rest of the Tanner graph.
Note that this property of equal balance between the extrinsic
messages is veriﬁed on average if the non-zero values are taken
uniformly at random. However, when one wants to optimize
only a limited number of non-zero values to improve the
performance, then the equal-balance property is lost, and we
propose here a design technique to compensate for it.
The new optimization criterion for component code selec-
tion is described in the following algorithm.
Algorithm 1 Component Code Optimization
1) Let us a non-binary parity check of degree dc with non-
zero values {h1 . . . hdc}
2) Consider the dc binary subcodes Scc(k) formed from the
combination of the dc − 1 values in {h1 . . . hdc} except
hk.
3) We choose for {h1 . . . hdc} the ﬁeld values in GF(q)
such that:
{h1 . . . hdc} =
max
{h1...hdc }
 dc
X
k=1
Dmin(Scc(k))
!
constrained to
Dmin(Scc(k) − Dmin(Scc(k′)
 ≤ 1
This criterion ensures that both the component code and all
the sub-codes of the components codes have good and equally
distributed error correction capability. This new optimization
criterion is indeed interesting since we saw slight improvement
in the waterfall region compared to codes that use existing
sets of non-zero values. We give below the best sets of ﬁeld
coefﬁcients for GF(64) and GF(256) that have been optimized
with the new criterion, and that we can use for the source
NB-LDPC code design. Recall that the notations used for the
ﬁeld elements are

0, α0, α1, . . . , α(q−2)	
. For dc = 4 and
dc = 6, four sets of values were found to have the exact same
performance with respect to the criterion of the optimization
algorithm.
• best rows for GF(64) and dc = 4
(α0, α9, α26, α46)
(α0, α17, α26, α43)
(α0, α17, α37, α54)
(α0, α20, α37, α46)
• best rows for GF(256) and dc = 4
(α0, α8, α173, α183)
(α0, α10, α82, α90)
(α0, α72, α80, α245)
(α0, α165, α175, α247)
210
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

B. NB-LDPC code Optimization at the Transmitter: Global
Tanner Graph
In this section, we describe our NB-LDPC code design,
based on protographs. First introduced by [23], a binary
protograph is deﬁned as a small bipartite graph from which
a larger graph is obtained, by the so-called lifting technique.
The protograph itself is generally described using its adjacency
matrix HB also called base matrix [24], where the coefﬁcients
HB(i, j) represent the number of edges between the i − th
check node Ci of the protograph and the j − th variable node
Vj. The base matrix HB is then a small matrix containing
small integer values. The lifting process is then to expand the
base matrix by replacing each non-zero entry HB(i, j) > 0
by the same number of non-overlapping circulant matrices.
Circulant matrices are usually preferred for practical purposes
since it reduces the descriptional complexity (ie. storage) of
the parity check matrix in the hardware realizations of the
LDPC encoder and decoder. If L is the size of the circulant
matrices, we obtain — after lifting — a Tanner graph with L
times more nodes and edges than the protograph. The last step
for non-binary LDPC codes is then to assign non-zero values
to the edges of the lifted Tanner graph. The nonzero values
are randomly assigned from the optimized subsets presented
in the previous section. Note that an additional optimization
step could be performed with the objective of improving the
performance in the error ﬂoor, as described in [14]. We have
performed this optimization technique in our code design, but
we do not present it in this paper, and refer to [14] for a
complete description.
On Figure 6, we show the protograph which has been chosen
for the coding rate R = 1/2. Similar protographs have been
build for higher rates, but we limit the discussion to the rate
R = 1/2 in this paper. The structure of the protograph has
been chosen so as to maximize the number of 1-SR survivors
[25]. In [25], the authors show that under iterative decoding, all
the codeword symbols do not have an equal protection, in the
situation that some symbols in their direct neighborhood in the
computational tree are erased or very noisy. They introduce the
concept of k−SR survivor symbols (k-steps recovery), which
is deﬁned as a symbol which can be recovered from the other
symbols after k iterations of the message passing decoder —
assuming that the other symbols are either correctly decoded,
or have a large likelihood. The authors use this property to
design puncturing patterns: 1−SR survivors can be preferably
punctured, since they are less sensitive than other symbols and
can be recovered easily under iterative decoding. Note that the
k − SR survivor property does not change if the code is a
binary LDPC code or a NB-LDPC code.
Here we will use this concept to indicate to the relays
where it is preferable to add non-binary repetition symbols
in the codeword. The reasoning is the dual of the puncturing
problem. If we know where the 1-SR symbols are in the code-
word, then the relay will preferably build repetition symbols
in the part of the codeword which does not contain the 1-
SR symbols. This way, after merging the LLR vectors into a
joint-LLR vector, the symbols which have the 1-SR property
will receive less information — on average — than the other
symbols. This is not a problem since the rest of the symbols,
with better joint-LLR values, will be able to retrieve the 1-
SR symbols. In the extreme case where the main link is so
noisy that the received LLR corresponds almost to a complete
erasure of the codeword, if we assume that the relays have
transmitted only the symbols without the 1-SR property, then
the receiver which uses the joint-LLR will successfully recover
the entire codeword.
It is obvious, from this discussion, that the NB-LDPC
code with the maximum of 1-SR symbols would be the best
choice. This way, it helps the relays to concentrate only on the
remaining part of the codeword to build the repetition symbols.
This is the approach that we used in this paper for the design
of the protograph. Figure 6 presents the obtained protograph
for the case of a coding rate R = 1/2, which is the protograph
with the maximum number of 1-SR symbols. In this structure,
4 checks are connected to the bottom 1-SR symbol (connected
with a bold/strong link) while 2 checks are connected to 2 of
the bottom symbols (indicated with a weak link). However,
each one of the bottom symbol is connected exactly to one
strong link and one weak link. The 1-SR condition is ensured
when each and every symbol is connected to at least one strong
link, i.e. at least one check node from which this symbol can
be recovered in 1 iterative step. With this protograph we get
4 symbols with the 1-SR property, which is the maximum
number for coding rate R = 1/2, and we would get 4 L
symbols with the 1-SR property after the lifting step. Note also
that this protograph has girth 6 (size of the minimum cycle),
which is also a good feature in order to get good Tanner graphs
after the lifting step [26].
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
1
0
0
0
0
1
0
1
0
0
0
0
1
0
0
1
1
1
1
1
1
1
1
1
1
1
1
0
0
1
0
0
1
0
1
0
0
1
0
0
1
0
1
0
1
0
of the Codeword
0
1
2
3
4
5
1
0
2
3
4
5
6
7
8
9
10
11
H =
1−SR Symbols Part
Fig. 6.
Detailed protograph for the source NB-LDPC code design. This
protograph has the property to maximize the number of symbols with the
1-SR property.
Let us have a look at the computational tree seen from one
of the 1-SR symbol node, which is drawn on Figure 7. Symbol
#8 is 1-SR from check node #0, and 2-SR from check node #5
since the symbol #10 will be recovered after the ﬁrst decoding
211
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

iteration. Note that all the symbols in the 1-SR region have
this property of being 1-SR from one of their edge, and 2-SR
from the other edge, which indicates that the number of 1-SR
symbols in maximum and there is no protograph with these
dimensions having more 1-SR symbols.
8
0
5
9
5
3
10
7
2
11
9
2
3
7
11
3
6
9
1
2
7
3
2
1
3
1
6
1
0
4
5
10
4
Fig. 7. Computational tree of the proposed protograph expanded from symbol
node #8.
To conclude this section, we have designed source NB-
LDPC codes based on a protograph approach, with connexion
degrees (dv = 2, dc). The considered protographs have both a
good girth g = 6 and the property of localized (a priori known
locations) maximum number of 1-SR symbols. The good girth
of the protograph ensures that very large girths can be obtained
for the lifted-graph, for example we obtained a girth of g = 16
for a NB-LDPC Tanner graph of length Ns = 480 coded
symbols. The localized 1-SR symbols, known at the relays,
are used to select the preferred locations of the non-binary
repetition symbols.
C. Repetition code Optimization at the Relays
We now discuss the impact of the non-binary repetition
symbols build by the relays and used in the joint-LLR compu-
tation at the destination. Usually, repetition coding is thought
as having no real coding gain, but is employed to reduce
the amount of noise in the received noisy symbols. Indeed,
repetition coding is used in many transmission schemes,
such as H-ARQ transmissions with Chase combining or in
cooperative coding with DF or CF strategies. In the case of
non-binary repetition codes however, it can be shown that the
simple repetition of a symbol, weighted by a non-zero value
h(i) ∈ GF(q) with h(i) ̸= 1, results in a non-negligible coding
gain [11].
Let us ﬁrst concentrate on the case of a single repetition.
We can simply explain the coding gain the following way: let
c be the symbol to be repeated and h(i).c being the repeated
Galois ﬁeld value. The receiver receives both noisy values on
c and h(i).c, corresponding to the same codeword symbol. It
follows that the demodulation actually acts as a maximum-a-
posteriori decoder of the repetition code, which is build from
the concatenation of the two Galois ﬁeld values [1, h(i)]. Now
the coding gain is increasing with the minimum distance of
the binary image of [1, h(i)]. In the case of simple a copy
— regular repetition with h(i) = 1 — the binary minimum
distance is Dmin = 2 and no coding gain can be achieved,
while for non-binary repetitions, this minimum distance is
typically larger Dmin ≥ 3 when the ﬁeld size q is sufﬁciently
large. Additionally, the non-zero repetition values h(i)
l
need
to be optimized with the knowledge of the non-zero values
which have been used in the source NB-LDPC code. Indeed,
during the iterative decoding algorithm, the extrinsic vector
messages will be computed using the joint-LLRs, that is, with
the modiﬁed parity-check nodes, including the repetition nodes
as well, as depicted on Figure 8. The modiﬁed parity-check
nodes act then as the new component codes of the joint coding
scheme. Following the discussion of Section IV-A, it is the
minimum distance of this modiﬁed parity-check nodes that
need to be optimized in order to have the best performance in
the waterfall region.
H
H
H
H
H
H
H
H
1 1
1 1
1 1
1 1
1 1
1 1
1 1
1 1
1 1
1 1
1 1
1 1
Source Codeword
Repetitions Symbols
Equivalent Binary Code
h1
h4
h3
h2
h(i)
4
h(i)
3
h(i)
2
h(i)
1
1
2
3
4
1
(i)
2
(i)
3
(i)
4
(i)
Fig. 8.
NB-LDPC parity-check node with concatenated repetition codes.
We now present the optimization of non-binary repetition
codes, with the objective of using only a small number of
non-binary ﬁeld values. We advice in particular to use the
same non-zero value h(i) for all the repeated symbols at
the relay i. By proper optimization, the coding gain is not
reduced compared to a relay which would use different non-
zero values {h(i)
l }l, and a single value per relay reduces greatly
the complexity of re-encoding at the relay. We then use the
following optimization procedure to optimize the values h(i),
∀i = 1 . . . I.
We proceed as follows. As described in the Section IV-A,
each and every check node of degree dc will be labeled with
the same set of non-zero values {h1, h2, . . . , hdc}. So each
location chosen by the relay in order to build a repetition
symbol will see two of the non-zero values in this set (since
dv = 2). As a consequence, the non-zero values h(i) needs to
be optimized jointly with all the values in {h1, h2, . . . , hdc}.
We have chosen to ﬁx the set corresponding to the check-node
values, and optimize the repetition values, conditionally to this
set. The optimization is described by the following algorithm:
The optimization algorithm is stopped when the maximum
number of potential relays I has been reached. We give as
an example the optimized repetition values for the case of a
dc = 4 NB-LDPC code in GF(64) and GF(256) using the
non-zero values sets presented in Section IV-A. The values
that we obtained with our algorithm are indicated in table I.
We have also indicated the minimum distance corresponding to
the equivalent binary code (parity-check plus repetition codes).
It can be seen that the minimum distance of equivalent codes
grows linearly with the number of relays, which shows that the
212
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

Algorithm 2 Non-Binary Repetition Code Optimization
1) Let a parity-check equation have ﬁxed non-zero values
corresponding to the set {h1, h2, . . . , hdc}. Let H0 be
the binary image of the equivalent code. Let i = 1.
2) Consider the modiﬁed binary code Hi, build from Hi−1
and the repetition codes with the same h(i) on all the dc
symbols,
3) Choose h(i) ∈ GF(q) such that the the minimum distance
of Hi is maximum. If several values h(i) have the
same minimum distance, choose the one with minimum
multiplicity,
4) i = i + 1, goto step 2).
Relay #
1
2
3
4
5
6
7
8
GF(64)
α26
α41
α52
α6
α56
α17
α50
α11
Dmin
8
14
20
25
31
37
43
49
GF(256)
α15
α165
α71
α150
α128
α122
α113
α104
Dmin
10
17
24
32
39
46
54
62
TABLE I
OPTIMUM NONZERO VALUES USED AT THE RELAYS FOR
REPETITION CODING.
coding gain at the receiver increases as well with the number
of relays.
In order to measure the performance gain in terms of
frame error rate, brought by our optimized repetition scheme,
we have performed Monte-Carlo simulations over a QPSK-
AWGN channel for 2 different schemes using GF(256) NB-
LDPC codes. The results are plotted on Figure 9. The di-
rect link is indicated in black, and uses a rate R = 1/2
source NB-LDPC code. Then, we assume that the receiver
receives gradually other channel values from the relays, with
in this situation, the case of 4 relays. Each additional channel
measurements lowers the overall coding rate, and in this
ﬁgure, we assumed that 25% of the codeword length have
been sent each time by the 4 relays. When the receiver has
received the information from the 4 relays, the overall coding
rate is indicated as R = 1/4. In our experiment, we have
compared the simple repetition scheme with our optimized
repetition scheme presented in this paper. One can see that the
coding gain, when using the optimized repetition codes is non-
negligible, between 0.3dB to 0.8dB, with no extra decoding
complexity at the receiver. It can also be seen on these curves,
that the coding gain increases with the number of relays.
V. SIMULATION RESULTS IN A SIMPLE COOPERATIVE
SITUATION
In order to evaluate the performance of our cooperative
scheme and compare it to other works proposed in the litera-
ture, we have chosen to take the example of the simplest case
of a single relay channel. The performance will be measured
by the distance to the capacity function, inferred from the
channel capacity. Capacities of various relaying strategies in
case of a single relay have been computed in [27], [28], [29],
and depend on the capacities of the three links. Since we
assumed that source-to-relay transmission is error free, as the
−3.5
−3
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
(Es/N0) in dB
Frame Error Rate
 
 
0.4000
0.3333
0.2857
0.2500
Fig. 9.
Performance comparison of simple repetition scheme at the relays,
and the optimized repetition scheme.
relay only propagates signals in case of successful decoding,
we only consider the capacities of the two other links.
The meaning of the capacity function is the following.
Assume that we want to transmit information with distributed
rate (RSD, RRD) over a single relay channel. The rate RSD
is chosen according to the quality of the channel between
source and relay, such that to ensure error free transmission
between them. The rate RRD is generally chosen according
to the delay constraints of the cooperation system. Recall
that γSD and γRD represent the signal-to-noise ratios from
source-to-destination and respectively relay-to-destination. We
deﬁne the relay channel discrepancy by the following quantity
δ = γRD
γSD
≥ 1, which represents the relative quality of the relay
link compared to the main link.
We have plotted on Figure 10 the SNR (γRD)dB of the
RD link with respect to the discrepancy ∆ = 10 log10(δ) in
the case of two scenarii, corresponding to (RSD, RRD) =
(0.5, 0.5) and (RSD, RRD) = (0.5, 1.0). The second scenario
is especially difﬁcult since we assume that the relay transmit
only K symbols to the destination. We have compared our
cooperative scheme with the binary split-and-extend LDPC
codes, which have been optimized for inﬁnite length us-
ing density evolution techniques [10]. For the binary LDPC
curves, we have plotted the minimum SNR (γRD)dB for which
the binary split-and-extend LDPC families converge to a zero
error probability, when the codeword size grows to +∞. As for
our NB-LDPC cooperative coding scheme, we have indicated
with symbols (circles and triangles) the SNR (γRD)dB at
which a Frame Error Rate of 10−5 has been reached with
Monte-Carlo simulations. For our NB-LDPC coding scheme,
GF(256) codes and repetition codes have been used, with
a codeword length of N = 720 coded symbols. For the
modulations, QPSK have been used for all links.
As we can see on these curves, the NB-LDPC cooperative
scheme is close to the capacity curves in all cases, and shows
especially a better robustness than the binary LDPC codes for
the (RSD, RRD) = (0.5, 1.0) scenario, when the discrepancy
213
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

becomes large. Additionnally, the capacity curves and the
binary LDPC curve correspond to asymptotic performance,
while our simulations are performed at relatively small lengths,
corresponding to N = 720 coded symbols in GF(256). We
then expect an axtra performance gain of our scheme by
considering either longer codeword lengths or irregular mother
NB-LDPC codes.
0
2
4
6
8
10
12
14
16
18
20
−8
−6
−4
−2
0
2
4
6
8
10
Discrepancy ∆γ (in dB)
Relay → Destination SNR : γRD (in dB)
 
 
(RSD,RRD)=(0.5,0.5) Capacity
(RSD,RRD)=(0.5,1.0) Capacity
(RSD,RRD)=(0.5,0.5) Binary LDPC
(RSD,RRD)=(0.5,1.0) Binary LDPC
Fig. 10.
Comparison of our cooperative scheme with existing binary LDPC
cooperative scheme and the relay channel capacity. Our NB-LDPC scheme is
indicated with the symbols (circles and triangles) in blue.
VI. CONCLUSIONS
In this paper, we have introduced and optimized a new
cooperative coding scheme based on non-binary LDPC codes
and the concept of non-binary repetition coding at the relays.
We have shown that our scheme can reconciliate the problems
usually encountered in decode-and-forward strategies, by en-
suring a non-negligible coding gain at the receiver, while the
joint-decoding complexity stays constant with the number of
relays in the system. Additionnally, the cooperative coding
scheme is independant on the channel model or on the order of
the modulation used for each link in the network, which allows
to keep all advantages shown in this paper with advanced link-
adaptation and channel estimation techniques. This will be the
purpose of a future work.
REFERENCES
[1] A. Sendonaris, E. Erkip, and B. Aazhang, “User cooperation diversity.
Part I. System description,” IEEE Transactions on Communications, vol.
51, no. 11, pp. 1927–1938, 2003.
[2] A. Sendonaris, E. Erkip, and B. Aazhang, “User cooperation diversity.
Part II. Implementation aspects and performance analysis,”
IEEE
Transactions on Communications, vol. 51, no. 11, pp. 1939–1948, 2003.
[3] J.N. Laneman, D.N. Tse, and G.W. Wornell,
“Cooperative diversity
in wireless networks: efﬁcient protocols and outage behaviour,” IEEE
Trans. on Information Theory, vol. 50, no. 12, pp. 3062–3080, 2004.
[4] M. C. Valenti and B. Zhao,
“Distributed turbo codes: towards the
capacity of the relay channel,” in IEEE Vehicular Technology Conference
(VTC), 2003, pp. 322–326.
[5] M. A. Khojastepour, N. Ahmed, and B. Aazhang, “Code design for the
relay channel and factor graph decoding,” in Asilomar Conf. on Signals,
Systems and Computers, 2004, pp. 2000–2004.
[6] P. Razaghi and W. Yu, “Bilayer LDPC codes for the relay channel,” in
IEEE Inter. Conf. on Communications (ICC), 2006, pp. 1574–1579.
[7] P. Razaghi and W. Yu,
“Bilayer low-density parity-check codes for
decode-and-forward in relay channels,”
IEEE Trans. on Information
Theory, vol. 53, no. 10, pp. 3723–3739, 2007.
[8] A. Chakrabarti, A. De Baynast, A. Sabharwal, and B. Aazhang, “Low-
density parity-check codes for the relay channels,” IEEE Journal on
Selected Areas in Communications, vol. 25, no. 2, pp. 280–291, 2007.
[9] J. Hu and T. M. Duman, “Low density parity check codes over wireless
relay channels,” IEEE Trans. on Wireless Communications, vol. 6, no.
9, pp. 3384–3394, 2007.
[10] V. Savin,
“Split-extended LDPC codes for coded cooperation,”
in
Information Theory and its Applications (ISITA), 2010 International
Symposium, October 2010.
[11] C. Poulliat K. Kasai, D. Declercq and K. Sakaniwa, “Multiplicatively
repeated non-binary LDPC codes,” IEEE Trans. Infomation Theory, vol.
57, no. 10, pp. 6788–6795, October 2011.
[12] D. Declercq K. Kasai and K. Sakaniwa, “Fountain coding via multi-
plicatively repeated non-binary LDPC codes,” to appear in IEEE Trans.
Communications, 2011.
[13] X. Y. Hu, E. Eleftheriou, and D. M. Arnold, “Regular and irregular
progressive edge-growth tanner graphs,” IEEE Trans. Inform. Theory,
vol. 51, no. 1, pp. 386–398, 2005.
[14] M. Fossorier C. Poulliat and D. Declercq, “Design of regular (2,dc)-
LDPC codes over GF(q) using their binary images,”
IEEE Trans.
Communications, vol. 56, no. 10, pp. 1626–1635, 2008.
[15] A. Bennatan and D. Burshtein,
“Design and analysis of nonbinary
ldpc codes for arbitrary discrete-memoryless channels,” IEEE Trans.
Information Theory, vol. 52, no. 2, pp. 549–583, 2006.
[16] S. Pﬂetschinger and D. Declercq,
“Non-binary coding for vector
channels,” in SPAWC’11, San Fransisco, CA, USA, June 2011.
[17] S. Pﬂetschinger and M. Navarro, “Link adaptation with retransmissions
for non-binary ldpc codes,”
in Future Network and Mobile Summit,
Florence, Italy, June 2010.
[18] R. M. Tanner, “A recursive approach to low complexity codes,” IEEE
Transactions on Information Theory, vol. 27, no. 5, pp. 533–547, 1981.
[19] H. Steendam H. Wymeersch and M. Moeneclaey, “Log-domain decoding
of ldpc codes over GF(q),” in ICC’04, Paris, France, June 2004.
[20] D. Declercq and M. Fossorier, “Decoding algorithms for non-binary
LDPC codes over GF(q),” IEEE Trans. Commun., vol. 55, no. 4, pp.
633–643, 2007.
[21] F. Verdier M. Fossorier A. Voicila, D. Declercq and P. Urard, “Low-
complexity decoding for non-binary LDPC codes in high order ﬁelds,”
IEEE Trans. Communications, vol. 58, no. 5, pp. 1365–1375, May 2010.
[22] D. Divsalar and F. Pollara, “On the design of turbo codes,” The JPL
TDA Progress Report, pp. 42–123, November 1995.
[23] J. Thorpe,
“Low-density parity-check (ldpc) codes constructed from
protographs,” JPL INP, Tech. Rep., August 2003.
[24] Lan
Lan
Yifei
Zhang
Shu
Lin
William
Ryan
Gianluigi
Liva,
Shumei Song, “Design of ldpc codes: A survey and new results,” Journal
of Communications Software and Systems, 2006.
[25] D. Klinc J. Ha, J. Kim and S. W. McLaughlin,
“Rate-compatible
punctured low-density parity-check codes with short block lengths,”
IEEE, Trans. Inform. Theory, vol. 52, pp. 728–738, 2006.
[26] D. Declercq A. Venkiah and C. Poulliat,
“Design of cages with a
randomized progressive edge growth algorithm,” IEEE Commun. Lett.,
vol. 12, no. 4, pp. 301–303, April 2008.
[27] T. Cover and A. E. Gamal, “Capacity theorems for the relay channel,”
IEEE Trans. on Information Theory, vol. 25, no. 5, pp. 572–584, 1979.
[28] M. A. Khojastepour, A. Sabharwal, and B. Aazhang, “On capacity of
Gaussian ’cheap’ relay channel,” in IEEE Global Telecom. Conference
(GLOBCOM), 2003, vol. 3, pp. 1776–1780.
[29] G. Kramer, M. Gastpar, and P. Gupta,
“Cooperative strategies and
capacity theorems for relay networks,”
IEEE Trans. on Information
Theory, vol. 51, no. 9, pp. 3037–3063, 2005.
214
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-183-0
ICN 2012 : The Eleventh International Conference on Networks

