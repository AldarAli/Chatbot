Reliability Aspects of Uniformly Parameterised Cooperations
Peter Ochsenschläger and Roland Rieke
Fraunhofer Institute for Secure Information Technology, SIT
Darmstadt, Germany
Email: peter-ochsenschlaeger@t-online.de, roland.rieke@sit.fraunhofer.de
Abstract—In this paper, we examine reliability aspects of
systems, which are characterised by the composition of a
set of identical components. These components interact in a
uniform manner, described by the schedules of the partners.
Such kind of interaction is typical for scalable complex systems
with cloud or grid structure. We call these systems “uniformly
parameterised cooperations”. We consider reliability of such
systems in a possibilistic sense. This is formalised by always-
eventually properties, a special class of liveness properties using
a modiﬁed satisfaction relation, which expresses possibilities.
As a main result, a ﬁnite state veriﬁcation framework for
uniformly parameterised reliability properties is given. The
keys to this framework are structuring cooperations into
phases and deﬁning closed behaviours of systems. In order to
verify reliability properties of such uniformly parameterised
cooperations, we use ﬁnite state semi-algorithms that are
independent of the concrete parameter setting.
Keywords-reliability aspects of scalable complex systems; live-
ness properties; uniformly parameterised reliability properties;
ﬁnite state veriﬁcation; possibilistic reliability.
I. INTRODUCTION
The transition from systems composed of many isolated,
small-scale elements to large-scale, distributed and mas-
sively interconnected systems is a key challenge of modern
information and communications technologies. These sys-
tems need to be dependable, which means they need to
remain secure, robust and efﬁcient [1]. Examples for highly
scalable systems comprise (i) grid computing architectures;
and (ii) cloud computing platforms. In grid computing, large
scale allocation issues relying on centralised controls present
challenges that threaten to overwhelm existing centralised
management approaches [1]. Cloud computing introduced
the concept, to make software available as a service. This
concept can only be successful, if certain obstacles such
as reliability issues are solved [2]. In order to be able to
model functional requirements of dependable systems best
satisfying both fault-tolerance and security attributes, three
distinct classes of (system speciﬁcation) properties need
to be considered, namely safety, liveness, and information
ﬂow [3]. Concrete reliability problems related to liveness
properties range from replica selection to consistency of
cloud storage (which allows multiple clients to access stored
data concurrently in a consistent fashion) [4]. Most existing
replica selection schemes rely on either central coordination
(which has reliability, security, and scalability limitations)
or distributed heuristics (which may lead to instability) [4].
Another important issue is, that clients of cloud services do
not operate continuously, so clients should not depend on
other clients for liveness of their operations [5].
In this paper, we consider systems that interact in a way
that is typical for scalable complex systems. These systems,
which we call uniformly parameterised cooperations, are
characterised by (i) the composition of a set of identical
components (copies of a two-sided cooperation); and (ii)
the fact that these components interact in a uniform manner
(described by the schedules of the partners). As an example
of such uniformly parameterised systems of cooperations, e-
commerce protocols can be considered. In these protocols,
the two cooperation partners have to perform a certain kind
of ﬁnancial transactions. Such a protocol should work for
several partners in the same manner, and the mechanism
(schedule) to determine how one partner may be involved
in several cooperations is the same for each partner. So,
the cooperation is parameterised by the partners and the
parameterisation should be uniform with respect to the
partners.
Reliability is an important concept related to depend-
ability, which ensures continuity of correct service [6]. In
this paper, we consider reliability in a possibilistic sense,
which means that correct services can be provided according
to a certain pattern of behaviour again and again. These
possibilities of providing correct services are expressed by
a special class of liveness properties using a modiﬁed satis-
faction relation. We call these properties always-eventually
properties.
As a main result of the work presented, a ﬁnite state
veriﬁcation framework for uniformly parameterised relia-
bility properties is given. The keys to this framework are
structuring cooperations into phases and deﬁning closed
behaviours of systems. In this framework, completion of
phases strategies and corresponding success conditions can
be formalised [7], which produce ﬁnite state semi-algorithms
that are independent of the concrete parameter setting. These
algorithms are used to verify reliability properties of uni-
formly parameterised cooperations under certain regularity
restrictions.
The paper is structured as follows. Section II gives an
overview of the related work. In Section III, uniform pa-
rameterisations of two-sided cooperations in terms of formal
25
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

language theory is formalised. Section IV introduces the
concept of uniformly parameterised reliability properties.
The concept of structuring cooperations into phases given in
Section V enables completion of phases strategies, which are
described in Section VI. Consistent with this, corresponding
success conditions can be formalised [2], which produce
ﬁnite state semi-algorithms to verify reliability properties
of uniformly parameterised cooperations. Finally, the paper
ends with conclusions and an outlook in Section VII.
II. RELATED WORK
System properties: A formal deﬁnition of safety and
liveness properties is proposed in [8]. In [9], we deﬁned a
satisfaction relation, called approximate satisfaction, which
expresses a possibilistic view on liveness and is equivalent
to the satisfaction relation in [8] for safety properties. In this
paper, we extended this concept (cf. Section IV) and deﬁned
uniformly parameterised reliability properties, which ﬁt to
the parameterised structure of the systems, which we con-
sider here. Besides these safety and liveness properties so
called “hyperproperties” [10] are of interest because they
give formalisations for non-interference and non-inference.
Veriﬁcation approaches for parameterised systems:
An extension to the Murϕ veriﬁer to verify systems with
replicated identical components through a new data type
called RepetitiveID is presented in [11]. A typical applica-
tion area of this tool are cache coherence protocols. The
aim of [12] is an abstraction method through symmetry,
which works also when using variables holding references
to other processes. This is not possible in Murϕ. In [13], a
methodology for constructing abstractions and reﬁning them
by analysing counter-examples is presented. The method
combines abstraction, model-checking and deductive veri-
ﬁcation. However, this approach does not consider liveness
properties. In [14], a technique for automatic veriﬁcation
of parameterised systems based on process algebra CCS
[15] and the logic modal mu-calculus [16] is presented.
This technique views processes as property transformers
and is based on computing the limit of a sequence of
mu-calculus formula generated by these transformers. The
above-mentioned approaches demonstrate, that ﬁnite state
methods combined with deductive methods can be applied
to analyse parameterised systems. The approaches differ
in varying amounts of user intervention and their range
of application. A survey of approaches to combine model
checking and theorem proving methods is given in [17].
Iterated shufﬂe products: In [18], it is shown that
our deﬁnition of uniformly parameterised cooperations is
strongly related to iterated shufﬂe products [19], if the
cooperations are “structured into phases”. The main concept
for such a condition are shufﬂe automata [20] (multicounter
automata [21]) whose computations, if they are determin-
istic, unambiguously describe how a cooperation partner is
involved in several phases.
In [22], we have shown in particular that for self-similar
parameterised systems LIK the parameterised problem of
verifying a uniformly parameterised safety property can be
reduced to ﬁnite many ﬁxed ﬁnite state problems.
Complementary to this, in the present paper, we deﬁne
a uniformly parameterised reliability property based on this
concept. The main result is a ﬁnite state veriﬁcation frame-
work for such uniformly parameterised reliability properties.
III. PARAMETERISED COOPERATIONS
The behaviour L of a discrete system can be formally
described by the set of its possible sequences of actions.
Therefore L ⊂ Σ∗ holds where Σ is the set of all actions
of the system, and Σ∗ (free monoid over Σ) is the set of
all ﬁnite sequences of elements of Σ (words), including the
empty sequence denoted by ε. Σ+ := Σ∗ \{ε}. Subsets of Σ∗
are called formal languages [23]. Words can be composed:
if u and v are words, then uv is also a word. This oper-
ation is called the concatenation; especially εu = uε = u.
Concatenation of formal languages U,V ⊂ Σ∗ are deﬁned
by UV := {uv ∈ Σ∗|u ∈ U and v ∈ V}. A word u is called
a preﬁx of a word v if there is a word x such that v = ux.
The set of all preﬁxes of a word u is denoted by pre(u);
ε ∈ pre(u) holds for every word u. The set of possible
continuations of a word u ∈ L is formalised by the left
quotient u−1(L) := {x ∈ Σ∗|ux ∈ L}.
Inﬁnite words over Σ are called ω-words [24]. The set
of all inﬁnite words over Σ is denoted Σω. An ω-language
L over Σ is a subset of Σω. For u ∈ Σ∗ and v ∈ Σω the
left concatenation uv ∈ Σω is deﬁned. It is also deﬁned for
U ⊂ Σ∗ and V ⊂ Σω by UV := {uv ∈ Σω|u ∈ U and v ∈ V}.
For an ω-word w the preﬁx set is given by the formal
language pre(w), which contains every ﬁnite preﬁx of w.
The preﬁx set of an ω-language L ⊂ Σω is accordingly
given by pre(L) = {u ∈ Σ∗| it exist v ∈ Σω with uv ∈ L}. For
M ⊂ Σ∗ the ω-power Mω ⊂ Σω is the set of all “inﬁnite
concatenations” of arbitrary elements of M. More formal
deﬁnitions of theses ω-notions are given in the appendix.
Formal languages, which describe system behaviour, have
the characteristic that pre(u) ⊂ L holds for every word u ∈ L.
Such languages are called preﬁx closed. System behaviour
is thus described by preﬁx closed formal languages.
Different formal models of the same system are partially
ordered with respect to different levels of abstraction. For-
mally, abstractions are described by so called alphabetic lan-
guage homomorphisms. These are mappings h∗ : Σ∗ −→ Σ′∗
with h∗(xy) = h∗(x)h∗(y) , h∗(ε) = ε and h∗(Σ) ⊂ Σ′ ∪{ε}.
So, they are uniquely deﬁned by corresponding mappings
h : Σ −→ Σ′ ∪ {ε}. In the following, we denote both the
mapping h and the homomorphism h∗ by h. Inverse homo-
morphism are denoted by h−1. Let L be a language over
the alphabet Σ′. Then h−1(L) is the set of words w ∈ Σ∗
such that h(w) ∈ L. In this paper, we consider a lot of
alphabetic language homomorphisms. So, for simplicity, we
26
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

tacitly assume that a mapping between free monoids is an
alphabetic language homomorphism if nothing contrary is
stated.
To describe a two-sided cooperation, let Σ = Φ ∪ Γ where
Φ is the set of actions of cooperation partner F and Γ is the
set of actions of cooperation partner G and Φ ∩ Γ = /0. Now
a preﬁx closed language L ⊂ (Φ ∪ Γ)∗ formally deﬁnes a
two-sided cooperation.
Example 1. Let Φ = {fs,fr} and Γ = {gr,gi,gs} and hence
Σ = {fs,fr,gr,gi,gs}. An example for a cooperation L ⊂ Σ∗
is now given by the automaton in Figure 1. It describes a
simple handshake between F (client) and G (server), where a
client may perform the actions fs (send a request), fr (receive
a result) and a server may perform the corresponding
actions gr (receive a request), gi (internal action to compute
the result) and gs (send the result).
In the following, we will denote initial states by a short
incoming arrow and ﬁnal states by double circles. In this
automaton, all states are ﬁnal states, since L is preﬁx closed.
fs
gr
gi
gs
fr
Figure 1.
Automaton for 1-1-cooperation L
For parameter sets I, K and (i,k) ∈ I × K let Σik de-
note pairwise disjoint copies of Σ. The elements of Σik
are denoted by aik and ΣIK :=
S
(i,k)∈I×K
Σik. The index ik
describes the bijection a ↔ aik for a ∈ Σ and aik ∈ Σik. Now
LIK ⊂ Σ∗
IK (preﬁx-closed) describes a parameterised system.
To avoid pathological cases, we generally assume parameter
and index sets to be non empty.
For a cooperation between one partner of type F with two
partners of type G in Example 1 let
Φ{1}{1,2} = {fs11,fr11,fs12,fr12},
Γ{1}{1,2} = {gr11,gi11,gs11,gr12,gi12,gs12} and
Σ{1}{1,2} = Φ{1}{1,2} ∪ Γ{1}{1,2}.
fs12
gr12
gi12
gs12
fr12
fs11
gr11
gi11
gs11
fr11
Figure 2.
Automaton for 1-2-cooperation L{1}{1,2}
A 1-2-cooperation, where each pair of partners coop-
erates restricted by L and each partner has to ﬁnish the
handshake it just is involved in before entering a new one,
is now given (by reachability analysis) by the automaton
in Figure 2 for L{1}{1,2}. It shows that one after another
client 1 runs a handshake either with server 1 or with
server 2. Figure 3 in contrast depicts an automaton for a
2-1-cooperation L{1,2}{1} with the same overall number of
partners involved but two of type F and one partner of
type G. Figure 3 is more complex than Figure 2 because
client 1 and client 2 may start a handshake independently of
each other, but server 1 handles these handshakes one after
another. A 5-3-cooperation with the same simple behaviour
of partners already requires 194.677 states and 1.031.835
state transitions (computed by the SH veriﬁcation tool [25]).
fs11
fs21
fs21
gr11
fs11
gr21
gr11
gr21
gi11
fs21
gi21
fs11
gi11
gi21
fs21
gs11
fs11
gs21
gs11
gs21
fs21
fr11
fs11
fr21
gr21
fr11
gr11
fr21
fr11
gi21
fr21
gi11
fr11
gs21
fr21
gs11
fr21
fr11
Figure 3.
Automaton for the 2-1-cooperation L{1,2}{1}
For (i,k) ∈ I ×K, let πIK
ik : Σ∗
IK → Σ∗ with
πIK
ik (ars) =

a |
ars ∈ Σik
ε |
ars ∈ ΣIK \Σik .
For uniformly parameterised systems LIK we generally
want to have
LIK ⊂
\
(i,k)∈I×K
((πIK
ik )−1(L))
because from an abstraction point of view, where only the
actions of a speciﬁc Σik are considered, the complex system
LIK is restricted by L.
In addition to this inclusion, LIK is deﬁned by local
schedules that determine how each “version of a partner”
can participate in different cooperations. More precisely,
let SF ⊂ Φ∗, SG ⊂ Γ∗ be preﬁx closed. For (i,k) ∈ I ×
27
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

K, let ϕIK
i
: Σ∗
IK → Φ∗ and γIK
k
: Σ∗
IK → Γ∗ with
ϕIK
i (ars) =
 a |
ars ∈ Φ{i}K
ε |
ars ∈ ΣIK \Φ{i}K
and
γIK
k (ars) =
 a |
ars ∈ ΓI{k}
ε |
ars ∈ ΣIK \ΓI{k} ,
where ΦIK and ΓIK are deﬁned correspondingly to ΣIK.
Deﬁnition 1 (uniformly parameterised cooperation).
Let I, K be ﬁnite parameter sets, then
LIK :=
\
(i,k)∈I×K
(πIK
ik )−1(L)
∩
\
i∈I
(ϕIK
i )−1(SF)∩
\
k∈K
(γIK
k )−1(SG)
denotes a uniformly parameterised cooperation.
By this deﬁnition,
L{1}{1} = (π{1}{1}
11
)−1(L)
∩ (ϕ{1}{1}
1
)−1(SF)∩(γ{1}{1}
1
)−1(SG).
Because we want L{1}{1} being isomorphic to L by the
isomorphism π{1}{1}
11
: Σ∗
{1}{1} → Σ∗, we additionally need
(π{1}{1}
11
)−1(L) ⊂ (ϕ{1}{1}
1
)−1(SF) and
(π{1}{1}
11
)−1(L) ⊂ (γ{1}{1}
1
)−1(SG).
This is equivalent to πΦ(L) ⊂ SF and πΓ(L) ⊂ SG, where
πΦ : Σ∗ → Φ∗ and πΓ : Σ∗ → Γ∗ are deﬁned by
πΦ(a) =

a |
a ∈ Φ
ε |
a ∈ Γ
and πΓ(a) =

a |
a ∈ Γ
ε |
a ∈ Φ .
So, we complete Def. 1 by the additional conditions
πΦ(L) ⊂ SF and πΓ(L) ⊂ SG.
Schedules SF and SG that ﬁt to the cooperations given
in Example 1 are depicted in Figs. 4(a) and 4(b). Here, we
have πΦ(L) = SF and πΓ(L) = SG.
fs
fr
(a) Schedule SF
gr
gi
gs
(b) Schedule SG
Figure 4.
Automata SF and SG for the schedules SF and SG
The system LIK of cooperations is a typical example of a
complex system. It consists of several identical components
(copies of the two-sided cooperation L), which interact in a
uniform manner (described by the schedules SF and SG and
by the homomorphisms ϕIK
i
and γIK
k ).
Remark 1. It is easy to see that LIK is isomorphic to LI′K′
if I is isomorphic to I′ and K is isomorphic to K′. More
precisely, let ιI
I′ : I → I′ and ιK
K′ : K → K′ be bijections and
let ιIK
I′K′ : Σ∗
IK → Σ∗
I′K′ be deﬁned by
ιIK
I′K′(aik) := aιI
I′(i)ιK
K′(k) for aik ∈ ΣIK.
Hence, ιIK
I′K′ is a isomorphism and ιIK
I′K′(LIK) = LI′K′. The
set of all these isomorphisms ιIK
I′K′ deﬁned by corresponding
bijections ιI
I′ and ιK
K′ is denoted by I IK
I′K′.
To illustrate the concepts of this paper, we consider the
following example.
Example 2. We consider a system of servers, each of them
managing a resource, and clients, which want to use these
resources. We assume that as a means to enforce a given
privacy policy a server has to manage its resource in such
a way that no client may access this resource while it is
in use by another client (privacy requirement). This may be
required to ensure anonymity in such a way that clients and
their actions on a resource cannot be linked by an observer.
We formalise this system at an abstract level, where
a client may perform the actions fx (send a request), fy
(receive a permission) and fz (send a free-message), and
a server may perform the corresponding actions gx (receive
a request), gy (send a permission) and gz (receive a free-
message). The possible sequences of actions of a client resp.
of a server are given by the automaton SF resp. SG. The
automaton L describes the 1-1-cooperation of one client and
one server (see Figure 5). These automata deﬁne the client-
server system LIK.
1
2
6
3
5
4
7
8
fx
gx
gy
fy
fz
fx
gz
gx
gz
gz
(a) 1-1-cooperation L
1
2
3
fx
fy
fz
(b) Schedule SF
1
2
3
4
gx
gy
gz
gx
gz
(c) Schedule SG
Figure 5.
Automata L, SF and SG for Example 2
IV. A CLASS OF LIVENESS PROPERTIES
Usually, behaviour properties of systems are divided into
two classes: safety and liveness properties [8]. Intuitively
28
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

a safety property stipulates that “something bad does not
happen” and a liveness property stipulates that “something
good eventually happens”. In [8], both classes, as well as
system behaviour, are formalised in terms of ω-languages,
because especially for liveness properties inﬁnite sequences
of actions have to be considered.
Deﬁnition 2 (linear satisfaction). According to [8], a prop-
erty E of a system is a subset of Σω. If S ⊂ Σω represents the
behaviour of a system, then S linearly satisﬁes E iff S ⊂ E.
In [8], it is furthermore shown that each property E is the
intersection of a safety and a liveness property.
Safety properties Es ⊂ Σω are of the form Es = Σω \FΣω
with F ⊂ Σ∗, where F is the set of “bad things”.
Liveness
properties
El ⊂ Σω
are
characterised
by
pre(El) = Σ∗. A typical example of a liveness property is
El = (Σ∗M)ω with /0 ̸= M ⊂ Σ+.
(1)
This El formalises that “always eventually a ﬁnite action
sequence m ∈ M happens”.
We describe system behaviour by preﬁx closed languages
B ⊂ Σ∗. So, in order to apply the framework of [8], we have
to transform B into an ω-language. This can be done by the
limit lim(B) [24]. For preﬁx closed languages B ⊂ Σ∗, their
limit is deﬁned by
lim(B) := {w ∈ Σω|pre(w) ⊂ B}.
If B contains maximal words u (deadlocks), then these u
are not captured by lim(B). Formally the set max(B) of all
maximal words of B is deﬁned by
max(B) := {u ∈ B| if v ∈ B with u ∈ pre(v), then v = u}.
Now, using a dummy action #, B can be unambiguously
described by
ˆB := B∪max(B)#∗ ⊂ ˆΣ∗,
where # /∈ Σ and ˆΣ := Σ ∪ {#}. By this deﬁnition, in ˆB the
maximal words of B are continued by arbitrary many #’s.
So, ˆB does not contain maximal words.
a
b
c
(a) Automaton for B
a
b
c
#
(b) Automaton for ˆB
Figure 6.
Automata for B and ˆB
Let for example B be given by the automaton in Fig-
ure 6(a), then ˆB is given by the automaton in Figure 6(b).
By this construction, we now can assume that system
behaviour is formalised by preﬁx closed languages ˆB ⊂
Σ∗#∗ ⊂ ˆΣ∗ without maximal words, and the corresponding
inﬁnite system behaviour S ⊂ Σω is given by S := lim( ˆB).
For such an S and safety properties E = ˆΣω \ F ˆΣω with
F ⊂ ˆΣ∗ it holds
S ⊂ E iff S∩F ˆΣω = /0 iff pre(S)∩F = /0 iff ˆB∩F = /0.
If F ⊂ Σ∗, then ˆB∩F = /0 iff B∩F = /0. Therefore,
S ⊂ E iff B∩F = /0 for F ⊂ Σ∗.
(2)
So, by (2) our approach in [22] is equivalent to the ω-
notation of safety properties described by F ⊂ Σ∗.
Linear satisfaction (cf. Def. 2) is too strong for systems
in our focus with respect to liveness properties, because S =
lim( ˆB) can contain “unfair” inﬁnite behaviours, which are
not elements of E.
Let for example I ⊃ {1,2} and K ⊃ {1}, then lim(d
LIK)∩
Σω
{1}{1} ̸= /0, which means that inﬁnite action sequences
exist, where only the partners with index 1 cooperate. So,
if a property speciﬁcation involves actions of a partner
with index 2, as for instance E = Σ∗
IKΣ{2}{1}Σω
IK, then this
property is not linearly satisﬁed because lim(d
LIK) ̸⊂ E.
Instead of neglecting such unfair inﬁnite behaviours, we
use a weaker satisfaction relation, called approximate satis-
faction, which implicitly expresses some kind of fairness.
Deﬁnition 3 (approximate satisfaction). A system S ⊂ ˆΣω
approximately satisﬁes a property E ⊂ ˆΣω iff each ﬁnite
behaviour (ﬁnite preﬁx of an element of S) can be continued
to an inﬁnite behaviour, which belongs to E. More formally,
pre(S) ⊂ pre(S∩E).
In [9], it is shown, that for safety properties linear
satisfaction and approximate satisfaction are equivalent.
With respect to approximate satisfaction, liveness proper-
ties stipulate that “something good” eventually is possible.
Many practical liveness properties are of the form (1). Let
us consider a preﬁx closed language B ⊂ Σ∗ and a formal
language /0 ̸= M ⊂ Σ+. By deﬁnition 3 lim( ˆB) approximately
satisﬁes (ˆΣ∗M)ω iff each u ∈ B is preﬁx of some v ∈ B with
v−1(B)∩M ̸= /0.
(3)
If B and M are regular sets, then (3) can be checked by
usual automata algorithms [23] without referring to lim( ˆB)∩
(ˆΣ∗M)ω.
Let us now consider the preﬁx closed language L ⊂ Σ∗ of
example 2 and the “phase” P ⊂ Σ+ given by the automaton
P in Figure 7.
I
II
III
IV
V
VI
VII
fx
gx
gy
fy
fz
gz
Figure 7.
Automaton P
lim(ˆL) approximately satisﬁes the liveness property
(ˆΣ∗P)ω ⊂ ˆΣ∗, because the automaton L in Figure 5(a)
is strongly connected and P ⊂ L.
(4)
29
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

(4) states that in the 1-1-cooperation lim(ˆL) always even-
tually a “complete run through the phase P” is possible. This
is a typical reliability property.
Properties of the form (ˆΣ∗M)ω with /0 ̸= M ⊂ Σ+ we call
always-eventually properties.
Let now /0 ̸= ˚M ⊂ Σ+
˚I ˚K with ﬁxed ﬁnite index sets ˚I and
˚K. Then
(ˆΣ∗
IK ˚M)ω
is an always-eventually property for each ﬁnite index sets
I ⊃ ˚I and K ⊃ ˚K. Using bijections on ˚I and ˚K this can easily
be generalised to each ﬁnite index sets I and K with |I| ≥ |˚I|
and |K| ≥ | ˚K|, where |I| denotes the cardinality of the set
I. More precisely, let I ˚I ˚K
I′K′ be the set of all isomorphisms
ι ˚I ˚K
I′K′ : Σ∗
˚I ˚K → Σ∗
I′K′ generated by bijections ι ˚I
I′ : ˚I → I′ and
ι ˚K
K′ : ˚K → K′ in such a way that
ι ˚I ˚K
I′K′(aik) := aι ˚I
I′(i)ι ˚K
K′(k)
for aik ∈ Σ˚I ˚K. Then
(ˆΣ∗
IKι ˚I ˚K
I′K′( ˚M))ω
is an always-eventually property for each I ⊃ I′, K ⊃ K′ and
ι ˚I ˚K
I′K′ ∈ I ˚I ˚K
I′K′. For ﬁnite index sets ˚I, I, ˚K and K let
I [(˚I, ˚K),(I,K)] :=
[
I′⊂I,K′⊂K
I ˚I ˚K
I′K′.
Note that I [(˚I, ˚K),(I,K)] = /0 if |˚I| > |I| or | ˚K| > |K|.
Deﬁnition 4 (uniformly parameterised reliability property).
Let ˚I, I, ˚K and K be ﬁnite index sets with |˚I| ≤ |I| and
| ˚K| ≤ |K|. If /0 ̸= ˚M ⊂ Σ+
˚I ˚K, then the family
A ˚M
IK := [(ˆΣ∗
IKι ˚I ˚K
I′K′( ˚M))ω]ι ˚I ˚K
I′K′∈I [(˚I, ˚K),(I,K)].
is a strong uniformly parameterised always-eventually prop-
erty (uniformly parameterised reliability property).
We say that lim(d
LIK) approximately satisﬁes such a
family A ˚M
IK iff lim(d
LIK) approximately satisﬁes each of the
properties (ˆΣ∗
IKι ˚I ˚K
I′K′( ˚M))ω for ι ˚I ˚K
I′K′ ∈ I [(˚I, ˚K),(I,K)].
Remark 2. We use the adjective strong, because in [7]
uniform parameterisations of general properties are deﬁned,
which, in case of always-eventually properties, are weaker
than deﬁnition 4.
Let us return to example 2 and let
˚P := (π{1}{1}
11
)−1P ⊂ Σ+
{1}{1} and
˚E := ( \
Σ{1}{1}
∗ ˚P)ω ⊂ \
Σ{1}{1}
ω.
(5)
Because π{1}{1}
11
: Σ∗
{1}{1} → Σ∗ is an isomorphism, by (4)
lim( \
L{1}{1}) approximately satisﬁes ˚E.
Now by deﬁnition 4 lim(d
LIK) approximately satisﬁes A ˚P
IK
iff in lim(d
LIK) for each pair of clients and servers always
eventually a complete run through a phase P is possible.
V. COOPERATIONS BASED ON PHASES
The schedule SG of example 2 shows that a server
may cooperate with two clients partly in an interleaving
manner. To formally capture such behaviour, cooperations
are structured into phases [18]. This formalism is based on
iterated shufﬂe products and leads to sufﬁcient conditions
for liveness properties (cf. Section VI).
Shufﬂing two words means arbitrarily inserting one word
into the other word, like shufﬂing two decks of cards. In
[21], this is formalised as follows:
A word w ∈ Σ∗ is called a shufﬂe of words w1,...,wm ∈ Σ∗
if the positions of w can be coloured using m colors so that
the positions with color i ∈ {1,...,m}, when read from left
to right, form the word wi. Shufﬂe of a set P ⊂ Σ∗, is {w :
w is a shufﬂe of some w1,...,wm ∈ P, for some m ∈ N}.
However, we now provide an alternative formalisation,
which is more adequate to the considerations in this paper.
Deﬁnition 5 (iterated shufﬂe product). Let t ∈ N, and for
each t let Σt be a copy of Σ. Let all Σt be pairwise disjoint.
The index t describes the bijection a ↔ at for a ∈ Σ and
at ∈ Σt (which is equivalent to a colouring with color t in
the formalism of [21]). Let
ΣN :=
[
t∈N
Σt, and for each t ∈ N
let the homomorphisms τN
t
and ΘN be deﬁned by
τN
t
: Σ∗
N → Σ∗ with τN
t (as) =

a |
as ∈ Σt
ε |
as ∈ ΣN \Σt
and
ΘN : Σ∗
N → Σ∗ with ΘN(at) := a for at ∈ Σt and t ∈ N.
The iterated shufﬂe product P of P is now deﬁned by
P := ΘN[
\
t∈N
(τN
t )−1(P∪{ε})] for P ⊂ Σ∗.
It is easy to see that this is equivalent to the deﬁnition
from [21] above. Let for example P = {ab}. Now, according
to [21], the word w = aabb is a shufﬂe of two words
w1, w2 ∈ P because two colors, namely 1 and 2, can be
used to colour the word aabb so that w1 = w2 = ab ∈ P.
According to deﬁnition 5, aabb ∈ P because aabb =
ΘN(a1a2b2b1) and τN
1 (a1a2b2b1) = τN
2 (a1a2b2b1) = ab ∈ P
and τN
t (a1a2b2b1) = ε for t ∈ N\{1,2}.
Following the ideas in [18], we structure cooperations into
phases.
Deﬁnition 6 (based on a phase). A preﬁx closed language
B ⊂ Σ∗ is based on a phase P ⊂ Σ∗, iff B = pre(P ∩B).
If B is based on P, then B ⊂ pre(P) = (pre(P)) and
B = pre(P) ∩B.
Let for example P = {ab} be given by the Automaton
P in Figure 8(a) and B be given by the automaton B in
Figure 8(b). Then P ∩ B = {ab}∗. This implies that B is
based on P.
30
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

I
II
III
a
b
(a) Automaton P for P= {ab}
a
b
(b) Automaton B for B
Figure 8.
Automata P and B
Generally, each B is based on inﬁnitely many phases. If B
is based on P, then B is based on P′ for each P′ ⊃ P. Each
B ⊂ Σ∗ is based on Σ because Σ = Σ∗. Figure 9 shows how
we use phases to structure cooperations. The appropriate
phases for our purposes as well as closed behaviours (words,
in which all phases are completed) will be discussed in
Section VI.
time
interleaving
complexity
1
2
3
closed behaviour segment
closed behaviour
closed
behaviour
phase in
cooperation (i′′,k′)

A records
open phases
all phases
are closed
(i,k)
...
(i′,k)
(i′′,k′)
...
...
...
shufﬂe describes
interleaving
strategy to
close all
open phases
Figure 9.
Phases and closed behaviours
We will now provide an automaton representation

A for
P, which will illustrate “how a language B is based on
a phase P”. Let P ⊂ Σ∗ and A = (Σ,Q,∆,q0,F) with ∆ ⊂
Q×Σ×Q, q0 ∈ Q and F ⊂ Q be an (not necessarily ﬁnite)
automaton that accepts P. To exclude pathological cases we
assume ε /∈ P ̸= /0. A consequence of this is in particular
that q0 /∈ F. Let NQ
0 denote the set of all functions from Q
in N0. For the construction of

A the set NQ
0 plays a central
role. In NQ
0 we distinguish the following functions:
0 ∈ NQ
0 with 0(x) = 0 for each x ∈ Q,
and for q ∈ Q the function
1q ∈ NQ
0 with 1q(x) =

1 |
x = q
0 |
x ∈ Q\{q} .
As usual for numerical functions, a partial order as well
as addition and partial subtraction are deﬁned.
For f,g ∈ NQ
0 let f ⩾ g iff f(x) ⩾ g(x) for each x ∈ Q,
f + g ∈ NQ
0 with (f + g)(x) := f(x) + g(x) for each x ∈ Q,
and for f ⩾ g, f −g ∈ NQ
0 with (f −g)(x) := f(x)−g(x) for
each x ∈ Q.
The key idea of

A is, to record in the functions of NQ
0 how
many open phases are in each state q ∈ Q respectively. Its
state transition relation

∆ is composed of four subsets whose
elements describe (a) the entry into a new phase, (b) the
transition within an open phase, (c) the completion of an
open phase, (d) the entry into a new phase with simultaneous
completion of this phase. With these deﬁnitions we now
deﬁne the shufﬂe automaton

A.
Deﬁnition 7 (shufﬂe automaton).
The shufﬂe automaton

A = (Σ,NQ
0 ,

∆,0,{0}) w.r.t. A is an
automaton with inﬁnite state set NQ
0 , the initial state 0, which
is the only ﬁnal state and

∆ :={(f,a, f +1p) ∈ NQ
0 ×Σ×NQ
0 |
(q0,a, p) ∈ ∆ and it exists (p,x,y) ∈ ∆} ∪
{(f,a, f +1p −1q) ∈ NQ
0 ×Σ×NQ
0 |
f ⩾ 1q,(q,a, p) ∈ ∆ and it exists (p,x,y) ∈ ∆} ∪
{(f,a, f −1q) ∈ NQ
0 ×Σ×NQ
0 |
f ⩾ 1q,(q,a, p) ∈ ∆ and p ∈ F} ∪
{(f,a, f) ∈ NQ
0 ×Σ×NQ
0 | (q0,a, p) ∈ ∆ and p ∈ F}.
Accepting of a word w ∈ Σ∗ is deﬁned as usual [23].
Generally

A is a non-deterministic automaton with an
inﬁnite state set. In the literature, such automata are called
multicounter automata [21] and it is known that they accept
the iterated shufﬂe products [26]. For our purposes, deter-
ministic computations of these automata are very important.
To analyse these aspects more deeply we use our own
notation and proof of the main theorems. In [18], it is shown
that

A accepts P.
Let for example P = {ab} (cf. Figure 8(a)). Then the states
f : Q → N0 of the automaton

P are described by the sets
{(q,n) ∈ Q×N0|f(q) = n ̸= 0}.
/0
a
−→ {(II,1)}
a
−→ {(II,2)}
b
−→ {(II,1)}
b
−→ /0
is the only computation of aabb ∈ P in

P; it is an accepting
computation.
Example 3. Let L be deﬁned by the automaton L in
Figure 5(a) and P ⊂ Σ+ be deﬁned by the automaton P in
Figure 7, then L∩P is accepted by the product automaton
of L and

P that is given in Figure 10.
This automaton is strongly connected and isomorphic to
L (without considering ﬁnal states), which proves that L
is based on phase P. The states (7,{(VI,1),(II,1)}) and
(8,{(VI,1),(III,1)}) show that L is “in this states involved
in two phases”.
Note that this product automaton, as well as the product
automaton in Figure 11(b) and 12(b), is ﬁnite and determin-
istic.
31
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

(1, /0)
(2,{(II,1)})
(6,{(VI,1)})
(3,{(III,1)})
(5,{(V,1)})
(4,{(IV,1)})
(7,{(VI,1),(II,1)})
(8,{(VI,1),(III,1)})
fx
gx
gy
fy
fz
fx
gz
gx
gz
gz
Figure 10.
Product automaton of L and

P
VI. SUFFICIENT CONDITIONS FOR A CLASS OF
LIVENESS PROPERTIES
The following deﬁnition is the key to sufﬁcient condi-
tions for strong uniformly parameterised always-eventually
properties.
Deﬁnition 8 (set of closed behaviours). Let B,M ⊂ Σ∗. M
is a set of closed behaviours of B, iff x−1(B) = B for each
x ∈ B∩M.
In Figure 10, the initial state (1, /0) is the only ﬁnal state
of that strongly connected product automaton, so P is a
set of closed behaviours of L.
Now, we get a sufﬁcient condition for uniformly param-
eterised always-eventually properties.
Theorem 1. Let I, K, ˚I and ˚K be ﬁnite index sets with
|˚I| ≤ |I| and | ˚K| ≤ |K|. Let LIK be a uniformly parameterised
system of cooperations and let CIK ⊂ Σ∗
IK be a set of closed
behaviours of LIK, such that LIK = pre(LIK ∩CIK).
If lim(d
L˚I ˚K) approximately satisﬁes (d
Σ˚I ˚K
∗ ˚M)ω, with ˚M ⊂
Σ+
˚I ˚K, then
lim(d
LIK) approximately satisﬁes A ˚M
IK.
For the proof of Theorem 1 see the appendix. The
following theorem gives a set of closed behaviours of LIK.
Theorem 2. Let P be a set of closed behaviours of L and
let πΦ(P) resp. πΓ(P) be a set of closed behaviours of
SF resp. SG, then
CIK :=
\
(i,k)∈I×K
(πIK
ik )−1(P)
is a set of closed behaviours of LIK.
Theorem 2 is proven in [7]. We now show that πΦ(P)
is a set of closed behaviours of SF, which is given in
Figure 5(b). The automaton PF in Figure 11(a) is the
minimal automaton of πΦ(P) ⊂ Φ+.
By Theorem 3, which is given in the appendix
SF ∩πΦ(P) = SF ∩(πΦ(P)).
I
II
III
IV
fx
fy
fz
(a) Automaton PF
(1, /0)
(2,{(II,1)})
(3,{(III,1)})
fx
fy
fz
(b) Product automaton of SF and

PF
Figure 11.
Automaton PF and product automaton of SF and

PF
So, SF ∩ πΦ(P) is accepted by the product automaton of
SF and

PF that is depicted in Figure 11(b). By the same
argument as for the product automaton of L and

P SF is
based on πΦ(P), and πΦ(P) is a set of closed behaviours
of SF.
Likewise, the automaton PG in Figure 12(a) is the mini-
mal automaton of πΓ(P) ⊂ Γ+, SG∩πΓ(P) is accepted by
the product automaton of SG and

PG in Figure 12(b), SG is
based on πΓ(P), and πΓ(P) is a set of closed behaviours
of SG.
I
II
III
IV
gx
gy
gz
(a) Automaton PG
(1, /0)
(2,{(II,1)})
(3,{(III,1)})
(4,{(III,1),(II,1)})
gx
gy
gz
gx
gz
(b) Product automaton of SG and

PG
Figure 12.
Automaton PG and product automaton of SG and

PG
So, by Figure 10, 11(b) and 12(b) all assumptions of
Theorem 2 are fulﬁlled.
(6)
Now to apply Theorem 1 together with Theorem 2 it remains
to ﬁnd conditions such that each u ∈ LIK is preﬁx of some
v ∈ LIK ∩ CIK. This set of closed behaviours CIK consists
of all words w ∈ Σ∗
IK, in which all phases are completed.
Considering example 2, we have shown that each phase
is initiated by an F-action (Figure 7), each F-partner is
involved in at most one phase (Figure 11(b)), and, each G-
partner is involved in at most two phases (Figure 12(b)).
Now to construct for each u ∈ LIK a v ∈ LIK ∩CIK with
u ∈ pre(v) one may imagine that the following strategy could
work.
1) For each G-partner involved in two phases, complete
one of this phases.
2) For each G-partner involved in one phases, complete
this phase.
3) Complete the phases, where only an F-partner is in-
volved in.
32
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

If L is based on P, SF based on πΦ(P) and SG based on
πΓ(P), then by Theorem 3 the assumptions of Theorem 2
imply L = pre(L∩P), SF = pre(SF ∩πΦ(P)) and SG =
pre(SG∩πΓ(P)).
This is in [7] the starting point of a more general form
of such a “completion (of phases) strategy”, where also
“success conditions” for that strategy are given. It is shown,
that under certain regularity restrictions these conditions can
be veriﬁed by semi-algorithms based on ﬁnite state methods.
These restrictions are:
The product automata as in Figure 10, 11(b) and
12(b) must be ﬁnite and deterministic.
(7)
We only get semi-algorithms but no algorithms, because
the product automata are constructed step by step and this
procedure does not terminate if the corresponding product
automaton is not ﬁnite.
Using (7), (3) and the Theorems 1 and 2, the approximate
satisfaction of uniformly parameterised always-eventually
properties can be veriﬁed by semi-algorithms based on ﬁnite
state methods. This veriﬁcation method only depends on L,
SF, SG, P and ˚M and doesn’t refer to the general index sets
I and K.
In [7], it is shown that the success conditions are fulﬁlled
in example 2. So, by (4), Theorem 1, Theorem 2 and (6) in
example 2 lim(d
LIK) approximately satisﬁes A ˚P
IK for each
ﬁnite index sets I and K, where ˚P is deﬁned in (5).
VII. CONCLUSIONS AND FUTURE WORK
The main result of this paper is a ﬁnite state veriﬁcation
framework for uniformly parameterised reliability proper-
ties. The uniformly parameterisation of reliability properties
exactly ﬁts to the scalability and reliability issues of complex
systems and systems of systems, which are characterised by
the composition of a set of identical components, interacting
in a uniform manner described by the schedules of the
partners.
In this framework, the concept of structuring cooperations
into phases enables completion of phases strategies. Con-
sistent with this, corresponding success conditions can be
formalised [7], which produce ﬁnite state semi-algorithms
(independent of the concrete parameter setting) to verify re-
liability properties of uniformly parameterised cooperations.
The next step should be to integrate these semi-algorithms
in our SH veriﬁcation tool [25].
Furthermore, we plan a generalisation of the presented
approach to systems whose global behaviour is composed of
behavioural patterns. The aim is, to eventually derive a set of
construction principles for reliable parameterised systems.
Another future work perspective is the application of the
approach presented in this paper to the Security Modeling
Framework (SeMF) [27]. In SeMF, beside system behaviour,
also local views of agents and agents knowledge about
system behaviour are considered.
ACKNOWLEDGEMENT
Roland Rieke developed the work presented here in the
context of the project MASSIF (ID 257475) being co-funded
by the European Commission within FP7.
APPENDIX
A. Basic Notations
The set of all inﬁnite words over Σ is deﬁned by
Σω = {(ai)i∈N|ai ∈ Σ for each i ∈ N},
where N denotes the set of natural numbers. On Σω a
left concatenation with words from Σ∗ is deﬁned. Let
u = b1 ...bk ∈ Σ∗ with k ≥ 0 and b j ∈ Σ for 1 ≤ j ≤ k
and w = (ai)i∈N ∈ Σω with ai ∈ Σ for all i ∈ N, then
uw = (xj)j∈N ∈ Σω with xj = bj for 1 ≤ j ≤ k and xj = aj−k
for k < j. For w ∈ Σω the preﬁx set pre(w) ⊂ Σ∗ is deﬁned by
pre(w) = {u ∈ Σ∗| it exists v ∈ Σω with uv = w}. For L ⊂ Σ∗
the ω-language Lω ⊂ Σω is deﬁned by Lω = {(ai)i∈N ∈
Σω| it exists a strict monotonically increasing function f :
N
→
N with a1 ...af(1)
∈
L and af(i)+1 ...af(i+1)
∈
L for each i ∈ N} . f : N → N is called strict monotonically
increasing if f(i) < f(i+1) for each i ∈ N.
B. Proof of Theorem 1
To prove Theorem 1 the following lemma is needed.
Lemma 1.
LIK ⊃ LI′K′ for I′ ×K′ ⊂ I ×K.
For the proof of Lemma 1 see [18] (proof of Theorem 1).
Proof: Proof of Theorem 1.
If lim(d
L˚I ˚K) approximately satisﬁes (d
Σ˚I ˚K
∗ ˚M)ω, then by (3)
(with u = ε) there exists v ∈ L˚I ˚K with v−1(L˚I ˚K) ∩ ˚M ̸= /0.
As ι ˚I ˚K
I′K′ is an isomorphism
ι ˚I ˚K
I′K′(L˚I ˚K) = LI′K′ and
(ι ˚I ˚K
I′K′(v))−1(LI′K′)∩ι ˚I ˚K
I′K′( ˚M) ̸= /0.
(8)
As CIK is a set of closed behaviours of LIK and each
u ∈ LIK is preﬁx of some v ∈ LIK ∩ CIK, there exists x ∈
u−1(LIK) with (ux)−1(LIK) = LIK.
By Lemma 1 LIK ⊃ LI′K′ for each I′ ⊂ I and K′ ⊂ K, so
(ux)−1(LIK) ⊃ LI′K′.
Now (8) implies
(ι ˚I ˚K
I′K′(v))−1((ux)−1(LIK))∩ι ˚I ˚K
I′K′( ˚M) ̸= /0.
(9)
As (ι ˚I ˚K
I′K′(v))−1((ux)−1(LIK)) = (uxι ˚I ˚K
I′K′(v))−1(LIK), (9)
and (3) complete the proof of Theorem 1.
C. Homomorphism Theorem for P
Theorem 3 (homomorphism theorem for P).
Let µ : Σ∗ → Σ′∗ be an alphabetic homomorphism, then holds
µ(P) = (µ(P)).
For the proof of Theorem 3 see [7] (proof of Theorem 6).
33
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

REFERENCES
[1] S. Bullock and D. Cliff, “Complexity and emergent behaviour
in ICT systems,” Hewlett-Packard Labs, Tech. Rep. HP-2004-
187, 2004.
[2] M. Armbrust, A. Fox, R. Grifﬁth, A. D. Joseph, R. H.
Katz, A. Konwinski, G. Lee, D. A. Patterson, A. Rabkin,
I. Stoica, and M. Zaharia, “Above the Clouds: A Berkeley
View of Cloud Computing,” EECS Department, University
of California, Berkeley, Tech. Rep. UCB/EECS-2009-28, Feb
2009.
[3] Z. Benenson, F. Freiling, T. Holz, D. Kesdogan, and L. Penso,
“Safety, liveness, and information ﬂow: Dependability revis-
ited,” in Proceedings of the 4th ARCS International Workshop
on Information Security Applications, pp. 56–65.
[4] P. Wendell, J. W. Jiang, M. J. Freedman, and J. Rexford,
“Donar: decentralized server selection for cloud services,”
in Proceedings of the ACM SIGCOMM 2010 conference on
SIGCOMM, ser. SIGCOMM ’10.
New York, NY, USA:
ACM, 2010, pp. 231–242.
[5] A. Shraer, C. Cachin, A. Cidon, I. Keidar, Y. Michalevsky,
and D. Shaket, “Venus: veriﬁcation for untrusted cloud stor-
age,” in Proceedings of the 2010 ACM workshop on Cloud
computing security workshop, ser. CCSW ’10.
New York,
NY, USA: ACM, 2010, pp. 19–30.
[6] A. Avizienis, J.-C. Laprie, B. Randell, and C. E. Landwehr,
“Basic Concepts and Taxonomy of Dependable and Secure
Computing,” IEEE Trans. Dependable Sec. Comput., vol. 1,
no. 1, pp. 11–33, 2004.
[7] P. Ochsenschläger and R. Rieke, “Behaviour Properties
of Uniformly Parameterised Cooperations,” Fraunhofer SIT,
Tech. Rep. SIT-TR-2010/2, 2010.
[8] B. Alpern and F. B. Schneider, “Deﬁning Liveness,” Informa-
tion Processing Letters, vol. 21, no. 4, pp. 181–185, October
1985.
[9] U. Nitsche and P. Ochsenschläger, “Approximately Satis-
ﬁed Properties of Systems and Simple Language Homomor-
phisms,” Information Processing Letters, vol. 60, pp. 201–
206, 1996.
[10] M. R. Clarkson and F. B. Schneider, “Hyperproperties,”
Computer Security Foundations Symposium, IEEE, vol. 0, pp.
51–65, 2008.
[11] C. N. Ip and D. L. Dill, “Verifying Systems with Replicated
Components in Murϕ,” Formal Methods in System Design,
vol. 14, no. 3, pp. 273–310, 1999.
[12] F. Derepas and P. Gastin, “Model Checking Systems of
Replicated Processes with SPIN,” in Proceedings of the 8th
International SPIN Workshop on Model Checking Software
(SPIN’01), ser. Lecture Notes in Computer Science, M. B.
Dwyer, Ed., vol. 2057.
Toronto, Canada: Springer, May
2001, pp. 235–251.
[13] Y. Lakhnech, S. Bensalem, S. Berezin, and S. Owre, “Incre-
mental Veriﬁcation by Abstraction.” in TACAS, ser. Lecture
Notes in Computer Science, T. Margaria and W. Yi, Eds., vol.
2031.
Springer, 2001, pp. 98–112.
[14] S. Basu and C. R. Ramakrishnan, “Compositional analysis for
veriﬁcation of parameterized systems,” Theor. Comput. Sci.,
vol. 354, no. 2, pp. 211–229, 2006.
[15] R. Milner, Communication and Concurrency, ser. Interna-
tional Series in Computer Science.
NY: Prentice Hall, 1989.
[16] J. C. Bradﬁeld and C. Stirling, “Modal Logics and Mu-
Calculi: An Introduction,” in Handbook of Process Algebra,
J. A. Bergstra, A. Ponse, and S. A. Smolka, Eds.
Elsevier
Science, 2001, ch. 1.4.
[17] T. E. Uribe, “Combinations of Model Checking and The-
orem Proving,” in FroCoS ’00: Proceedings of the Third
International Workshop on Frontiers of Combining Systems.
London, UK: Springer-Verlag, 2000, pp. 151–170.
[18] P. Ochsenschläger and R. Rieke, “Uniform Parameterisation
of Phase Based Cooperations,” Fraunhofer SIT, Tech. Rep.
SIT-TR-2010/1, 2010.
[19] M. Jantzen, “Extending Regular Expressions with Iterated
Shufﬂe,” Theor. Comput. Sci., vol. 38, pp. 223–247, 1985.
[20] J. Jedrzejowicz and A. Szepietowski, “Shufﬂe languages are
in P,” Theor. Comput. Sci., vol. 250, no. 1-2, pp. 31–53, 2001.
[21] H. Björklund and M. Bojanczyk, “Shufﬂe Expressions and
Words with Nested Data,” in Mathematical Foundations of
Computer Science 2007, 2007, pp. 750–761.
[22] P. Ochsenschläger and R. Rieke, “Security Properties of Self-
similar Uniformly Parameterised Systems of Cooperations,”
in Proceedings of the 19th Euromicro International Confer-
ence on Parallel, Distributed and Network-Based Computing
(PDP).
IEEE Computer Society, February 2011.
[23] J. Sakarovitch, Elements of Automata Theory.
Cambridge
University Press, 2009.
[24] D. Perrin and J.-E. Pin, Inﬁnite Words.
Elsevier, 2004, vol.
Pure and Applied Mathematics Vol 141.
[25] P. Ochsenschläger, J. Repp, and R. Rieke, “The SH-
Veriﬁcation Tool,” in Proc. 13th International FLorida Ar-
tiﬁcial Intelligence Research Society Conference (FLAIRS-
2000).
Orlando, FL, USA: AAAI Press, May 2000, pp.
18–22.
[26] J. Jedrzejowicz, “Structural Properties of Shufﬂe Automata,”
Grammars, vol. 2, no. 1, pp. 35–51, 1999.
[27] A. Fuchs, S. Gürgens, and C. Rudolph, “Towards a Generic
Process for Security Pattern Integration,” in Trust, Privacy
and Security in Digital Business, 6th International Confer-
ence, TrustBus 2009, Linz, Austria, September 3–4, 2009,
Proceedings.
Springer, 2009.
34
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

