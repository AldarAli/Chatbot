286
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Answering Complex Requests with Automatic Composition of Semantic Web
Services
Brahim Batouche
Public Research Center Henri Tudor,
Luxembourg
brahim.batouche@tudor.lu
Yannick Naudet
Public Research Center Henri Tudor,
Luxembourg
yannick.naudet@tudor.lu
Fr´ed´eric Guinand
University of Le Havre,
France
frederic.guinand@univ-lehavre.fr
Abstract—Today, there is a growing need for user to be able
to express, and get answers to more complex requests, those
including multiple functionalities, conditions, constraints and
objectives. Complex requests including multiple functionalities
only can not usually be answered with one single Web service.
As multiple services are needed, the problem is then to
ﬁnd good combination using the available services. This paper
contributes to answering this issue. It focuses on the problem
of semantic Web services composition to answer such requests.
We propose an automatic composition algorithm designing
the answering composition. The algorithm takes into account
all suitable composition structures. The set of answering
composition is modeled as a graph, which supports the selection
of the best composition according to the request constraints and
objectives.
Keywords-complex web request; composition of web services;
semantic web services.
I. INTRODUCTION
Electronic commerce (e-commerce) presents an important
average gain for enterprises of different domains: tourism,
transport, etc. For this reason the e-commerce has a growing
interest in Web services to publish its products. Addition-
ally, the Web services relative simplicity gives information
providers and users easy access to new content. They are
now widely available on the Web. For instance in 2009, the
number of Web pages for e-tourism (electronic tourism) has
been estimated to 65.2 billions, and represents in Europe
25.7% of the market [1]. As a side effect of this success,
customer requirements become more and more complex,
such that ﬁnding a single service ﬁtting the speciﬁc needs
of a user is unlikely.
Let us consider someone wanting to organize a stay in
Rome. Using natural language, he/she could express his/her
wish as: “ I want to visit Rome for a week-end, I would
like to go there by airplane and to stay in an hotel”. Such
request has two functionalities: ﬂight and hotel booking.
A functionality is associated to a service and each one
accepts inputs and produces outputs. The departure and
destination cities of the ﬂight are the input parameters of
the ﬂight service. The localization and the date are the input
parameters of the hotel service. These parameters have to be
coherent, e.g. the arrival date in Rome has to be the same
as the starting date of the Hotel reservation.
The request is processed in two steps: a ﬁrst step for
determining the services able to answer the different func-
tionalities, i.e., the services allowing to book a ﬂight and to
book an hotel, and a second step for actually executing the
functionalities, i.e., actual booking of ﬂight and hotel. The
ﬁrst step is achieved by calling informative services (IS),
while the second one is performed by active services (AS).
IS output is used as input by AS.
This paper is an extension of [2]. We propose an algo-
rithm for automatically ﬁnding all candidate compositions
answering a complex request, without a priori knowledge
of the composition structure. When the request does not
formally specify any chaining between the request elements,
the algorithm ﬁnds suitable composition structures based on
the available services. The structure of the composite service
depends obviously on the request, but also of the available
services. The underlying problem is not trivial because there
are many possible combinations of services, as well as many
composition structures.
Services composition is useful in many different domains,
e.g., tourism, transport, multimedia, etc. Some of them
involve a dynamic environment where at any time events
can affect previously computed compositions. The proposed
algorithm can compensate services failures by ﬁnding a new
executable composition when this happens.
In Section I-A and I-B we deﬁne respectively the research
context and the useful deﬁnitions. In Section II, we present
the state of the art and our contributions. In Section III,
we formalize the problem elements: service, request and
answering composition. In Section IV, we present how to
describe semantically Web services and complex request. In
Section V, we present the model of answering compositions.
Section VI present our algorithm for automatic construction
of a composition. Section VII is concerned with an experi-
mentation results on which we assess our algorithm. Section
VIII present speciﬁc cases of request resolutions. Finally, we
conclude in Section IX.

287
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
A. Background
Complex requests such as the example presented here
before, cannot be answered with one single service. Dif-
ferent processing steps are required. [3] decomposes the
request resolution into: service presentation, service trans-
lation, composition generation, composition evaluation, and
composition execution. In [4], the request processing is de-
composed into: Web services discovery, planning, execution,
and optimization. In [5], the request treatment follows three
steps: discovery, plan generation and plan optimization. It
appears that the choice of the resolution steps depends on
the considered point of view: [4], [5] take the customer point
of view, while [3] considers the provider point of view.
In this paper, we take the customer point of view and we
consider both the composition design time and runtime to
deﬁne our resolution steps. Design time can be decomposed
in three steps: services discovery, composition design (or
planning [4]) and selection of compositions. Runtime can
be decomposed into execution and adaptation steps [6].
We propose a general resolution process for answering
complex request made of ﬁve steps: (1) description of re-
quest functionalities, constraints and objectives; (2) services
discovery: to ﬁnd suitable services; (3) composition design:
to determine how the services can be composed together
to answer the request, and to design the corresponding
composite service; (4) selection of answer(s): to select the
composited services fulﬁlling the best the request objec-
tive(s) and respecting the request constraint(s), and ﬁnally
(5) composition execution.
Figure 1 illustrates the different steps from the user
request to the actual execution of the different services. The
outputs of one step are the inputs of the following one. This
paper focuses on steps (1) and (3), the step (2) being not
considered as it is widely studied (see e.g., [7]). We also
discuss the dynamic composition case, occurring when either
services are faulty on when they can no more be invoked at
execution time.
The request solving is decomposed into service discov-
ery and service selection. When the request is complex
we design the answer using composition of existing Web
service. The automatic composition provides the answering
composition set. Then the selection of the best composition
can require an optimization method.
Automatic composition is based on automatic service
discovery and combines the different discovered services
to answer a complex request. Functional parameters in
the request are used to ﬁnd services, while non-functional
parameters (request constraints and objectives) are exploited
to select the best matching services.
B. Overview and Deﬁnitions
Web services composition consists in two steps: design
time (design of composition answering a request) and run-
time (composition execution). At design time, two steps can
Figure 1.
Complex request processing principle.
also be considered: (1) the search of possible compositions
regarding the available services; and (2) the selection of best
compositions based on request objective and constraint. In
the following we provide related deﬁnitions.
1) Composition Design: The composition design can be
performed in three ways: automatically, semi-automatically
and manually. Moreover, the composition can be abstract or
executable.
Manual composition is a combination of services directly
speciﬁed directly by a designer. Semi-automatic composition
determines the composing services and their control ﬂow
progressively by interrogating the user. Automatic compo-
sition determines the composing services and their control
ﬂow progressively without user interaction.
An executable composition allows services invocation and
can be used as a composite service. An abstract composition
comprises only the functionalities and their control ﬂow,
without giving any execution possibility.
Following our requirements, we consider executable ser-
vices only. Indeed, the automatic composition requires being
able to invoke some services at design time: in particular
informative services, which will provide input data for other
services. Additionally, the composition itself needs to be
executable.
The composition of Web service is designed to achieve
a speciﬁc goal. This goal is achieved by composing many
services, and then building a new service, called “compos-
ite service”. The composite service can be modeled as a
composition path, tree, organization of agents, chromosome,
etc. The building of a composite service involves different
composition structures such as: sequence, choice, switch,
while, split (starting parallelism) and split-joint (ending
parallelism), see Figure 2. Many other terms are used for
naming composition structures like: control ﬂow, execution
plan, and planning. In this paper these terms will be used
as synonyms.
2) Composition Runtime: The composition runtime can
be done in static or dynamic environment, the composition
in dynamic environment is named “ dynamic composition”

288
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 2.
Composition structures illustration
while in static environment it is named “static composi-
tion”. The dynamic composition takes into account possible
execution failures (service breakdown) and provides some
executable alternative composition(s). This case is not con-
sidered in static composition [6].
II. STATE OF THE ART
Since our work concerns three items: complex request
description, automatic composition design and answering
composition model, this section presents the existing works
in these areas and highlight our contributions.
A. Complex Request Description
Several works try to describe semantically the complex
request. In [8], a complex request is presented as a set of
inputs, outputs and conditions, which are formalized in de-
scription logic ALN. The works [9], [10] present a complex
request as an abstract composite Web service and use service
proﬁle of OWL-S [11]. The service model can be used
to describe the internal structure. However, decomposing a
request in a connected set of services, estimating data and
control ﬂow, is not obvious for users.
The request formalization used in [8], [10], [9] is some-
how limited. [8] considers the request I/O and condition,
but the use of ALN as a formalization language makes it
difﬁcult to use with existing services standards implementa-
tions (using, e.g., OWL-S). The works [10], [9] use OWL-S
description, but they do not consider all the request elements
of formula 1, such as constraint and objective.
We modelled our request ontology to take into account
all the elements speciﬁed in the request formalization (for-
mula 1), and with the objective of keeping full advantage
of existing works on semantic Web services, such as the
matchmaking service OWL-MX [12]. Additionally, the user
request needs to be formalized in such a way it can directly
be used to ﬁnd matching services.
B. Composition Models
Before analyzing the existing works, we present our
requirements. According to our objectives, the composition
model should fulﬁll the ﬁve following points: (1) represent a
search space for optimization, specifying functional and non-
functional parameters of each composition. (2) support all
possibles composition structures: sequence, choice, switch,
while, split and split-joint, (3) allow the composition in-
vocation, (4) support dynamic environment and dynamic
composition: allowing to search for alternative compositions
when failures occur during execution, (5) allow the transla-
tion of compositions into existing Web services description
languages.
A model for the composition of Web services represents
a set of services and their links, achieving a speciﬁc set
of functionalities. According to researchers point of view
and requirements, the composition is modeled by different
mathematical representation: Petri nets [13], [14], [15], [16],
[17], Directed Acyclic Graph [18], [19], [5], Workﬂows [20],
[3], Situation Calculus [21], UML diagrams [22], Finite
State System [23] or Multi Agents System (MAS) [24].
1) Petri nets: Are the widely used to model services
composition, because they allow to model the steps and
events in distributed system and consider the compositions
structures. The composition is modeled with a set of places,
transitions and tokens: places correspond to services, transi-
tions correspond to input/output exchanges between services,
tokens correspond to atomic operations [14]. Functional and
non-functional parameters of services are speciﬁed in the
places of Petri nets, and not speciﬁed in the transitions.
We can not model services having values of parameters
according to other service, because non-functional param-
eters are speciﬁed in the places. For example, when the
hotel reservation cost changes according to the travel agency
service, the hotel service can have different costs (non-
functional parameter value), which cannot be speciﬁed in
the same place [13], [14], [15], [16], [17]. Non-functional
parameters could be speciﬁed as a transition weight vector,
but Petri nets are not speciﬁcally designed to achieve this
goal.
2) Directed Acyclic Graphs: DAG can be used to rep-
resent the execution order of services. The graph nodes
represent the services and the arcs represent the data ﬂow
between services. The composition is modeled as a path.
The functional parameters are speciﬁed in the node and the
non-functional parameters are speciﬁed on the arcs. This
structure allows to overcome the limit of Petri nets models.
However, unlike Petri nets, DAG have some restrictions that
prevent representing all the structures illustrated in Figure 2.
For instance, DAG acyclic constraints is incompatible with
the loop/while structure. To overcome this limit DAGs can
be adapted for different composition structures [18], [19],
[5].
3) The following synthesis can be made about the other
approaches: Workﬂow presents a composition as a sequence
of tasks and the message ﬂow between services. The work-
ﬂow semantic [20] allows to facilitate the interoperability
of heterogeneous Web services. Workﬂows can model com-
position structures, but do not allow representing multiple
compositions. UML activity diagrams is a descriptive model,
inspired from Petri nets model [22]. The UML diagram
is used for describing one compositions, and not a set.
Situation calculus is efﬁcient to construct the composition

289
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
in dynamic environment, because it represents the actions,
and the situation as a sequence of actions. However, it
is not obvious to exploit situation calculus to evaluate
a composition. Additionally, it cannot be used to model
multiple compositions, since it builds one composition step
by step [21]. Finite state system (FSS) represents a set of
states and transitions. States represent the services. Transi-
tions consider all possible actions to execute a composition.
However, FSS represents a composition as a sequence of
services, and it is not well suited to consider other structures
such as split or split-joint. Last, with Multi Agents System
(MAS) [24] a services composition can be represented by a
set of agents. Roles of agents corresponds to functionalities
of services; input, output, precondition and effect. The MAS
can be used to model the organization of compositions, but
it provides a model that cannot be used as an optimization
search space, because the non-functional parameters are not
considered.
Each of the aforementioned models, has advantages and
drawbacks for a speciﬁc requirement, but fails to meet all
requirements listed at beginning of this section. Among the
possible models we have listed, only the DAG is suitable,
because it can be easily adapted to our requirements of
supporting any composition structure and composition ex-
ecution. Adaptation of the other models remains a priori too
complex, without any foreseen beneﬁt.
C. Automatic Composition Design
As deﬁned in I-B1, automatic composition allows design-
ing a composition without interrogating the user, deﬁning
the different Web services components and their composition
structures. Some works [25], [26], [27], [15], [28], [29], [16],
[24], [17] try to achieve this goal.
In [25], rules are used to generate a sequence of Web
services, from the relations between them. Sequences are
the only composition structures considered in that work.
In [26] a ﬂooding algorithm is used. It ﬁrst looks for
services matching a request input. Then the algorithm pro-
gresses step by step by ﬁnding next services having input
matching the output of previously selected services. The
progression ﬁnishes when a selected service output matches
with the request output.
An architecture for automatic Web service composition
is proposed in [27], which according to the authors, allows
fast composition of OWL-S services. The proposed approach
uses implicitly a ﬂooding algorithm. However, while authors
provide interesting ideas for the design of the composite ser-
vice and automating service invocation, they only consider
sequences of services.
[15] proposes an algorithm based on matrix-equation
approach and the provided compositions are modeled with
Petri Nets. The compositions are built to answer a request.
During the building, the method allows to check the reacha-
bility of the composition, by checking accessibility of states
from initial state. This approach is also useful to verify the
validity of the built composition by other methods, but it
does not allow the evaluation of the composition.
Oh, Lee, and Kumara [29] present an AI-planning al-
gorithm of Web services composition, called WSPR. The
algorithm relies on the request input and output, and then
achieves the composition in two steps: (1) It computes the
cost to achieve the composition, beginning with the request
input. (2) This cost is used as guidance, to minimize the
length of the sequence of services. This approach allows
designing and selecting the composition at the same time,
which it is not possible for any request, as discussed in
section VIII-A. Additionally it considers only the sequence
structure.
The algorithm in [28] builds a composition graph from a
given request. It identiﬁes ﬁrst the input and output of the
request and searches for a matching service. If none can be
found, a service having only a matching output is selected
and recursively, subsequent services having output matching
with the input of the latter service and input matching with
the request input are sought. The algorithm ends when a
sequence of services starting with the request input and
ending with its output is found, or when the set of available
services has been visited. While the algorithm allows the
composition execution, it is limited to sequences structures,
such as [26]. The algorithm in [28] uses an inverse direction
of built [26], and it has been designed to minimize the
number of compositions, because generally an input can
correspond to services having different outputs. The method
of [26] is suitable to have a large set of compositions.
[16] presents an algorithm for “conﬁguration” of com-
positions and selection of the best composition according
to the services cost. The compositions are modeled with
Petri Nets and are selected by considering the non-functional
requirements. This approach allows to conﬁgure and select
the composition at the same time, as in [29].
In [24], a MAS is used to answer a user request using
automatic composition. The composition is based on a rea-
soning loop to determine the composition plans answering
the request. An agent is limited to an OWL-S service and its
functional parameters describing the agent role. The agents
collaborate to provide the composition needed. The proposed
reasoning algorithm allows to detect the composition plan
according to the service semantic, but it does not consider
all composition structures.
[17] builds the composition relying on semantic of service
input/output. An hypergraph representation, as in [30], is
used to determine the suitable services, and then to model the
composition with Petri Nets. Using the semantic of services
I/O ensures the coherency of composed services. The use of
an hypergraph allows the determination of suitable compo-
sitions according to functional parameters, without consid-
ering non-functional parameters. However, it considers only
the sequence structure. According to our requirements, it is

290
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
suitable to model all compositions without selection. The
latter is reported in the compositions optimization step.
To automate the composition design, considering our re-
quirements, the dedicated algorithm has to allow determining
the composition structures and executing the composition.
For this, we have to rely on the semantic of services
input and output (as in [17]), and also on the semantic of
composition structures.
D. Contributions
Our contributions to the Web services composition re-
search ﬁeld are respectively:
1) To formalize the different concepts of the problem:
Web service, complex request and composition of Web
service.
2) To propose an ontology (OWL-CR) describing seman-
tically the complex request.
3) To model the composition by considering all require-
ment cited at beginning of section II-B.
4) To propose an algorithm solving a complex request
with automatic composition, which considers any
composition structures and detects them automatically.
5) To determine when the composition requires an opti-
mization. When this is the case, we explain how to
represent the composition set as a search space for
optimization. In the other case, we explain how to
select the best composition.
The existing studies address the composition problem only
partially, and none of them considers all the points cited
above. Additionally, no formalization of the problem can be
found in the state of the art. In the following section, we
clearly state the problem to solve.
III. FORMALIZATION
The problem space of automatic service composition con-
cerns three main elements: a complex Web request to solve,
a set of available Web services and service compositions that
are form the services to answer the request. In this section,
We formalize these elements.
A. Complex Request
Deﬁnition 1: A complex request illustrates a service a
user asks for, following a speciﬁc goal, for which he/she
speciﬁes both functional and non-functional parameters. It
can be represented as a set of functionalities on which
conditions can be expressed, and a set of constraints and
objectives expressing non-functional parameters.
The complex request can then be written as a three-
tuple: R =< FR, D, NFR >, where FR = (FRi)T is the
vector of functionalities, T being the transposition operator,
where each functionality FRi is mandatory or optional and
has as input and output respectively IFRi and OFRi . D =
{d1, ..., dr} is a set of conditions, where a condition refers
to a request functionality input (IFRi ) or output (OFRi ); and
NFR is the set of non-functional parameters.
Lets ﬁrst write IR = {IFRi } and OR = {OFRi },
denoting respectively the input and output set of the request,
NFR can be deﬁned as NFR =< C, B, λ >, where C =
{c1, · · · , cm} is the set of constraints, B = {obj1, ..., objk}
is the set of objectives, and λ is the set of importance levels
associated to objectives. Finally, this leads to the following
formula:
R =< IR, OR, D, C, B, λ >
(1)
Conditions D differ form constraints C in that they have
to be veriﬁed by services answering a part of the request
or for instantiating the input parameters of service (e.g.,
the depart and destination cities for a transport service),
while constraints allow ﬁltering the set of answering services
or data obtained by the Informative Service (IS), or the
composition obtained by the automatic composition process
[2].
Objectives of B will have to be minimized (e.g., cost,
time) or maximized (e.g., performance, availability). In a
speciﬁc context, an objective will be minimized (e.g., the
service execution time is minimized) and maximized in an-
other context (e.g., the leisure activity time is maximized).
Constraints and objectives can refer to data, e.g., the
ﬂight price must not exceed 200 Euro (Cd), or, minimize
the ﬂight price (Bd). They can refer to services, e.g., the
service price must not exceed 5 Euro (Cs) (minimization);
or to the composition, e.g., the travel price must not ex-
ceed 3000 Euro (Cc) (minimization). We write accordingly
C =< Cd, Cs, Cc > and B =< Bd, Bs, Bc > . It should be
noticed that a composition constraint Cc can refer to one or
multiple optional functionality(s) (e.g., if the price exceeds
2500 Euro, then cancel the sports activity service to reduce
the price).
The importance levels λ are speciﬁed by the user. They
can concern one single functionality (e.g., the transport price
is more important than its quality.) or the whole request (e.g.,
the price is more important than the quality, globally). In
the ﬁrst case, we write λi,l, where i and l are respectively
the objective and functionality indexes. In the latter case,
it is simply written λi. The set of objectives importance
levels can be written: λ = {λi,l, λi}. Additionally λ can be
a single value (e.g., λ1 = 0.4, λ2 = 0.6) or an interval (e.g.,
λ1 ∈ [0, 0.4[, λ2 ∈ [0.6, 1[ ). We have Pi=k
i=1 λi = 1, and
∀l, Pi=k
i=1 λi,l = 1. We note that a request functionality can
be answered with a service or a composition of services. The
latter can contain different types of services, informative,
active or the both.
Finally, the request conditions can induce different kinds
of dependency between functionalities. We distinguish three
functionalities dependency types: no dependency, one-to-

291
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
one dependency and global dependency. The two latter are
deﬁned in Deﬁnition 2. Different strategies will be applied
depending on their kind, as will be explained in section
VIII-B.
Deﬁnition 2: One-to-one
dependency
in
the
request
means that all dependencies existing between request func-
tionalities concern at most two of them, and each function-
ality has at most one dependency.
Deﬁnition 3: Global dependency in the request means
that there exists at least one functionality having more than
one dependency.
B. Web Services
The literature proposes several deﬁnitions of Web ser-
vices. Basically: a Web service is a collection of pro-
tocols and standards used for exchanging data between
applications [31]. More speciﬁcally: Web services are self-
contained, modular business applications that have open,
Internet-oriented, standards-based interfaces [32]. Very
speciﬁcally: a Web service is a software application identi-
ﬁed by a URI, whose interfaces and bindings are capable of
being deﬁned, described, and discovered as XML artifacts. A
Web service supports direct interactions with other software
agents using XML-based messages exchanged via Internet-
based protocols [33].
Mathematically, we formalize a Web service as a ﬁve-
tuple:
S :=< ID, FP, NF, CS, NS >,
(2)
where ID denotes the service identiﬁer and access
(e.g., service URI), FP denotes its functional parame-
ters, Input, Output, Precondition, Effect (IOPE); NF
denotes its non-functional parameters (e.g., service name,
service price, etc.), CS denotes the composition structure
(i.e., the service control ﬂow); and NS is the set of ID
inner services (or operations). The existing Web service
languages try to annotate this ﬁve-tuple by describing them
syntactically or semantically.
A Web service is modeled according to a speciﬁc goal.
For this reason, there exist three Web service models [34]:
black box, white box and semi-transparent box. The black
box describes only the service functionalities, FP, the semi-
transparent box describes FP and the service composition
structures, CS, and the white box details all inner services,
NS. According to [34], the white box is hardly useable,
because it implies formalizing the service program in too
much details.
Solving a complex request implies modeling both the
existing services and the answering compositions. Regarding
existing services, the black box model is privileged because
knowing the functional parameter of services is enough to
discover matching services. For the answering compositions,
which can be used as an optimization search space, the
mixed use of white box and semi-transparent box (white-
semitransparent box) is suitable. This allows describing all
inner services NS and composition structures CS.
There are two types of service: informative service (IS)
and active service (AS). The ﬁrst provides some data
(e.g., list of things) and does not modify its database after
invocation. The second performs an action and modiﬁes its
database after its invocation (e.g., ﬂight booking). There
are signiﬁcant differences between IS and AS regarding
their usage in our resolution approach. Indeed, the IS will
be executed at composition time to aggregate the provided
information in the composition, whereas the AS will be
executed at composition runtime, i.e., after the optimization
has been performed, and after the user has selected its
preferred composition among the best compositions pro-
posed by the optimization method. The service can answer
a request functionality partially or completely.
C. Composition of Web Services
Web services compositions is the combination of multiple
service operations. These operations can follow a speciﬁc in-
vocation order (i.e., a control ﬂow or composition structure).
A service composition can be formalized as a triple:
SC :=< OP, CF, E >,
(3)
where
OP
denotes
the
set
of
service
operations
{op1, ..., opj}, CF denotes the set of control ﬂow constructs
(or composition structures) and E ⊆ (OP∪CF)×(OP∪CF)
are edges connecting operations and control ﬂow constructs
[35]. For example, if we consider a DAG of composition
G =< N, A >, where N is the set of nodes and A the set of
arcs, we have: SC :=< OP = N, CF = {Arc sequence},
E = A >.
In order to deﬁne the set CF, we ﬁrst review the most
common Web service composition languages: OWL-S and
BPEL4WS [36]. The existing languages for Web services
composition allow to model different composition structures
in different ways. Taking the most commonly known, we ob-
served the following. The structures modeled by OWL-S are:
”sequence”, ”any-order”, ”if-then-else”, ”choice”, ”while”,
”until”, ”split” and ”split-joint”. Differently, BPEL4WS [36]
uses: ”sequence”, ”switch”, ”while”, ”pick” and ”ﬂow”. A
mapping between the two representations involves two op-
erators: equivalence (e.g., “choice” is equivalent to “pick”);
decomposition (e.g., the “ﬂow” structure in BPEL4WS can
be decomposed into two structures of OWL-S: “split” and
“split-joint”; “switch” is set of imbrication “if-then-else”).
So, “while”, “until”, and “any-order” can be described by
other structures.
In order to insure a compatibility with the different
representations and keeping a generic approach, we focus

292
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 3. Service composition illustration: tree, ﬂow and graph, where, AT
means Available Train, AF means Available Flight, BT means Book Train,
BF means Book Flight, AH means Available Hotel, BH means Book Hotel,
ARC means Available Rentals Car, RC means Rent Car, PT means Plan
Touristic map, CW means City Weather, SN start node and EN end node.
on elementary structures (sequence (sq), choice (ch), switch
(sw), split (sp), split-joint (sj)), from which many others
can be modeled. Consequently, CF is deﬁned as:
CF = {sq, ch, sw, sp, sj},
(4)
1) Composition Structures Illustration: A composition
may comprise several different structures, which can them-
selves contain combinations of structures. A tree represen-
tation helps understanding and visualizing the composition:
the leaves are service operations, the nodes and the root
are the compositions structures. A ﬂow representation cor-
responds to the reading of the composition tree by following
a depth-ﬁrst search.
Let us consider a composition answering the following
request: “I want to travel from City A to City B, reserve
several hotel rooms in destination city where each booking is
billed separately, rent a car for six people, have the weather
forecast and plan for the destination city”. The Figure 3
shows the composition tree, the corresponding composition
path and the composition graph.
2) Characteristics of Composition Structures : In the
following, we describe the different composition structures,
and we provide a syntax for them.
Sequence ”→”: This structure deﬁnes a total order be-
tween services. There are two ways to detect the order: (1)
checking the match between services IOPE (Input, output,
precondition and effect); (2) checking the dependency be-
tween the services answering the question: which service
cancels the other when it is canceled?
Choice ”+” (or-split): This structure represents a choice
between several services that have a same functionality.
Choice(A, B1, B2, · · · , Bk) ≡ (A −→ B1) ∨ (A −→
B2) ∨ · · · ∨ (A −→ Bk), knowing that service A precedes
all services {Bi} which have the same functionality.
If-then-else ”⊗c”: This structure is the classical condition
branching. It allows a conditional service execution or choice
of services input parameters values. This structure checks a
request condition, and controls a service if at least one of
its functional parameters corresponds to a request condition
predicate. The switch structure is based on If-then-else
structure, because it represents an imbrication of this latter.
In the following, switch and if-then-else terms are used as
synonyms.
Split ”⊢”: This structure indicates a simultaneous start
of multiple services (or services chains) that can be paral-
lelized. The parallelized services have the same predecessor
and provide different types of outputs. Each parallelized
service can start a new sub-path in the composition. All
services chains starting at a split will be executed in parallel
and ended with a split-joint. Split(A, B1, B2, · · · , Bk) ≡
(A −→ B1) ∧ (A −→ B2) ∧ · · · ∧ (A −→ Bk).
Split-joint ”⊣”: This structure ends a parallel structure,
where different composition paths belong to a same ”split”
and the last services {Bi}, in parallel chains, have the same
successor A. Split-Joint (B1, B2, · · · , Bk, A) ≡ (B1 −→
A) ∧ (B2 −→ A) ∧ · · · ∧ (Bk −→ A), where services {Bi}
end the parallel composition paths. It is possible that services
from a same split do not end with the same Split-joint.
Any-Order ”⊙”: This structure represents a random in-
vocation of services. It is not elementary because it means
the choice between all possible alternatives, i.e., it can be
expressed using choice and sequence structures: A ⊙ B ≡
(A −→ B) + (B −→ A). At execution time, such structure
can be replaced by a sequence or a parallel structure [37]. I
can be noticed that if the number of services involved in the
any-order structure is large, the replacement by a parallel
structure may be very costly, since it is a combinatorial
enumeration.
While ”⊕c” and until ”⊖c ”: These structures are used
for iterative service invocation, and they are not elementary
because they can be constructed with if-then-else and se-
quence structures: ⊕c(A) = ⊗c −→ A ∧ A −→ ⊗c and
⊖c(A) = A −→ ⊗c ∧ ⊗c −→ A.
The Table I summarizes the detection rules of composition

293
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Composition structure
Detection rule
Sequence (A, B)
M(OA, IB) ≤ ϵ ∨ (M(OA, OR[i]) ≤ ϵ ∧ M(IR[i + 1], IB) ≤ ϵ)
Choice (Bi, Bj)
M(OBi, OBj ) ≤ ϵ ∧ A → {Bi, Bj}
If-then-else (A)
dom(ai) = OA
Split (A, Bi, Bj)
M(OBi, OBj ) > ϵ ∧ A → {Bi, Bj}
Split-joint (Bi, Bj, A)
M(OBi, OBj ) ≤ ϵ ∧ {Bi, Bj} → A ∧ n.id(Bi) ≡ n.id(Bj)
Table I
DETECTION RULE OF ELEMENTARY COMPOSITION STRUCTURES,
where, I, O are respectively input,output; A,B are Web service; IR, OR are respectively the request input/output; ai is a predicate of request condition ;
n.id(Bi) denotes the split identiﬁcation, where service Bi belong, M the matching level and ϵ the matching threshold.
structures.
In our example in Figure 3, the AF and AT are structured
with “choice” structure, because their output classes match.
The AH service is controlled with “switch” structure because
the request condition “rent a car for six people” refers to
the car capacity. The latter is a property of the ARC output
class. So on for the other structures.
IV. SEMANTIC DESCRIPTION
The complex request resolution requires describing se-
mantically the Web services and the complex request. Se-
mantic web services provides knowledge to discover, com-
pose and invocate services. The semantic description of a
complex request provides knowledge needed to solve the
request.
A. Semantic Web Service
Semantic Web Services approaches add a semantic layer
to elements of Web services, ID, FP, NF, CS, NS (see
equation 2). This allows the automation of discovery, com-
position and invocation of Web services over the Web. Then,
the main question is: Which semantic layer is needed to
automate service discovery, composition and invocation?.
Existing works focus on speciﬁc elements of equation 2.
For example, the WSLA (Web Service Level Agreement)
project [38] adds a semantic layer on NF, addressing
service management issues and challenges in a Web services
environment on SLA speciﬁcation, creation and monitoring.
The WSDL-S [39] language adds a semantic layer to WSDL,
i.e., on ID, CS and FP. The METEOR-S (Managing
End-To-End Operations for Semantic Web Services) project
[40] presents a semantic annotation of WSDL, addressing
the issues related to workﬂow process management for
large-scale, complex workﬂow process applications in real-
world multi-enterprise heterogeneous computing environ-
ments. METEOR-S is based on approaches described in
[41], [18], to deﬁne an extensible ontology that describes
the properties of quality of service.
According to our point of view, services discovery can
be automated by adding a semantic layer to FP; services
composition can be automated by adding a semantic layer to
FP, CS and NS; and service invocation can be automated
by adding a semantic layer to ID and FP. OWL-S is
currently the most known and referred language for semantic
web services. It allows more ﬂexibility than METEOR-S by
relying on a domain ontology. The process view taken by
the latter not only induces some complexity in the reasoning,
but also is unnecessary for the needs of our research.
The Semantic Web Services language OWL-S provides
semantic layers namely for ID (service grounding), CS and
NS (service model). FP is modeled by the service proﬁle,
but the semantics of IO is left to the additional use of a
domain ontology, as well as the semantics of PE, which in
[10] is described with SWRL rules. NF description is also
left to the use of an additional QoS ontology.
In the following section, we present an ontology for de-
scribing complex requests and useable with OWL-S services
description.
B. The Complex Request Ontology: OWL-CR
The ontology for Complex Request we have designed is
illustrated in Figure 4. The root class of OWL-CR is the class
Request. Two main properties, namely hasFunctionality
and hasNFparameter, allow respectively to formalize the
different functionalities and non-functional parameters of a
request.
For each functionality, a Functionality Profile
is deﬁned, which can be Mandatory or Optional. The
optional proﬁle is not taken into account when its consider-
ation induces the non-respect of a constraint. Each element
of the request in formula 1 has a corresponding class in
the ontology. For a given request R, the IFRi , OFRi are
input or output classes of a service domain ontology (in
our case, the travel booking service ontology), the condition
D is described using the ruleml:Impl class of SWRL,
deﬁning a rule. This is formalized using respectively the
hasInput, hasOutput and hasCondition proper-
ties. The parameter type in Input and Output classes
allow specifying the URI of corresponding classes in a
service domain ontology modeling services characteristics
in a particular domain.
The non-functional parameters, constraints C and the
objectives B, are respectively instances of Constraint
and
Objective,
which
can
depend
on
the
non-
functional parameters of Service, Data or Answered
composition. The importance level of an objective λ

294
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 4.
Web service complex request ontology (OWL-CR)
is an instance of Importance Level, which can be a
Fixed level or Variable level. The objective has
an optimization direction: Min or Max, used to specify how
it has to be exploited.
The ontology OWL-CR contains different cardinalities
(0,1), (0, n), (1,1) and (1,n), where n ≥ 1. According to the
OWL language capability, it has been formalized in OWL
DL. OWL-CR is used as a language to describe complex
requests. Practically, this means that users inputs, through
a dedicated user interface, are used to construct a request
description formalized in OWL-CR.
For an ideal situation, functional and non-functional pa-
rameters of the request need to be expressed using the same
domain and QoS ontologies of the services to be queried.
The OWL-CR ontology we have designed for expressing
requests uses directly these ontologies. Moreover, it exploits
SWRL to formalize the conditions.
V. MODELS OF ANSWERS
The goal of this section is to present how the set of valid
compositions answering a request is modeled, according to
the request characteristics. The request functionality depen-
dencies have an impact on the adapted compositions models.
One can numerate three cases:
1) When no dependency is speciﬁed, the composition is
modeled as a sequence following a random order and
the set of compositions can be modeled as a graph.
2) In the case of one-to-one dependencies, the composi-
tion is modeled as a sequence following the speciﬁed
order of dependent functionalities and the set of com-
position can be modeled as a graph.
3) When the dependencies are global, a composition can
be modeled as a sequence and we cannot model the
set of valid compositions as a graph. We detail this
point in section VIII-B.
A. Graph of Compositions
When the request contains no dependency or one-to-one
dependencies, the compositions answering the request are
modeled as a graph. The composition graph G models the
set of possible connexion between services. The complete
paths starting from the ﬁrst node and ending at the last node
of the graph, are composition answering the request. G is
composed of several layers according to request functionali-
ties. Each layer contains a set of services answering the same
request functionality. The composition graph is formulated
as: G =< N, A >, where N is a set of nodes {nj} and A
is a set of arcs {ai}. An arc is deﬁned as ai =< b, e, w >,
where b is the depart node, e is the destination node and
w is a weight. Nodes ni correspond to service. G has two
special nodes representing the start, sn =< IFR1 >, where
IFR1 is the ﬁrst element of the request input; and the end of
all compositions en =< OFRl >, where l is the index of the
last functionality. The composition paths of G are deﬁned
by the following deﬁnitions.
Deﬁnition 4: Let Ω be the set of paths in a composition
graph answering a request R. We have:
∀x = (b → e) ∈ Ω : b = sn, e = en
Corollary 1: ∀x
∈
Ω, ∀c
∈
Cc ∪ Cd:
x
|=
ci, ∃I, M(IFRi , I) ≤ ϵ, ∃O, M(OFRj , O) ≤ ϵ, ∀IFRi
∈
IR, ∀OFRj ∈ OR.
Where |= is the satisfaction symbol, I/O is the in-
put/output of inner services of x, Cc, Cd are set of con-

295
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
straints referring respectively to composition and data, ϵ is
the matching threshold level and M(y, z) is the matching
level between y and z.
A composition path has both functional and non-
functional parameters. Functional parameters are affected to
the nodes (i.e., service I/O), and non-functional parameters
are affected to arcs. An arc weight is a vector containing
request objectives values vobji for the arc destination node.
Formally, let ai,j : (ni → nj) be an arc and wai,j its weight,
wai,j =

296
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
evaluation function of the ﬂow structure. Finally, the MSCG
transformation and the recalculation of arc weights allow
building a suitable set of answering composition (called
optimization search space), considering all the composition
structures.
2) Acyclic Composition Graph: The acyclic composition
graph (ACG) contains only sequences. Its nodes can be
deﬁned as nodes of MSCG, but to simplify the representation
of node, one single type of node will be used and it contains
variables for data URI (URIDA), informative service URI
(URIIS), and active service URI (URIAS).
n =< URIDA, URIIS, URIAS >
(6)
Where the service URIs, URIIS, URIAS, correspond
respectively to the OWL-S description of informative and
active services.
The arc weight values waj,j+1, are calculated by consid-
ering all values of DA, IS and AS:
vobji(nj+1) = vobji(DA) + vobji(IS) + vobji(AS).
The weight waj,j+1 values of an arc (aj,j+1 : nj → nj+1)
are the sum of the destination node nj+1 elements (DA, IS,
AS). These weights will be used in the optimization step, to
evaluate the composition.
VI. COMPOSITION DESIGN ALGORITHMS
The goal of composition design algorithms is to build
the composition graph answering the request, which will
be used as an optimization search space. As explained in
the previous section, when the composition design considers
only sequence structures, the graph is acyclic (ACG); when
all composition structures are taken into account, the graph
is a MSCG. When the request functionalities dependency
is global, the search space cannot be modeled as a graph.
It is then modeled as a set of clusters. A cluster regroups
the services matching a request functionality (FR[i]), and a
cluster is created for each request functionality. A request
functionality can require an informative service (IS), active
service (AS) or both. When an IS is used, it is executed.
For each data, it generates a node is created. This node
integrates the link (URI) of the informative service and the
corresponding active service if it is required, and then it is
affected to the corresponding cluster.
The proposed design composition algorithms, process
progressively the request to build the executable composition
graph. The process logic is based on the ﬂooding algorithm
and checks the composition structures. This checking is
based on the characteristics of composition structures (as
said in section III-C2). We present in the following two
algorithms: algorithm 1 considers only sequence structures,
and algorithm 2 considers all composition structure.
A. Composition Algorithms
We name the current layer, Lk, the set of nodes in
the composition graph having a same depth level, being
processed by the algorithm: Lk = {ni}. Initially Lk contains
the starting node sn of G, Lk = {sn}. One step of the
algorithm corresponds to the full coverage of Lk. The node
of Lk being processed during an iteration is named current
node (Lk[i]), where i is the node index. We denote T the
temporary buffer, L a layer of nodes, Lend the end layer,
Ld a layer of data, di a condition and ai a statement in a
condition.
Algorithm 1: ACG: Design composition algorithm (Re-
quest R)
1: Lk, Lk+1, LEnd ← φ;
2: Lk.add(sn(IFR1 ));
3: N.addAll(Lk); // Add all nodes of Lk;
4: i ← 0;
5: while i < |Lk| do
6:
Lk[i] : current node;
7:
sj ← SelectNextServices(Lk[i]); // Algorithm 3.
8:
for sj : NextService do
9:
AddArcSequence(Lk[i], sj);
10:
if sj /∈ N then
11:
if EndFunctionality[sj] then
12:
LEnd.add(sj);
13:
else
14:
Lk+2 ← RunInformativeService(sj); //
Algorithm 4.
15:
for DAk : Lk+2 do
16:
sj ← Concatenation(sj, DAk);
17:
Lk+1.add(sj);
18:
end for
19:
end if
20:
else
21:
Lk+1.add(sj);
22:
end if
23:
end for
24:
N.addAll(Lk+1); Lk ← Lk+1; Lk+1 ← φ;
25:
i++;
26: end while
27: Return ACG;
From a request, ﬁrst ﬁll in the current graph layer with
matching services and process it (line 2 for starting and line
24 during processing). For each node in the current layer,
select the next services according to their matching with
functionalities FRi (Algo. 1 or Algo. 2 - line 7, call Algo.
3). The set of nodes created from next services is put into the
next layer. When the current node output matches with one
of the FRi outputs, the algorithm carries on with next node in
the current layer. Otherwise, services having inputs matching
the current node output are selected. Corresponding nodes
are created after checking they do not already exist in the
set of nodes N of G.

297
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Algorithm 2: MSCG: Design Composition algorithm
(Request R)
1: Lk, Lk+1, T, LEnd ← φ;
2: Lk.add(sn(IFR1 ));
3: N.addAll(Lk);
4: i ← 0;
5: while i < |Lk| do
6:
Lk[i] : current node;
7:
sj ← SelectNextServices(Lk[i]);
8:
for sj : NextService do
9:
AddArcSequence(Lk[i], sj);
10:
if sj /∈ N then
11:
if EndFunctionality[sj] then
12:
LEnd.add(sj);
13:
else
14:
T.add(sj);
15:
if Lk[i] ∈ Split then
16:
GetInSplit(sj, Lk[i]);
17:
end if
18:
end if
19:
CheckSplitJoint(i, Lk, sj);
20:
Lk+2 ← RunInformativeService(sj,D);
21:
if |Lk+2| = 0 then
22:
SW ← CheckCondition(sj, D);
23:
if SW ̸= null then
24:
T.add(SW);
25:
end if
26:
else
27:
Lk+1.addAll(Lk+2);
28:
end if
29:
else
30:
CheckSplitJoint(0, Lk, sj);
31:
end if
32:
ChechSplit(Lk[i], T);
33:
Lk+1.addAll(T);
34:
T ← φ;
35:
end for
36:
N.addAll(Lk+1); Lk ← Lk+1; Lk+1 ← φ; Lk+1 ←
φ;
37:
i++;
38: end while
39: Return MSCG;
An arc-sequence is created between the current node and
each of the next nodes. When a selected service is an IS,
it is invoked to obtain the data it provides before creating
the arc (Algo. 1-line 14, Algo 2-line 20, call to Algo 5).
Once the data are obtained (ﬁlling the data layer Ld), the
algorithm creates an arc-sequence between the node of
the service and each one of the data nodes. The selected
service node is then replaced by the set of data nodes.
B. Sub-Branches Used in Composition Algorithms
Algorithm 3: SelectNextServices
(Service
si)
1: if M(Outputsi, OutputFRi ) > ϵ then
2:
if M(Inputsi, Inputsj) ≤ ϵ then
3:
sj selected;
4:
if M(OutputFRi+1 , Outputsj) ≤ ϵ ∧ |IR| = i + 1
then
5:
EndFunctionality[sj] ← true;
6:
end if
7:
end if
8: else
9:
if M(InputFRi+1 , Inputsj) ≤ ϵ then
10:
sj selected;
11:
if M(OutputFRi+1 , Outputsj) ≤ ϵ ∧ |IR| = i + 1
then
12:
EndFunctionality[sj] ← true;
13:
end if
14:
end if
15: end if
16: Return selected sj;
When a next node has been newly created, i.e., the service
corresponding to the node, is not selected already (Algo. 2,
Algo. 5, Line 10), the algorithm checks the existence of
a condition. This is the case if the output of the service
represented by the node corresponds to one of the request
conditions, or if the class of data represented by the node
contains predicates used in a condition (Algo. 6). In this
case, we create a SW-node and link it to the node by an arc-
sequence. The node following the SW-node is then selected
according to the ﬁrst node output.
Algorithm 4: Run
informative
service
(Service
s)
1: Ld ← φ;
2: if s: informative Service then
3:
Ldata ← Runs(s);
4: end if
5: for i = 1, |Ldata| do
6:
AddArcSequence(s, Ldata[i]);
7: end for
8: Return Ldata;
Algorithm 5: Run informative service (Service s, Condi-
tion D)
1: Ld ← φ;
2: if s: informative Service then
3:
Ldata ← Runs(s);
4: end if
5: SW ← CheckConditionData(Ldata[0], D);
6: Ldata.add(SW);
7: for i = 1, |Ldata| do
8:
AddArcSequence(s, Ldata[i]);
9:
if SW ̸= null then
10:
AddArcSequence(Ldata[i], SW);

298
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
11:
end if
12: end for
13: Return Ldata;
Algorithm 6: CheckCondition (Node n, Condition D )
1: for i = 1, |L| do
2:
if (n is service) then
3:
if (a1∨a2∨. . . ∨) ∈ class(Outputs)∨QoSs then
4:
SW ← CreatSwitchNode(di);
5:
AddArcSequence(L[i], SW);
6:
end if
7:
else
8:
if (a1 ∨ a2 ∨ . . . ∨) ∈ DataClass(n) then
9:
SW ← CreatSwitchNode(di);
10:
end if
11:
end if
12:
T ← T S SW;
13:
if (d1 ∨ d2 ∨ . . . ∨ dn) ∈ class(Inputs) then
14:
AddArcSequence(SW, s);
15:
end if
16: end for
17: Return SW;
When all Fri have been covered, the next node is affected
to the end layer (Algo. 2, Line 12). Otherwise, it is put into
the next layer for (Algo. 1, Line 21), and for Algo. 2, it
is put into temporary buffer, and later into the next layer
(Line 33), after checking the split structure. The checking
of split-structures is performed when the temporary buffer
is full, containing all nodes matching the current node. The
checking of split-joint-structure is performed when the next
node is selected. Hence, the algorithm checks split-joint
structure before the split structure. The process checks the
existence of a split-joint structure starting from next node
(Algo. 7). If it is selected from N of G, it is possible to
ﬁnd a node which can precede the next node. In this case, a
complete check is performed (Algo. 2, Line 30), otherwise
only a partial check is necessary (Algo. 2, Line 19). The
complete check considers all nodes of the current layer.
The partial check considers a current node and current layer
nodes which have not been yet processed.
Algorithm 7: CheckSplitJoint (SerciceIndex i, NextLayer
Lk+1, Service s)
1: IsSplitJoint ← false;
2: if M(Inputs, OutputL[i]) ≤ ϵ ∧ L[i] ∈ Split then
3:
for m = i + 1, |L| do
4:
if
M(Inputs, OutputL[m])
≤
ϵ
∧
SameSplit(L[m], L[i]) then
5:
IsSplitJoint ← true;
6:
AddArcSplitJoint(L[i], L[m], s);
7:
GetOutSplit(L[m]);
8:
end if
9:
if (M(Inputs, OutputL[m]) > ϵ ∧ L[m] ∈ Split
then
10:
if SameSplit(L[m], L[i]) then
11:
GetInSplit(s, L[i]);
12:
end if
13:
end if
14:
end for
15:
if IsSplitJoint then
16:
GetOutSplit(L[i]);
17:
end if
18: end if
The algorithm 7 creates a split-joint-arc when it detects
nodes, L[i], L[m], having the same succeeding node (s:
ends the parallel structure), and they have the same split-
structure. After creation of split-joint-arc (Algo. 7, Line 6),
the nodes leave the split structure (Algo. 7, line 7, line 16).
The concatenation of parallel structures is possible, when
paths of a same split-structure do not meet in a same split-
joint structure. The node ending split s is then included in
the parallel structure split (Algo. 7, line 11).
Algorithm 8: CheckSplit (Service s, Temporary buffer T)
1: for i = 1, |T| − 1 do
2:
for j = i + 1, |T| do
3:
if (M(OutT [i], OutT [j]) > ϵ) then
4:
AddArcSplit(s, T[i], T[j]);
5:
GetIntoSameSplit(T[i], T[j]);
6:
end if
7:
end for
8: end for
The checking for the existence of a split structure (Algo.
8) is performed between the current node and the nodes
in the temporary buffer T[j]. If these nodes have different
functionalities (i.e., different output), we create a split-arc
and add them in the same split structure (Algo. 8, line 5).
Then all following nodes are affected to this split structures
(Alg. 2, line 15-16). When all nodes of the current layer are
processed, the next layer becomes the current layer and so
on until the next layer is empty. The algorithm terminates
when this state is reached.
C. Algorithm Complexity
An algorithm complexity can be evaluated from two
aspects. Time complexity measures the processing time,
while Memory complexity measures the manipulated data
size.
1) Time Complexity: In the algorithm 2, each request
functionality (FR[i]) implies at least one iteration of the
algorithm. This leads to a total of at least card(FR) it-
erations. An iteration involves ¯L (¯L is the average services
layers size) discovered services, and for each discovered ser-
vice there are card(D) veriﬁcations of condition, card(Cs)
veriﬁcations of service constraint , and O(split − joint)
veriﬁcations of split-joint if the discovered service belongs
to a split structure. For each iteration, the algorithm checks

299
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
O(split) times the split structure. Discovered informative
services are executed and all their provided data veriﬁed.
The algorithm has then a complexity order of card(FR)×
¯L×card(D)×card(Cs)×O(split)×O(split−joint). Con-
dition and constraint checking have a constant complexity,
but the split
checking process has a complexity of vector sort, in the
worst case O(split) = ¯L × log(¯L). The split-joint checking
process has a complexity order ¯L. In conclusion, in the worst
case, the algorithm complexity equals O(card(FR) × ¯L ×
(¯L2 ×log(¯L))×card(D)×card(Cs)). Since the discovered
service ¯L, are important, then the complexity algorithm is
cubic and has an order ¯L3.
The complexity of algorithm 1 equals O(card(FR) ×
card(Cs) × ¯L).
This
complexity
is
linear
because
card(FR) × card(Cs) is constant.
To conclude, our algorithms have a cubic complexity
(Algo. 2) or linear complexity (Algo. 1). The most inﬂuential
element is the number of discovered services. Therefore, the
more services answering the request functionality, the more
important is the resolution time. The number and severity
of constraints put on services and data in the request will
reduce the number of services. However too much or strict
constraints can lead to empty layers in the composition
graph.
2) Memory Complexity: It is important to reduce the
memory used by the composition graph. Generally, we can
store the graph nodes and their arcs, but we cannot save
all paths of the graph, because the memory complexity is
exponential (¯Ll), where ¯L is the average layer size and
l = card(FR) is the layer number.
Concerning ACG, the nodes size is: O(card(N)) = r +
(l × (2 × ¯L)) + 2 ≈ l¯L, where r = card(D) is the condition
number. We multiply ¯L by 2, because each functionality
can require both informative and active services, and (+2)
corresponds to the start and the end node (sn, en). The arcs
size is: O(card(A)) = l × (¯L2 + ¯L × r) ≈ l × ¯L2,
Concerning MSCG, in the worst case, the nodes size is:
O(card(N)) = l × r × (¯L + ¯L) + 2 = 2lr¯L. The arcs
size is: O(card(A)) = l × (r × ¯L2) + r × (¯L + ¯L) = l ×
r × ¯L2 + 2 × l × r × ¯L, which can be approximated by:
O(card(A)) ≈ l×r×L2. However, the memory complexity
of a transformed MSCG is the same as for ACG.
VII. EXPERIMENTATION
The experiments we have conducted focus on three points:
complex request description and services composition au-
tomatic design. For the request description, we give some
example requests in natural language, and then describe
manually their functionalities, conditions, constraints and
objectives. For the automatic composition, we check its
correctness by assessing the suitability of composition struc-
tures regarding the request and available services. The sec-
ond point is the processing time of the composition design
algorithm. Based on its complexity, the size of matching
services has an important impact for the processing time.
A. Implementation and Hypotheses
The used Web services are described semantically, using
the OWL-S Language. For that purpose, we implemented
a program generating OWL-S descriptions of services. This
program relies on the Jdom API [42]. The type of service
(input and output) is deﬁned by referring to a domain
ontology of travel booking The values of QoS parameters
are randomly generated: price and reputation of service are
considered.
We used different APIs at the different levels of the
resolution process. (1) Jena [43], and SPARQL [44] are used
to check the data constraints (Cd) and conditions (D). (2)
The OWL-S API [45] is used to read the OWL-S service
description and also to check services constraints (Cs). (3)
Pellet [46] is used to check the matching level between I/O
of services and the request, through the OWLS-MX API.
Our experiments have been conducted with the following
set of hypotheses:
(1) Web services are formally described with OWL-S. We
do not consider mapping with other Web services semantic
description language.
(2) A QoS ontology is used within the OWL-S services
descriptions, in order to describe the non-functional param-
eters such as price and reputation.
(3) A speciﬁc service domain ontology linked to a domain
ontology is used to describe service I/O. In our experimen-
tation cases, we have used the Travel Booking ontology
which is associated to the MobileTTE Tourism ontology
[47]. Request and services use this same ontology.
(4) We do not consider the necessary mapping of services
described with different domain ontologies: all the services
are described using a same travel booking ontology.
(5) As a consequence of (4), the matching process pro-
vides binary responses, even if the OWLS-MX API [12] that
we use implements a full matchmaking process. Moreover
only inputs and outputs parameters are exploited in the
matchmaking.
Finally, the computing environment used to implement
and test the application is a Core2 Duo CPU based machine
(1.58 GHz) with 2.89 GB of RAM.
B. Complex Request Description
The tourism domain has been chosen as use case, because
it offers a rich set of services. Moreover, the planning of a
tourism trip is a classical example of service composition
problem that anyone can face today. We consider the fol-
lowing request: “We want to travel from City A to City B,
to reserve several individual hotel rooms in destination city
where each booking is billed separately, rent a car for six
people and if a car does not allow six people, then rent two
cars. I want to know the weather forecast and get a map

300
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
of the destination city. Additionally, choose a museum visit
or city monument visit according to the weather. The whole
at best price and reputation, and the price must not exceed
3000 Euro”.
This request has four functionalities: transport, hotel,
car renting, city information. Each request functionality
is characterized with the input and output class. Theses
classes are detailed in Table III.Note that the city information
functionality can be answered with different services such
as, city weather, city map, and city museum service. These
services can be executed in parallel because they have the
same input type and provides different output types (as
detailed in Table I).
This request contains three conditions, D = {d1, d2, d3}
:
(1) A condition referring to the hotel billing (d1): “each
booking is billed separately”. This condition is written as,
d1 : if (a1 < a2) ⇒ c1 = false, where a1 is the reserved
rooms number, a2 is the billed reservations and c1 is the
achieved payment.
(2) A condition referring to the weather state (d2): “choose
the museum visit or city monument according to the
weather”. This condition is written as, d2 : if (a3 =
good) ⇒ c2 = c3. Where a3 is the weather condition, c2 is
cultural activity and c3 is monument visit.
(3) A condition referring to the rental car type (d3): “when
a car does not allow six people, then rent two cars”. This
condition is written as, d3 : if (a4 < 6) ⇒ c4 = 2. Where
a4 is the car capacity and c4 is the number of cars.
The request predicates a1, a2, a3, a4, c1, c2, c3, c4, corre-
spond to properties in the domain ontology. a1 and a2
are properties of the “BookedHotelInput” class. a1 is
the data property “numberOfrooms”, a2 is the object
property “paymentBookHotel”. a3 is a property of the
“WeatherOutput” class, and corresponds to the data
property “weather-condition”. a4 corresponds to the
data property “carCapacity”, and it is a property ofthe
“CarInfo” class, and so one.
The request contains two objectives, price and rep-
utation, and one constraint, the price. The price and
reputation are described in the QoS ontology. Formally
the request elements are: IR = {I1, I2, I3, I4}, OR =
{O1, O2, O3, O4}, D = {d1, d2, d3}, C = {Cd, Cs, Cc},
Cd = φ, Cs = φ, Cc = {price}, B = {Bd, Bs, Bc},
Bc = {price, reputation}.
Table IV details some experimented requests. The initial
request, described at the beginning of this section can be
formalized with R2 or R4, where the request functionalities
order is different. The request R1 is less complex and
corresponds to: “I want to travel from City A to City B,
reserve an hotel room in destination city and rent a car. The
whole at best price and reputation, and the price does not
exceed 3000 Euro”.
The request R3 corresponds to request R1 by adding the
requirements: “(1) reserve several hotel rooms and each
booking is billed separately; (2) rent a car for six people
and when a car does not allow six people, then rent two
cars; (3) know the weather forecast and get a map for the
destination city”.
We choose these speciﬁc requests, in order to evaluate
the correctness of the automatic composition, by analyzing
the different compositions designed by the algorithm. The
requests R1, · · · , R4 are described semantically with the
OWL-CR ontology.
In the following section, we present our experiments and
the obtained results. The experiments rely on different use
cases, each use-case corresponding to a speciﬁc request.
C. Automatic Composition Results
Algorithm, 1 and 2 have been used to answer the request.
In our tests, the matching threshold has ﬁxed to 1, and the
similarity threshold to 0.
The composition design algorithms search the available
services in a UDDI, in order to design answer(s) for a
given request. This UDDI contained references of services
covering in particular the functionalities of the request: hotel,
transport, rent a car and city information.
In order to evaluate the algorithm performances, we
present and discuss two types of experiments. The ﬁrst one
concerns the correctness of composition. The second one
concerns the composition performances in terms of response
time.
1) Composition Correctness: The assessment of the com-
position correctness consists in verifying that the designed
composition answers all request functionalities and detects
correctly the composition structures whatever their numbers
and the number of different ones.
Figures 5 and 6 illustrate a composition graph answering
the request R1, where the rectangle presents the informative
service, a circle presents an active service (the same meaning
for the following Figures), and the graph contains only
the choice and sequence structures. The graph on Figure 5
contains 10 answering services by layer. For better visibility,
the graph on Figure 6 contains only 2 answering composition
by layers.
Observing
the
graph,
it
can
be
seen
that,
the
transport
request
is
answered
either
by
an
atomic
service,
Booktransport,
or
a
composite
service
{Availabletransport → BookFlight}. This illustrates
that, for each request functionality, the algorithm can ﬁnd
one single matching service or builds sub-composition.
The Figure 7 illustrates the composition graph resulting
from the processing of request R2, which requires multiple
composition structures: sequence, while, choice, switch, split
and split-joint. The graph illustrates clearly the composition
structures and for more visibility, each layer is limited to two
services. We recall that arcs →, ⊢, ⊣ illustrate respectively:
sequence, split, and split-joint. The structure switch “sw2”

301
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Class
Properties
I1 : InTransportClass
departCity, destinationCity, travelDate
I2 : InHotelClass
roomNumber, arrivedDate, departDate
I3 : InRentCarClass
dateTime4Take, dateTime4Make, InRentCarClass
I4 : InCityInformation
cityName, Date
O1 : OutTransportClass
flightOrTrainNumber , reservationNumber, placeNumber
O2 : OutHotelClass
reservationNumber
O3 : OutRentCarClass
reservationNumber
O4 : OutCityInformation
Map, weather, Heritage, Museum
Table III
INPUT AND OUTPUT CLASSES
Request
Formalization
R1
< {I1, I2, I3}, {O1, O2, O3}, D = φ, C = {price}, B = {price, reputation}, λ = φ >
R2
< {I1, I2, I3, I4}, {O1, O2, O3, O4}, {d1, d2, d3}, {price}, {price, reputation}, φ >
R3
< {I2, I1, I3, I4}, {O2, O1, O3, O4}, {d1, d3}, {price}, {price, reputation}, φ >
R4
< {I2, I1, I4, I3}, {O2, O1, O4, O3}, {d1, d2, d3}, {price}, {price, reputation}, φ >
Table IV
EXPEREMENTED REQUEST
Figure 5.
Executable service composition graph for R1 (10 services)
Figure 6.
Executable service composition graph for R1 (2 services)

302
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
checks the city weather and it belongs to the parallel
structure (between split and split-joint), this shows that the
automatic composition algorithm can provide an imbrication
of composition structures.
Figure 7.
Executable service composition graphs for R2
The graph composition structures, illustrated Table V, are
coherent with structure characteristics deﬁned in Table I. For
example, AF and AT are structured with a “choice” structure
because their output classes match. AT and BF are structured
with a “sequence” because the output of AT matches with
the input of BF. BH is structured with a “while” because
“each booking is billed separately”; the condition checking
is before and after BH. A “switch” structure sw1 follows
ARC service because the request condition “rent a car for
six people” refers to the car capacity predicate and it belong
to the output of ARC. RC is followed by structure a “split”,
opening parallelism, because the following services CW
and CM have different functionalities. CB and CHM are
followed by a “split-joint”, ending parallelism, because they
are included in the same split structure and are followed by
the same node “end”. The same holds for the other structures
(Figure 8 and Figure 9).
In the built composition graphs, we have tested if the
composition structures can be detected correctly. After this
Composition structure
participating services
Choice
(AH0,AH1), (BF0, BF1), (AH0, AH1), etc
Sequence
(AT0, BF0),(AT0, BF1),(BF0, AH0), etc
While
BH0, BH1
Switch
sw0, sw1, sw2
Split
RC0, RC1
Split-joint
end
Table V
STRUCTURES IN THE COMPUTED COMPOSITIONS,
where, AT denotes Available Transport, AF denotes Available Flight, BT
denotes Book Train, BF denotes Book Flight, AH denotes Available
Hotel, BH denotes Book Hotel, ARC denotes Available Rentals Car, RC
denotes Rent Car , CB denotes City Bus, CW denotes City Weather, CM
denotes City Map, and CHM denotes City Heritage Museum.
veriﬁcation, we test the limit of this detection, such as, (1)
test if the services following split structure can proceed, at
the same time, the split-joint structure. (2) test if a parallel
structure, split and split-joint can be in the middle of a
composition path.
The Figure 8 and Figure 9 illustrate the composition
graph resulting from the processing of request R3, and R4
respectively. The view is limited to two services by layers
for sake of readability.
The graph on Figure 8 illustrates the services following a
split and preceding a split-joint in the same time. In this test
we have removed from the UDDI registry, the following
services: ‘‘City Heritage Museum’’ and ‘‘City
bus’’.
The graph on Figure 9 illustrates the possibility that the
split and split-joint can be detected in the middle of the
composition. The parallel structure follows BookFlight,
and precedes AvailabeRantelsCar.
2) Performance Experiment: As said in section VI-C1,
the complexity of composition algorithms depend strongly
on the answering services number (the width of its layers).
We have conducted experiments to evaluate this inﬂuence.
Considering the composition graph answering the request
having four request functionalities (R2), the Table VI sum-
marizes the layer size impact on the composition design
response time. Where card(N), card(A) are respectively
nodes and arcs size of the composition graph, ¯L is the
average layer size. We recall from the analysis made in
section VI-C2, that card(N) ≈ 2lr¯L and card(A) ≈ lr¯L2,
where r is the number of conditions of the request and l the
number of layer. The Figure 10 illustrates the evolution of
the execution time with respect to the average layer size.
If we consider that averagely each functionality can have
about 15 answering services, the request processing requires
600 seconds (about 10 minutes) to return the MSCG
and about 3 minutes to return ACG. As shown in Table
VI and VII, the algorithm processing time depends on the
number of answering services (¯L) can be limited thanks to
request constraints. We note that the larger the number of
request constraints (services Cs and data Cd), the smaller

303
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 8.
Executable service composition graph for R3
¯L
card(N)
card(A)
time (second)
2
24
42
25
4
45
124
57
6
65
246
89
8
85
408
108
10
105
610
194
12
125
852
333
14
145
1134
484
16
165
1456
740
18
185
1818
1098
20
205
2220
1641
Table VI
DISCOVERED SERVICES INFLUENCE ON RUNTIME WITH MSCG.
¯L
card(N)
card(A)
time (second)
2
16
32
28
4
30
120
49
6
44
264
73
8
58
464
94
10
72
720
119
12
86
1032
143
14
100
1400
171
16
114
1824
194
18
128
2304
220
20
142
2840
248
Table VII
DISCOVERED SERVICES INFLUENCE ON RUNTIME WITH ACG.
Figure 9.
Executable service composition graph for R4
Figure 10.
Dependence between average layer size and execution time.
the number of answering services and then the smaller the
processing time.
VIII. SPECIFIC CASES
The complex request resolution method changes accord-
ing to the characteristics of composition graph, request
dependencies type and dynamic events. In this section, we
discuss these speciﬁc cases.

304
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
A. One Step and Multi Steps Resolution
The composition graph can be a layered digraph (order
pair of sets, as illustrated in Figure 3) in which the nodes of
too consecutive layers are all connected together, (i.e., there
exists an arc au,v between each node u and v of consecutive
graph layers, lk and lk+1). This case is formalized by the
following condition:
∀i ∈ {1 · · · k}, ∀u ∈ li, ∀v ∈ li+1 : au,v ∈ A.
(7)
At design time, the selection of compositions answering
a request may or may not require an optimization method,
depending on the composition graph structure and the num-
ber of objectives in the request. Considering the request
functionalities have no global dependency, the composition
does not require an optimization method when: (a) the
graph layers respect the condition 7 and there is only a
request objective (card(B) = 1); or (b) the objectives
can be combined because their importance levels λ are
ﬁxed (λi = x, x ∈ [0, 1]), thus allowing to order them.
Optimization is not required when condition 7 is veriﬁed
and the following condition is veriﬁed:
(card(B) = 1) ∨ (card(B) > 1 ∧ λ ̸= φ ∧ λi = x)
(8)
In this case, the request functionalities can be treated sep-
arately, for each request functionality, and several matching
services can be found. The more suitable one is selected
according to the request objectives and constraints, and then
executed. In other words, if this condition is veriﬁed, the
steps: (2) service discovery, (3) composition design, (4)
optimization of compositions, (5) execution of compositions,
(illustrated in Figure 1) can be merged in one step.
In any other case, an optimization method is required
to select the best composition. Therefore, we distinguish
two types of request processing: one step resolution (no
optimization) and multi-steps resolution (with optimization),
as illustrated in ﬁgure 11.
The automatic composition is also adapted consequently:
composition with selection for one step resolution, and
composition without selection for multi-steps resolution. The
compositions selection without optimization method means
that this selection is done during the composition (left-
hand side of Figure 12). When the composition selection is
done with an optimization method, the composition design
provides the set of composed services (right-hand side of
Figure 12), in order to use it as an optimization search space.
The composition design steps are ﬁnally the following,
the required steps depending on the need for optimization:
(0) Formalize user request with OWL-CR. (1) Read the
request functionalities. Then for each functionality: (2) Find
the corresponding services using the discover process,
which uses the matchmaker process for computing a match-
ing level between request input/output and existing services.
The discovered services and data are then ﬁltered, according
to the service constraints (cs) and data constraints (cd).
(3) The Composition design takes into account the
possible composition structures by considering the request
conditions D.
(4) Select the best service according to the request objec-
tive(s) B.
(4A) and (5A): Go to the next functionality, if the
discovered (4A)/selected (5A) service fulﬁlls the current
functionality.
(4B) and (5B): consider again the same treated function-
ality, if the discovered (4B) or selected (5B) service does
not fulﬁll the functionality. In this case, we consider the
discovered or selected service output as a next request input.
B. Global Dependencies and Compositions Model
The existence of global dependencies generates some
complexity in composition modeling. This is because the
compositions graph will be designed with multiple layers
of matching services and only subsequent layers can have
relation arcs between them. Indeed, the checking at each
node of the arcs history requires to maintain a list of all
preceding paths to consider the relations with the following
layers, which is a task having an exponential complexity
[48]. The memory complexity for a node in the graph can
be ¯Ll, where ¯L is the average number of layers and l is
the number of layer. Let ni, ni+1 be nodes; to check the
existence of an arc aj : ni → ni+1, we may require to
check conditions related to nodes [n1 · · · ni−1].
We can neglect the path history by modeling the set of
compositions as a graph, but without any guaranty regarding
the validity of the composition. To be able to considering
valid compositions only, we model the compositions as
a set of clusters, each cluster corresponds to a set of
services answering a request functionality. Then the validity
of the compositions is checked during the initial step of the
optimization.
C. Dynamic Events Processing
As said in section I-A, the steps (3-5: composition,
optimization, execution) can be concerned by dynamical
events, because on the one hand, random events can lead to
service breakdown, affecting quality of service, and on the
other hand because new services can appear. This impacts
the composition design, the composition optimization and
the composition execution.
During the composition design, perturbations can be ne-
glected, because the composition design takes few time, and
considers available services only.
During composition optimization, a speciﬁc mechanism
has to be taken into account.

305
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 11.
Solving request steps
Figure 12.
Automatic composition ﬂow
During composition execution, the events are consid-
ered within the composition representation. When this one
does not provide an alternative solution, we create a sub-
composition corresponding to a new request and then select
the best sub-composition with or without optimization. The
new created request considers only the functionalities, that
have not been fulﬁlled. We consider a functionality is
completely achieved only when the corresponding active
service is executed. Let i be an index of the last completed
functionality, the new request is formalized as:
R =< F[i+1,...], D, C, B, λ >
(9)
Then we reuse an automatic composition algorithm (see
section VI). In order to reduce the time of resolution, we
suggest using algorithm 1 instead of algorithm 2, because it
has lower resolution complexity.
To estimate the possibility of reparation, without recre-
ating sub-composition that already exit in the graph, we
calculate the k−connectivity of the composition graph.
The k−connectivity of a composition graph evaluates
how many nodes can breakdown with assuring that the
graph has the compositions alternatives. For example, if
k=3, then for each depart-destination node, maximally two
nodes can be deleted for assuring the possibility of ﬁnding
an alternative path (k − 1: maximal number of nodes,
whose can be deleted). For a fully connected composition
graph, k corresponds to a minimal size of existing layers,
k = min(card(L)).
IX. CONCLUSION AND FUTURE WORK
This paper proposes a groundwork for solving complex
Web requests with Web services composition considering
the request processing steps. The set of compositions are
modeled according to the request characteristics ( request
objectives and constraints). When there exist global depen-
dencies, the set of possible compositions can not be modeled
as a graph. In this case, compositions are modeled as a set of
clusters. When the request dependency is not global, the set
of compositions is modeled as a directed graph. The latter
can be built with the algorithms we proposed.
Our algorithms answer a request, and in order to deﬁne
answering compositions, exploit existing Web services and
a semantic description of both request and services. If the
request objectives or constraints have different evaluation
function for different composition structures, then the com-
position algorithm 2 can be used. Otherwise, algorithm 1
is used. The composition graphs built by the algorithms,
MSCG or ACG, can be used as a search space for the
optimization process. In addition, if one of the composed
services breaks down, the proposed algorithms support the
repairing of the original composition.
We cited conditions allowing to choose automatically the
suitable composition algorithm, suitable model of composi-
tions and suitable resolution steps.
Experiments show the correctness of obtained composi-
tions, concerning all composition structures, and the runtime
performance. When only sequence structures are considered,
the runtime complexity is linear with the average Web
services. When all composition structures are considered,

306
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
the runtime complexity is cubic.
In the future work, we look: (1) to consider better the
personalized knowledge of user, [49], [50] consider the com-
position answering a request as a personalized composition.
According to our point of view, the answering composition
is personalized when it answers a request by considering its
conditions D. The personalization can be widen, by consid-
ering the user proﬁle for example. (2) To deﬁne the process
allowing the transformation, from MSCA, ACG or clusters
set to OWL-S or BPEL4WS description. This transformation
does not consider the data (input values if services) and
concerns only the non-personalized composition, in order to
add them to the services base.
ACKNOWLEDGMENT
This work has been performed under the PhD grant TR-
PhD-BFR07 funded by the Luxembourg National Research
Fund (FNR).
REFERENCES
[1] C. H. Marcussen, “Trends in European Internet Distribution -
of Travel and Tourism Services,” Tech. Rep., 2009. [Online].
Available: http://www.crt.dk/uk/staff/chm/trends.htm
[2] B. Batouche, Y. Naudet, and F. Guinand, “Algorithm to solve
web service complex request using automatic composition of
semantic web service,” in COGNITIVE, 2010, pp. 84 – 89.
[3] J. Rao and X. Su, “A survey of automated web service
composition methods,” in Proceedings of the First Interna-
tional Workshop on Semantic Web Services and Web Process
Composition, SWSWPC 2004, 2004, pp. 43–54.
[4] D. B. CLARO, “ SPOC - Un canevas pour la composition
automatique de services web ddis
la ralisation de devis,”
Ph.D. dissertation, Universit d’angers, october 2006.
[5] B.
Jeong,
H.
Cho,
and
C.
Lee,
“On
the
functional
quality
of
service
(fqos)
to
discover
and
compose
interoperable web services,” Expert Syst. Appl., vol. 36,
pp.
5411–5418,
April
2009.
[Online].
Available:
http://portal.acm.org/citation.cfm?id=1497653.1498400
[6] Z. Li, L. O’Brien, J. Keung, and X. Xu, “Effort-oriented
classiﬁcation
matrix
of
web
service
composition,”
in
Proceedings of the 2010 Fifth International Conference
on
Internet
and
Web
Applications
and
Services,
ser.
ICIW
’10.
Washington,
DC,
USA:
IEEE
Computer
Society,
2010,
pp.
357–362.
[Online].
Available:
http://dx.doi.org/10.1109/ICIW.2010.59
[7] D.
Martin,
M.
Burstein,
D.
Mcdermott,
S.
Mcilraith,
M. Paolucci, K. Sycara, D. L. Mcguinness, E. Sirin,
and
N.
Srinivasan,
“Bringing
semantics
to
web
services
with
owl-s,”
World
Wide
Web,
vol.
10,
pp.
243–277,
September
2007.
[Online].
Available:
http://dl.acm.org/citation.cfm?id=1285732.1285745
[8] C. REY, “D 2 CP et computeBCov: Un prototype et
un algorithme pour la d´ecouverte de services web dans
le contexte du web s´emantique,” Ing´enierie des syst`emes
d’information(2001), vol. 8, no. 4, pp. 83–112, 2003.
[9] M. Klusch, B. Fries, and K. Sycara, “Automated semantic
web service discovery with owls-mx,” in AAMAS ’06:
Proceedings of the ﬁfth international joint conference on
Autonomous agents and multiagent systems.
New York, NY,
USA: ACM Press, 2006, pp. 915–922. [Online]. Available:
http://dx.doi.org/10.1145/1160633.1160796
[10] U. Rerrer-Brusch, “Service Matching with Contextualised
Ontologies,” Ph.D. dissertation, University of Paderborn, oc-
tober 2006.
[11] D. Martin, M. Burstein, E. Hobbs, O. Lassila, D. Mcdermott,
S. Mcilraith, S. Narayanan, B. Parsia, T. Payne, E. Sirin,
N. Srinivasan, and K. Sycara, “OWL-S: Semantic Markup
for
Web
Services,”
Nov.
2004.
[Online].
Available:
http://www.w3.org/Submission/OWL-S/
[12] M. Klusch, B. Fries, and M. Khalid, “Owls-mx: Hybrid owl-s
service matchmaking,” in Proceedings of 1st Intl. AAAI Fall
Symposium on Agents and the Semantic Web, 2005.
[13] S. Narayanan and S. A. McIlraith, “Simulation, veriﬁcation
and automated composition of web services,” in WWW, 2002,
pp. 77–88.
[14] R. Hull and J. Su, “Tools for composite web services: a short
overview,” ACM SIGMOD Record, vol. 34, no. 2, pp. 86–95,
2005.
[15] A. Brogi and S. Corﬁni, “Behaviour-aware discovery of web
service compositions,” International journal of Web services
research, Tech. Rep., 2006.
[16] P. Xiong, Y. Fan, and M. Zhou, “Qos-aware web service
conﬁguration,” IEEE Transactions on Systems Man and Cy-
bernetics Part A Systems and Humans, vol. 38, no. 4, pp.
888–895, 2008.
[17] X.
Tang,
C.
Jiang,
and
M.
Zhou,
“Automatic
web
service
composition
based
on
horn
clauses
and
petri
nets,”
Expert
Syst.
Appl.,
vol.
38,
pp.
13 024–13 031,
September
2011.
[Online].
Available:
http://dx.doi.org/10.1016/j.eswa.2011.04.102
[18] L. Zeng, B. Benatallah, M. Dumas, J. Kalagnanam, and
Q. Sheng, “Quality driven web services composition,” Pro-
ceedings of the 12th international conference on World Wide
Web, pp. 411–421, 2003.
[19] X. X. Yifei Wang, Hongbing Wang, “Web Services Selection
and Composition based on the Routing Algorithm,” 10th
IEEE International Enterprise Distributed Object Computing
Conference Workshops, pp. 57–66, 2006.
[20] J. Cardoso and A. Sheth, “Semantic e-workﬂow composition,”
Journal of Intelligent Information Systems, vol. 21, pp. 191–
225, 2003.
[21] H. Levesque, F. Pirri, and R. Reiter, “Foundations for the
situation calculus,” pp. 159–178, 1998.
[22] J. T. E. Timm, “Specifying semantic web service composi-
tions using uml and ocl,” in In 5th International Conference
on Web Services.
IEEE press, 2007.

307
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[23] R. Kazhamiakin and M. Pistore, “A parametric communica-
tion model for the veriﬁcation of bpel4ws compositions,” in In
Mario Bravetti, Lela Kloul, and Gianluigi Zavattaro, editors,
EPEW/WS-FM, volume 3670 of Lecture Notes in Computer
Science.
Springer, 2005, pp. 318–332.
[24] D. Pellier and H. Fiorino, “Un modle de composition automa-
tique et distribue de services web par planiﬁcation,” in Revue
d’Intelligence Artiﬁcielle, volume 23, no. 1, 2009, pp. 13–46.
[25] S. R. Ponnekanti and A. Fox, “Sword: A developer toolkit
for web service composition,” in Proceedings of the 11th
International WWW Conference (WWW2002), Honolulu, HI,
USA, 2002.
[26] S.-C. Oh, B.-W. On, E. J. Larson, and D. Lee, “Bf*: Web ser-
vices discovery and composition as graph search problem,” e-
Technology, e-Commerce, and e-Services, IEEE International
Conference on, pp. 784–786, 2005.
[27] M. Klusch and A. Gerber, “Semantic web service composition
planning with owls-xplan,” in In Proceedings of the 1st Int.
AAAI Fall Symposium on Agents and the Semantic Web, 2005,
pp. 55–62.
[28] E. M. Goncalves da Silva, L. Ferreira Pires, and M. J. van
Sinderen, “An algorithm for automatic service composition,”
in 1st International Workshop on Architectures, Concepts and
Technologies for Service Oriented Computing, ICSOFT 2007,
Barcelona, Spain, E. M. Goncalves da Silva, L. Ferreira Pires,
and M. J. van Sinderen, Eds.
INSTICC Press, July 2007,
pp. 65–74.
[29] S.-C. Oh, D. Lee, and S. R. T. Kumara, “Web service planner
(wspr): An effective and scalable web service composition
algorithm,” Int. J. Web Service Res., vol. 4, no. 1, pp. 1–22,
2007.
[30] C. Rey, “Dcouverte des meilleures couvertures d’un concept
en utilisant une terminologie Application
la dcouverte de
services web smantiques,” Ph.D. dissertation, Universit Blaise
Pascal - Clermont II, dcembre 2004.
[31] G. Alonso, F. Casati, H. Kuno, and V. Machiraju, “Web
services. concepts, architectures and applications,” 2003.
[32] UDDI, “Uddi technical white paper,” September 2000.
[33] D. Booth, H. Haas, F. McCabe, E. Newcomer, M. Cham-
pion, C. Ferris, and D. Orchard, “Web services architec-
ture,” World Wide Web Consortium, Note NOTE-ws-arch-
20040211, February 2004.
[34] L. Bourgois, “Repr´esentation et comparaison de Web services
complexes avec des logiques dynamiques,” Ph.D. dissertation,
Universite Paris 13- Villetaneuse, june 2007.
[35] J. Schaffner, H. Meyer, and M. Weske, “A formal model for
mixed initiative service composition,” Services Computing,
IEEE International Conference on, pp. 443–450, 2007.
[36] T.
Andrews,
F.
Curbera,
H.
Dholakia,
Y.
Goland,
J. Klein, F. Leymann, K. Liu, D. Roller, D. Smith,
S. Thatte, I. Trickovic, and S. Weerawarana, BPEL4WS,
Business
Process
Execution
Language
for
Web
Services
Version
1.1,
IBM,
2003.
[Online].
Available:
http://download.boulder.ibm.com/ibmdl/pub/software/dw/specs/ws-
bpel/ws-bpel.pdf
[37] S.
V.
Hashemian
and
F.
Mavaddat,
“Automatic
composition
of
stateless
components:
a
logical
reasoning
approach,”
in
Proceedings
of
the
2007
international
conference
on
Fundamentals
of
software
engineering, ser. FSEN’07.
Berlin, Heidelberg: Springer-
Verlag,
2007,
pp.
175–190.
[Online].
Available:
http://portal.acm.org/citation.cfm?id=1775223.1775235
[38] L. H. P. G. Dan, A., “Web service differentiation with service
level agreements,” White Paper, IBM Corporation, Tech. Rep.,
March, 2003.
[39] “http://www.w3.org/Submission/WSDL-S/,” 12-12-2011.
[40] R. Aggarwal, K. Verma, J. Miller, and W. Milnor, “Dynamic
Web Service Composition in METEOR-S,” 2004.
[41] J. Cardoso, J. Miller, A. Sheth, and J. Arnold, “Modeling
Quality of Service for Workﬂows and Web Service Pro-
cesses,” Web Semantics Journal: Science, Services and Agents
on the World Wide Web Journal, vol. 1, no. 3, pp. 281–308,
2004.
[42] “http://www.jdom.org/docs/apidocs/,” 12-12-2011.
[43] hp, “Jena - A Semantic Web Framework for Java,” available:
http://jena.sourceforge.net/index.html, 2002.
[44] E. P.hommeaux and A. Seaborne, “Sparql query language for
rdf (working draft),” W3C, Tech. Rep., March 2007. [Online].
Available: http://www.w3.org/TR/2007/WD-rdf-sparql-query-
20070326/
[45] “http://www.mindswap.org/2004/owl-s/api/,” 12-12-2011.
[46] E. Sirin, B. Parsia, B. Grau, A. Kalyanpur, and Y. Katz,
“Pellet: A practical OWL-DL reasoner,” Web Semantics:
Science, Services and Agents on the World Wide Web,
vol. 5, no. 2, pp. 51–53, Jun. 2007. [Online]. Available:
http://dx.doi.org/10.1016/j.websem.2007.03.004
[47] J.-D. Labails, “Description de l’ontologie des ressources
touristiques,” MobileTTE WP5.1: Standard d’interoprabilit
pour les donnes touristiques, Technical Report, Henri Tudor
Public Research Center, Luxembourg, Tech. Rep., 2006.
[48] M. R. Garey and D. S. Johnson, Computers and Intractability:
A Guide to the Theory of NP-Completeness.
New York, NY,
USA: W. H. Freeman & Co., 1979.
[49] P. Albers and O. Licchelli, “Composition de services web
personalis,” in Intelligence Artiﬁcielle et Web Intelligence
Conference, Grenoble, July 2007.
[50] S. Khapre and D. Chandramohan, “Personalized web service
selection,” in International Journal of Web
Semantic Tech-
nology (IJWesT) Vol.2, No.2, April 2011.

