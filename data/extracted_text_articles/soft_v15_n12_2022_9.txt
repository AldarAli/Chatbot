An Approach for Learning Behavioural Models of
Communicating Systems
S´ebastien Salva
LIMOS - UMR CNRS 6158
University Clermont Auvergne, France
email: sebastien.salva@uca.fr
Abstract—This paper is concerned with recovering formal
models from event logs collected from communicating systems.
We refer here to systems made up of components interacting
with each other by data networks and whose communications can
be monitored, e.g., Internet of Things (IoT) systems, distributed
applications or Web service compositions. Our approach, which
we call CkTailv2, aims at generating, from en event log, one Input
Output Labelled Transition System (IOLTS) for every component
participating in the communications and one graph illustrating
the directional dependencies with the other components. These
models can help engineers better and quicker understand how a
communicating system behaves and is structured. They can also
be used for bug detection or for test generation. Compared to
other model learning approaches specialised for communicating
systems, CkTailv2 improves the precision of the generated models
by integrating algorithms that better recognise sessions in event
logs. CkTailv2 revisits and extends a ﬁrst approach by simplifying
the set of requirements and assumptions in order to increase its
applicability on communicating systems. It now integrates two
new trace extraction algorithms: the former segments event logs
into traces by trying to detect sessions; the latter assumes event
logs to include session identiﬁers and allows to quicker generate
models. We report experimental results obtained from 10 case
studies and show that CkTailv2 has the capability of producing
precise models in reasonable time delays.
Index Terms—Reverse engineering; Model learning; Event Log;
Communicating systems.
I. INTRODUCTION
Model learning is a software reverse engineering approach,
which is receiving growing attention as a solution to help device
models as state machines. These models, which capture system
behaviours, can be considered as documentation or exploited in
some software engineering stages, e.g., robustness or security
testing. Over the last decade, there has been an extensive body
of work in this ﬁeld, making emerge two main categories
of approaches called active and passive model learning. Such
approaches infer behavioural models of systems seen as a black-
boxes, either by analysing a set of execution traces resulting
from monitoring (passive approaches, e.g., [1, 2, 3, 4, 5, 6, 7,
8, 9, 10]) or by interacting with them (active approaches, e.g.,
[11, 12, 13, 14, 15, 16, 17]).
We however observed that a few works [9, 18, 19] focused
on the learning of models for communicating systems. Yet,
these systems are more and more omnipresent in our daily
life, especially with the emergence of Internet of Things (IoT)
systems. Model learning would greatly ease the understanding
and analysis of communicating systems. For instance, the
generation of models expressing the behaviours of every
component could help engineers to quicker understand the
functioning of the whole system and would assist them in the
bug or vulnerability detection. We also noticed that several
issues remain open in the previous approaches. For instance,
the active technique given in [18] requires to know the system
topology in advance and only supports accessible and testable
components to build models. But, we have often observed that
many communicating systems integrate untestable components.
For instance, an autonomous component that continuously
delivers messages is uncontrollable and hence cannot be
experimented to get observations. The two other papers propose
passive approaches, which do not rely on these requirements.
Instead, they analyse execution traces to recover behaviours.
In order to build precise models, one key point is to be able
to recognise sessions in event logs, i.e., a temporary message
interchange among components forming a behaviour of the
whole system from one of its initial states to one of its ﬁnal
states. Unfortunately, these approaches cannot extract sessions.
These observations motivated us to present a ﬁrst approach and
tool called Communicating system k-Tail, shortened CkTailv1
[2]. To design it, we choose to extend the k-Tail learning
algorithm [3] with the capability to build one model called
Input Output Labelled Transition System (IOLTS) for every
component of a communicating system under learning. k-Tail
is well-known to quickly build generalised models from traces,
but it is unable to take into account the notion of component
and to construct models from event logs. We showed that
CkTailv1 builds more precise models than the two previous
passive approaches, but we also concluded that its requirements
and assumptions are still too restrictive to be practical.
In [1], we also proposed a passive model learning approach
for recovering models as IOLTSs from event logs. We however
assumed that correlation mechanisms, e.g., execution trace
identiﬁers, are employed to propagate context IDs in event logs.
The major contribution of this approach is its capability to
automatically retrieve conversations from event logs, without
having any knowledge about the used correlation mechanisms.
Our algorithm is based upon a formalisation of the notion of
correlation patterns and is guided towards the most relevant
conversation sets by evaluating conversation quality.
Contributions: this paper presents an extension of [1] and [2],
simply called CkTailv2, and the related tool. This new approach
111
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

aims at relaxing some requirements of CkTailv1 for targeting
more communicating systems. CkTailv2 indeed accepts event
logs having communication and non-communication events,
the latter being often used to keep track of debug outputs or
errors. Event logs can now integrate requests followed by an
unlimited amount of responses. Besides, CkTailv2 relies on two
session extraction algorithms. The former segments event logs
by trying to detect sessions with respect to constraints related to
the request-response pattern, the recognition of nested requests,
time delays and data dependency among components. The latter
assumes event logs to include session identiﬁers and uses the
trace extraction algorithm presented in [1]. CkTailv2 also infers
dependency graphs, which show in a simple way the directional
dependencies observed among components. We believe that
this kind of graph completes the behavioural models and will
be helpful to evaluate different kinds of model properties, e.g.,
testability or security.
This paper also provides a detailed empirical evaluation,
which investigates the precision of the models derived by
CkTailv2 and its performance in terms of execution times. This
empirical evaluation was carried out on event logs collected
from 10 case studies and compares our implementation of
CkTailv2 against three other tools namely CSight, the algorithm
given in [19] and CkTailv1. This evaluation shows that
CkTailv2 infers more precise models than the three previously
approaches, in reasonable time delays.
In summary, the major contributions of this paper are:
• the presentation of the CkTailv2 tool and approach, which
generates behavioural models and dependency graphs for
every component of a communicating system from event
logs,
• the design of two new algorithms allowing to better
recognise sessions in event logs, and hence to build more
precise models,
• the implementation of the approach publicly available
in [20] and an evaluation that compares CkTailv2 with
CSight, the approach proposed in [19] and CkTailv1.
Paper organisation: Section II discusses related work and
presents our motivations. We provide an overview of our tool
along with its capability of inferring models of communicating
systems with a concrete example of IoT system in Section
III. Our algorithms are detailed in Section IV. We recall some
basic deﬁnitions about the IOLTS model and we describe the
four steps of the approach. Section V examines experimental
results and discusses about the threats to validity. Section VI
summarises our contributions and draws some perspectives for
future work.
II. RELATED WORK
Model learning can be deﬁned as a set of methods that
recover a speciﬁcation by gathering and analysing system
executions and concisely summarising the frequent interaction
patterns as state machines that capture the system behaviour
[21]. Model learning algorithms can be organised into two main
categories: active and passive approaches. Both categories are
discussed below.
A. Active Model Learning
In this ﬁrst category, systems are repeatedly queried (often
with tests) to collect positive or negative observations, which
are analysed and generalised to produce models [11, 12, 13, 14,
15, 16, 17]. Most of the active techniques have been conceived
upon two concepts, the L∗ algorithm [11] and incremental
learning [12]. This model learning category is actively studied
to make the approaches more effective and efﬁcient. Among
the possible research directions, some works recently proposed
optimisations to reduce the query number [22], while others
tackled systems having speciﬁc constraints [17].
Some active model learning approaches have been proposed
for communicating systems. Groz et al. introduced an algorithm
to generate a controllable approximation of components through
active testing [23]. This kind of active technique implies that
the system is testable and can be queried. The learning of
the components is done in isolation. A recent work lifts this
constraint by testing a system with unknown components by
means of a SAT solving method [18]. Tappler et al. also
proposed a model-based testing technique for IoT systems
[24]. This technique is based on the generation of models
from multiple implementations of a common speciﬁcation,
which are later pair-wise cross-checked for equivalence. Any
counterexample to equivalence is ﬂagged as suspicious and
has to be analysed manually.
B. Passive Model Learning
The second category includes the techniques that passively
recover models from a given set of samples, e.g., a set of
execution traces. These are said passive as there is no direct
interaction with the system under learning. Models are often
generated by encoding sample sets with state diagrams whose
equivalent states are merged. For instance, the k-Tail approach
[3] merges the states having the same k-future, i.e., the same
event sequences having the maximum length k, which all are
accepted by the two states. k-Tail has been later enhanced with
Gk-tail to generate Extended Finite State Machines encoding
data constraints [4]. Other approaches also enhance k-Tail to
build more precise models [5, 7, 8]. kBehavior [6] is another
kind of approach that generates models from a set of traces
by taking every trace one after the other and by completing
a ﬁnite-state automaton in such a way that it now accepts
the trace. These previous passive algorithms usually yield big
models, which may quickly become unreadable.
Some passive approaches dedicated to communicating sys-
tems have also been proposed. Mariani et al. proposed in
[19] an automatic detection of failures in log ﬁles by means
of model learning. This work extends kBehavior to support
events combined with data. It segments an event log with two
strategies: per component or per user. The former, which can
be used with communicating systems, generates one model
for each component. CSight [9] is another tool specialised
in the model learning of communicating systems, where
components exchange messages through synchronous channels.
It is assumed that both the channels and components are
known. Besides, CSight requires speciﬁc trace sets, which are
112
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

segmented with one subset by component. CSight follows ﬁve
stages: 1) log parsing and mining of invariants 2) generation
of a concrete Finite State Machine (FSM) that captures the
functioning of the whole system by recomposing the traces
of the components; 3) generation of a more concise abstract
FSM; 4) model reﬁnement with invariants that must hold in
FSMs, and 5) generation of Communicating FSM.
C. Key Observations and Motivations
After having studied the literature, we have ﬁrstly observed
that few papers and tools tackled the model generation of
component based systems or communicating systems. As stated
in the introduction, the main concerns of the active model
learning techniques are that the component topology must
be known in advance, and that all the components must be
reachable, testable and resettable many times. As a consequence,
active learning can be currently applied on a limited amount of
systems. As for passive techniques, the approaches [9, 19] have
paved the way, however, there is still room of improvements
to relax the approach requirements and to infer precise models.
Besides, we have observed that the generation and use of
invariants to make models more precise also limits learning
to small trace sets only in practice. For instance, the invariant
mining and satisﬁability checking used in CSight are both
costly and prevent the tool from taking as input medium to
large trace sets.
We have proposed in [25] a passive model learning algorithm
for component-based systems, which builds one model per
component to avoid the generation of large and unreadable
models. This approach is specialised to IoT systems with an
algorithm called Assess [26]. The requirements considered in
these approaches are different from those of CkTail or CSight.
The main difference lies in the fact that the communications
among components are assumed hidden (not available in event
logs). Therefore, Assess tries to detect implicit component calls
and adds new synchronisation actions in models. Its algorithm
is hence speciﬁc to this assumption. Then, we have proposed
CkTailv1 [2] to generate models of communicating systems. In
short, the novelty proposed by CkTailv1 lies in its capability of
detecting sessions in event logs. Indeed, CSight needs sessions
put in separate sets but does not provide a way to generate
them from event logs. The work proposed in [6] offers the
possibility to segment event logs with several strategies. One
of them allows to extract the session of every component on
condition that the events include component identiﬁers.
We showed that CkTailv1 builds more precise models than
the other approaches by better recognising sessions, but we
also concluded that its requirements are too restrictive to be
widely used. Indeed, CkTailv1 requires event logs comprising
communication events only in such a way that each request
has to be followed by one response only. CkTailv2 aims at
relaxing some of these assumptions and integrates two new
trace extraction algorithms to support more communicating
systems.
III. CKTAILV2 TOOL AND APPROACH PRESENTATION
CkTailv2 is implemented in Java and is released as open
source in [20]. The tool takes as inputs an event log collected
from a communicating system and a ﬁle including regular
expressions used to format the event log. It returns two kinds of
models. The behaviours of each component of the system under
learning are encoded with one IOLTS. Intuitively, an IOLTS
expresses here the interactions of one component c with the
others along with the non-communication actions of c. Besides,
CkTailv2 generates dependency graphs, given under the form
of Direct Acyclic Graphs (DAGs). Each component has its own
DAG capturing its dependencies towards other components.
Such graphs help better comprehend the architecture of the
whole system. They complement the IOLTSs by offering
another viewpoint of the component interactions and they might
be used to different purposes, e.g., testability measurement, or
security analysis. Once generated, CkTailv2 stores these models
into two folders containing ﬁles saved in the DOT format. We
chose this format since it is based upon a well-known plain text
graph description language that can be translated into graphics
formats, e.g., PDF.
We provide below the requirements of CkTailv2, an over-
view of its architecture and functioning along with an example
of model generation.
A. CkTailv2 Requirements
The capability of CkTailv2 of inferring models depends on
several realistic assumptions made on a system under learning
denoted SUL:
• A1 Event log: we consider the components of SUL as
black-boxes (no access to ﬁrmware, code, data stored
on the device, etc.). The communications among the
components can be monitored, e.g., on components, on
servers, gateways, or by means of wireless sniffers. Event
logs are collected in a synchronous environment made
up of synchronous communications. Besides, these events
are ordered by means of timestamps given by a global
clock. At the end of the monitoring process, we consider
having one event log;
• A2 Event content: components produce communication
events or non-communication events. Both kinds of
events include parameter assignments allowing to identify
the source and the destination of each event. For non-
communication events, both the source and the destination
refer to the same component that has produced the event.
Besides, a communication event can be identiﬁed either
as a request or a response;
• A3 Device collaboration: components can run in parallel
and communicate with each other. To learn precise models,
we want to recognise sessions of the system in event logs.
We consider two exclusive cases:
– A31: the components of SUL follow this strict be-
haviour: they cannot run multiple instances; requests
are processed by a component on a ﬁrst-come, ﬁrst
served basis. Besides, components follow the request
113
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

–response exchange pattern (a response is associated
to one request, a request is associated to one or more
responses), or
– A32: the events that belong to the same session are
identiﬁed by a parameter assignment.
The session recognition mentioned in A3 helps extract
traces expressing complete behaviours of SUL, i.e., disjoint
action sequences starting from one of its initial states and
ending in one of its ﬁnal states. A32 represents the classical
assumption stating that messages include an identiﬁer allowing
to observe whole collaborations among components. Usually,
the session identiﬁcation strongly facilitates the trace extraction.
Unfortunately, we have observed that this technique is seldom
adopted with communicating systems. When it is not used,
we restrict the functioning of SUL with A31 to be able to
recognise sessions. We have observed that this assumption can
be applied with many wireless or IoT systems.
B. CkTailv2 Overview
CkTailv2 is organised into four-steps, illustrated in Figure
1. Initially, the user gives as inputs an event log collected
from SUL along with regular expressions. The latter are
used to format the event log into a sequence S of actions
of the form a(α) with a a label and α some parameter
assignments. In accordance with the assumptions A1-A3, the
event log formatting allows to highlight some information such
as timestamps, or the sources and destinations of the messages
(request or response).
Execution traces are extracted from S by means of two
algorithms, which rely either on the assumption A31 or A32.
In short, if the actions include session identiﬁers, allowing
to directly recognise sessions in S (A32), The ﬁrst algorithm
which aims at recognising sessions in S with respect to
constraints derived from the assumptions A1-A31. The second
one extracts traces by using session identiﬁers. When these
identiﬁers are provided, the algorithm simply extracts traces
by covering actions and their respective identiﬁers. When the
latter are unknown, the event log is analysed w.r.t. session
patterns and quality metrics to recover these identiﬁers ﬁrst.
Both algorithms return a trace set denoted Traces(SUL) and
detect dependencies among the components of SUL. Then,
the third step of CkTailv2 derives dependency graphs from
Deps(SUL). In its last step, CkTailv2 generates one IOLTS
for every component of SUL with three sub-steps called “4A
Trace partitioning”, “4B IOLTS Generation” and “4C IOLTS
Generalisation”. The latter calls the k-Tail approach, which is
a model learning technique used to reduce IOLTSs by merging
equivalent states.
C. Model Learning Example
Before describing the CkTailv2’s steps, let us illustrate them
with a motivating example of model generation. Figure 2
shows a part of an event log collected from an IoT system
made up of devices and of two gateways. The events are
formatted by means of regular expressions to produce actions.
The regular expression example of Figure 2 extracts from
HTTP requests a label equals to the URI along with some
parameters. Figure 3 depicts an example of sequence of 15
actions obtained after the ﬁrst step of CkTailv2. The ﬁrst four
actions are derived from the HTTP messages of Figure 2. As
required, these actions indicate the sources and destinations
of the messages with the parameters from and to. The other
parameter assignments capture acknowledgements or sensor
data, e.g., a temperature value with svalue:=68 or a level of
luminance with svalue:=1000. We can observe from these
actions that the IoT system SUL is made up of 6 components.
But interpreting their interactions and what they do is still
tricky because of lack of readability.
Traces are now extracted from the action sequence S of
Figure 3 by the second step of CkTailv2. It covers and segments
S while trying to recognise sessions. In our example, no session
identiﬁer is found in the actions. As a consequence, CkTailv2
uses an algorithm that tries to recover sessions with respect
to the assumption A31. To be integrated in the algorithm, we
formulated this assumption with ﬁve constraints expressing
what a session is and when keeping an action to a current
session. These constraints are detailed in Section IV-C and
summarised as follows: C1: a response is always associated
to the last observed request sharing the same communicating
components; C2: successive responses are always associated
to the related request; C3: nested requests (a request to a
component that also performs another request before giving a
response) are always kept together in a session; C4: a session
gathers messages exchanged between components interacting
together in a limited time delay and all the messages capturing
a data dependency between two components; C5: a non-
communication event is kept is the current session also with
respect to time delay and data dependency. Figure 4 gives
the trace set Traces(SUL) obtained from the action sequence
of Figure 3 with this algorithm. For sake of readability, the
parameter assignment are concealed in the ﬁgure. We observe
that it has kept together the related requests and responses, and
the nested requests req6 req7. Here, our algorithm has only
detected one distinctive longer time interval between the two
actions resp5 req6, which implicitly shows that a session ends
at resp5 and that a new one begins at req6.
While actions are covered to extract traces, the component
interactions are also analysed by CkTailv2 for detecting
component dependencies. These dependencies are given under
the form of component lists c1c2 . . . ck expressing that a
component c1 depends on a component c2, which itself depends
on another component and so on. The set Deps(SUL) gathers
these component lists. The component dependency is deﬁned
in Section IV-E. Figure 4 shows the set Deps(SUL) inferred
from our example. Most of the dependencies between pairs
of components stem from requests. The component sequence
G1G2d3 is detected from the nested requests req6 req7. Four
data dependencies are also detected between d2d1, G2d1,
d4d1, (with the data svalue:=68) and d3G1 (with the data
cmd:=status).
The CkTail’s third step generates dependency graphs. It
derives DAGs from the set Deps(SUL) and computes their
114
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Fig. 1. Model learning of communicating systems with the CkTail approach
Jan 20, 2020 09:56:24.225
CET;Host=d1;Dest=G1;Protocol=HTTP;Verb=GET
Uri=/req1?svalue=68.00 HTTP/1.1;
Jan 20, 2020 09:56:24.682
CET;Host=G1;Dest=d1;Protocol=HTTP;HTTP/1.1
status=200 response=OK;
Jan 20, 2020 09:56:25.153
CET;Host=G1;Dest=d2;Protocol=HTTP;Verb=GET
Uri=/req2?svalue=68.00 HTTP/1.1;
Jan 20, 2020 09:56:25.318
CET;Host=d2;Dest=G1;Protocol=HTTP;HTTP/1.1
status=200 response=OK data=done;
Example of regular expression:
ˆ(?<date>\w{3} \d{2}, \d{4} \d{2}:\d{2}:\d{2}.\d{3})
\s(CET);(?<param1>(\w+=\w\d));(?<param2>(\w+=\w\d));
(?<param3>[ˆ;]+);(?<param4>[ˆ=]+=[A-Z]{3,4})\s(Uri=)
(?<label>[ˆ?]+)[?](?<param5>(\w+=\d{2}\.\d{2}))\s
HTTP/1.1;$
Fig. 2. Example of 4 HTTP messages collected from an IoT system. The
regular expression retrieves a label and 5 parameters here. The label expression
will be the label of the action in the action sequence S
transitive closures. Figure 5 illustrates the dependency graphs
obtained in our example.
The fourth step of CkTailv2 lifts traces to the level of
IOLTSs. In the step 4A Trace partitioning, CkTailv2 builds one
trace set for every component of SUL. It begins by doubling
every communication action to give a pair of output/input
actions by separating the notion of source/destination. The non-
communication actions are marked as outputs. Traces(SUL)
is then partitioned into as many trace sets as components found
in SUL. Each trace set Tc gathers only the traces related to
the component c. If we take back our example, Figure 6 gives
the new trace sets composed of sequences of input and output
actions derived from the set Trace(SUL) of Figure 4. As
this system is made up of 6 components, Traces(SUL) is
partitioned into 6 subsets.
The step 4B IOLTS Generation transforms every trace set
Tc into an IOLTS by converting traces into IOLTS path cycles,
which are joined on the initial state only. In our example, as
we have 6 trace sets, we obtain 6 IOLTSs Ld1-Ld4, LG1, LG2,
illustrated in Figure 7. Finally, CkTailv2 applies the k-Tail
algorithm to reduce the IOLTS sizes in the step 4C IOLTS
Generalisation. More precisely, it merges the states sharing
req1(from:=d1,to:=G1,svalue:=68,time:=
09:56:24.225)
resp1(from:=G1,to:=d1,content:=ok, time:=
09:56:24.682)
req2(from:=G1,to:=d2,svalue:=68, time:=
09:56:25.153)
resp2(from:=d2,to:=G1,content:=done,
time:=09:56:25.318)
req3(from:=G1,to:=G2,svalue:=68, time:=
09:56:26.267)
req1(from:=d1,to:=G1,svalue:=68, time:=
09:56:27.369)
resp3(from:=G2,to:=G1,content:=ok, time:=
09:56:27.371)
resp1(from:=G1,to:=d1,content:=ok, time:=
09:56:27.720)
req5(from:=G2,to:=d4,svalue:=68, time:=
09:56:27.859)
log(from:=d4,to:=d4,content:=heat-off,
time:=09:56:28.909))
resp5(from:=d4,to:=G2,content:=done,
time:=09:56:28.982)
req6(from:=G1,to:=G2,udevice:=12, cmd:=
status,time:=09:56:35.962)
req7(from:=G2,to:=d3,cmd:=status,GPIO:=1
time:=09:56:35.974)
resp7(from:=d3,to:=G2,svalue:=1000,
time:=09:56:36.846)
resp6(from:=G2,to:=G1,svalue:=1000, time:=
09:56:36.958)
Fig. 3.
Action sequence of an IoT system. These actions have the form
<label><parameter assignments>, the latter expressing the components
involved in the communications and data
Traces(SUL)={req1resp1req2resp2req3req1resp3
resp1req5logresp5, req6req7resp7resp6}
Deps={ d1G1, G1d2, d2d1, G1G2, G2d4, G2d1,
d4d1, G1G2d3, G2d3, d3G1 }
Fig. 4. Step 2: Traces of SUL and dependency set Deps(SUL). The parameter
assignments are concealed for readability
115
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Fig. 5.
Step 3: Dependency Graph Generation. Each component has its
own dependency graph expressing its directional dependencies with the other
components of SUL
$T_{d1}$={ !req1 ?resp1 !req1 ?resp1 }
$T_{d2}$={ ?req2 !resp2 }
$T_{d3}$={ ?req7 !resp7 }
$T_{d4}$={ ?req5 !log !resp5 }
$T_{G1}$={ ?req1 !resp1 !req2 ?resp2 !req3
?req1 ?resp3 !resp1, !req6 ?resp6 }
$T_{G2}$={ ?req3 !resp3 !req5 ?resp5, ?req6
!req7 ?resp7 !resp6 }
Fig. 6. Step 4A: Trace Partitioning. Traces(SUL) is prepared before the
IOLTS generation. Traces(SUL) is segmented to produce one trace set for
every component of SUL
the same k-future, i.e., the same action sequences having the
maximum length k. In our example, with k := 2, only the
states in white of the IOLTS Ld1 are merged by k-Tail, which
produces the IOLTS Ld11.
With these IOLTSs and DAGs, it becomes easier to interpret
the behaviour of SUL. In our example, the IOLTSs bring out
that the central devices of SUL are G1 and G2, which are
the two gateways. The component d1 is an active sensor that
provides temperature values. These values are sent to two
actuators d2 and d4 through the gateways G1 and G2. d3 is a
passive sensor (an illuminance light meter) that is queried by
G1 through G2, as d3 is directly connected to G2. d4 seems
to control a heating system, which is turned off when the
temperature reaches 68◦F.
Furthermore, as we now have formal models, different
kinds of activities may be automatically or semi-automatically
conducted to document SUL, to discover defects or more
generally to audit SUL. For instance, the European Telecom-
munications Standards Institute (ETSI) has proposed a general
method dedicated to audit large scale, networked systems by
undertaking testing and risk assessments [27]. One of the stages
of this method corresponds to establishing the context of SUL,
which can be partially performed with our tool from event
logs. Besides, quality metrics such as testability degrees can be
computed from our models [28, 29]. We provide another tool
for computing Observability, Controllability and Dependability
in [30]. These metrics can be used to deduce which component
is testable, or testable in isolation. Other approaches can take
these models or transition systems to audit the security of SUL
[24, 31, 32, 33].
After this overview of CkTailv2, we will develop its
theoretical background along with its algorithms in the next
section.
IV. THE CKTAILV2 APPROACH
Before going to the CkTailv2 step description, we will brieﬂy
recall some basic deﬁnitions and notations used in the remainder
of the paper.
A. Preliminary Deﬁnitions
As in many works dealing with the modelling of atomic
components, e.g., [34, 35], we express the behaviours of
components with the well established Labelled Transition
System (LTS) model. A LTS is deﬁned in terms of states
and transitions labelled by actions, themselves taken from a
general action set L, which expresses what happens. The Input
Output LTS is an extension of the LTS allowing to better
express behaviours with inputs and outputs.
Deﬁnition 1 (IOLTS) An Input Output Labelled Transition
System (IOLTS) is a 4-tuple ⟨Q, q0, Σ, →⟩ where:
• Q is a ﬁnite set of states;
• q0 is the initial state;
• Σ ⊆ L is the ﬁnite set of actions. ΣI ⊆ Σ is the countable
set of input actions, ΣO ⊆ Σ is the countable set of output
actions, with ΣO ∩ ΣI = ∅;
• →⊆ Q × Σ × Q is a ﬁnite set of transitions. A transition
(q, a, q′) is denoted q
a−→ q′.
We also use the following notations on action sequences.
The concatenation of two action sequences σ1, σ2 ∈ L∗
is denoted σ1.σ2. ϵ denotes the empty sequence. We de-
note that σ1 is a subsequence of another sequence σ2 with
σ1 ⪯ σ2. final(σ) denotes the action ak(αk) of the sequence
σ = a1(α1) . . . ak(αk) or ϵ if σ = ϵ. A trace is a ﬁnite
sequence of observable actions in L∗. The trace of an IOLTS
is a sequence a0 . . . ak such that ∃qi−1, qi, ai, (1 ≤ i ≤ k) :
q0
a1
−→ q1 . . . qk−1
ak
−→ qk ∈→∗. Traces(L) denote the trace
set of the IOLTS L.
Furthermore, to better match the functioning of commu-
nicating systems, we assume that an action has the form
a(α) with a a label and α an assignment of parameters in
P, with P the set of parameter assignments. For example,
!switch(from := c1, to := c2, cmd := on) is an output action
composed of the label ”switch” followed by a parameter assign-
ment expressing the components involved in the communication
and a parameter of the switch command.
We will ﬁnally use the following notations on actions to
make our algorithms more readable:
• from(a(α)) = c denotes the source of the action;
• to(a(α)) = c denotes the destination;
• components(a(α)) = {from(a(α)), to(a(α))};
116
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Fig. 7. Steps 4B & C: IOLTS Generation and generalisation with the k-Tail algorithm. Each component has its own IOLTS.
• time(a(α)) = t returns the timestamp value identifying
when a(α) occurred, time(ϵ) = +∞;
• isReq(a(α)), isResp(a(α)) are boolean expressions ex-
pressing the nature of the message;
• session(a(α)) = id denotes the session identiﬁer when
available. Otherwise, session(a(α)) = ∅.
• data(a(α)) = α \ {from := c1; to := c2, time :=
t, session := s};
The dependencies among the components of a communicat-
ing system are captured with a Directed Acyclic Graph (DAG),
where component identiﬁers are labelled on vertices.
Deﬁnition 2 (Directed Acyclic Graph) A DAG Dg is a 2-
tuple ⟨VDg, EDg⟩ where V is the ﬁnite set of vertices and E
the ﬁnite set of edges.
λ denotes a labelling function mapping each vertex v ∈ V to
a label λ(v).
B. CkTailv2 Step 1: Trace Formatting
Keeping in mind the assumption A1, CkTail takes as input
an event log gathering events that are totally ordered by means
of their time-stamps. These events are parsed to retrieve the
actions performed by SUL and their related data. These actions
must have the form a(α) with a a label and α an assignment
of parameters and must be compliant with the assumption A2.
This formatting is achieved by means of regular expressions
given to CkTailv2. Their writing may be performed manually
with small to medium event logs, but this activity may quickly
become laborious as the log size grows. A way to eliminate or
assist users in this intervention is to consider the approaches
and tools that automatically mine patterns from log ﬁles [19,
36, 37, 38, 39, 40]. These patterns may be used to quickly
derive regular expressions.
As events are usually too detailed or speciﬁc to their related
executions, regular expressions are also a good mean to lift
the abstraction level by ﬁltering out some useless actions, or
some concrete values in actions.
At the end of this step, we hence assume having a sequence
S ∈ L∗ of actions on the form a1(α1) . . . ak(αk). The next
step of CkTailv2 covers the action sequence S to extract the
sub-sequences that capture some sessions of SUL. This step
TABLE I
CONSTRAINTS DERIVED FROM THE ASSUMPTIONS A1, A2, A31. WHEN
ONE OF THESE CONSTRAINTS HOLD, THE CURRENT ACTION ai(αi) IS KEPT
IN A SESSION σ.
C1
A response ai(αi) is always associated to the last request previously
observed in σ such that the replier returns the response to the requester
which has sent the request.
C2
All the responses associated to the same request are kept in σ.
C3
A request ai(αi) that belongs to a chain of nested requests must be
kept in the session σ. Two requests req1 and req2 are nested iff the
action sequence S includes this form of sequence: req1(from:=c1, to:=c2)
req2(from:=c2, to:=c3) resp2(from:=c3, to:=c2) resp1(from:=c2, to:=c1).
C4
A component, which already participated to the session σ, can send a new
request ai(αi) to another component. This request is kept in σ if C4.1:
the session is not timed out, or if C4.2: this request shares data with some
previous actions of σ
C5
A non-communication action ai(αi) is kept in σ if C5.1: the session is
not timed out, or if C5.2: ai(αi) shares data with some previous actions
of σ
relies either on the assumption A31 or A32 and is hence
implemented with two different algorithms presented in the
two next sections.
C. CkTailv2 Step 2: Trace Extraction Without Session Identiﬁer
The ﬁrst trace extraction algorithm is founded on the
assumptions A1, A2, A31 to interpret communications and
to recover sessions in event logs. In particular, with A31, we
suppose that sessions are not identiﬁed in event logs.
To devise this algorithm, we derived a list of constraints
from these assumptions giving the conditions for a sub-sequ-
ence of S to be a session. As our algorithms cover the actions
of S one after the other, we have formulated these constraints
to express whether an action ai(αi) of the action sequence
S = a1(α1) . . . ak(αk) ∈ L∗ belongs to a session denoted
σ. Table I gathers the ﬁve constraints used in our algorithms.
C1 and C2 focus on responses, while C3 and C4 deal with
requests. C4 is a special constraint expressing when a new
request ai(αi), sent from a component that has previously
participated in the current session, belongs to σ. The choice
of keeping this new request in the session depends on two
other factors, i.e., time delay and data dependency, with the
constraints C4.1 and C4.2. C5 addresses non-communication
actions and restricts the session participation as in C4.
117
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

TABLE II
FORMALISATION OF THE CONSTRAINTS C1-C5 USED IN THE TRACE
EXTRACTION ALGORITHM
C1
∃!σr ∈ Lreq(σ) : response(ai(αi), final(σr))}
C2
∃!σr ∈ OLreq(σ) : response(ai(αi), final(σr))}
C3
isReq(ai(αi)) ∧ Lreq′ = {σ1 ∈ Lreq(σ) | from(ai(αi)) =
to(final(σ1))} ̸= ∅∧ ¬pendingRequest(from(ai(αi)))
C4
isReq(ai(αi))∧
from(ai(αi)) ∈ KC ∧(∀σ1 ∈ Lreq(σ) : from(ai(αi)) ̸=
to(final(σ1)))∧ (ontime(ai(αi), σ) ∨ dataDependency(
ai(αi), S, σ))∧ ¬pendingRequest(from(ai(αi)))
C5
¬isReq(ai(αi))∧ ¬isResp(ai(αi))∧ from(ai(αi)) ∈ KC ∧
(ontime(ai(αi), σ)∨ dataDependency(ai(αi), S, σ))
To use these constraints in our algorithms, we formulated
them with boolean expressions written with the notations given
in Section IV-A completed by these ones:
• KC stands for the set of known components involved in
the session σ so far;
• response(a1(α1), a(α)) is the boolean expression
isResp( a1(α1))∧ from(a1(α1)) = to(a(α))∧ to(a1(
α1)) = from(a(α));
• Lreq(σ) denotes the set of sequences of pending requests
i.e., the sequences of requests a1(α1) . . . ak(αk)
⪯ σ for which responses have not yet been received.
Lreq(σ) =def {a1(α1) . . . ak(αk) ⪯ σ | isReq(ai(
αi))1≤i≤k, ∀a(α) ∈ L∗ : response(a(α), ai(αi)) =⇒
ai(αi)a(α)ai+1(αi+1)  σ};
• OLreq(σ) denotes the set of requests for which a least
one response has been received;
• ontime(a(α), σ) is a boolean expression that returns true
if the action a(α) may belong to the session σ with regard
to the session duration or session time-out;
• data-dependency(a(α), S, σ) is a boolean expression that
returns true if the request a(α) shares some data with
other requests of the session σ ⪯ S. The data dependency
is deﬁned in Section IV-E;
• pendingRequest(c) is the boolean expression (∃σ1 ∈
Lreq(σ), a(α) ∈ σ1 : c ∈ components(a(α))) that eval-
uates whether the component c has sent (resp. received) a
request and has not yet received (resp. sent) the response.
From these notations, we formulated the above constraints,
listed their boolean terms and studied their possible permuta-
tions. We ﬁnally kept the constraints expressing that an action
ai(αi) belongs to the current session when they hold. These
are listed in Table II.
Algorithms 1 and 2 implement the trace extraction. Al-
gorithm 1 calls the procedure Keep-or-Split with an action
sequence initialised to S. It returns Traces(SUL), the ﬁnal
component set C along with the set of component dependencies
Deps(SUL).
The procedure Keep-or-Split covers an action sequence
a1( α1) . . . ak(αk) to extract a session σ. The set of known
components KC is initialised with the components of the
ﬁrst action a1(α1). Then, every action ai(αi) is covered to
decide whether it is kept in σ (line 8) or not. Given an action
ai(αi), the procedure updateOLreq (Algorithm 2 lines (1-5))
is called to update the set of pending requests OLreq w.r.t. the
Algorithm 1: Trace Extraction with A31
input :Action sequence S
output :T races(SUL), Component set C, Component dependency set
Deps(SUL)
1 C := Deps(SUL) := ∅;
2 Keep-or-Split(S);
3 Procedure Keep-or-Split(a1(α1) . . . ak(αk)) is
4
σ := σ2 := ϵ;
5
Lreq(σ) := OLreq(σ) := ∅;
6
KC := components(a1(α1));
7
i := 1;
8
while i ≤ k do
9
updateOLreq(ai(αi));
10
case C1 true do
11
σ := σ.ai(αi); T rim(σr);
12
KC := KC ∪components(ai(αi));
13
case C1 false and C2 true do
14
σ := σ.ai(αi);
15
KC := KC ∪components(ai(αi));
16
case C3 true do
17
σ := σ.ai(αi);
18
Extend(σr, ai(αi));
19
KC := KC ∪components(ai(αi));
20
case C3 false and C4 true do
21
σ := σ.ai(αi);
22
Extend(ϵ, ai(αi));
23
KC := KC ∪components(ai(αi));
24
case C5 true do
25
σ := σ.ai(αi);
26
KC := KC ∪components(ai(αi));
27
otherwise do σ2 := σ2.ai(αi) ;
28
i++;
29
T races(SUL) := T races(SUL) ∪ {σ};
30
C := C ∪ KC;
31
if σ2 ̸= ϵ then
32
Keep-or-Split(σ2);
33 END;
assumption A31. More precisely, if ai(αi) is a new request
coming from a component c, then all the previous requests that
involve c are removed from OLreq to meet A31 (ﬁrst come,
ﬁrst served). In the same way, if ai(αi) is a response, only the
request associated to this response is kept.
Then, the procedure Keep-or-Split processes the action ai(αi)
with the constraints C1-C5. When one of them holds, the action
ai(αi) is added to the session σ. Besides, the set of known
components KC is updated to include the components involved
in ai(αi). For any other case, the action ai(αi) is put into a
new action sequence σ2 (line 27). Once all the actions have
been covered, σ is added to Traces(SUL) and C is updated
with the set of components KC built with this session. If σ2
is not empty, the procedure Keep-or-Split( σ2) is recursively
called to recover other sessions in σ2 (line 31).
The main difference among the cases C1 to C5 lies in
the update of the set of pending requests Lreq(σ), with the
procedures Trim and Extend. The former is called with C1:
receipt of a response associated to a list of pending requests
σr in Lreq(σ). Trim is called to remove the last request
of σr, final(σr), because a response has been received to
this request. final(σr) is shifted to OLreq(σ). The procedure
Extend is called with C3 and C4. C3 corresponds to the
receipt of a request that belongs to a chain of nested requests
σr ∈ Lreq(σ). Extend is here called to update Lreq(σ) with
118
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

the nested request list σr.ai(αi). C4 stands for the receipt
of a new request from a known component. Extend is now
called to add the new request ai(αi) in Lreq(σ). Furthermore,
Extend builds the set Deps(SUL) of component lists. This
part is detailed in Section IV-E.
Algorithm 2:
1 Procedure updateOLreq(ai(αi)) is
2
if isReq(ai(αi)) then
3
OLreq(σ) := OLreq(σ) \ {a(α) ∈ OLreq |
from(ai(αi)) ∈ components(a(α))};
4
else if isResp(ai(αi)) then
5
Lr := {a(α) ∈ OLreq(σ) | from(ai(αi) = to(a(α))}
OLreq(σ) := OLreq(σ) \ {a(α) ∈ OLreq(σ) |
from(ai(αi) ∈ components(a(α))} ∪ Lr;
6 Procedure T rim(σr) is
7
σ′ := remove(final(σr));
8
Lreq(σ) := Lreq(σ) \ {σr} ∪ {σ′};
9
OLreq(σ) := OLreq(σ) \ {a(α) ∈ OLreq(σ) |
from(final(σr)) ∈ components(a(α))};
10
OLreq(σ) := OLreq(σ) ∪ {final(σr)};
11 Procedure Extend(σr, a(α)) is
12
σ′ := σr.a(α) = a1(α1) . . . ak(αk);
13
Lreq(σ) := Lreq(σ) \ {σr} ∪ {σ′};
14
//Component dependencies
15
lc := c1 . . . ckck+1 such that ci = from(ai(αi))(1≤i≤k),
ck+1 = to(ak(αk));
16
Deps(SUL) := Deps(SUL) ∪ {lc};
17 Procedure ontime(ai(αi), σ) is
18
return (time(ai(αi)) − time(final(σ)) < T );
19 Procedure data-dependency(ai(αi), S, σ) is
20
if ∃σ1 = a1(α1)a2(α2) . . . ai(αi) ⪯ S : to(ai(αi))
data
−−−→
σ1
from(a1(α1)) then
21
Deps(SUL) := Deps(SUL)∪{to(ai(αi)).from(a1(α1))};
22
if σ1 ⪯ σ.ai(αi)) then
23
return true;
24
return false;
The boolean expression ontime(a(α), σ), used in C4 and
C5, is implemented with the procedure ontime. As stated
previously ontime allows to limit the session duration. Several
implementations are possible. We provide an example in
Algorithm 2, line (17). This procedure checks whether the
time delay between the last received action ai(αi) and the
previous one in the session σ is lower than a time duration T.
The boolean expression data-dependency (ai(αi), S, σ), also
used in C4 and C5, is implemented by the procedure given
in Algorithm 2. It checks whether a data dependency exists
between the request ai(αi) and some requests of the session
σ. The notion of dependency among components and this
procedure shall be discussed in Section IV-E.
The action sequence of Figure 3 has been converted into
Traces(SUL) by means of this algorithm, as no session
identiﬁer is available within actions. Here, the trace extraction
algorithm has detected that C4 does not hold with the request
req6. It has indeed detected, by means of the timestamps,
a distinctive longer time interval between the actions resp5
req6, which implicitly suggests that the session timed out. The
algorithm has detected two nested requests req6 req7. Besides,
several data dependencies have been identiﬁed between the
requests req1,req2 req3,req5. These requests along with their
responses are hence kept together in the same session.
D. CkTailv2 Step 2: Trace Extraction With Session Identiﬁers
Algorithm 3: Trace Extraction with A32
input :Action sequence S
output :T races(SUL), Component set C, Component dependency set
Deps(SUL)
1 C := Deps(SUL) := ∅;
2 ID := {session(a(α)) | a(α) ∈ S};
3 T races(SUL) := S
id∈ID{σid} with
σid = S \ {a(α) | session(a(α)) ̸= id};
4 foreach σ = a1(α1) . . . ak(αk) ∈ T races(SUL) do
5
S := σ;
6
Keep-or-Split2(S);
7 END;
8 Procedure Keep-or-Split2(a1(α1) . . . ak(αk)) is
9
Lreq(σ) := OLreq(σ) := ∅;
10
KC := components(a1(α1));
11
i := 1;
12
while i ≤ k do
13
C := C ∪ components(ai(αi));
14
case C1 true do
15
T rim(σr);
16
case C3 true do
17
Extend(σr, ai(αi));
18
case C3 false and C4 true do
19
Extend(ϵ, ai(αi));
20
i++;
The previous trace extraction algorithm relies on the as-
sumption A31 to extract traces. This second trace algorithm
now relies on A32. This assumption involves that the session
identiﬁers should be given to the algorithm. Nonetheless,
we observed that establishing an identiﬁer list is a strong
assumption especially when SUL is a composition of external
items, e.g., services or IoT, whose functioning is not known.
To solve this issue, we presented in [1] an algorithm for
extracting session identiﬁers from event logs. In short, this
algorithm explores the trace set space that can be derived from
an event log along with the respective identiﬁers. Furthermore,
it is guided toward the most relevant solutions by means of
session invariants and trace quality metrics. The algorithm
either provides a ﬁrst session identiﬁer set that meets quality or
returns a sorted list w.r.t. quality. More details were presented
in [1].
With a given set of session identiﬁers and A32, the trace
extraction is quite simpler to perform. Algorithm 3 begins to
build Traces(SUL) by extracting from S the sub-sequences
of actions having the same session identiﬁer (lines 2-3).
Afterwards, it calls the procedure Keep-or-Split2 for every
trace of Traces( SUL) to detect component dependencies as
previously (lines 4-6). To this end, this procedure updates the
set of pending requests Lreq( σ) as previously for every trace
σ with the constraints C1, C3, C4 (only these constraints are
needed to build Lreq(σ)). Lreq(σ) is updated by means of
the procedures Trim and Extend, which disclose component
dependencies and build the set Deps(SUL).
119
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

E. CkTailv2 Step 3: Dependency Graph Generation
The notion of component dependency is formulated by means
of the three expressions given below. We write c1 depends on
c2, when at least one of these expressions holds.
Deﬁnition 3 (Component dependency) Let c1, c2 ∈ C, c1 ̸=
c2, and S ∈ L∗. We denote c1 depends on c2 iff (c1
r−→
σ c2) ∨
(c1
nr
−→
σ
c2) ∨ (c1
data
−−−→
σ
c2) with:
1) c1
r−→
σ c2 iff ∃σ ⪯ S, a(α) ⪯ σ : isReq(a(α)),
from(a(α)) = c1, to(a(α)) = c2;
2) c1
nr
−→
σ
c2 iff ∃σ ⪯ S, a1(α1) . . . ak(αk) ⪯ σ :
from(a1(α1)) = c1, to(ak(αk)) = c2, a1(α1) . . .
ak(αk) ∈ Lreq(σ);
3) c1
data
−−−→
σ
c2 iff ∃σ ⪯ S, α ∈ P : DS(σ, c1, c2, α) and
∀σ′ = a′
1(α′
1)a′
2(α′
2) . . . ak(αk) ⪯ S : DS(σ′, c1, c2, α)
=⇒ σ′ ⪯ σ, with DS(a1(α1) . . . ak(αk)c1, c2, α) the
boolean expression from(a1(α1)) = c2∧ to(ak(αk))
= c1∧ isReq(ak( αk))∧ to(ai(αi)) = from(ai+1(
αi+1) )1≤i<k)∧
\
(1≤i≤k)
αi = α.
The two ﬁrst expressions illustrate that a component c1
depends on another component c2 when c1 queries c2 with
a request or by means of successive nested requests of the
form req1(from := c1, to := c)req2(from := c, to := c2).
The last expression deals with data dependency. We say that
c1 depends on c2 if there is a chain of actions from c2 ended
by a request to c1 sharing the same data α. More precisely,
the third expression holds if a component c2 has sent an
action a1(α1) with some data α, if there is a unique sequence
a1(α1) . . . ak(αk) sharing this data and if ak(αk) is a request
whose destination is c1. An immediate consequence of this
expression is that we do not consider component dependencies
when there are several chains of actions all sharing the same
data and addressed to the several components. Yet, we can
observe that there is a data dependency among components,
but we are unable to establish the dependency relations as
several options among the components are possible. Because
of this ambiguity that may bring false relationships, we prefer
to not consider this case.
The component dependencies are detected by the second step
of CkTailv2 and are given under the form of component lists
c1 . . . ck in Deps(SUL). Component dependencies are detected
while Algorithms 1 or 3 build traces by means of the procedures
Extend and data-dependency. The procedure Extend detects
the two ﬁrst component dependency cases of Deﬁnition 3.
It uses the set of pending requests Lreq(σ) to complete the
set Deps(SUL). Indeed, the procedure Extend constructs a
sequence of Lreq(σ) in such a way that it is either one request
(Case C4) or a list of nested requests (Case C3). The procedure
covers the component sequences lc = c1 . . . ckck+1 of Lreq(σ)
and adds the dependency lists in Deps(SUL) (Algorithm 2,
line 15). The procedure data-dependency(ai(αi), S, σ) checks
whether the last expression of Deﬁnition 3 holds. If there is
a unique sequence a1(α1) . . . (ai(αi) sharing the same data
α ∈ data( ai(αi)) and ﬁnished by the request ai(αi) then the
dependency to(ai(αi)).from(a1(α1)) is added to Deps(SUL)
(line 21). If this sequence is a subsequence of the current session
σ.ai(αi), then the procedure also returns true to Algorithms 1
and 3 to indicate that this request must be kept in the current
session.
It is worth noting that Algorithms 1 and 3 slightly differ
in the data dependency detection. Given two components c1
and c2, Algorithm 1 checks whether c1
data
−−−→
σ
c2 holds on the
initial action sequence S. It checks that there is a unique chain
of actions from c2 to c1 in S as it does not know the sessions
in advance. Algorithm 3 does the same veriﬁcation but on
every trace σ of Traces(SUL), which represent sessions. As
a trace σ is usually much shorter than the action sequence S,
c1
data
−−−→
σ
c2 may be satisﬁed more frequently. In other terms,
Algorithm 3 may detect more component dependencies because
the sessions are already given and known.
Figure 4 shows the set Deps(SUL) derived from the action
sequence of Figure 3. Most of the component dependencies
stem from requests. For instance, the component sequence
G1G2d3 is detected from the nested requests req6 req7. Four
data dependencies are detected between d2d1, G2d1 d4d1,
(with the data svalue:=68) and d3G1 (with cmd :=status).
CkTailv2 implements the generation of dependency graphs
from Deps(SUL) with Algorithm 4. The latter partitions
Deps( SUL) to group the dependency lists starting by the
same component into the same subset. This partitioning is
performed with the equivalence relation ∼c on C∗ given by
∀l1, l2 ∈ Deps(SUL), with l1 = c1 . . . ck, l2 = c′
1 . . . c′
k,
l1 ∼c l2 iff c1 = c′
1. Given a partition Ci and a component list
l ∈ Ci, Algorithm 4 builds a path of the DAG Dgi such that
the nth state is labelled by the nth component of l. Algorithm
4 ﬁnally computes the transitive closure of the DAGs to make
all component dependencies visible.
The dependency graphs, which are generated from the set
Deps(SUL) of Figure 4, are depicted in Figure 5. They reﬂect
another window on the architecture of SUL. Indeed, these
graphs show in a readable manner how the components interact
together. They also help identify central components that might
have a strong negative impact on SUL when they integrate
faults.
Algorithm 4: Device Dependency Graphs Generation
input :Deps(SUL)
output :Dependency graph set DG
1 foreach Ci ∈ Deps(SUL)/ ∼c do
2
foreach c1c2 . . . ck ∈ Ci do
3
add the path sc1 → sc2 . . . sck−1 → sck to Dgi;
4
Dg′
i is the transitive closure of Dgi;
5
DG := DG ∪ {Dg′
i};
F. CkTailv2 Step 4: IOLTS Generation
This last step, implemented by Algorithm 5, generates one
IOLTS for every component in C. The algorithm starts by
120
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Algorithm 5: IOLTS Generation
input :T races(SUL)
output :IOLTSs Lc1 . . . Lck
1 T := {};
2 foreach σ = a1(α1) . . . ak(αk) ∈ T races(SUL)) do
3
σ′ := ϵ;
4
foreach ai(αi) ⪯ σ do
5
σ′ := σ′.!ai(αi ∪ {id := from(ai(αi))} \ {time :=
t, session := s});
6
if isReq(ai(αi)) ∨ isResp(ai(αi))) then
7
σ′ := σ′.?ai(αi ∪ {id := to(ai(αi))} \ {time :=
t, session := s});
8
foreach c ∈ C do
9
Tc := Tc ∪ {σ′ \ {a(α) ∈ σ′ | (id := c) /∈ α}
10 foreach Tc with c ∈ C do
11
Generate the IOLTS Lc from Tc;
12
Merge the equivalent states of Lc with kT ail(k = 2, Lc);
transforming the traces to integrate the notions of input and
output. Given a trace a1(α1) . . . ak(αk), every action is doubled
by separating the component source and destination. The source
and the destination are identiﬁed by a new assignment on the
parameter id added to each action. Besides, the timestamps
and session identiﬁers are removed from the assignments to
improve the model generalisation. For a communication action
ai(αi), this step produces a new trace σ′ composed of the
output !ai(αi1) sent by the source of the message, followed
by the input ?ai(αi2) received by the destination (lines 5-7).
Non-communication actions are marked as outputs. Then, this
new trace σ′ is segmented into sub-sequences, each capturing
the behaviours of one component only (lines 8, 9). The trace
set Tc gathers the traces of the component c.
Every trace set Tc is now lifted to the level of IOLTS.
A trace t = a1(α1) . . . ak(αk) ∈ Tc is transformed into the
path q0
a1(α1)
−−−−→ q1 . . . qk−1
(ak(αk)
−−−−−→ q0 such that the states
q1 . . . qk−1 are new states. These paths are joined on the state
q0 to build the IOLTS Lc:
Deﬁnition 4 (IOLTS generation) Let Tc = {t1, . . . , tn} be
a trace set. Lc = ⟨Q, q0, Σ, →⟩ is the IOLTS derived from Tc
where:
• q0 is the initial state.
• Q, Σ, → are deﬁned by the following rule:
ti=a1(α1)...ak(αk)
q0
a1(α1)
−−−−→qi1...qik−1
ak(αk)
−−−−→q0
Finally, Algorithm 5 applies the kTail algorithm to generalise
and reduce the IOLTSs by merging the equivalent states having
the same k-future. We use k = 2 as recommended in [4, 41].
V. EMPIRICAL EVALUATION
The experiments presented in this section aim to evaluate
the capabilities of our algorithms to build models in terms
of precision and performance, compared to the approaches
allowing to learn models of communicating systems. Prior
to this work, we evaluated CkTailv1 along with the tools
CSight [9], Assess [26], and the tool suite proposed in [19]
based upon the tool kbehavior, which we denote LFkbehavior.
Our experimental results, given in [2], showed that Assess
requires assumptions that are strongly different than those
required by the other tools. The main difference for Assess
lies in the fact that the communications among components
are assumed hidden (not available in event logs). Assess tries
to detect implicit calls of components instead, and completes
models with synchronisation actions to express them. When
this assumption does not hold, i.e., when we feed Assess with
event logs including communication messages, we showed that
it builds high imprecise models. Consequently, for this new
evaluation, we have chosen to conduct several experimentations
on CSight, LFkbehavior, CkTailv1 and CkTailv2 (source code
and explanations available in [20]). As our approach uses
two distinct trace extraction algorithms, we have chosen to
differentiate them with the notations CkTailv2-w/oS (Algorithm
1 without session identiﬁer) and CkTailv2-w/S (Algorithm 3
with session identiﬁers).
This evaluation aims at investigating the capabilities of our
algorithms through the following four questions:
• RQ1: can CkTailv2 infer models that capture correct
behaviours of SUL? This question studies the capability
of CkTailv2 to build models that accept valid traces of the
system compared to CSight, CkTailv1 and LFkbehavior.
The valid traces correspond to traces extracted from event
logs but not used for the model generation;
• RQ2: do the models inferred by CkTailv2 reject abnormal
behaviours? RQ2 studies the capability of CkTailv2 to
generate models that reject invalid traces, compared to
CSight, CkTailv1 and LFkbehavior. Invalid traces express
abnormal behaviours of the system;
• RQ3: is CkTailv2 able to detect accurate dependencies
among components? RQ3 investigates the recall and
precision of CkTailv2 to detect component dependencies.
Recall is here the percentage of the real dependencies that
are detected, and precision is the percentage of detected
dependencies that are correct;
• RQ4: what is the performance of CkTailv2 to infer models
compared to the other tools? How does CkTailv2 scale
with the size of the event log?
A. Empirical Setup
To generate models, the considered tools impose different
assumptions, which we examined before our experiments to
avoid any bias. We ran LFkbehavior with the strategy that
segments event logs w.r.t. component identiﬁer, as this is the
only one that can be applied with communicating systems to
build one model per component. CSight does not take event log
as input but trace sets such that every component is associated
to its own trace set. CkTailv1 is more restrictive on the event
log content than LFkbehavior and CkTailv2. For CkTailv1, an
event log must be exclusively composed of communication
events and a request must be associated to one response only.
As a consequence, we have taken into consideration all
these differences through experiments conducted on several
121
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

conﬁgurations. We ﬁrstly assembled and conﬁgured 6 com-
municating systems from a set of 7 commercial devices (3
sensors, 2 gateways, 2 actuators). Each of these systems
contains at least one gateway using the home automation
system Domoticz 1, connected to at least two sensors and
one actuator. The behaviours of the gateway(s) after the receipt
of data from the sensors differ in each conﬁguration. We
monitored these systems and collected event logs of about
2200 events. We denote them Conf1 to Conf6. We also
considered 2 other systems made up of other components to
avoid giving conclusions on similar systems. The ﬁrst one has
8 sensors (4 are commercial devices and the others are based
upon the open source framework EspEasy 2) that periodically
send data to a Cloud server. The second one corresponds to
an IP security camera, which is interconnected to NTP, SMTP
and FTP servers. The corresponding event logs are denoted
Conf7 and Conf8 and respectively include 2206 and 1310
events. All these event logs do not include session identiﬁers.
Hence, we manually modiﬁed them to compare our algorithms
CkTailv2-w/oS and CkTailv2-w/S. The modiﬁcations consisted
in adding a session identiﬁer in every action with regard to the
functioning of the systems. We denote these new event logs
Conf9 to Conf16.
All the tools except CSight take event logs as input. We
experimented CSight after having manually segmented Conf1
to Conf8 into trace sets, but we were unable to get any result
after 5 hours of computation, which was our limit for each
experiment. We observed that the ﬁrst steps of CSight were
achieved, but these were always followed by time-outs. The
last steps of Csight call a model-checker to reﬁne models
with invariants, and we suspect that the model-checker was
unable to check invariant satisﬁability on large trace sets.
Therefore, to compare CSight with the other tools, we took
back two trace sets given with the CSight implementation.
The ﬁrst one, denoted Tcp contains 8 traces (46 events)
collected from two components exchanging TCP messages.
The second trace set denoted AltBit contains 15 traces (246
events) expressing message exchanges between two components
over the Alternating Bit Protocol, which belongs to the family
of reliable transport protocols.
In summary, we considered 18 conﬁgurations. Conf1, 3, 5,
8, Tcp and AltBit are event logs that meet the requirements
of all the tools, and are particularly interesting for comparing
CSight, CkTailV1, LFkbehavior and CkTailv2-w/oS. Conf2,
4, 6, 7 are more general event logs (composed of requests
associated to multiple responses and of non-communication
events) and are used to confront CkTail- v2-w/oS with
LFkbehavior. Finally, Conf9 to 16 allow to compare our
algorithms CkTailv2-w/oS and CkTailv2-w/S.
Furthermore, CkTailv1 and CkTailv2 use the procedure
ontime to check whether an action belongs to a current session
with regard to the session duration. The same procedure, which
is given in Section IV-C, was used for both tools.
1https://www.domoticz.com/
2https://www.letscontrolit.com/
Tcp
AltBit
Conf1
Conf2
Conf3
Conf4
Conf5
Conf6
Conf7
Conf8
Mean
0,00 %
10,00 %
20,00 %
30,00 %
40,00 %
50,00 %
60,00 %
70,00 %
80,00 %
90,00 %
100,00 %
LFkbehavior
CkTailv1
CkTailv2-w/oS
CSight
Fig. 8.
Percentage of valid traces accepted by the models with the
conﬁgurations Tcp, AltBit, Conf1 to 8
B. RQ1: can CkTailv2 infer models that capture correct
behaviours of SUL?
To answer RQ1, we measured the rate of valid traces
accepted by all the behavioural models generated from the 18
conﬁgurations. Given a valid trace σ and an IOLTS L, IOLTS
acceptance means here that σ ∈ Traces(L). To get valid traces,
we chose to follow a Hold Out method, which partitioned each
event log in one training log for the model generation and
one testing log for the extraction of valid traces. We manually
segmented event logs into two parts with an approximative
ratio of 80% and 20%, taking care not to separate actions that
belong to the same session to avoid the generation of incorrect
models.
Afterwards, still to avoid any bias, we extracted valid
trace sets from the testing logs. This trace extraction was
automatically performed for the event logs including session
ids. But for the other event logs, as there is no information
allowing to recognise valid traces, we manually extracted them
by leveraging our knowledge of the case study functioning.
We obtained around 35 to 200 valid traces for Conf1 to 16.
For the conﬁgurations Tcp and AltBit we respectively used
75% of the traces to generate models, the remaining being
used as valid traces.
a) Results: The percentages of valid traces accepted by
the models generated by each tool are illustrated in the bar-
diagrams of Figures 8 and 9. With the conﬁgurations Conf1
to 8, the models that accept the most of valid traces are always
those generated by CkTailv2-w/oS. In our experiments, these
models accept an average of 96.43% of valid traces. The
models given by CkTailv1 and LFkbehavior provide close
results with 66.47% and 63.23%. If we focus on the results
given by CkTailv2-w/oS and CkTailV1, we have the same
rate of valid traces accepted by the models with Conf1, 3,
5 and 8. These similarities come from the fact that these
conﬁgurations meet the assumptions of both tools. The trace
segmentation along with the model generation are hence
performed in a similar manner. As expected, with the other
conﬁgurations, we observe that CkTailv1 produced less correct
122
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Conf9
Conf10
Conf11
Conf12
Conf13
Conf14
Conf15
Conf16
Mean
0,00 %
10,00 %
20,00 %
30,00 %
40,00 %
50,00 %
60,00 %
70,00 %
80,00 %
90,00 %
100,00 %
LFkbehavior
CkTailv1
CkTailv2-w/oS
CkTailv2-w/S
Fig. 9.
Percentage of valid traces accepted by the models with the
conﬁgurations Conf9 to 16
models as it eliminated some actions during the trace extraction.
LFkbehavior outperforms CkTailv1 with Conf2, 4 and 6 for
the same reason.
Figure 8 also shows that the models generated from the
conﬁgurations Tcp and AltBit accept all the valid traces,
whatever the approach used. These results tend to reveal that
the sizes of the event logs used with these conﬁgurations are
not large enough to make distinctions among the approaches.
Therefore, we prefer to not give any conclusion here. As stated
earlier, we were unable to apply CSight on larger trace sets.
Figure 9 shows that when the event logs include sessions
identiﬁers, LFkbehavior and CkTailv1 infer models accepting
the same ratio of valid traces. The interesting observation is
that CkTailv2-w/oS and CkTailv2-w/S provide close results,
i.e., the models given by CkTailv2-w/oS accept slightly less
valid traces only. We recall that CkTailv2-w/S extracts traces
from event logs by means of session identiﬁers (the trace
extraction is always correct) whereas CkTailv2-w/oS tries to
detect sessions for extracting traces. Hence, Figure 9 tends
to show that the trace extraction algorithm of CkTailv2-w/oS
(Algorithm 1) is very effective.
C. RQ2: do the models inferred by CkTailv2 reject abnormal
behaviours?
This research question targets the capability of our algorithms
to infer models that reject incorrect behaviours of the system.
Incorrect behaviours are expressed by means of invalid traces,
which are here derived from valid traces by injecting one of the
following errors: repetition of actions (random addition of 2 to
6 actions), inversion of a request with its associated response(s),
permutation of one request in a sequence of nested requests, and
suppression of one response when several responses associated
to the same request are found.
We generated 16 sets having 43 to 100 invalid traces for each
conﬁguration Conf1 to 16, and two sets of 20 invalid traces
for Tcp and for AltBit. Then, we measured the proportions
of invalid traces accepted by the range of models inferred from
the same conﬁgurations and training sets used for RQ1.
Tcp
AltBit
Conf1
Conf2
Conf3
Conf4
Conf5
Conf6
Conf7
Conf8
Conf9
Conf10
Conf11
Conf12
Conf13
Conf14
Conf15
Conf16
Mean
0,00 %
2,00 %
4,00 %
6,00 %
8,00 %
10,00 %
12,00 %
14,00 %
LFkbehavior
CkTailv1
CkTailv2-w/oS
CkTailv2-w/S
CSight
Fig. 10.
Percentage of invalid traces accepted by the models for each
conﬁguration
a) Results: The bar-diagram of Figure 10 shows the
proportions of invalid traces accepted by the models given
by each tool in each conﬁguration. This ﬁgure reveals that all
the tools performed well in the sense that the inferred models
reject most of the incorrect behaviours. CkTailv1, CkTailv2
and CSight outperform LFkbehavior with some conﬁgurations
though. For instance, LFkbehavior produced models that accept
13.3% of invalid traces with Conf5.
As previously, it remains difﬁcult to compare CSight and
CkTailv2 because only two conﬁgurations Tcp and AltBit
are considered in this evaluation. As CSight uses invariant
satisﬁability to increase the model precision and not CkTailv2,
we believe that CSight should return more precise models, but
only with small trace sets.
The results given with RQ1 and RQ2 tend to indicate that
the models produced by CkTailv2 offer the best precision: not
only they accept the highest ratio of valid traces, but also reject
all the invalid ones (as CSight).
D. RQ3: can CkTailv2 detect accurate dependencies among
components?
This research question investigates the capability of our
algorithms to ﬁnd component dependencies during the event
log analysis. Among the range of tools considered in this
evaluation, only CkTailv1, CkTailv2-w/oS and CkTailv2-w/S
are able to infer dependency graphs, but CkTailv1 and CkTail-
v2-w/oS use the same dependency detection. As a consequence,
we chose to study RQ3 by comparing the DAGs returned
by CkTailv2-w/oS and CkTailv2-w/S to the real dependency
graphs we manually built from the dependency schemes that
we devised for Conf1 to 8, Tcp and AltBit. We evaluated
the recall and precision of both algorithms. A good component
dependency detection is characterised by a high recall and high
precision, where high recall also relates to a low false negative
rate and high precision relates to low false positive rate.
a) Results: Table III shows the number of real component
dependencies for each conﬁguration and the bar-diagram of
Figure 11 depicts the recalls and precisions achieved by
123
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

TABLE III
# REAL DEPENDENCIES FOR EACH CONFIGURATION
Conf1
Conf2
Conf3
Conf4
Conf5
Conf6
Conf7
Conf8
T cp
AltBit
8
8
9
6
8
7
4
10
2
2
0,00%
20,00%
40,00%
60,00%
80,00%
100,00%
Conf1
Conf2
Conf3
Conf4
Conf5
Cong6
Conf7
Conf8
Tcp
AltBit
Recall CkTailv2-w/oS
Precision CkTailv2-w/oS
Recall CkTailv2-w/S
Precision CkTailv2-w/S
Fig. 11. Recall and precision of CkTailv2 to detect component dependencies.
Recall is the percentage of the real dependencies that are detected; precision
is the percentage of detected dependencies that are correct
CkTail- v2-w/oS and CkTailv2-w/S. On average, CkTailv2-
w/oS detected 88% of the real dependencies and CkTailv2-w/S
97.5%. No wrong component dependency is returned by both
algorithms. After inspection, we observed that the undiscovered
dependencies correspond to some data dependencies that can be
observed among several chains of messages sharing the same
data addressed to several components at the same time. We have
chosen in Deﬁnition 3 to not consider them to avoid returning
false dependencies. This case of having chains of messages
sharing the same data addressed to several components is more
frequent with CkTailv2-w/oS as it detects data dependencies on
the action sequence S, while CkTailv2-w/S does it on traces,
which are smaller sequences. As a consequence, the recall of
CkTailv2-w/oS is lower than the one of CkTailv2-w/S.
E. RQ4: what is the performance of CkTailv2 to infer models
compared to the other tools? How does CkTailv2 scale with
the size of the event log?
a) Procedure: To answer RQ4, we ﬁrstly studied how
the tools scale with the size of the event logs. We collected
40 event logs from Conf3 by varying the number of events
between 500 to 10000 events. Then, we measured execution
times to produce models. As CSight did not complete on
Conf3, we considered LFkbehavior, CkTailv1, CkTailv2-w/oS
and CkTailv2-w/S. Besides, ss CkTailv2-w/S has two modes,
i.e., trace extraction with session identiﬁers provided by the
user, and extract of identiﬁers when these are not provided, we
applied both modes on Conf3. For readability, this is denoted
as CkTailv2-w/S and CkTailv2-w/US. To include CSight in our
evaluation, we measured the execution times of all the tools on
Tcp and AltBit. Experiments were carried out on a computer
with 1 Intel R⃝ CPU i5-6500 @ 3.2GHz and 32GB RAM.
Fig. 12. Execution times vs. number of events
Tcp
AltBit
0
2
4
6
8
10
12
14
16
18
20
Execution times in seconds
LFkBehaviour
CkTailv1
CkTailv2-w/oS
CkTailv2-w/S
Csight
Fig. 13. Execution times of the tools with the conﬁgurations Tcp and AltBit
b) Results: Figure 12 depicts the execution times in
seconds of the tools w.r.t. the event log sizes. CkTailv2-w/S
offers the best performance as it produces models in less than 1
second. These results are not surprising as the algorithm splits
event logs quickly thanks to the known session identiﬁers.
LFkbehavior offers close results as it never took more than 2
seconds to produce models. On the other hand, CkTailv1 and
CkTailv2-w/oS required less than 33s and 89s, respectively.
The curve for CkTailv2-w/oS follows a quadratic regression.
The difference between CkTailv1 and CkTailv2-w/oS comes
from the fact that CkTailv2-w/oS uses two set of pending
requests to check if the constraints C1-C5 hold while CkTailv1
needs one set only. The last curve shows execution times with
CkTailv2-w/US. In this case, the curve also follows a quadratic
regression but reveals that our tool does not scale well. Most of
the execution times are consumed by the analysis of the event
logs to recover session identiﬁers. These are indeed retrieved by
testing whether combinations of parameter assignments identify
execution traces w.r.t. the satisﬁability of session patterns and
the evaluation of trace quality metrics.
The bar-diagram of Figure 13 illustrates the execution times
of all the tools on the conﬁgurations Tcp and AltBit. These
results tend to show that CSight is signiﬁcantly slower than the
other tools, it is around 30 times slower than CkTail- v2-w/oS.
Besides, as stated earlier, CSight were unable to return models
after 5 hours with Conf1 to 8.
124
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

These experiments show that CkTailv2 can be used in
practice to infer models of communicating systems even with
large event logs, but it suffers from insufﬁcient scalability, on
account of its feature of detecting sessions for extracting traces.
F. Threat to Validity
Some threats to validity can be identiﬁed in our evaluation.
The ﬁrst factor, which may threaten the external validity of our
results, applies to the case studies used in the experimentations.
Most of them indeed are IoT systems using the HTTP protocol.
We also considered two other event logs collected from
components exchanging messages by means of the TCP and
Alternating bit protocols. But many communicating systems
rely on other kinds of protocols, from which it may be more
difﬁcult to identify senders, receivers, requests or responses.
Hence, our results cannot be generalised to all communicating
systems. This is why we deliberately avoid drawing any
general conclusion. We chose to mainly concentrate our
experimentations on IoT systems that we devised to be able
to appraise the capability of CkTailv2 of inferring correct
dependency graphs. This threat is somewhat mitigated by the
fact that our results can be easily generalised to communicating
systems based upon the HTTP protocol, and that the latter is
used by numerous communicating systems.
The generalisation of our approach is also restricted by the
requirements A1-A3. The event logs have to include timestamps
given by a global clock and must be formatted by means of
regular expressions so that the event types can be identiﬁed.
Although we have observed that this task is not too difﬁcult
to carry out on HTTP messages, it is manifest that this is
not generalisable to any kind of protocols, especially those
encrypting some parts of the message contents. We need to
investigate how these requirements could be relaxed in future
work.
There are also some threats to internal validity. Firstly, like
all the other passive model learning approaches, the larger
the event log, the more complete and precise the models will
be. Furthermore, our approach uses one parameter denoted
T, in the procedure ontime, to limit the session duration.
We set this parameter to 1 or 2 seconds in our experiments
as the session durations was lower than these values in our
case studies. Changing this parameter impacts the precision
of the models though. We assume that the user has some
knowledge about SUL and that he/she can set this parameter
correctly. Otherwise, we suggest to generate several models
while modifying this parameter. We evaluated the precisions
of the models generated from Conf2 with T taking values
between 0 and 150 seconds. Figure 14 illustrates the ratios of
valid and invalid traces accepted by the inferred models. The
ratio of invalid traces remain unchanged. But, the ratio of valid
traces evolves with T. Although the ﬁgure does not allow to
directly deduce the best parameter value as several ones are
possible, it helps avoid choosing the bad ones.
0,00 %
10,00 %
20,00 %
30,00 %
40,00 %
50,00 %
60,00 %
70,00 %
80,00 %
90,00 %
100,00 %
0
20
40
60
80
100
120
140
ratio of accepted traces
T in seconds
Valid traces
Invalid traces
Fig. 14. Impact of the session duration on the model precision
VI. CONCLUSION
This paper has proposed the design and evaluation of a
tool called CkTailv2, which is specialised into the learning of
behavioural models along with dependency graphs from event
logs, themselves collected from of communicating systems.
Compared to other model learning algorithms, CkTailv2
increases the precision of the generated models by integrating
an algorithm that better recognises sessions in event logs with
respect to constraints related to the request-response pattern,
the recognition of nested requests, time delays and component
dependency. Besides, when sessions are explicitly identiﬁed
in event logs, CkTailv2 provides another algorithm to quicker
generate models.
CkTailv2 is simple to use. A user only has to give an event
log and a set of regular expressions as inputs to produce one
IOLTS and one DAG per component of the communicating
system. These models are stored in DOT ﬁles and varied
tools can process them to graphically represent how the
communicating system behaves and is structured. These models
may be then used to detect defects or security vulnerabilities.
Besides, our evaluation showed that CkTailv2 is effective, as
it provides precise models, and that it can be used in practice
on large event logs.
Nevertheless, several aspects need to be investigated and
improved in the future. We ﬁrstly plan to evaluate CkTailv2 on
further kinds of systems to conﬁrm our experimental results.
The latter show that CkTailv2 does not scale well with the
size of the event logs. We believe that the performance can be
improved by devising parallel algorithms. But another way is to
get rid of some requirements, such as the need to have events
that encode senders and receivers. We believe that an additional
event log analysis step could perform this task automatically.
Another direction of future work is to make use of these
models to assist developers in the analysis and test of com-
municating systems. More precisely, we intend to propose an
approach combining this model learning technique with the
generation of mocks, i.e., fake components that simulate real
components and that behave in a predeﬁned way. These mock
components could make test development easier by replacing
125
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

complex dependencies (e.g., infrastructure or environment
related dependencies [42]). Besides, mock components could
increase test efﬁciency by replacing slow-to-access components.
We ﬁnally believe that the models produced by CkTailv2
could be analysed to automatically generate executable mock
components.
VII. ACKNOWLEDGEMENT
Research
supported
by
the
French
Project
VASOC
(Auvergne-Rhˆone-Alpes Region) https://vasoc.limos.fr/
REFERENCES
[1] S. Salva, “Reverse Engineering Models of Concurrent
Communicating Systems From Event Logs,” in Sixteenth
International
Conference
on
Software
Engineering
Advances
ICSEA
2021,
Barcelona,
online,
Spain,
Oct.
2021,
pp.
37–42.
[Online].
Available:
https:
//hal.uca.fr/hal-03444549
[2] S. Salva and E. Blot, “Cktail: Model learning of
communicating systems,” in Proceedings of the 15th
International
Conference
on
Evaluation
of
Novel
Approaches to Software Engineering, ENASE 2020,
Prague, Czech Republic, May 5-6, 2020, R. Ali,
H. Kaindl, and L. A. Maciaszek, Eds.
SCITEPRESS,
2020, pp. 27–38. [Online]. Available: https://doi.org/10.
5220/0009327400270038
[3] A. Biermann and J. Feldman, “On the synthesis of
ﬁnite-state machines from samples of their behavior,”
Computers, IEEE Transactions on, vol. C-21, no. 6, pp.
592–597, June 1972.
[4] D. Lorenzoli, L. Mariani, and M. Pezz`e, “Automatic
generation of software behavioral models,” in Proceed-
ings of the 30th International Conference on Software
Engineering, ser. ICSE’08.
New York, NY, USA: ACM,
2008, pp. 501–510.
[5] F. Pastore, D. Micucci, and L. Mariani, “Timed k-tail:
Automatic inference of timed automata,” in 2017 IEEE
International Conference on Software Testing, Veriﬁcation
and Validation (ICST), March 2017, pp. 401–411.
[6] L. Mariani and M. Pezze, “Dynamic detection of cots
component incompatibility,” IEEE Software, vol. 24, no. 5,
pp. 76–85, 2007.
[7] I. Beschastnikh, Y. Brun, S. Schneider, M. Sloan, and
M. D. Ernst, “Leveraging existing instrumentation to
automatically infer invariant-constrained models,” in Pro-
ceedings of the 19th ACM SIGSOFT Symposium and the
13th European Conference on Foundations of Software
Engineering, ser. ESEC/FSE ’11.
New York, NY, USA:
ACM, 2011, pp. 267–277.
[8] T. Ohmann, M. Herzberg, S. Fiss, A. Halbert, M. Palyart,
I. Beschastnikh, and Y. Brun, “Behavioral resource-aware
model inference,” in Proceedings of the 29th ACM/IEEE
International Conference on Automated Software Engi-
neering, ser. ASE ’14.
New York, NY, USA: ACM,
2014, pp. 19–30.
[9] I.
Beschastnikh,
Y.
Brun,
M.
D.
Ernst,
and
A. Krishnamurthy, “Inferring models of concurrent
systems from logs of their behavior with csight,” in
Proceedings of the 36th International Conference on
Software Engineering, ser. ICSE 2014.
New York, NY,
USA: ACM, 2014, pp. 468–479. [Online]. Available:
http://doi.acm.org/10.1145/2568225.2568246
[10] L. Mariani, M. Pezz`e, and M. Santoro, “Gk-tail+ an
efﬁcient approach to learn software models,” IEEE
Transactions on Software Engineering, vol. 43, no. 8,
pp. 715–738, Aug 2017.
[11] D. Angluin, “Learning regular sets from queries and
counterexamples,” Information and Computation, vol. 75,
no. 2, pp. 87–106, 1987.
[12] P. Dupont, “Incremental regular inference,” in Proceedings
of the Third ICGI-96.
Springer, 1996, pp. 222–237.
[13] H. Raffelt, B. Steffen, and T. Berg, “Learnlib: A library for
automata learning and experimentation,” in Proceedings
of the 10th International Workshop on Formal Methods
for Industrial Critical Systems, ser. FMICS ’05.
New
York, NY, USA: ACM, 2005, pp. 62–71.
[14] R. Alur, P. ˇCern´y, P. Madhusudan, and W. Nam, “Synthe-
sis of interface speciﬁcations for java classes,” SIGPLAN
Not., vol. 40, no. 1, pp. 98–109, Jan. 2005.
[15] T. Berg, B. Jonsson, and H. Raffelt, “Regular inference
for state machines with parameters,” in Fundamental
Approaches to Software Engineering, ser. Lecture Notes
in Computer Science, L. Baresi and R. Heckel, Eds.
Springer Berlin Heidelberg, 2006, vol. 3922, pp. 107–
121.
[16] F. Howar, B. Steffen, B. Jonsson, and S. Cassel, “Infer-
ring canonical register automata,” in Veriﬁcation, Model
Checking, and Abstract Interpretation, ser. Lecture Notes
in Computer Science, V. Kuncak and A. Rybalchenko,
Eds.
Springer Berlin Heidelberg, 2012, vol. 7148, pp.
251–266.
[17] K. Hossen, R. Groz, C. Oriat, and J. Richier, “Automatic
model inference of web applications for security testing,”
in Seventh IEEE International Conference on Software
Testing, Veriﬁcation and Validation, ICST 2014 Workshops
Proceedings, March 31 - April 4, 2014, Cleveland, Ohio,
USA, 2014, pp. 22–23.
[18] A. Petrenko and F. Avellaneda, “Learning communicating
state machines,” in Tests and Proofs - 13th International
Conference, TAP 2019, Held as Part of the Third World
Congress on Formal Methods 2019, Porto, Portugal,
October 9-11, 2019, Proceedings, ser. Lecture Notes in
Computer Science, D. Beyer and C. Keller, Eds., vol.
11823.
Springer, 2019, pp. 112–128. [Online]. Available:
https://doi.org/10.1007/978-3-030-31157-5
[19] L. Mariani and F. Pastore, “Automated identiﬁcation of
failure causes in system logs,” in Software Reliability
Engineering, 2008. ISSRE 2008. 19th International Sym-
posium on, Nov 2008, pp. 117–126.
[20] E. Blot and S. Salva, “The cktailv2 tool,” 2020. [Online].
Available: https://github.com/sasa27/CkTailv2
126
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[21] G. Ammons, R. Bod´ık, and J. R. Larus, “Mining speci-
ﬁcations,” SIGPLAN Not., vol. 37, no. 1, pp. 4–16, Jan.
2002.
[22] B. K. Aichernig and M. Tappler, “Learning from faults:
Mutation testing in active automata learning - mutation
testing in active automata learning,” in NASA Formal
Methods - 9th International Symposium, NFM 2017,
Moffett Field, CA, USA, May 16-18, 2017, Proceedings,
2017, pp. 19–34.
[23] R. Groz, K. Li, A. Petrenko, and M. Shahbaz, “Modular
system veriﬁcation by inference, testing and reachabil-
ity analysis,” in Testing of Software and Communicat-
ing Systems, K. Suzuki, T. Higashino, A. Ulrich, and
T. Hasegawa, Eds.
Berlin, Heidelberg: Springer Berlin
Heidelberg, 2008, pp. 216–233.
[24] M. Tappler, B. K. Aichernig, and R. Bloem, “Model-based
testing iot communication via active automata learning,” in
2017 IEEE International Conference on Software Testing,
Veriﬁcation and Validation (ICST), March 2017, pp. 276–
287.
[25] S. Salva and E. Blot, “Model generation of component-
based systems,” Software Quality Journal, vol. 28, no. 2,
pp. 789–819, June 2020.
[26] ——, “Reverse engineering behavioural models of
iot devices,” in 31st International Conference on
Software Engineering & Knowledge Engineering (SEKE),
Lisbon, Portugal, July 2019. [Online]. Available: https:
//hal-clermont-univ.archives-ouvertes.fr/hal-02134046
[27] ETSI, “Methods for testing & speciﬁcation; risk-based
security assessment and testing methodologies, euro-
pean telecommunications standards institute, technical re-
port, https://www.etsi.org/deliver/etsi eg/203200 203299/
203251/01.01.01 50/eg 203251v010101m.pdf,” 2015.
[28] R. Dssouli, K. Karoui, A. Petrenko, and O. Raﬁq,
“Towards testable communication software,” in Protocol
Test Systems VIII: Proceedings of the IFIP WG6.1 TC6
Eighth International Workshop on Protocol Test Systems,
September 1995, A. Cavalli and S. Budkowski, Eds.
Boston, MA: Springer US, 1996, pp. 237–251.
[29] S. Salva, H. Fouchal, and S. Bloch, “Metrics for timed
systems testing,” in Procedings of the 4th International
Conference on Principles of Distributed Systems, OPODIS
2000, Paris, France, December 20-22, 2000, 2000, pp.
177–200.
[30] E. Blot and S. Salva, “Testability measurments on
inffered models,” 2020. [Online]. Available: https:
//github.com/Elblot/testability
[31] L.
Guti´errez-Madro˜nal,
I.
Medina-Bulo,
and
J. Dom´ınguez-Jim´enez, “Iot–teg: Test event generator sys-
tem,” Journal of Systems and Software, vol. 137, pp. 784–
803, 2018. [Online]. Available: http://www.sciencedirect.
com/science/article/pii/S0164121217301280
[32] A. Ahmad, F. Bouquet, E. Fourneret, F. Le Gall, and
B. Legeard, “Model-based testing as a service for iot
platforms,” in Leveraging Applications of Formal Methods,
Veriﬁcation and Validation: Discussion, Dissemination,
Applications, T. Margaria and B. Steffen, Eds.
Cham:
Springer International Publishing, 2016, pp. 727–742.
[33] S. Salva and E. Blot, “Verifying the application of security
measures in iot software systems with model learning,”
in Proceedings of the 15th 15th International Conference
on Software Technologies, ICSOFT 2020, Paris, France,
july, 2020, 2020, pp. 1–12.
[34] Y. Falcone, M. Jaber, T.-H. Nguyen, M. Bozga, and
S. Bensalem, “Runtime Veriﬁcation of Component-
Based
Systems,”
in
SEFM
2011
-
Proceedings
of
the
9th
International
Conference
on
Software
Engineering and Formal Methods, ser. Lecture Notes in
Computer Science (LNCS), G. Barthe, A. Pardo, and
G. Schneider, Eds., vol. 7041.
Montevideo, Uruguay:
Springer, Nov. 2011, pp. 204–220. [Online]. Available:
https://hal.archives-ouvertes.fr/hal-00642969
[35] M. van der Bijl, A. Rensink, and J. Tretmans, “Com-
positional testing with ioco,” in Formal Approaches to
Software Testing, A. Petrenko and A. Ulrich, Eds. Berlin,
Heidelberg: Springer Berlin Heidelberg, 2004, pp. 86–100.
[36] Q. Fu, J.-G. Lou, Y. Wang, and J. Li, “Execution anomaly
detection in distributed systems through unstructured log
analysis,” 2009 Ninth IEEE International Conference on
Data Mining, pp. 149–158, 2009.
[37] A. Makanju, A. N. Zincir-Heywood, and E. E. Milios, “A
lightweight algorithm for message type extraction in sys-
tem application logs,” IEEE Transactions on Knowledge
and Data Engineering, vol. 24, no. 11, pp. 1921–1936,
Nov 2012.
[38] R. Vaarandi and M. Pihelgas, “Logcluster - a data
clustering and pattern mining algorithm for event logs,”
in 2015 11th International Conference on Network and
Service Management (CNSM), Nov 2015, pp. 1–7.
[39] S. Messaoudi, A. Panichella, D. Bianculli, L. Briand,
and R. Sasnauskas, “A search-based approach for
accurate identiﬁcation of log message formats,” in
Proceedings
of
the
26th
Conference
on
Program
Comprehension,
ser.
ICPC
’18.
New
York,
NY,
USA: ACM, 2018, pp. 167–177. [Online]. Available:
http://doi.acm.org/10.1145/3196321.3196340
[40] J. Zhu, S. He, J. Liu, P. He, Q. Xie, Z. Zheng, and M. R.
Lyu, “Tools and benchmarks for automated log parsing,”
CoRR, vol. abs/1811.03509, 2018. [Online]. Available:
http://arxiv.org/abs/1811.03509
[41] D. Lo, L. Mariani, and M. Santoro, “Learning extended
fsa from software: An empirical assessment,” Journal
of Systems and Software, vol. 85, no. 9, pp. 2063 –
2076, 2012, selected papers from the 2011 Joint Working
IEEE/IFIP Conference on Software Architecture (WICSA
2011). [Online]. Available: http://www.sciencedirect.com/
science/article/pii/S0164121212001008
[42] D. Spadini, M. Aniche, M. Bruntink, and A. Bacchelli,
“Mock objects for testing java systems,” Empirical Softw.
Eng., vol. 24, no. 3, p. 1461–1498, Jun. 2019. [Online].
Available: https://doi.org/10.1007/s10664-018-9663-0
127
International Journal on Advances in Software, vol 15 no 1 & 2, year 2022, http://www.iariajournals.org/software/
2022, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

