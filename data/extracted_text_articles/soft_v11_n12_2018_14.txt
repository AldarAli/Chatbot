An Auto-active Approach to Develop
Correct Logic-based Graph Transformations
Amani Makhlouf, Christian Percebois, Hanh Nhi Tran
University of Toulouse
IRIT Laboratory
Toulouse, France
Email: {Amani.Makhlouf | Christian.Percebois | Hanh-Nhi.Tran}@irit.fr
Abstract—We aim at assisting developers to write, in a Hoare
style, provably correct graph transformations expressed in the
ALCQ Description Logic. Given a postcondition and a transfor-
mation rule, we compute the weakest precondition for developers.
However, the size and quality of this formula may be complex
and hard to grasp. We seek to reduce the weakest precondition’s
complexness by a static analysis based on an alias calculus. The
reﬁned precondition is presented to the developer in terms of
alternative formulae, each one specifying a potential matching of
the source graph. By choosing some alternatives that correspond
to his intention, the developer can interact with an auto-active
program veriﬁer, which continuously ensures the correctness of
the resulting Hoare triple.
Keywords–Graph transformation; weakest precondition calcu-
lus; static analysis; alias calculus; auto-active program veriﬁer.
I.
INTRODUCTION
All approaches applying production rules to a graph require
to implement a binary relation between a source graph and a
target graph. In the theory of algebraic graph transformations,
Habel and Pennemann [2] deﬁned nested graph conditions as a
graphical and logical formalism to specify graph constraints by
explicitly making use of graphs and graph morphisms. Nested
conditions have the same expressive power as Courcelle’s
ﬁrst-order graph logic [2][3][4]. However, they need to be
derived into speciﬁc inference rules in order to be proved
in a speciﬁc theorem-prover that suits them [5][6]. Moreover,
this transformation requires the proof of a sound and complete
proof system for reasoning in the proposed logic.
The proof of the completeness part of Pennemann’s trans-
formation for nested conditions was done by Lambers and
Orejas [7] thanks to a tableau reasoning method. The authors
introduce nested tableaux, an extension of usual tableaux,
to take into account nested conditions. Their proof system
requires an M-adhesive category allowing some compatibility
of pushouts and pullbacks along M-morphisms. Recently,
M-adhesive transformation systems have been generalized to
M, N-adhesive ones [8] to cover graph programs dealing with
node relabeling as done in GP [9].
Another way to express and reason about graph properties
is to directly encode graphs in terms of some existing logic
[10]. This solution leads to consider connections between
graph constraints and ﬁrst-order graph formulae. Adopting this
approach, we deﬁne graphs axiomatically by ALCQ Descrip-
tion Logic (DL) predicates [11] and manipulate them with
speciﬁc statements. In this way, we designed a non-standard
imperative programming language named Small-tALC dedi-
cated to transform labeled directed graphs. The sufﬁx is limited
to ALC because this logic is prototypical of DLs.
Despite the above differences from algebraic graph trans-
formations, we point out the common idea to use satisﬁability
solvers to prove rules’correctness. This technique requires to
assign a predicate transformer to a rule in order to compute
the rule’s weakest precondition. The setup is rather traditional:
given a Hoare triple {P}S{Q}, we compute the weakest
(liberal) precondition wp(S, Q) of the rule transformation
statements S with respect to the postcondition Q, and then
verify the implication P ⇒ wp(S, Q). The correctness of
the rule is proved by a dedicated tableau reasoning, which
is sound, complete and which results in a counter-example
when a failure occurs. This veriﬁcation can be realized in an
auto-active mode [12] where developers annotate their code
with speciﬁcations to facilitate the automatic veriﬁcation of
the program’s correctness. Some veriﬁers like AutoProof [13]
or Dafny [14] use this approach for object-oriented languages.
Aiming to assist developers in writing provably correct
transformations [15], we adopt this auto-active approach to
provide more interactions with developers to produce a Hoare
triple, and thus beneﬁt from their guidance and give them more
feedback. In this context, we propose to statically calculate the
weakest precondition based on an alias calculus in order to
suggest precondition formulae that are easier to understand
but still ensuring the correctness of the Hoare-triple. The
result is presented to developers in a disjunctive normal form.
Each conjunction of positive and negative literals speciﬁes a
potential matching of the source graph. By letting developers
interactively choose a conjunction as a premise that reﬂects
the rule’s intention, our approach can ﬁlter and reduce some
combinatorial issues.
This paper presents an extension of our work originally re-
ported in Proceedings of the Twelfth International Conference
on Software Engineering Advances [1]. Section II ﬁrst deﬁnes
logic-based formulae to annotate pre- and postconditions of
a transformation rule. This choice yields manageable proof
obligations in a Hoare’s style for rules’correctness. Then, we
introduce in Section III Small-tALC atomic statements that
manipulate graph structures. Each statement is characterized
by a weakest precondition with respect to a given postcon-
dition. On the basis of an alias calculus that is presented in
Section IV-A, we show in Section IV-B how to reduce some
combinatorial issues while ensuring the program correctness
147
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

by ﬁnely analyzing the weakest precondition. This leads to an
auto-active veriﬁcation of a Hoare triple, which is sketched
out in Section V. In Section VI we present our integrated
development environment consisting of various tools to assist
developers in writing, executing, testing and reasoning about
graph transformations. We ﬁnally give some discussions on
related work in Section VII and wrap up the paper with a
conclusion and possible improvements in Section VIII.
II.
LOGIC-BASED CONDITIONS
Slightly diverged from the standard approach, we choose
a set-theoretic approach for our transformation system [16].
The basic idea is to specify sets of nodes and edges of
a subgraph using a fragment of ﬁrst-order logic. It turns
out that replacing graph patterns by graph formulae yields
manageable proof obligations for rules’correctness in a Hoare
style {P}S{Q} [10]. A precondition formula P designates
a subgraph matching a substructure that should exist in the
source graph. The postcondition Q requires the existence of
the subgraph represented by Q in the target graph. For instance,
consider a rule requiring that: (1) x must be a node (individual)
not connected by the relation (role) R to a node y; (2) y
is of class (concept) C; (3) x is linked to at most three
successors (qualiﬁed number of restrictions) of class C via
R. This precondition can be expressed by the logic formula
x ¬R y ∧ y : C ∧ x : (≤ 3 R C).
At this point, readers familiar with Description Logics
(DLs) may recognize a DL formula. Labeled directed graphs
can be directly modeled by entities of DLs, a family of logics
for modeling and reasoning about relationships in a domain
of interest [17]. Most DLs are decidable fragments of ﬁrst-
order logic. They are organized around three kinds of entities:
individuals, roles and concepts. Individuals are constants in
the domain, roles are binary relations between individuals
and concepts are sets of individuals. Applied to our graphs,
individuals are nodes labeled with concepts and roles are
edges. Accordingly, pre- and post-assertions are interpreted
as graphs by using unary predicates for nodes and binary
predicates for edges. The correctness of a graph transformation
rule is checked by assigning to each of its statements a
predicate transformer in order to compute the corresponding
weakest precondition.
To design our own experimental graph transformation
language, we chose the ALCQ logic, an extension of the
standard DL Attributive Language with Complements (ALC)
[18], which allows qualifying number restrictions on concepts
(Q). ALCQ is based on a three-tier framework: concepts, facts
and formulae. The concept level enables to determine classes
of individuals (Ø, C, ¬C, C1 ∪ C2 and C1 ∩ C2). The fact
level makes assertions about individuals owned by a concept
(i : C, i : ¬C, i : (≤
n R C) and i : (≥
n R C)), or
involved in a role (i R j and i ¬R j). The third level is about
formulae deﬁned by a Boolean combination of ALCQ facts
(f, ¬f, f1 ∧ f2 and f1 ∨ f2).
Figure 1 depicts a model (graph) satisfying the previous
precondition x ¬R y ∧ y : C ∧ x : (≤
3 R C). In this
graph, the white circles designate the nodes variables x and
y manipulated by the formula. Nodes variables refer (by a
dotted edge) to real nodes represented by black circles. The
«
» node outlines a concept labeled with C. Note that the
subgraph having two anonymous nodes each one outﬁtted with
an incoming edge from x and an outgoing edge to the concept
C is a model, which checks the fact x : (≤ 3 R C).
Figure 1. Model satisfying the precondition
x ¬R y ∧ y : C ∧ x : (≤ 3 R C)
Our formulae contain free variables that assign references
to nodes in a graph. Equality and inequality assertions can be
used to deﬁne constraints on the value of these variables. If x
and y are node variables, x = y means that x and y refer to
the same node and x ̸= y means that x and y are distinct. The
inequality relationship enforces injective graph morphisms.
III.
THE SMALL-TALC LANGUAGE
The ALCQ formulae presented in the previous section have
been plugged into our Small-tALC imperative language and
used in atomic transformation actions on nodes (individuals)
and edges (roles), as well as in traditional control-ﬂow con-
structs as loops (while) and conditions (if...then...else...). In
the transformation code, statements manipulate node variables,
which are bound to the host graph’s nodes during the trans-
formation’s execution.
We have deﬁned ﬁve atomic Small-tALC statements ac-
cording to the following grammar where i and j are node
variables, C is a concept name, R is a role name, F is an
ALCQ formula and v is a list of node variables:
atomic_statement ::=
add(i : C)
(node labeling)
| delete(i : C)
(node unlabeling)
| add(i R j)
(edge labeling)
| delete(i R j)
(edge unlabeling)
| select v with F
(assignment)
The ﬁrst four statements modify the graph structure by
changing the labeling of nodes and edges. Note that since we
consider a set-theoretic approach, the statements add(i : C)
and add(i R j) have no effects if i belongs to the set C
and (i, j) to R respectively. Hence, no parallel edges with the
same label are allowed. An original construct is the select
statement that non-deterministically binds node variables to
nodes in the subgraph that satisﬁes a logic formula. This
assignment is used to handle the selection of speciﬁc nodes
where the transformations are requested to occur. For instance,
select i with i : C selects a node labeled with C. If the
selection is satisﬁed the execution continues normally with the
value of the node variable i. Otherwise, the execution meets
an error situation.
A Small-tALC program is organized into rules. A rule
is structured into three parts: a precondition, the transforma-
tion code and a postcondition. Small-tALC uses the classical
control structures to enable sequential composition, branching
148
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

and iteration of the atomic statements. Inside a rule, the
developer can write an ordered list of statements s1; s2; use
the statements if or if − else to express a choice between
alternatives or the statement while for repeating actions. We
illustrate in Figure 3 an example of a transformation rule
written in Small-tALC. The rule r ﬁrst selects a node n of
concept A that is R-linked to a. Then, it deletes this link and
removes a from the concept A.
rule r {
pre: (a : A) ∧ a : (≥ 3 R A);
select n with (a R n) ∧ (n : A);
delete(a R n);
delete(a : A);
post: (a : ¬A) ∧ a : (≥ 2 R A);
}
Figure 3. Example of a Small-tALC rule
The inference rules in Figure 2 deﬁne the axiomatic se-
mantics of Small-tALC. Each rule consists of a premise and
a conclusion separated by a horizontal bar. Some ones display
prominently the substitutions in the form P[E\V ] to indicate
that V is replaced by E in P when updating nodes and edges
of a graph. For instance, the inference rule ADDC can be
interpreted that if the assertion P is valid when substituting the
concept C +i for the concept C then P is valid after executing
the statement add(i : C). We can say that ADDC is similar
to the rule deﬁning the semantics of the assignment V := E
in traditional imperative programs. The same observation can
be done for DELC deﬁning the semantics of the statement
delete(i : C), which modiﬁes the interpretation for C in order
to delete the node denoted by i. Rules ADDR and DELR deﬁne
the semantics of add(i R j) and delete(i R j) to add and
delete respectively a pair of nodes (i, j) to/from the set of
pairs connected by R.
The rules SEQ, IF, IF-ELSE and WHILE give the semantics
for the Small-tALC control structures. Conditionals in Small-
tALC are speciﬁc DL predicates, which can be considered as
Booleans queries on a knowledge base of concept assertions
and role assertions. Evaluating a conditional Boolean expres-
sion is without side-effects. The statement select v with F
is more speciﬁc. As we seek and assign individuals when
checking the formula F, the inference rule SELECT speciﬁes
that any choice for a list v of nodes that satisﬁes the condition
F must provide the postcondition Q assuming the precondition
P. If no instance satisﬁes F, the semantics is blocked.
To shape a sequencing of transformation steps, Small-tALC
rules will be called inside the main function, which is the
entry-point of a Small-tALC program. Two separate axiomatic
deﬁnitions CALL and CALL! are deﬁned for rule invocations
inside the main function. Given a rule r and a statement S, we
denote body(r) = S in order to ascertain the logical relation of
assertions around the execution of the body of r. Note that in
Small-tALC we only consider rules without parameters. The
inference rule CALL refers to a simple rule invocation and says
that if we can show that the relation {P}S{Q} is true where
S = body(r), then the relation {P}r{Q} is true. Thanks to
the inference rule CALL!, a body of a rule can be executed
many times. Such a call corresponds to an iteration as long as
a subgraph matches the rule’s precondition formula. To express
the semantics of CALL!, we conclude that the current rule call
is correct (i.e., {P}r{Q}) if we assume that the previous calls
are correct as well (i.e., {P}r{Q} ⊢ {P}S{Q}, which can be
interpreted as followed: the sentence {P}S{Q} is a syntactic
consequence (⊢) of the assumption {P}r{Q}).
We aim at using a Hoare-like calculus to prove that Small-
tALC graph programs are correct. This veriﬁcation process
is based on a weakest (liberal) precondition (wp) calculus
[19]. Each Small-tALC statement S is assigned to a predicate
transformer yielding an ALCQ formula wp(S, Q) assuming
{P[C + i \ C]} add (i : C) {P} (ADDC)
{P[C − i \ C]} delete (i : C) {P} (DELC)
{P[R + (i, j) \ R]} add (i R j) {P} (ADDR)
{P[R − (i, j) \ R]} delete (i R j) {P} (DELR)
P ∧ ∀v(F ⇒ Q)
{P} select v with F {Q} (SELECT)
{P} s1 {Q}
{Q} s2 {R}
{P} s1; s2 {R}
(SEQ)
{P ∧ c} s {Q}
{P ∧ ¬c} ⇒ {Q}
{P} if c then s {Q}
(IF)
{P ∧ c} s1 {Q}
{P ∧ ¬c} s2 {Q}
{P} if c then s1 else s2 {Q}
(IF-ELSE)
{P ∧ c} s {P}
{P} while c do s {P ∧ ¬c} (WHILE)
{P} S {Q}
body(r) = S
{P} r {Q}
(CALL)
{P} r {Q} ⊢ {P} S {Q}
body(r) = S
{P} r {Q}
(CALL!)
Figure 2. Axiomatic semantics of Small-tALC
149
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

the postcondition Q. The correctness of a program prg with
respect to Q is established by proving that the given precon-
dition P implies the weakest precondition: every model that
satisﬁes P also satisﬁes wp(prg, Q). Weakest preconditions of
Small-tALC statements are given in Figure 4.
wp(add (i : C), Q) = Q[C + i\C]
wp(delete (i : C), Q) = Q[C − i\C]
wp(add (i R j), Q) = Q[R + (i, j)\R]
wp(delete (i R j), Q) = Q[R − (i, j)\R]
wp(select v with F, Q) = ∀v(F ⇒ Q)
wp(s1; s2, Q) = wp(s1, wp(s2, Q))
wp(if c then s1, Q) = (c ⇒ wp(s1, Q)) ∧ (¬c ⇒ Q)
wp(if c then s1 else s2, Q) = (c ⇒ wp(s1, Q))
∧ (¬c ⇒ wp(s2, Q))
wp({inv} while c do s, Q) = inv
Figure 4. Small-tALC weakest preconditions
Small-tALC axiomatic semantics for add and delete state-
ments introduces substitutions, which build formulae that no
longer belong to the ALCQ logic: C + i in ADDC, C − i
in DELC, R + (i, j) in ADDR and R − (i, j) in DELR do
not represent concepts and roles anymore. This means that
the weakest precondition calculus computes predicates, which
are not closed under substitutions with respect to ALCQ
[20]. To resolve this situation, substitutions are considered as
constructors for concepts and roles and should be eliminated
by predicate transformers. For instance:
wp(add(i : C), x : C) = x : C[C + i\C]
= x : (C + i)
= x : C ∨ x = i.
IV.
SPECIFICATION EXTRACTION
The conventional precondition calculus presented in the
previous section does not take into account particular situations
of a transformation program and thus may result in a complex
precondition. In this section, we look at how the precondition’s
formula can be improved to be more speciﬁc and simple on
the basis of alias calculus.
A. Alias calculus
The principle of alias calculus was proposed by Bertrand
Meyer in order to decide whether two reference expressions
appearing in a program might, during some execution, have the
same value, meaning that the associated references are attached
to the same object [21].
Since our rewriting system allows non-injective mor-
phisms, two or more node variables may reference to the same
node in a graph. On the other hand, a node variable can be
assigned to a random node of the graph. This is one reason why
a Small-tALC formula can be represented by several graph
patterns. For example, Figure 5 shows two potential models
satisfying the formula x : C ∧ y R z. In Figure 5a, y and z
refer to the same node. In 5b, y and z are different but x and
y are combined.
In this regard, for a transformation program, we apply an
alias calculus to determine the node variables that can never
refer to the same node. Discerning such speciﬁc circumstances
helps to discard later unsatisﬁed subformulae of the weakest
precondition. Thus, our method consists in assigning to each
node variable x, a set of other node variables that may reference
(a) y = z, x ̸= y
(b) y ̸= z, x = y
Figure 5. Example of models satisfying the formula x : C ∧ y R z
to the same node in the graph as x. We identify four atomic
conditions in which two individuals x and y can never refer to
the same node in the graph:
•
x ̸= y
•
∃C /x : C ∧ y : ¬C
•
∃R.∃z /x R z ∧ y ¬R z
•
∃R.∃z /z R x ∧ z ¬R y
The ﬁrst case (x ̸= y) states that x and y are naturally
distinct so they can never be assigned to the same node. The
second one asserts that x and y belong to two complement
subsets C and ¬C. The same applies to the last two cases
where the nodes connected by R and ¬R refer to two disjoint
subsets R and ¬R.
For each of the above four conditions, x and y are said
to be non-possibly equivalent nodes. We note this relation by
x ̸≃ y. As a result we assert that x ̸≃ y ⇒ x ̸= y. However, no
conclusion can be drawn from the possibly equivalent relation
x ≃ y.
Consider, as a simple example, the following formula that
is presented in the disjunctive normal form: (x = y ∧x R y)∨
(x : C ∧ x ¬R y), and suppose that a static analysis deduces
from the code that x and y are non-possibly equivalent, which
means that x ̸= y. As a result, the initial formula can be
reduced to x : C ∧ x ¬R y because the ﬁrst conjunction x =
y
∧ x R y can never be true in this case. In the section
that follows, we show how this calculus helps in reducing the
complexness of the weakest precondition.
B. Precondition extraction
To formally verify the correctness of a Small-tALC graph
transformation, besides the code, the program’s pre- and post-
conditions must be properly speciﬁed. This task may not be
easy for novice developers, so a suggestion of a valid precon-
dition that corresponds to a given code and a postcondition
would be useful to them.
Since the computed weakest precondition is often very
complex and hard to comprehend, we propose a ﬁner static
analysis on the basis of the alias calculus of the program to
achieve a simpler precondition. The resulting precondition P
is presented in a disjunctive normal form (DNF) where each
conjunction of P can be considered as a valid precondition
on its own. The analysis consists ﬁrst in converting the
postcondition Q to DNF, i.e., Q = ∨Qi where Qi = ∧qj is a
conjunction of facts, then calculating for each statement and
for each conjunction Qi the weakest precondition. This process
maintains correctness because wp(S, Q1) ∨ wp(S, Q2) ⇒
wp(S, Q1 ∨ Q2). In each and every step, the formula of the
150
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

wp(S, Qi) may be ﬁltered by discarding subformulae accord-
ing to the identiﬁed non-possibly equivalent node variables.
A precondition P is obtained such that P ⇒ wp(prg, Q),
which makes the transformation program prg correct. This
process is applied to add and delete statements as detailed in
Section IV-B1. Regarding the select statement, wp is reduced
differently as presented later in Section IV-B2.
1) The add and delete statements:
Let us consider ﬁrst the add(i : C) statement. Its weakest
precondition with respect to the postcondition x : C is x :
C ∨ x = i, which means that either the node x was already of
concept C before adding i to C, or x and i are equal. Knowing
that x and i are non-possibly equivalent, it can be stated that
x ̸= i, and so the weakest precondition can be reduced to the
ﬁrst subformula x : C of the disjunction.
A more glaring example is reducing the weakest pre-
condition of the add(i R j) statement with respect to the
postcondition Q = x : (≤
n R C), which indicates that
there are at most n edges labeled R outgoing from the node
x to nodes of concept C. Adding an R-edge between i and
j may have a direct impact on Q regarding the concept of j,
the existence of a relation between i and j and the equality
between i and x.
Hence, wp(add(i R j), x : (≤ n R C)) =
(x = i ∧ j : C ∧ i ¬R j ∧ x : (≤ (n − 1) R C))
∨ (x ̸= i ∧ x : (≤ n R C))
∨ (j : ¬C ∧ x : (≤ n R C))
∨ (i R j ∧ x : (≤ n R C))
∨ (x : (≤ (n − 1) R C))
Knowing that x ̸≃ i or j : ¬C, the ﬁrst conjunction x =
i ∧ j : C ∧ i ¬R j ∧ x : (≤ (n−1) R C) can be discarded
as it will never be satisﬁed in this case. Furthermore, the whole
formula of the wp can be reduced to x : (≤ n R C) according
to the second and third conjunctions, which indicate that the
number of restrictions remains unchanged in case one of these
two conditions is satisﬁed.
We illustrated how to reduce the wp with respect to a
postcondition composed of a single fact. In case of a postcon-
dition consisting of a conjunction of facts, only the facts that
manipulate the same concepts and roles given in the statement
parameters are identiﬁed as a ﬁrst step. For example, adding
an instance to a concept (add(i : C)) results in considering
in the given postcondition only the facts that manipulate this
concept (x : C, x : ¬C, x : (≤ n R C)).
Tables I and III represent the preconditions calculated
by our static analyzer for the statement add(i
:
C) and
add(i R j) respectively. For each statement s, we show in
the second column the facts that should be identiﬁed in the
postcondition to derive a precondition. The third column shows
the standard weakest precondition wp(s, f) of the statement s
with respect to an identiﬁed fact f. To simplify this formula,
we present in the fourth column the conditions that allow to
discard some conjunctive clauses of the wp. The resulting
formula is presented in the last column.
Consider the ﬁrst row of the Table III. If a fact x R y
is identiﬁed within the postcondition during calculation, we
look for simplifying wp(add(i R j), x R y) = (x = i ∧ y =
j) ∨ x R y. If the alias calculus asserts that at least one of the
conditions x ̸≃ i or y ̸≃ j is true, wp is reduced to x R y.
As observed in Tables I and III, many complex disjunctions
in the wp can be reduced to only one conjunction on the basis
of a condition calculated by the alias calculus or a condition
given explicitly in the postcondition. Note that the results of
the delete(i : C) and delete(i R j) statements are similar to the
add statements and are respectively described in Tables II and
IV.
2) The select statement:
So far, the static analysis transforms the predicate Q into a new
predicate P regarding statements already presented. However,
it operates differently when it comes to the select statement
where wp(select v with F, Q) = ∀v (F ⇒ Q). The weakest
precondition here involves two formulae that may be complex:
F given by the select, and the postcondition Q. Consequently,
the implication F ⇒ Q makes the wp more obscure for the
developer. In this case, the static analyzer simpliﬁes the wp by
eliminating this implication as further detailed below.
For each conjunction Qi of the postcondition Q, the
static analysis isolates ﬁrst the facts that manipulate the node
variables v of the select statement. Let Qiv be the conjunctive
formula of these identiﬁed facts, and Qiv′ the conjunctive
formula of the others facts, so that Qi = Qiv ∧ Qiv′. For
example, given a formula Q1 = x R y∧y : C and the statement
select x with x : C, we have Q1v = x R y and Q1v′ = y : C.
Then, the static analysis checks, via our logic formula
evaluator, if the implication ∀v (F ⇒ Qiv) holds. If so, the
precondition wp(select v with F, Qi) = ∀v (F ⇒ Qi) is re-
duced to Qi without affecting the validity of the Hoare triple as
Qi ⇒ wp(select v with F, Qi). Conversely, the non-validity
of the implication ∀v (F ⇒ Qiv) results in transforming Qi
to the predicate false (⊥) so that nothing can be concluded
about the transformation correctness. This situation is meant
to warn the developer that there are inconsistencies in his
transformation between the select statement and the predicate
formula Q. These cases are given in Table V for a conjunctive
formula Qi.
To clarify the idea, consider an example of a code consist-
ing of the statement select i with i : C. First, suppose that
the given postcondition is Q = (i : C) ∧ (j : C). So we have
F = i : C and Qv = i : C as i : C is the only fact that
manipulates the selected node variable i in the postcondition.
The implication i : C ⇒ i : C is obviously true, so the
precondition is reduced to Q.
Now consider another postcondition for the same code: Q =
(i R j) ∧ (j : C). In this case, the implication between
F = i : C and Qv = i R j does not hold. Hence, the
static analyzer returns false as a precondition, and so this
transformation can not be executed because no state can satisfy
the precondition as mentioned above.
3) The other statements:
We presented how the static analyzer ﬁlters the weakest
precondition of an atomic statement with respect to each con-
junction Qi = ∧qj of Q where Q = ∨Qi. The precondition P
of a sequence of statements s1; s2 is computed conventionally
as it is presented above (wp(s1, wp(s2, Q))). Similarly, the
extracted precondition of the if c then s1 else s2 statement
is its weakest precondition transformed into a DNF formula:
(c ∧ wp(s1, Q)) ∨ (¬c ∧ wp(s2, Q)).
Apart from loops, weakest preconditions can be com-
puted automatically as it is presented in this section. How-
151
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

TABLE I. WEAKEST PRECONDITION’S FILTERING FOR THE add(i : C) STATEMENT
Statement
Identiﬁed fact
wp
Condition
Precondition
add(i : C)
x : C
x : C ∨ x = i
x ̸≃ i
x : C
x : ¬C
x : ¬C ∧ x ̸= i
x ̸≃ i
x : ¬C
x : (≤ n R C)
(x R i ∧ i : ¬C ∧ x : (≤ (n − 1) R C))
∨ (x ¬R i ∧ x : (≤ n R C))
∨ (i : C ∧ x : (≤ n R C))
∨ (x : (≤ (n − 1) R C))
x ¬R i
x : (≤ n R C)
TABLE II. WEAKEST PRECONDITION’S FILTERING FOR THE delete(i : C) STATEMENT
Statement
Identiﬁed fact
wp
Condition
Precondition
delete(i : C)
x : ¬C
x : ¬C ∨ x = i
x ̸≃ i
x : ¬C
x : C
x : C ∧ x ̸= i
x ̸≃ i
x : ¬C
x : (≥ n r C)
(x r i ∧ i : C ∧ x : (≥ n + 1 r C))
x ¬r y
x : (≥ n r C)
∨(x ¬r i ∧ x : (≥ n r C))
∨(i : ¬C ∧ x : (≥ n r C))
∨(x : (≥ n + 1 r C))
TABLE III. WEAKEST PRECONDITION’S FILTERING FOR THE add(i R j) STATEMENT
Statement
Identiﬁed fact
wp
Condition
Precondition
add(i R j)
x R y
(x = i ∧ y = j) ∨ x R y
x ̸≃ i ∨ y ̸≃ j
x R y
x ¬R y
(x ̸= i ∨ y ̸= j) ∧ (x ¬R y)
x ̸≃ i ∨ y ̸≃ j
x ¬R y
x : (≤ n R C)
(x = i ∧ j : C ∧ i ¬R j ∧ x : (≤ (n − 1) R C))
∨ (x ̸= i ∧ x : (≤ n R C))
∨ (j : ¬C ∧ x : (≤ n R C))
∨ (i R j ∧ x : (≤ n R C))
∨ (x : (≤ (n − 1) R C))
x ̸≃ i ∨ j : ¬C
x : (≤ n R C)
TABLE IV. WEAKEST PRECONDITION’S FILTERING FOR THE delete(i R j) STATEMENT
Statement
Identiﬁed fact
wp
Condition
Precondition
delete(i R j)
x ¬R y
(x = i ∧ y = j) ∨ x ¬R y
x ̸≃ i ∨ y ̸≃ j
x ¬R y
x R y
(x ̸= i ∨ y ̸= j) ∧ (x R y)
x ̸≃ i ∨ y ̸≃ j
x R y
x : (≥ n R C)
(x = i ∧ j : C ∧ i R j ∧ x : (≥ n + 1 R C))
x ̸≃ i ∨ j : ¬C
x : (≥ n R C)
∨(x ̸= i ∧ x : (≥ n R C))
∨(j : ¬C ∧ x : (≥ n R C))
∨(i ¬R j ∧ x : (≥ n R C))
∨(x : (≥ n + 1 R C))
TABLE V. REDUCING THE WP OF THE select STATEMENT
Statement
Postcondition
wp
Condition
Precondition
select v with F
Qi
∀v (F ⇒ Qi)
∀v (F ⇒ Qiv)
Qi
∀v (F ̸⇒ Qiv)
⊥
ever, it is more complicated when it comes to the while
statement. In fact, while c do s is semantically equiva-
lent to if c then {s; while c do s} else skip, then its
weakest precondition is a recursive equation of the form:
wp(while c do s, Q) = (c ⇒ wp(s, wp(while c do s, Q))) ∨
(¬c ⇒ Q). For this reason, the weakest precondition is
approximated by a veriﬁcation condition, which considers
the invariant of the while statement as it is shown in the
152
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

TABLE VI. VERIFICATION CONDITION OF THE while STATEMENT
Statement
Postcondition
Veriﬁcation condition
Precondition
{inv} while c do s
Q
(inv ∧ ¬c ⇒ Q)
∧ (inv ∧ c ⇒ wp(s, inv))
∧ inv
DNF(inv)
else
⊥
third column of the Table VI. Basing on the given invariant
inv, our logic formula evaluator checks whether all of the
implications presented in the third column hold. In this case,
the precondition of the loop is simpliﬁed by inv. Otherwise,
Q is transformed into the predicate false (⊥) as the given
invariant does not satisfy the loop veriﬁcation condition.
The ﬁnal result of the precondition will be presented as
a DNF formula that expresses different possible alternatives.
Each alternative represents a conjunction of facts, constituting
a graph that matches a subgraph of the source graph on which
the transformation rule is applied.
We ﬁlter the weakest precondition by discarding conjunc-
tive clauses that are invalid. This reduction leads to a precon-
dition P stronger than the weakest precondition wp(S, Q). In
particular, when two node variables are non-possibly equiva-
lent, a deductive reasoning is carried out by applying equiv-
alence and implication connectives between P and wp(S, Q).
We adopt a similar deduction for a node variable belonging
to a concept complement and for a role complement. Using
these deductions and the well-behaved wp properties, such as
distributivity of conjunction and disjunction, we construct the
formula P, which satisﬁes the implication P ⇒ wp(S, Q) so
that the triple {P}S{Q} is always correct-by-construction.
V.
AUTO-ACTIVE VERIFIER
Different techniques pertaining to formal program veriﬁ-
cation exist. An automatic veriﬁcation requires no interaction
with developers; a solver performs autonomously the formal
veriﬁcation of a program. However, it provides weak feed-
back in case of failure. Conversely, an interactive veriﬁcation
requires an expert to guide the proof assistant through its
manipulations to perform the veriﬁcation.
Since our purpose is to help a novice developer to achieve
a correct transformation, we adopt an auto-active veriﬁcation
approach, which lies between automatic and interactive veri-
ﬁcation [12]. The auto-active approach expects a developer to
annotate his code with speciﬁcations, then the veriﬁcation will
be done automatically. The process can be repeated in many
iterations until the program is proved.
The auto-active approach has two main advantages: on
the one hand it promotes an incremental development with
rich feedback at each step, on the other hand it bridges the
gap between a non-expert developer and a formal veriﬁcation
tool. This technique is used by AutoProof, part of EVE (Eiffel
Veriﬁcation Environment) to verify Eiffel programs [13], and
by Dafny to verify functional correctness of Dafny programs
[14].
In the next, an example of an incremental development
for constructing a correct transformation program with the
assistance of our auto-active veriﬁer will be described.
A. Incremental Developement
Algorithm 1 shows an example of an incremental devel-
opment using the auto-active approach to help developers
construct speciﬁcations and reﬁne the transformation triple.
The idea is alternating the intervention of the static analyzer
with the developer’s in a progressive process until achieving
ﬁnally a correct-by-construction triple.
Since the static analyzer calculates many conjunctions as
preconditions with respect to a code and a postcondition as
explained in Section IV, the number of extracted preconditions
may be sizable. In this sense, using an interactive process to
enable developers express more precisely their intention can
help reduce the number of the extracted conjunctions given by
the static analyzer.
Input: Code, Post
Output: Pre
repeat
/* by Static Analyzer
*/
E_Pre = extractedPre(Code, Post);
/* by Developer
*/
S_Pre = selectConjunctions(E_Pre);
if isCorespondToIntention(S_Pre) then
Pre = selectPrecondition(S_Pre);
else
refineCodeAndPost(Code, Post, S_Pre);
until isV alid(Pre, Code, Post);
Algorithm 1: Example of an incremental development with
Auto-active Veriﬁer
First, the static analyzer suggests a precondition formula in
the disjunctive normal form. Then the developer selects some
of the suggested conjunctions that reﬂect his intention. If he is
satisﬁed with the selection, the developer can take directly the
chosen conjunctions as the ﬁnal precondition and terminate the
iteration. If not, the developer can reﬁne his code or/and his
postcondition to clarify his intention then starts a new iteration.
In general, the developer can update his transformation code or
reﬁne his speciﬁcation by injecting into them the facts of the
chosen conjunctions. In this way, the transformation program
is incrementally enhanced based on the developer’s intention.
B. Example
In order to illustrate the application of our auto-active
veriﬁer in the proposed incremental process, we present in this
section an example based on the development of an application
simulating the activities of a hospital [22].
In this application, we consider Patients and Doctors
in a hospital composed of several Departments. Each
153
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

doctor works in (denoted by worksIn) a department and
treats patients. Each department is directed by (denoted by
directedBy) a head who is one among its doctors. Each
department is in charge of (denoted by inChargeOf) some
diseases and registers the patients (denoted by registers) who
suffer one of those diseases. A hospitalized patient has a
reference doctor (denoted by refDr) and is allocated (denoted
by allocated) a Room.
Supposed that a graph is used to represent different con-
cepts and individuals in the hospital. The following scenarios
illustrate a development process of a novice developer to write
a graph transformation for updating the hospital’s status when
patients arrive. We suppose that the developer does not write
immediately a correct Hoare triple, but needs many iterations
to reﬁne his program with the static analyzer’s help.
Rule assignDoctor
At the ﬁrst step, the developer wants to write the rule
assignDoctor to assign a doctor dr to treating a patient p.
He writes thus the rule’s code to add the relations treats and
refDr between the patient p and the doctor dr.
The chosen doctor dr has to work in the department dep
where the patient p is registered. Moreover, a doctor who
is head of a department can not treat more than 3 patients
simultaneously. Considering these constraints, the developer
writes the ﬁrst version of his rule as shown in Figure 6.
rule assignDoctor {
add(dr treats p);
add(p refDr dr);
post: p : Patient ∧ dr : Doctor
∧ dep : Department
∧ dep registers p ∧ dr worksIn dep
∧ head : Doctor ∧ dep directedBy head
∧ head : (≤ 3 treats Patient)
∧ dr treats p ∧ p : (≤ 1 refDr Doctor);
}
Figure 6. Rule assignDoctor - First version
To complete the rule assignDoctor, the developer uses the
static analyzer to extract a precondition. From the program in
Figure 6, the static analyzer proposes the twelve following
conjunctions as possible preconditions:
1) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ head : (≤ 2 treats Patient)
∧ p : (≤ 0 refDr Doctor)
2) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ head : (≤ 2 treats Patient)
∧ p !refDr dr
∧ p : (≤ 0 refDr Doctor)
3) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ head : (≤ 2 treats Patient)
∧ p refDr dr
∧ p : (≤ 1 refDr Doctor)
4) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ dr ̸= head
∧ head : (≤ 3 treats Patient)
∧ p : (≤ 0 refDr Doctor)
5) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ dr treats p
∧ head : (≤ 3 treats Patient)
∧ p : (≤ 0 refDr Doctor)
6) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ dr !treats p
∧ dr = head
∧ head : (≤ 2 treats Patient)
∧ p : (≤ 0 refDr Doctor)
7) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ dr treats p
∧ p !refDr dr
∧ head : (≤ 3 treats Patient)
∧ p : (≤ 0 refDr Doctor)
8) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ dr ̸= head
∧ p !refDr dr
∧ head : (≤ 3 treats Patient)
∧ p : (≤ 0 refDr Doctor)
9) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ dr ̸= head
∧ p refDr dr
∧ head : (≤ 3 treats Patient)
∧ p : (≤ 1 refDr Doctor)
10) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ dr treats p
∧ p refDr dr
∧ head : (≤ 3 treats Patient)
∧ p : (≤ 1 refDr Doctor)
11) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ dr !treats p ∧ p refDr dr
∧ dr = head
∧ head : (≤ 2 treats Patient)
∧ p : (≤ 1 refDr Doctor)
154
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

12) p : Patient ∧ dr : Doctor ∧ dep : Department
∧ dr worksIn dep ∧ dep registers p
∧ head : Doctor ∧ dep directedBy head
∧ dr !treats p
∧ p !refDr dr
∧ dr = head
∧ head : (≤ 2 treats Patient)
∧ p : (≤ 0 refDr Doctor)
Among these conjunctions, eight formulae contain the fact
p : (≤ 0 refDr Doctor) stating that the examined patient
p does not have yet a reference doctor. This fact reﬂects
the developer’s precondition regarding a patient, thus ﬁrst
he selects the formulae 1, 2, 4, 5, 6, 7, 8, 12 as possible
preconditions.
Now, to treat a patient p, the developer wants to choose
a doctor who is not in charge of the department. To clarify
his intention and help the static analyzer reduce the number of
extracted conjunctions, the developer injects a select statement
into his code in order to choose the instance dr that is distinct
from the instance head. Figure 7 shows the modiﬁed body of
the rule assignDoctor.
select dr with
dr : Doctor ∧ dr worksIn dep ∧ dr ̸= head;
add(dr treats p);
add(p refDr dr);
Figure 7. Reﬁned code of the rule assignDoctor
Using again the static analyzer with this new code, only
one precondition is extracted. It is taken directly by the
developer as the precondition of his rule. The ﬁnal complete
rule assignDoctor is shown in Figure 8.
rule assignDoctor {
pre: p : Patient ∧ dep : Department
∧ dep registers p ∧ head : Doctor
∧ dep directedBy head
∧ head : (≤ 3 treats Patient)
∧ p : (≤ 0 refDr Doctor);
select dr with
dr : Doctor ∧ dr worksIn dep ∧ dr ̸= head;
add(dr treats p);
add(p refDr dr);
post: p : Patient ∧ dr : Doctor
∧ dep : Department
∧ dep registers p ∧ dr worksIn dep
∧ head : Doctor ∧ dep directedBy head
∧ head : (≤ 3 treats Patient)
∧ dr treats p ∧ p : (≤ 1 refDr Doctor);
}
Figure 8. Rule assignDoctor - Final version
Rule registerPatient
The rule assignDoctor assumes that the examined patient
is already registered in a department. This means that before
calling assignDoctor another rule is needed to register the
patient. For this purpose, the developer now writes the rule
registerPatient to receive and place a patient in an appro-
priate department according to his illness.
Because registerPatient precedes assignDoctor, the
postcondition of the rule registerPatient must include the
facts regarding Patient and Department concepts in the pre-
condition of the rule assignDoctor, i.e., the facts p : Patient,
dep : Department and dep registers p.
To make sure that a patient is registered in a depart-
ment that is in charge of his disease, the developer adds to
the registerPatient’s postcondition the following two facts:
p suffers disease and dep inChargeOf disease.
Since the person p was not considered as a patient before
being registered, in the rule’s code, the developer writes
the statements to declare p belongs to the concept Patient
and to create a relationship between the department dep and
the patient p. Figure 9 shows the ﬁrst version of the rule
registerPatient.
rule registerPatient {
add(p : Patient);
add(dep registers p);
post: p : Patient ∧ dep : Department
∧ dep registers p
∧ p suffers disease
∧ dep inChargeOf disease;
}
Figure 9. Rule registerPatient - First version
Taking as input the program in Figure 9, the static analyzer
extracts the following precondition:
dep : Department ∧ dep inChargeOf disease
∧ p suffers disease
The developer takes the extracted precondition and add to it
the fact p : Person ∩ !Patient specifying that before apply-
ing the rule p is of concept Person and not of type Patient.
Figure 10 shows the ﬁnal version of the rule registerPatient.
rule registerPatient {
pre: dep : Department
∧ dep inChargeOf disease
∧ p : Person ∩ !Patient ∧ p suffers disease;
add(p : Patient);
add(dep registers p);
post: p : Patient ∧ dep : Department
∧ dep inChargeOf disease
∧ p suffers disease ∧ dep registers p;
}
Figure 10. Rule registerPatient - Final version
With the help of the static analyzer, the developer can
develop two correct-by-construction rules as we’ve just pre-
sented. Now, he can write the main program of his application
155
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

as followed to manage all people who have arrived at the
hospital as shown in 11. In this code, the operation ! allows
applying each rule iteratively as long as possible.
main {
receivePatient!;
assignDoctor!;
}
Figure 11. Program ManagePatients
VI.
INTEGRATED DEVELOPMENT ENVIRONMENT
Aiming at integrating various tools to assist in developing
and reasoning about graph transformations, the static analyzer
is part of an experimental environment that provides the
assistance in coding, executing and verifying transformations
written in Small-tALC [11].
Figure 12 shows the big picture of our framework and its
components. Each component provides a speciﬁc support for
Small-tALC programs: the compiler translates a Small-tALC
program to an executable code; the dynamic analyzer examines
the behavior of a running program; the static analyzer helps
achieve correct transformations and the prover veriﬁes the
correctness of programs. The development of each component
is based on an implementation of Small-tALC’s semantics in
an appropriate foundation.
Figure 12. Overview of the Small-tALC environment
The compiler, developed using the compiler generator
Coco/R, produce the byte code of a Small-tALC program for
the Java Virtual Machine. This executable code transforms a
source graph into a target graph.
The dynamic analyzer can be used to ﬁnd inconsisten-
cies between a transformation code and its speciﬁcations by
executing the transformation generated by the compiler then
applying automated tests on the target graph. The test cases
are generated from the postcondition using our Small-tALC
testing library, which is based on JUnit assertions. The input
graph can be generated automatically from the precondition or
can be given by the user.
The prover is a formal veriﬁcation tool that veriﬁes a
transformation program with respect to its pre- and postcon-
ditions by translating it into Isabelle/HOL logic and gen-
erating veriﬁcation conditions. These veriﬁcation conditions
are passed to an automated theorem prover, which can then
formally prove the correctness of the code. In case of failure,
the prover displays a counter-example, which is a model of
the precondition that does not satisfy the postcondition when
applying the transformation.
In the following we illustrate the use of different tools
in our integrated development environment via a scenario of
writing a third rule in the application to manage a hospital.
Rule allocateRoom
Suppose that the developer now wants to write a rule to
allocate a hospital’s room r (r : Room) to a patient p (p :
Patient) who is already assigned to a doctor dr (dr treats p)
but is not allocated a room yet (p : (≤ 0 allocated Room)).
The
allocated
room
must
be
available
(r
:
AvailableRoom) and in the department dep where p is
registered (p allocated r ∧ r isIn dep ∧ dep registers p).
The developer then writes the ﬁrst version of the rule
allocateRoom as shown in Figure 13.
rule allocateRoom {
pre: p : Patient ∧ r : Room ∩ AvailableRoom
∧ r isIn dep ∧ dep registers p
∧ dr treats p
∧ p : (≤ 0 allocated Room);
add(p allocated r);
delete(r : AvailableRoom);
post: p : Patient ∧ r : Room ∩ !AvailableRoom
∧ p allocated r
∧ p : (≤ 0 allocated Room);
}
Figure 13. Rule allocateRoom - First version
When submitting the program in Figure 13 to the prover,
the proof fails and a counter-example is given as shown in
Figure 14.
Figure 14. A counter-example of the rule allocateRoom
Having difﬁculties to locate the error from the counter-
example given by the prover, the developer uses the dynamic
analyzer to examine his program by running tests. From the
postcondition, the dynamic analyzer generates the following
test cases:
156
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

1) assertExistNode(graph, p, AtomicConcept(Patient));
2) assertExistNode(graph, r, AtomicConcept(Room));
3) assertNotExistNode(graph, r,
AtomicConcept(AvailableRoom));
4) assertExistEdge(graph, p, allocated, r);
5) assertAtMostNumberEdges(graph, p, allocated,
AtomicConcept(Room), 0);
When applying the rule allocatedRoom on a generated
graph source from the precondition then executing the tests on
the target graph , the ﬁrst four test cases succeed but the ﬁfth
test fails. The failure of this assertAtMostNumberEdges
test means that the target graph does not respect the condition
"there is at most 0 relation allocated between p and the
individuals of the type Room". The error is therefore from
the fact p : (≤ 0 allocated Room) in the given postcondition.
Thanks to this diagnosis, the developer notices that it
is necessary to increase the number of restrictions in the
erroneous fact as follows : p : (≤ 1 allocated Room). Now he
resubmits the modiﬁed program to the prover, which indicates
that the triplet is correct.
Our Small-tALC environment provides different levels of
assistance in writing both rule’s statements and their speciﬁ-
cations. We choose a testing framework as infrastructure of
the dynamic analyzer for providing immediate feedback and
detailed diagnostics to help correct rule code with respect
to given speciﬁcations. On the other hand, the static ana-
lyzer helps in an auto-active approach construct a correct-by-
construction transformation given a postcondition and partially
a code. Consequently, both produce a valid Hoare triple of a
rule to be eventually proved formally by the prover.
VII.
RELATED WORK
Most of the logic-based approaches for graph transforma-
tions focus on the veriﬁcation question. Thus, they attempt to
encode graph conditions in an appropriate logic that is both
expressive and decidable. The work in [23] expresses invariants
in Computation Tree Logic (CTL). Becker et al. [24] encoded
graph patterns as ﬁrst-order predicates and created symbolic
representations for possible violations of the rule’s properties.
Inaba et al. [25] veriﬁed graph transformations against the
graph structural constraints in Monadic Second-Order logic
(MSO). Calvanese et al. [26] studied the static veriﬁcation
for evolving graph databases where the integrity constraints
are expressed in DL ALCHOIQ. Brenas et al. [27] provided
a decidable logic based on the DL SROIQ for reasoning
on program processing structures deﬁned as graphs. Like us,
Selim et al. [28] proposed a direct veriﬁcation framework
for their transformation language DSLTrans so that no in-
termediate representation for a speciﬁc proving framework is
required. They used symbolic execution to build a ﬁnite set
of path conditions representing all transformation executions
through a formal abstraction relation and thus allow formal
properties to be exhaustively proved. Their property language
based on graph patterns and propositional logic proposes a
limited expressiveness and the property-proving algorithm was
presented as a proof-of-concept.
The works in [24] and [29] share with ours some ideas with
respect to the assistance in producing a Hoare triple. Becker
et al. [24] proposed an iterative development of consistency-
preserving refactorings, which are speciﬁed in a rule-based
manner and rely on a graph-transformation formalization.
Given a modeling language with well-formedness constraints
and a refactoring speciﬁcation, Becker et al. [24] use an
invariant checker to detect and report constraint violations via
counter-examples and lets developers modify their refactoring
iteratively. Similarly to us, Clariso et al. [29] used backward
reasoning to automatically synthesize application conditions
for model transformation rules. Application conditions are
derived from the OCL expression representing the rules’s
postconditions and the atomic rewriting actions performed by
the rule. However, OCL expressions are not really suitable for
exploring the graph properties of the underlying model struc-
tures. It is thus rather cumbersome when used for verifying
complex model transformations. To obtain a higher abstraction
and beneﬁt the formal veriﬁcation of graph rewriting systems,
recently, there are some graph-based approaches proposing the
translations of a set of OCL expressions to graph patterns [30]
or nested graph constraints [31].
VIII.
CONCLUSION AND FUTURE WORK
The distinctive feature of Small-tALC is that it uses the
same logic ALCQ to represent graphs, to code a transforma-
tion and to reason about graph transformations in a Hoare style.
In order to assist users in developing correct transformations,
we propose a ﬁne analysis of the weakest precondition to take
into account special situations of a program on the basis of an
alias calculus. Our auto-active approach allows developers to
select a precondition to annotate their code according to their
intention.
It would be interesting in our framework to automatically
infer and test invariant candidates for loop constructs gathered
from their corresponding postcondition as proposed in [32].
This attempt is based on the fact that a Small-tALC loop often
iterates on individuals selected from a logic formula in order
to achieve the same property for the transformed elements.
As a complement to a Hoare triple veriﬁcation, we are
working on effects of rules execution in terms of DL reasoning
services at the speciﬁcation rule level. A Small-tALC rule
execution updates a knowledge base founded upon a ﬁnite set
of ALCQ concept inclusions (TBox) and a ﬁnite set of ALCQ
concept and role assertions (ABox). This leads to a reasoning
problem about a knowledge base consistency embodied by a
graph in Small-tALC [33].
ACKNOWLEDGMENT
Part of this research has been supported by the Climt (Cate-
gorical and Logical Methods in Model Transformation) project
(ANR-11-BS02-016). We are grateful for Martin Strecker for
the interesting discussions.
REFERENCES
[1]
A. Makhlouf, C. Percebois, and H. N. Tran, “A Precondition Calcu-
lus for Correct-by-Construction Graph Transformations,” in Interna-
tional Conference on Software Engineering Advances (ICSEA), Athens
(Greece), 08/10/2017-12/10/2017. http://www.iaria.org/: IARIA, 2017,
pp. 172–177.
157
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[2]
A. Habel and K.-H. Pennemann, “Correctness of high-level transforma-
tion systems relative to nested conditions,” Mathematical. Structures in
Comp. Sci., vol. 19, no. 2, Apr. 2009, pp. 245–296.
[3]
A. Rensink, “Representing ﬁrst-order logic using graphs,” in Graph
Transformations: Second International Conference ICGT,.
Berlin,
Heidelberg: Springer Berlin Heidelberg, 2004, pp. 319–335.
[4]
B. Courcelle, “Handbook of theoretical computer science (vol. b).”
Cambridge, MA, USA: MIT Press, 1990, ch. Graph Rewriting: An
Algebraic and Logic Approach, pp. 193–242.
[5]
K.-H. Pennemann, “Resolution-like theorem proving for high-level
conditions,” in Graph Transformations: 4th International Conference,
ICGT.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2008, pp. 289–
304.
[6]
F. Orejas, H. Ehrig, and U. Prange, “A logic of graph constraints,” in
Fundamental Approaches to Software Engineering: 11th International
Conference, FASE.
Berlin, Heidelberg: Springer Berlin Heidelberg,
2008, pp. 179–198.
[7]
L. Lambers and F. Orejas, “Tableau-based reasoning for graph prop-
erties,” in Graph Transformation: 7th International Conference, ICGT.
Cham: Springer International Publishing, 2014, pp. 17–32.
[8]
A. Habel and D. Plump, “M,N-adhesive transformation systems,” in
Proceedings of the 6th International Conference on Graph Transforma-
tions, ser. ICGT’12.
Berlin, Heidelberg: Springer-Verlag, 2012, pp.
218–233.
[9]
D. Plump, “The graph programming language gp,” in Algebraic In-
formatics: Third International Conference, CAI.
Berlin, Heidelberg:
Springer Berlin Heidelberg, 2009, pp. 99–122.
[10]
M. Strecker, “Modeling and verifying graph transformations in proof
assistants,” Electron. Notes Theor. Comput. Sci., vol. 203, no. 1, Mar.
2008, pp. 135–148.
[11]
N. Baklanova, J. H. Brenas, R. Echahed, A. Makhlouf, C. Percebois,
M. Strecker, and H. N. Tran, “Coding, executing and verifying graph
transformations with small-tALCQe,” in 7th Int. Workshop on Graph
Computation Models (GCM), 2016, URL: http://gcm2016.inf.uni-due.
de/ [accessed: 2018-05-06].
[12]
K. R. M. Leino and N. Polikarpova, “Veriﬁed calculations,” in Veriﬁed
Software: Theories, Tools, Experiments: 5th International Conference,
VSTTE.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2014, pp.
170–190.
[13]
C. A. Furia, M. Nordio, N. Polikarpova, and J. Tschannen, “Autoproof:
auto-active functional veriﬁcation of object-oriented programs,” Inter-
national Journal on Software Tools for Technology Transfer, 2016, pp.
1–20.
[14]
K. R. M. Leino, “Dafny: An automatic program veriﬁer for functional
correctness,” in Proceedings of the 16th International Conference on
Logic for Programming, Artiﬁcial Intelligence, and Reasoning, ser.
LPAR’10.
Berlin, Heidelberg: Springer-Verlag, 2010, pp. 348–370.
[15]
A. Makhlouf, H. N. Tran, C. Percebois, and M. Strecker, “Combining
dynamic and static analysis to help develop correct graph transfor-
mations,” in Tests and Proofs: 10th International Conference, TAP.
Switzerland: Springer International Publishing, 2016, pp. 183–190.
[16]
M. Nagl, “Set theoretic approaches to graph grammars,” in Proceedings
of the 3rd International Workshop on Graph-Grammars and Their
Application to Computer Science.
London, UK, UK: Springer-Verlag,
1987, pp. 41–54.
[17]
M. Krötzsch, F. Simancik, and I. Horrocks, “A description logic primer,”
arXiv preprint arXiv:1201.4089, 2012, URL: http://arxiv.org/abs/1201.
4089 [accessed: 2018-05-06].
[18]
M. Schmidt-Schauß and G. Smolka, “Attributive concept descriptions
with complements,” Artif. Intell., vol. 48, no. 1, Feb. 1991, pp. 1–26.
[19]
E. W. Dijkstra and C. S. Scholten, Predicate Calculus and Program
Semantics.
New York, NY, USA: Springer-Verlag New York, Inc.,
1990.
[20]
J. H. Brenas, R. Echahed, and M. Strecker, “On the closure of
description logics under substitutions,” in Proceedings of the 29th In-
ternational Workshop on Description Logics, Cape Town, South Africa,
April 22-25, 2016., M. Lenzerini and R. Peñaloza, Eds., 2016, URL:
http://ceur-ws.org/Vol-1577/paper_47.pdf [accessed: 2018-05-06].
[21]
B. Meyer, “Steps towards a theory and calculus of aliasing,” Int. J.
Software and Informatics, vol. 5, no. 1-2, 2011, pp. 77–115.
[22]
J. H. Brenas, R. Echahed, and M. Strecker, “Ensuring correctness
of model transformations while remaining decidable,” in Theoretical
Aspects of Computing – ICTAC 2016, A. Sampaio and F. Wang, Eds.
Cham: Springer International Publishing, 2016, pp. 315–332.
[23]
Z. Langari and R. Treﬂer, “Application of graph transformation in
veriﬁcation of dynamic systems,” in Integrated Formal Methods: 7th
International Conference, IFM.
Berlin, Heidelberg: Springer Berlin
Heidelberg, 2009, pp. 261–276.
[24]
B. Becker, L. Lambers, J. Dyck, S. Birth, and H. Giese, “Iterative de-
velopment of consistency-preserving rule-based refactorings,” in Theory
and Practice of Model Transformations: 4th International Conference,
ICMT. Berlin, Heidelberg: Springer Berlin Heidelberg, 2011, pp. 123–
137.
[25]
K. Inaba, S. Hidaka, Z. Hu, H. Kato, and K. Nakano, “Graph-
transformation veriﬁcation using monadic second-order logic,” in Pro-
ceeding of the 13th International ACM SIGPLAN Symposium on
Symposium on Principles and Practice of Declarative Programming.
ACM Press, Jul. 2011.
[26]
D. Calvanese, M. Ortiz, and M. Simkus, “Evolving graph databases
under description logic constraints,” in Proc. of the 26th Int. Workshop
on Description Logics (DL 2013), 2013.
[27]
J. H. Brenas, R. Echahed, and M. Strecker, “A hoare-like calculus
using the SROIQ σ logic on transformations of graphs,” in Theoretical
Computer Science - 8th IFIP TC 1/WG 2.2 International Conference,
TCS, 2014, pp. 164–178.
[28]
G. M. Selim, L. Lúcio, J. R. Cordy, J. Dingel, and B. J. Oakes, “Speciﬁ-
cation and veriﬁcation of graph-based model transformation properties,”
in International Conference on Graph Transformation.
Springer, 2014,
pp. 113–129.
[29]
R. Clarisó, J. Cabot, E. Guerra, and J. de Lara, “Backwards reasoning
for model transformations,” J. Syst. Softw., vol. 116, no. C, Jun. 2016,
pp. 113–132.
[30]
G. Bergmann, “Translating ocl to graph patterns,” in Model-Driven
Engineering Languages and Systems: 17th International Conference,
MODELS.
Cham: Springer International Publishing, 2014, pp. 670–
686.
[31]
H. Radke, T. Arendt, J. S. Becker, A. Habel, and G. Taentzer, “Trans-
lating essential ocl invariants to nested graph constraints focusing on
set operations,” in Graph Transformation: 8th International Conference,
ICGT.
Cham: Springer International Publishing, 2015, pp. 155–170.
[32]
J. Zhai, H. Wang, and J. Zhao, “Post-condition-directed invariant infer-
ence for loops over data structures,” in Proceedings of the 2014 IEEE
Eighth International Conference on Software Security and Reliability-
Companion, ser. SERE-C ’14. Washington, DC, USA: IEEE Computer
Society, 2014, pp. 204–212.
[33]
U. Sattler, “Reasoning in description logics: Basics, extensions, and
relatives,” in Reasoning Web: Third International Summer School.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2007, pp. 154–182.
158
International Journal on Advances in Software, vol 11 no 1 & 2, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

