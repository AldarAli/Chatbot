220
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
An Efﬁcient Bi-Dimensional Indexing Scheme for Three-Dimensional Trajectories
Antonio d’Acierno
Institute of Food Science
National Research Council of Italy
Avellino, Italy
dacierno.a@isa.cnr.it
Marco Leone, Alessia Saggese,
Mario Vento
DIEII, University of Salerno
Fisciano (SA), Italy
{mleone,asaggese,mvento}@unisa.it
Abstract—The proliferation of devices able to monitor their
position is favoring the accumulation of large amount of
geographically referenced data, that can be proﬁtably used
in a lot of applications, ranging from trafﬁc control and
management to location-aware services. The strong interest in
these applications has entailed a signiﬁcant research effort in
the last years, both toward the modeling of spatio-temporal
databases and toward indexing strategies to efﬁciently process
spatio-temporal queries. Recently, we presented an indexing
scheme (based on a redundant storing strategy) able to index
three-dimensional trajectories using widely available bidimen-
sional indexes. In this paper we propose a method that, while
avoids redundant storing of data, still uses well established
bi-dimensional indexes. With respect to the previous work,
the retrieving performance is improved by taking advantage
both of a more efﬁcient representation and of a trajectory
segmentation stage, as experimental results show.
Keywords-indexing; moving objects databases; spatial queries.
I. INTRODUCTION
The increasing number of mobile devices able to report
their position in real-time with high accuracy has implied the
collection of large amount of data, which can be proﬁtably
used in many realms, ranging from trafﬁc control and
management to location-aware services [1][2]. Moreover,
the need for security in many public environments has also
contributed to an exponential proliferation in the number
of available cameras and, starting from the video streams
acquired from these peripherals, objects’ positions can be
extracted by using available video analytic algorithms [3].
In this way, databases for the analysis and the validation of
models related to different typologies of objects’ movements
and behaviors (pedestrians, cars, pets and so on) have gained
great interest.
In order to store and efﬁciently retrieve the information
extracted from this large amount of acquired data, in the
last years a signiﬁcant research effort has been made, both
towards the modeling of spatio-temporal Moving Object
Databases (MODs) and towards indexing strategies aimed
at efﬁciently process spatio-temporal queries.
According to the widely adopted line segment model, it
is straightforward to represent the movement of each object
as a sequence of line segments, each represented by two
sample positions at consecutive time instants. The trajectory
associated to the object’s motion is thus represented by a
polyline in a three-dimensional space, the ﬁrst two dimen-
sions referring to the space and the third one to the time.
An example is shown in Figure 1.
When handling with MODs, we typically aim at ex-
tracting, from the entire collection of stored data, only
those trajectories possessing a given property: information
retrieval is therefore achieved through processing the query
submitted by the user.
Queries that are worth to be considered in spatio-temporal
databases can be subdivided at least into three orthogonal
categories. First, from a temporal perspective, ”ﬁnd all
the vehicles that will be in a given area in the next ten
minutes” is an instance of the so-called future query; in
order to solve this query, models able to predict the future
position of a moving object are needed. On the other hand,
past queries handle with the historical positions of moving
objects. Finally, now queries ask for the position of objects at
the current time instant tnow; these queries can be considered
as a special case of future queries if the last recorded position
is lower than tnow; furthermore, they represent a special case
(at least from the indexing strategy point of view) of now
queries if the current position of objects has been recorded.
Another commonly accepted query taxonomy [4][5] is
based on the following consideration: a trajectory is a
very complex data structure, so implying that the time
needed to extract it from the database strongly inﬂuences the
performance of a generic retrieval system. For this reason,
it is important to distinguish, for example, if we are only
interested in the identiﬁers of the objects passing through a
given area in a given time interval or if we are interested
in the whole trajectory of these objects. The former query
is commonly deﬁned as coordinate-based query; a typical
example is: ’ﬁnd the number of pedestrians in Saint Peter’s
square in Rome between 9-12 am yesterday’; the latter
is commonly deﬁned as trajectory-based query and, in
turn, contains two different categories: topological queries
and navigational queries. Topological queries make use of
information about the scene for the extraction of an object’s
trajectory (’when did vehicle X leave Plebiscito’s square in
Naples most recently?’). Navigational queries need derived

221
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
information to answer questions like ’what is the current
speed of vehicle X?’; in this case, the needed information
(like speed, heading, travel distance, etc.) is not typically
stored directly and, therefore, a computational overhead is
paid.
Furthermore, from a temporal point of view, a simple
but useful distinction is made between time slice and time
interval queries; a time slice query asks about a ﬁxed time
point while a time interval query considers a temporal
interval. For the sake of clarity, a time slice query, in its
coordinate-based form, can be exempliﬁed as ’ﬁnd all the
objects that are in a given area at a given time instant ti’
while its trajectory-based form is ’ﬁnd the trajectories of
each object that is in a given area at a given time instant
ti’. When ti < tnow, we are facing a past query; ti > tnow
characterizes future queries, while ti = tnow is the case
of now queries. A time interval query, in its coordinate-
based form, can be exempliﬁed as ’ﬁnd all the objects that
pass through a given area in the time interval [t1, t2]’,
while a trajectory-based example is ’ﬁnd all the trajectories
of objects that traverse a given area in the time interval
[t1, t2]’. Assuming t1 < t2, if t2 < tnow we are dealing
with a past query, while t1 > tnow characterizes future
queries. The case t1 < tnow < t2 can be easily assumed
as composed by a past time interval query (t ∈ [t1, tnow), a
now time slice query (t = tnow) and a future time interval
query (t ∈ (tnow, t2]).
Many other interesting queries are reported in [6], [7],
[8], [9] and in [10]. The large amount of queries that have
been proposed, especially in the last years, reinforces the
evidence that research is still ongoing in this ﬁeld and, at
our knowledge, efﬁcient solutions are still being investigated.
In this context, we are interested in efﬁciently storing
and querying moving objects’ trajectories extracted from
Figure 1. A spatio-temporal trajectory; x and y dimensions refer to position
while the third dimension (t) refers to time.
video cameras. Although efﬁcient bidimensional indexing
methods are usually available, several problems arise when
data to be handled are three- or even four-dimensional,
as it happens for the trajectory-based systems. To solve
these problems, we recently proposed a method [1] able to
redundantly project and analyze a collection of trajectories
on bi-dimensional planes by using off-the-shelf solutions.
Starting from our previous work, in this paper we propose
an improved version of the system able to answer past
(trajectory-based) time interval queries on a MOD; even still
using bidimensional indexes, the proposed solution avoids
the redundancy in the stored data and improves the whole
performance, also thanks to a segmentation algorithm aimed
at optimizing the use of the adopted indexes.
The paper is organized as follows: after a discussion
about some of the papers related to both bi-dimensional
and three-dimensional data indexing methods (Section II),
in Section III we describe our previous proposal in [1] and
its improvement, obtained by using a new indexing strategy
that avoids redundancy in the data to be stored; in Section
III we also introduce and describe the adopted segmentation
algorithm. Experimental results are the concern of Section
IV, while Section V concludes the paper outlining future
directions.
II. RELATED WORK
Indexing moving objects databases has been an active re-
search area in the recent past and several solutions have been
proposed. [6] and [11] survey many accessing strategies,
proposed in the last two decades, which are able to index the
past and the current position, as well as methods supporting
queries related to the future.
According to [11] and [12], one of the most inﬂuential
accessing methods in the area of spatial data management
was proposed by Guttman. He suggested, in his pioneering
paper [13], a structure named R-tree able to efﬁciently index
bidimensional rectangular objects in VLSI (Very Large Scale
Integration) design applications. The conceptual simplicity
of an R-tree and its resemblance to widely adopted stan-
dard B-trees, allowed the developers to easily incorporate
such a solution in spatial enabled DBMS [12] in order to
support spatial query optimization and processing. R-trees
hierarchically organize the geometric objects by representing
them through Minimum Bounding Rectangles (MBRs, [14]),
which are an expression of the object’s maximum extents in
its coordinate system; each internal node corresponds to the
MBR that bounds its children while, as usual, a leaf contains
pointers to the objects (see Figure 2). The insertion of a new
object takes place by choosing, at each level, the node that
involves the smallest expansion; when a split of the selected
leaf node is needed, Guttman proposed three algorithms with
different complexity to handle such a split, aiming at the
minimization of the sum of the areas of resulting nodes. It
is worth noting that, since an MBR can be included in many

222
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 2.
An R-tree example (adapted from [12]).
nodes (see R6 in Figure 2), a spatial search may include the
visit of many nodes.
Starting from the original R-Tree structure, several im-
proved versions have been proposed; when we move from
spatial to spatio-temporal data, for instance, the temporal
coordinate can be considered as an extra dimension and
data can be indexed using three-dimensional R-trees [15].
Such an approach does not discriminate between spatial and
temporal dimensions and is well suited for indexing the past,
i.e., when only closed trajectories are considered.
STR-trees [4] extend R-tree with a different insert/split
algorithm, while the characteristics of spatio-temporal data
are captured by two access methods (STR-tree and TB-tree).
When objects’ movements are constrained, for example
on a network of connected road segments, a bidimensional
R-tree can be used to index the static network’s segments.
In this case, each leaf contains a segment and a pointer to
a monodimensional R-Tree that indexes the time intervals
of objects’ movements, as for FNR-Tree [16]. MON-tree
[17] extends the FNR-tree by modeling the constrained
network as a set of junctions and routes; a bidimensional
R-tree is used to index polylines’ bounding boxes while,
for each polyline, another bidimensional R-tree indexes the
time dimension of the objects within the polyline. PARINET
[18] has been designed for historical data in constrained
networks and models the network as a graph; trajectories are
partitioned according to the graph partitioning theory. This
method has been extended to handle continuous indexing of
moving objects [19].
When dealing with real applications for indexing and
querying large repositories of trajectories, the size of MBRs
can be reduced by segmenting each trajectory and then
indexing each sub-trajectory by using R-Trees; such an
approach is described, for example, in [20], where a dynamic
programming algorithm is presented for the minimization
of the I/O for an average size query. SETI [21] segments
trajectories and groups sub-trajectories into a collection of
spatial partitions; queries run over the partitions that are
most relevant for the query itself. TrajStore [22] co-locates
on a disk block (or in a collection of adjacent blocks)
trajectory’ segments by using an adaptive multi-level grid;
thanks to this method, it is possible to answer a query by
only reading a few blocks.
All the above approaches, even presenting efﬁcient so-
lutions from different perspectives, are typically not sup-
ported in the available commercial products that make
use of very efﬁcient spatial indexes that, unfortunately,
are typically restricted to the bi-dimensional case. For
instance, PostGIS [23], a well known extension of Post-
greSQL DBMS [24] for storing spatial data, even supporting
three (and four)-dimensional data, does not support three-
dimensional intersection and indexing operations. As a con-
sequence, there is a strong interest in those methods which,
even using off-the-shelf solutions, allow to solve the problem
in the multi-dimensional space.
For this reason, in this work we propose a method able to
index large sets of trajectories extracted from video cameras
by means of off-the-shelf solutions; in our approach, we
consider that objects are freely moving in our scene, without
any kind of constraint. The main novelty lies in the fact
that, differently from previous solutions, we do not suggest
any new indexing three-dimensional structures. As a matter
of fact, we propose a way to efﬁciently use available
bidimensional solutions in order to solve the problem that
spatial indexes for three-dimensional data are not widely
available.
III. THE PROPOSED METHOD
According to the line segment model, a trajectory T k can
be represented as a sequence of spatio-temporal points:
T k =< P k
1 , P k
2 , ..., P k
n >
with:
P k
i = (xk
i , yk
i , tk
i )
∀i ∈ [1, n].

223
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
0
0
xmax
x
xmin
ymin
y
ymax
t
ts
te
Figure 3.
A query box representing a TIQ.
Each pair (xk
i , yk
i ) refers to the spatial location of an object
at the time instant tk
i . As already mentioned, the trajectory is
approximated by a polyline, each segment being the linear
interpolant between two consecutive points (Figure 1).
A Time Interval Query (TIQ) aims at detecting all those
trajectories passing through a given spatial area A in a given
time interval [ts, te]; assuming that the area A is rectangular,
the latter is fully identiﬁed by two points in the xy plane
P xy
m = (xmin, ymin) and P xy
M = (xmax, ymax). Each TIQ
can be thus associated to a query box B:
B = {(xmin, ymin, ts), (xmax, ymax, te)},
Differently speaking, the temporal dimension extends the
rectangular area A in the 3D space (see Figure 3).
From a geometrical point of view, in order to solve a TIQ
we need to ﬁnd all those trajectories intersecting the query
box B. A simple algorithm for retrieving the trajectories
satisfying such a query is based on processing, for each
trajectory, all its segments, starting from the ﬁrst one: as
soon as the intersection occurs, it can be concluded that the
trajectory intersects the query box. In order to determine if
a trajectory segment lies inside or outside a query box, a
clipping algorithm can be used.
We propose to use the 2D Cohen-Sutherland Line Clip-
ping Algorithm [25] (brieﬂy summarized in Figure 4).
According to it, the geometric plane is subdivided into nine
areas by extending the edges of the query rectangle: if at
least one of the segment endpoints lies inside the query
box, the intersection is trivially veriﬁed (see segment AB in
Figure 4.a); if, on the contrary, both the endpoints lie outside
the query box, we check the position of the endpoints with
respect to the query area: in some cases the intersection can
be still trivially veriﬁed, as for CD and EF respectively in
Figure 4.b, otherwise the segment is split at its intersection
points and each obtained sub-segment is in turn inspected
(as in the case of the segment GH and IL in Figure 4.c).
A 
B 
xe 
xs 
ye 
ys 
C 
D 
xe 
xs 
ye 
ys 
E 
F 
G 
H 
xe 
xs 
ye 
ys 
I 
L 
(a)
(b)
(c)
Figure 4.
The Cohen-Sutherland Algorithm [25].
This clipping algorithm can be easily extended for dealing
with 3D trajectories by considering 27 spatial regions, rather
than 9.
Unfortunately, despite its simplicity, the use of a clipping
algorithm is not suited for handling with large datasets,
so demanding for more efﬁcient approaches. In fact, the
clipping algorithm has to process, for each trajectory, all its
segments, starting from the ﬁrst one until the intersection
occurs. The worst case arises when a trajectory does not
intersect at all the query box; in this case, in fact, all its
segments must be processed, making this approach infeasi-
ble for large amount of data.
When the number of trajectories increases, more efﬁcient
approaches are thus mandatory; for example, suitable index-
ing strategies would be necessary to reduce the number of
trajectories to be clipped. Although many spatial databases
today available, both open source and commercial ones,
provide very efﬁcient spatial indexing techniques, these
indexes schemes are unfortunately typically restricted to
deal with 2D data; for this reason, it is worth trying to
represent the actual 3D problem in terms of (one or more)
2D sub-problems, so as to fully exploit the efﬁcient available
bidimensional indexes.
A. The Solution Proposed in [1]
In [1], given a trajectory T k and a query box B, we
proposed a method according to which both T k and B were
ﬁrst projected on the three coordinate planes; let T k
kz and
Bkz be the projections of T k and of B on the kz plane. We
then observed that, if a trajectory intersects the 3D query
box, then each trajectory projection must also intersect the
correspondent query box projection:
T k ∩ B ̸= ∅ ⇒



T k
xy ∩ Bxy ̸= ∅
T k
xt ∩ Bxt ̸= ∅
T k
yt ∩ Byt ̸= ∅



(1)
Equation 1 represents a necessary but not sufﬁcient condi-
tion, as the opposite is clearly not true. In fact, if all trajec-
tory’s projections intersect the correspondent box projection
on the considered spaces, they do not necessarily intersect
the 3D query box too. To better explain this concept,
Figure 5.a shows, in the 3D space, a trajectory that does
not intersect a given query box: it can be noticed that all the

224
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
trajectory projections intersect the correspondent query box
projections (Figure 5.b-d ).
Thus, as a matter of fact, if all projections of T k intersect
the correspondent box projections, we consider T k as a
candidate to be clipped in the three-dimensional space; the
guess is that there will be not too many false positives.
According to the above considerations, in [1], for each
three-dimensional trajectory T k, we proposed to store three
bi-dimensional trajectories obtained by projecting T k on the
xy plane (T k
xy), on the xt plane (T k
xt) and on the yt plane
(T k
yt).
Given a box B representing the time interval query to be
solved, we similarly considered Bxy, Bxt and Byt.
With this strategy, by using one of the available bi-
dimensional indexes, it is possible to ﬁnd on each plane
the following three trajectory sets (Θ1, Θ2, Θ3) in a very
simple and efﬁcient manner:
Θxy = {Txy : MBR(Txy) ∩ Bxy ̸= ∅}
(2)
Θxt = {Txt : MBR(Txt) ∩ Bxt ̸= ∅}
(3)
Θyt = {Tyt : MBR(Tyt) ∩ Byt ̸= ∅}
(4)
The set T of the trajectories candidate to be clipped in the
3D space is thus trivially deﬁned as:
Θ = {T : Txy ∈ Θxy ∧ Txt ∈ Θxt ∧ Θyt ∈ Tyt}
(5)
This strategy, while taking advantage of widely available
efﬁcient bidimensional indexes, still presents two weak
points. First, for a n points trajectory, we need to redundantly
store 6·n values (2·n for each of the three coordinate planes).
Another subtle crucial point is that the use of bidimensional
indexes is not optimized: as a matter of fact, the MBR of
each projected trajectory can easily span a great percentage
of the whole area.
In the following two subsections, the above problems
will be separately handled and solutions for them will be
presented.
B. Improving the Method by Removing Redundancies
It is possible to observe that, for a given trajectory T k,
rather than storing the three different trajectory projections
in each coordinate plane, we can store T k as the original
sequence of points in the 3D space, and separately main-
tain three different bidimensional MBRs: MBRxy(T k),
MBRxt(T k) and MBRyt(T k). MBRxy(T k) (respectively
MBRxt(T k) and MBRyt(T k)) is obtained by project-
ing on the xy (respectively xt and yt) plane the three-
dimensional MBR of T k.
It is worth noting that the redundancy introduced by the
three MBR projections is not dependent on the number of
points in the trajectory and, therefore, has only a marginal
impact on the spatial complexity, since it only requires the
storage of six pairs of points.
Assuming such a scheme, on each 2D plane we ﬁnd
the trajectories intersecting the corresponding 2D query box
in a very efﬁcient manner by using one of the available
2D indexes. Let Γxy, Γxt and Γyt be the resulting sets of
trajectories deﬁned as:
Γxy = {T : MBRxy(T) ∩ Bxy ̸= ∅}
(6)
Γxt = {T : MBRxt(T) ∩ Bxt ̸= ∅}
(7)
Γyt = {T : MBRyt(T) ∩ Byt ̸= ∅},
(8)
where, as usual, Bxy, Bxt and Byt are the projections of
the 3D query box B. The set Θ of the trajectories candidate
to be clipped in the 3D space is therefore now deﬁned as:
Θ = Γxy ∩ Γxt ∩ Γyt
(9)
Figure 6 resumes the method: given a set of trajectories
and a query box (Figure 6.a), we discard the green trajectory
since its MBRxy(T) and MBRyt(T) do not intersect the
corresponding projection of the black query box (Figure 6.b
and Figure 6.c). The candidate set Θ is thus composed by
the other two trajectories, the red and the blue one, which
are ﬁnally clipped, obtaining the desired output represented
by the blue trajectory (Figure 6.e).
C. Optimizing the Selectivity of the 2D Indexes
It should be clear at this point that the entire system
performance will strongly depend on the indexing phase and,
as a consequence, on the capability to reduce the number of
trajectories to be clipped in the three-dimensional space. At
a more detailed analysis, the selectivity of the indexes in
each plane is related to the area of the corresponding MBR
which, in turn, only depends on the trajectory geometry, so
being (apparently) ﬁxed. This is the reason why we decided
to introduce a segmentation stage, aimed at increasing the
selectivity of the indexes.
Segmentation algorithms aim at subdividing each trajec-
tory into consecutive smaller units, which we will refer to
as trajectory units. We are interested in a segmentation algo-
rithm able to exploit the characteristics of the available bi-
dimensional indexes; this can be accomplished by decreasing
the area of the projected MBR of each trajectory unit.
The proposed algorithm works recursively: initially (that
is at iteration 0) it assumes that the trajectory T k is com-
posed by a single unit 0U k
1 , that is split into a set of m
consecutive smaller units {1U k
1 , . . . ,1 U k
m}; each of the 1U k
i
is in turn inspected and, if the stop criteria are not satisﬁed,
it is further split.
Let us analyze how a generic unit (i−1)U = {P1, . . . , Pm}
is split into {iU1, . . . ,i Un}; we ﬁrst choose a split-
dimension and a split-value. Assume, as an example and
without loss of generality, that x has been chosen as the
split-dimension and let x∗ be the split-value. In addition,
assume that x1 < x∗. According to these hypotheses, iU1

225
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
(a)
(b)
(c)
(d)
Figure 5.
An example of 3D trajectory (a) and its projections on the different coordinate planes xy (b), xt (c) and yt (d). Although the trajectory does
not intersect the query box, its projections do it.
is the set of the consecutive points lying on the left of the
split-value:
iU1 = {P1, . . . , Pk}
(10)
where Pk is the ﬁrst point such that xk ≥ x∗. Then, the
second unit will be formed by the sequence of consecutive
points lying on the right of the split-value:
iU2 = {Pk+1, . . . , Pl}
(11)
where Pl is the ﬁrst point such that xk ≤ x∗. The inspection
of (i−1)U ends when the last point Pm is reached.
According to the above considerations, the criteria for
the choice of the two parameters, split-dimension and split-
value, play a crucial role. Since we aim at optimizing the
indexing strategy, the proposed segmentation algorithm is
based on the occupancy percentage on each 2D coordinate
plane.
First we calculate the coordinate plane corresponding to
the maximum among the three occupancy percentage values
Oxy, Oxt and Oyt of the trajectory unit MBRs, with respect
to the correspondent global volume of interest V :
Oxy = MBRxy(U)
V xy
(12)
Oxt = MBRxt(U)
V xt
(13)
Oyt = MBRyt(U)
V yt
(14)
Without loss of generality, suppose that the maximum oc-
cupancy percentage value is Oxy and, consequently, the
corresponding plane is xy; let width and height be the two
dimensions of MBRxy(U), respectively along the coordi-
nates x and y; the split-dimension sd is deﬁned as:
sd =



x
if width > height
y
otherwise
Given the split-dimension sd we choose, as the split-value
sd∗, the MBR average point on the coordinate sd.
Figure 7 sketches the execution of the ﬁrst iteration of our
algorithm on the trajectory T (assumed to be composed at
this iteration by a single unit U).
In Figure 7.a we are assuming that our volume of interest
is:
0 ≤ x ≤ 150; 0 ≤ y ≤ 50; 0 ≤ t ≤ 30
(15)

226
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
(a)
(b)
(c)
(d)
(e)
Figure 6.
An overview of the method. (a) a query box and three trajectories; (b), (c), (d): the projections of trajectories’ MBRs on the coordinate planes;
(e) the ﬁnal result of our method, after the application of the clipping algorithm on the blu and red trajectories.
We
ﬁrst
consider
MBRxy(U),
MBRxt(U)
and
MBRyt(U) (Figure 7.b) obtaining that:
Oxy > Oxt > Oyt.
(16)
According to the above inequalities, we choose to operate
on the xy plane. As the values of the dimensions are:
width = xmax − xmin = 135
(17)
height = ymax − ymin = 40,
(18)
assuming that x has been chosen as the split-dimension, the
split-value will be easily obtained as follows:
x∗ = xmax + xmin
2
= 72.5
(19)
(20)
Now we are in the position of segmenting the unit; Figure 7.c
shows the current iteration, that is the segmentation of the
unit while, in Figure 7.d, are shown, with different colors,
the obtained 4 units with the corresponding MBRs. Last,

227
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 7.e shows the projections of the obtained MBRs on
each coordinate plane.
The algorithm ends when all the trajectory units cannot be
further subdivided, since at least one of the stop conditions
has been reached for each unit; in particular, we employ two
stop criteria . First, we choose not to segment trajectory units
whose MBR areas are smaller than a ﬁxed percentage of the
entire scenario (PAmin); furthermore, we do not segment a
unit with less than PSmin points.
Finally, a further reﬁnement is needed in our algorithm for
handling with the formation of the last unit; in fact, when
the generic unit U i is splitted, it can happen that the last
unit is only composed by a few points. In this case, a suited
strategy is introduced to speciﬁcally handle with this issue.
Figure 8.a clariﬁes this concept: the last unit (the black one)
is composed by three points, but LU min is set to four. For
this reason, this unit will be merged with the previous one
(the green one, see Figure 8.b).
D. Summarizing the method
In this section we will summarize the proposed method.
Each trajectory T k is segmented (when it is loaded) and
stored as a sequence of trajectory units {U k
1 , . . . , U k
l }; using
one of the available bidimensional indexes, we select:
ΓU
xy = {U : MBRxy(U) ∩ Bxy ̸= ∅}
(21)
ΓU
xt = {U : MBRxt(U) ∩ Bxt ̸= ∅}
(22)
ΓU
yt = {U : MBRxy(U) ∩ Byt ̸= ∅},
(23)
where, as usual, Bxy, Bxt and Byt are the projections of
the 3D query box B.
The set ΓU of units candidate to be clipped in the 3D
space is therefore deﬁned as:
ΓU = ΓU
xy ∩ ΓU
xt ∩ ΓU
yt.
(24)
By analyzing ΓU we build, as follows, the set Θ:
Θ = {∅}
∀ U k ∈ ΓU {
if k /∈ Θ {
if U k intersects B in the three-dimensional space {
Γ = Γ S k
}
}
}.
The set Θ represents the result of a TIQ, if we are
interested in the coordinate-based form, while the entire
trajectories have to be extracted if we are interested in
trajectory-based TIQs.
IV. EXPERIMENTAL RESULTS
In order to characterize the efﬁciency of the proposed
method, several trajectory-based TIQs were performed. We
conducted our experiments on a PC equipped with an Intel
quad core CPU running at 2.66 GHz, using the 32 bit version
of PostgreSQL 9.1 server and the 1.5.3 version of PostGIS.
Data have been indexed using the standard bidimensional R-
tree over GiST (Generalized Search Trees) indexes; as the
specialized literature conﬁrms, this choice guarantees higher
performance in case of spatial queries with respect to the
PostGIS implementation of R-trees.
We represent each trajectory unit as a tuple:
(ID, UID, U, MBRxy, MBRxt, MBRyt)
(25)
where ID is the moving objects identiﬁer, UID identiﬁes
the trajectory unit, and U is the 3D trajectory unit, repre-
sented as a sequence of segments (a PostGIS 3D multi-line).
Finally MBRxy, MBRxt and MBRyt are the three unit’s
MBRs in each coordinate plane, xy, xt and yt respectively,
represented as PostGis BOX geometries. Once data have
been indexed, PostGIS provides a very efﬁcient function to
perform intersections between boxes and MBRs in a 2D
space.
The experimental results have been obtained by testing
the system performance on synthetic data, which have been
generated as follows. Let W and H be the width and
the height of our scene and S the temporal interval. Each
trajectory T i starting point is randomly chosen in our scene
at a random time instant ti
1; the trajectory length Li is
assumed to follow a Gaussian distribution, while the initial
directions along the x axis and the y axis, respectively
di
x and di
y, are randomly chosen. At each time step t, we
ﬁrst generate the new direction, assuming that both di
x and
di
y can vary with probability PIx and PIy respectively;
subsequently, we choose the velocity along x and y at
random. The velocity is expressed in pixels/seconds and
is assumed to be greater than 0 and less than two ﬁxed
maximum, V max
x
and V max
y
. Therefore, the new position of
the object can be easily derived; if it does not belong to our
scene, new values for dx and/or dy are generated. We refer to
the scene populated with trajectories as the Scenario. Table
I reports the free parameters and the values for the creation
of the 30 different scenarios used in our experiments as well
as the parameters used by the segmentation algorithm. Note
that the worst case, corresponding to the maximum values
of T and L, results in 104 trajectories with 104 points, for
a total of 108 points to store and process; these values are
over and above if compared with many real world datasets.
For the evaluation of the efﬁciency of the proposed seg-
mentation algorithm, we generated and segmented 6000 tra-
jectories with L ∈ {1000, 2000, 3000, 4000, 5000, 10000};
for each trajectory T i we measured the number of ob-
tained segments (N i
seg) and the time needed to segment
the trajectory (T i
seg). Last, the obtained N i
seg and T i
seg
are averaged over L, so obtaining Nseg(L) and Tseg(L).
Figure 9 shows on the left the averaged number of segments
(Nseg) as L changes; not surprisingly we have, with very

228
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
(a)
Oxy = 72%
Oxt = 69%
Oyt = 53.4%
(b)
(c)
(d)
(e)
Figure 7.
An overview of the segmentation algorithm. See text for details.

229
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
(a)
(b)
Figure 8.
The effect of LUmin on a segmented unit.
Table I
THE PARAMETERS USED IN OUR EXPERIMENTS.
Scene width (pixels)
104
Scene height (pixels)
104
Time interval length (secs)
105
Number of trajectories (T)
{1, 2, 3, 5, 10} ∗ 103
Points in each trajectory (L)
{1, 2, 3, 5, 10} ∗ 103
PIx
5%
PIy
5%
V max
x
10 pixels/secs
V max
y
10 pixels/secs
PAmin
1%
PSmin
100
LUmin
10
good approximation, that the number of segments linearly
increases with L. On the right of Figure 9 is shown, in
milliseconds, the averaged time Tseg needed to segment a
trajectory with L points; with good approximation, Tseg
quadratically increases with L.
The time needed to process a generic TIQ query (QT) is
a function of at least 4 parameters, namely the number of
trajectories T, the average trajectories’ length L, the query
cube dimension Dc, expressed as percentage of the entire
scenario, and the position of the query box Pc:
QT = f(T, L, Dc, Pc).
(26)
Among the above parameters, Pc strongly inﬂuences the
time needed to extract the trajectories as these are not
uniformly distributed, especially in real world scenarios. In
order to avoid the dependency on the query cube position,
we decided to repeat the query a number of times inversely
proportional to the query cube dimension, positioning the
query cube in different positions, as shown in row N of
Table II; ﬁnally, results are averaged to obtain:
QT = f(T, L, Dc).
(27)
For the description of the experimental results we deﬁne
three different set of experiments, obtained by ﬁxing two
Figure 9.
The performance of the segmentation algorithm.
Table II
NUMBER N OF TIMES EACH QUERY IS REPEATED AS Dc VARIES.
Dc
1%
5%
10%
20%
30%
50%
N
200
40
20
10
7
4
of the three parameters T, L and Dc and showing the
variation of QT with respect to the third (free) parameter; an
example is shown in Figure 10, which expresses the values

230
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
of QT with Dc and L ﬁxed and T variable. Each diamond
refers to the real value in seconds of QT for a given value
of T; Figure 10 shows the curve which best interpolates
the diamonds: in this case the approximation is linear, so
obtaining a line. It is worth pointing out that, for the sake
of readability, the ﬁgures for the experimental results will
be expressed in a semi-log scale as, even not permitting
to display part of the curves interpolating small values, it
provides a greater comprehension of the system behavior
for large values of the parameters.
Figure 10.
QT (in seconds) as the number of trajectories increases with
Dc = 5% and L = 5000.
In Figure 11, QT relates to the variable number of
trajectories T, for various values of Dc; the number of
curves corresponds to the different ﬁxed values of L =
{1, 2, 3, 5, 10} ∗ 103. The relationship between QT and T
has been analyzed by polynomially approximating QT(T):
note that QT linearly increases with T, with a very small
factor of approximation.
Diamond points in Figure 12 express QT in relation to
the query box dimensions Dc and for T = 3.000 and T =
10.000; the number of curves corresponds to the different
ﬁxed values of L = {1, 2, 3, 5, 10} ∗ 103. In this case we
obtain that QT quadratically depends on Dc.
In Figure 13, the diamonds express QT as a function
of L, for Dc ∈ {1%, 5%, 20%, 30%}, while the number
of curves corresponds to the different ﬁxed values of T =
{1, 2, 3, 5, 10}∗103. Again we obtain that QT quadratically
depends on L.
Finally, Figure 14 highlights the enhancement of the pro-
posed indexing scheme as compared with the one presented
in [1], for Dc ∈ {1%, 20%}. In particular, the diamonds
refer to the new method, while the circles refers to the
previous one. Note that, thanks to a novel indexing strategy
and segmentation algorithm, the system performance signif-
icantly improved while the redundancy in stored data has
been signiﬁcantly removed.
V. CONCLUSION
In this paper we proposed an enhanced version of the
retrieval system proposed in [1], aimed to index large
amount of 3D trajectory data by using widely available 2D
indexes. With respect to the previous method, two main
improvements have been achieved: the former is the removal
of the redundancy, obtained thanks to a novel indexing
scheme; the latter is the optimization of the selectivity of the
indexes, obtained by introducing a segmentation algorithm.
The experimental results, performed on synthetic data,
show that the proposed solution is able to fully exploit the
retrieving capabilities based on well established 2D indexes.
In fact, the system performance have been signiﬁcantly
improved, if compared with the results presented in [1].
Further improvements in the performance will be achieved
by applying the clipping algorithm in parallel to each can-
didate trajectory. This step can be easily implemented using
multi-threading, in order to take advantage of multi-core and
multi-processors systems. Strategies aiming at compressing
data to be stored and retrieved are also being considered.
Finally, we are extending our system in order to answer
different query typologies.
ACKNOWLEDGMENT
This research has been partially supported by A.I.Tech
s.r.l. (a spin-off company of the University of Salerno,
www.aitech-solutions.eu) ) and by the FLAGSHIP In-
terOmics project (PB.P05, funded and supported by the
Italian MIUR and CNR organizations).
REFERENCES
[1] A. d’Acierno, A. Saggese, and M. Vento, “A redundant bi-
dimensional indexing scheme for three-dimensional trajecto-
ries,” in Proceedings of the First Conference on Advances in
Information Mining and Management (IMMM 2011), 2011.
[2] A. d’Acierno, M. Leone, A. Saggese, and M. Vento, “A
system for storing and retrieving huge amount of trajectory
data, allowing spatio-temporal dynamic queries,” in Intelli-
gent Transportation Systems (ITSC), 2012 15th International
IEEE Conference on, sept. 2012, pp. 989 –994.
[3] R. Di Lascio, P. Foggia, A. Saggese, and M. Vento, “Tracking
interacting objects in complex situations by using contextual
reasoning,” in Computer Vision Theory and Applications
(VISAPP), 2012 International Conference on, 2012.
[4] D. Pfoser, C. S. Jensen, and Y. Theodoridis, “Novel ap-
proaches in query processing for moving object trajectories,”
in Proceedings of VLDB Conference.
San Francisco, CA,
USA: Morgan Kaufmann Publishers Inc., 2000, pp. 395–406.
[5] D. Lim, D. Cho, and B. Hong, “Indexing moving objects for
trajectory retrieval on location-based services,” IEICE - Trans.
Inf. Syst., vol. E90-D, pp. 1388–1397, September 2007.
[6] M. F. Mokbel, T. M. Ghanem, and W. G. Aref, “Spatio-
temporal access methods,” IEEE Data Eng. Bull., vol. 26,
no. 2, pp. 40–49, 2003.

231
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[7] Y. K. Huang and L. F. Lin, “Continuous within query in road
networks,” in 7th International Wireless Communications and
Mobile Computing Conference (IWCMC), 2011, pp. 1176 –
1181.
[8] Y.
Gao,
B.
Zheng,
G.
Chen,
Q.
Li,
C.
Chen,
and
G.
Chen,
“Efﬁcient
mutual
nearest
neighbor
query
processing for moving object trajectories,” Inf. Sci., vol.
180,
pp.
2176–2195,
June
2010.
[Online].
Available:
http://dx.doi.org/10.1016/j.ins.2010.02.010
[9] S.
Shang,
B.
Yuan,
K.
Deng,
K.
Xie,
K.
Zheng,
and X. Zhou, “PNN query processing on compressed
trajectories,” GeoInformatica, pp. 1–30, Oct. 2011. [Online].
Available: http://dx.doi.org/10.1007/s10707-011-0144-5
[10] Z. Li, Y. Gao, and Y. Lu, “Continuous obstructed range
queries in spatio-temporal databases,” in System Science,
Engineering Design and Manufacturing Informatization (IC-
SEM), 2011 International Conference on, vol. 2, oct. 2011,
pp. 267 –270.
[11] L.-V. Nguyen-Dinh, W. G. Aref, and M. F. Mokbel, “Spatio-
temporal access methods: Part 2 (2003 - 2010),” IEEE Data
Eng. Bull., vol. 33, no. 2, pp. 46–55, 2010.
[12] Y. Manolopoulos, A. Nanopoulos, A. N. Papadopoulos, and
Y. Theodoridis, R-Trees: Theory and Applications (Advanced
Information and Knowledge Processing).
Secaucus, NJ,
USA: Springer-Verlag New York, Inc., 2005.
[13] A. Guttman, “R-trees: a dynamic index structure for spatial
searching,” in Proceedings ACM SIGMOD Conference. New
York, NY, USA: ACM, 1984, pp. 47–57.
[14] D. Papadias and Y. Theodoridis, “Spatial relations, minimum
bounding rectangles, and spatial data structures,” Interna-
tional Journal of Geographical Information Science, vol. 11,
no. 2, pp. 111–138, 1997.
[15] Y. Theodoridis, M. Vazirgiannis, and T. Sellis, “Spatio-
temporal indexing for large multimedia applications,” in
Proceedings of the 3rd IEEE International Conference on
Multimedia Computing and Systems, 1996, p. 441 448.
[16] E. Frentzos, “Indexing objects moving on ﬁxed networks,”
in 8th International Symposium on Advances in Spatial and
Temporal Databases (SSTD 2003). Springer, 2003, pp. 289–
305.
[17] V. T. De Almeida and R. H. G¨uting, “Indexing the
trajectories of moving objects in networks*,” Geoinformatica,
vol.
9,
pp.
33–60,
March
2005.
[Online].
Available:
http://dl.acm.org/citation.cfm?id=1046957.1046970
[18] I. S. Popa, K. Zeitouni, V. Oria, D. Barth, and S. Vial,
“Parinet: A tunable access method for in-network trajecto-
ries,” in Proceedings of the 26th International Conference on
Data Engineering, ICDE 2010, March 1-6, 2010, Long Beach,
California, USA, F. Li, M. M. Moro, S. Ghandeharizadeh,
J. R. Haritsa, G. Weikum, M. J. Carey, F. Casati, E. Y. Chang,
I. Manolescu, S. Mehrotra, U. Dayal, and V. J. Tsotras, Eds.
IEEE, 2010, pp. 177–188.
[19] I. Sandu Popa, K. Zeitouni, V. Oria, D. Barth, and S. Vial,
“Indexing in-network trajectory ﬂows,” The VLDB Journal,
vol. 20, pp. 643–669, Oct. 2011.
[20] S. Rasetic, J. Sander, J. Elding, and M. A. Nascimento, “A
trajectory splitting model for efﬁcient spatio-temporal index-
ing,” in Proceedings of the 31st international Conference on
VLDB.
VLDB Endowment, 2005, pp. 934–945.
[21] V. P. Chakka, A. Everspaugh, and J. M. Patel, “Indexing large
trajectory data sets with seti,” in CIDR, 2003.
[22] P. Cudre-Mauroux, E. Wu, and S. Madden, “Trajstore: An
adaptive storage system for very large trajectory data sets,”
Data Engineering, International Conference on, vol. 0, pp.
109–120, 2010.
[23] R. Obe and L. Hsu, PostGIS in Action.
Greenwich, CT,
USA: Manning Publications Co., 2011.
[24] PostgreSQL
Global
Development
Group,
“Post-
greSQL,”
Accessed:
12/19/2012.
[Online].
Available:
http://www.postgresql.org/
[25] J. D. Foley, A. van Dam, S. K. Feiner, and J. F. Hughes, Com-
puter Graphics: Principles and Practice in C (2nd Edition).
Addison-Wesley, 2004.

232
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Dc = 1%
Dc = 5%
Dc = 20%
Dc = 50%
Figure 11.
QT (in seconds) as the number of trajectories increases having
the number of points in each trajectory as parameter.
T = 1000
T = 3000
T = 5000
T = 10000
Figure 12.
QT (in seconds) as the dimension of the querying cube (in
percentage of the whole volume) increases and having L as parameter.

233
International Journal on Advances in Intelligent Systems, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/intelligent_systems/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Dc = 1%
Dc = 5%
Dc = 20%
Dc = 50%
Figure 13.
QT (in seconds) as the number of points in each trajectory
increases and having the number of trajectories as parameter.
Dc = 1%
Dc = 20%
Figure 14.
The results obtained with the solution proposed in [1] (circles)
compared with the results obtained with the solution here as T varies
(L=5000).

