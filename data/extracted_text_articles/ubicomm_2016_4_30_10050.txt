Verifying Scenarios of Proximity-based Federations among Smart Objects
through Model Checking
Reona Minoda
Graduate School of Information Science
and Technology, Hokkaido University
Sapporo, Hokkaido 060–8628, Japan
Email: minoda@meme.hokudai.ac.jp
Yuzuru Tanaka
Meme Media Laboratory
Hokkaido University
Sapporo, Hokkaido 060–8628, Japan
Email: tanaka@meme.hokudai.ac.jp
Shin-ichi Minato
Graduate School of Information Science
and Technology, Hokkaido University
Sapporo, Hokkaido 060–8628, Japan
Email: minato@ist.hokudai.ac.jp
Abstract—In this paper, we show a formal approach of ver-
ifying ubiquitous computing scenarios. Previously, we proposed
“a proximity-based federation model among smart objects”,
which is intended for liberating ubiquitous computing from
stereotyped application scenarios. However, we faced challenges
when establishing a veriﬁcation method for this model. This
paper proposes a veriﬁcation method of this model through
model checking. Model checking is one of the most familiar
formal veriﬁcation approaches and it is often used in various
ﬁelds of industry. Model checking is conducted using a Kripke
structure which is a formal state transition model. We introduce
a context catalytic reaction network (CCRN) to handle this
federation model as a formal state transition model. We also
give an algorithm to transform a CCRN into a Kripke structure
and we conduct a case study of ubiquitous computing scenario
veriﬁcation, using this algorithm and the model checking.
Keywords—ubiquitous computing; catalytic reaction network;
formal veriﬁcation; model checking; smart object.
I. INTRODUCTION
Today, we are surrounded by a lot of devices with computa-
tion and communication capabilities. These devices are called
Smart Objects (SOs). SOs include PCs, smart phones, embed-
ded computers, sensor devices and radio frequency identiﬁer
(RFID) tags. Here, we use the term federation to denote the
deﬁnition and execution of interoperation among resources that
are accessible either through the Internet or through peer-to-
peer ad hoc communication. SOs’ communication capabilities
make it possible to form federations of SOs. Our real world
environment is now steadily laying the foundation for the
concept of ubiquitous computing which Mark Weiser had
foreseen [1].
It has been almost quarter of century since Weiser proposed
the notion of ubiquitous computing. In the meantime, a lot of
different frameworks have been proposed to realize ubiquitous
computing. However, regardless of speciﬁc research areas in
ubiquitous computing, these researches typically only consider
two types of application scenarios. One is “location trans-
parent service continuance” (i.e., a user can use a service
wherever the user goes). The other one is “context-aware
service provision” (i.e., a user can use different kinds of
services depending on where the user is). Robin Milner
thought that the lack of models for describing ubiquitous
computing application scenarios limited application scenarios
to these two types [2]. Besides, according to Milner [2], it is
not possible to describe all concepts of ubiquitous computing
by using a single model. Milner argued that the hierarchy
structure of models (Milner called it “a tower of models”) was
necessary. In a tower of models, each higher model should be
implemented by a lower model.
Following the notion of a tower of models, Yuzuru Tanaka
once proposed the basic idea for describing ubiquitous com-
puting application scenarios using a catalytic reaction network
model [3]. This idea includes the following three models:
• At the ﬁrst (lowest) level, the port matching model
describes the federation mechanism between two SOs in
close proximity to each other.
• At the second (middle) level, the graph rewriting model
describes the dynamic change of federation structures
among SOs.
• At the third (highest) level, the catalytic reaction network
model describes application scenarios involving mutually
related multiple federations.
In our previous work, Julia and Tanaka brushed up these
three models and established a concrete tower of models
by proving that a higher model surely implements a lower
model [4]. Moreover, Julia’s model implementation has error
handling mechanisms assuming unexpected situations such as
the connection failures between two SOs. Therefore, we can
focus on the catalytic reaction network model for describing
application scenarios of ubiquitous computing.
However, there are still challenges of establishing the veri-
ﬁcation method of the catalytic reaction network model. So
far, when we made a scenario using the catalytic reaction
network model, we could not prove easily whether a particular
federation would occur because federations of multiple devices
are formed by proximity sensitive connections between SOs.
So when we discuss a scenario using the catalytic reaction
network, we also need to consider the proximity relations of
SOs.
In this paper, we propose a veriﬁcation method of device-
federation model based on catalytic reaction network. Ba-
sically we transform a scenario into a well-known state-
transition model such as Kripke structure. This enables us to
apply existing model checking veriﬁers. With this method, we
can discuss the following things:
• Determining whether a property described in a linear
65
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Gate
Headset
Phone
IC card
Scope of
(iii) Phone     and headset     
                  are federated (denoted by      ).
expressed as
makes    and    federated.
(ii)
(i) A user enters into
the scope of      .
(This action is triggered by   .)
Figure 1. Example of a Catalytic Reaction
temporal logic (LTL) speciﬁcation (e.g., a particular
federation ﬁnally occured) is satisﬁed or not in the
given scenario described by the catalytic reaction network
model.
• Showing a counterexample if there is any case violating
the property described above.
In a scenario using original catalytic reaction network
model, there are so many proximity relations among SOs
(n SOs would have 2n proximity relations). This sometimes
causes the state explosion problem in the model checking.
We need to constrain the proximity relations in the original
catalytic reaction network model. For this reason, we will ﬁrst
deﬁne the constrained model called “Context Catalytic Reac-
tion Network (CCRN).” Then, we will propose the method to
transform CCRN into a well-known state transition model such
as a Kripke structure that can apply existing model checking
veriﬁers.
The rest of this paper is organized as follows. The rest of
this section introduces related work of our research. Section II
provides preliminaries of this paper, such as basic deﬁnitions
and notations. Using them, we deﬁne a CCRN in Section
III. Then, we propose the veriﬁcation method of a CCRN
in Section IV. Section V introduces the case study of the
veriﬁcation. Finally, we summarize the results of this paper
in Section VI.
A. Related Work
1) Formal Veriﬁcation of Cyber Physical Systems: Sim-
ilarly to ubiquitous computing, a lot of devices such as
sensors measure physical phenomena such as temperature,
humidity, acceleration and so on, while actuators manipulate
the physical world, like in automated robots. The combination
of an electronic system with a physical process is called cyber
physical system (CPS). In the ﬁeld of CPS, Drechsler and
K¨uhne use timed automata [5] as a state transition model to
conduct formal veriﬁcations of given systems’ properties [6].
2) Context Inconsistency Detection: In the ﬁeld of ambient
computing, Xu and Cheung propose a method of context in-
consistency detection [7]. This method detects inconsistencies
from a series of gathered events such as “a user entered a
room” and “the temperature of room is 30◦C” by logical
deduction. Unlike a formal veriﬁcation, this method can be
applied only after the system begins to work. Instead, a formal
veriﬁcation can ﬁnd the failed cases from a given system in
advance.
II. PRELIMINARIES
In this section, we give deﬁnitions and notations which is
necessary for this paper.
A. Basic Deﬁnitions and Notations
Let X and Y be any two sets, we use X ∪ Y , X ∩ Y and
X \ Y to denote the union, intersection and difference of X
and Y respectively. For a set X, we denote its power set (i.e.,
all subsets) by 2X and its cardinality by |X|. For a family
M of sets (i.e., a set of sets), we denote the union and the
intersection of all sets in M by ∪ M and ∩ M respectively.
B. Catalytic Reaction Network
A catalytic reaction network was originally proposed by
Stuart Kauffman in the ﬁeld of biology to analyze protein
metabolism [8]. Based on this model, Tanaka applied it to
the ﬁeld of ubiquitous computing as the way to describe
an application scenario involving mutually related multiple
federations among SOs [3]. In this paper, we mean the latter
by the term “catalytic reaction network”.
A catalytic reaction network is a set of catalytic reactions.
Each catalytic reaction takes input materials and transforms
them into output materials. And each catalytic reaction has
a catalyst which is called context. It may be also possible
to include a catalyst in input materials. We call this kind of
catalyst stimulus. A catalytic reaction occurs when all required
SOs are in the proximity of each other. We use the term
“scope” to denote the inside of the proximity area (we assume
a range of Wi-Fi radiowave, and so on). The scope of a SO
o is represented as a set of SOs which are accessible from
the SO o. Tanaka assumed that all scopes of the context
and SOs involved in a catalytic reaction are considered [3].
However, as we mentioned in previous section, this causes
the state explosion problem during the model checking. For
this reason, in this paper, we assume that only the scopes of
contexts are considered instead. In other words, we consider
66
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Figure 2. Four Types of a Catalytic Reactions
that the catalytic reaction occurs if all required SOs just enter
into the scope of the corresponding context.
Fig. 1 shows an example of single catalytic reaction. In this
example, there is a gate c1 regarded as a context and a user
has three SOs i.e., a phone a, a headset b and an IC card
s. If the user enters into the scope of c1, c1 makes a and b
federated. This action is triggered by s. After that, phone a
and headset b are federated. We denote federated SOs such
as a and b by a concatenation of a and b, i.e., ab. During
this process, c1 and s work as catalysts. In particular, s is a
stimulus in this reaction. We express this reaction as the right
hand side diagram of Fig. 1.
In catalytic reaction networks, there are four types of
catalytic reactions as we show in Fig. 2. We categorize these
four types of reactions into two groups. One group is the
composition reaction group (Fig. 2 (i) and (ii) ), the other
group is the decomposition reaction group (i.e., Fig. 2 (iii)
and (iv) ). A catalytic reaction of Fig. 1 is a type (i) catalytic
reaction. We also consider the catalytic reaction without a
stimulus such as Fig. 2 (ii). In type (ii), if a user who has
SO a and SO b enters into the scope of context c2, c2 makes
a and b federated without a stimulus. In a similar way, we
consider the decomposition reactions such as Fig. 2 (iii) and
(iv). In type (iii), if a user who has two SOs that are federated
into ab enters into the scope of context c3, c3 decomposes
these SOs ab into a and b triggered by SO s. Type (iv) is a
decomposition reaction without a stimulus.
The output SO of a reaction may promote other reactions
as a stimulus or become an input SO of other reactions. In
this way, catalytic reactions form a network of reactions.
Now we deﬁne a catalytic reaction network formally. First,
let O be a set of SOs, we give a deﬁnition of a federated SO
of by of ∈ 2O \ ∅ where |of| > 1. If |of| = 1, we treat of as
a single SO. Next, we deﬁne a catalytic reaction as follows:
Deﬁnition 1 (Catalytic Reaction): Let O and C be a set of
SOs and a set of contexts respectively, a catalytic reaction is
deﬁned as a tuple (c, M, N) where
• c ∈ C, M ⊆ 2O \ ∅, N ⊆ 2O \ ∅
• ∀of∀o′
f ∈ M.(of ̸= o′
f → of ∩ o′
f = ∅)
• ∀of∀o′
f ∈ N.(of ̸= o′
f → of ∩ o′
f = ∅)
• ∪ M = ∪ N, and
• (|M ∩ N| + 1 = |N|, |M| > |N|) ∨
(|M ∩ N| + 1 = |M|, |M| < |N|)
(∗)
The former of the last condition (signed by (∗)) and the latter
of the last condition correspond to a necessary condition for
composition reaction and decomposition reaction respectively.
We give some examples of catalytic reactions. Given C =
{c1, c3}, O = {a, b, s}, a catalytic reaction of Fig. 2 (i) and
(iii) can be deﬁned by (c1, {{a}, {b}, {s}}, {{a, b}, {s}}) and
(c3, {{a, b}, {s}}, {{a}, {b}, {s}}) respectively.
Finally, a catalytic reaction network is deﬁned as follows:
Deﬁnition 2 (Catalytic Reaction Network): A catalytic re-
action network is a set of catalytic reactions.
C. Model Checking
A model checking is a method to verify a property of a
state transition system. It has been often used in various ﬁelds,
which range from electronic-circuit-design veriﬁcation [9] to
secure-network-protocol (e.g., Secure Sockets Layer (SSL)
protocol) design veriﬁcation [10]. In the model checking, it is
typically assumed to use a Kripke structure as a state transition
system. The property of a Kripke structure is described by a
modal logic. There are two kinds of commonly used modal
logics such as linear temporal logic (LTL) and computational
tree logic (CTL). In this paper, we use LTL to describe the
property of the Kripke structure.
1) Kripke Structure: Before we consider the details of a
model checking, we give the deﬁnition of a Kripke struc-
ture [11] which is necessary for a modal logic and a model
checking.
Deﬁnition 3 (Kripke Structure): Let AP be a set of atomic
propositions, a Kripke structrue M is a tuple (S, I, R, L),
where
• S is a ﬁnite set of states,
• I ⊆ S is a set of initial states,
• R ⊆ S × S is a set of transition relation such that R is
left-total, i.e., ∀s ∈ S, ∃s′ ∈ S such that (s, s′) ∈ R, and
• L : S → 2AP is a labeling function.
2) Linear Temporal Logic: LTL is a well-known modal
logic. LTL was ﬁrst proposed for the formal veriﬁcation of
computer programs by Amir Pnueil in 1977 [12]. First, we
give a deﬁnition of LTL syntax.
Deﬁnition 4 (Linear Temporal Logic Syntax): Let AP be a
set of atomic propositions, a linear temporal logic formula ϕ
is deﬁned by the following syntax recursively.
ϕ ::= ⊤ | ⊥ | p | ¬ϕ | ϕ ∨ ϕ | X ϕ | G ϕ | F ϕ | ϕ U ϕ
where p ∈ AP.
These right-hand terms denote true, false, p, negation, disjunc-
tion, next time, always, eventually and until respectively.
Next, we deﬁne a transition path π of a Kripke structure
M.
Deﬁnition 5 (Transition Path): Let M be a Kripke structure,
π = (π0, π1, π2, . . . ) is a transition path in M if it respects
M’s transition relation, i.e., ∀i.(πi, πi+1) ∈ R. πi denotes π’s
ith sufﬁx, i.e., πi = (πi, πi+1, πi+2, . . . ).
67
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

Also it can be shown that
(πi)j = (πi, πi+1, πi+2, . . . )j
= (πi+j, πi+j+1, πi+j+2, . . . )
= πi+j.
Now we focus on the semantics of linear temporal logic.
First, we deﬁne the binary satisfaction relation, denoted by
|=, for LTL formulae. This satisfaction is with respect to a
pair – ⟨M, π⟩, a Kripke structure and a transition path. Then
we enumerate LTL semantics as follows:
• M, π |= ⊤ (true is always satisﬁed)
• M, π ̸|= ⊥ (false is never satisﬁed)
• (M, π
|= p) iff (p ∈ L(π0)) (atomic propositions
are satisﬁed when they are members of the path’s ﬁrst
element’s labels)
And there are two LTL semantics of boolean combinations as
follows:
• (M, π |= ¬ϕ) iff (M, π ̸|= ϕ)
• (M, π |= ϕ ∨ ψ) iff [(M, π |= ϕ) ∨ (M, π |= ψ)]
And there are four LTL semantics of temporal operators as
follows:
• (M, π |= X ϕ) iff (M, π1 |= ϕ)
• (M, π |= F ϕ) iff
[
∃i.(M, πi |= ϕ)
]
• (M, π |= G ϕ) iff
[
∀i.(M, πi |= ϕ)
]
• (M, π |= ϕ U ψ) iff
[
(∀j < i.(M, πj |= ϕ)) ∧ (M, πi |= ψ)
]
3) Model Checking Problem: Intuitively saying, a model
checking problem is to judge whether a given Kripke structure
M satisﬁes a given property described in a modal logic
formula ϕ. A model checking problem is formally stated as
follows.
Deﬁnition 6 (Model Checking Problem): Given a desired
property described by a modal logic formula ϕ (in this paper,
we use LTL) and a Kripke structure M, a model checking
problem is a decision problem whether the following formula
∀π.(M, π |= ϕ)
is satisﬁed or not. Note that a set {π | (M, π ̸|= ϕ)} is
particularly called counterexamples.
It is known that a model checking problem can be reduced to
a graph search if M has ﬁnite states.
There are several implementations of the model checking
veriﬁer such as Simple Promela INterpreter (SPIN) [13], Label
Transition System Analyzer (LTSA) [14], New Symbolic
Model Veriﬁer version 2 (NuSMV2) [15] and so on. In this
paper, we use a model checking veriﬁer NuSMV2.
III. CONTEXT CATALYTIC REACTION NETWORK
In this section, we introduce a segment graph and a CCRN.
A. Segment Graph
As we discussed in the previous section, a catalytic reaction
occurs when the required SOs enter into the scope of the
corresponding context. To analyze the property of a given
Scope of
Scope of
Context
Context
A user can walk around a path     .
Given Situation
Corresponding Segment Graph
Scope of
Scope of
Figure 3. Example of Segment Graph
catalytic reaction network as a state transition system, it is
necessary to formalize the movement of SOs. For example, in
Fig. 3 (i), there are contexts c1 and c2 and these scopes have an
overlap. A user can walk around the path αβ shown in Fig.
3 (i). This situation can be represented as a segment graph
shown in Fig. 3 (ii). We consider that the user walks around
this segment graph and the user is always located at one of the
nodes of this segment graph. Each node of a segment graph
has a corresponding set of scopes of contexts. In this way, the
given situation like Fig. 3 (i) including overlaps of scopes of
contexts can be represented as a discrete structure.
Now we deﬁne a segment graph as follows.
Deﬁnition 7 (Segment Graph): Let C be a set of contexts,
a segment graph G is a tuple (S, E, F), where
• S is a ﬁnite set of segments,
• E ⊆ S × S is a set of directed edges between two
segments, and
• F : S → 2C is a function returning scopes of contexts at
corresponding segments.
B. Context Catalytic Reaction Network
A context catalytic reaction network (CCRN) is a discrete
structure of a situation involving SOs in a catalytic reaction
network. A CCRN is deﬁned as a conbination of a segment
graph and a catalytic reaction network.
Deﬁnition 8 (Context Catalytic Reaction Network): A CCRN
is a tuple (O, C, R, G, LFIX, l0), where
• O is a set of smart objects,
• C is a set of contexts,
68
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

• R is a set of catalytic reactions,
• G is a segment graph (S, E, F),
• LFIX ⊆ O × S is the locations of ﬁxed SOs, and
• l0 ∈ S is the initial segment locating mobile SOs (mobile
SOs can be represented as O \ {o ∈ O | ∃s ∈ S.((o, s) ∈
LFIX)}).
IV. VERIFICATION METHOD OF A CCRN
In this section, we propose a veriﬁcation method of a
CCRN. Before discussing the details of the method, we assume
that all mobile SOs are carried together (by a single user).
A state of a CCRN can be represented as a combination of
the location of mobile SOs (e.g., mobile SOs are located at
segment s) and the presence of federated SOs (e.g., federated
SOs of and o′
f are existing) and we regard these two kind
of facts as atomic propositions. We use the following atomic
propositions (AP):
• locOMOB(s): mobile SOs are located at segment s
• fed(of): federated SOs of is existing
While mobile SOs move around a segment graph, more
than one federated SOs may appear. For example, federated
SOs {a, b} and {c, d} may appear at the same time. For that
reason, we deﬁne a single state of the presence of federated
SOs as the subset of 2O (e.g., {{a, b}, {c, d}} is a subset of
2{a,b,c,d}). But each SO can not be a part of more than one
federated SOs. For example, we do not permit federated SOs
like {a, b} and {b, c} are presented at the same time because
SO b is a part of both of these two federated SOs. Considering
this constraint, a set of states of presence of federated SOs
can be represented as OF = {∅} ∪ {oF | oF ⊆ 2O, ∀of, o′
f ∈
oF .(of ̸= o′
f → of ∩ o′
f = ∅, ∀of ∈ oF .(|of| > 1)}. Finally,
we represent a state of a CCRN as state(s, oF ) where s is
the segment at which mobile SOs are located and oF is the
set of federated SOs. For example, state(s0, {{a, b}, {c, d}})
means mobile SOs are located at segment s0 and federated
SOs {a, b} and {c, d} are existing.
Using the above representation of a state of a CCRN and
atomic propositions, we conduct veriﬁcation of a CCRN by
constructing a Kripke structure from a given CCRN. Here we
give an algorithm in Fig. 4 to construct a Kripke structure
from a given CCRN. After constructing a Kripke structure
from a CCRN, now we describe properties of a CCRN by
LTL formulae. We enumerate examples of LTL formulae:
• G(¬fed(of) → F(fed(of)))
Informally and intuitively saying, federated SOs of ﬁ-
nally exists if of does not exist at the beginning and this
always happens.
• G((¬fed(of) → F(fed(of)))∨(¬fed(o′
f) → F(fed(o′
f))))
This means federated SOs of ﬁnally exists if of does not
exist at the beginning. Similarly, federated SOs o′
f ﬁnally
exists if o′
f does not exist at the beginning. At least one
of these phenomena always happens.
Finally, we conduct the model checking, giving a Kripke
structure and LTL formulae. This can be done by various
implementations of model checking veriﬁers which we intro-
duced in previous section.
Input: CCRN (O, C, R, (S, E, F), LFIX, l0)
Output: Kripke Structure (S, I, R, L)
Initialization :
1: OMOB = O \ {o ∈ O | ∃s ∈ S.((o, s) ∈ LFIX)}
2: OF = {∅} ∪ {oF | oF ⊆ 2O, ∀of, o′
f ∈ oF .(of ̸= o′
f →
of ∩ o′
f = ∅), ∀of ∈ oF .(|of| > 1)}
3: AP = {locOMOB(s) | s ∈ S} ∪
{fed(of) | of ∈ oF , oF ∈ OF }
4: S = {state(s, oF ) | s ∈ S, oF ∈ OF }
5: I = state(l0, ∅)
6: R = ∅
Loop Process :
7: for each oF ∈ OF do
8:
for each s ∈ S do
9:
L(state(s, oF )) = {locOMOB(s)} ∪
{fed(of) | of ∈ oF }
10:
S′ = {s′ | (s, s′) ∈ E}
11:
for each s′ ∈ S′ do
12:
R′ = {(c, M, N) ∈ R | c ∈ F(s′),
{of ∈ M \ N | |of| > 1} ⊆ oF , O(c) ⊇ ∪ M}
where O(c ∈ C) = OMOB ∪
{o ∈ O | ∃s′′ ∈ S.(c ∈ F(s′′), (o, s′′) ∈ LFIX)}
13:
if R′ ̸= ∅ then
14:
for each (c, M, N) ∈ R′ do
15:
choose o′
F ∈ OF s.t.
oF \ o′
F = {of ∈ M \ N | |of| > 1},
o′
F \ oF = {of ∈ N \ M | |of| > 1}
16:
R = R ∪ {(state(s, oF ), state(s′, o′
F ))}
17:
end for
18:
else
19:
R = R ∪ {(state(s, oF ), state(s′, oF ))}
20:
end if
21:
end for
22:
end for
23: end for
24: return (S, I, R, L)
Figure 4. Algorithm for transforming CCRN into Kripke structure
V. CASE STUDY OF THE VERIFICATION
We have conducted a case study of a veriﬁcation of a given
CCRN, using a model checking. We assume that a CCRN is
given by the designer who intend to design applications of
ubiquitous computing. Here, we use an example of museum
as shown in Fig. 5. A CCRN of this example is represented
as a tuple (O, C, R, (S, E, F), LFIX, l0) where
• O = {a, b, d, e, s},
• C = {c1, c2, c3, c4, c5, c6},
• R = {(c1, {{a}, {b}, {s}}, {{a, b}, {s}}),
(c2, {{a, b}, {d}}, {{a, b, d}}),
(c3, {{a, b, d}}, {{a, b}, {d}}),
(c4, {{a, b}, {e}}, {{a, b, e}}),
(c5, {{a, b, e}}, {{a, b}, {e}}),
(c6, {{a, b}, {s}}, {{a}, {b}, {s}}) },
• S = {s1, s2, s3, s4, s5, s6, s7, s8, s9},
69
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

(Outside)
,    and    are mobile SOs.
Catalytic Reactions:
and    are fixed SOs located at      and     respectively.
(Entrance)
(Room A)
(Room B)
Headset
Phone
Ticket
Exhibit
Exhibit
At first, a user locates at     .
: a scope of a context.
Figure 5. Example of Museum
• E = {(s1, s2), (s2, s1), (s2, s3), (s3, s2), (s3, s4), (s4, s3),
(s4, s5), (s5, s4), (s5, s9), (s9, s5), (s2, s6), (s6, s2),
(s6, s7), (s7, s6), (s7, s8), (s8, s7), (s8, s9), (s9, s8),
(s9, s1), (s1, s9)},
• F = {(s1, ∅), (s2, {c1}), (s3, {c2}), (s4, {c2, c3}), (s5, {c3}),
(s6, {c4}), (s7, {c4, c5}), (s8, {c5}), (s9, {c6})},
• LFIX = {(d, s4), (e, s7)}, and
• l0 = s1.
In this example, a user enters the entrance of a museum,
carrying a phone a, a headset b and a ticket s. Once the
user entered the entrance, the phone a and the headset b are
federated by a reaction associated with the scope of c1, which
is triggered by the ticket s. Then, the federated SOs ab are
worked as a voice guide of the museum. Next, if the user
enters into room A, the federated SO ab and an exhibit d are
federated by a reaction associated with the scope of c2. By
the federated SO abd, an explanation of the exhibit d can be
provided to the user. After this, the user leaves the room A and
the federated SO abd is decomposed and becomes ab again by
a reaction associated with the scope of c3. A similar reaction
occurs in the room B, which is for an explanation of an exhibit
e. If the user leaves one of the exhibition rooms and returns
to the entrance, the federated SO ab is decomposed before
leaving the museum.
Now we verify a CCRN of this example. Using an algorithm
shown in Fig. 4, we can obtain a Kripke structure M. Then,
the designer may give desired properties of the given CCRN
by LTL formulae such as:
• ϕ1 = G(¬(fed({a, b, d}) ∧ fed({a, b, e}))), and
• ϕ2 = G( (¬fed({a, b, d}) → F(fed({a, b, d}))) ∨
(¬fed({a, b, e}) → F(fed({a, b, e}))) ).
Intuitively saying, ϕ1 means that no more than one federation
for the explanation of exhibits exists at the same time and ϕ2
(Entrance)
(Room A)
(Room B)
Exhibit
Exhibit
Figure 6. A Counterexample of Museum Example
means that if a user enters into one of the exhibition rooms,
an explanation of each exhibit is always provided to a user.
Now we verify a CCRN using a generated Kripke struc-
ture M, ϕ1 and ϕ2. To conduct model checking, we used
NuSMV2 as a model checking veriﬁer. We have conﬁrmed that
∀π.(M, π |= ϕ1) is satisﬁed. However, ∀π.(M, π |= ϕ2) is not
satisﬁed. A model checking veriﬁer also give a counterexample
πc such as
πc = (state(s1, ∅), state(s2, {{a, b}}), state(s3, {{a, b, d}}),
state(s4, {{a, b}}), state(s5, {{a, b}}), state(s9, ∅),
state(s5, ∅), state(s4, ∅), state(s5, ∅), state(s4, ∅) . . . ).
A bold line in Fig. 6 is the visualization of πc. First, the
70
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

(Entrance)
(Room A)
(Room B)
Exhibit
Exhibit
Figure 7. Revised Museum Example
user enters the entrance of the museum, then, the user goes
to room A and goes away from room A. But the user enters
the room A again from where the user goes away. Finally, the
user stays there. In this situation, we never obtain the federated
SO abd again since the user stays in the room A. To resolve
this problem, we need appropriate constraints on the segment
graph not to cause any counterexamples of ϕ2 during model
checking.
Now we debug the system to satisfy all properties of a given
CCRN given by LTL formulae. To do so, we need to revise
the segment graph of a given CCRN of this example. We
have rewritten E of the given CCRN as follows (Fig. 7 is the
visualization of this revision):
E = {(s1, s2), (s2, s3), (s3, s4), (s4, s5), (s5, s9), (s2, s6),
(s6, s7), (s7, s8), (s8, s9), (s9, s1)}.
This revision indicates that the user should follow the regular
route of the museum.
Then, we have conducted the model checking again using
the revised Kripke structure M, ϕ1 and ϕ2. Finally, we have
conﬁrmed that both ∀π.(M, π |= ϕ1) and ∀π.(M, π |= ϕ2) are
satisﬁed. If all of these two LTL formulae are satisﬁed, this
museum meets all of requirements deﬁned by the designer of
this museum. Of course, the designer can try other properties
within range of LTL, using a combination of two kinds of
atomic propositions.
In this case study, we show that our method actually helps
designers of applications to ﬁnd exceptions of the design of
applications and to debug these exceptions using counterex-
amples provided by model checking veriﬁers through trial
and error. Using our method, we can discuss the property
such as the validity and the safety of applications consisting
of mutually related multiple federations among SOs. Formal
approaches, such as this kind of veriﬁcation, are important
because they can avoid speciﬁcations errors of ubiquitous
computing applications in advance of actual implementations
of these applications, which may incur additional costs.
VI. CONCLUSION AND FUTURE WORK
In this paper, we proposed a veriﬁcation method of appli-
cations which is described by a CCRN using model check-
ing. Using our framework, various properties of scenarios of
ubiquitous computing can be discussed by logic such as LTL.
At this time, we have considered only the case of a single
user but in future work, we will also consider the case of
multiple users. Namely, more than one user moves around,
carrying SOs simultaneously. This will enable us to consider
more complex applications of ubiquitous computing.
ACKNOWLEDGMENT
Our work is partly supported by JSPS KAKENHI(S)
15H05711.
REFERENCES
[1] M. Weiser, “The Computer for the 21st Century,” Scientiﬁc American,
vol. 265, no. 3, pp. 94–104, sep 1991.
[2] R.
Milner,
“Theories
for
the
global
ubiquitous
computer,”
in
Foundations
of
Software
Science
and
Computation
Structures.
Springer,
2004,
pp.
5–11.
[Online].
Available:
http://www.springerlink.com/index/h0261v5xde0qegef.pdf
[3] Y. Tanaka, “Proximity-based federation of smart objects: liberating
ubiquitous computing from stereotyped application scenarios,” in
Knowledge-Based
and
Intelligent
Information
and
Engineering
Systems.
Springer,
2010,
pp.
14–30.
[Online].
Available:
http://www.springerlink.com/index/103TL30123728248.pdf
[4] J. Julia and Y. Tanaka, “Proximity-based federation of smart objects,”
Journal of Intelligent Information Systems, vol. 46, no. 1, pp. 147–178,
feb 2016. [Online]. Available: http://link.springer.com/10.1007/s10844-
015-0357-4
[5] R. Alur and D. L. Dill, “A theory of timed automata,” Theoretical
Computer Science, vol. 126, no. 2, pp. 183–235, apr 1994. [Online].
Available: http://linkinghub.elsevier.com/retrieve/pii/0304397594900108
[6] R. Drechsler and U. K¨uhne, Eds., Formal Modeling and Veriﬁcation of
Cyber-Physical Systems. Wiesbaden: Springer Fachmedien Wiesbaden,
2015. [Online]. Available: http://link.springer.com/10.1007/978-3-658-
09994-7
[7] C. Xu and S. C. Cheung, “Inconsistency Detection and Resolution
for Context-aware Middleware Support,” Proceedings of the 10th
European
Software
Engineering
Conference
Held
Jointly
with
13th ACM SIGSOFT International Symposium on Foundations of
Software
Engineering,
pp.
336–345,
2005.
[Online].
Available:
http://doi.acm.org/10.1145/1081706.1081759
[8] S. Kauffman, Investigations.
Oxford New York: Oxford University
Press, 2002.
[9] J.
Burch,
E.
Clarke,
K.
McMillan,
and
D.
Dill,
“Sequential
circuit
veriﬁcation
using
symbolic
model
checking,”
in
27th
ACM/IEEE
Design
Automation
Conference,
vol.
13,
no.
4.
IEEE,
1994,
pp.
46–51.
[Online].
Available:
http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=114827
[10] J. C. Mitchell, V. Shmatikov, and U. Stern, “Finite-state Analysis
of SSL 3.0,” in Proceedings of the 7th Conference on USENIX
Security Symposium - Volume 7, ser. SSYM’98.
Berkeley, CA,
USA:
USENIX
Association,
1998,
p.
16.
[Online].
Available:
http://dl.acm.org/citation.cfm?id=1267549.1267565
[11] S. A. Kripke, “Semantical Analysis of Modal Logic I Normal Modal
Propositional Calculi,” Zeitschrift f¨ur Mathematische Logik und Grund-
lagen der Mathematik, vol. 9, no. 5-6, pp. 67–96, 1963.
[12] A. Pnueli, “The temporal logic of programs,” 18th Annual Symposium
on Foundations of Computer Science (sfcs 1977), pp. 46–57, 1977.
[13] G. Holzmann, “The model checker SPIN,” IEEE Transactions on
Software Engineering, vol. 23, no. 5, pp. 279–295, may 1997.
[14] J. Magee and J. Kramer, Concurrency State Models and Java Programs.
New York, New York, USA: John Wiley and Sons, 1999.
[15] A.
Cimatti,
E.
Clarke,
and
E.
Giunchiglia,
“Nusmv
2:
An
opensource tool for symbolic model checking,” Computer Aided
Veriﬁcation,
vol.
2404,
pp.
359–364,
2002.
[Online].
Available:
http://link.springer.com/chapter/10.1007/3-540-45657-0 29
71
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-505-0
UBICOMM 2016 : The Tenth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies

