Automated Generation of Requirements-Based Test Cases for an Automotive Function
using the SCADE Toolchain
Adina Aniculaesei∗, Andreas Vorwald∗ and Andreas Rausch∗
∗ Institute for Software and Systems Engineering
Technische Universit¨at Clausthal, Clausthal-Zellerfeld, Germany
Email: adina.aniculaesei@tu-clausthal.de, andreas.vorwald@tu-clausthal.de, andreas.rausch@tu-clausthal.de
Abstract—Results of acceptance tests trigger various adaptations
in the architecture and design of a complex software system.
Several adaptation iterations are needed until all acceptance tests
are successfully passed. Checking whether the adapted software
system complies with an extensive catalogue of requirements is
an elaborate task, which cannot be managed only via manual
testing anymore. Over the years, model checking has established
itself as an efﬁcient method for the generation of requirements-
based test cases. At the same time, the traction gained by model-
based development tools, such as SCADE Suite, especially in the
automotive and the avionics domains, facilitates the use of formal
methods for the analysis and veriﬁcation of complex software
systems developed in these industries. This paper describes an
approach which supports the generation of test cases from
formalized requirements using the SCADE toolchain. In order to
evaluate the applicability of our approach, we apply our concept
on a simple system from the automotive domain and discuss
outcomming results.
Keywords–architecture adaptation; model-based development;
requirements-based testing; model checking; automotive function;
SCADE toolchain
I.
INTRODUCTION
Control systems are installed in cars with the purpose to
improve the driving experience and increase the safety of the
vehicles and their passengers. Tasks which were previously
carried out by the driver are now performed by complex
software systems. An immediate consequence of this software
complexity is that extensive catalogues of system requirements
have become more common in the automotive industry [1].
Throughout their life cycle, automotive software systems
are subjected to various modiﬁcations, which originate in
different sources, e.g., change requests caused by defect re-
moval or system enhancements triggered by end user demands.
Once the changes have been implemented, the software system
must pass the acceptance tests again in order to get into
series production. This means that the software system must
satisfy every requirement in the catalogue. Test results may
expose further defects in the system design or in the system
implementation. Thus, the architecture of the software system
and its implementation may go through a series of adapta-
tion iterations until the system has successfully passed all
acceptance tests. These adaptations may further increase the
complexity of the software system.
Software testing is a process which requires a lot of expert
knowledge. Testing complex software systems against large
requirements catalogue is a task which cannot be managed
manually anymore. In the automotive industry, requirements
speciﬁcations are often maintained as informal documents.
In the best case scenario, they are broken down into lists
of individual requirements, which are then maintained using
a dedicated tool, e.g., IBM’s Doors. The large number of
requirements for every product version makes it impossible to
guarantee consistency and to test the requirements in a rigorous
manner. In the automotive domain, model-based development
is used by software engineers to create formal models of the
desired software system early in the development lifecycle and
to test the software against these models, e.g., through back-
to-back testing.
We have established the formal connection between system
models and system requirements for the automotive domain in
a previous work [2]. In [2], we used the approach presented
in [3] and generated requirements-based test cases via model
checking for a prototype of an adaptive cruise control system.
Since model-based development has gained so much traction
in the automotive industry, we are interested in ﬁnding out
whether the approach developed in [2] is also applicable
with software toolchains used in model-based development.
In this paper, we focus on the SCADE toolchain [4] and we
investigate the following research question:
RQ: How can the SCADE toolchain be used to generate
requirements-based test cases for an automotive func-
tion?
As research methodology, we build an academic case study
of a control system in the automotive domain. We apply
requirements-based test case generation to a simple prototype
of a door locking system using the SCADE Design Veriﬁer as
model checker. For the sake of simplicity, we formulate only
one requirement for the door locking system. For this purpose,
we use a controlled natural language with speciﬁc sentence
patterns, showing which is the subject and which is the object
targeted by the requirement [5]. Our work is meant to offer
support to the test engineers, who need to develop meaningful
and cost-efﬁcient tests, but also to the software developers and
software architects, who must decide on the basis of the test
results whether any system adaptations are necessary.
Related Work. Using model checking for test-case gen-
eration is by now a well-known approach. The paper in [6]
uses model checking to generate MC/DC model-based test
sequences from the mode logic of a ﬂight-guidance system. For
the same type of system, Whalen et al. [3] use model checking
to generate requirements-based test cases on the basis of three
speciﬁc criteria: requirements coverage, antecedent coverage
and unique ﬁrst cause. In [7], the approach presented in [3]
is evaluated on four industrial examples from the avionics
domain. All four systems were modeled in the Simulink
notation from Mathworks and then translated to the Lustre
synchronous programming language for the purpose of test
case generation.
Generating test cases from natural language requirements
69
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

is addressed among others in [8]. The approach uses NLP in
order to generate knowledge graphs. Different graph traversing
methods are used to construct the test cases. Other approaches
use UML diagrams such as use-case or sequence diagrams for
test generation [9] [10].
In [11], a translator framework is introduced which al-
lows the translation of commercial modeling languages, e.g.,
SCADE, in the input languages of veriﬁcation tools, e.g.,
Prover or PVS. This allows the integration of commercial
model-based development tools with veriﬁcation tools. The
approach is demonstrated on several case studies from the
avionics domain.
In this work, we provide a concept for a requirements-
based test case generation, which is fully integrated with the
SCADE toolchain. We apply it on an example system from the
automotive domain. Some of the foundations of our approach
are provided by the work of Whalen et al. in [3], [12], and
[11].
Paper Outline. In Section II we describe preliminary no-
tions, which are necessary to understand the approach pre-
sented in this work. In Section III, we give an overview of our
concept. Section IV introduces our case study, while Section
V describes the experiment carried out on the example system.
In Section VI, we present the results of our experiment and
discusses the lessons learned from this work. Section VII
concludes the paper with a summary of our contribution and
an overview of future work.
II.
PRELIMINARIES
In this section, we present the basic process of model
checking and explain how this method can be used to generate
test cases from system requirements. Furthermore, an overview
of model-based development and formal veriﬁcation with
SCADE is given.
Basic Process of Model Checking. Given a system model
and a system property to verify, a model checker builds a
formal representation of the system model in the form of a
ﬁnite state machine and explores its state space in search for
states which falsify the system property. If the system property
is falsiﬁed, the model checker returns a counter-example trace,
showing how the state which falsiﬁes the system property can
be reached from the initial state of the system model.
Generation of Test Cases with Model Checking. Throughout
the years, model checking has established itself as an efﬁcient
method to generate test cases from system requirements. One
possibility to generate test cases using model checking is
to build trap properties [3]. Trap properties are basically
negations of the system properties, which are satisﬁed by the
system model if the latter is correctly built. While verifying
the system model against a trap property, the model checker
searches for a counter-example to disprove the trap property.
By the law of double negation in propositional logic, the
counter-example which disproves the trap property is in fact an
example showing how the original system property is satisﬁed.
The counter-example is then used as a basis for building a
requirements-based test case, which checks if the System under
Test (SuT) satisﬁes the respective system requirement.
Model-based Development with SCADE. SCADE Suite is
a development environment used for the model-based design
and development of software system components.Software
components are encapsulated in SCADE operators, which,
in turn, are organised in SCADE projects. Each SCADE
operator has inputs and outputs, which form the interface of
the respective software component. The formal basis of the
SCADE language is given by the declarative language Lustre
and is deﬁned in [4]. The systems of equations speciﬁc to the
language Lustre are used to model the dataﬂow inside SCADE
operators, connecting the input ﬂows to the output ﬂows of the
operator. Hierarchical state machines are used to describe the
control ﬂow of SCADE operators.
Formal Veriﬁcation with SCADE Design Veriﬁer. In SCADE
Suite, formal veriﬁcation is performed using SCADE Design
Veriﬁer, a model checker based on a SAT-solver [13] [14]. The
SCADE Design Veriﬁer works on the basis of the SCADE
observer principle. System properties which must be veriﬁed
with the SCADE Design Veriﬁer are ﬁrst encapsulated as
observers. An observer is a SCADE operator which takes as
input both the input ﬂows and the output ﬂows of the system
model. The observer produces a Boolean output ﬂag. The
system property is satisﬁed if the observer’s output evaluates
to true in every computation cycle. Should the ﬂag evaluate
to false in one computation cycle, the SCADE Design Veriﬁer
returns a counter-example which shows why this answer has
been reached.
III.
TEST CASE GENERATION FROM REQUIREMENTS
USING THE SCADE TOOLCHAIN
An overview of our approach is given in Figure 1. The
concept illustrates the necessary steps for the generation and
execution of requirements-based test cases.
System Model Construction and System Requirement For-
malization. The system requirement is manually formalized as
an obligation in Linear Temporal Logic (LTL). The system
model is designed with SCADE Suite on the basis of the
system requirement, and therefore satisﬁes the LTL obliga-
tion. Both the system model and the system requirement are
presented in Section IV.
Trap Property Generation. A trap property is the negation
of an LTL obligation which is satisﬁed by the system model.
Since the test case generation process using the SCADE
toolchain is the focus of this paper, we limit ourselves to using
only the Requirements Coverage (RC) criterium to build the
trap property corresponding to the LTL obligation.
Test Case Generation using Model Checking. The system
model and the trap property are given as input to the SCADE
Design Veriﬁer in order to generate traces. In the classical
model checking process, the model checker explores the entire
state space of the system model consisting of all the combi-
nations of inputs and states in order to ﬁnd violations of the
LTL obligation. If found, then the model checker produces a
conterexample trace which shows how the LTL obligation can
be falsiﬁed. The trace is in turn transformed into a test case
with which the SuT can be later executed.
Test Case Execution. The SuT, in our case the SCADE
system model, is loaded in the SCADE Test Environment and
then executed with the test input data speciﬁed in the generated
test case.
IV.
CASE STUDY EXAMPPLE
Our case study is constructed around a simple prototype
of a door locking system in an automobile. The door locking
system is regarded as a safety feature for the vehicle, as its
primary goal is to ensure that the doors do not open while the
70
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

LTL-Obligations
ANSYS SCADE 
Design Verifier
Trace2TestCase
LTL 
Trap Properties
Traces
Test Cases
LTL2Trap
LTL2SCADE
SCADE
Trap Properties
Test Results
System under Test
Automated Test Case Generation System
Requirements
Formalisation
Derivation
SCADE System Model
Notation:
- existent tools
- implemented tools
- manual step
Figure 1. Test Case Generation from Requirements using the SCADE Toolchain.
vehicle is moving. Figure 2 depicts the implementation of the
door locking system in the SCADE Suite.
<company>
Doorlock_1/Doorlock
Fri Mar 22 17:17:26 2019
1
STATE_RUNNING
Current_State
Opendoor
f alse
Opendoor
f alse
Doorknob
<Opendoor_Decision>
Engine_Running
Current_State
STATE_STOPPED
Doorknob
Opendoor
f alse
Opendoor
true
<Opendoor_Decision>
Engine_Stopped
<SM_Door_Locking_Sy stem>
1
Start
1
 not Start
Figure 2. Case Study Example: A Simple Door Locking System.
A. System Model
We model the door locking system in strong correlation with
the current vehicle status. Our example system is modeled as
a state machine with two states which describe the vehicle
status: state Engine_Running for the moving vehicle and
state Engine_Stopped for the stillstanding vehicle. For the
purpose of this case study, the functionality of the door locking
system is kept rather simple. Thus, if a vehicle passenger
operates the door handle while the engine is running, then
the vehicle door stays closed. On the other side, if the engine
is stopped and the vehicle passenger operates the door handle,
then vehicle door opens.
The input interfaces of the door locking system consist
of the boolean ﬂags Doorknob and Start, which model
the operation of the door handle by the vehicle passenger
and respectively the start/stop of the vehicle engine. The
output interfaces of the door locking system are represented
by the boolean ﬂag Opendoor and the enumeration variable
Current_State. The former models the status of the door
vehicle (opened/closed). The latter switches between the con-
stants STATE_STOPPED = 0 and STATE_RUNNING = 1,
in order to keep track of the current state of the vehicle.
B. System Requirements
For the purpose of simplicity, we formulate one safety
requirement for the door locking system. The system require-
ment, formulated in a controlled natural language [5], reads as
follows:
R1. If the motor is running and the doorknob is pushed,
then the door shall not be opened.
V.
FORMALIZATION AND TEST CASE GENERATION
Our process for the generation of test cases from require-
ments has already been published in a previous work [2].
However, the purpose of this paper is to automatize this process
using the SCADE toolchain. For the purpose of completeness,
we present the steps of the test case generation process,
highlighting the details speciﬁc for the work with the SCADE
toolchain:
A. From System Requirements to LTL Obligations
We build the LTL obligation for the door locking system
from the system requirement R1, presented in Section IV. The
corresponding LTL obligation is written in (1):
φ : G(Current State = STATE RUNNING ∧
Doorknob → X(Opendoor = false))
(1)
Observe that time model of LTL differs from the time model
of the SCADE language, i.e., LTL looks from the present time
point into the future while SCADE looks from the present
point into the past. Therefore, the LTL obligation in (1) must
be transformed using the last operator as shown in (2), so
that it conforms to the SCADE time model:
φ : G(last′Current State = STATE RUNNING ∧
Doorknob → X(last′Opendoor = false))
(2)
B. From LTL Obligations to Traces
In order to obtain a test case which satisﬁes the system
requirement R1, the ﬁrst step is to build a trap property by
simply negating the LTL obligation shown in (2). Thus, the
corresponding trap property for requirement R1 is given in
71
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

(3):
φ : ¬G(last′Current State = STATE RUNNING ∧
Doorknob → X(last′Opendoor = false)) (3)
The trap property is then transformed in SCADE code
against which the SCADE system model can be veriﬁed using
SCADE Design Veriﬁer as model checker. Figure 3 gives an
overview of the necessary steps for the transformation of the
LTL trap property in SCADE code.
LTL2SCADE
BA as SCADE code
Notation:
- existent tools
LTL Parser
LTL Expression
𝐺(𝑎 ∧ 𝑏 ∨ 𝑐)
LTL as Abstract 
Syntax Tree
Transformation 
Rules
BA Grammar
SCADE Grammar
Transformation 
Rules Dictionary
Transformation Rules 
Evaluation Engine
- implemented tools
LTL Grammar
Parser 
Generator
SCADE System Modell
LTL2BA
NBA
Figure 3. Transformation of LTL Obligations in SCADE Code.
LTL Parser Generation and AST Construction. We generate
an LTL parser on the basis of the LTL grammar, in order ensure
the correct parsing of the system requirements formalised
in LTL with respect to operator priority rules. The operator
precedence is encoded in the Abstract Syntax Tree (AST).
In our implementation of the LTL grammar, the logical and
temporal operators of LTL, as well as the arithmetic operators
are nonterminal symbols. As terminal symbols, our grammar
allows the boolean constants, true and false, variable names
and arithmetic constants in atomic propositions, e.g a ≤ 10,
but also the keyword last, which is speciﬁc to the SCADE
language.
B¨uchi Automaton Construction. The common basis of LTL
and SCADE is represented by automata. This is based on the
fact that the concept of automata is integrated in the SCADE
language [15] [4], and that nondeterministic B¨uchi automata
(NBA) are an alternate representation of LTL formulae [16].
Figure 4 illustrates the steps needed to transform an LTL
formula into an NBA. This transformation is based on the algo-
rithm deﬁned by Gerth et al. in [17]. The algorithm transforms
an LTL formula expressed in positive normal form (PNF) into a
generalized nondeterministic B¨uchi automaton (GNBA). Once
this transformation is complete, only atomic propositions occur
as transition guards. The atomic propositions are connected
via the logical operator AND (∧), if there is more than one
as transition guard on the same transition. Then, the GNBA is
transformed into an NBA using the algorithm presented in [16].
The NBA constructed from the trap property of requirement
R1 is presented in Figure 5.
LTL2BA
LTL as Abstract 
Syntax Tree
LTL2PNF
LTL2GNBA
PNF as Abstract 
Syntax Tree
LTL2NBA
GNBA
NBA
Notation:
- implemented tools
- existent tools
Figure 4. Transformation of LTL Obligations in Non-deterministic B¨uchi
Automata.
(′𝑛𝑜𝑑𝑒2′, 0)
(′𝑖𝑛𝑖𝑡′, 0)
(′𝑛𝑜𝑑𝑒6′, 0)
(′𝑛𝑜𝑑𝑒7′, 0)
𝑡𝑟𝑢𝑒
𝑡𝑟𝑢𝑒
𝑙𝑎𝑠𝑡 ′𝑐𝑢𝑟𝑟𝑒𝑛𝑡_𝑠𝑡𝑎𝑡𝑒 = 𝑆𝑇𝐴𝑇𝐸_𝑅𝑈𝑁𝑁𝐼𝑁𝐺
𝑡𝑟𝑢𝑒
𝑛𝑜𝑡 𝑙𝑎𝑠𝑡 ′𝑂𝑝𝑒𝑛𝑑𝑜𝑜𝑟
𝑙𝑎𝑠𝑡 ′𝑐𝑢𝑟𝑟𝑒𝑛𝑡_𝑠𝑡𝑎𝑡𝑒 = 𝑆𝑇𝐴𝑇𝐸_𝑅𝑈𝑁𝑁𝐼𝑁𝐺
Notation:
- accepting state
- normal state
- transition
- initial state
Figure 5. B¨uchi Automaton for Requirements R1.
SCADE Code Generation. The core idea of this process
step is to create for each LTL trap property a new SCADE
operator which has the same input as the SCADE system
model. This SCADE operator is then used later to generate
test cases. The inputs of the new SCADE operator are redi-
rected to the SCADE system model to perform a computation
cycle. Then, a unique output as observer for the LTL trap
property and a corresponding state machine implementing
the NBA of the LTL trap property are created. Furthermore,
the name of the SCADE system model is used in order
to build the name of the newly created SCADE operator:
<SCADE-system-model>_proof. Figure 6 shows the
SCADE Code generated for the system requirement R1.
node Doorlock_proof(Doorknob : bool; Start : bool)
returns (output0 : bool default = false)
var
Opendoor : bool last = false;
Current_State : uint8 last = 0;
_counter0 : uint64 default = 1 + last '_counter0 last = 0;
let
Opendoor, Current_State = Doorlock(Doorknob, Start);
_ = Opendoor;
_ = Current_State;
automaton SM0
initial state init_0
unless
if (last 'Current_State = STATE_RUNNING) and Start do
let
output0 = true;
_counter0 = 0;
tel
restart node6_0;
if true do
let
output0 = true;
_counter0 = 0;
tel
restart node2_0;
state node2_0
unless
if (last 'Current_State = STATE_RUNNING) and Start do
let
output0 = true;
_counter0 = 0;
tel
restart node6_0;
if true and last '_counter0 <= 1 do
let
output0 = true;
tel
restart node2_0;
state node6_0
unless
if (not last 'Opendoor) do
let
output0 = true;
_counter0 = 0;
tel
restart node7_0;
state node7_0
unless
if true do
let
output0 = true;
_counter0 = 0;
tel
restart node7_0;
returns .. ;
tel
Figure 6. SCADE code corresponding to the NBA generated from
Requirement R1.
The SCADE Design Veriﬁer is the model checker of the
SCADE Suite and can be interfaced by using observers which
are evaluated in each computation cycle during the state space
exploration [15]. The model checker explores the state space
in search of a trace which falsiﬁes the trap property. It stops
the state space exploration when it has exhausted the entire
state space or when the observer of the trap property switches
to false. When the latter occurs, a trace of input assignments
is printed, which shows how the trap property can be falsiﬁed.
In SCADE, an NBA is represented by a statemachine.
Automata are a feature of SCADE, and respectively of the
Lustre language [15] [4]. Figure 7 illustrates the transfor-
mation of the NBA corresponding to the requirement R1 in
SCADE based on two transitions extracted from Figure 5.
Every state of the NBA is represented in SCADE via the
keyword state, while the initial state of the NBA is also
marked by the keyword initial. A transition in the NBA
is transformed into an if-statement within the state. In order
to ensure optimal transition execution, the outgoing transitions
of a state are sorted descending according to the number of
72
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

transition guards. For example, if a state s1 has two outgoing
transitions, (s1, a0, s2) and (s1, a0 ∧ a1, s3), then the second
one is prefered.
(′𝑛𝑜𝑑𝑒6′, 0)
(′𝑛𝑜𝑑𝑒7′, 0)
𝑡𝑟𝑢𝑒
𝑛𝑜𝑡 𝑙𝑎𝑠𝑡 ′𝑂𝑝𝑒𝑛𝑑𝑜𝑜𝑟
[…]
restart node2_0;
state node6_0
unless
if (not last 'Opendoor) do
let
output0 = true;
_counter0 = 0;
tel
restart node7_0;
state node7_0
unless
if true do
let
output0 = true;
_counter0 = 0;
tel
restart node7_0;
returns .. ;
tel
Transitions in the non-deterministic
Büchi Automaton
Excerpt of the corresponding code
generated in Lustre
Figure 7. Excerpt of Transformation from non-deterministic B¨uchi Automata
to Lustre code.
C. From Traces to Test Cases
The trace generated by the SCADE Design Verifer contains
only test input data. However, in order to get the full test case,
output data are also needed. Figure 8 displays the workﬂow
used to obtain the test output data and generate test cases.
Trace2TestCase
Extraction of Test Input 
Data for Simulation
SCADE 
Simulator
Assembly of
Test Cases
Notation:
- implemented tools
- existent tools
Test Input Data
Traces
Test Output Data
Test Cases
Figure 8. Transformation of Traces in Test Cases.
To begin with, the test input data is extracted from the trace.
Then, the SCADE system model is run with the test input data
in the SCADE Simulator. The test output data obtained from
the simulation is assembled with the test input data extracted
from the trace in a test case ﬁle (.sss-ﬁle), which can later
be run in the SCADE Test Environment. A trace and the
corresponding test case showing how requirement R1 may be
satisﬁed are shown in Figure 9.
VI.
EVALUATION
A. Setup
The system in Figure 2 was modeled in ANSYS SCADE
19.1 (build 20180327). To implement the workﬂow described
in Figure 1, a Python 3.4 script using the Python-API of
SCADE was created. The parser was then generated with the
parser generator ply [18].
The SuT was then executed with the test case obtained
from the system requirement R1. The results of the test case
execution are displayed in Figure 10.
B. Lessons Learned
In order to successfully generate requirements-based test
cases with the SCADE toolchain, test engineers must under-
stand the innerworkings of SCADE state machines. According
# ---------------------------------------------------------------
# Simulation scenario file for SCADE Simulator
# Task:  Doorlock_proof.output0
# Model: Verifier
# Node:  Doorlock
# ---------------------------------------------------------------
SSM::set Doorlock_proof/Doorknob t
SSM::set Doorlock_proof/Start f
SSM::cycle
SSM::set Doorlock_proof/Doorknob t
SSM::set Doorlock_proof/Start t
SSM::cycle
SSM::set Doorlock_proof/Doorknob f
SSM::set Doorlock_proof/Start f
SSM::cycle
SSM::set Doorlock_proof/Doorknob f
SSM::set Doorlock_proof/Start f
SSM::cycle
(a)
SSM::set Doorlock/Doorknob t
SSM::set Doorlock/Start f
SSM::check Doorlock/Opendoor t
SSM::check Doorlock/Current_State 0
SSM::cycle
SSM::set Doorlock/Doorknob t
SSM::set Doorlock/Start t
SSM::check Doorlock/Opendoor f
SSM::check Doorlock/Current_State 1
SSM::cycle
SSM::set Doorlock/Doorknob f
SSM::set Doorlock/Start f
SSM::check Doorlock/Opendoor f
SSM::check Doorlock/Current_State 0
SSM::cycle
SSM::set Doorlock/Doorknob f
SSM::set Doorlock/Start f
SSM::check Doorlock/Opendoor f
SSM::check Doorlock/Current_State 0
SSM::cycle
(b)
Figure 9. a) Trace generated with the SCADE Design Veriﬁer out of the
System Requirement R1; b) Test Case generated from the Trace in a) with
the SCADE Simulator.
Figure 10. Execution of the System under Test with the Generated Test Case.
to their semantics, the data ﬂow which connects the inputs to
the outputs of a state in a SCADE state machine is executed
synchronously in a single cycle, before any active transitions
in the system model can be ﬁred.
Often, it is necessary to know the state in which the
computation of state variables used within a cycle originated.
This is why it is often indispensable to make use of the
last operator, especially for system requirements formu-
lated over state variables. Take for example LTL formulae
of the form G(µ → Xψ) in which the logical formulae µ
and ψ are expressed over state variables. In this case, the
SCADE operator last is needed for the state variables in
µ as well as for those in ψ, in order to get the state from
which the calculation within a cycle starts. The use of the
SCADE operator last can vary, depending on the system
requirement and on the implementation of the system model.
Since we found no sound way to normalize it, we decided
to enable the use of this operator. Indeed, syntactically the
last operator is considered as a terminal symbol, yet it has
effect on LTL operators. To be more speciﬁc, the LTL formula
G(a ≤ 10 → X(last′ b = 5)) is semantically equivalent to the
LTL formula G(a ≤ 10 → b = 5), where b is a state variable
in the current state. Here, the effect of the last operator on
the LTL operator X (neXt) is similar to that of the absorbtion
law in propositional logic. It is then up to the test engineers to
decide whether the usage of the last operator is appropriate,
depending on the system requirements and on the SCADE
system model.
Furthermore, one has to consider that the link between
SCADE and LTL is not perfect. Nondeterministic B¨uchi
automata are usually used in automata-based LTL model
checking to construct the product transition system of the
73
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

negated property and the system model [16]. The SCADE
Design Veriﬁer is built on top of a SAT-Solver [13], with
the property observer as its interface. This allowed us to
use nondeterministic B¨uchi automata as a uniform approach
to create chronological state sequences from LTL formulae.
However, for LTL (sub-)formulae of the type µ U ψ, the
generated NBA contains non-accepting states. These states can
have recursive transitions, which always ﬁre. This behavior
leads to endless loops, which in turn can generate wrong
results. We solved this problem by adding a counter which
increments up to a predeﬁned maximum value everytime a
recursive transition of a non-accepting state ﬁres. The counter
is then reset, if the next state is an accepting state. The
maximum value can be deﬁned by the test engineer. The
deﬁned value should not be too high, as it may cause long or
indeterminate system runs, and not too low, so that correctness
can be ensured.
VII.
CONCLUSION AND FUTURE WORK
In this paper, we implemented the concept deﬁned by
Aniculaesei et al. [2] on the industrial toolchain ANSYS
SCADE, in order to generate test cases straight from the
system requirements formalized in LTL and the SCADE sys-
tem model. We used the SCADE Design Veriﬁer as model
checker to deliver test inputs in form of traces, which were then
simulated to calculate the corresponding test outputs. The test
cases, containing the test inputs and outputs, were assembled
in SCADE scenario ﬁles (.sss-ﬁles). The scenario ﬁles are
given as input to the SCADE Testing Environment in order to
automatically execute the test cases on the System under Test,
in this case the SCADE system model itself.
In order to connect LTL with SCADE, we needed to express
chronological sequences of states over inﬁnite time. For this
purpose, we generated nondeterministic B¨uchi automata from
formalised requirements in LTL by applying the algorithm
deﬁned by Gerth et al. in [17]. Here, we found out that this
connection is not all-embracing when non-accepting states
with recursive transitions occur in the generated NBA (see
Section VI). Since we found no uniform concept for mapping
of the LTL time model onto the SCADE time model, we
enabled the use of last operator from SCADE in terminal
symbols and we gave the user the liberty to decide upon the
usage of this operator within LTL formulas. Based on our
case study, valid test cases were generated (see Figure 9) and
executed (see Figure 10).
In future work, we want to extend the concept for
requirements-based test case generation developed for the
SCADE toolchain with the approach in [2]. We plan to apply
the extended concept on a more complex system in the automo-
tive ﬁeld. Here we plan to use construction methodologies for
test case generation via model checking based on three differ-
ent criteria, requirements coverage (RC), antecedent coverage
(AC) and unique ﬁrst cause coverage (UFC) as deﬁned in [3]
[7]. Furthermore, we plan to measure the quality of our test
suites with respect to MC/DC Coverage [19] [20] by creating
mutants on code level.
REFERENCES
[1]
M. Fockel, J. Holtmann, and M. Meyer, “Mit Satzmustern hochwer-
tige Anforderungsdokumente efﬁzient erstellen (engl.: Using Sentence
Patterns to Efﬁciently Create High-quality Requirements Documents),”
OBJEKTspektrum, no. RE/2014, jun 2014, pp. 1–4.
[2]
A. Aniculaesei, F. Howar, P. Denecke, and A. Rausch, “Automated
generation of Requirements-Based Test Cases for an Adaptive Cruise
Control System,” in 2018 IEEE Workshop on Validation, Analysis and
Evolution of Software Tests (VST@SANER).
IEEE, 2018, pp. 11–15.
[3]
M. W. Whalen, A. Rajan, M. P. Heimdahl, and S. P. Miller, “Coverage
metrics for requirements-based testing,” in Proceedings of the 2006
international symposium on Software testing and analysis, L. Pollock
and M. Pezz`e, Eds.
New York, NY: ACM, 2006, pp. 25–36.
[4]
Esterel Technologies S.A.S., Scade Language Reference Manual.
AN-
SYS, Inc., 2018.
[5]
C. Rupp and SOPHISTen, “Schablonen f¨ur alle F¨alle (engl.: Patterns
for all Purposes),” SOPHIST GmbH, 2016. [Online]. Available: https://
www.sophist.de/ﬁleadmin/user upload/Bilder zu Seiten/Publikationen/
Wissen for free/MASTeR Broschuere 3-Auﬂage interaktiv.pdf
[6]
S. Rayadurgam and M. P. E. Heimdahl, “Generating mc/dc adequate
test sequences through model checking,” in Proceedings of 28th Annual
NASA Goddard Software Engineering Workshop. IEEE, 2003, pp. 91–
96.
[7]
M. Staats, M. W. Whalen, M. P. E. Heindahl, and A. Rajan, “Coverage
metrics for requirements-based testing: Evaluation of effectiveness,”
in Proceedings of the Second NASA Formal Methods Symposium.
NASA, april 2010, pp. 161–170.
[8]
P. P. Kulkarni and Y. Joglekar, “Generating and Analyzing Test cases
from Software Requirements using NLP and Hadoop,” International
Journal of Current Engineering and Technology, vol. 4, no. 6, 2014,
pp. 3934–3937.
[9]
N. Kosindrdecha and J. Daengdej, “A test case generation technique
and process,” Journal of Software Engineering, vol. 4, no. 4, 2010, pp.
265–287.
[10]
C. Nebut, S. Pickin, Y. Le Traon, and J.-M. J´ez´equel, “Automated
Requirements-based Generation of Test Cases for Product Families,”
in Proceedings of 18th IEEE International Conference on Automated
Software Engineering, 2003.
Montreal, Quebec, Canada: IEEE, 2003,
pp. 263–266.
[11]
S. P. Miller, M. W. Whalen, and D. D. Cofer, “Software model
checking takes off,” Commununications of the ACM, vol. 53, no. 2,
feb 2010, pp. 58–64. [Online]. Available: http://doi.acm.org/10.1145/
1646353.1646372
[12]
M. Whalen, D. Cofer, S. Miller, B. H. Krogh, and W. Storm,
“Integration
of
Formal
Analysis
into
a
Model-based
Software
Development Process,” in Proceedings of the 12th International
Conference on Formal Methods for Industrial Critical Systems, ser.
FMICS’07.
Berlin, Heidelberg: Springer-Verlag, 2008, pp. 68–84.
[Online]. Available: http://dl.acm.org/citation.cfm?id=1793603.1793612
[13]
A. Bouali and B. Dion, “Formal veriﬁcation for model-based develop-
ment,” SAE transactions, 2005, pp. 171–181.
[14]
Esterel Technologies S.A.S., SCADE Suite User Manual.
ANSYS,
Inc., 2018, vol. SCS-UM-19 - DOC/rev/35771-03.
[15]
——, Scade Language Primer.
ANSYS, Inc., 2018.
[16]
C. Baier and J.-P. Katoen, Principles of model checking.
Cambridge,
Massachusetts, USA: MIT Press, 2008.
[17]
R. Gerth, D. Peled, M. Y. Vardi, and P. Wolper, “Simple on-the-ﬂy
automatic veriﬁcation of linear temporal logic,” in Proceedings of
the Fifteenth IFIP WG6.1 International Symposium on Protocol
Speciﬁcation, Testing and Veriﬁcation XV.
London, UK, UK:
Chapman
&
Hall,
Ltd.,
1996,
pp.
3–18.
[Online].
Available:
http://dl.acm.org/citation.cfm?id=645837.670574
[18]
“PLY (Python Lex-Yacc),” accessed: 21.03.2019. [Online]. Available:
https://www.dabeaz.com/ply/
[19]
J. J. Chilenski and S. P. Miller, “Applicability of modiﬁed con-
dition/decision coverage to software testing,” Software Engineering
Journal, vol. 9, no. 5, 1994, pp. 193–200.
[20]
K.
Hayhurst,
D.
S.
Veerhusen,
J.
J.
Chilenski,
and
L.
K.
Rierson,
“A
Practical
Tutorial
on
Modiﬁed
Condition/Decision
Coverage,” National Aeronautics and Space Administration, Langley
Research
Center,
Tech.
Rep.,
2001.
[Online].
Available:
https:
//ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20010057789.pdf
74
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-706-1
ADAPTIVE 2019 : The Eleventh International Conference on Adaptive and Self-Adaptive Systems and Applications

