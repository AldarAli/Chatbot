Towards a Formal Semantics for System Calls in terms of Information Flow
Laurent Georget
Guillaume Piolle
Fr´ed´eric Tronel
Val´erie Viˆet Triem Tong
EPC CIDRE SUPELEC/INRIA/CNRS/University of Rennes 1
Rennes, France
Email: ﬁrst name.last name@supelec.fr
Mathieu Jaume
Team MoVe, UPMC LIP6
Paris, France
Email: mathieu.jaume@lip6.fr
Abstract—We propose a new semantics for system calls, which
focuses on the information ﬂows they generate in a UNIX OS.
We built a prototypal model of an OS and system calls using the
concurrent transaction logic along with its interpreter. We have
yet a few results and applications that show the usefulness of
our semantics to model an OS from a kernel point of view. Once
completed, we expect our semantics to enable us to extensively
test security software implemented inside the kernel, among other
use cases.
Keywords—Operating Systems; Security; System Calls; Infor-
mation Flow.
I. INTRODUCTION
In an operating system (OS), system calls deﬁne a clear
boundary between the kernel-land, where lives the core part
of the OS and the userland, which contains all the end-user
applications. While the kernel runs with all privileges on the
hardware, the user applications are granted only few rights
to prevent them from interfering with each other. When such
applications want to perform tasks requiring an access to the
hardware or to communicate with each other, they need to ask
the kernel for this service by the mean of system calls. Those
are the only code interfaces between kernel-land and userland.
System calls are necessary because they enable the userland
processes to achieve complex tasks. By allowing processes
to communicate with each other and storing data, they let
information ﬂow in the system, which is necessary for all kinds
of tasks. However, this can also be problematic because OS
security mechanisms mostly rely on access control which can
only prevent access to containers of information, and not to
the information itself. Therefore, once a piece of information
has left its original container, it is difﬁcult to control the way
it is accessed. One way to keep being able to know where
each piece of information is in the system is to monitor the
information ﬂows using meta-information attached to each
container of information called taints. Each time information
ﬂow from one container to another, the receiver gets tainted
with the meta-information from the source. This way, each
container is tainted accordingly to the origin of the data it
contains. This monitoring can be performed at several levels
of granularity depending on what is considered an elementary
container of information. In our case, we are interested in
OS-level containers, such as processes, ﬁles, sockets, etc. As
the entire OS security relies on the correct interpretation of
the information ﬂows, information ﬂows monitors are critical,
and it is important to know how far they can be trusted.
Our main problem is that it is hard to know if information
ﬂows monitors actually interpret the ﬂows correctly and if their
view of the system is consistent with the actual state of the
system. A formal proof through static analysis for example is
infeasible if they are implemented on top of a preexisting OS
which was not designed for proof. To tackle this issue, we need
to know what are the information ﬂows caused in an OS. Our
work is based on the two following hypothesis. First of all,
only processes cause information ﬂows in a system because
they are the active entities that execute codes whereas the other
components are passive. Second, system calls are necessary for
all information ﬂows deliberately caused by processes. This
leads us to deﬁne more precisely what the information ﬂows
generated by each system call are. Our goal is a formalized
semantics of system calls in terms of information ﬂows for a
preexisting UNIX-like OS. This semantics will deﬁne clearly
and unambiguously what information ﬂows can be caused
in the system and by which means. This would give us a
reference to state on the correctness of a given information
ﬂow monitor. The rest of this paper is organized as follows.
In Section I, we present the state of the art. In Section II,
we discuss our working hypothesis and we present the main
elements of our modelization. In Section III, a commented
example of a system call gives the intuition of our syntax.
Then, in Section IV, we present our work on a use case of our
semantics: testing an existing information ﬂow monitor. We
conclude and give perspectives in Section VI.
II. RELATED WORK
Information ﬂow control systems is a long-studied topic
in security. Some are implemented on top of preexisting
OSes, which makes them more likely to be used in practical
applications than ad hoc solutions. Blare [1] is built for the
mainstream Linux kernel. Contrary to other tools such as
Flume [2], it monitors automatically all the processes and does
not rely on a user-land daemon to intercept system calls. Blare
is based on the Linux Security Modules (LSM) framework
[3]. LSM adds security ﬁelds in existing data structures inside
the kernel and provides security developers with hooks. Those
1
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-399-5
ICONS 2015 : The Tenth International Conference on Systems

are placed before any access to a kernel object, which can
represent a ﬁle for example. Functions can be set up on any
hook so that when it is triggered the function is executed to
mediate the access to the object. Blare plugs in functions
in charge of calculating the propagation of taints on the
kernel objects. The correctness of security softwares based on
LSM relies on the correct placement of the hooks, otherwise,
the access control is ﬂawed. Several approaches using static
analysis have been proposed so far to verify respectively that
(1) all security-sensitive operations are mediated by a hook
[4], and (2) to check that the necessary set of hooks is called
before each security-sensitive operation on a kernel object [5].
Although those works are necessary to ensure that security
mechanisms based on LSM are correct, they are not sufﬁcient
because they cannot be used to verify those mechanisms
themselves. Our work aims at ensuring that information ﬂows
are correctly interpreted by security mechanisms, in order to
give stronger guarantees on the validity of their model and the
correctness of their implementation.
III. MODELING INFORMATION FLOWS IN AN OS
A. Discussion on our Working Hypothesis
Our working hypothesis is that no information ﬂow can
occur in an OS without at least the execution of one system
call. Therefore, the kernel that receives the system calls and
acts upon them is aware of all the information ﬂows in
the system. This hypothesis arises from the fact that system
calls are the only way for a process to ask the kernel to
run code on its behalf, and only code run by the kernel,
that has high privileges, can make information ﬂow between
processes or from processes to other containers like ﬁles or
network sockets. Of course, processes are free to manipulate
the information they have inside their own memory space and
to perform arbitrary manipulation on it. Hence, we have to
consider containers of information at a coarser grain than
individual memory locations. The ﬁle descriptor abstraction
used under UNIX is useful here. On a ﬁrst approximation, for
our prototype, we consider as a container a process or anything
that can be handled by a ﬁle descriptor in a UNIX abstraction.
This covers ﬁles, network sockets, message queues, etc.
Our hypothesis has some drawbacks, too. For example,
when two processes want to share a memory area, they need
only a few system calls to set up and map the memory area
and then, they can communicate and exchange information
freely without any additional system call. So, to fully capture
the information ﬂows in this case, we have to overapproximate
them and consider that the processes have exchanged all the
information they had while the memory remained shared. A
few malicious processes could then abuse this overapproxi-
mation by setting up shared memory areas and opening a lot
of ﬁles to mask their real objective. Typically, a virus that
would infect a lot of core processes could lower the accuracy
of the information ﬂow monitor so much that it would become
practically ineffective. However, this would only result in valid
ﬂows being denied, not illegal ﬂows being granted.
B. Scope and Object of our Modelization
To describe the information ﬂows caused by each indi-
vidual system call, we need to consider their environment.
Information ﬂows are caused by processes and occur between
containers. The internal state of the OS also matters because
the results of some system calls depend on speciﬁc conditions
which are out of control from the process. For example, there
is a limit on the total number of ﬁles that can be open
simultaneously in an OS. Therefore, the same system call with
the same parameters issued by a process asking for a given
ﬁle to be opened can succeed or fail in two contexts indistin-
guishable from the process’s point of view. This fact leads us
to model the entire OS, with its internal state along with the
system calls. Unlike many models focusing on processes like
the process algebras which describe communication between
them, we consider the kernel’s point of view.
For our work, we ﬁrst focused on the MINIX OS [6]. This
OS is a fully-featured UNIX environment with a very clear and
simple design. The methodology used to build our prototype
can be extended to others kernels with a larger codebase such
as Linux. In our model, the kernel is a database of containers
of information. These containers may be of various types: ﬁles,
network sockets, processes, memory segments, etc. For each
of these containers, we maintain various pieces of information
such as the size in case of a ﬁle, the program being executed
in case of a process, etc. Separately, we have a list of observed
information ﬂows. We model system calls as transactions
impacting the database asynchronously. Each time a system
call is triggered, it is executed, objects in the database are
created, altered or even deleted, and new information ﬂows
may be added to the list. This is where our semantics of
system calls is necessary; without it, our model could not be
proved accurate and we may miss important side effects in
the internal state of the kernel (represented in our database),
or even information ﬂows. We also made our semantics and
model executable. This is important because it allows us to
build runnable test cases.
C. Model of the System Calls and the Database
As we previously said, system calls are modeled as transac-
tions asynchronously reaching the database. Those transactions
may alter the database in any possible way but they are
executed as a whole, i.e., either the transaction is entirely
executed or it is not at all. Furthermore, two system calls trans-
actions cannot interfere with each other: their execution may
be interleaved but not simultaneous and they cannot access
the same objects if they are interleaved. These precautions
are necessary to keep the database in a valid state, consistent
with a real kernel. Of course, in a real multiprocesses system,
two system calls may be executed at the same time but
synchronization mechanisms, such as locks, prevent them from
accessing the same objects and data structures in the kernel
at the same time so our model remains valid if we make the
assumption that synchronization is correctly enforced in the
real system. If this were not the case, the real system would
2
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-399-5
ICONS 2015 : The Tenth International Conference on Systems

TABLE I. FILES’ META-ATTRIBUTES.
Name
Meaning
path
File system path
rd locked
Read lock
wr locked
Write lock
uid
Owner’s id
gid
Owning group’s id
mode
Access rights and ﬂags setuid, setgid, sticky bit
be buggy and its internal state inconsistent, so no model would
be accurate.
To model the system calls, we used the Concurrent TRans-
action logic, CTR, by Bonner and Kifer [7]. This logic pro-
vides us with both a syntax and a semantics to express changes
and consultations in a database as transactions. The database,
in the case of the CTR, can have an arbitrary structure,
provided that it can be accessed by the means of clearly
deﬁned logical primitives. In our case, those primitives are the
consultation of the database, the atomic change of an attribute
of a single object in the database, the creation of a new object
in the database, the deletion of an object, and the registration
of a newly detected information ﬂow. As its name suggests,
the CTR lets two or more transactions run concurrently, in
an interleaved manner, which is desired in our case. Last but
not least, the CTR provides us with an executional semantics:
an interpreter can be built to simulate the execution of a
transaction in a database. The documentation of our interpreter
is available online [8].
Our database model contains four tables and a list. The
tables are (1) the table of active processes in the system,
(2) the table of existing ﬁles in the system, (3) the table
of open ﬁle descriptors, and (4) the table of memory areas
allocated to processes. The list contains the information ﬂows
the interpreter detects. It is chronologically sorted. This is of
course a small model built only for the sake of prototyping
because we consider only processes and ﬁles as containers
of information but it can be extended. Each table contain
a set of entries. An entry is indexed by a unique identiﬁer
and represents an object in the OS. For example, an entry in
the processes table is a living process in the system. Each
entry is described through several attributes. Tables I and II
describe respectively the ﬁelds contained in the entries of
the ﬁles table and the ﬁle descriptors tables. As one can
see, we try to mimic as closely as possible the real OS
and we replicate the semantics of open and close because
obviously, information ﬂows are not identical for open and
closed ﬁles. This is why we made the distinction between
ﬁles and ﬁle descriptors, which correspond to ﬁles opened by
some process.
IV. EXAMPLE OF A SYSTEM CALL: READ
System calls are written as a set of logical clauses. Each
clause is a transaction which corresponds to the system call.
The clauses are mutually exclusive, only one of them will
TABLE II. FILES DESCRIPTORS’ META-ATTRIBUTES.
Name
Meaning
ﬁle
File corresponding to the ﬁle descriptor
procs
Processes owning this ﬁle descriptor
opts
Read-only, Write-only, Read-Write, Append, etc.
pos
Current position in the ﬁle
execute. They correspond to the different behaviors of the
system call: there is a clause for each error case and each valid
case. The way the interpreter chooses the clause to execute
is simple: it tries them one after the other, until one can be
entirely executed. Each clause begins with the header of read
with some arguments. Arguments can be preceded by a + sign
or a − sign. A + sign means that the argument is an input, a
− sign that it is an output. A system call usually has a return
value but can also return values through a pointer passed as
an argument. Our notation captures this.
read(+FileDescriptor, +Buffer, +Size, -Return) ←
(1)
¬(GET_FID_FOR_PROC(caller, FileDescriptor, Fid)) (2)
⊗ Return = EBADF.
(3)
This ﬁrst clause describes the execution of read with an
invalid ﬁle descriptor as ﬁrst argument. The clause’s body
starts with a query called GET_FID_FOR_PROC which re-
turns, for a given process and a given ﬁle descriptor, the
ﬁle referenced by the ﬁle descriptor for the process. This
is a logical predicate having logical value true if the ﬁle
descriptor is valid, in which case Fid is a reference to the
ﬁle and false if the ﬁle descriptor is invalid. In the ﬁrst
clause, the ﬁle descriptor is invalid. What comes after is an
addition of the CTR to the predicate calculus. The operator
⊗ is the sequential conjunction. The intuition of this operator
is that if both A and B are transactions, then A ⊗ B is the
transaction whose execution consists of the correct execution
of A followed by the correct execution of B. If A has not
logical value true, which means it cannot be executed, then
B is not executed (its effects on the database, if any, are
ignored) and the whole transaction A ⊗ B is false (which can
be thought of as aborted). If A is true, B is executed and if B
is false, the transaction is false too. Here, we test the negation
of GET_FID_FOR_PROC so if the ﬁle descriptor is invalid,
the previously undetermined value Return is now known to be
equal to the constant EBADF. If the ﬁle descriptor is valid, the
clause is rejected and another one is tried. When a clause is
rejected, all its effects on the database are rollbacked.
read(+FileDescriptor, +Buffer, +Size, -Return)
←
(4)
GET_FID_FOR_PROC(caller, FileDescriptor, Fid)
(5)
⊗ Fid.opts ̸∋ READ
(6)
⊗ Return = EIO.
(7)
In the second clause, we ﬁrst check that the ﬁle descriptor
is valid (5), then if it is, we check if the ﬁle was opened
in reading mode (6) and if it is not, we conclude with the
3
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-399-5
ICONS 2015 : The Tenth International Conference on Systems

returned value of constant EIO (7) (Input/Output Error). If it
is, the transaction aborts. Here, we see how the transaction
representing the system call refers to the content of the
database representing the OS’s objects. Fid refers to an entry
in the ﬁle descriptors table, and Fid.opts refers to the value
of the attribute opts inside this entry.
read(+FileDescriptor, +Buffer, +Size, -Return)
←
(8)
GET_FID_FOR_PROC(caller, FileDescriptor, Fid)
(9)
⊗ Fid.opts ∋ READ
(10)
⊗ Size > 0
(11)
⊗ ReqSize is min(Size, Fid.file.size − Fid.pos) (12)
⊗ Buffer << Fid.file
(13)
⊗ Fid.pos := Fid.pos + ReqSize
(14)
⊗ Return = ReqSize.
(15)
Finally, the third clause describes the execution of read that
actually ends up with an information ﬂow. In this clause,
after the ﬁrst check identical to the previous case (9), the
ﬁle open mode is tested (10). The size to read is checked
to be non-null (11). Then, a new name ReqSize is created and
immediately given the minimum value between the requested
size and the number of bytes left in the ﬁle (12). The special
syntax that follows means that an information ﬂow took place
from the ﬁle to Buffer, which represents the memory zone
where the content of the ﬁle is read by the process (13). Next,
another syntax element is introduced (14). The current position
in the ﬁle (which is one of the numerous elements of the
database) is updated and becomes equal to the old position
plus the number of bytes read. Finally, the returned value is
the number of bytes read (15).
V. USAGE OF THE SEMANTICS
The semantics for system calls is executable. Sleghel et
al. built in 2000 an interpreter for the CTR [9]. Of course,
their work was not directly usable for us because they used a
very generic model of relational database. In our very speciﬁc
case, we needed a special database model to account for the
particular nature of an OS’s kernel. Fortunately, the CTR is
not bound to any speciﬁc database but can be used with any
model as long as elementary operations to query and update
the database are provided. So, we built our interpreter basing
our implementation on Sleghel et al.’s work for the inference
engine and implementing our own elementary predicates. The
inference engine, which implements the inference rules of
CTR, is written in SWI Prolog [10] and the database part
in C++. The latter lets us implement all kinds of side effects
in the database and instrument the interpreter. Sleghel et al.’s
interpreter was built for another Prolog ﬂavor, but we chose
to port it to SWI Prolog because of its handy C++ interface.
The motivation behind the construction of our semantics
was to test Blare [1], an information ﬂow monitor. While this
is still an on-going work we already have encouraging results
on our semantics and interpreter. We are able to set the model
of the OS, i.e., the database, in a given initial conﬁguration.
Then, we can run simple test cases such as two concurrent
processes trying to atomically write in the same ﬁle at the
same time. One of the processes output gets overriden by the
other and the result depends on the order of execution of the
writings. Our interpreter lets us effectively see that fact and we
can see the content of the database in each situation. This is
very interesting because, using the same test case once we get
a full formal semantics for Linux system calls, if we reproduce
the same situation on an OS equipped with Blare, we should
see the same result. If Blare tells us that the ﬁle contains
information from both processes or information from none
of the processes, we can tell it is wrong. Of course, this is a
simple example and there are many cases much more complex
to deal with.
VI. CONCLUSION AND FUTURE WORK
We presented a formal semantics for MINIX system calls
for and a methodology to build similar ones for any UNIX-
like OS. To the best of our knowledge, this is the ﬁrst
time a semantics is proposed for system calls in preexisting
OSes. Our work will be useful to get more conﬁdence in
the correct functionning of those information ﬂow monitors.
The semantics may also have other uses in the future, such
as proofs of correctness for the implementation of system
calls. Research work on information ﬂow control is far from
being over and more work is needed to achieve a control as
accurate as possible, and thus, to bring more security to end-
users of OSes. We follow on this track to improve existing
solutions and make both OSes and security mechanisms more
trustworthy.
REFERENCES
[1] L. George, V. Viˆet Triem Tong, and L. M´e, “Blare tools: a policy-based
intrusion detection system automatically set by the security policy,”
Recent Advances in Intrusion Detection.
Saint-Malo, France: Springer
Berlin Heidelberg, Sep. 2009, vol. 5758, pp. 355–356.
[2] M. Krohn et al., “Information ﬂow control for standard OS abstractions,”
ACM Symposium on Operating Systems Principles.
Stevenson, WA,
USA: ACM, 2007, pp. 321–334.
[3] C. Wright, C. Cowan, S. Smalley, J. Morris, and G. Kroah-Hartman,
“Linux security modules: general security support for the linux kernel,”
USENIX Security Symposium.
San Francisco, CA, USA: USENIX
Association, 2002, pp. 17–31.
[4] X. Zhang, A. Edwards, and T. Jaeger, “Using CQUAL for static analysis
of authorization hook placement,” USENIX Security Symposium.
San
Francisco, CA, USA: USENIX Association, Aug. 2002, pp. 33–48.
[5] T. Jaeger, A. Edwards, and X. Zhang, “Consistency analysis of authoriza-
tion hook placement in the linux security modules framework,” ACM
Transactions on Information and System Security, vol. 7, no. 2, May
2004, pp. 175–205.
[6] A. Tanenbaum and A. S. Woodhull, Operating Systems: design and
implementation, 3rd ed.
Upper Saddle River: Prentice Hall, 2009.
[7] A. J. Bonner and M. Kifer, “Concurrency and communication in
transaction logic,” Joint Intl. Conference and Symposium on Logic
Programming.
MIT Press, 1996, pp. 142–156.
[8] L. Georget, “ALFRED, an interpreter for the semantics of system calls,”
2014, [Retrieved: 2015.03.02]. [Online]. http://www.lgeorget.eu/alfred/
[9] A. F. Sleghel, “An optimizing interpreter for concurrent transaction
logic,” Ph.D. dissertation, University of Toronto, 2000.
[10] J. Wielemaker, T. Schrijvers, M. Triska, and T. Lager, “SWI-prolog,”
Theory and Practice of Logic Programming, vol. 12, no. 1-2, Jan. 2012,
pp. 67–96.
4
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-399-5
ICONS 2015 : The Tenth International Conference on Systems

