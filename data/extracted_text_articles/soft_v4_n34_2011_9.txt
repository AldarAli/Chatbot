354
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
A Formal Language for the Expression of Pattern Compositions
Ian Bayley and Hong Zhu
Department of Computing and Communication Technologies
Oxford Brookes University
Oxford OX33 1HX, UK.
Email: ibayley@brookes.ac.uk, hzhu@brookes.ac.uk
Abstract—In real applications, design patterns are almost
always to be found composed with each other. Correct appli-
cation of patterns therefore relies on precise deﬁnition of these
compositions. In this paper, we propose a set of operators on
patterns that can be used in such deﬁnitions. These operators
are restriction of a pattern with respect to a constraint,
superposition of two patterns, and a number of structural
manipulations of the pattern’s components. We demonstrate
the uses of these operators by examples. We also report a case
study on the pattern compositions suggested informally in the
Gang of Four book in order to demonstrate the expressiveness
of the operators.
Keywords-Design patterns, Pattern composition, Object ori-
ented design, Formal methods.
I. INTRODUCTION
As codiﬁed reusable solutions to recurring design prob-
lems, design patterns play an increasingly important role
in the development of software systems [2], [3]. In the
past few years, many such patterns have been identiﬁed,
catalogued [2]–[15], formally speciﬁed [16]–[20], and in-
cluded in software tools [21]–[31]. Although each pattern is
speciﬁed separately, they are usually to be found composed
with each other in real applications. It is therefore vital to
represent pattern compositions precisely and formally, so
that the correct usage of composed patterns can be veriﬁed
and validated.
The composition of design patterns have been studied by
many authors informally, e.g., in [32], [33]. Visual notations
such as the Pattern:Role annotation, and a forebear based on
Venn diagrams, have been proposed by Vlissides [34] and
widely used in practice. They indicate where, in a design,
patterns have been applied so their compositions are com-
prehensible. These notations focus on static properties. In
[35], Dong et al. developed techniques for visualising pattern
compositions in such notations by deﬁning appropriate UML
proﬁles. Their tool, deployed as a web service, identiﬁes
pattern applications, and does so by displaying stereotypes,
tagged values, and constraints. Such information is delivered
dynamically with the movement of the user’s mouse cursor
This paper is an extended and revised version of the paper [1] presented
at the 2nd International Conference on Pervasive Patterns and Applications
(PATTERNS 2011)
on the screen. Their experiments show that this delivery on
demand helps to reduce the information overload faced by
designers.
More recently, Smith proposed the Pattern Instance Nota-
tion (PIN), to visually represent the composition of patterns
in a hierarchical manner [36]. Most importantly, he also
recognised that multiple instances of roles needed to be
better expressed and he devised a suitable graphic nota-
tion for this. However, while many approaches to pattern
formalisation have been proposed, very few authors have
investigated pattern composition formally. Two of those who
have are Dong et al. [37]–[41] and Taibi and Ngo [18], [42],
[43], respectively.
As far as we know, Dong et al. were the ﬁrst to study
pattern composition in a formal setting [37]. In their ap-
proach, a composition of two patterns is deﬁned as a pair of
name mappings. Each mapping "associates the names of the
classes and objects declared in a pattern with the classes and
objects declared in the composition of this pattern and other
patterns" [37]. They illustrate this by composing Composite
with Iterator [37]–[39]. Dong et al. also demonstrated that
how structural and behavioural properties of the instances of
patterns and their compositions can be inferred from their
formal speciﬁcations.
In [41], they developed this approach further recently in
their study on the commutability of pattern instantiation with
pattern integration, another term for pattern composition.
A pattern instantiation was deﬁned as a mapping from
names of various kinds of elements in the pattern to classes,
attributes, methods, etc., in the instance. An integration of
two patterns was deﬁned as a mapping from the set union
of the names of the elements in the two patterns into the
names of the elements in the resulting pattern. However,
in a recent study of the compositions of security patterns
[40], they merely presented the compositions in the form
of diagrams, from which they manually derived the formal
speciﬁcations afterwards.
Taibi and Ngo [43] took an approach very similar to this,
but instead of deﬁning mappings for pattern compositions
and instantiations, they use substitution to directly rename
the variables that represent pattern elements. Instantiation
replaces these variables with constants, whereas composition

355
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
replaces them with new variables, before then combining the
predicates. They illustrated the approach by combining the
Mediator and Observer patterns in [42] and the Command
and Composite patterns in [43].
In [44], we formally deﬁned a pattern composition oper-
ator based on the notion of overlaps between the elements
in the composed patterns. We distinguished three different
kinds of overlaps: one-to-one, one-to-many and many-to-
many. The compositions in Dong et al. and Taibi’s ap-
proaches all have overlaps that are one-to-one. However,
the other two kinds are often required. For example, if the
Composite pattern is composed with the Adapter pattern in
such a way that one or more of the leaves are adapted then
that is a one-to-many overlap. This cannot be represented
as a mapping between names, nor by a substitution or
instantiation of variables. However, although our overlap
based operator is universally applicable, we found in our
case study that it is not very ﬂexible for practical uses and
its properties are complex to analyse.
In this paper, therefore, we revise our previous work
and take a radically different approach. Instead of deﬁning
a single universal composition operator, we propose a set
of six more primitive operators, with which each sort of
composition can then be accurately and precisely expressed.
This paper makes the following three the main contributions.
• A set of operators on design patterns are formally
deﬁned.
• The uses of the operators in pattern-based software de-
sign are illustrated by classic examples in the literature.
• The expressiveness of the operators is demonstrated
by a case study on the compositions of the patterns
suggested by the Gang of Four book [2].
The remainder of the paper is organised as follows.
Section II provides a background by reviewing the different
approaches to pattern formalisation. Section III formally
deﬁnes the six operators. Section IV gives two examples to
illustrate how compositions can now be speciﬁed. Section
V reports a case study in which we used the operators to
realise all the pattern combinations suggested by the Gang
of Four (GoF) book [2]. Section VI concludes the paper with
a discussion of related works and future work.
II. BACKGROUND
In the past few years, researchers have advanced several
approaches to the formalisation of design patterns. In spite
of differences in these formalisms, the basic underlying
ideas are quite similar. In particular, valid pattern instances
are usually speciﬁed using statements that constrain their
structural features and sometimes their behavioural features
too. The structural constraints are typically assertions that
certain types of components exist and have a certain static
conﬁguration. The behavioural constraints, on the other
hand, detail the temporal order of messages exchanged
between the components that realise the designs.
The various approaches to pattern formalisation differ
in how they represent software systems and in how they
formalise the predicate. For example, Eden’s predicates are
on the source code of object-oriented programs [19] but they
are limited to structural features. Taibi’s approach in [18] is
similar but he takes the further step of adding temporal logic
for behavioural features. In contrast, our predicates are built
up from primitive predicates on UML class and sequence
diagrams [20]. These primitives are induced from GEBNF
(Graphic Extension of Backus-Naur Form) deﬁnition of
the abstract syntax of graphical modelling languages [45],
[46]. Nevertheless, the operators on design patterns used in
this paper are generally applicable and independent of the
particular formalism used. Still, the example speciﬁcations
of GoF patterns come from our previous work [20].
As examples, Figures 1 and 2 show the speciﬁcations
of the Object Adapter and Composite design patterns, re-
spectively. The class diagrams from the GoF book have
been reproduced to enhance readability; while their sequence
diagrams are omitted for the sake of space. The primitive
predicates and functions we use are explained in Table I.
All of them are either induced directly from the GEBNF
deﬁnition of UML, or are deﬁned formally in terms of such
predicates. The predicate trigs is particularly important in
describing dynamic behavioural properties and it is formally
deﬁned as follows.
trigs(m, m′) ≜
toAct(m) = fromAct(m′) ∧ m < m′
Speciﬁcation 1: (Object Adapter Pattern)
Components
1) Client, Target, Adapter, Adaptee ∈ classes,
2) requests, specreqs ⊆ operations,
Dynamic Components
1) mr, ms ∈ messages
Static Conditions
1) requests ⊆ Target.opers,
2) specreqs ⊆ Adaptee.opers
3) Adapter −−▷ Target,
4) Adapter −→ Adaptee,
5) Client −→ Target
Dynamic Conditions
1) mr.sig ∈ requests
2) ms.sig ∈ specreqs
3) trigs(mr, ms)
Figure 1.
Speciﬁcation of Object Adapter Pattern

356
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Speciﬁcation 2: (Composite)
Components
1) Client, Component, Leaf, Composite ∈ classes
2) operation ∈ operations
Dynamic Components
1) m1, m2 ∈ messages
Static Conditions
1) operation ∈ Component.opers
2) Leaf −−▷ Component
3) Composite −−▷ Component
4) Client −→ Component
5) Composite ⋄−→∗ Component
6) ¬Leaf ⋄−→∗ Component
7) operation.isAbstract
Dynamic Conditions
1) m1.sig = Composite.operation
2) isOp(m2)
3) trigs(m1, m2)
4) m2.sig = Leaf.operation =⇒
¬∃m3 ∈ messages · trigs(m2, m3) ∧ isOp(m3)
Figure 2.
Speciﬁcation of Composite Pattern
The deﬁnition of the Composite pattern uses an auxiliary
predicate isOp deﬁned on messages as follows.
isOp(m) ≜
m.sig = Leaf.operation ∨
m.sig = Composite.operation
In general, a design pattern P can be deﬁned abstractly
as an ordered pair ⟨V, Pr⟩, where Pr is a predicate on
the domain of some representation of software systems, and
V is a set of declarations of variables free in Pr. In other
words, Pr speciﬁes the structural and behavioural features
of the pattern and V speciﬁes its components. Let V =
{v1 : T1, · · · , vn : Tn}, where vi are variables that range
over the type Ti of software elements. The semantics of the
speciﬁcation is a ground predicate in the following form.
∃v1 : T1 · · · ∃vn : Tn · (Pr)
(1)
Note that, for the sake of readability, in the examples we
split the predicate in the speciﬁcation into two parts: one for
static conditions and the other for dynamic conditions as in
[16], [18], [37] and [20]. In the sequel, we write Spec(P)
Table I
THE FUNCTIONS AND PREDICATES USED IN THE EXAMPLES
ID
Meaning
classes
The set of class nodes in the class diagram
operations
The set of operations in the class diagram
C.opers
The operations contained in the class node C
m.sig
The signature of the message m as operation
X −−▷ Y
Class X inherits class Y directly or indirectly
X −→ Y
There is an association (either direct or
indirect) from class X to Y
X ⋄−→ Y
There is an composite or aggregate relation
(either direct or indirect) from X to Y
C.op
The redeﬁnition of op for class C
trigs(m, m′)
Message m is sent to the activation from
which message m′ is afterwards sent
isAbstract(C)
Class C is abstract
op.isAbstract
Operation op is abstract
fromLL(m)
The lifeline from which message m is sent
toLL(m)
The lifeline to which message m is sent
l.class
The class of the lifelines
hasParam(m, p)
p is one of the parameters of message m
returnV alue(m)
The value returned by message m
to denote the predicate (1) above, V ars(P) for the set of
variables declared in V , and Pred(P) for the predicate Pr.
Note further that the above deﬁnition can easily be gener-
alised or adapted so that the predicates in pattern speciﬁca-
tions are deﬁned on the domain of program implementations
and their dynamic behaviours.
We can formally deﬁne the conformance of a design
model m to a pattern P, written as m |= P, and reason
about the properties of instances based on the patterns they
conform to, but we omit the details here for the sake of
space. Readers are referred to [20] and [45]. The theory
developed in this paper remains valid so long as this notion
of conformance is valid and the logic is consistent. However,
for the sake of simplicity, this paper only considers designs
represented as models.
III. OPERATORS ON PATTERNS
We now formally deﬁne the operators on design patterns.
A. Restriction operator
The restriction operator was ﬁrst introduced in our previ-
ous work [44], where it is called the specialisation operator.
Deﬁnition 1: (Restriction operator)
Let P be a given pattern and c be a predicate deﬁned on
the components of P. A restriction of P with constraint c,
written as P [c], is the pattern obtained from P by imposing
the predicate c as an additional condition on the pattern.
Formally,
1) V ars(P[c]) = V ars(P),
2) Pred(P[c]) = (Pred(P) ∧ c). ⊓⊔
For example, a variant of the Adapter pattern in which
there is only one request and one speciﬁc request, hereafter
known as Adapter1, can be formally deﬁned as follows.

357
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Adapter1 ≜
Adapter[||requests|| = 1 ∧ ||specreqs|| = 1].
Restriction is frequently used in the case study, particu-
larly in the form P[u = v] for pattern P and variables u
and v of the same type. This expression denotes the pattern
obtained from P by unifying u and v to make them the same
element.
Note that the instantiation of a variable u in pattern P
with a constant a of the same type of variable u can also
be expressed by using restriction: P[u = a].
This operator does not introduce any new components into
the structure of a pattern, but the following operators do.
B. Superposition operator
Deﬁnition 2: (Superposition operator)
Let P and Q be two patterns. Assume that the compo-
nent variables of P and Q are disjoint, i.e., V ars(P) ∩
V ars(Q) = ∅. The superposition of P and Q, written P ∗Q,
is a pattern that consists of both pattern P and pattern Q as
formally deﬁned below.
1) V ars(P ∗ Q) = V ars(P) ∪ V ars(Q);
2) Pred(P ∗ Q) = Pred(P) ∧ Pred(Q). ⊓⊔
For example, the superposition of Composite and Adapter
patterns, Composite ∗ Adapter, requires each instance to
contain one part that satisﬁes the Composite pattern and
another that satisﬁes the Adapter pattern. These parts may or
may not overlap, but the following expression does enforce
an overlap, as it requires that the Leaf class be the target
of an Adapter.
(Composite ∗ Adapter)[Target = Leaf]
The requirement that V ars(P) and V ars(Q) be disjoint is
easy to fulﬁl using renaming. An appropriate notation for
this will be introduced later.
C. Extension operator
Deﬁnition 3: (Extension operator)
Let P be a pattern, V be a set of variable declarations that
are disjoint with P’s component variables (i.e., V ars(P) ∩
V = ∅), and c be a predicate with variables in V ars(P)∪V .
The extension of pattern P with components V and linkage
condition c, written as P#(V • c), is deﬁned as follows.
1) V ars(P#(V • c)) = V ars(P) ∪ V ;
2) Pred(P#(V • c)) = Pred(P) ∧ c. ⊓⊔
D. Flatten operator
Deﬁnition 4: (Flatten Operator)
Let P be a pattern, (xs : P(T)) ∈ V ars(P), x ̸∈
V ars(P), and Pred(P) = p(xs, x1, · · · , xk). The ﬂatten-
ing of P on variable xs, written P ⇓ xs\x, is the pattern
deﬁned as follows:
1) V ars(P ⇓ xs\x) =
(V ars(P) − {(xs : P(T))}) ∪ {x : T};
2) Pred(P ⇓ xs\x) = p({x}, x1, · · · , xk).
Note that P(T) denotes the power set of T. For example,
in the speciﬁcation of the Adapter pattern, the component
variable requests is a subset of operations so its type is
P(operation).
The single-leaf variant of the Adapter pattern Adapter1
can also be deﬁned as follows.
Adapter1 ≜
(Adapter ⇓ requests\request) ⇓ specreq\specreqs
As an immediate consequence of this deﬁnition, we have
the following property. For x1 ̸= x2 and xs1 ̸= xs2,
(P ⇓ xs1\x1) ⇓ xs2\x2 = (P ⇓ xs2\x2) ⇓ xs1\x1.
(2)
Therefore, we can overload the ⇓ operator to a set of
component variables. Formally, let XS be a subset of P’s
component variables all of power set type, i.e., XS =
{xs1 : P(T1), · · · , xsn : P(Tn)} ⊆ V ars(P), n ≥ 1 and
X = {x1 : T1, · · · , xn : Tn} ∩ V ars(P) = ∅, we write
P ⇓ XS\X to denote P ⇓ xs1\x1 ⇓ · · · ⇓ xsn\xn.
Note that our pattern speciﬁcations are closed formulae,
containing no free variables. Although the names given to
component variables greatly improve readability, they have
no effect on semantics so, in the sequel, we will often omit
new variable names and write simply P ⇓ xs to represent
P ⇓ xs\x.
E. Generalisation operator
Deﬁnition 5: (Generalisation operator)
Let P be a pattern, x : T ∈ V ars(P) and xs ̸∈ V ars(P).
The generalisation of P on variable x, written P ⇑ x\xs,
is deﬁned as follows.
1) V ars(P ⇑ x\xs) =
(V ars(P) − {x : T}) ∪ {xs : P(T)},
2) Pred(P ⇑ x\xs) = ∀x ∈ xs · Pred(P).⊓⊔
For example, we can deﬁne the Adapter pattern as a
generalisation of the variant Adapter1, as follows:
Adapter ≜
(Adapter1 ⇑ request\requests) ⇑ specreq\specreqs
We will use the same syntactic sugar for ⇑ as we do
for ⇓. We will often omit the new variable name and write
P ⇑ x. Thanks to an analogue of Equation 2, we can and
will promote the operator ⇑ to sets also.
F. Lift operator
The lift operator was ﬁrst introduced in our previous
work [44]. The deﬁnition given below is a revised version
that allows lifting not only on class type variables but on
variables of other types too .
Deﬁnition 6: (Lift Operator)
Let P be a pattern, X = {x1 : T1, · · · , xk : Tk} ⊂
V ars(P), k > 0 and Pred(P) = p(x1, · · · , xn), where
n ≥ k. The lifting of P with X as the key, written P ↑ X,
is the pattern deﬁned as follows.

358
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
1) V ars(P ↑ X) = {xs1 : P(T1), · · · , xsn : P(Tn)},
2) Pred(P ↑ X) = ∀x1 ∈ xs1 · · · ∀xk ∈ xsk·
∃xk+1 ∈ xsk+1 · · · ∃xn ∈ xsn · p(x1, · · · , xn). ⊓⊔
When the key set is singleton, we omit the set brackets
for simplicity, so we write P ↑ x instead of P ↑ {x}.
Informally, lifting a pattern P results in a new pattern
P ′ that contains a number of instances of pattern P. For
example, Adapter ↑ Target is the pattern that contains a
number of Targets of adapted classes. Each of these has a
dependent Client, Adapter and Adaptee class conﬁgured
as in the original Adapter pattern. In other words, the
component Target in the lifted pattern plays a role similar
to the primary key in a relational database. Figure 3 is the
pattern deﬁned by expression Adapter ↑ Target.
Speciﬁcation 3: (Lifted Object Adapters Pattern)
Components
1) Targets, Adapters, Adaptees, Clients ⊆ classes,
2) requestses, specreqses ⊆ P(operations)
Dynamic Components
1) mrs, mss ⊆ messages,
Conditions
∀Target ∈ Targets, ∃Client ∈ Clients,
∃Adapter ∈ Adapters, ∃Adaptee ∈ Adaptees,
∃requests ∈ requestses, ∃specreqs ∈ specreqses,
∃mr ∈ mrs, ∃ms ∈ mss·
1. Static Conditions
1) requests ⊆ Target.opers,
2) specreqs ⊆ Adaptee.opers
3) Adapter −−▷ Target
4) Adapter −→ Adaptee
5) Client −→ Target
2. Dynamic Conditions
1) mr.sig ∈ requests
2) ms.sig ∈ specreqs
3) trigs(mr, ms)
Figure 3.
Speciﬁcation of Lifted Object Adapter Pattern
IV. EXAMPLES
In this section, we present two examples of using the
operators to deﬁne composition of design patterns.
A. Model-View-Controller as Pattern Composition
Model-View-Controller (MVC) is one of the most well-
known design patterns and perhaps the most widely used
one. A detailed description of the MVC design pattern can
be found in [47], which includes the class and sequence
diagrams displayed in Figure 4. We can formalise the pattern
as shown in Figure 5.
It is immediately apparent from the diagrams that the
View and Controller classes are both observers of the Model,
so we can alternatively specify MVC as an extension of the
Observer pattern, whose speciﬁcation is given in Figure 6.
-
Observer 
update
call update 
Model 
coreData 
setOfObservers 
attach(Observer) 
detach(Observer) 
notify 
getData 
service 
A 
attach 
getData 
I 
View 
myModel 
myController 
initialize(Model) 
create 
Controller
manipulate
makeController 
display
activate 
myModel
display 
myView
update 
attach initialize(Model,View) 
call service handleEvent 
update 
UCiuuUUg lJIUCeUUle. 
Controller 
Model 
handleEvent 
View 
seIVice 
update 
getData 
update 
Figure 4.
Class and Sequence Diagrams of the MVC Design Pattern
Note that the GoF book puts the notify operation in an
abstract superclass, but we ﬂatten the inheritance hierarchy
for simplicity.
Now, we rename the variables in this pattern in two
different ways to match those used for its two occurrences
within MVC. We call these renamed patterns Observer1
and Observer2.
Observer0 ≜
Observer[Model := Subject][getData := getState]
Observer1 ≜
Observer0[mu1, mg1 := mu, mg]
[V iew := ConcreteSubject]
Observer2 ≜
Observer0[mu2, mg2 := mu, mg]
[Controller := ConcreteSubject]
So, MVC pattern can now be deﬁned as follows.
MV C ≜
(Observer1 ∗ Observer2)
#({display ∈ V iew.opers, mh, md ∈ messages,
handleEvent ∈ Controller.opers}
•(Controller −→ V iew ∧
mh.sig = handleEvent ∧ md.sig = display ∧
trigs(mu1, md) ∧ trigs(md, mg1)
Here, ∗ is the operator that renames shared variable names

359
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Speciﬁcation 4: (MVC – Version 1)
Components
1) Model, V iew, Controller, Observer ∈ classes
2) notify, getData, service ∈ operations
3) display, handleEvent, update ∈ operations
Dynamic Components
1) mh, ms, mn, mu1, md, mg1, mu2, mg2 ∈ messages
Static Conditions
1) notify, getData, service ∈ Model.opers
2) display ∈ V iew.opers
3) handleEvent ∈ Controller.opers
4) update ∈ Observer.opers
5) V iew −−▷ Observer
6) Controller −−▷ Observer
7) Model −→∗ Observer
8) Controller −→ V iew
9) Controller −→ Model
10) V iew −→ Model
Dynamic Conditions
1) mh.sig = handleEvent
2) ms.sig = service
3) mn.sig = notify
4) mu1.sig = V iew.update
5) md.sig = display
6) mg1.sig = getData
7) mu2.sig = Controller.update
8) mg2.sig = getData
9) trigs(mh, ms)
10) trigs(ms, mn)
11) trigs(mn, mu1)
12) trigs(mu1, md)
13) trigs(md, mg1)
14) trigs(mu1,mg1)
15) trigs(mn, mu2)
16) trigs(mu2, mg2)
Figure 5.
Speciﬁcation of MVC Pattern (Version 1)
before applying ∗ and then renames them back to what
they were. Formally, let P1 and P2 be any given patterns,
{v} = V ars(P1) ∩ V ars(P2) and v1 ̸= v2 /∈ V ars(P1) ∪
V ars(P2). Then, ∗ is deﬁned as follows, with the obvious
generalisation to more than one variable:
P1∗P2 ≜
(P1[v1 := v] ∗ P2[v2 := v])[v := v1 = v2].
The GoF book further proposes the use of Composite with
MVC, to enable views to be nested, and Strategy too, so
that the controller associated with each view is dynamically
conﬁgurable. The speciﬁcation of Strategy pattern is given
in Figure 7. But, it is its lifted version composed with
Composite, which is deﬁned as follows.
StrategyLifted ≜
Strategy ⇑ ConcreteStrategy\ConcreteStrategies
This brings us to a new deﬁnition of MVC, i.e., MV C2
below. The result of evaluating this deﬁnition gives the
speciﬁcation shown in Figure 8.
Speciﬁcation 5: (Simpliﬁed Observer)
Components
1) Subject, ConcreteObserver, Observer ∈ classes
2) notify, getState, service, update ∈ operations
Dynamic Components
1) ms, mn, mu, mg ∈ messages
Static Conditions
1) notify, getState, service ∈ Subject.opers
2) update ∈ Observer.opers
3) ConcreteObserver −−▷ Observer
4) Subject −→∗ Observer
5) ConcreteObserver −→ Subject
Dynamic Conditions
1) ms.sig = service
2) mn.sig = notify
3) mu.sig = ConcreteObserver.update
4) mg.sig = getState
5) trigs(ms, mn)
6) trigs(mn, mu)
7) trigs(mu, mg)
Figure 6.
Speciﬁcation of Observer Pattern
Speciﬁcation 6: (Strategy)
Components
1) Context, Strategy, ConcreteStrategy ∈ classes
2) contextInterface,
algorithmInterface ∈ operations
Dynamic Components
1) mc, ma ∈ messages
Static Conditions
1) contextInterface ∈ Context.opers
2) algorithmInterface ∈ Strategy.opers
3) Context ⋄−→ Strategy
4) ConcreteStrategy −−▷ Strategy
5) algorithmInterface.isAbstract
6) ¬isAbstract(ConcreteStrategy)
Dynamic Conditions
1) mc.sig = contextInterface
2) ma.sig = ConcreteStrategy.algorithmInterface
3) trigs(mc, ma)
Figure 7.
Speciﬁcation of Strategy Pattern
MV C′ ≜
MV C ∗ (Composite[display = operation ∧
V iew = Component ∧ Controller = Client])
[LeafV iew := Leaf]
[CompositeV iew := Composite]
MV C2 ≜
(MV C′ ∗ StrategyLifted)
[Controller = Strategy ∧ V iew = Context ∧
handleEvent = algorithmInterface ∧
actionPerformed = contextInterface ∧
ConcreteControllers := ConcreteStrategies]

360
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Speciﬁcation 7: (MVC – Version 2)
Components
1) Model, V iew, Controller, Observer
Client, LeafV iew, CompositeV iew ∈ classes
2) notify, getData, service ∈ operations
3) display, handleEvent, update ∈ operations
Dynamic Components
1) mh, ms, mn, mu1, md, mg1, mu2, mg2,
m1, m2, mc, ma ∈ messages
Static Conditions
1) notify, getData, service ∈ Model.opers
2) display ∈ V iew.opers
3) handleEvent ∈ Controller.opers
4) update ∈ Observer.opers
5) V iew −−▷ Observer
6) Controller −−▷ Observer
7) Model −→∗ Observer
8) Client −→ V iew
9) Controller −→ Model
10) V iew −→ Model
11) LeafV iew −→ V iew
12) CompositeV iew −→ V iew
13) CompositeV iew ⋄−→∗ V iew
14) ¬LeafV iew ⋄−→∗ V iew
15) display.isAbstract
16) V iew ⋄−→ Controller
17) ∀C ∈ ConcreteControllers · C −−▷ Controller
18) handleEvent.isAbstract
19) ∀C ∈ ConcreteControllers · ¬isAbstract(C)
Dynamic Conditions
1) mh.sig = handleEvent
2) ms.sig = service
3) mn.sig = notify
4) mu1.sig = V iew.update
5) md.sig = display
6) mg1.sig = getData
7) mu2.sig = Controller.update
8) mg2.sig = getData
9) m1.sig = Composite.operation
10) isOp(m2)
11) mc.sig = contextInterface
12) ma.sig = ConcreteStrategy.algorithmInterface
13) trigs(mh, ms)
14) trigs(ms, mn)
15) trigs(mn, mu1)
16) trigs(mu1, md)
17) trigs(md, mg1)
18) trigs(mu1,mg1)
19) trigs(mn, mu2)
20) trigs(mu2, mg2)
21) trigs(mc, ma)
22) trigs(m1, m2)
23) m2..sig = Leaf.operation =⇒
¬∃m3 ∈ messages · trigs(m2, m3) ∧ isOp(m3)
Figure 8.
Speciﬁcation of MVC Pattern (Version 2)
B. A Request-Handling Framework
In [32], the utility of pattern composition was demon-
strated with a case study of pattern-based software design,
in which ﬁve design patterns were composed to form an
extensible request-handling framework. As shown in Figure
9, the ﬁve patterns are Command, Command Processor,
Memento, Strategy and Composite. The composition can be
expressed in terms of our operators and an explicit deﬁnition
of the pattern can thereby be derived.
The last two patterns have already been deﬁned, thus here
are the ﬁrst three, starting with Command shown in Figure
10, which is based on the simpliﬁed version in [32] that
makes the Client also be the invoker.
The original case study treats the memento as being
created by the caretaker, but in fact it is created by the
originator instead, so we have the speciﬁcation of Memento
in Figure 11.
The Command Processor pattern is not one of the GoF
patterns. Figure 12 is the diagram given in [9] that illustrates
the pattern’s structure and dynamic behaviour. In particular,
the Command Processor object executes requests on behalf
of the clients. Its speciﬁcation is given in Figure 13.
Now, the request-handling framework, ReqHand, can
be deﬁned as follows using our operators on patterns,
where RH1, RH2 and RH3 are intermediate steps of the
composition.
RH1 ≜ ((Command[Application := Receiver]
⇑ ConcreteCommand\ConcreteCommands
⇑ mn\mns ⇑ me\mes)
∗ CommandProcessor[mee := me])
[Component = Command]
RH2 ≜ (RH1 ∗ Memento)
[Command −→ Application ∧
Command = Caretaker ∧
Originator = Application]
RH3 ≜ (RH2 ∗ Strategy ⇑ ma\mas
⇑ ConcreteStrategy\ConcreteStrategies)
[CommandProcessor = Context]
[Strategy := Logging]
[ConcreteStrategies
:= ConcreteLoggingStrategies]
ReqHand ≜
(RH3 ∗ Composite ⇑ m2\mls)
⇑ Leaf\Leaves [Command = Component]
[mm := m] [LeafCommands := Leaves]
[ConcreteCommands =
LeafCommands ∪ {CompositeCommands}]
[CompositeCommand := Composite]
Evaluating the above expressions according to the def-
initions of the operators, we have the speciﬁcation of the
extensible request handling framework shown in Figure 14
for the static and dynamic parts.

361
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Client
Command 
Processor
Logging
Concrete 
Logging 
Strategy A
Concrete 
Logging 
Strategy B
Command
Composite 
Command
Concrete 
Command A
Concrete 
Command B
Application
Memento
Command Processor: command processor
Strategy: context
Strategy: strategy
Command Processor: command
Command: command
Composite: component
Memento: caretaker
Memento: memento
Memento: originator
Command: concrete command
Composite: leaf
Memento: caretaker
Command: concrete command
Composite: leaf
Memento: caretaker
Figure 9.
Request Handling Framework
Speciﬁcation 8: (Command)
Components
1) Command ∈ classes
2) ConcreteCommand ∈ classes
3) Client ∈ classes
4) Receiver ∈ classes
5) execute, action ∈ operations
Dynamic Components
1) mn, me, ma ∈ messages
Static Conditions
1) execute ∈ Command.opers
2) action ∈ Receiver.opers
3) Client −→ Command
4) ConcreteCommand −→ Receiver
5) ConcreteCommand −−▷ Command
6) execute.isAbstract
7) ¬isAbstract(ConcreteCommand)
Dynamic Conditions
1) mn.sig.isNew
2) me.sig = execute
3) ma.sig = action
4) mn < me
5) fromLL(mn).class = Client
6) fromLL(me).class = Client
7) toLL(mn) = toLL(me)
8) trigs(me, ma)
Figure 10.
Speciﬁcation of Command Pattern
Speciﬁcation 9: (Memento)
Components
1) Caretaker, Memento, Originator ∈ classes
2) setState, getState ∈ operations
3) createMemento, setMemento ∈ operations
Dynamic Components
1) mcm, mnm, mss, msm, mgs ∈ messages
Static Conditions
1) setState, getState ∈ Memento.opers
2) createMemento, setMemento ∈ Originator.opers
3) Caretaker ⋄−→ Memento
Dynamic Conditions
1) mcm.sig = createMemento
2) mnm.sig.isNew
3) mss.sig = setState
4) msm.sig = setMemento
5) mgs.sig = getState
6) trigs(mcm, mnm)
7) trigs(mcm, mss)
8) trigs(mss, mgs)
9) mcm < msm
10) fromLL(mcm) = fromLL(msm)
11) toLL(mcm) = toLL(msm)
12) hasParam(msm, toLL(gs))
13) toLL(mnm) = returnV alue(mnm)
14) toLL(mss) = returnV alue(mnm)
Figure 11.
Speciﬁcation of Memento Pattern
Client
execute
Service Request
Execute_request
Command 
Processor
1
Issue request
Function_1
Component
execute
Execute request
Function_2
2
Figure 12.
Diagram of Command Processor Pattern [9]
Speciﬁcation 10: (Command Processor)
Components
1) Client, CommandProcessor, Component
∈ classes
2) executeRequest, function ∈ operations
3) me, mf ∈ messages
Static Conditions
1) executeRequest ∈ CommandProcessor.opers
2) function ∈ Component.opers
3) Client −→ CommandProcessor
4) CommandProcessor −→ Component
Dynamic Conditions
1) me.sig = executeRequest
2) mf.sig = function
3) fromLL(me).class = Client
4) trigs(me, mf)
Figure 13.
Speciﬁcation of Command Processor Pattern

362
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Speciﬁcation 11: (Extensible Request Handler)
Components
1) Command, Client, Application,
CommandProcessor, Memento, Logging,
Client, CompositeCommand ∈ classes
2) ConcreteCommands, LeafCommands,
ConcreteLoggingStrategies ⊆ classes
3) execute, function, operation, action ∈ operations
4) executeRequest, contextInterface ∈ operations
5) setState, getState ∈ operations
6) createMemento, setMemento,
algorithmInterface ∈ operations
Static Conditions
1) execute, function, operation ∈ Command.opers
2) action ∈ Action.opers
3) executeRequest, contextInterface
∈ CommandProcessor.opers
4) setState, getState ∈ Memento.opers
5) createMemento, setMemento
∈ Application.opers
6) algorithmInterface ∈ Logging.opers
7) Client −→ Command
8) ∀C ∈ ConcreteCommands · C −→ Application
9) ∀C ∈ ConcreteCommands · C −−▷ Command
10) execute.isAbstract
11) ∀C ∈ ConcreteCommands · ¬isAbstract(C)
12) Client −→ CommandProcessor
13) CommandProcessor −→ Application
14) Caretaker ⋄−→ Memento
15) Command −→ Application
16) Memento −→ Application
17) CommandProcessor ⋄−→ Logging
18) ∀C ∈ ConcreteLoggingStrategies·
C −−▷ Logging
19) algorithmInterface.isAbstract
20) ∀C ∈ ConcreteLoggingStrategies·
¬isAbstract(C)
21) CompositeCommand −−▷ Command
22) CompositeCommand ⋄−→∗ Command
23) ∀C ∈ LeafCommands · ¬C ⋄−→∗ Command
24) ConcreteCommands =
LeafCommands ∪ {CompositeCommand}
25) operation.isAbstract
Dynamic Components
1) ma, mee, mf, mc, mm
mcm, mnm, mss, msm, mgs ∈ messages
2) mns, mes, mas, mls ⊆ messages
Dynamic Conditions
1) ∀C ∈ ConcreteCommands · mnsC.sig.isNew
2) ∀C ∈ ConcreteCommands·mesC.sig = C.execute
3) ma.sig = action
4) mee.sig = executeRequest
5) mf.sig = function
6) mcm.sig = createMemento
7) mnm.sig.isNew
8) mss.sig = setState
9) msm.sig = setMemento
10) mgs.sig = getState
11) mc.sig = contextInterface
12) ∀C ∈ ConcreteStrategies·
masC.sig = C.algorithmInterface
13) mm.sig = Composite.operation
14) ∀C ∈ LeafCommands· isOp(mlsC)
15) ∀C · mnsC < mesC
16) ∀C · fromLL(mnsC).class = Client
17) ∀C · fromLL(mesC).class = Client
18) ∀C · toLL(mnsC) = toLL(mesC)
19) ∀C · trigs(mesC, ma)
20) fromLL(mee).class = Client
21) trigs(mee, mf)
22) trigs(mcm, mnm)
23) trigs(mcm, mss)
24) trigs(mss, mgs)
25) mcm < msm
26) fromLL(mcm) = fromLL(msm)
27) toLL(mcm) = toLL(msm)
28) hasParam(msm, toLL(gs))
29) toLL(mnm) = returnV alue(mnm)
30) toLL(mss) = returnV alue(mnm)
31) ∀C ∈ ConcreteStrategies· trigs(mc, masC)
32) ∀C ∈ LeafCommands· trigs(mm, mlsC)
33) ∀C ∈ LeafCommands·
mlsC..sig = C.operation ⇒
¬∃mmm ∈ messages·
trigs(mlsC, mmm) ∧ isOp(mmm)
Figure 14.
Speciﬁcation of Request Handling Pattern
V. CASE STUDY
In the GoF book, the documentation for each pattern
concludes with a brief section entitled Related Patterns. A
few words are devoted to the comparisons and contrasts that
this title would suggest, but the section mostly consists of
suggestions for how other patterns may be composed with
the one under discussion. These compositions are the subject
of our case study.
On page 106 of the GoF book, for example, it is stated that
A Composite is what the builder often builds. This suggests a
composition of the Composite and Builder patterns, and that
composition can formally be speciﬁed using our operators
as follows:
(Builder ∗ Composite)[Product = Component].
Figure 15 shows the relationships between patterns that
we have successfully formalised. The formal deﬁnitions of
the relationships are given in Table II; the two numbers
in each row are the arrow label followed by the page
number in the GoF book. The column "Description of the
Relationship"’ quotes what are described in the GoF book.
The column "Formal Expression" gives the expression of the
relationship using the operators.
A similar diagram appears in the GoF book but we have
added ﬁve new arrows, numbered in bold font, for the

363
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Table II
FORMAL DEFINITIONS OF THE COMPOSITIONAL RELATIONSHIPS BETWEEN PATTERNS
No.
Page
Description of the relationship
Formal expression
1
106
A Composite is what the builder often builds.
(Builder ∗ Composite) [Product = Component]
2
173,
Often the component-parent link is used for a Chain of Respon-
sibility.
(Composite ∗ ChainOfResponsibility)
[Handler = Component ∧ Operation = Handle ∧ multiplicity = 1]
232
Chain of Responsibility is often applied in conjunction with
Composite. There, a component’s parent can act as its successor.
3
173
When Decorator and Composite are used together, they will
usually have a common parent class.
(Composite′ ∗ Decorator) [Decorator = Composite′ ∧
Composite′.Component = Decorator.Component ∧
Composite′.Operation = Decorator.Operation ∧ ConcreteComponent = Leaf ]
4
173
Flyweight lets you share components [of Composite].
(Composite ∗ Flyweight)
[Leafs = {ConcreteFlyweight, UnsharedConcreteFlyweight}]
206
The Flyweight pattern is often combined with the Composite
pattern to implement a logically hierarchical structure in terms
of a directed-acyclic graph with shared leaf nodes.
5
173
Iterator can be used to traverse composites.
(Composite ∗ Iterator′) [ConcreteAggregate = Component]
6
173
Visitor localises operations and behaviour that would otherwise be
distributed across composite and leaf classes [in the Composite].
(Composite ∗ V isitor) [Element = Component ∧
Operation = Accept(v) ∧ ConcreteElements = {Leaf, Composite}]
7
242
A Composite can be used to implement MacroCommands [i.e.,
ConcreteCommand in Command].
(Composite ∗ Command) [Command = Component ∧ execute = operation ∧
ConcreteCommand = Leaf ]
8
255
Flyweight shows how to share terminal symbols within the
abstract syntax tree.
(Interpreter ∗ Flyweight) [TerminalExpression = Flyweight]
9
255
Visitor can be used to maintain the behaviour in each node in the
abstract syntax tree in one class.
(Interpreter ∗ V isitor)[Element = AbstractExpression ∧ Interpret = Accept(v)∧
ConcreteElements = {NonTerminalExpression, TerminalExpression}]
10
95
AbstractFactory classes are often implemented with factory meth-
ods of Factory Method.
(AbstractFactory ∗ ((FactoryMethod ↑ Product) ⇑ FactoryMethod))
[Creator = AbstractFactory ∧ #AnOperations = 1 ∧ Products = AbstractProducts ∧
createMethods ⊆ FactoryMethods ∧ ConcreteCreators = ConcreteFactories ∧
AbstractFactory.ConcreteProducts = FactoryMethod.ConcreteProducts]
11
95
AbstractFactory classes can also be implemented using Prototype.
(AbstractFactory ∗ (Prototype ↑ Client)) [ConcreteFactories ⊆ Clients ∧
AbstractProducts ⊆ Prototypes ∧ CreateProductOperations ⊆ Operations]
12
95
A concrete factory in the AbstractFactory is often a singleton.
(AbstractFactory ∗ (Singleton ↑ {Singleton})) [Singletons ⊆ ConcreteFactories]
13
116
Factory methods are often called within Template Methods.
(TemplateMethod ∗ FactoryMethod)
[AbstractClass = Creator ∧ TemplateMethod = AnOperation]
14
193
Abstract Factory can be used with Facade to provide an interface
for creating subsystem objects in a subsystem-independent way.
(AbstractFactory ∗ Facade) [AbstractFactory = Facade]
15
161
Abstract Factory can create and conﬁgure a particular bridge.
(AbstractFactory ∗ Bridge) [AbstractProducts = {Abstraction, Implementor}]
16
193
usually only one Facade object is required. Thus Facade objects
are often Singletons.
(Facade ∗ Singleton)[Facade = Singleton]
17
242
A Memento can keep state the commend [in Commkand] requires
to undo its effect.
(Command ∗ Memento)[Originator = Command]
18
242
A command [in Command] that must be copied before being
placed on the history list acts as a Prototype.
(Command ∗ Prototype)[Command = Prototype]
19
271
Polymorphic iterators reply on factory methods to instantiate the
appropriate Iterator subclass.
(Iterator∗FactoryMethod) [ConcreteCreator = ConcreteAggregate ∧ Creator = Aggregate ∧
Product = Iterator ∧ ConcreteProduct = ConcreteIterator∧AnOperation = CreateIterator]
20
271
An iterator can use a memento to capture the state of an iteration.
The iterator stores the memento internally.
(Memento ∗ Iterator) [ConcreteAggregate = Originator]
21
282
Colleagues can communicate with the mediator using the Ob-
server.
(Mediator ∗ Observer) [ConcreteColleagues = {ConcreteSubject, ConcreteObserver}]
22
303
The ChangeManager [an instance of the Mediator pattern] may use
the Singleton pattern to make it unique and globally accessible.
(Mediator ∗ Singleton) [ConcreteMediator = Singleton]
23
313
The Flyweight pattern explains when and how State objects can
be shared.
(Flyweight ∗ State) [Flyweight = State ∧ Handle = Operation(extrinsicState)]
24
313
State objects are often Singletons.
(State ∗ (Singleton ⇑ Singleton)) [Singletons ⊆ ConcreteStates]
25
206
It’s often best to implement Strategy objects as Flyweight.
(Strategy ∗ Flyweight)
[Strategy = Flyweight ∧ algorithmInterface = Operation(extrinsicState)]

364
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
* Defining 
grammar
* Defining 
traversal
* Changing Skin 
versus guts
(25) Sharing 
strategies
(24)
(23) Sharing 
states
(21) Complex 
dependency 
management
(22) 
(20) Saving 
state of iteration
(19)
(18)
(17) Avoiding 
hysteresis
(16) Single 
instance
(15)
(14) 
(13) Often 
uses
(12) Single 
instance
(11) Configure 
factory dynamically
(10) Implement 
using
(9) Adding 
operations
(8) Sharing 
terminal symbols
(7) Composed 
using
(6) Adding 
operations
(2) Defining 
the chain
(4) Sharing
composites
(1) Creating 
composites
Composite
Iterator
Builder
Decorator
Strategy
Flyweight
Interpreter
Visitor
Memento
Command
Chain of 
Responsibility
Observer
Mediator
Template 
Method
Factory
Method
Abstract
Factory
Singleton
Prototype
Bridge
Proxy
Adapter
(5) Enumerating 
children
(3) Adding 
responsibilities
to objects
Facade
State
* Defining 
algorithm 
steps
Figure 15.
Case Study on Formalising Relationships between GoF Patterns
relationships we have formalised that are discussed in the
main text but not shown on the original diagram. Four other
relationships are unnumbered but asterisked. These do not
represent compositions and so have not been formalised. In
particular, and for a start, it is a specialisation relation that
links Composite and Interpreter. The relationship between
Decorator and Strategy is about the differences between
them, not a suggested composition. So too is the relationship
between Strategy and Template Method. And ﬁnally, the
relationship between Iterator and Visitor, has been left
unformalised for the different reason that it is mentioned
in GoF only on the diagram, and not expanded upon in
the main text. Therefore, our case study has covered all the
compositional relationships in the GoF book.
Comparing Table II with Table 2 of [44], which express
the same relationships using composition with overlaps, we
can see that those compositional relationships that require
one-to-many and many-to-many overlaps can all be repre-
sented more accurately using our operators.
In summary, the case studies demonstrated that the oper-
ators deﬁned in this paper are expressive enough to deﬁne
compositions of design patterns. Other work by us [44]
has shown that their logic properties and algebraic laws are
useful for proving the properties of pattern compositions.
VI. CONCLUSION
In this paper, we proposed a set of operators on design
patterns that enable compositions to be formally deﬁned with
ﬂexibility. We illustrated the operators with examples. We
also reported a case study on the relationships suggested by
the GoF book [2]. This demonstrated the expressiveness of
the operators when used to compose patterns.
A. Related Work
As far as we know, there is no similar work in the
literature that deﬁnes operators on design patterns for pattern
composition or instantiation. The closest work is perhaps
that of Dong et al. [37] and Taibi [18], [42], [43], as
previously discussed in Section I. Here we discuss the
relationship between their work and ours more formally,
using their notation for expositional clarity.
In [38], Dong et al. describe a composition P of patterns
P1, P2, · · · Pn using a composition mapping C : P1 × · · · ×
Pn → P. This is, in fact, intended to formally represent a
set of signature mappings Ci such that Ci maps the sets of
component names in pattern Pi to P so the properties θi for
each Pi is translated into another property θ′
i = C(θi) as a
part of the properties of P. In [39], the composition mapping
is better deﬁned as from the union of the variables in Pi.
For instantiation, the mapping is to constants of classes,
attributes, methods, etc.
The approach of Taibi et al. [42], [43] is very similar
except that they directly rename the components using sub-
stitution. Again, composition replaces variables with vari-
ables, whereas instantiation replaces them with constants.
Formally, if pattern P1 have properties ϕ1 and pattern P2
have properties ϕ2 then the properties of their composition
are given by
Subst{v1\t1, · · · , vn\tn}, ϕ1 ∧ ϕ2,
which, informally, is the conjunction of ϕ1 and ϕ2 after
variables vi have each been replaced by terms ti. Here,

365
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
terms ti are either variables or constants. This approach
has an advantage over that of Dong et al. that instantiation
and composition are represented in the same notation, but
apart from that it is mathematically equivalent, because
substitutions are mappings with the terms restricted to be
either variables or constants. Since substitutions and sig-
nature mappings must both preserve variable types for the
translations to be syntactically valid, neither approach can
express one-to-many or many-to-many overlaps. Moreover,
they are both mathematically equivalent to an application of
our restriction operator with conditions in the simplest form,
u = v. That is why our approach is more expressive, as we
have demonstrated in the case study.
B. Further work
Formal reasoning about design patterns and their com-
positions can naturally be supported by formal deduction
in ﬁrst-order logic. This activity is well understood, and
well supported by software tools such as theorem provers.
It is desirable to employ or develop such tools for automatic
reasoning about pattern compositions that are expressed as
applications of the operators.
We have seen that pattern compositions can be represented
by different but equivalent expressions. For example, we saw
in Section III that Adapter1 can be expressed either using
the restriction operator or by using the ﬂatten operator, and
these two expressions are equivalent. Inspired by this, we
have investigated the algebraic laws that the operators obey.
This led us to a calculus of pattern composition for reasoning
about the equivalence of such expressions. The results have
been reported in a separate paper [48], thus omitted here.
One of the more important questions in the study of
pattern composition is whether a composition is appropriate
for a particular pair of patterns. Dong et al. addressed this
issue in [37] with their notion of faithfulness conditions.
A composition is faithful to the composed patterns if it
satisﬁes two conditions: (a) no pattern loses any properties
after composition, and (b) the composition does not add any
new facts to its components. However, Taibi and Ngo argued
that although the ﬁrst condition is relevant, it is not always
necessary [43]. So further investigation seemed warranted
on how to formalise the notion of appropriateness, and to
prove that the operators presented in this paper have such a
property.
REFERENCES
[1] I. Bayley and H. Zhu, “A formal language of pattern compo-
sition,” in Proceedings of The 2nd International Conference
on Pervasive Patterns (PATTERNS 2010). Xpert Publishing
Services, Nov. 2010, pp. 1–6.
[2] E. Gamma, R. Helm, R. Johnson, and J. Vlissides, Design
Patterns - Elements of Reusable Object-Oriented Software.
Addison-Wesley, 1995.
[3] D. Alur, J. Crupi, and D. Malks, Core J2EE Patterns: Best
Practices and Design Strategies, 2nd ed. Prentice Hall, 2003.
[4] M. Grand, Patterns in Java: A Catalog of Reusable Design
Patterns Illustrated with UML,Volume 1. John Wiley & Sons,
2002.
[5] ——, Patterns in Java, volume 2. John Wiley & Sons, 1999.
[6] ——, Java Enterprise Design Patterns. John Wiley & Sons,
2002.
[7] M. Fowler, Patterns of Enterprise Application Architecture.
Addison Wesley, 2003.
[8] G. Hohpe and B. Woolf, Enterprise Integration Patterns:
Designing, Building, and Deploying Messaging Solutions.
Addison Wesley, 2004.
[9] F. Buschmann, K. Henney, and D. C. Schmidt, Pattern-
Oriented Software Architecture. vol. 4: A Pattern Language
for Distributed Computing. John Wiley & Sons, 2007.
[10] M. Voelter, M. Kircher, and U. Zdun, Remoting Patterns. John
Wiley & Sons, 2004.
[11] M.
Schumacher,
E.
Fernandez,
D.
Hybertson,
and
F.
Buschmann, Security Patterns: Integrating Security and Sys-
tems Engineering. John Wiley & Sons, 2005.
[12] C. Steel, Applied J2EE Security Patterns: Architectural Pat-
terns & Best Practices. Prentice Hall, 2005.
[13] L. DiPippo and C. D. Gill, Design Patterns for Distributed
Real-Time Systems. Springer-Verlag, 2005.
[14] B. P. Douglass, Real Time Design Patterns: Robust Scalable
Architecture for Real-time Systems. Addison Wesley, 2002.
[15] R. S. Hanmer, Patterns for Fault Tolerant Software. Wiley,
2007.
[16] P. S. C. Alencar, D. D. Cowan, and C. J. P. de Lucena, “A
formal approach to architectural design patterns,” in Proc. of
FME’96, Springer-Verlag, 1996, pp. 576 – 594.
[17] T. Mikkonen, “Formalizing design patterns,” in Proc. of ICSE
1998. IEEE CS, April 1998, pp. 115–124.
[18] T. Taibi, D. Check, and L. Ngo, “Formal speciﬁcation of
design patterns-a balanced approach,” Journal of Object Tech-
nology, vol. 2, no. 4, Jul.-Aug. 2003.
[19] E. Gasparis, A. H. Eden, J. Nicholson, and R. Kazman,
“The design navigator: charting Java programs,” in Proc. of
ICSE’08, Companion Volume, 2008, pp. 945–946.
[20] I. Bayley and H. Zhu, “Formal speciﬁcation of the variants
and behavioural features of design patterns,” Journal of
Systems and Software, vol. 83, no. 2, pp. 209–221, Feb. 2010.
[21] J. Niere, W. Schäfer, J. P. Wadsack, L. Wendehals, and
J. Welsh, “Towards pattern-based design recovery,” in Proc.
of ICSE 2002. IEEE CS Press, May 2002, pp. 338–348.
[22] D. Hou and H. J. Hoover, “Using SCL to specify and check
design intent in source code,” IEEE Transactions on Software
Engineering, vol. 32, no. 6, pp. 404–423, June 2006.
[23] N. Nija Shi and R. Olsson, “Reverse engineering of design
patterns from Java source code,” in Proc. of ASE 2006, Sept.
2006, pp. 123–134.
[24] A. Blewitt, A. Bundy, and I. Stark, “Automatic veriﬁcation of
design patterns in Java,” in Proc. of ASE 2005. ACM Press,
Nov. 2005, pp. 224–232.
[25] D. Mapelsden, J. Hosking, and J. Grundy, “Design pattern
modelling and instantiation using dpml,” in Proc. of Tools
Paciﬁc 2002. Australian Computer Society, 2002, pp. 3–11.
[26] J. Dong, Y. Zhao, and T. Peng, “Architecture and design
pattern discovery techniques - a review,” in Proc. of SERP
2007, H. R. Arabnia and H. Reza, Eds., vol. II. CSREA Press,
Jun. 25-28 2007, pp. 621–627.
[27] D.-K. Kim and L. Lu, “Inference of design pattern instances
in UML models via logic programming,” in Proc. of ICECCS
2006. IEEE CS Press, Aug. 2006, pp. 47–56.

366
International Journal on Advances in Software, vol 4 no 3 & 4, year 2011, http://www.iariajournals.org/software/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[28] D.-K. Kim and W. Shen, “An approach to evaluating structural
pattern conformance of UML models,” in Proc. of SAC’07.
ACM Press, March 2007, pp. 1404–1408.
[29] ——, “Evaluating pattern conformance of UML models:
a divide-and-conquer approach and case studies,” Software
Quality Journal, vol. 16, no. 3, pp. 329–359, 2008.
[30] H. Zhu, I. Bayley, L. Shan, and R. Amphlett, “Tool support
for design pattern recognition at model level,” in Proc. of
COMPSAC 2009. IEEE CS Press, Jul. 2009, pp. 228–233.
[31] H. Zhu, L. Shan, I. Bayley, and R. Amphlett, “A formal
descriptive semantics of UML and its applications,” in UML
2 Semantics and Applications, K. Lano, Ed. John Wiley &
Sons, Nov. 2009.
[32] F. Buschmann, K. Henney, and D. C. Schmidt, Pattern-
Oirented Software Archiecture. vol. 5: On Patterns and Pat-
tern Languages. John Wiley & Sons, 2007.
[33] D. Riehle, “Composite design patterns,” in Proc. of OOP-
SLA’97. ACM Press, Oct. 1997, pp. 218–228.
[34] J. Vlissides, “Notation, notation, notation,” C++ Report, Apr.
1998.
[35] J. Dong, S. Yang, and K. Zhang, “Visualizing design patterns
in their applications and compositions,” IEEE Transactions
on Software Engineering, vol. 33, no. 7, pp. 433–453, Jul.
2007.
[36] J. M. Smith, “The pattern instance notation: A simple hi-
erarchical visual notation for the dynamic visualization and
comprehension of software patterns,” Journal of Visual Lan-
guages and Computing, vol. 22, no. 5, pp. 355–374, Oct.
2011, doi:10.1016/j.jvlc.2011.03.003.
[37] J. Dong, P. S. Alencar, and D. D. Cowan, “Ensuring structure
and behavior correctness in design composition,” in Proc. of
ECBS 2000. IEEE CS Press, Apr. 2000, pp. 279–287.
[38] J. Dong, P. S. C. Alencar, and D. D. Cowan, “Correct
composition of design components,” in Proc. of the 4th In-
ternational Workshop on Component-Oriented Programming
in conjunction with ECOOP’99, 1999.
[39] J. Dong, P. S.C.Alencar, and D. Cowan, “A behavioral
analysis and veriﬁcation approach to pattern-based design
composition,” Software and Systems Modeling, vol. 3, pp.
262–272, 2004.
[40] J. Dong, T. Peng, and Y. Zhao, “Automated veriﬁcation
of security pattern compositions,” Information and Software
Technology, vol. 52, no. 3, p. 274–295, Mar. 2010.
[41] ——, “On instantiation and integration commutability of
design pattern,” The Computer Journal, vol. 54, no. 1, pp.
164–184, Jan. 2011.
[42] T. Taibi, “Formalising design patterns composition,” Software,
IEE Proceedings, vol. 153, no. 3, pp. 126–153, Jun. 2006.
[43] T. Taibi and D. C. L. Ngo, “Formal speciﬁcation of design
pattern combination using BPSL,” Information and Software
Technology, vol. 45, no. 3, pp. 157–170, March 2003.
[44] I. Bayley and H. Zhu, “On the composition of design pat-
terns,” in Proc. of QSIC 2008, IEEE CS Press, Aug. 2008,
pp. 27–36.
[45] H. Zhu, “On the theoretical foundation of meta-modelling
in graphically extended BNF and ﬁrst order logic,” in Proc.
TASE 2010. IEEE CS Press, Aug. 2010, pp. 95–104.
[46] ——, “An institution theory of formal meta-modelling in
graphically extended BNF,” Frontier of Computer Science,
(In Press).
[47] F. Buschmann, K. Henney, and D. C. Schmidt, Pattern-
oriented Software Architecture. Vol. 1: A System of Patterns.
John Wiley & Sons, 1996.
[48] H. Zhu and I. Bayley, “Laws of pattern composition,” in Proc.
of ICFEM 2010, LNCS, vol. 6447. Springer, Nov. 17-19 2010,
pp. 630–645.

