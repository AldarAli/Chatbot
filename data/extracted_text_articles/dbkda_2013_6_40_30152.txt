Parameterized Attribute and Service Levels Semantic Matchmaking Framework
for Service Composition
Salem Chakhar
CRAD, ESAD, University Laval, Qu´ebec, QC, Canada
Email: salem.chakhar@crad.ulaval.ca
Abstract—The paper presents a parameterized and highly
customizable semantic matchmaking framework. The match-
making approach on which this framework is based dis-
tinguishes three types of matching: (i) functional attribute-
level matching, (ii) functional service-level matching, and (iii)
non-functional matching. This paper focuses only on func-
tional matching. A series of algorithms is advised for both
attribute-level and service-level matching. These algorithms
are designed to support a customizable matching process
that permits the user to control the attributes matched, the
order in which attributes are compared, and the way the
sufﬁciency is computed for both attribute and service levels.
Experimental results show that both the proposed algorithms
and the original one perform pretty much in the same way.
Keywords-web service; service composition; matchmaking;
attribute-level matching; service-level matching.
I. INTRODUCTION
Individual web services are conceptually limited to rela-
tively simple functionalities modeled through a collection
of simple operations. However, for certain types of appli-
cations, it is necessary to combine a set of individual web
services to obtain more complex ones, called composite or
aggregated web services [1]. One important issue within
web service composition is related to the selection of the
most appropriate one among the different candidate com-
posite web services. The selected web service(s) should
mach at best the speciﬁcations provided by the user. Most
of existing matchmaking frameworks such as [2] [3] [4]
utilize a strict capability-based matchmaking, which is
proven [5] to be inadequate in practice. Some recent
proposals including [6] [7] propose to use semantics to
enhance the matchmaking process but most of them still
consider capability attributes only. To avoid the short-
comings of strict capability-based matchmaking, Doshi
et al. [5] present a parameterized semantic matchmak-
ing framework that exhibits a customizable matchmaking
behavior. One important shortcoming of [5] is that the
sufﬁciency condition deﬁned by the authors is very strict
since it requires that all the speciﬁed conditions hold at the
same time. This seems to be very restrictive in practice,
especially for attributes related to the Quality of Service
(QoS).
The objective of this paper is to propose a semantic
matchmaking framework for web service composition. In
this framework, we distinguish three types of matching: (i)
functional attribute-level matching, (ii) functional service-
level matching, and (iii) non-functional matching. The
functional attribute-level matching concerns capability and
property attributes. The functional service-level matching
supports attribute-level matching and adds a service simi-
larity measure that should be satisﬁed by the advertised
service as a whole. The non-functional matching deals
with the QoS attributes. This paper focalizes on functional
matching only.
The rest of the paper is as follows. Section II sets
the background. Section III addresses functional attribute-
level matching. Section IV deals with functional service-
level matching. Section V presents experimental results.
Section VI discusses related work. Section VII concludes
the paper.
II. BACKGROUND
A. Example Scenario
For the purpose of illustration, we consider a web ser-
vice use case concerning travel reservation. This example
is freely inspired from a use case scenario described in
the WSC Web Services Architecture Usage Scenarios [8].
A company (travel agent) offers to people the ability to
book complete vacation packages: plane/train/bus tickets,
hotels, car rental, excursions, etc. Service providers (air-
lines, bus companies, hotel chains, etc) are providing web
services to query their offerings and perform reservations.
The user gets the location of a travel agent service via
an unspeciﬁed way (search engine, service directory, etc).
The user provides a destination and some dates to the
travel agent service. The travel agent service inquires
airlines about deals and presents them to the user.
B. Basic Deﬁnitions
We introduce some basic deﬁnitions of a service and
other service-speciﬁc concepts. Some ones are due to [5].
Deﬁnition 1 (Service): A service S is deﬁned as a
collection of attributes that describe the service. Let S.A
denotes the set of attributes of service S and S.Ai denotes
each member of this set. Let S.N denote the cardinality
of this set.♢
Example 1: The travel agent company provides a web
service, bookVacation, that is deﬁned by the following
attributes: service category, input, output, precondi-
tions, postconditions, response time, availability, cost,
security, and geographical location.♢
Deﬁnition 2 (Service Capability): The capability of a
service S.C is a subset of service attributes (S.C ⊆ S.A),
and includes only functional ones that directly relate to its
working.♢
Example 2: The capability of bookVacation is: S.C =
{input, output, preconditions, postconditions}.♢
159
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

Deﬁnition 3 (Service Quality): The quality of a service
S.Q, is a subset of service attributes (S.Q ⊆ S.A), and
includes all attributes that relate to its QoS.♢
Example 3: The Service Quality of bookVacation is:
S.Q = {response time, availability, cost, security}.♢
Deﬁnition 4 (Service Property): The property of a ser-
vice, S.P, is a subset of service attributes (S.P ⊆ S.A),
and includes all attributes other than those included in
service capability or service quality.♢
Example 4: The property of bookVacation is: S.P =
{service category, geographical location}.♢
C. Service Matching Types
The input for web service composition is a set of
speciﬁcations describing the capabilities of the desired
service. These speciﬁcations can be decomposed into two
groups:
• Functional requirements that deal with the desired
functionality of the composite service,
• Non-functional requirements that relate to issues like
cost, performance and availability.
The non-functional requirements are often called QoS
attributes. The QoS attributes can be subdivided into two
groups [1]:
• Hard attributes: These correspond to QoS attributes
for which some obligatory constraints are imposed by
the client. Instances that fail to meet these constraints
are automatically eliminated,
• Soft attributes: These correspond to QoS attributes
that should be optimized, i.e., maximized or mini-
mized, according to the user desires.
Hard QoS attributes are very useful in practice since
they permit to reduce the computing time. They should
be used in a preliminary analysis step [1] to reduce the
number of candidate compositions. Soft QoS attributes, in
the contrary, are used to compute the overall QoS of the
remaining candidate compositions.
Furthermore, we may distinguish three types of service
matching [1]:
• Functional attribute-level matching: This type of
matching concerns capability and property attributes
and consider each matching attribute independently
of the others.
• Functional service-level matching: This type of
matching concerns capability and property attributes
but the matching operation implies the service as a
whole.
• Non-functional matching: This type of matching
concerns QoS attributes. It uses soft QoS attributes.
In the rest of this paper, we will focalize only on
functional attribute-level and service-level matching. The
non-functional QoS-oriented matching is addressed in [9].
III. FUNCTIONAL ATTRIBUTE-LEVEL MATCHING
Functional matching may be deﬁned as the process
of discovering a service advertisement that sufﬁciently
satisﬁes a service request [5]. Functional matching is based
on the concept of sufﬁciency. The latter relies on the
similarity measure.
A. Similarity Measure
A semantic match between two entities frequently
involves a similarity measure. The similarity measure
quantiﬁes the semantic distance between the two entities
participating in the match. Following [5], a similarity
measure is deﬁned as follows.
Deﬁnition 5 (Similarity Measure): The
similarity
measure, µ, of two service attributes is a mapping that
measures the semantic distance between the conceptual
annotations
associated
with
the
service
attributes.
Mathematically,
µ : A × A →
{Exact, Plug-in, Subsumption,
Container, Part-of, Disjoint}
where A is the set of all possible attributes.♢
The mapping between two conceptual annotations is
called:
• Exact map: if the two conceptual annotations are
syntactically identical,
• Plug-in map: if the ﬁrst conceptual annotation is
specialized by the second,
• Subsumption map: if the ﬁrst conceptual annotation
specializes the second,
• Container map: if the ﬁrst conceptual annotation
contains the second,
• Part-of map: if the ﬁrst conceptual annotation is a
part of the second,
• Disjoint map: if none of the previous cases applies.
A preferential total order may now be established on
the above mentioned similarity maps.
Deﬁnition 6 (Similarity Measure Preference):
Preference amongst similarity measures is governed by
the following strict total order:
Exact ≻ Plug-in ≻ Subsumption ≻ Container ≻
Part-of ≻ Disjoint
where a ≻ b means that a is preferred over b.♢
This deﬁnition of similarity measure is due to [5]. Other
matchmaking frameworks (e.g., [10] [5] [3] [4]) utilize an
idea similar to µ, but label it differently.
B. Matchmaking Supported Customizations
The functional attribute-level matching algorithms pro-
posed in this paper extend [5]’s matchmaking algorithm.
Indeed, to enhance the work of [5], we propose an
additional customization by allowing the user to specify
the way the similarity measures are logically aggregated.
Indeed, in [5]’s matching algorithm, the match must hold
conjointly for all attributes. However, it may be useful to
allow the user to specify different types of logical expres-
sions. In fact, other logical connectors than “AND” may
be used to combine attribute-level similarity measures.
Accordingly, we distinguish three types of functional
attribute-level matching: (i) conjunctive matching based
on the use of “AND” connector, (ii) disjunctive matching
based on the use of “OR” connector, and (iii) complex
matching that uses different logical connectors, especially
160
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

“AND”, “OR” and “NOT” operators. For the purpose
of this paper, only conjunctive and disjunctive functional
attribute-level matching are considered. Complex match-
ing is addressed in [9].
C. Functional Attribute-Level Conjunctive Matching
As speciﬁed above, functional matching concerns only
capability and property attributes. Let SR be the service
that is requested, and SA be the service that is advertised.
A ﬁrst customization of functional matching is to allow
the user to specify a desired similarity measure for each
(capability and property) attribute in SR.A. In this case, a
sufﬁcient match exists between SR and SA in respect to
attribute SR.Ai if there exists an identical attribute of SA
and the values of the attributes satisfy the desired simi-
larity measure. A second customization of the matching
process is to allow the user specifying which attributes
of the service requested should be utilized during the
matching process, and the order in which the attributes
must be considered for comparison.
In order to support these customizations, we use the
concept of Criteria Table, introduced by [5], that serves
as a parameter to the matching process.
Deﬁnition 7 (Criteria Table): A Criteria Table, C, is
a relation consisting of two attributes, C.A and C.M.
C.A describes the service attribute to be compared, and
C.M gives the least preferred similarity measure for that
attribute. Let C.Ai and C.Mi denote the service attribute
value and the desired measure in the ith tuple of the
relation. C.η denotes the total number of tuples in C.♢
Example 5: Table I shows a Criteria Table example.♢
Table I
AN EXAMPLE CRITERIA TABLE
C.A
C.M
input
Exact
output
Exact
precondition
Subsumes
postcondition
Subsumes
A sufﬁcient functional attribute-level conjunctive match
between services can now be deﬁned as follows.
Deﬁnition 8 (Sufﬁcient Functional Conjunctive Match):
Let SR be the service that is requested, and SA be the
service that is advertised. Let C be a Criteria Table. A
sufﬁcient conjunctive match exists between SR and SA
if for every attribute in C.A there exists an identical
attribute of SR and SA and the values of the attributes
satisfy the desired similarity measure as speciﬁed in
C.M. Formally,
∀i∃j,k(C.Ai = SR.Aj = SA.Ak) ∧ µ(SR.Aj, SA.Ak) ≽ C.Mi
⇒ SuffFunctionalConjunctiveMatch(SR, SA)
1 ≤ i ≤ C.η.♢
(1)
The functional attribute-level conjunctive match is for-
malized in Algorithm 1. This algorithm follows directly
from Sentence (1).
D. Functional Attribute-Level Disjunctive Matching
A less restrictive deﬁnition of sufﬁciency consists in
using a disjunctive rule on the individual similarity mea-
sures. The attribute-level disjunctive matching is deﬁned
as follows.
Deﬁnition 9 (Sufﬁcient Functional Disjunctive Match):
Let SR be the service that is requested, and SA be the
service that is advertised. Let C be a Criteria Table. A
sufﬁcient disjunctive match exists between SR and SA
if for at least one attribute in C.A it exists an identical
attribute of SR and SA and the values of the attributes
satisfy the desired similarity measure as speciﬁed in
C.M. Formally,
∃i,j,k(C.Ai = SR.Aj = SA.Ak) ∧ µ(SR.Aj, SA.Ak) ≽ C.Mi
⇒ SuffFunctionalDisjunctiveMatch(SR, SA).♢
(2)
The functional attribute-level disjunctive match is for-
malized in Algorithm 2. This algorithm follow directly
from Sentence (2). Algorithms (1) and (2) differ only at
the level of the last while loop.
Algorithm 1: FunctionalConjunctiveMatching
Input : SR, // requested service.
SA, // advertised requested.
C, // criteria table.
Output: Boolean // success: true; fail: false.
while (i ≤ C.η) do
while
(
j ≤ SR.N
)
do
if
(
SR.Aj = C.Ai
)
then
Append SR.Aj to rAttrSet;
end
Assign j ←− j + 1;
end
while
(
k ≤ SA.N
)
do
if
(
SA.Ak = C.Ai
)
then
Append SA.Ak to aAttrSet;
end
Assign k ←− k + 1;
end
Assign i ←− i + 1;
end
while (t < C.η) do
if (µ(rAttrSet[t], aAttrSet[t]) ≺ C.Mt) then
return fail;
end
Assign t ←− t + 1;
end
return success;
E. Computational Complexity
Algorithms 1 and 2 have the same complexity. Gener-
ally, we have SA.N ≫ SR.N, hence the complexity of the
ﬁrst outer while loop is O(C.η × SA.N). Then, the worst
case complexity of our algorithms is O(C.η ×SA.N)+α
where α is the complexity of computing µ. The value
of α depends on the approach used to infer µ(·, ·). As
underlined in [5], inferring µ(·, ·) by ontological parse of
pieces of information into facts and then utilizing com-
mercial rule-based engines which use the fast Rete [11]
pattern-matching algorithm leads to α = O(|R||F||P|)
where |R| is the number of rules, |F| is the number of
facts, and |P| is the average number of patterns in each
rule. In this case, the worst case complexity of Algorithms
1 and 2 is O(C.η × SA.N) + O(|R||F||P|). Furthermore,
we observe, as in [5], that the process of computing µ is
the most “expensive” step of the algorithms. Hence, we
obtain: O(C.η ×SA.N)+O(|R||F||P|) ≍ O(|R||F||P|).
161
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

Algorithm 2: FunctionalDisjunctiveMatching
Input : SR, // requested service.
SA, // advertised requested.
C, // criteria table.
Output: Boolean // success: true; fail: false.
while (i ≤ C.η) do
while
(
j ≤ SR.N
)
do
if
(
SR.Aj = C.Ai
)
then
Append SR.Aj to rAttrSet;
end
Assign j ←− j + 1;
end
while
(
k ≤ SA.N
)
do
if
(
SA.Ak = C.Ai
)
then
Append SA.Ak to aAttrSet;
end
Assign k ←− k + 1;
end
Assign i ←− i + 1;
end
while (t < C.η) do
if (µ(rAttrSet[t], aAttrSet[t]) ≽ C.Mt) then
return success;
end
Assign t ←− t + 1;
end
return fail;
IV. FUNCTIONAL SERVICE-LEVEL MATCHING
The service-level matching allows the client to use two
types of desired similarity: (i) desired similarity values
associated with each attribute in the Criteria Table, and
(ii) a global desired similarity that applies to the service
as a whole. In order to deﬁne the sufﬁcient functional
service-level match, we need to introduce the concepts of
aggregation rule and sufﬁcient single attribute match.
A. Aggregation Rule
The computing of service-level similarity measure re-
quires the deﬁnition of an aggregation rule to combine the
similarity measures associated with attributes into a single
measure relative to the service as a whole.
Deﬁnition 10 (Aggregation Rule): An
aggregation
rule ζ is a mean to combine the similarity measures into
a single similarly measure. Mathematically,
ζ : F1 × · · · × Fη →
{Exact, Plug-in, Subsumption,
Container, Part-of, Disjoint}
where Fj={Exact, Plug-in, Subsumption, Container, Part-
of, Disjoint} (j = 1, · · · , η); and η is the number of
attributes included in the Criteria Table.♢
The similarity maps given in Section III-A still apply
here. Furthermore, the preference amongst similarity mea-
sures is governed by the same strict total order given in
Deﬁnition 6.
Since the similarity measures are deﬁned on an ordinal
scale, there are only a few possible aggregation rules that
can be used to combine similarity measures:
• Minimum: picks out the minimum similarity mea-
sure,
• Maximum: picks out the maximum similarity mea-
sure,
• Median: picks out the similarity measure correspond-
ing to the median (in terms of order).
• Floor: picks out the similarity measure corresponding
to the ﬂoor of the median values.
• Ceil: picks out the similarity measure corresponding
to the ceil of the median values.
The Floor and Ceil rules apply only when there is an
even number of similarity measures (which leads to two
median values).
B. Sufﬁcient Single Attribute Match
The sufﬁcient single attribute match is deﬁned as fol-
lows.
Deﬁnition 11 (Sufﬁcient Single Attribute Match): Let
SR be the service that is requested, and SA be the service
that is advertised. Let C be a Criteria Table. A sufﬁcient
match exists between SR and SA in respect to attribute
SR.Ai if there exists an identical attribute of SA and
the values of the attributes satisfy the desired similarity
measure as speciﬁed in C.Mi. Formally,
∃j,k(C.Ai = SR.Aj = SR.Ak) ∧ µ(SR.Aj, SA.Ak) ≽ C.Mi)
⇒ SuffSingleAttrMatch(SR, SA, Ai).♢
(3)
The single attribute matching is formalized in Algorithm
3. This algorithm follows directly from Sentence (3).
Algorithm 3: SuffSingleAttrMatching
Input : SR, // requested service.
SA, // advertised requested.
C, // criteria table.
Ai, // service attribute.
Output: Boolean // success: true; fail: false.
while
(
j ≤ SR.N
)
do
if
(
SR.Aj = C.Ai
)
then
Append SR.Aj to rAttrSet;
end
Assign j ←− j + 1;
end
while
(
k ≤ SA.N
)
do
if
(
SA.Ak = C.Ai
)
then
Append SA.Ak to aAttrSet;
end
Assign k ←− k + 1;
end
if (µ(rAttrSet[i], aAttrSet[i]) ≽ C.Mi) then
return success;
end
return fail;
C. Functional Service-Level Matchmaking Algorithm
The service-level similarity measure quantiﬁes the se-
mantic distance between the requested service and the
advertised service entities participating in the match by
taking into account both attribute-level and service-level
desired similarity measures.
Deﬁnition 12 (Sufﬁcient Functional Service-Level Match):
Let SR be the service that is requested, and SA be the
service that is advertised. Let C be a Criteria Table.
Let β be the service-level desired similarity measure. A
sufﬁcient service-level match exists between SR and SA
if (i) for every attribute in C.A there exists an identical
attribute of SR and SA and the values of the attributes
162
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

satisfy the desired similarity measure as speciﬁed in C.M,
and (ii) the value of overall similarity measure satisﬁes
the desired overall similarity measure β. Mathematically,
[∀i
(SuffSingleAttrMatch(SR, SA, Ai))
1 ≤ i ≤ C.η]
∧
[∃j1, · · · , ji, · · · , jη
(ζ(s1,j1, · · · , si,ji, · · · , sη,jη ) ≽ β)]
⇒ SuffFunctionalServiceLevelMatch(SR, SA)
(4)
where ζ is an aggregation rule; and for i = 1, · · · , η and
ji ∈ {j1, · · · , jη}:
si,ji = µ(SR.Ai, SA.Aji).♢
The service-level matching is formalized in Algorithm
4. This algorithm follows directly from Sentence (4).
Algorithm 4: FunctionalServiceLevelMatching
Input : SR, // requested service.
SA, // advertised requested.
C, // criteria table.
ζ, // aggregation rule.
β, // overall similarity threshold.
Output: Boolean // success: true; fail: false.
while (i ≤ C.η) do
if
(
NOT (SuffSingleAttrMatch(SR, SA, Ai))
)
then
return fail;
end
end
while (i ≤ C.η) do
while
(
j ≤ SR.N
)
do
if
(
SR.Aj = C.Ai
)
then
Append SR.Aj to rAttrSet;
end
Assign j ←− j + 1;
end
while
(
k ≤ SA.N
)
do
if
(
SA.Ak = C.Ai
)
then
Append SA.Ak to aAttrSet;
end
Assign k ←− k + 1;
end
Assign i ←− i + 1;
end
if
(ζ(µ(rAttrSet[1], aAttrSet[1]), · · · , µ(rAttrSet[C.η], aAttrSet[C.η])) ≽ β)
then
return success;
end
return fail;
D. Computational Complexity
The complexity of the two ﬁrst while loops in Algorithm
3 is equal to O(SR.N) + O(SA.N). Generally we have
SA.N ≫ SR.N, hence the complexity of the two ﬁrst
while loops in Algorithm 3 is equal to O(SA.N). Then,
based on the discussion given in Section III-E, we may
conclude that the worst case complexity of Algorithm 3 is
O(|R||F||P|), where R, F and P have the same deﬁnition
as in Section III-E.
Based on the discussion in Section III-E, we can set
that the complexity of the ﬁrst while loop in Algorithm
4 is equal to O(C.η × (|R||F||P|)) and the complexity
of the second while loop is equal to O(C.η × SA.N).
Finding the minimum, maximum, median, ﬂoor and ceil of
a list of n values are O(n) worst-case linear time selection
algorithms. Then, the overall complexity of Algorithm 4 is
equal to O(C.η ×(|R||F||P|))+O(C.η ×SA.N)+O(n).
Then based on the discussion of Section III-E, the worst
case complexity of Algorithm 4 is O(|R||F||P|) + O(n).
V. ILLUSTRATION AND EXPERIMENTAL RESULTS
A. Illustration
Let consider the travel agent scenario example given
in Section II. Fig. 1 shows a fragment of the Travel
Agent Ontology. We consider an Advertisement for the
travel agent web service who permits the client to book
Accommodation in the speciﬁed Destination. Assume that
the Advertisement has the following Inputs and Outputs:
Inputs:
Destination
Outputs:
Accommodation, Sport, Cost
We consider a Query from a client who planning a
vacation. The client wants to make reservations for a
Hotel and an Excursion at the speciﬁed Destination. As
shown in Fig. 1, the Hotel is a subclass of the concept
Accommodation and Excursion is a subclass of the concept
Entertainment. The Query has the following Inputs and
Outputs:
Inputs:
Destination
Outputs:
Hotel, Excursion
Let now focalize on the process of matching Query
outputs. The same reasoning applies to the process of
matching the inputs. The matching algorithm iterates over
the list of output concepts of the Query and looks to
ﬁnd a match to an output concept in the Advertise-
ment. Intuitively, any concept in the output represents a
candidate for the match. In this particular example, the
initial candidate list is {Accommodation, Sport, Cost}.
The matching algorithm ﬁrst looks to see if there is a
match for Hotel. Based on Fig. 1, the match between
Hotel and Accommodation will be ﬂagged Exact. Then, the
algorithm looks a match for Excursion. Based on Fig. 1,
the match for Excursion with respect to Accommodation,
Sport and Cost will fail (since there is no relationship
between these concepts and Excursion concept). Based on
the same reasoning, we obtain an Exact match for the input
concept Destination.
Assume now that the Criteria Table is as in Table II.
The desired similarity speciﬁed by the Criteria Table holds
only for Destination and Hotel. Hence, the attribute-level
conjunctive matching algorithm will fail but the attribute-
level disjunctive matching algorithm will success.
Table II
CRITERIA TABLE
C.A
C.M
input
Exact
output
Exact
Suppose now that the Advertisement has the following
Inputs, Outputs and Categories:
Inputs:
Destination
Outputs:
Accommodation, Entertainment, Cost
Categories:
AirplaneModel
163
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

Figure 1.
Travel Ontology
Suppose also that Query has the following Inputs,
Outputs and Categories:
Inputs:
Destination
Outputs:
HotelType, Excursion
Categories:
AirplaneModel
Based on the same reasoning as earlier, the match for
Destination, Excursion and AirplaneModel concepts will
be ﬂagged Exact; and the match for concept HotelType
will be ﬂagged Plug-in. Assume that the Criteria Table is
as follows:
Table III
CRITERIA TABLE
C.A
C.M
input
Exact
output
Exact
service category
Subsumption
The instantiation of the last instruction in Algorithm
(4) will then look like ζ(Exact, Plug-in, Exact, Exact).
Then, the result of Algorithm (4) according to different
aggregation rules (except Median which does not apply
here) is as follows:
Table IV
RESULT OF AGGREGATION
Aggregation rule (ζ)
Minimum
Maximum
Floor
Ceil
Result
Plugin
Exact
Plugin
Exact
B. Implementation and Experimental Results
For the purpose of implementation, we used the same
architecture proposed by [10]. We used the Protege ed-
itor [12] to browse and edit OWL [13] ontologies. The
Mindswap OWL-S API [14] has been used to load the
OWL ontologies into the Knowledge Base and parse
the OWL-S [13] Queries and Advertisements. We used
the Pellet reasoner [15] to classify the loaded ontologies
and Jena API [16] to query the reasoner for concept
relationships. To test the algorithms, we used 10 ontologies
from the OWTLS-TC (service retrieval test collection
from SemWebCentral) in our Knowledge Base. About
500 advertisements from OWLS-TC were loaded into
the advertisement repository. Experiments were designed
to measure execution time of the algorithms. All mea-
surement points shown are average results taken from
50 runs. The data sets for clients and providers were
randomly generated. Fig. 2 shows the execution time of
all algorithms.
Figure 2.
Execution time of algorithms
VI. RELATED WORK
Existing matchmaking frameworks such as [2] [3] [4]
utilize a strict capability-based matchmaking, which is
proven [5] to be inadequate in practice. Some recent
proposals [6] [7] propose to use semantics to enhance
the matchmaking process but most of them still consider
capability attributes only. Doshi et al. [5] present a param-
eterized semantic matchmaking framework that exhibits a
customizable matchmaking behavior. This framework has
three main merits. First, it uses semantic information in the
matching process which has been proven in information
retrieval [17], fuzzy database [18] and semantic web
services [19] [20] [21] to be more useful than simple
syntactic search. Second, it uses both functional and non-
functional matchmaking. Third, by enabling the user to
specify matchmaking criteria and conditions. One impor-
tant shortcoming of [5] is that the sufﬁciency condition
deﬁned by the authors is very strict since it requires that
all the speciﬁed conditions hold at the same time.
In [22], Fu et al. transform the problem of matching web
services to the computation of semantic similarity between
concepts in domain ontology. They developed a semantic
distance measure to provide a quantitative similarity mea-
sures to support matching in semantic web services. Bellur
and Kulkarni [10] improve [3]’s matchmaking algorithm
and propose a greedy-based algorithm that relies on the
concept of matching bipartite graphs. Their idea permits to
avoid problems faced with the original [3]’s matchmaking
algorithm.
In [9], we extended the work given in this paper
by adding generic attribute-level and non-functional QoS
matching. The non-functional matching permits to catego-
rize web services into different ordered QoS classes. The
user should then select one web service from the highest
QoS class for implementation.
We think that the matchmaking framework presented
in this paper extends and improves the works of [10] [5]
[3]. Speciﬁcally, the proposed framework adds more cus-
tomization, relaxes matchmaking conditions and supports
three types of matching. An important addition of the
proposed framework is the service-level matching which,
to the best knowledge of the author, previous studies have
not dealt with it.
164
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

VII. CONCLUSION AND FUTURE WORK
In this paper, we presented a parameterized and highly
customizable semantic matchmaking framework. A series
of highly customizable algorithms is advised for both
attribute-level and service-level matching. These algo-
rithms are designed to support a customizable matching
process that permits the user to control the attributes
matched, the order in which attributes are compared, as
well as the way the sufﬁciency is computed for both
attribute and service levels. In this paper, we addressed
functional attribute-level conjunctive matching, functional
attribute-level disjunctive matching and functional service-
level matching. We extended the work given in this paper
in [9] by adding generic attribute-level and non-functional
QoS matching.
The matchmaking framework proposed in this paper
and its extended version given in [9] constitutes a basic
component of a layered system, called QoSeBroker, for
web service composition that we have proposed in [1].
In the future, we plan to conduce additional experimental
tests in order to analyze the performance of the matching
algorithms. We also intend to implement the subsequent
components of QoSeBroker system.
REFERENCES
[1] S. Chakhar, “QoS-enhanced broker for composite web ser-
vice selection,” in Proc. of the 8th International Conference
on Signal Image Technology & Internet Based Systems,
Sorrento - Naples, Italy, Nov. 2012, pp. 533–540.
[2] L. Li and I. Horrocks, “A software framework for match-
making based on semantic web technology,” in Proc. of the
12th International World Wide Web Conference, Budapest,
Hungary, May 1999, pp. 331–339.
[3] M. Paolucci, T. Kawamura, T. Payne, and K. Sycara,
“Semantic matching of web services capabilities,” in Proc.
of the First International Semantic Web Conference on The
Semantic Web, Sardinia, Italy, Jun. 1999, pp. 333–347.
[4] K. Sycara, M. Paolucci, M. van Velsen, and J. Giampapa,
“The retsina mas infrastructure,” Autonomous Agents and
Multi-Agent Systems, vol. 7, no. 1-2, pp. 29–48, 2003.
[5] P. Doshi, R. Goodwin, R. Akkiraju, and S. Roeder, “Param-
eterized semantic matchmaking for workﬂow composition,”
IBM Research Division, Tech. Rep. RC23133, Mar. 2004.
[6] S. Ben Mokhtar, A. Kaul, N. Georgantas, and I. Val´erie,
“Efﬁcient semantic service discovery in pervasive com-
puting environments,” in Proc. of the ACM/IFIP/USENIX
2006 International Conference on Middleware, Melbourne,
Australia, Nov. 2006, pp. 240–259.
[7] R. Guo, J. Le, and X. L. Xiao, “Capability matching
of web services based on OWL-S,” in Proc. of the 16th
International Workshop on Database and Expert Systems
Applications, Copenhagen, Denmark, Aug. 2005, pp. 653–
657.
[8] H.
Hao,
H.
Haas,
and
D.
Orchard.
(2004)
Web
services architecture usage scenarios. [Online]. Available:
http://www.w3.org/TR/ws-arch-scenarios/ [retrieved: Nov.,
2012]
[9] S. Chakhar, “QoS-aware parameterized semantic match-
making for web service composition,” in Proc. of the 9th
International Conference on Web Information Systems and
Technologies, Aachen, Germany, May 2013, unpublished.
[10] U. Bellur and R. Kulkarni, “Improved matchmaking algo-
rithm for semantic web services based on bipartite graph
matching,” in Proc. of the IEEE International Conference
on Web Services, Salt Lake City, Utah, USA, Jul. 2007, pp.
86–93.
[11] C. Forgy, “Rete: A fast algorithm for the many pat-
terns/many objects match problem,” Artiﬁcial Intelligence,
vol. 19, no. 1, pp. 17–37, 1982.
[12] Protege: Ontology editor and knowledge-base framework.
[Online]. Available: http://protege.stanford.edu/ [retrieved:
Nov., 2012]
[13] G. Antoniou and F. van Harmelen, “Web ontology lan-
guage: OWL,” in Handbook on Ontologies, 2nd ed.,
S. Staab and R. Studer, Eds. Berlin / Heidelberg, Germany:
Springer-Verlag, 2009, pp. 91–110.
[14] MINDSWAP: Maryland information and network dynamics
lab
semantic
web
agents
project,
OWL-S
API.
[Online]. Available: http://www.mindswap.org/2004/owl-
s/api/ [retrieved: Nov., 2012]
[15] Pellet:
An
OWL
DL
reasoner.
[Online].
Available:
http://pellet.owldl.com/ [retrieved: Nov., 2012]
[16] Jena: Java framework for building semantic web. [Online].
Available:
http://jena.sourceforge.net/
[retrieved:
Nov.,
2012]
[17] A. K. Kirykov and K. S. Iv, “Ontologically supported
semantic matching,” in Proc. of NoDaLiDa’99: Nordic
Conference on Computational Linguistics, Trondheim, Nor-
way, Dec. 1999, pp. 9–10.
[18] R. Bouaziz, S. Chakhar, V. Mousseau, S. Ram, and A. Tel-
moudi, “Database design and querying within the fuzzy
semantic model,” Information Sciences, vol. 177, no. 21,
pp. 4598–4620, 2007.
[19] J. Cardoso, J. Miller, and S. Emani, “Web services discov-
ery utilizing semantically annotated WSDL,” in Reasoning
Web, C. Baroglio, P. Bonatti, J. Maluszynski, M. Marchiori,
A. Polleres, and S. Schaffert, Eds.
Berlin / Heidelberg,
Germany: Springer-Verlag, 2008, pp. 240–268.
[20] C. Mateos, M. Crasso, A. Zunino, and M. Campo, “Sup-
porting ontology-based semantic matching of web services
in movilog,” in Advances in Artiﬁcial Intelligence, S. R.
J. Sichman, H. Coelho, Ed. Berlin / Heidelberg, Germany:
Springer-Verlag, 2006, pp. 390–399.
[21] P. V. C. E. Wu, C., “Latent semantic analysis - the dynamics
of semantics web services discovery,” in Advances in Web
Semantics I, R. M. K. S. T. Dillon, E. Chang, Ed.
Berlin /
Heidelberg, Germany: Springer-Verlag, 2009, pp. 346–373.
[22] P. Fu, S. Liu, H. Yang, and L. Gu, “Matching algorithm of
web services based on semantic distance,” in Proc. of the
2009 International Workshop on Information Security and
Application, Qingdao, China, Nov. 2009, pp. 465–468.
165
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-247-9
DBKDA 2013 : The Fifth International Conference on Advances in Databases, Knowledge, and Data Applications

