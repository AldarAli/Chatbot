Towards a Formalised Approach for Integrated Function Updates of Mechatronic
Systems
Tim Warnecke, Karina Rehfeldt, Andreas Rausch
Technische Universit¨at Clausthal
38678 Clausthal-Zellerfeld, Germany
email: {tim.warnecke, karina.rehfeldt, andreas.rausch}@tu-clausthal.de
David Inkermann, Tobias Huth, Thomas Vietor
Technische Universit¨at Braunschweig
38106 Braunschweig, Germany
email: {d.inkermann, tobias.huth, t.vietor}@tu-braunschweig.de
Abstract—Looking at different everyday products, we are
facing the situation that they are replaced although their technical
life time has not ended. The main reason for this is that
customers often replace products like smart phones or household
devices, because there are new ones available providing new
and additional functions and features. These functions and
features are predominately based on software and follow shorter
development and innovation cycles. From the resource point of
view the mismatch between technical life time and use period
of products leads to great disposal. In order to address this
challenge, a common concept is to update existing products. To
provide substantial new functions, such updates have to concern
both hardware and software components. Due to the complexity
of dependencies between these components, it is not an easy task
to come up with these integral and veriﬁed updates. As a ﬁrst
step to tackle this problem, we propose a formalized approach to
describe integrated hardware and software upgrades. Based on
this formalism, we present our ongoing research and preliminary
results in the ﬁelds of functions and systems modeling.
Index Terms—Complex Systems; Design for Maintainability;
Release Management; Software Product Lines; Software Evolu-
tion.
I. INTRODUCTION
In most of modern products like vehicles, household devices
or machine tools, functions are realized by a combination
of hardware, electronics and software components. These
components are the results of development within different
domains and are often differing with regard to the time needed
for their realization, their innovation cycles and their speciﬁc
technological advancements. Fast technological developments,
for instance in the ﬁelds of comfort or communication in-
terfaces, are often driven by software engineering. However,
engineering and development of hardware components like
a car body or drive train are missing the speed of these
advancements. At the same time, implementation of new soft-
ware often requires speciﬁc hardware like sensors or actors.
Therefore, common practice is to implement and release new
functions only within new released product generations. This
leads to the situation that the actual use period of products
compared to their technical life span is greatly shortened [1],
[2]. Products are shut down or disposed of, although their
functionality is still given from the technical point of view [3].
This is caused by the customers buying decisions which are
tremendously inﬂuenced by features like comfort, assistance
or multimedia-based functions. Furthermore, the gap between
technical life span and actual use period leads to the disposal of
still valuable resources like materials but energy - for instance
of the manufacturing process stored within the mechanical
components - as well. In order to counteract this trend and
increase the ecological sustainability of products, there are
several restrictive laws planned. For instance, it is planned to
deﬁne a minimum service life span for electric components
[4]. Another expedient and less restrictive strategy is a so
called planned product upgrade of an existing product. Within
this paper we follow the second strategy.
A. Challenge of Integrated Product Updates
There is a great body of literature dealing with the adaptabil-
ity and changeability of products. General approaches referred
to as Design for Changeability [5], Design for Flexibility [6]
or modularization [7] provide basic strategies to adapt system
properties and functions during the life cycle. However, these
approaches are focusing on the classical life cycle understand-
ing and do not consider upgrades of existing products. The
focus of these approaches is to support the initial design of
products.
In the domain of software engineering, product updates are
generally possible if the software was designed accordingly.
However, when it comes to systems, including both hardware
and software like embedded systems, software upgrades are
limited by the installed hardware components. Furthermore,
software updates are often hindered because new software
63
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-532-6
ADAPTIVE 2017 : The Ninth International Conference on Adaptive and Self-Adaptive Systems and Applications

Fig. 1. Illustration of the question whether an existing product variant can be updated with a new function.
is developed with current hardware components in mind and
does not consider limitations of older hardware components.
Therefore, compatibility with existing hardware components
of previous product variants is not guaranteed. This forward-
looking development drives progress, but makes the integration
of new software functions into existing products even harder.
In the domain of hardware engineering, it is even worse, since
most of the used hardware components can’t be easily changed
after the initial handover to the customer. Furthermore, it is
hard to identify and deﬁne required extensions within existing
hardware conﬁgurations to enable the implementation of new
software functions.
In order to support an integrated function update of mecha-
tronic systems, it is therefore essential to analyze the interrela-
tions between functions and features as well as the components
realizing these functions and features.
B. Focus of Research
Figure 1 highlights the problem addressed in this contribu-
tion by schematically representing the development of vehicle
variants in product lines and their constituting components.
The development is ongoing over time and new products
are based on either existing, updated or newly developed
components. To support the update of products, it is essential
to understand how their components can be adapted. This
question is directly linked to the time scale we present in
Figure 1. Here, the ﬁrst two vehicles p1 and p2 represent
vehicles, which are already in use. Vehicle p1 of the ﬁrst
generation uses three components k11 − k31. Note, here kij is
the component ki used in development version j. The vehicle
p2 in the middle is an advanced development of p1. Product p2
uses the same component identities k1−k3 but in development
version 2, here components k12 − k32. On the right hand side
of Figure 1 a vehicle in development version, p3, is illustrated.
Variant p3 uses the components k2 and k3 in version 3. In this
case, the component k12 used in vehicle p2 is reused directly,
because an improvement was not necessary. Additionally, p3
receives a new functionality, in this case a lane keeping system
(LKS), illustrated by the top most component. Because of a
proper executed development process of vehicle p3, we can
be certain that the LKS will work correctly in the component
conﬁguration of this vehicle. Additionally, during its own
development, the previous vehicle p2 was already tested and
checked for functional correctness. In order to support the
integrated update of the vehicle p2, we are facing the question
whether the LKS system of vehicle p3 can be also integrated
and which changes have to be made with regard to existing
software and hardware components.
Our research is focusing on methods to model and ana-
lyze the compatibility and interaction between hardware and
software components. Primary objective is to provide methods
supporting estimation and evaluation of required changes of
both, hardware and software, components. Furthermore, we
aim to reduce the effort required for safeguarding of changed
product conﬁgurations after updating these. This research
will contribute to efﬁcient upgrades of existing mechatronic
systems and, therefore, the extension of their use periods. The
research is guided by the following questions:
• How do we model the structure, behavior, functions and
requirements of systems to identify required adaptations
or updates with regard to hardware and software?
• How do we reduce test effort of a new system conﬁgu-
ration when its functions and structure are already partly
tested?
• How do we support the design of evolution friendly
64
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-532-6
ADAPTIVE 2017 : The Ninth International Conference on Adaptive and Self-Adaptive Systems and Applications

system structures?
In this contribution, we describe a formalism to specify the ﬁrst
question. Furthermore, we state the areas to work on further
more precisely. Therefore, in Section II we discuss the state
of the art and basic understanding of releases and design for
maintainability as well as approaches for systems modeling,
both from the mechanical and the software point of view.
In Section III, we deﬁne a simple formalization to describe
functions, components and their connecting structure. Based
on this, we introduce our approach to the stated problem in
Section IV. The paper is summarized by a short conclusion in
Section V.
II. BACKGROUND AND STATE OF THE ART
Based on the focus of research introduced, in this section
an overview and deﬁnitions of essential terms are given.
The focus is on basic strategies to extend the use period of
complex systems and their effects on hardware and software
components.
Release Management (RM) is originated from software de-
velopment and describes the process and activities conducted
to develop and deploy releases as a result of change requests.
A major task of RM is to maintain the integrity and minimize
the disruption of the original system during and after the
deployment release of new features. This is done by prior
planning and testing of a release [8]. A release in this context,
is a collection of “one or more changes to a service that are
built, tested and deployed together” [8]. At the beginning of
the RM process, a subset of changes (sometimes also referred
to as requirements) is selected as the scope of the release [9].
Besides the development and implementation of the release,
RM also covers the estimation of effort and the resource
management needed for planning, design and implementation
of releases. In information technology, RM is well-established.
The transfer to “hardware” products is still subject of research,
cf. [10].
Design for maintainability (DfM) comprises the considera-
tion of aspects regarding for instance serviceability, repairabil-
ity or supportability, minimizing the effort during the use phase
of the system to keep it in - or to restore it to - a usable
condition [11]. According to the IEEE Standard Glossary of
Software Engineering Terminology, maintainability is deﬁned
as “the ease with which a software system or component
can be modiﬁed to correct faults, improve performance or
other attributes, or adapt to a changed environment” [12].
DfM is closely linked with the modularity of products whose
foundation is laid during the early design phases in form of
the product’s architecture [13].
There is a lot of research dealing with effort estimation in
software changes, design of maintainable software systems and
processes and methods for software engineering. Regarding
software changes, in the last years more and more approaches
were made in feature-oriented software evolution and changes.
[14] proposes a feature-based software evolution with auto-
matic traceability, analysis and recommendations. Passos et.
al assume that managing changes at the level of features can
help system designers in estimating costs and efforts while
having a better understanding of the impacts of a change on
the system.
Ferreira et. al [15] studied whether feature-oriented pro-
gramming really beneﬁts variety management in software
product lines (SPL). They argue feature-oriented programming
is indeed well suited for software product lines but still has
drawbacks. The SPL tends to be more stable under cer-
tain aspects with feature-oriented programming. Nevertheless,
feature-based software evolution does not have a general
answer how new features can be integrated into whole systems
dealing with both hardware and software.
The difﬁculty of the considered mechatronic systems and
their updates are the deep interaction of hardware and software
components. The software is built with a speciﬁc hardware
concept in mind and vice versa. To our current knowledge
there is no model or paradigm to generally address the problem
of modeling a complex system to identify required adaptations
for upgrade of functionalities. As a ﬁrst step towards a better
understanding and basis for our further research, in the fol-
lowing section we propose a formalism to describe integrated
function updates of existing mechatronic systems. Based on
the formalism, we identify further research needs.
III. DEFINITIONS
To give an idea on how we are tackling the mentioned
questions, we formalize the concepts of product variants,
hardware and software components as well as functions.
Without loss of generality, we term hardware and software
components simply as components and formalize them with
the same deﬁnition. Later, a distinction between hardware and
software components might become necessary. But for now,
we are interested in the general idea of including new functions
through new components whether hardware or software into
existing products.
First, we deﬁne that every product variant consists of a
restricted number of software and hardware components
kij with i is the identity and j is the development version
of component k. Furthermore, with regard to a development
process we denote kij−1 as the predecessor version of
component kij and kij+1 the successor version of component
kij. So, we deﬁne the set of all usable components as
K = {kij} with i, j ∈ N
We deﬁne a product variant as
pn := (Km, vm := Km × Km) with n, m ∈ N
and the set of all possible product variants as
P := {pn} with n ∈ N
This highlights that every product variant pi ∈ P consists of
a subset of all usable components Km ⊆ K and a struc-
ture vm. vm describes the connections between the different
65
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-532-6
ADAPTIVE 2017 : The Ninth International Conference on Adaptive and Self-Adaptive Systems and Applications

components Km to form a fully functional system. We do
not differentiate the connections between components of a
product variant. In case of a connection between two software
components, it might be an interface usage. The connection
between two hardware components might be a physical link
while the connection between hardware and software are, e.g.,
signals.
Every product variant pn is developed with the objective
to fulﬁll a pre-deﬁned set of functions taking into account
speciﬁc requirements. The set of all possible functions can
be deﬁned as
F = {fn} with n ∈ N
The function set Fq ⊆ F denotes a subset of all possible
functions. If a function set Fq is fulﬁlled by a product variant
pn we denote this as a satisﬁability relation
Fq |= pn
In the next section, we show our formalized approach to the
problem described in the introduction.
IV. A FORMALIZED APPROACH
If products are developed as product lines, we expect that
a previous product variant pold exists. pold fulﬁlls a known
set of functions Fold. Additionally, a new product variant
pnew exists, which fulﬁlls Fnew. In the proposed notation,
we write Fold |= pold and Fnew |= pnew. We now formalize
our question whether pold may be upgraded to fulﬁll the
new function set Fnew of our new product. Moreover, which
changes in pold are necessary to be able to fulﬁll the functions
Fnew completely or with limitations. We assume that a product
variant called p′
old derived from pold exists and fulﬁlls the set
of functions Fnew from pnew - that is Fnew |= p′
old. We deﬁne
the product variant p′
old as
p′
old := ({Km}, vm : Km × Km)
with ∀kxa ∈ Π1(pnew)∃kxb ∈ Π1(p′
old)
With other words, we are looking for a product variant, which
contains for every component identity ki in version a from
pnew a corresponding component identity ki in version b.
Figure 2 shows the construction of the updated product based
on the old and new product. The upper two product variants
are the old product pold, which will be updated and the new
product pnew with a new functionality. There are components
from pold, which are kept in p′
old. Those are components
not touched by the update (blue) and components, which are
equal to the ones used in pnew and, therefore, kept (gray).
Components existing in different version in pold and pnew
are updated (violet). Also, in pold there are components that
are removed in p′
old (red). Additional components for the new
functionality in pnew are added to p′
old (green). The bottom
product variant shows a possible outcome of the updated pold,
our p′
old.
Coming back to our initial question, we want to ﬁnd a
way to determine whether a new function can be integrated
Fig. 2. Illustration of the construction of an updated product based on pold
and pnew.
into an old product and which changes to the old product
are necessary. On basis of our formalization, we can now
formulate essential questions regarding the necessary changes
between pold and p′
old and the changes’ relation to pnew.
1) Which components of pnew are already included in pold
and, therefore, do not need to be changed in p′
old?
This questions asks for components in pnew, which were
already used in the same version in pold. Therefore, we do
not need to change pold regarding these components and p′
old
remains unchanged. In Figure 2 these are the components with
gray background.
2) Which components of pnew are not included in pold and,
therefore, have to be added to p′
old?
This question asks for components introduced with the new
functions in pnew. These components cannot be part of pold
and, therefore, have to be added to p′
old to fulﬁll the new
functions. In Figure 2 these are components with green back-
ground.
3) Which components kia of pnew are included in pold but
in a different version b and which version is included in
p′
old?
This question asks for component identities, which are used
both in pold and pnew but in different versions. In other
words, the component used in pnew is either the predecessor
or successor of the component used in pold. The question
is, which of these version will be included in the updated
product p′
old. In Figure 2 these are the components with violet
background.
66
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-532-6
ADAPTIVE 2017 : The Ninth International Conference on Adaptive and Self-Adaptive Systems and Applications

4) Which component identities from pold are not included
in pnew but in p′
old?
This question asks for the components in pold that are not
touched by the update. These components are not involved in
the new or any associated functions. In Figure 2 these are the
components with blue background.
5) Are there any components in p′
old, which are neither
included in pnew nor pold?
This question asks for components that were introduced in p′
old
as a kind of adapter for components from pnew. In other words,
the necessary components from pnew could not be added to
p′
old because of an incompatible interface. However, an adapter
component could resolve this incompatibility. In Figure 2 this
is the glue component with green background in p′
old.
To tackle these questions we are convinced that a new
modeling and engineering approach for complex systems
has to be developed. Moreover, even after integrating and
developing new components to construct a p′
old from pold and
pnew, it is not obvious that the new product will work like
expected. Usually, after the integration of a new function, the
entire system has to be retested and veriﬁed to guarantee that
no unexpected side effects can occur. This includes testing
functions without direct interactions with the new one because
most side effects occur indirectly.
Naturally, it is not possible to fully test and verify already
developed products in the ﬁeld. Testing is a very time and
cost consuming task, which is even harder to accomplish for
older products that no longer have a development team. So,
it is preferable that we don’t need to test and verify the
whole product with all its functions again. Instead, it would be
preferable to just focus on parts of p′
old, which have changed
in comparison to pold.
We ask the question, whether it is possible to achieve
much more simple retests for the new functions with the test
results and data and control ﬂows of pold and pnew and the
changes made to construct p′
old. We are convinced that these
informations enable us to slice the architecture of p′
old in such
a way that only new functions and some of their dependencies
to components from pold need to be retested.
V. CONCLUSION
We have presented the current mismatch between techni-
cal life time and the actual use period of modern products
and highlighted the need for an integrated functional update
approach for mechatronic systems. One of the main reasons
for customers to replace a product, are extended function-
alities implemented in newer product generations. In order
to address this challenge, a common concept is to provide
updates for existing products. Due to complex dependencies
between software and hardware components, it is not an easy
task to come up with these integral updates. Therefore, it is
essential to understand the interrelations between the different
components as well as the functions and components. We have
shown that a critical improvement has to be made regarding
modeling approaches for complex systems, addressing both
the structure of the system as well as the functional view
upon the system. While there exist methods to design both
mere software and hardware systems for maintainability, the
interaction of both domains in complex mechatronic systems
asks for new approaches.
The formalization introduced will be used as a starting point
for further research. The next research steps will be to develop
an integrated modeling language for requirements, structures
and components in mechatronic systems. This modeling lan-
guage will be designed with the goal to identify needs for
adaptation in case of functional upgrades. Another step will
be the development of a method to evaluate effort of integral
updates.
Our last research question is how to minimize the necessary
test cases when a product was updated. Based on slicing
techniques we want to reuse the results of formerly done
tests to reduce the necessary retests when a product was only
slightly changed.
REFERENCES
[1] K. Ishii, “Incorporating end-of-life strategies in product deﬁnition,” Proc.
of EcoDesign’99, pp. 364–369, 1999.
[2] Y. Umeda, T. Daimon, and S. Kondoh, “Life cycle option selection
based on the difference of value and physical lifetimes for life cycle
design,” Proc. of the International Conference on Engineering Design,
ICED 2007, 2007.
[3] K. Watanabe, Y. Shimomura, A. Matsuda, S. Kondoh, and Y. Umeda,
“Upgrade planning for upgradeable product design,” in Quantiﬁed Eco-
Efﬁciency.
Springer, 2007, pp. 261–281.
[4] “Directive 2009/125/ec of the european parliament and the council of
21 october 2009 establishing a framework for setting of ecodesign
requirements for energy-related products,” 2009.
[5] E. Fricke and A. P. Schulz, “Design for changeability (dfc): Principles to
enable changes in systems throughout their entire lifecycle,” in Systems
Engineering, Vol. 8, No. 4, 2005, 2005, pp. 342–359.
[6] A. Bischof, “Developing ﬂexible products for changing environments,”
Dissertation, Technische Universit¨at Berlin, 2010.
[7] K. Ulrich and S. Eppinger, Product Design and Development.
New
York: McGraw-Hill, 1995.
[8] “IEEE standard - adotion of the ISO/IEC 20000-2:2012, information
technology - service management - part 2: Guidance on the application
of service management systems,” 2013.
[9] P. Carlshamre, “Release planning in market-driven software product
development: Provoking an understanding,” Requirements engineering,
vol. 7, no. 3, pp. 139–151, 2002.
[10] G. Schuh and W. Eversheim, “Release-engineeringan approach to con-
trol rising system-complexity,” CIRP Annals-Manufacturing Technology,
vol. 53, no. 1, pp. 167–170, 2004.
[11] R. F. Stapelberg, Handbook of reliability, availability, maintainability
and safety in engineering design.
Springer Science & Business Media,
2009.
[12] “IEEE standard glossary of software engineering terminology,” 1990.
[13] G. Schuh, S. Aleksic, and S. Rudolfs, “Module-based release manage-
ment for technical changes,” in Progress in Systems Engineering: Proc.
of the twenty-third International Conference on Systems Engineering,
2015, pp. 293–298.
[14] L. Passos, K. Czarnecki, S. Apel, A. Wasowski, C. K¨astner, and J. Guo,
“Feature-oriented software evolution,” in Proceedings of the Seventh
International Workshop on Variability Modelling of Software-intensive
Systems.
ACM, 2013, p. 17.
[15] G. C. S. Ferreira, F. N. Gaia, E. Figueiredo, and M. de Almeida Maia,
“On the use of feature-oriented programming for evolving software
product linesa comparative study,” Science of Computer Programming,
vol. 93, pp. 65–85, 2014.
67
Copyright (c) IARIA, 2017.     ISBN:  978-1-61208-532-6
ADAPTIVE 2017 : The Ninth International Conference on Adaptive and Self-Adaptive Systems and Applications

