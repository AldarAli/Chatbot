Quasigroup Redundancy Check Codes For Safety-Critical Systems
Nataˇsa Ilievska
Faculty of Computer Science and Engeneering
Ss. Cyril and Methodius University
Skopje, Republic of Macedonia
e-mail: natasa.ilievska@finki.ukim.mk
Danilo Gligoroski
Department of Telematics
Norwegian University of Science and Technology
Trondheim, Norway
e-mail: danilog@item.ntnu.no
Abstract—We deﬁne error-detecting codes based on linear quasi-
groups. We prove that the probability of undetected errors
of the deﬁned codes, does not depend on the distribution of
the characters in the input message. Next we calculate the
probability of undetected errors and identify the best class of
linear quasigroups of order 8 for these codes. Also, we explain
how the probability of undetected errors can be controlled. At
the end, we compare these codes with several CRC codes and
conclude that our code has smaller probability of undetected
errors than the CRC codes when code rate and block lengths are
equal.
Keywords–error-detecting
codes;
CRC;
linear
quasigroups;
Safety-Critical Systems.
I.
INTRODUCTION
A Cyclic Redundancy Check (CRC) is one of the most fre-
quent mechanisms for error detection used in communication
networks and storage devices. The idea presented ﬁrst in 1961
in the work of Peterson and Brown [1] is for every block of
data to produce a short check value attached to it. That check
value is computed by an algorithm based on cyclic codes.
Very soon after their introduction, CRCs became very
popular in communication and computer industry due to their
mathematical simplicity and their properties to be implemented
easily both in hardware and in software. Many variants of
cyclic redundancy check codes have been proposed and stan-
dardized such as: CRC-8 [2], CRC-8-WCDMA (Wideband
Code Division Multiple Access) [3], CRC-12 [4], CRC-
ANSI (American National Standards Institute) [19], CRC-
CCITT (Comit´e Consultatif Internationale T´el´egraphique et
T´el´ephonique) [20], CRC-32 [6], CRC-64-ISO (International
Organization for Standardization) [7], and many others.
Additionally, many other alternatives not based on cyclic
codes have been proposed such as: Fletcher-16, Fletcher-32,
Fletcher-64 [8][9] and Adler-32 [10].
Beside their typical use in digital networks, CRC codes (or
their similar replacements) have been frequently used in so-
called Safety-Critical Systems [11][21] that involves process
control where toxic, ﬂammable or explosive materials are
used, in transportation systems such as railways, avionics and
automotive systems and in nuclear power stations.
The motivation and justiﬁcation of our work in this paper
is closely connected with construction of redundancy check
codes that will be more suitable in some use-case scenarios for
those Safety-Critical Systems. This means that, while in some
properties (such as the rate of the code) our codes are not that
good as CRC codes, from the perspective of the probability
to detect errors, our codes outperform CRCs by one or two
orders of magnitude.
The paper is organized as follows. In Section II, we present
the mathematical preliminaries to describe our codes. In par-
ticular it brieﬂy deﬁnes the algebraic structures of quasigroups
and linear quasigroups. In Secttion III, we describe our Linear
Quasigroup Redundancy Check Codes and in Section IV,
we thoroughly analyse the probability of undetected errors
with our codes. In Section V, we identify a class of linear
quasigroups of order 8 that give the best probabilities for
error detections. In Section VI, we compare the error detection
probability of our codes with three other CRC codes and we
conclude the paper in Section VII.
II.
MATHEMATICAL PRELIMINARIES
Previous work with error-detecting codes based on quasi-
groups found that the best results are obtainned with linear
quasigroups [12][15].
Deﬁnition 1: Quasigroup is algebraic structure (Q, ∗) such
that
(∀u, v ∈ Q)(∃!x, y ∈ Q) (x ∗ u = v & u ∗ y = v)
(1)
Deﬁnition 2: The quasigroup (Q, ∗) of order 2q is linear if
there are non-singular binary matrices A and B of order q ×q
and a binary matrix C of order 1 × q, such that
(∀x, y ∈ Q) x ∗ y = z ⇔ z = xA + yB + C
(2)
where x, y and z are binary representations of x, y and z as
vectors of order 1 × q and + is binary addition.
When Q is a quasigroup of order 2q, then we take that
Q = {0, 1, ..., 2q − 1}.
Example 1: One linear quasigroup of order 8 is deﬁned
with the following non-singular binary matrices
A =
" 1
0
1
0
0
1
1
1
1
#
and
B =
" 1
1
1
0
1
0
0
1
1
#
and the matrix C = [0 0 0]. In order to calculate 5 ∗ 6, for
example, ﬁrst we turn 5 and 6 into binary form. Thus, 5 =
[1 0 1], 6 = [1 1 0] and substitute them in (2). We calculate
[1 0 1]A + [1 1 0]B + [0 0 0] = [1 1 1]
Now, [1 1 1] turned into decimal form is 7 so 5 ∗ 6 = 7. In
the same manner we calculate all other products and obtain
the following linear quasigroup:
72
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-411-4
AICT 2015 : The Eleventh Advanced International Conference on Telecommunications

∗
0 1 2 3 4 5 6 7
0
0 3 2 1 7 4 5 6
1
7 4 5 6 0 3 2 1
2
1 2 3 0 6 5 4 7
3
6 5 4 7 1 2 3 0
4
5 6 7 4 2 1 0 3
5
2 1 0 3 5 6 7 4
6
4 7 6 5 3 0 1 2
7
3 0 1 2 4 7 6 5
Figure 1. Example of a linear quasigroup of order 8.
III.
LINEAR QUASIGROUP REDUNDANCY CHECK CODES
Let (Q, ∗) be linear quasigroup of order 2q and let
a0a1a2...an−1 be an input block of length n. The redundant
characters are deﬁned in the following way:
di = ai ∗ ai+1, i ∈ {0, 1, ..., n − 1}
(3)
where all operations in indexes are per modulo n. This
means that d0 = a0 ∗ a1, d1 = a1 ∗ a2, . . ., dn−2 =
an−2 ∗ an−1, dn−1 = an−1 ∗ a0. Now, the extended message
a0a1a2...an−1d0d1d2...dn−1, previously turned into binary
form, is transmitted through the binary symmetric channel.
A block of length n is extended into a block with length 2n,
from where it follows that the rate of the code is 1/2.
Under the inﬂuence of the noises in the channel, some of
the characters may not be correctly transmitted. After receiving
the block, the receiver checks if all equations (3) are satisﬁed.
If there is some i ∈ {0, 1, ..., n − 1} for which the equation
is not satisﬁed, the receiver concludes that there is an error
in transmission and it asks the sender to send the block
once again. But, since the redundant characters are transmitted
through the binary symmetric channel, it is possible that they
are incorrectly transmitted too, in a way that all equations
(3) are satisﬁed, although some of the information characters
a0, a1, ..., an−1 are incorrectly transmitted. For this reason, it
is possible to have undetected errors in transmission.
IV.
THE PROBABILITY OF UNDETECTED ERRORS
With P{i → j} we will denote the probability that i will
be transferred into j through the binary symmetric channel.
The following Lemma can be easily shown.
Lemma 1: For all binary vectors a, b i c, it is true that
P{a + b → c + b} = P{a → c}
where + is a binary addition on vectors.
Theorem 1: The probability of undetected errors for the
considered code is independent from the distribution of the
characters in the input message and form the matrix C.
Proof: Let us consider two disjoint strings of consecutive
characters, say aiai+1...ai+s, s ≥ 0 and ajaj+1...aj+r, r ≥ 0,
from the input message a0a1 . . . an−1, such that there is at
least one character between them, i.e., the two strings do not
form a string of consecutive characters. Note that the two
strings can have length one (if s = 0 or r = 0). Since,
there is at least one character between the two strings, they
act on different redundant characters: The string aiai+1...ai+s
acts on redundant characters di−1, di, di+1, ..., di+s while the
string ajaj+1...aj+r acts on dj−1, dj, dj+1, ..., dj+r and this
two sets of redundant characters are disjoint. For this reason,
the random events:
S : the string aiai+1...ai+s is incorrectly transmitted and the
error is not detected;
R : the string ajaj+1...aj+r is incorrectly transmitted and the
error is not detected;
are independent, from where it follows that P(QR)
=
P(Q)P(R). For this reason, the probability of undetected
errors will be function of the probabilities that r consecutive
characters of the input message are incorrectly transmitted
and the error is not detected. Therefore, in order to show
that the probability of undetected errors is independent from
the distribution of the characters in the input message and
from the matrix C, it is enough to show that the probability
that r consecutive characters of input message are incorrectly
transmitted and the error is not detected is independent from
the distribution of the characters in the input message and from
the matrix C, for arbitrary r.
For this purpose, we introduce the following random
events:
Ai : Exactly i consecutive characters from the input message
a0a1...an−1 are incorrectly transmitted and the error is not
detected, i = 1, 2, ..., n.
First, let calculate the probability P(A1), i.e., the prob-
ability that exactly one character (let say ai) is incorrectly
transmitted and the error is not detected.
Let Hj be the random event: the true value of ai is j,
j = 0, 1, 2, ..., 2q − 1.
Then, using the formula for total probability, we obtain:
P(A1) =
2q−1
X
j=0
P(A1|Hj)P(Hj)
(4)
P(A1|Hj) =
=
2q−1
P
k = 0
k ̸= j
P{ai → k}P{di−1 → ai−1 ∗ k}P{di → k ∗ ai+1}
=
2q−1
P
k = 0
k ̸= j
P{j → k}P{ai−1 ∗ j → ai−1 ∗ k}·
·P{j ∗ ai+1 → k ∗ ai+1}
=
2q−1
P
k = 0
k ̸= j
P{j → k}P{ai−1A + jB + C → ai−1A + kB + C}·
·P{jA + ai+1B + C → kA + ai+1B + C}
=
2q−1
P
k = 0
k ̸= j
P{j → k}P{jB → kB}P{jA → kA}
=
2q−1
P
k = 0
k ̸= j
P{0 → k + j}P{0 → (k + j)B}P{0 → (k + j)A}
(5)
In the last two equations in (5), Lemma 1 is used. We introduce
replacement l = k + j in the last expression of (5). Since j is
ﬁxed and k runs through all values from {0, 1, ..., 2q−1}\{j},
l will run through all values from {0, 1, ..., 2q − 1} \ {0} =
{1, ..., 2q − 1}:
P(A1|Hj) =
2q−1
P
l=1
P{0 → l}P{0 → lB}P{0 → lA},
∀j ∈ {0, 1, 2, ..., 2q − 1}
(6)
73
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-411-4
AICT 2015 : The Eleventh Advanced International Conference on Telecommunications

Form (4) and (6) it follows that
P(A1) =
2q−1
X
l=1
P{0 → l}P{0 → lB}P{0 → lA}
(7)
Equation (7) means that P(A1) is independent from the true
values of ai−1, ai and ai+1, i.e., it is independent from the
distribution of the characters in the input message. Also,
P(A1) does not depend on the matrix C.
Similarly, we derive a formula for P(A2) - the probability
that exactly two consecutive characters (let say ai and ai+1)
form the input message are incorrectly transmitted and the
error is not detected. We introduce the random events
Hjk : the true value of ai is j and the true value of ai+1 is k,
j, k = 0, 1, 2, ..., 2q − 1. Then,
P(A2) =
2q−1
X
j=0
2q−1
X
k=0
P(A2|Hjk)P(Hjk)
(8)
P(A2|Hjk) =
=
2q−1
P
l = 0
l ̸= j
2q−1
P
s = 0
s ̸= k
P{ai → l, ai+1 → s}P{di−1 → ai−1 ∗ l}·
·P{di → l ∗ s}P{di+1 → s ∗ ai+2}
=
2q−1
P
l = 0
l ̸= j
2q−1
P
s = 0
s ̸= k
P{j → l, k → s}P{ai−1 ∗ j → ai−1 ∗ l}·
·P{j ∗ k → l ∗ s}P{k ∗ ai+2 → s ∗ ai+2}
=
2q−1
P
l = 0
l ̸= j
2q−1
P
s = 0
s ̸= k
P{j → l}P{k → s}·
·P{ai−1A + jB + C → ai−1A + lB + C}·
·P{jA + kB + C → lA + sB + C}·
·P{kA + ai+2B + C → sA + ai+2B + C}
=
2q−1
P
l = 0
l ̸= j
2q−1
P
s = 0
s ̸= k
P{j → l}P{k → s}P{jB → lB}·
·P{jA + kB → lA + sB}P{kA → sA} =
=
2q−1
P
l = 0
l ̸= j
2q−1
P
s = 0
s ̸= k
P{0 → l + j}P{0 → s + k}·
·P{0 → (l + j)B}·
·P{0 → (l + j)A + (s + k)B}·
·P{0 → (s + k)A}
(9)
We introduce replacement: t = l+j and r = s+k in the last
expression of (9). When l gets all values from Q \ {j}, t will
get all values from Q \ {0}. Similarly, when s gets all values
from Q \ {k}, r will get all values from Q \ {0}. We obtain:
P(A2|Hjk) =
2q−1
P
t=1
2q−1
P
r=1
P{0 → t}P{0 → r}P{0 → tB}P{0 → tA + rB}·
·P{0 → rA}, ∀j, k ∈ {0, 1, ..., 2q − 1}
(10)
Using (8) and (10) we derive that:
P(A2) =
2q−1
P
t=1
2q−1
P
r=1
P{0 → t}P{0 → r}P{0 → tB}·
·P{0 → tA + rB}P{0 → rA}
(11)
From (11) we see that P(A2) is independent from the true
values of ai−1, ai, ai+1 and ai+2 , i.e., it is independent
form the distribution of the characters in the input message.
Obviously, P(A2) does not depend on the matrix C, too.
In general, to derive formula for P(Ar) - the probability
that exactly r consecutive characters ai, ai+1, ...ai+r−1 from
the input message are incorrectly transmitted and the error is
not detected, we introduce random evens
Hj0j1...jr−1 : the true value of ai is j0, the true value of ai+1
is j1, the true value of ai+2 is j2,..., the true value of ai+r−1
is jr−1, where j0, j1, ..., jr−1 ∈ {0, 1, ..., 2q − 1}.
Now,
P (Ar) =
2q−1
X
j0=0
2q−1
X
j1=0
...
2q−1
X
jr−1=0
P (Ar|Hj0j1...jr−1)P (Hj0j1...jr−1)
(12)
P (Ar|Hj0j1...jr−1) =
2q−1
X
s0 = 0
s0 ̸= j0
2q−1
X
s1 = 0
s1 ̸= j1
...
2q−1
X
sr−1 = 0
sr−1 ̸= jr−1
B
sr−1
s0
(13)
where in a same way as (9) we obtain:
B
sr−1
s0
= P {0 → s0 + j0}P {0 → s1 + j1}P {0 → s2 + j2} · ...·
·P {0 → sr−1 + jr−1}P {0 → (s0 + j0)B}·
·P {0 → (s0 + j0)A + (s1 + j1)B}·
·P {0 → (s1 + j1)A + (s2 + j2)B} · ...·
·P {0 → (sr−2 + jr−2)A + (sr−1 + jr−1)B}·
·P {0 → (sr−1 + jr−1)A}
(14)
By introducing replacement tu = su+ju, u = 0, 1, 2, ..., r−1
in the expression (14) and replacing it in (13), we get:
P (Ar|Hj0j1...jr−1) =
2q−1
P
t0=1
2q−1
P
t1=1
...
2q−1
P
tr−1=1
P {0 → t0}·
·P {0 → t1}P {0 → t2} · ...·
·P {0 → tr−2}P {0 → tr−1}·
·P {0 → t0B}P {0 → t0A + t1B}·
·P {0 → t1A + t2B} · ...·
·P {0 → tr−2A + tr−1B}·
·P {0 → tr−1A}
(15)
From (12) and (15), we derive
P (Ar) =
2q−1
P
t0=1
2q−1
P
t1=1
...
2q−1
P
tr−1=1
P {0 → t0}·
·P {0 → t1}P {0 → t2} · ...·
·P {0 → tr−2}P {0 → tr−1}·
·P {0 → t0B}P {0 → t0A + t1B}·
·P {0 → t1A + t2B} · ...·
·P {0 → tr−2A + tr−1B}·
·P {0 → tr−1A}
(16)
This means that P(Ar) is independent from the distribution
of the characters in the input message and from the matrix C.
Thus, the theorem is proven.
Using the fact that the probability of undetected errors is
independent from the distribution of the characters in the input
message the following theorem holds (proved in [16]):
Theorem 2: Let f(n, p) be the probability that at most 4
characters of the input message with length n are incorrectly
transmitted through a binary symmetric channel with prob-
ability of bit-error p and the error is not detected. If linear
74
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-411-4
AICT 2015 : The Eleventh Advanced International Conference on Telecommunications

quasigroup of order 2q is used for the code deﬁned with (3)
then
f(2, p)
=
2v0v1 + r2
f(3, p)
=
3v3
0v1 + 3v0v2 + r3
f(4, p)
=
4v5
0v1 + 4v3
0v2 + 2v2
0v2
1 + 4v0v3 + r4
f(n, p)
=
nv1v2n−3
0
+ nv2v2n−5
0
+ n(n − 3)
2
v2
1v2n−6
0
+nv3v2n−7
0
+ n(n − 4)v2v1v2n−8
0
+ n(n − 4)(n − 5)
6
v3
1v2n−9
0
+ nv4v2n−9
0
+n(n − 5)v3v1v2n−10
0
+ n(n − 5)
2
v2
2v2n−10
0
+ n(n − 5)(n − 6)
2
v2v2
1v2n−11
0
+ n(n − 5)(n − 6)(n − 7)
24
v4
1v2n−12
0
, n ≥ 5
(17)
In the formulas, we use the following notations:
vt - the probability of undetected errors when exactly t
consecutive characters of the initial message a0a1 . . . an−1
are incorrectly transmitted (the characters ai, ai+1, . . . , ai+t−1
are incorrectly transmitted, but ai−1 and ai+t are correctly
transmitted), t = 1, 2, 3, 4;
v0 - the probability of correct transmission of a character;
rt - the probability of undetected errors in a block with length
t when all t characters are incorrectly transmitted, t = 2, 3, 4.
Although the Theorem 2 in [16] is formulated for fractal
quasigroups of order 4, from the proof it can be seen that it
holds if for coding is used quasigroup of arbitrary order for
which the probability of undetected errors is independent from
the distribution of the characters in the input message.
The formula (17) gives us an approximate formula for
the probability of undetected errors. Namely, the probability
that 5 or more characters of the input message are incorrectly
transmitted and the error is not detected is inconsiderably small
for small values of a bit-error p. For this reason and the fact
that in the real channels the probability of bit-error p is very
small, the formula f(n, p) given with (17) gives a good enough
approximation of the probability of undetected errors.
The parameters vt in Theorem 2 are practically P(At)
from the proof of Theorem 1. The parameters r2, r3 and
r4 occur for the following reason. Let say that the two
consecutive characters a0 and a1 are incorrectly transmitted.
The information character a0 affects the redundant characters
dn−1 and d0, while a1 affects d0 and d1. If the block length is
greater then or equal to 3, then a0 and a1 have one common
redundant characters and both of them affect d0. But if the
block length is equal to 2, then the characters a0 and a1 have
two common redundant characters that are affected: d0 and d1.
For this reason, the probability that two consecutive characters
are incorrectly transmitted and the error is not detected for the
blocks with length two is different than the probability for the
blocks with length greater than two. Therefore, this case should
be considered separately from the general one, and requesting
the parameter r2 to be introduced. A similar situation is for
r3 and r4. The formulas for these parameters are obtained
analogously to the formulas for vt:
r2 =
2q−1
P
t=1
2q−1
P
r=1
P{0 → t}P{0 → r}P{0 → tA + rB}·
·P{0 → rA + tB}
(18)
r3 =
2q−1
P
t=1
2q−1
P
r=1
2q−1
P
s=1
P{0 → t}P{0 → r}P{0 → s}·
·P{0 → tA + rB}P{0 → rA + sB}·
·P{0 → sA + tB}
(19)
r4 =
2q−1
P
t=1
2q−1
P
r=1
2q−1
P
s=1
2q−1
P
h=1
P{0 → t}P{0 → r}P{0 → s}·
·P{0 → h}P{0 → tA + rB}·
·P{0 → rA + sB}P{0 → sA + hB}·
·P{0 → hA + tB}
(20)
In order to calculate the probability of undetected errors for
a given linear quasigroup, one should ﬁrst calculate the values
of the parameters, using (16), (18), (19) and (20), and then to
substitute these values into (17).
V.
RESULTS WITH LINEAR QUASIGROUPS OF ORDER 8
A. The Smallest Probability of Undetected Errors
The values of vt depend on matrices A and B (see
(16)), from where it follows that they depend on the chosen
quasigoup for coding. Since the probability of undetected
errors depends on vt, it follows that this probability depends
on the chosen quasigroup for coding. It is best the probability
of undetected errors to be as small as possible. For this reason,
we applied the formula (17) on each pair (A, B) of non-
singular binary matrices of order 3 and found that the smallest
probability of undetected errors is the following:
f(2, p)
=
(1 − p)2p3(4 − 20p + 56p2 − 96p3 + 96p4
−55p5 + 22p6 − 3p7)
f(3, p)
=
(1 − p)3p3(3 − 30p + 162p2 − 580p3 + 1470p4
−2658p5 + 3394p6 − 3024p7 + 1866p8 − 787p9
+213p10 − 27p11 + p12)
f(4, p)
=
(1 − p)4p4(8 − 88p + 404p2 − 784p3 − 808p4
+9440p5 − 29720p6 + 57432p7 − 77044p8
+74352p9 − 51892p10 + 25960p11 − 9179p12
+2268p13 − 378p14 + 44p15 − 3p16)
f(n, p)
=
1
24np4(1 − p)6(n−4) ×
h
24 − 384p + 2832p2
−12384p3 + 12(n + 2807)p4 − 48(2n + 1009)p5
+48(6n − 499)p6 + 326976p7 + 4(n2 − 603n
−239092)p8 + 48(144n + 37283)p9 − 24(n2
+271n + 102896)p10 + 24(5n2 − 455n
+110576)p11 + (n3 + 78n2 + 39863n
−2273238)p12 + 8(n3 − 96n2 − 6943n
+194358)p13 + 4(5n3 − 16n2 + 13801n
−213770)p14 + 8(n3 + 99n2 − 4924n + 46854)p15
−2(13n3 + 420n2 − 10207n + 64386)p16
−8(n3 − 86n2 + 1007n − 4234)p17 + 4(5n3
−90n2 + 583n − 1626)p18 − 8(n3 − 12n2 + 53n
−102)p19 + (n3 − 10n2 + 35n − 50)p20i
, n ≥ 5
(21)
The graphic of this function, for different values of the
block length n is given in Figure 2.
B. Controlling the Error
As we can see from Figure 2, when the block length
increases the probability of undetected errors decreases and
the sequence of maximums converges to zero. This means that
there is some natural number n0, such that the maximum of
f(n, p) will be smaller than ε for all natural numbers n that
are greater than or equal to n0 and the maximum of f(n, p)
will be greater than ε for all natural numbers n that are smaller
than n0. So, if we want the probability of undetected errors to
be smaller than some previous given value ε, we will choose
75
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-411-4
AICT 2015 : The Eleventh Advanced International Conference on Telecommunications

the block length n to be the smallest natural number such that
the maximum of the function f(n, p) is smaller than ε (i.e.,
n = n0). Since the maximum of f(n, p) will be smaller than
ε, follows that f(n, p) will be smaller than ε for all values of
p ∈ (0, 1
2). We choose n to be the smallest natural number for
which the maximum of the function f(n, p) is smaller than ε
since we want if there are errors in transmission the smallest
possible blocks to be retransmitted.
0.05
0.1
0.15
0.2
0.25
0.3 p
5·10-6
0.00001
0.000015
0.00002
0.000025
0.00003
0.000035
f@n, pD
f@6,pD f@7,pD f@8,pD f@9,pD f@10,pDf@11,pDf@12,pD
Figure 2. The smallest probability of undetected errors for different values
of the block length n if for coding are used quasigroups of order 8.
C. The Best Class of Linear Quasigroups of Order 8
We deﬁne the best class of linear quasigroups of order 8
to be the class that contains exactly those linear quasigroups
of order 8 that achieve the smallest probability of undetected
errors, i.e., the probability given with (21). The quasigroups
from this class are best for coding.
We obtained that the best class contains the quasigroups
for which the matrix A contains exactly two zeros and the
matrix B is determined by the matrix A in the following
way. For each non-singular binary matrix A of order 3 with
exactly 2 zeros, there are two possible choices for the matrix
B: one in which the rows of A are cyclically shifted one
position up, and the other in which the rows of A are cyclically
shifted two positions up. Namely, if A =
"
a11
a12
a13
a21
a22
a23
a31
a32
a33
#
is non-singular binary matrix with exactly two zeros, than this
matrix A determine two quasigroups of order 8 which have
the smallest probability of undetected errors. One of them
is obtained when B =
"
a21
a22
a23
a31
a32
a33
a11
a12
a13
#
and the other is
obtained when B =
"
a31
a32
a33
a11
a12
a13
a21
a22
a23
#
.
There are 18 binary non-singular matrices with two zeros
that can be chosen for the matrix A and for each one of them
there are two possible choice for the matrix B. Therefore,
there are 36 pairs of non-singular binary matrices (A, B)
which give the smallest probability of undetected errors. These
quasigroups are given below. Since for every of these 36
pairs of matrices (A, B), any of the eight binary matrices of
order 1 × 3 may be chosen as matrix C, there are 288 linear
quasigroups of order 8 in the best class of linear quasigroups
of order 8.
The 36 pairs of non-singular binary matrices (A, B) in the
best class are given in Figure 3.
A
B
h
1
0
1
0
1
1
1
1
1
ih
0
1
1
1
1
1
1
0
1
i
A
B
h
1
0
1
0
1
1
1
1
1
ih
1
1
1
1
0
1
0
1
1
i
h
1
0
1
1
1
1
0
1
1
ih
1
1
1
0
1
1
1
0
1
i
h
1
0
1
1
1
1
0
1
1
ih
0
1
1
1
0
1
1
1
1
i
h
1
1
0
0
1
1
1
1
1
ih
0
1
1
1
1
1
1
1
0
i
h
1
1
0
0
1
1
1
1
1
ih
1
1
1
1
1
0
0
1
1
i
h
1
1
0
1
1
1
0
1
1
ih
1
1
1
0
1
1
1
1
0
i
h
1
1
0
1
1
1
0
1
1
ih
0
1
1
1
1
0
1
1
1
i
h
1
1
1
0
1
1
1
0
1
ih
0
1
1
1
0
1
1
1
1
i
h
1
1
1
0
1
1
1
0
1
ih
1
0
1
1
1
1
0
1
1
i
h
1
1
1
0
1
1
1
1
0
ih
0
1
1
1
1
0
1
1
1
i
h
1
1
1
0
1
1
1
1
0
ih
1
1
0
1
1
1
0
1
1
i
h
1
1
1
1
0
1
0
1
1
ih
1
0
1
0
1
1
1
1
1
i
h
1
1
1
1
0
1
0
1
1
ih
0
1
1
1
1
1
1
0
1
i
h
1
1
1
1
1
0
0
1
1
ih
1
1
0
0
1
1
1
1
1
i
h
1
1
1
1
1
0
0
1
1
ih
0
1
1
1
1
1
1
1
0
i
h
0
1
1
1
0
1
1
1
1
ih
1
0
1
1
1
1
0
1
1
i
h
0
1
1
1
0
1
1
1
1
ih
1
1
1
0
1
1
1
0
1
i
h
0
1
1
1
1
1
1
0
1
ih
1
1
1
1
0
1
0
1
1
i
h
0
1
1
1
1
1
1
0
1
ih
1
0
1
0
1
1
1
1
1
i
h
1
1
0
1
0
1
1
1
1
ih
1
0
1
1
1
1
1
1
0
i
h
1
1
0
1
0
1
1
1
1
ih
1
1
1
1
1
0
1
0
1
i
h
1
1
0
1
1
1
1
0
1
ih
1
1
1
1
0
1
1
1
0
i
h
1
1
0
1
1
1
1
0
1
ih
1
0
1
1
1
0
1
1
1
i
h
1
1
1
1
0
1
1
1
0
ih
1
0
1
1
1
0
1
1
1
i
h
1
1
1
1
0
1
1
1
0
ih
1
1
0
1
1
1
1
0
1
i
h
1
1
1
1
1
0
1
0
1
ih
1
1
0
1
0
1
1
1
1
i
h
1
1
1
1
1
0
1
0
1
ih
1
0
1
1
1
1
1
1
0
i
h
0
1
1
1
1
1
1
1
0
ih
1
1
1
1
1
0
0
1
1
i
h
0
1
1
1
1
1
1
1
0
ih
1
1
0
0
1
1
1
1
1
i
h
1
0
1
1
1
1
1
1
0
ih
1
1
1
1
1
0
1
0
1
i
h
1
0
1
1
1
1
1
1
0
ih
1
1
0
1
0
1
1
1
1
i
h
0
1
1
1
1
0
1
1
1
ih
1
1
0
1
1
1
0
1
1
i
h
0
1
1
1
1
0
1
1
1
ih
1
1
1
0
1
1
1
1
0
i
h
1
0
1
1
1
0
1
1
1
ih
1
1
0
1
1
1
1
0
1
i
h
1
0
1
1
1
0
1
1
1
ih
1
1
1
1
0
1
1
1
0
i
Figure 3. The best class of linear quasigroups of order 8.
VI.
COMPARISON WITH THE CRC CODES
We give a comparison of our codes with some CRC codes.
The comparison is made from the aspect of the probability
of undetected errors. Ability of the CRC code to detect errors
depends on the chosen polynomial for coding. We will consider
several cases of polynomials, accepted as a standard for coding.
Namely, we will consider CRC-12 deﬁned with the polynomial
g(x) = x12+x11+x3+x2+x+1 [4], CRC-ANSI deﬁned with
g(x) = x16 + x15 + x2 + x + 1 [19] and CRC-CCITT deﬁned
with g(x) = x16 + x12 + x5 + 1 [20]. Unlike our code, CRC
code adds constant number of redundant characters, regardless
of the length of the information block. CRC-12 adds 12 bits,
while CRC-ANSI and CRC-CCITT add 16 bits. In Table I
the maximums of the probabilities of undetected errors for
our code and CRC-12 code are given, while in Table II the
maximums of the probabilities of undetected errors for our
code, CRC-ANSI and CRC-CCITT codes for different values
of the block length n are given. The values for CRC codes are
taken from [18]. The block length is expressed in bits. We can
see that our code has smaller probability of undetected errors
than CRC-12 for all values of block length n which are greater
than or equal to 12. For n greater than or equal to 15, our code
has smaller probability of undetected errors than all considered
76
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-411-4
AICT 2015 : The Eleventh Advanced International Conference on Telecommunications

TABLE I. THE MAXIMUMS OF THE PROBABILITY OF UNDETECTED
ERRORS FOR OUR CODE AND CRC-12. THE BLOCK LENGTH n IS
EXPRESSED IN BITS
n
Our code
CRC-12
6
1.53809 × 10−2
4.98239 × 10−4
9
1.94931 × 10−3
4.44429 × 10−4
12
2.72046 × 10−4
4.92904 × 10−4
15
7.22452 × 10−5
5.32493 × 10−4
18
3.48346 × 10−5
5.24102 × 10−4
21
1.94926 × 10−5
5.01021 × 10−4
24
1.20057 × 10−5
4.95408 × 10−4
27
7.91486 × 10−6
4.68967 × 10−4
30
5.49112 × 10−6
4.36575 × 10−4
33
3.96425 × 10−6
4.13106 × 10−4
36
2.95482 × 10−6
3.98553 × 10−4
39
2.26092 × 10−6
3.84785 × 10−4
42
1.76831 × 10−6
3.68207 × 10−4
45
1.40897 × 10−6
3.53279 × 10−4
48
1.14074 × 10−6
3.40974 × 10−4
TABLE II. THE MAXIMUMS OF THE PROBABILITY OF UNDETECTED
ERRORS FOR OUR CODE, CRC-ANSI AND CRC-CCITT. THE
BLOCK LENGTH n IS EXPRESSED IN BITS
n
Our code
CRC-ANSI
CRC-CCITT
6
1.53809 × 10−2
2.09564 × 10−4
1.82571 × 10−4
9
1.94931 × 10−3
1.83062 × 10−4
1.59587 × 10−4
12
2.72046 × 10−4
1.49497 × 10−4
1.31108 × 10−4
15
7.22452 × 10−5
1.49435 × 10−4
1.07281 × 10−4
18
3.48346 × 10−5
1.87672 × 10−4
9.68045 × 10−5
21
1.94926 × 10−5
1.96955 × 10−4
8.80828 × 10−5
24
1.20057 × 10−5
1.88110 × 10−4
7.82445 × 10−5
27
7.91486 × 10−6
1.72350 × 10−4
6.89410 × 10−5
30
5.49112 × 10−6
1.66609 × 10−4
6.05393 × 10−5
33
3.96425 × 10−6
1.67740 × 10−4
5.32930 × 10−5
36
2.95482 × 10−6
1.61975 × 10−4
4.71277 × 10−5
39
2.26092 × 10−6
1.52149 × 10−4
4.18904 × 10−5
42
1.76831 × 10−6
1.40941 × 10−4
3.74422 × 10−5
45
1.40897 × 10−6
1.34158 × 10−4
3.41088 × 10−5
48
1.14074 × 10−6
1.31914 × 10−4
3.17809 × 10−5
CRC codes (even in the case when the CRC checksum is for
short lengths such that the CRC code has also a rate of 1/2).
Additionally, which is important for Safety-Crytical Sys-
tems, we can make the probability of undetected errors arbi-
trary small, which is not case with CRC codes. Namely, the
probability of undetected errors for CRC code with c redundant
bits tends to 2−c when the block length n tends to inﬁnity.
VII.
CONCLUSION
We deﬁned error-detecting codes based on linear quasi-
groups. We proved that the probability of undetected errors
is independent from the distribution of the characters in the
input message. Using this property, we found the best class of
linear quasigroups of order 8 for such coding and we computed
the corresponding probability of undetected errors. Finally, we
explained how the probability of undetected errors can be made
arbitrary small. We compare our codes with CRC-12, CRC-
ANSI and CRC-CCITT and show that our code has smaller
probability of undetected errors than the CRC codes when code
rate and block lengths are equal.
ACKNOWLEDGMENT
This work was partially ﬁnanced by the Faculty of Com-
puter Science and Engineering at the ”Ss.Cyril and Methodius”
University.
REFERENCES
[1]
W. W. Peterson and D. T. Brown, “Cyclic Codes for Error Detection,”
in Proceedings of the IRE, vol. 49, no. 1, 1961, pp. 228-235.
[2]
P. Koopman and T. Chakravarty, “Cyclic Redundancy Code (CRC) Poly-
nomial Selection For Embedded Networks,” International Conference on
Dependable Systems and Networks, 2004, pp. 145-154.
[3]
A. Richardson, WCDMA Handbook, Cambridge, UK, Cambridge Uni-
versity Press, 2005, pp. 223.
[4]
A. Perez, “Byte-Wise CRC Calculations,” IEEE Micro vol. 3, no. 3,
1983, pp. 40-50.
[5]
S. Blanc, A. Bonastre, and P. J. Gil, “Dependability assessment of by-
wire control systems using fault injection,” Journal of Systems Architec-
ture, vol. 55, no. 2, 2009, pp. 102-113.
[6]
P. Koopman, “32-Bit Cyclic Redundancy Codes for Internet Appli-
cations,” The International Conference on Dependable Systems and
Networks, 2002, pp. 459-468.
[7]
D. T. Jones, “An improved 64-bit cyclic redundancy check for protein
sequences,” University College London, 2009.
[8]
J. G. Fletcher, “An Arithmetic Checksum for Serial Transmissions,” IEEE
Transactions on Communications, vol 30, no. 1, 1982, pp. 247-252.
[9]
J. Zweig and C. Partridge, “TCP Alternate Checksum Options,” IETF
RFC 1146, Mar. 1990.
[10]
P. Deutsch and J.-L. Gailly, “ZLIB Compressed Data Format Speciﬁ-
cation Version 3.3,” IETF RFC 1950, May 1996.
[11]
G. Latif-Shabgahi, J. M. Bass, and S. Bennett, “A taxonomy for software
voting algorithms used in safety-critical systems,” IEEE Transactions on
Reliability, vol. 53, no. 3, 2004, pp. 319-328.
[12]
V. Bakeva and N. Ilievska, “A probabilistic model of error-detecting
codes based on quasigroups,” Quasigroups and Related Systems, vol.
17, no. 2, 2009, pp. 135-148.
[13]
N. Ilievska and D. Gligoroski, “Error-Detecting Code using Linear
Quasigroups,” Advances in Intelligent Systems and Computing vol. 311,
ICT Innovations 2014, Springer, 2014, pp. 309-318.
[14]
N. Ilievska and D. Gligoroski, “An Error-Detecting Code based on
Linear Quasigroups,” in Proceedings of 11th International Conference for
Informatics and Information Technology (CIIT 2014), Bitola, Republic
of Macedonia, 2014, in press.
[15]
N. Ilievska, “Proving the probability of undetected errors for an error-
detecting code based on quasigroups,” Quasigroups and Related Systems
vol. 22, no. 2, 2014, pp. 223-246.
[16]
N. Ilievska and V. Bakeva, “A Model of error-detecting codes based
on quasigroups of order 4,” in Proceedings of 6th International Confer-
ence for Informatics and Information Technology, Bitola, Republic of
Macedonia, 2008, pp. 7-11.
[17]
Y. Chen, M. Niemenmma, A.J. Han Vinck, and D. Gligoroski, “On the
Error Detection Capability of One Check Digit,” IEEE Transactions on
Information theory, 2014, pp. 261-270.
[18]
K. A. Witzke, “Exmanination of the undetected error probability of
linear block codes,” Thesis: M.A. Sc, University of British Columbia
Department of Electrical Engineering, 1984.
[19]
T.V. Ramabadran and S.S. Gaitonde, “A tutorial on CRC computations,”
Micro, IEEE, vol.8, no.4, Aug. 1988, pp. 62-75.
[20]
P. Koopman and T. Chakravarty, “Cyclic Redundancy Code (CRC)
Polynomial Selection For Embedded Networks,” in Proceedings of the
International Conference on Dependable Systems and Networks, 2004,
pp. 145-154.
[21]
J.C. Knight, “Safety Critical Systems: Challenges and Directions,” in
Proceedings of the 24th International Conference on Software Engineer-
ing, 2002, pp. 547-550.
77
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-411-4
AICT 2015 : The Eleventh Advanced International Conference on Telecommunications

