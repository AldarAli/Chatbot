Interpolation and Intersection Algorithms and GPU 
 
 
Vaclav Skala 
Department of Computer Science 
VSB-Technical University 
Ostrava, Czech Republic 
Vaclav.Skala@vsb.cz  
 
 
Abstract — Interpolation and intersection methods are closely 
related and used in computer graphics, visualization, computer 
vision etc. The Euclidean representation is used nearly exclusively 
not only in computational methods, but also in education despite it 
might lead to instability in computation in many cases. The 
projective geometry, resp. projective extension of the Euclidean 
space, offers many positive features from the computational and 
educational points of view with higher robustness and stability of 
computation. This paper presents simple examples of projective 
representation advantages, especially from the educational point of 
view. In particular, how interpolation and intersection can be 
applied to fundamental algorithms, which are becoming more 
robust, stable and faster due to compact formulation. Another 
advantage of the proposed approach is a simple implementation on 
vector-vector architectures, e.g. GPU, as it is based on matrix-
vector operations. 
Keywords - Interpolation; intersection; principle of duality; 
barycentric coordinates; cross-product; linear systems of 
equations. 
I. 
 INTRODUCTION  
Algorithm efficiency and robustness are key points of 
research activities in computer graphics [7], [1], computer 
vision [6], [4], texture mapping [19] etc. Due to many items 
to be processed, a strong requirement for speed arises; also 
hardware architecture needs to be considered. However, 
speed and robustness requirements are usually in 
contradiction, especially if the Euclidean representation is 
used.  
Nevertheless, some other approaches like projective or 
conformal geometries can be used to overcome selected 
problems. As the projective representation is widely used in 
computer graphics, a simple modification of interpolation 
and intersection algorithms will be introduced and simple 
examples presented for demonstration. 
II. 
PROJECTIVE REPRESENTATION 
Projective representation uses homogeneous coordinates 
for computations and geometric transformations. A point 
ࢄ ൌ ሺܺ, ܻሻ in E2 (the Euclidean space) can be represented as 
࢞ ൌ ሾݔ,ݕ:ݓሿ்  in P2 (the projective extension of the 
Euclidean space).  Mutual conversion is defined as:  
ܺ ൌݔݓ⁄    ܻ ൌݕݓ
ൗ
    ݓ്0   (origin excluded) 
 
x
y
w
w=1
x
X
Y
(a)
a
b
c
c=1
D(p)
D( )
ρ
A
B
(b)
p
D(P )
2
P
2
E
2
D(E )
 
2
ρ
 
 
Figure 1. Geometric interpretation of a dual space 
 
One parametric set of points in P2 representing a unique 
point in E2, see [14]. A significant advantage of the 
projective representation is a possibility to use principle of 
duality. In the above case, a point is dual to a line and vice 
versa, etc. which might lead to new algorithms [2], [13], 
[18]. 
Similarly, the concept of the projective extension of the 
Euclidean space can be extended to n-dimensional space, 
especially to E3 used in computer graphics and vision. 
This simple formulation shows, that many computations, 
not necessarily only geometric transformations, can be made 
using homogeneous coordinates.  
It means that “projective scalar”, i.e. ࢞ ൌ ሾݔҧ:ݓሿ்  or 
“projective vector” ࢞ ൌ ሾ࢞ഥ:ݓሿ் ൌ ሾݔ,ݕ:ݓሿ், where ࢞ഥ is a 
vector, can form an input or output of the processing 
pipeline, e.g. interpolation and intersection computation. 
Projective representation can also help to explain many 
geometrical problems in a simple way, e.g. line intersection 
[13], area or volume computation [14], solution of linear 
homogeneous systems and computation of barycentric 
coordinates [12]. 
III. 
PRINCIPLE OF DUALITY 
Principle of duality is an essential principle and 
especially in computer graphics and vision can bring quite a 
new way how to handle and solve non-trivial problems. The 
principle states that any theorem remains true when we 
interchange the words “point” and “line”, “lie on” and “pass 
through”, “join” and “intersection” and so on. Once the 
theorem has been established, the dual theorem is obtained 
as described above, see [5]. 
218
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

The advantages of the projective geometry and principle 
of duality use can be demonstrated on very simple 
examples, e.g. a point as an intersection of two lines and a 
line as a join of two points.  
Let two points x1 and x2 be given in the projective space. 
Then the coefficients of the line p, which is defined by those 
two points, are determined as the  of their homogeneous 
coordinates. 
p = x1× x2 
i.e. 
 
1
1
1
2
2
2
det x
y
w
x
y
w
⎡
⎤
⎢
⎥
=
⎢
⎥
⎢
⎥
⎣
⎦
i
j
k
p
 
where: p = [a,b:c]T 
If the principle of duality is used, it is possible to write 
computation of an intersection of two lines as: 
x = p1× p2 
i.e. 
1
2
1
1
1
2
2
2
 × 
det a
b
c
a
b
c
⎡
⎤
⎢
⎥
=
=
⎢
⎥
⎢
⎥
⎣
⎦
i
j
k
x
p
p
 
where: x = [x,y:w]T 
A computation of an intersection point of two lines or a 
computation of a line if two points are given is made by the 
same sequence using the principle of duality and no division 
operation is needed. 
In the case of E3 point is dual to a plane and vice versa, 
i.e. if three points are given a computation of a plane is the 
same, in the sense of duality, as intersection computation of 
three planes, i.e. a plane is computed by the generalized 
cross-product as: 
1
1
1
1
1
2
3
2
2
2
2
3
3
3
3
×
×
det x
y
z
w
x
y
z
w
x
y
z
w
⎡
⎤
⎢
⎥
⎢
⎥
=
⎢
⎥
⎢
⎥
⎣
⎦
i
j
k
l
x
x
x
 
and an intersection of three planes is computed as: 
1
1
1
1
1
2
3
2
2
2
2
3
3
3
3
×
×
det a
b
c
d
a
b
c
d
a
b
c
d
⎡
⎤
⎢
⎥
⎢
⎥
=
⎢
⎥
⎢
⎥
⎣
⎦
i
j
k
l
ρ
ρ
ρ
 
It should noted that a division operation is not needed and 
the computational sequence is the same for both the cases. 
IV. 
LINEAR INTERPOLATION 
Linear interpolation is frequently used method not only 
in computer graphics. Let us consider a simple case of linear 
interpolation, when we want to interpolate on a line ࢖ or on 
a surface ࣋ , i.e. 
࢖:ࢄሺݐሻ ൌࢄ஺൅ࡿଵݐ     or 
࣋:ࢄሺݑ,ݒሻ ൌࢄ஺൅ࡿଵݑ൅ࡿଶݒ 
where: ࡿଵ ൌࢄ஻ െࢄ஺  and  ࡿଶ ൌࢄ஼ െࢄ஺ 
These are well-known formulas, of course. But what 
happens if points are given in homogeneous coordinates? 
From the teaching experience, the approach is 
a conversion of points to the Euclidean space followed by 
the “standard” linear interpolation. It means that in the first 
case 6 divisions and in the second case 9 divisions are 
needed with all consequences, including precision and 
stability issues. 
However, there is a possibility to make a linear 
interpolation directly in homogeneous coordinates as: 
࢖: ࢞ሺݐሻ ൌ ࢞஺ ൅ ࢙ଵݐ      
where: ࢙૚ ൌ ࢞஻ െ ࢞஺ 
ൌ ሾݔ஻ െݔ஺, ݕ஻ െݕ஺: ݓ஻ െݓ஺ሿ ் 
or 
࣋: ࢞ሺߦ,ߟሻ ൌ ࢞஺ ൅ ࢙ଵߦ൅࢙ଶߟ 
where:  ࢙૚ ൌ ࢞஻ െ ࢞஺ 
ൌ ሾݔ஻ െݔ஺, ݕ஻ െݕ஺,ݖ஻ െݖ஺: ݓ஻ െݓ஺ሿ் 
and 
࢙૛ ൌ ࢞஼ െ ࢞஺ ൌ ሾݔ஼ െݔ஺, ݕ஼ െݕ஺, ݖ஼ െݖ஺: ݓ஼ െݓ஺ ሿ ் 
In both cases, the following conditions apply: 
ݓ஺൐0,    ݓ஻൐0,ݓ஼൐0 
As in the projective space the metric is not generally 
defined, there must be some different behavior of such 
interpolation. Note that there is a direct connection to 
interpolation and projection operation in the graphical 
pipeline. 
Basic property of the interpolation in the projective 
space is a non-linear monotonic parameterization, i.e. for 
߬ ൌ 1/2 the center of the segment ࢄ஺ࢄ஻ in the Euclidean 
space is not obtained in general. It is well known problem of 
determining z-coordinate after projection operation. It 
means that we have a linear interpolation with: 
• Linear parameterization in the Euclidean space 
• Non-linear parameterization, but with a monotonic 
parameterization, 
in 
the 
projective 
space. 
This 
fundamental property is needed when comparison 
of  ݐଵ ൏ݐଶ, resp. ߬ଵ ൏ ߬ଶ , is required for a decision, e.g. 
which object is closer etc. 
In both cases,  division operation can be avoided by 
“hiding” denominator to the homogeneous coordinate, i.e. 
࢞ሺݐሻ ൌ ሾݓ஻࢞ഥ஺ ൅ ሺݓ஺࢞ഥ஻ െݓ஻࢞ഥ஺ሻݐ:ݓ஺ݓ஻ሿ் 
In this case, the parameterization is linear, of course. 
It should be noted that barycentric coordinates can be 
computed directly in homogeneous coordinates without 
division operations as well, see [12], using generalized 
cross-product. 
The above presented approach is quite simple for 
understanding projective space principles. 
V. 
BARYCENTRIC COORDINATES 
Barycentric coordinates are very often used not only in 
computer graphics, computer graphics and visualization. It 
is known that computation of barycentric coordinates leads 
to solution of linear system of equations (LSE). A solution 
of LSE is equivalent to the generalized cross-product. This 
219
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

result to computation of the barycentric coordinates directly 
using generalized cross-product without use of division 
operation and therefore the computation is more robust in 
general. The barycentric coordinates are computed as    
×
×
b =
ξ
η
w  
 
0
T
τ b =
 
1
2
3
4
,
,
,
T
= ⎡b b b b
⎤
⎣
⎦
b
 
x T
x
x
x
, ]
,
,
[
3
2
1
ξ =
  
T]1
,1 ,1
w = ,1[
 
y T
y
y
y
, ]
,
,
[
3
2
1
η =
    ݀݁ݐ ቮ
߬ଵ
߬ଶ
߬ଷ
߬
ݔଵݔଶݔଷݔ
ݕଵݕଶݕଷݕ
1111
ቮ ൌ 0 
The barycentric coordinates of the point x are then given as 
 
1
1
4
b
a
b
= −
, 
2
2
4
b
a
b
= −
, 
3
3
4
b
a
b
= −
 
The above formulas shows that the computation of the 
barycentric coordinates is quite simple. If hardware 
acceleration using matrix-vector operation is used, the 
computation is very fast. It is important to note that the 
similar scheme for the barycentric coordinates computation 
is valid for homogeneous coordinates as the determinant is 
multi-linear. 
VI. 
INTERSECTION COMPUTATIONS 
A. Line-plane intersection 
There is lot of algorithms based on line intersections, like 
ray-tracing, line clipping etc. Let us consider a simple case of 
intersection of a line in a parametric form with a plane, 
which is the fundamental principle of many algorithms, e.g. 
Cyrus-Beck’s (CB) line clipping, see Fig. 2 for E2 analogy 
(planes are “degenerated” to edges). 
xA
x2
x3
xi
x0
e0
t0
e1
t1 e2
t2
e3
t3
e4
t4
ti ei
en-1
tn-1
xN-1
x1
xB
x4
 
Figure 2. Line clipping by a convex polygon 
Let us consider two planes ࣋ଵ and ࣋ଶ and a line ࢖ in a 
parametric form given in homogeneous coordinates by two 
points ࢞஺ and ࢞஻.  
In many algorithms including CB algorithm the 
relation ݐଵ ൏ݐଶ, needs to be evaluated, e.g. to get an order of 
intersection 
points. 
For 
this 
only 
monotonic 
parameterization on the line ࢖ is needed.. It means that the 
linear 
interpolation 
with 
non-linear 
parameterization 
presented above can be used efficiently.  
The CB algorithm is based on an intersection solution of 
a line  ࢖ given in a parametric form and a plane ࣋ in E3 (or a 
line in E2) given in the implicit form as follows: 
࣋:ࢇ்࢞ ൌ 0   ࢖: ࢞ሺ߬ሻ ൌ ࢞஺ ൅ ࢙߬ 
It should be noted that all vectors are vectors of the 
projective space, i.e. they have homogeneous coordinates. 
Therefore, it is easy to compute the intersection point as 
ࢇ்࢞஺൅ࢇ்࢙߬ ൌ 0 
then 
߬ ൌ െࢇ்࢞஺
ൗࢇ்࢙
 
The parameter can be represented by a “projective scalar” as  
߬ ൌ ሾെࢇ்࢞஺:ࢇ்࢙ሿ் ൌ ሾ߬ҧ: ߬௪ሿ் 
Then the CB’s algorithm can be modified as follows: 
߬௠௜௡ ൌ ሾെ∞: 1ሿ்;         ߬௠௔௫ ൌ ሾ∞: 1ሿ்  
for i:=1 to N_planes do 
{ 
࣎: ൌ ሾെࢇ்࢞஺:ࢇ்࢙ሿ்;  # ࣎ ൌ ሾ߬ҧ: ߬௪ሿ் # 
 
if ߬௪ ൏ 0 then ࣎ ؔ െ࣎; 
 
# ߬௪ coordinate needs to be non-negative # 
 
if ߬ҧ ൏ 0 then ࣎௠௜௡ ൌ max  ሺ߬௠௜௡, ߬ሻ  
 
 
else ࣎௠௔௫ ൌ min ሺ߬௠௔௫, ߬ሻ 
} 
if NON-EMPTY (࣎௠௜௡, ࣎௠௔௫) = true then  
 
#equivalent test to  ݐଵ ൏ݐଶ # 
{ 
࢞஺_௡௘௪ ൌڮ....; ࢞஻_௡௘௪ ൌڮ         } 
Algorithm 1 
The above shows that no division operation is needed. 
Experiments made proved a slight speed-up for the case 
when the points are given in the Euclidean space (the 
algorithm has been simplified as wA, wB = 1 of course) and 
significant speed-up for the case when the points of the 
clipped line are given in the homogeneous coordinates. As 
N_planes, the number of planes, is usually higher, the speed-
up will grow with the number of planes of the given convex 
polyhedron. 
B. Intersection of two planes 
Intersection of two planes is another case very often 
solved in computer graphics and vision. Unfortunately in 
many cases available solutions are not robust or formula are 
neither simple nor convenient for GPU use. 
 
Figure 3. Intersection of two planes 
220
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

If the projective space is used, the solution is quite simple. 
Let us consider two planes ࣋ଵ and ࣋ଵ given as  
࣋ଵ ൌ ሾܽଵ, ܾଵ, ܿଵ: ݀ଵሿ் 
࣋ଶ ൌ ሾܽଶ, ܾଶ, ܿଶ: ݀ଶሿ் 
It means that normal vectors of those planes are 
࢔ଵ ൌ ሾܽଵ, ܾଵ, ܿଵሿ் ࢔ଶ ൌ ሾܽଶ, ܾଶ, ܿଶሿ் 
It is obvious that a directional vector of a line is determined 
as an intersection of two planes ࣋ଵ and ࣋ଵ given as 
࢙ ൌ ࢔ଵ ൈ ࢔ଶ 
However, the “starting” point ࢞଴ of the line is determined in 
quite complicated ways, sometimes even not robustly 
enough and based on a user choice of some value, or 
proposes solution of a system of linear equations [Gol90], 
[20]. 
The following “standard” formula can typically be 
found: 
࢔ଷ ൌ ࢔ଵ ൈ ࢔ଶ 
ݔ଴ ൌ
݀ଶ ฬܾଵ
ܿଵ
ܾଷ
ܿଷฬ െ ݀ଵ ฬܾଶ
ܿଶ
ܾଷ
ܿଷฬ
ܦܧܶ 
ݕ଴ ൌ
݀ଶ ቚܽଷ
ܿଷ
ܽଵ
ܿଵቚ െ ݀ଵ ቚܽଷ
ܿଷ
ܽଶ
ܿଶቚ
ܦܧܶ 
ݖ଴ ൌ
݀ଶ ฬܽଵ
ܾଵ
ܽଷ
ܾଷฬ െ ݀ଵ ฬܽଶ
ܾଶ
ܽଷ
ܾଷฬ
ܦܧܶ 
ܦܧܶ ൌ อ
ܽଵ
ܾଵ
ܿଵ
ܽଶ
ܾଶ
ܿଶ
ܽଷ
ܾଷ
ܿଷ
อ 
The formula is quite “horrible” one and for students not 
acceptable as it is too complex and they do not see from the 
formula comes from. 
As outline below, there is a quite simple geometrical 
explanation and solution. So the first question is how to find 
the “starting” point ࢞଴ of the line ࢖ given by two planes ࣋ଵ 
and ࣋ଶ. If a robust solution is required a user should be 
prevented from a selection of some “parameters”.  
Let us imagine that there exists a plane  ࣋଴ , whose 
normal vector is given as  ࢙ ൌ ࢔ଵ ൈ ࢔ଶ. 
It means that its position needs to be “fixed” in the 
space. As there is no other requirement on this plane, we can 
“fix” it so it passes through the origin of the coordinate 
system, i.e. the plane ࣋଴ is given as 
࣋଴ ൌ ሾܽ଴, ܾ଴, ܿ଴: 0ሿ்   
and the line  ࢖ is orthogonal to the plane ࣋଴ – resulting in  a 
robust geometric position. 
Now, the intersection point of three planes is the point ࢞଴ 
we are looking for. Coordinates of the point ࢞଴   are 
determined by generalized cross-product as 
࢞଴ ൌ ࣋ଵ ൈ ࣋ଶ ൈ ࣋଴  
As this formula is very compact and the cross-product is a 
GPU instruction, it is suitable for GPU use. See the 
Appendix 
for 
the 
extended 
cross-product 
GPU 
implementation.  
From the formulation presented above, it can be seen 
that it is not only very simple, easy to understand and 
remember, but also easy to implement. It is obvious that the 
point ࢞଴ is also the closest point on the line to the origin, 
too. As a result the Plücker coordinates formulation of this 
problem solution is not needed when looking for such 
properties. 
VII. WINDOW CLIPPING 
Line or line segment clipping against rectangular window 
or convex polygon in E2 is a basic operation in computer 
graphics. There are well-known Cohen-Sutherland algorithm 
and many other algorithms. Some of these well-known 
algorithms are not easy to implement due to their 
complexity. However, there is a simple and effective solution 
based on projective representation and the line clipping 
algorithm can be described using 7 lines only.  
The algorithm is based on classification of the window 
vertices resulting in a binary code which is the address to 
TAB1 and TAB2 tables, where indices of intersected edges 
are stored. Coordinates of intersection points are computed 
as a cross-product of the given line and intersected edges. 
x0
xA
x2
x3
e3
e0
e1
e2
x1
xB
F(x)<0
F(x)>0
 
Figure 4. Line clipping by a rectangular window 
procedure CLIP_L;    { input: xA , xB } 
# xA=[xA,yA:wA]T, xB=[xB,yB:wB]T # 
# xA , xB –in homogeneous coordinates # 
# the EXIT statement ends the procedure # 
{ 
p := xA x xB; { ax+by+c = 0; p = [a,b,c]T } 
 
for k:=0 to N-1 do # xk=[xk,yk:wk]T # 
 
 
if pTxk ≥ 0 then ck:=1 else ck:=0; 
 
if c = [0000]T or c = [1111]T then EXIT; 
 
i:= TAB1[c]; j:= TAB2[c]; 
 
xA := p x ei ; xB := p x ej ; 
 
DRAW (xA; xB) 
} 
Algorithm 2 
Where N is a number of edges of the clipping window TAB1 
and TAB2 are constant tables with window edges 
classifications, for details see [15].  
221
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

For the situation at Fig. 4, CODE=[0011]=3, TAB1=1 
and TAB2=3. The algorithm itself is easy to explain and 
implement, too. 
The line segment clipping algorithm is a little bit longer, 
but still easy to implement, see [15], and to modify for line 
or line segment clipping by a convex polygon as well. It 
should be noted that due to the principle of duality, line 
clipping by a convex polygon is dual to a point-in-polygon 
test, which is of ܱሺ݈݃ܰሻ complexity. Line clipping algorithm 
of ܱሺ݈݃ܰሻ complexity is more complex, see [16]. 
VIII. CONCLUSION 
Application of projective geometry principles to the 
computational pipeline, especially in the field of geometry 
and computer graphics can bring new algorithms that are 
more robust and faster even for the Euclidean space. Due to 
the formulation, is very convenient for vector-vector or 
matrix-vector architectures, like GPU and a significant 
speed-up can be expected as well. Projective geometry can 
easily explain several methods in a more simple way and 
also provide new formula and geometric representation 
which contributes to students’ better understanding. 
ACKNOWLEDGMENT 
The author would like to thank students and colleagues 
at the VSB-Technical University and University of West 
Bohemia for discussions and suggestions, reviewers for 
their critical comments and constructive recommendations.  
This work was partially supported by SGS, VSB-
Technical University of Ostrava, Czech Republic, under the 
grant No. SP2011/163. 
REFERENCES 
[1] D. van Arsdale, 
“Homogeneous 
Transformation 
Matrices 
for 
Computer Graphics,” Computers & Graphics, Vol.18, No.  2, March-
April 1994, pp. 177-191, 1994. 
[2] M.M.S. Coxeter, “Projective Geometry,” Toronto: University of 
Toronto, 2nd edition, 1974. 
[3] R. Goldman, “Intersection of Three Planes,” Graphics Gems 
(Ed. A.Glassner.), Academic Press, pp. 305-310, 1990. 
[4] R. Hartley and A. Zisserman, “Multiple View Geometry in Computer 
Vision,” Cambridge University Press, 2000. 
[5] M. Johnson, “Proof by Duality: or the Discovery of “New” 
Theorems,” Mathematics Today, December, 1996. 
[6] M.E. Loaiza, A.B. Raposo and M. Gattass, “Multi-camera Calibration 
Based on an Invariant Pattern,” Computers & Graphics, Vol. 35, Issue 
2, pp. 198-207, 2011. 
[7] J.R. Miller, “Vector Geometry for Computer Graphics,” IEEE 
Computer Graphics and Applications, Vol. 19, No. 3., 1999. 
[8] V. Skala, “Geometric Computation, Duality and Projective Space,” 
IW-LGK workshop proceedings, pp.105-111, Dresden University of 
Technology, 2011. 
[9] V. Skala and V. Ondracka, “A Precision of Computation in the 
Projective Space,” Recent Researchers in Computer Science, 
WSEAS, pp. 35-40, 2011. 
[10] V. Skala, “Duality and Intersection Computation in Projective Space 
with GPU support,” ASM 2010 Conf., pp. 66-71, NAUN, 2010. 
[11] V. Skala, “Computation in Projective Space,” MAMETICS 2009 
Conf., pp. 152-157, WSEAS, 2009. 
[12] V. Skala, “Barycentric Coordinates Computation in Homogeneous 
Coordinates,” Computers & Graphics, Elsevier, Vol. 32, No. 1, 
pp. 120-127, 2008. 
[13] V. Skala, “Intersection Computation in Projective Space using 
Homogeneous Coordinates,” International Journal on Image and 
Graphics, Vol. 8, No. 4, pp. 615-628, 2008. 
[14] V. Skala, “Length, Area and Volume Computation in Homogeneous 
Coordinates,” International Journal of Image and Graphics, Vol. 6., 
No. 4, pp. 625-639, 2006. 
[15] V. Skala, “A New Approach to Line and Line Segment Clipping in 
Homogeneous Coordinates,” The Visual Computer, Vol.21, No.11, 
pp.905-914, Springer Verlag, 2005. 
[16] V. Skala, “O(lg N) Line Clipping Algorithm in E2,” Computers & 
Graphics, Pergamon Press, Vol.18, No.4, 1994. 
[17] J. Stolfi, “Oriented Projective Geometry,” Academic Press, 2001. 
[18] F. Yamaguchi, “Computer-Aided Geometric Design,” Springer 
Verlag, 2002. 
[19] Y. Yu, “Efficient Visibility Processing for Projective Texture 
Mapping,” Computers & Graphics, Vol. 23, No. 2, pp. 245-253, 1999. 
WEB references 
[20] Softsurfer http://softsurfer.com/ <retrieved on 2011-12-05> 
 
APPENDIX 
The cross-product in 4D defined as 
࢞૚ ൈ ࢞૛ ൈ ࢞૜ ൌ ݀݁ݐ ተ
࢏
࢐
࢑
࢒
ݔଵݕଵݖଵݓଵ
ݔଶݕଶݖଶݓଶ
ݔଷݕଷݖଷݓଷ
ተ 
 
can be implemented in Cg/HLSL on GPU as follows: 
 
float4 cross_4D(float4 x1, float4 x2, float4 x3)  
{ 
 
float4 a; 
 
a.x=dot(x1.yzw, cross(x2.yzw, x3.yzw)); 
 
a.y=-dot(x1.xzw, cross(x2.xzw, x3.xzw)); 
 
// or a.y=dot(x1.xzw, cross(x3.xzw, x2.xzw)); 
 
a.z=dot(x1.xyw, cross(x2.xyw, x3.xyw)); 
 
a.w=-dot(x1.xyz, cross(x2.xyz, x3.xyz)); 
 
// or a.w=dot(x1.xyz, cross(x3.xyz, x2.xyz)); 
 
 
return a; 
} 
 
or more compactly 
 
float4 cross_4D(float4 x1, float4 x2, float4 x3) 
{ 
 
return ( dot(x1.yzw, cross(x2.yzw, x3.yzw)),  
 
-dot(x1.xzw, cross(x2.xzw, x3.xzw)),  
 
dot(x1.xyw, cross(x2.xyw, x3.xyw)), 
 
-dot(x1.xyz, cross(x2.xyz, x3.xyz)) ); 
} 
 
 
222
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-184-7
ICONS 2012 : The Seventh International Conference on Systems

