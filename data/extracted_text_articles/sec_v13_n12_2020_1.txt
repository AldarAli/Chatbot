Investigating the Creation of an Evolvable Firewall Rule Base and Guidance for
Network Firewall Architecture, using the Normalized Systems Theory
Geert Haerens
Department of Management Information Systems
Faculty of Business and Economics
University of Antwerp, Belgium
and Engie IT — Dir. Architecture
Email: geert.haerens@engie.be
Herwig Mannaert
Department of Management Information Systems
Faculty of Business and Economics
University of Antwerp, Belgium
Email: herwig.mannaert@uantwerp.be
Abstract—A ﬁrewall is an essential network security component.
It protects network connected company resources from potential
malicious trafﬁc. The ﬁrewall rule base, the list of ﬁlters to be
applied to network trafﬁc, can quickly become complex up to the
point where companies consider the rule base as unmanageable.
The complexity leads to unforeseen and painful side effects
when the ﬁrewall rule base is changed (add/remove ﬁltering
rules). Sufﬁcient literature exists on the root cause of rule base
evolvability issues. However, little research is available on how
to properly construct a rule base such that the evolvability
issues do not occur. Normalized Systems (NS) theory provides
proven guidance on how to create evolvable modular systems.
In this paper NS is used to study the combinatorics involved
when creating a ﬁrewall rule base. Based on those combinatorics,
an artifact (method) is proposed to create a ﬁrewall rule base,
that has evolvability in its design. As a network rarely contains
only one ﬁrewall, the impact of different ﬁltering strategies and
changes on multiple ﬁrewalls, is studied as well.
Keywords–Normalized Systems; Firewall; Rule Base; Filtering
Strategies.
I.
INTRODUCTION
This paper is an extended version of “Using Normalized
Systems to Explore the Possibility of Creating an Evolvable
Firewall Rule Base” [1] Firewalls are an essential component
of network security. They have been protecting network-
connected resources for over 25 years and will continue to do
so for the next decades [2] [3]. Initially, ﬁrewalls were used
to protect a company against threats coming from the outside
(i.e., the “evil Internet”). Such kind of ﬁltering is called North-
South trafﬁc ﬁltering [4]. But security breaches are not only
caused by access through the Internet. A signiﬁcant portion
of security breaches are caused from within the company
network [5] where hacks have become more sophisticated.
Getting a foothold on one resource on the internal network and
from there on hopping between resources, is a known hacking
strategy against which ﬁltering North-South trafﬁc offers no
protection. For this reason, protecting the network-connected
resources from internal trafﬁc, referred to as East-West trafﬁc
[4], is gaining ground.
Networks are becoming more and more complex: they
often contain multiple ﬁrewalls, which protect numerous net-
work segments. The rule base of those ﬁrewalls (i.e., the
deﬁnitions of which trafﬁc is allowed or not) is becoming
equally complex, up to the point where it becomes almost
unmanageable. In a survey organized by Firemon [6], 73 %
of survey participants stated that their ﬁrewall ranges from
“somewhat complex” to “out of control”. Further, complexity
is the highest-ranked challenge for ﬁrewall management [2]
[3].
The ﬁrewall rule base is a classic example of a system that
needs to evolve. It starts with one ﬁrewall, and two network
segments and ﬁltering rules between them. As the network
grows, the number of resources connected to the network
grows, the number of services offered on the network grows,
and the number of security threats grows. The resulting ﬁrewall
rule base will enlarge dramatically. This evolution will, at some
point, result in a rule base where regular changes (i.e., the
addition of a rule or the removal of a rule) result in unforeseen
side effects. Those effects are proportional to the size of the
rule base: the bigger the system (rule base), the worse it gets
[2].
A network rarely contains only one ﬁrewall. Large com-
panies have networks containing many ﬁrewalls. Valuable IT
assets, located in data centers, are protected by multiple layers
of ﬁrewalls. A single ﬁrewall can quickly become a non-
evolvable system. Multiple ﬁrewalls only make the problem
worse. Besides the question on how to create the correct rule
and implement it on the rule base, one also has to decide on
which ﬁrewall(s) this rule should be applied.
Normalized Systems (NS) theory [7]–[11] studies combi-
natorics in modular systems and provides a set of theorems to
design modular systems exhibiting ex-ante proven evolvability.
The goal is to avoid so-called combinatorial effects (CE). CE’s
are impacts that are proportional to the type of change as well
as the size of the system to which the change is applied. When
all modules of a system respect the NS theorems, the system
will be free of such CE’s. At that point, the system can be
considered stable under change for a set of anticipated changes
(such as adding and removing components from the system).
Multiple vendors sell tools to analyze a ﬁrewall rule
base and can even be used to simplify it (e.g., Firemon,
Tuﬁn, Algosec). Some academic research on such analyses is
available as well. Both industry and academics seem to focus
on improving existing rule bases. However, a more ambitious
objective would be to avoid this type of problem upfront
through the deliberate design of the rule base and incorporate
evolvability by design.
1
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

This paper will study the combinatorics involved in the
ﬁrewall rule base. We will propose an artifact (a method), that
translates the general NS theorems into a set of ﬁrewall rule
base principles. When applied, this will result in an ex-ante
proven evolvable (free of CE) rule base with respect to the
addition and removal of rules to the ﬁrewall rule base.
We will start with a literature review and relate work. The
remainder of the paper is structured according to the Design
Science approach [12] [13]. Therefore, Section III starts by
explaining some ﬁrewall basics and explains the evolvability
issues of a ﬁrewall rule base. Section IV describes the artifact
goals and design. The artifact is demonstrated (apply changes
to a rule base) and evaluated in Section V. Section VI
elaborates on different ﬁltering strategies and Section VII
will address the problems and possible solutions related to
multiple ﬁrewalls. In Section VIII, automation and scaling of
the propose solution is discussed and a link is made with the
concept of Software Deﬁned Network. In Section IX a part of
the literature review is revised and weaknesses of the artifact
are pointed out. Finally, Section X wraps up the paper and
proposes future research.
This article builds on earlier research [11], where the
applicability of NS for IT infrastructure systems was being
explored. The current paper focuses on a practical case where
NS and domain-speciﬁc knowledge on ﬁrewalls are combined,
resulting in a design strategy for an evolvable ﬁrewall rule base
and network ﬁrewall architecture.
II.
LITERATURE REVIEW AND RELATED WORK
The academic literature about ﬁrewalls can be divided into
3 groups. The ﬁrst group (published roughly before the year
2000) focuses on the performance of the ﬁrewall and the hard-
ware used to perform the actual package ﬁltering. The second
group (published roughly between 2000 and 2006) focuses on
the complexity and issues with the rule base of the ﬁrewall.
The third group (published roughly after 2006) focuses on the
ﬁrewall in a Software Deﬁne Network (SDN) context, where
distributed ﬁrewalls and software deﬁned ﬁrewalls are used.
As this paper focuses on the complexity and issues related to
the ﬁrewall rule base, the following literature review will only
focus on the second group of papers [14]–[25]. To the best
of our knowledge, we did not ﬁnd papers which speciﬁcally
address and try to solve the evolvability issues of the ﬁrewall
rule base. Next to academic papers, reports from Forrester
and white papers from industry leaders were used as well
[2]–[6], [26]–[28]. Those reports include surveys, which give
information on the current state-of-affairs. One might think
that, because academic publication about rule base issues have
diminished after 2006, the problem is solved. However, the
surveys provide a different view. Companies are still struggling
with their ﬁrewall [2]–[6], [26]–[28]. This can be due to the
“knowing-doing” gap or because the issue is not fully resolved.
Most papers start by stating that there is a problem with
the ﬁrewall rule base because of:
•
Translation issues: how to convert a high level secu-
rity policy into a low-level language of ﬁrewall rules
[14]–[25] [26].
•
Size of the rule base issues: a large rule base is
considered complex [6] [16] [20] [22] [23].
•
Error and anomalies issues: A rule base is error-
prone due to complexity and manual interventions [2]–
[6], [15], [16], [23], [26]–[28] and can contain ﬁrewall
rule conﬂicts or anomalies [6], [14]–[16], [19], [21]–
[23], [25], [27].
The “Translation-issue” is tackled by proposing tools,
which could translate high level security concepts into low
level ﬁrewall rules. FANG [19], FIRMATO [16], LUMETA
[18] are artifacts proposed and described, which help translat-
ing high level security requirements into a low level ﬁrewall
rule base. There are however no guarantees that these tools
deliver a small and simple ﬁrewall rule base free of anamolies
[16]. Companies such as TUFIN, ALGOSEC, FIREMON,
VMWare also deliver commercial tools, which claim to help
managing the complexity of network security. The tools do not
prescribe, neither enforce how a rule base should be created
in order to be free of anomalies and exhibit evolvability.
The “Size of the rule base issue” receives a lot of attention.
Effort is put in reducing the rule base to a minimum list
of rules, that still answer to the ﬁltering requirements. The
motivation for this “reduction of the rule base” is performance,
although in [16] it was suggested that the actual size of the rule
base is not related to the way the hardware actually applies the
rules. This suggests a decorrelation between the size of the rule
base and the ﬁrewall performance. This point will be revisited
in Section IX.
The “Error issue” due to complexity and manual inter-
vention is recognized and conﬁrmed in recent surveys [2]–[6],
[26]–[28]. The academic papers focus more on the technical
root causes of the errors, being the anomalies in the rule base.
Over time, the deﬁnitions of the types of anomalies, their
formal deﬁnition and proof, have evolved and resulted in a
deﬁnition of how a ﬁrewall rule base should look like in order
to remain stable under change: a ﬁrewall rule base should only
include disjoint rules [15] [21] [22] [23] [24] [25]. Artifacts
have been put forward [15] [16], [20]–[22], [25], which allow
to scan the rule base for non-disjoint rules and make them
disjoint if required. The same artifacts allow to assess the
impact of adding a new rule and adjusting the rules in such
way that the rule base only contains disjoint rules. However,
each time a rule is entered, the whole rule base needs to be
scanned to detect potential anomalies between the existing rule
base and the new rule. The effort of making a change to the
system is thus proportional to the size of the system.
The literature review shows that the problems related to the
ﬁrewall rule base are well known and the necessary condition
to keep the rule base under control (i.e., having disjoint rules)
is also known. However, clear architectural guidance on how
to create a disjoint rule base as of the moment of conception, is
lacking. It is exactly this architectural guidance, making use of
NS, which is the main contribution of this paper. By structuring
the rules in such a way that they are always disjoint, one can
add and remove rules without having to analyze the rule base
or worry about unforeseen side effects of the change.
III.
GENERAL BACKGROUND AND PROBLEM
DESCRIPTION
This section explains some fundamental concepts about
ﬁrewalls, followed by a summary of the issues regarding the
evolvability of a ﬁrewall rule base. The section continues by
explaining the notion of ﬁrewall group objects, their value, and
related issues. The section continues with a brief explanation
of the Zero Trust (ZT) ﬁltering strategy, which is one of the
design objectives of the envisioned artifact, and terminates with
an introduction to the Normalized Systems Theory.
2
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 1. Firewall concepts
A. Firewall concepts
An IP4 TCP/IP based ﬁrewall, located in the network path
between resources, can ﬁlter trafﬁc between the resources,
based on the Layer 3 (IP address) and Layer 4 (TCP/UDP
ports) properties of those resources [29] [30]. Filtering happens
by making use of rules. A rule is a tuple containing the
following elements: <Source IP, Destination IP, Destination
Port, Protocol, Action>. IP stands for IP address and is a 32-
bit number that uniquely identiﬁes a networked resource on a
TCP/IP based network. The rule is evaluated by the ﬁrewall,
meaning that when it sees trafﬁc coming from a resource with
IP address =<Source IP>, going to resource =<Destination
IP>, addressing a service listening on Port = <Destination
port>, using Protocol = <Protocol>, then the ﬁrewall will
perform an action = <Action>. The action can be “Allow”
or “Deny”. See Figure 1 for a graphical representation of the
explained concepts.
A ﬁrewall rule base is a collection of order-sensitive rules.
The ﬁrewall will evaluate all inbound trafﬁc against the ordered
rule base. The ﬁrewall starts at the top of the rule base until
it encounters the ﬁrst rule that matches the criteria (Source,
Destination, Destination Port, Protocol) of the trafﬁc. The
ﬁrewall then performs the action as speciﬁed in the rule. In a
ﬁrewall rule, <Source IP>, <Destination IP>, <Destination
Port> and <Protocol> can be one value or a range of values.
The protocol can be TCP or UDP. In the remainder of this
document, the notion of protocol is omitted as it can be
included in the Port variable (for example, TCP port 58 or
UDP port 58).
B. Firewall evolvability issues
As a rule base changes over time, different rules start
interfering with each other, resulting in complexity. In [15],
the following relations are deﬁned between rules:
•
Disjoint: Two rules R1 and R2 are disjoint (completly
or partially), if they have at least one criterion (source,
destination, port) that has completely disjoint values
(= no overlap or match).
•
Exactly Matching: Two rules R1 and R2 are exactly
matched, if each criterion (source, destination, port)
of the rules match exactly.
•
Inclusively Matching: A rule R1 is a subset, or
Figure 2. Possible relationships between rules (from [21])
inclusively matched to another rule R2, if there exists
at least one criterion (source, destination, port) for
which R1’s value is a subset of R2’s value and for
the remaining attributes, R1’s value is equal to R2’s
value
•
Correlated: Two rules R1 and R2 are correlated, if
R1 and R2 are not disjoint, but neither a subset of the
other.
Figure 2 represents the differnet relation in a graphical
manner. Exactly matching, inclusively matching and correlated
rules can result in the following ﬁrewall anomalies [15]:
•
Shadowing Anomaly: A rule R1 is shadowed by an-
other rule R2 if R2 precedes R1 in the policy, and R2
can match all the packets matched by R1. The result
is that R1 is never activated.
•
Correlation Anomaly: Two rules R1 and R2 are cor-
related if they have different ﬁltering actions and R1
matches some packets that match R2 and R2 matches
some packets that R1 matches.
•
Redundancy Anomaly: A redundant rule R1 performs
the same action on the same packets as another rule
R2 so that if R1 is removed the security policy will
not be affected.
A fully consistent rule base should only contain disjoint
rules. Disjoint rule are completely disjoint or partially dis-
joint. In that case, the order of the rules in the rule base
is of no importance and the anomalies described above will
not occur [15] [21]–[25] ). However, due to several reasons
such as unclear requirements, a faulty change management
process, lack of organization, manual interventions, and system
complexity [13], the rule base will include correlated, exactly
matching, and inclusively matching rules. Combined with the
order-sensitivity of the rule base, changes to the rule base
(the addition or removal of a rule) can result in unforeseen
side effects. To be conﬁdent that a change will not introduce
unforeseen side effects, the whole rule base needs to be
analyzed. Therefore, the impact of the change is proportional
to the change and the size of the system, being the complete
rule base. According to NS, this is a CE. As a result, a ﬁrewall
rule base containing rules other than disjoint rules, is unstable
under change.
3
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

C. Firewall group objects
A rule base made up of IP’s as source/destination and port
numbers is difﬁcult to interpret by humans. It is just a bunch of
numbers. Modern ﬁrewalls allow the usage of ﬁrewall objects,
called groups, to give a logical name to a source, a destination,
or a port, which is more human-friendly. Groups are populated
with IP addresses or ports. Groups can be nested.
Using groups should improve the manageability of the
ﬁrewall. But, using groups can easily result in the introduction
of exactly matching, inclusively matching or correlated rules
as well.
Example:
“Group Windows APP” and “Group Windows APPS” could
be two groups with each contain the IP addresses of all
Windows Application Servers. The latter may have been cre-
ated without knowledge of the former [6], introducing exactly
matching rules. The group memberships may start to deviate
from each other, introducing correlated or inclusively matching
rules, which could lead to anomalies in the rule base. The
group structure must be well designed to avoid this.
D. Zero Trust
In [18] [19] [20] Forrester advocates the usage of a Zero
Trust (ZT) model:
•
Ensure all resources are accessed securely, regardless
of location and hosting model,
•
Adapt a “least privilege” strategy and strictly enforce
access control,
•
Inspect and log all trafﬁc for suspicious activity.
The working assumption in the case of protecting network-
connected resources is that all trafﬁc towards those resources
is considered a threat and must be inspected and secured. A
network-connected resource should only expose those services
via the network, which are minimally required. Also, each
network connected resource should only be allowed access to
what it needs.
E. Introduction to Normalized Systems
The Normalized Systems Theory [7]–[10] originates from
the ﬁeld of software development. There is a widespread belief
in the software engineering community that using software
modules decrease complexity and increases evolvability. It is
also well known that one should strive towards “low coupling
and high cohesion”. The problem is that the community does
not seem to agree on how exactly “low coupling and high
cohesion” needs to be achieved and what the size of a module
should be, to achieve low complexity and high evolvability.
The Normalized Systems Theory takes the concept of sys-
tem theoretic stability from the domain of classic engineering
to determine the necessary conditions a modular structure of
a system must adhere to in order for the system to exhibit
stability under change. Stability is deﬁned as Bounded Input
equals Bounded Output (BIBO). Transferring this concept to
software design, one can consider bounded input as a certain
amount of functional changes to the software and the bounded
output as the number of effective software changes. If the
amount of effective software changes is not only proportional
to the amount of functional changes but also the size of
the existing software system, then NS states that the system
exhibits a Combinatorial Effect and is considered unstable
under change. Normalized Systems Theory proves that, in
order to eliminate Combinatorial Effects, the software system
must have a certain modular structure, where each module
respects four design rules. Those rules are:
•
Separation of Concern (SoC): a module should only
address one concern or change driver
•
Separation of State (SoS): a state should separate
the use of a module by another module during its
operation
•
Action Version Transparency (AVT): a module, per-
forming an action should be changeable without im-
pacting modules calling this action.
•
Data Version Transparency (DVT): a module per-
forming a certain action on a data structure, should
be able to continue doing this action, even is the
data structures has undergone change (add/remove
attributes)
Only by respecting those rules, the system can inﬁnity grow
and still be able to incorporate new requirements.
Although NS originates in software design, the appli-
cability of the NS principles in other disciplines such as
process design, organizational design, accounting, document
management, and physical artifacts. The theory can be used to
study evolvability in any system that can be seen as a modular
system and derive design criteria for the evolvability of such a
system. In this paper, NS will be used to study the evolvability
of the ﬁrewall rule base.
IV.
CREATING AN ARTIFACT FOR AN EVOLVABLE RULE
BASE
This section starts with investigating the modular structure
of a ﬁrewall rule base, followed by a discussion of the issues
that surface when the modular structure is instantiated. The
section continues with a set of formal deﬁnitions of the ﬁrewall
rule base components, from which the combinatorics are
derived when creating a ﬁrewall rule base. The combinatorics
are used to distill the design rules for the evolvable rule base.
The design rules are translated into the actual artifact.
Based on the analysis of the problem space in the previous
section, the objective is:
•
To create a rule base compliant with the ZT concept.
•
To create a rule base that contains only disjoint rules.
•
To create a rule base, making use of ﬁrewall group
objects to improve readability and manageability.
•
To create a rule base that is evolvable for the following
anticipated changes: the addition and removal of rules.
NS will be used to structure this evolvable rule base.
A. Modular structure of the rule base
A rule base is the aggregation of rules. A rule is an aggre-
gation of Source, Destination, Service, and Action. Source is
the aggregation of Clients requiring services. Destination is the
aggregation of Hosts offering services. Service is the aggrega-
tion of Ports (combination of port number and protocol), which
compose a service. Figure 3 represents the implicit modular
data structure of a rule base in a ﬁrewall. Implicit because
ﬁrewall vendors do not publish the internal data structure
they use. The model corresponds with the type of information
one needs to enter to create a rule in a ﬁrewall. Therefore,
we assume that the model is a sufﬁcient representation of a
ﬁrewall rule base. In NS terms, the modular structure would
be considered as evolvable when “Separation of Concern” is
respected (the theorems “Separation of State” and “Data and
4
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 3. Modular Structure of a rule base
Action Version Transparency” are not relevant for the analysis
of the rule base structure). As each of the mentioned modules
focusses on one concern, one tends to conclude that the design
of a rule base can be considered as stable under change.
B. Module instantiation
If the modular structure of the rule base seems to be stable
under change, then where does the problem of non-evolvable
rule bases comes from? In this respect, it is important to be
aware that a ﬁrewall rule base is an order-sensitive system.
More speciﬁcally, each instantiation of a rule must be given
the correct place in the rule base, or the rule will have an
impact on existing rules (see Section III). The order sensitivity
is the root cause of the evolvability issues when the modular
structure is instantiated. Indeed, it seems that —in some
speciﬁc situations— certain evolvability issues of a modular
structure only show up at instantiation time. Therefore, it is
interesting to look at the application of the NS theorems at
the instantiation level as well. In the context of this research,
this would mean that we need to look whether the addition
or removal of instantiations (of rules) can result in CE’s,
and thus evolvability issues, making an operational system
unmanageable.
Eliminating the order-sensitivity of the rule base is the
key to solving the problem. A ﬁrewall rule base should only
contain disjoint rules. Disjoint rules have no coupling with
other rules and are thus compliant with the “Separation of
Concern” theorem of NS.
C. Formal deﬁnitions of rule base components
Let N represent a Layer 4 TCP/IP based network, in which
2 groups of network connected resources can be deﬁned:
•
The hosts, providing network services via TCP/IP
ports.
•
The clients, requiring access to the services offered by
the host.
The
network
contains
a
ﬁrewall
with
conﬁguration
F,
which is conﬁgured in a way that only certain clients have
access to certain services on certain hosts. The ZT principle
should be applied, meaning that clients have only access to
those services on hosts they have been given explicit access to.
Let Port represent a Layer 4 TCP/IP deﬁned port.
•
Port.name = the name of the port.
•
Port.protocol = the layer 4 TCP/IP protocol, being one
of the following two values: TCP or UDP.
•
Port.number = the number of the port, represented as
an integer ranging from 1 to 216.
Let P represent the list of Ports, of length = pj .



P[1] ... P[pj].
P[j] contains a Port.
1 ≤ j ≤ pj.
Let Service represent a network service accessible via a list
of layer 4 TCP/IP ports.
•
Service.name = name of the service.
•
Service.ports = list of ports = P.
Let S represent a list of Services, of length = sj.



S[1] ... S[sj].
S[i] contains a Service.
1 ≤ i ≤ sj.
Let Host represent a network host that provides services.
•
Host.name = the Fully Qualiﬁed Domain Name
(FQDN) of the network host.
•
Host.IP = the IP address of the network host.
Let H represent a list of Hosts, of length = hj. The length of
H is a function of the network N.







H[1] ... H[hj].
H[k] contains a Host.
1 ≤ k ≤ hj.
hj = fh(N)
Let Client represent a network client that requires access to
hosted services.
•
Client.name = the FQDN of the network client.
•
Client.IP = the IP address of the network client.
Let C represent a list of Clients, of length = cj. The length of
C is a function of the network N.







C[1] ... C[cj].
C[l] contains a Client.
1 ≤ l ≤ cj.
cj = fc(N)
Let R represent a ﬁrewall rule.
•
R.Source = a list of Clients Cs of length = csj, where
◦
1 ≤ csj≤ cj
◦
Cs ⊂ C
•
R.Destination = a list of Hosts Hd of length = hdj,
where
◦
1 ≤ hdj≤ hj.
◦
Hd ⊂ H.
•
R.Ports = a list of Ports = a Service Sp
◦
where Sp ∈ S[sj].
5
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

•
R.Action = either “Allow” of “Deny”.
Let F, representing a list of rules R of length = fj, be the
ordered ﬁrewall rule base F
•
F[1] ... F[fj]
•
F[m] contains a ﬁrewall rule R
•
1 ≤ m ≤ fj
•
F is order-sensitive. If Rx is a ﬁrewall rule at location
y in F, then the behavior of the ﬁrewall can be
different if Rx is located at position z instead of y,
where z:1→ fj and z ̸= y. Whether or not the behavior
is different depends on the relation Rx has with the
other rules of F.
D. Combinatorics
1) Ports: Port numbers are represented by 16-bit binary
number and thus go from 1 to 216. Assuming that only TCP
and UDP protocols are considered for OSI Layer 4 ﬁltering,
the possible number of values for Ports is equal to 2.216 = 217.
2) Services: S is the list of all possible services delivered
via all ports exposed on the network N.
Smax is the largest possible list of services, with length = sjmax,
in which all possible combinations of possible Ports are being
used, where
sjmax =
217
X
k=1
217
k

(1)
3) Hosts: The size of the list H, hj, is function of the
network N and expressed as hj = fh(N).
Hmax is the list of all possible lists of hosts that are part of H.
The length of this list is hjmax, where
hjmax =
hj
X
a=1
hj
a

(2)
and where hj = fh(N).
4) Services
on
Host:
The
maximum
number
of
Hosts/Services combinations = hjmax.sjmax =
hjmax.sjmax =
 hj
X
a=1
hj
a
!
.


217
X
k=1
217
k


(3)
where hj = fh(N).
5) Clients: The size of the list C, cj, is a function of the
network N. and expressed as cj = fc(N).
Cmax is the list of all possible lists of clients that are part of
C. The length of this list is cjmax where
cjmax =
cj
X
a=1
cj
a

(4)
where cj = fc(N).
6) Rules and rule base: In a rule R,
•
R.Source can contain any element of Cmax.
•
R.Destination can contain any element of Hmax.
•
R.Ports can contain any element of Smax.
•
R.Action is the maximum number of action combina-
tions, being 2 (“Allow” or “Deny”)
The ﬁrewall rule base Fmax contains all possible rules that
can be made with Cmax, Hmax and Smax
fjmax = 2.cjmax.hjmax.sjmax
(5)
fjmax = 2.
 cj
X
a=1
cj
a
!
.
 hj
X
a=1
hj
a
!
.


217
X
k=1
217
k


(6)
where cj = fc(N) and hj = fh(N)
The possible design space for a rule base is phenomenal.
Multiple rules can deliver one particular required functionality.
Choosing the right rule is a real challenge. As the network
grows and fc(N) and fh(N) grow, choosing the right ﬁrewall
rule from the design space becomes even more difﬁcult. To
gain control over the design space, it needs to be consciously
reduced.
E. Designing an evolvable rule base
A rule will be made up of:
•
Cs representing the Source, where Cs⊂ Cmax.
•
Hd representing the Destination, where Hd⊂ Hmax.
•
Sp representing the Ports, where Sp ∈ Smax.
•
Action is to be “Allow” as each rule in the rule
base explicitly provides access to allowed services on
allowed hosts.
•
R = (Cs, Hd, Sp, “Allow’)
Note that the last rule in the rule base F, F[fj] has to be
the default deny rule (Rdefault deny) as, when no rule explicitly
provides access to a service on a host, the trafﬁc needs to be
explicitly blocked.







Rdefault deny.Source = ANY,
Rdefault deny.Destination=ANY,
Rdefault deny.Port= ANY,
Rdefault deny.Action = “Deny”.
From Section III-B, it is known that:
•
A Firewall rule base is order-sensitive.
•
Different types of relations/coupling can exist between
rules.
•
If all rules are disjoint from each other, there is no
coupling between the rules.
•
If all rules are disjoint, the rule base is no longer order-
sensitive.
•
If a new rule is added to the rule base and it’s disjoint
with all existing rules, then the location of the rule in
the rule base is not important.
If the whole ﬁrewall rule base needs to be checked to
see if a rule is disjoint to all existing rules, a CE is being
introduced. Introducing a new rule to, or removing a rule
from the system should result in work that is proportional to
the newly required functionality and not into work, that has
no logical link to the required functionality and that requires
searching throughout the whole system (being the entire rule
base). Or as NS formulates it: the impact of the change should
be proportional to the nature of the change itself, and not
proportional to the system to which the change is applied.
Disjoint rules have no overlap in source or destination or
ports. The following combinations are possible:
•
No overlap in sources - do not care about destination
and port overlaps.
6
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

•
No overlap in destinations - do not care about source
and port overlaps.
•
No overlap in ports - do not care about source and
destination overlap.
•
No overlap in source-destination combination, do not
care about ports.
•
No overlap in source-ports combinations, do not care
about destinations.
•
No overlap in destination-ports combinations, do not
care about sources.
•
No overlap in source-destination-port combination.
Cs is fc(N) and Hd is fh(N). The network is an
uncontrollable variable. Trying to ﬁnd a way to structure Cs
and Hd to allow for disjoint rules starting from this variable,
will not yield to anything useful. On the other hand, Sp
represents the ports and is bound: the nature of TCP/IP limits
the number of possible ports and thus all port combinations.
It thus makes sense to look for a way to guarantee that there
is no overlap at port/service level.
Let us consciously restrict Sp to Su, so that Su only
contains unique values.
 ∃!Su[m] in Su for m:1→suj.
Su[u] ∩ Su[v] = ∅, where u, v:1→suj, and u ̸= v
If each service is represented by 1 port, Su will contain
217 elements, which is the max size of Su in this restricted
case.
The service Su[m] can be delivered by many hosts.
Let HdSu[m] represent the list of hosts that offer service
Su[m].







HdSu[m] ⊂ Hmax and HdSu[m][x] contains a single host.
HdSu[m] contains unique and disjoint elements.
∃!HdSu[m][x] in HdSu[m]for x:1→hdm
HdSu[m][u] ∩ HdSu[v] = ∅, where u, v:1→hdmj, and u ̸= v
Combining hosts and services (HdSu[m][x],Su[m]) where
x:1→hdmj, gives a list of tuples that are disjoint. This hold
for all m:1→suj. At this point, all services and hosts who
deliver the services, form tuples that are disjoint and can thus
be used as a basis for creating an order independent ﬁrewall
rule base. CsHdSu[m][x] is the list of clients that have access to
service Su[m], deﬁned on host HdSu[m][x].
By using :
•
Su[m] where m:1→suj, with suj=number of disjoint
services offered on the network, for deﬁning R.Port
•
HdSu[m][x], x:→hdmj, with hdmj=number of hosts
offering Su[m], for deﬁning R.Destination
•
CsHdSu[m][x] being the list of clients requiring access to
service Su[m] on host HdSu[m][x], of length = cjs, for
deﬁning R.Source
•
“Allow”, for R.action
disjoint rules are being created, usable for an evolvable ﬁrewall
rule base.
F. The artifact
What has been discussed in the previous section needs
to be transformed into a solution usable in a real ﬁrewall.
As discussed in Section III-C, ﬁrewalls work with groups.
Groups can be used to represent the concepts discussed in the
previous sections.
1)
Starting from an empty ﬁrewall rule base F. Add as
ﬁrst rule the default deny rule F[1]= Rdefault deny with







Rdefault deny.Source = ANY,
Rdefault deny.Destination=ANY,
Rdefault deny.Port= ANY,
Rdefault deny.Action = “Deny”.
2)
For each service offered on the network, create a
group. All service groups need to be completely
disjoint from each other: the intersection between
groups must be empty.
Naming convention to follow:
•
S service.name,
•
with service.name as the name of the service.
3)
For each host offering the service deﬁned in the
previous step, a group must be created containing
only one item (being the host offering that speciﬁc
service).
Naming convention to follow:
•
H host.name S service.name,
•
with host.name as the name of the host offer-
ing the service
4)
For each host offering the service from the ﬁrst step, a
client group must be created. That group will contain
all clients requiring access to the speciﬁc service on
the speciﬁc host.
Naming convention to follow:
•
C H host.name S service.name
5)
For each S service.name,H host.name S service.name
combination, create a rule R with:







R.Source =C H host.name S service.name
R.Destination = H host.name S service.name
R.Port= S service.name
R.Action = “Allow”
Add those rules to the ﬁrewall rule base F.
The default rule Rdefault should always be at the end
of the rule base.
By using the artifact’s design principles, group objects are
created that form the building blocks for an evolvable rule
base. Each building block addresses one concern.
If each service of Su is made up of only one Port, then the Su
will contain maximum 217 elements, resulting in maximum
217 service groups S service.name being created. For each
host, maximum 217 services can be deﬁned, expressed in
H host.name S service.name destination groups. According
to the artifact, one rule per host and per service, must be
created. This reduced the rule base solution space from
2.
 cj
X
a=1
cj
a
!
.
 hj
X
a=1
hj
a
!
.


217
X
k=1
217
k


(7)
where cj = fc(N) and hj = fh(N)
to:
fj = hdj.suj + 1 = hdj.217 + 1
(8)
with hdj = number of hosts connected to the network.
hdj = fh(N). The “+1” is the default deny rule Rdefault deny
7
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

V.
DEMONSTRATE AND EVALUATE ARTIFACT
In this section, we will demonstrate the artifact. We will
apply different changes on a rule base (add/remove rule) and
on the components that make up rule (add/remove a service,
add/remove a host, add/remove a client). We also show what
happens if rules are aggregated. The section terminate with an
evaluation of the proposed artifact.
A. Add and remove a rule
Creating rules according to the artifact’s design principles,
leads to rules that are disjoint from each other. Disjoint rules
can be added and removed from the ﬁrewall rule base without
introducing CE’s.
B. Adding a new service to the network
A new service is a service that is not already deﬁned in
Su. The new services results in a new deﬁnition of a service
being added to Su. The artifact prescribes that a new group
S service.name must be created for the new service. The group
will contain the ports required for the service. For each new
host offering the service, the artifact prescribes to create a
new group destination H host.name S service.name, and an
associated source group C H host.name S service.name. The
destination groups are populated with only one host (the host
offering the service). The source groups are populated with all
clients requiring access to the service one speciﬁc host. All
building blocks to create the disjoint rules are now available.
For each host offering the new service, a rule must be created
using the created groups. No CE’s are being introduced during
these operations. Adding the new rules to the rule base does
not introduce CE’s (see Section V-A).
C. Adding a new host offering existing services, to the network
A new host is a host that is not already deﬁned in
Hd. The new host results in a new host deﬁnition be-
ing added to Hd. The artifact prescribes that a new group
H host.name S service.name must be created for each ser-
vice delivered by the host and a corresponding source group
C H host˙name S service.name must be created as well. The
destination groups are populated by their corresponding hosts.
The source groups are populated with all clients requiring
access to the service on that host. All building blocks to create
the disjoint rules are now available. For each service offered by
the new host, a rule must be created using the created groups.
No CE’s are being introduced during these operations. Adding
the new rules to the rule base does not introduce CE’s (see
SectionV-A).
D. Adding a new host offering new services, to the network
Combining Sections V-C and V-B delivers what is required
to complete this type of change. The artifact prescribes that
new service groups must be created for new services. An equal
amount of destination groups needs to be created and each
populated by the new host. The same amount of source groups
needs to be created and populated by the clients requiring
access to one of the new services on the new host. All building
blocks to create the disjoint rules are now available. For each
combination (new host, new service), a rule must be created
using the created groups. No CE’s are being introduced during
these operations. Adding the new rules to the rule base does
not introduce CE’s (see Section V-A).
E. Adding a new client to the network
Adding a new client to the network does not require
the creation of new rule building blocks or the addition of
new rules. The new client only needs to be added to those
source groups that give access to the required services/hosts
combinations. No CE’s are being introduced during these
operations.
F. Removing a service from the network
Let sr be the service that needs to be removed from the
network. The name of the service is sr.name=sremove. The
service is part of Su. The group corresponding with sr is
S sremove. The hosts offering the service correspond with
the groups H host.name S sremove. The clients consuming
the service are deﬁned in C H host.name S sremove. All
building blocks to identify the rules that require removing from
the rule base are now available. For each host offering sr, the
corresponding rule







Rdefault deny.Source = C H host.name S sremove
Rdefault deny.Destination=H host.name S sremove
Rdefault deny.Port= S sremove
Rdefault deny.Action = “Allow”
must be removed from the rule base. No CE’s are being
introduced during these operations. Removing rules from the
rule base does not introduce CE’s (see Section V-A). The
service sr needs to be removed from Su as well as the
corresponding group S remove in the ﬁrewall.
G. Removing a host from the network
Let hr be the host that needs to be removed from the
network. The name of the host is hr.name=hremove. The
host is part of Hd. There will be as much destination groups
for hr as there are services offered by hr. They are deﬁned
by H hremove S service name. The same holds form the
source groups, deﬁned by C H hremove S service.name. All
building blocks to identify the rules that require removal from
the rule base are available. For each service offered by hr, the
corresponding rule







Rdefault deny.Source = C H hremove S service.name
Rdefault deny.Destination=H hremove S service name
Rdefault deny.Port= S service.name
Rdefault deny.Action = “Allow”
must be removed from the rule base. No CE’s are being
introduced during these operations. Removing rules from the
rule base does not introduce CE’s (see Section V-A). The host
hr needs to be removed from Hd and the corresponding groups
H remove S service.name in the ﬁrewall, must be removed as
well.
H. Removing a service from a host
Let sr be the services with sr.name=sremove, which
needs removing from host hr with hr.name = hremove. The
service is part of Su. The group corresponding with sr is
S sremove. The destination group for service sr on host hr,
is H hremove S sremove. The corresponding source group is
C H hremove S sremove. All building blocks to identify the
rule 






Rdefault deny.Source = C H hremove S sremove
Rdefault deny.Destination=H hremove S sremove
Rdefault deny.Port= S sremove
Rdefault deny.Action = “Allow”
8
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

which require removing from the rule base are available. No
CE’s are being introduced during these operations. Removing
rules from the rule base does not introduce CE’s (see Sec-
tion V-A). The service sr does not need to be removed from
Su and neither does the corresponding group as the service is
still offered on other hosts.
I.
Removing a client from the network
Let cr be a client that needs to be removed from the
network. The client is part of Cs. Removing a client from
the network does not require removing rules from the rule
base. The client needs to be removed from the different source
groups that provide the client access to speciﬁc services on
speciﬁc hosts. If the services and hosts to which the client has
access are known, then the source group from which the client
needs to be removed, are known as well. If the services and/or
hosts are not known, then an investigation of all the source
groups is required to see if the client is part of the group or
not. If part of the group, the client needs to be removed. The
client also needs to be removed from Cs. Determining if a
client is part of a source group can be considered as a CE as
all source groups require inspection.
J. The impact of aggregations
When following the prescriptions of the artifact, many
groups and rules will be created (see Section V-K for more
details). The urge to aggregate and consolidate rules into
more general rules, will be a natural inclination of ﬁrewall
administrators as a smaller rule base will be (wrongfully)
considered as a less complicated rule base. However, any form
of aggregation will result in loss of information. It is because
the artifact consciously enforces ﬁne-grained information in
the group naming and usages that disjoint rules can be created
and the ZT model can be enforced. If due to aggregations
it can no longer be guaranteed that rules are disjoint, then
a CE-free rule base can no longer be guaranteed either.
Aggregation will also lead to violations of the ZT model.
We provide two examples of aggregations.
Aggregation at service level: all hosts offering the same
service are aggregated into one destination group. Such an
aggregation excludes the possibility of specifying that a client
needs access to a speciﬁc service on a particular host. A
client will have access to the service on all hosts offering
the service, desired or not. In such a conﬁguration, ZT can
no longer be guaranteed. As long as the services on the
network are unique, so will be the port groups. Rules will
stay disjoint and the rule base CE-free. The moment that one
starts combining ZT and non-ZT rules, non-disjoint rule will
pop-up. The rule base can no longer be guaranteed to be
CE-free.
Example: if for some reason, it cannot be allowed that a client
has access to the service on all hosts and a special service
group is being created (no longer disjoint with the existing
service group) with a special associated destination group
(no longer disjoint with existing destination groups), the rule
created with those groups is not disjoint with existing rules
in the rule base and the effect of adding this rule to the rule
base is no longer guaranteed CE-free.
Aggregation at host level: all services offered on a host
are aggregated into one host-bound port/service group. The
aggregation method excludes specifying that a client needs
access to some of the services on the host. A client will have
access to all services deﬁned on the host, desired or not. In
such a conﬁguration, ZT can no longer be guaranteed. As long
as the destination groups are unique, disjoint rules can still be
created. The moment that ZT and non-ZT rules are combined,
non-disjoint rule will pop-up. The rule base can no longer be
guaranteed CE-free.
Example: if for some reason, it cannot be allowed that a client
has access to all services on the host and a special service
group is being created (no longer disjoint with existing service
groups) with a special associated destination group (no longer
disjoint with existing destination group), the rule created with
those groups is not disjoint with existing rules in the rule base
and the effect of adding this rule to the rule base is no longer
guaranteed CE-free.
K. Evaluation
The
previous
demonstrates
that,
when
applying
the
artifact, the rules are guaranteed to be disjoint and adding
and removing such rules has no unwanted side effects on
the existing rule base. Such a rule base will be ﬁne-grained
(i.e., having many rules). The size of the rule base might
be consider this as a drawback. Large size is often regarded
as complex. A large size rule base may also impact ﬁrewall
performance, as surching for a matching rule in a large
rule base, has a direct impact on ﬁrewall performance. In
Section
VIII, the impact of rule base size on performance
is further investigated. Some operations on rules may indeed
result in CE’s at group level, such as adding and removing
a client from the network. Aggregations will violate the ZT
constraint. Combining aggregation and non-aggregation based
rules results in non-disjoint rules and CE’s at rule base level.
VI.
FILTERING STRATEGIES
The artifact discussed in the previous section was created
to be compliant with the ZT ﬁltering strategy. In this section,
we will discuss other ﬁltering strategies: Interconnect strategy
and Outbound ﬁltering and see what kind of impact they have
on the artifact.
A. Interconnect ﬁltering strategy
The ZT ﬁltering strategy can be considered as an inbound
ﬁltering strategy. Only trafﬁc corresponding with exposed
services is allowed. The ﬁltering strategy used to interconnect
different network segments and control the trafﬁc between
those segments is an Interconnect (IC) ﬁltering strategy. The
focus is on trafﬁc between network segments, like VLANs
or groups of VLANs, and not on the resources connected to
those network segments. The rules are different compared to
ZT rules. The level of granularity is a network subnet, not the
resource. Filtering does not happen at port/service level. This
means that there is one less parameter to enforce disjointness
between the rules.
The proposed artifact can still be used to create an IC
strategy based rule base. The group objects used in an IC
strategy rule base would represent the following:
•
Destination group: a group containing the IP ad-
dresses, expressed in subnets (VLAN’s), that make up
a logical part of the network.
9
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

•
Source group: a group of IP addresses expressed in
subnets (VLAN’s), that make up a logical part of the
network.
The VLANs can be organized in different ways. They can
be organized according to a physical location or organizational
department. In the former case, there is a VLAN per building
ﬂoor, and the sum of all VLANs represents the building. In the
latter case, there are VLANs per organizational unit, grouped
in different parts of the building. The sum of all VLANs based
organizational units in the building represents the full building.
In ZT based ﬁltering, the most ﬁne-grained component
ﬁltering is performed at, is the port. In IC based ﬁltering, the
most ﬁne-grained component ﬁltering is performed at, is the
VLAN. The design of the rule base will be structured around
the VLAN.
Using the artifact previously designed artifact:
•
Start from an empty ﬁrewall rule base F. Add as the
ﬁrst rule; the default deny rule.
•
For each VLAN requiring access control, create a
destination group. Populate the group with the relevant
IP address ranges representing the VLAN. The inter-
section between all groups must be empty! A VLAN
cannot be present in 2 different logical parts of the
network and thus in 2 groups. The naming convention
of those groups: D VLAN-LogicalName-VLANnr
•
For each part of the network, which requires potential
shielding from other parts of the network, create a
source group. Populate the source group with the
VLAN’s that require access. The naming convention
of those groups: S D VLAN-LogicalName-VLANnr.
•
For each VLAN that requires protection, create a rule:
◦
Source: S D VLAN-LogicalName-VLANnr
◦
Destination: D VLAN-LogicalName-VLANnr
◦
Protocol: ANY
The D VLAN-LogicalName-VLANnr groups will enforce
the disjointness of the rules in the rule base. Add, remove,
change operation on a rule base created according to the
artifact are compliant with the evolvability conditions. It should
be clear that this kind of ﬁltering cannot be combined with ZT
based ﬁltering. The disjointness of rule cannot be guaranteed
if ZT and IC based rules are used in the same ﬁrewall rule
base:
•
Protocol: violates disjointness
•
Destination: ZT rules will be a subnet of IC rules and
thus violate disjointness.
•
Source: is not used to enforce disjointness
An example of an IC strategy use case is the merger
between two companies. Each has their network. As long as the
security policies are not aligned between both companies, there
is a good reason not to interconnect the two networks directly.
The interconnection is best done via a ﬁrewall. The ﬁrewall
will ﬁlter between IP ranges, for instance, allowing trafﬁc
between the two headquarters, but not yet between remote
sites (simpliﬁed example, not considering potential IP range
overlap, NATing etc.).
As change is the only constant in companies, IC based
ﬁltering is complicated. Moves between buildings, reorgani-
zation in buildings, add and removal of sites, organizational
changes, all make upfront, and stable segmentation of a
network difﬁcult. Segmentation rules change, segmentation
principles are mixed, and logical network segments no longer
Figure 4. Inbound and outbound on a single ﬁrewall
become disjoint. The result will be evolvability issues in the
rule base(s) and unforeseen side effects due to changes. Till
now, the IC problem has been addressed in a network-centric
approach. As network segmentation and company organiza-
tion can result in implementation conﬂicts, solutions such as
identity-based ﬁrewalls emerged. In those solutions, IC’ based
ﬁltering happens based on the identity of the user. When a
user tries to connect to certain parts of the network and hits
an identity-based ﬁrewall enforcing the IC, the ﬁrewall will
check the identity of the user and will ﬁlter based on this
identity. This only works if:
•
The ﬁrewall can establish the identity of the user
associated with the source (who’s working on PC with
IP = x.y.z.u).
•
The ﬁrewall has access to a DB containing the iden-
tities and has mechanisms to validate the identity.
•
The ﬁrewall has a set of rules stating which identity
has access to which destinations.
Such a setup is more user-centric. Access to the network
is linked to the identity of the user and not the building or
organizational layout. Elegant as the solution may seem, it
just shifts the problem from the network space to the identity
space. This research will not further investigate this. However,
it is worth pointing out that, user identities, identify veriﬁca-
tion (authentication), identity authorization, identity deﬁnition,
identity implementation, identity and HR policies, identity syn-
chronization solutions, are among the most complex IS systems
of an IT landscape. Researching the associated evolvability
issues and proposing solutions is worthy of a separate Ph.D.
research.
B. Inbound and outbound ﬁltering strategy
An inbound ﬁltering strategy, as ZT, will ﬁlter trafﬁc close
to the destination. The outbound ﬁltering strategy will ﬁlter
close to the source. From a security point of view, it makes
sense to stop the trafﬁc as early as possible on the network.
On a single ﬁrewall, the notion of inbound and outbound
is relative. A ﬁrewall rule base is not aware of inbound or
outbound. It only knows source and destination and both can
be located on the two sides of the ﬁrewall.
The artifact we propose started from a scenario where all
sources are located on the left and all destination to the right
of the ﬁrewall, effectively implementing an inbound ﬁltering
strategy. The same artifact can be used in a single ﬁrewall
setup where sources and destination are located at both sides
of the ﬁrewall. As long as the artifact is strictly followed,
all rules will stay disjoint. There are some dangers involved.
Take the case described in Figure 4 where a host1, located on
the left side of the ﬁrewall, needs to access a host2 on the
right side. Host2 also requires access to a service offered by
host1. According to the artifact, the 2 following rules would
10
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

be created.
•
C H host2 S Y, H host2 S Y, S Y, Allow
◦
trafﬁc from left to right
◦
H host2 S Y contains host2
◦
C H host2 S Y contains host1
•
C H host1 S X, H host1 S X, S X, Allow
◦
trafﬁc from right to left
◦
H host1 S X contains host1
◦
C H host1 S X contains host2
What the ﬁrewall will do internally is look at the content of the
groups, not the group names itself, and the rules are internally
translated as
•
host1, host2, Y, Allow
•
hotst2, host1, X, Allow
Both host1 and host2 are member of different group. Inter-
chaning those groups will result in rules which do not follow
the logic of the artifact but that do represent the same rules
inside the ﬁrewall
•
H host1 S Y, C H host1 S Y, S X, Allow
◦
host2, host1, X, Allow
•
H host2 S Y, C H host1 S X, S Y, Allow
◦
host1, host2, Y, Allow
Group objects are used to increase the manageability of
rule bases. The above makes it clear that, if not used cor-
rectly, manageability will decrease. Groups created to represent
destinations cannot be used to represent souces in rules, and
vise versa. This is a manifestation of Separation of Concern.
Representing sources and destination are different concerns.
They should not be mixed.
Inbound and outbound ﬁltering are also two different
concerns. In the above scenario, both are mixed on one
ﬁrewall yet, no immediate impact seems to surface. The impact
will become visible when there are multiple ﬁrewalls in the
network. This will be discussed in the next section.
VII.
MULTIPLE FIREWALLS
In the previous sections, the assumption was taken that the
network only contains one ﬁrewall. In this section, we will
investigate the impact of multiple ﬁrewalls between the source
and the destination.
A. The serial ﬁrewall ﬁltering function
Let Pa be a package traveling over the network.
•
Pa.source = the IP adress of the source sending
package Pa.
•
Pa.destination = the IP address of the destination for
package Pa.
•
Pa.port
=
the
Port
targetted
on
destination
Pa.destination.
Let φf(Ff,Pa) be the ﬁrewall ﬁltering function that takes
rule base Ff and package Pa as input.







φf(Ff,Pa) = 0 if the package is blocked
- there is no rule R in Ff such that the package is allowed
φf(Ff,Pa) = 1 if the package is allowed
- there is a rule R in Ff such that the package is allowed
Figure 5. Multiple ﬁrewalls in a network
Let f total be the total amount to ﬁrewalls in a given
network. Let Φsfw be the serial ﬁrewall ﬁltering function for a
network path containing fw ﬁrewalls in serie. Then
Φs
fw(Pa) =
f=fw
Y
f=1
φf(Ff, Pa)
(9)
Φs
fw(Pa) = φ1(F1, Pa).φ2(F2, Pa)...φfw(Ffw, Pa)
(10)
Where:









fw : 1 → f total
Φs
fw(Pa) = 0 if Pa is blocked by at least one of the
fw ﬁrewalls
Φs
fw(Pa) = 1 if Pa is allowed by all fw ﬁrewalls
See Figure 5 for a graphical representation of these concepts.
B. Applying the rules on some ﬁrewalls
In a given network, fw and thus Φsfw, will differ from the
location of the source, destination, and the internal routing of
the network. Let us assume that in such a network, all ﬁrewalls
have an evolvable rule base according to the proposed artifact.
The addition of a new resource, host new offering service
S new, requires the addition of new rules Rnew, such that
host new is protected according to the ZT ﬁltering strategy.
Let us assume that Rnew is only implemented on the ﬁrewalls
in the path between the initially identiﬁed sources (members
of C H host new S new), and destination host new. As time
moves on, the initially identiﬁed sources require modiﬁcation:
a new client needs to access the host, or a client is removed
from the network.
According to our artifact, adding or removing a client is
just a question of adding and removing the client from the
group C H host new S new. In our current scenario, this is
no longer the case. If a new client has a different network
path towards the host new compared to the path in which the
rule Rnew was initially implemented, then the rule Rnew must
now be implemented on the all ﬁrewalls in the path between
the new client and host new as well. In addition, the source
group must be updated on all ﬁrewalls in all paths between all
current clients and host new. As the possible network paths are
a function of the network, and the network can grow inﬁnitely,
a CE is being introduced. This is the worst kind of CE, as we
will not know upfront where adjustments are required, and the
11
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 6. Apply the rules on some ﬁrewalls
full investigation of the network is required. An example of
the described scenario can be found in Figure 6.
C. Applying the rules on all ﬁrewalls
The only way to avoid the problem described in the
previous section, is to have all ﬁrewalls contain the same rule
base. All manipulations of rules must be done on all ﬁrewalls
simultaneously. As the network grows, so will the number of
ﬁrewalls, and again, a CE is being introduced. This CE is less
aggressive as it is know now the manipulations are required on
all ﬁrewalls. We have already discussed the impact of the size
of the rule base on the ﬁrewall. Having to duplicate all rules
all over the network will make the rule base even larger and
less coherent. Rules are added to ﬁrewalls, which will never
be activated, and groups contain objects that are not relevant
to the context of that speciﬁc ﬁrewall. The manageability of
the ﬁrewalls will decrease. All ﬁrewalls are addressing the
same concern. Normalized Systems learns that this will have
a negative impact on evolvability, as can be concluded from
the above.
D. Restricting Inbound trafﬁc ﬁltering
The paper “Minimizing the Maximum Firewall Rule Set in
a Network with Multiple Firewalls” [31] is closely related to
the problem we are trying to solve. According to [31], placing
ﬁrewalls in a network such that the rule base is minimal, is
an NP-complete problem, which requires a heuristics-based
approach. Although applying the heuristic-base algorithm de-
scribed in [31] may minimize the rule base over all ﬁrewalls,
the evolvability of those rule bases is not discussed.
In Section VI-B, we mentioned that a network with one
ﬁrewall is combining both inbound and outbound ﬁltering
rules. If we have a network with two ﬁrewalls that are
connected in a back-to-back conﬁguration - meaning the
ﬁrewalls are directly interconnected and no resources are
located in this interconnection - inbound and outbound trafﬁc
ﬁltering can be separated. This can be done by adding a
new default rule, which states that all outbound trafﬁc is
allowed. Figure 7 illustrates the setup, while Algorithm 1 and
Algorithm 2 show the construction of the rule bases of F1
and F2.
The rules R1 on both ﬁrewalls are disjoint with respect to
the rule base in which they are located as:
•
on F1: C H F1Any S Any - represents all hosts
protected by inbound trafﬁc by F1
Figure 7. back-to-back ﬁrewalls
Rules Firewall F1
R1: C H F1Any S Any, H F1Any S Any,
S Any, Allow
R2: C H host1 S X, H host1 S X, S X, Allow
R3: Any, Any, Any, Deny
with group contents
in R1: H F1Any S F1Any: any
in R1: S F1Any: any
in R2: C H host1 S X: all hosts needing
access to host1, host2 in this case
in R2: H host1 S X: host1
in R2: S X: port X
Algorithm 1: Rule base of F1
•
on F2: C H F2Any S Any - represents all hosts
protected by inbound trafﬁc by F2
•
C H F1Any S Any ∩ C H F2Any S Any = ∅
and
•
All
source
groups
on
F1
are
subsets
of
C H F2Any S Any - represents all hosts protected
by inbound trafﬁc by F2
•
All
source
groups
on
F2
are
subsets
of
C H F1Any S Any.
Thus, on both F1 and F2, the default outbound rule is disjoint
with all other groups.
We see here appearing Separation of Concern. The concern of
protecting a resource is only assigned to one ﬁrewall. If given
to multiple ﬁrewalls, evolvability issues will occur. The leads
to the following design criteria:
•
A ﬁrewall should be clearly assigned to protect a set
of resources. Those resources are protected by the
ﬁrewall via the inbound ZT trafﬁc ﬁltering strategy.
•
The ﬁrewall allows all outbound trafﬁc from the set
of resources it protects, to the rest of the network.
Rules Firewall F2
R1: C H F2Any S Any, H F2Any S Any,
S Any, Allow
R2: C H host2 S Y, H host2 S Y, S Y, Allow
R3: Any, Any, Any, Deny
with group contents
in R1: H F2Any S F2Any: any
in R1: S F2Any: any
in R2: C H host2 S Y: all hosts needing
access to host2, host1 in this case
in R2: H host2 S X: host2
in R2: S Y: port Y
Algorithm 2: Rule base of F2
12
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

Figure 8. Path with multiple ﬁrewalls
•
If all ﬁrewalls are protecting their resources, there is
no need for outbound ﬁltering.
As illustrated, our artifact can be made compliant with such
as setup, simply by adding the “default allow” rule and the
creation of some extra groups.
The approach described above might be turned around: by
default allow all inboud trafﬁc and ﬁlter on outbound trafﬁc.
Separation of Concerns would be respected. The artifact would
need to be revised as disjointness would need to be enforced
based on the combination of Service and Source instead of
Service and Destination. The same reasoning applies for a
the inbound default allow rule. Although technically possible,
this ﬁltering strategy would be confusing. Compare with the
following scenario: A city needs to close an entry road due
to construction works. Trafﬁc will be blocked as close to the
yard as possible (inbound ﬁltering). It is impossible to block
all roads, which could potentially lead to the city (outbound
ﬁltering).
E. Multiple ﬁrewalls revised
What happens when there are more than 2 ﬁrewalls be-
tween 2 resources? Figure 8 illustrates the setup. If we apply
the design criteria from the previous section, we have to
conclude that F2 to Ffw-1 are not allowed to ﬁlter inbound
trafﬁc. Those concerns are already assigned to F1 and Ffw.
Firewall F2 to Ffw-1 must handle other concerns such as:
•
chokepoint: Use a ﬁrewall as a kind of valve: allow
all or deny all. This comes in handy in case of network
intrusions, and trafﬁc needs to be blocked asap in a
simple way, without impacting existing routing.
•
Interconnect ﬁltering strategy: use those ﬁrewalls to
control connectivity between network segments (see
Section VI-A).
Note that for the Interconnect ﬁltering strategy, Separation of
Concern needs to be respected as well. A “IC” ﬁrewall should
be assigned to handle the interconnect of assigned ranges,
and no other “IC” ﬁrewall should ﬁlter on the same ranges.
This can again become quickly complex and evolve into an
NP-complete problem. The best advice is to refrain from the
usage of “IC” and chokepoint ﬁrewalls, limiting the number
of ﬁrewalls in any network path as much as possible.
VIII.
ADDITIONAL ASPECTS OF FIREWALL RULES BASES
Applying the Normalized Systems Principles results in a
ﬁne-grained modular structure. The creation of an evolvable
ﬁrewall rule base is no exception; it leads to a ﬁne-grained
rule base. Creating and managing a large rule base requires
automation, and a large rule base may lead to performance
issues. In this section, the scalability of an evolvable rule base
will be disussed, together with a possible approach to automate
the creation and management of an evolvable rule base. The
section ends with a reﬂection on Software Deﬁned Networks
(SDN) and Software Deﬁned Firewalls (SDF) and why SDF
has interesting evolvabilty features.
Figure 9. Scaling of Firewalls with normalized rule base
A. Scaling
In an evolvable rule base, all the rules are disjoint from
each other and every network package can only hit one rule.
This rule can be located in the beginning or near the end of
the rule base. As there is only one rule that can be hit, the rule
base can be split in multiple pieces and distributed parallelly
over different ﬁrewalls. Let F be a ﬁrewall rulebase containing
only disjoint rules, created according to the artefact described
in Section IV-F. As visualized in Figure 9, F can be split in
fw sub rule bases, which are spread over fw parallel ﬁrewalls.
Each of the fw rule bases contains the “Default Deny” rule at
the end.
A network package will try to pass each of the ﬁrewalls,
but only one of the ﬁrewalls has a rule it can hit.
F =
f=fw
X
f=1
Ff
(11)
Let φf(Ff,Pa) be the ﬁrewall ﬁltering function that takes rule
base Ff and package Pa as input.
•
φf(Ff,Pa) = 0 if the package is blocked - there is no
rule R in Ff such that the package is allowed
•
φf(Ff,Pa) = 1 if the package is allowed - there is a
rule R in Ff such that the package is allowed
Let Φpfw be the parallel ﬁrewall ﬁltering function for fw
ﬁrewalls in parallel. Then
Φp
fw(Pa) =
f=fw
X
f=1
φf(Ff, Pa)
(12)
Φp
fw(Pa) = φ1(F1, Pa)+φ2(F2, Pa)+...+φfw(Ffw, Pa) (13)
Where:

















Φp
fw(Pa) = 0 if Pa is blocked by all of the
fw ﬁrewalls
Φp
fw(Pa) = 1 if Pa is allowed by one rule of one
of the fw ﬁrewalls, as:
∃!Ff ∈ F forf = 1 → fw =⇒ R ∈ Fj
This mechanism shows that the size of the evolvable rule
base does not matter, as the solution scales. Firewalls with a
13
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

non-evolvable rule base cannot scale the same way. Scaling
comes with a cost. Modern ﬁrewalls allow virtualization, but
each virtual instance comes at a cost as well.
In addition to the horiziontal scaling posibilities of an
evolvable rule base, the performance of an evolvale rule base
can be boosted by moving the most frequently used rules at
the top. A ﬁrewall vendor such as CheckPoint, suggests to put
the rules that are most frequently hit (and applied) at the top
of the ﬁrewall table. In a rule base that is order-sensitive, this
may be a real issue. In a rule base that is not order-sensitive,
one could monitor the ﬁrewall and see which rules are hit most
and move those rules around without having to worry about
the potential impact on other rules. Doing this dynamically
would even be more powerful as the ﬁrewall would be able to
reorganize his rules according to the trafﬁc of the day.
B. Automation
The creation of the ﬁne-grained rule base by humans can
be an issue. The procedure regarding deﬁnitions of the groups
needs to be followed strictly, and the creation of a catalog
of all possible services is a must. For standard services and
tools, lists of assigned ports/protocols and international stan-
dardization organizations related to the Internet (like iana.org)
exist and can be reused. The management of the groups, their
content, and the rules, should be done in a tool outside of the
ﬁrewall (see Figure 10). This tool could expand the ﬁrewall
rules in the ﬁne-grained format, according to the naming
conventions, performing checks against the group deﬁnitions
and content via a user-friendly interface. The tool could then
push the rules towards the ﬁrewall, effectively separating the
management of rules and implementation of rules. Such tools
exist on the market. Examples are Algosec, Tufﬁn, Firemon.
However, none of those tools consciously restrict the design
space and will thus enforce the creation of an evolvable rule
base.
Deﬁning a rule for each service may be considered cum-
bersome. Roles could be created, like ”monitoring and man-
agement”, which are a grouping of smaller, disjoint services.
The ﬁrewall administrator can create a rule specifying this
”monitoring and management” role, to express that the server
needs to allow access to all monitoring and management
services. The tool will expand this role into the individual
rules for each disjoint service. Example:
•
”Monitoring and Management” = SSH + SFTP + FTP
+ SMTP + TELNET
•
Host = x
•
Rule : C Hx SMaM; Hx S MaM; S MaM; allow
•
Will be expanded to :
◦
C Hx S SSH; Hx S SSH; S SSH; allow
◦
C Hx S SFTP; Hx S SFTP; S SFTP; allow
◦
C Hx S FTP; Hx S FTP; S FTP; allow
◦
C Hx S SMTP; Hx S SMTP; S SMTP; al-
low
◦
C Hx S TELNET;
Hx S TELNET;
S TELNET; allow
C. Software Deﬁned Network and Software Deﬁned Firewall
Pushing the inbound ﬁltering strategy discussed in previous
section to the limit equals providing each resource with its ﬁre-
wall. This is what is happening in a Software Deﬁned Network
(SDN) combined with a Software Deﬁned Firewall (SDF). In
an SDN, the network layer is virtualized inside a virtualization
Figure 10. Firewall Management Tool
layer called the hypervisor. The SDN is decoupled from the
actual underlying physical network. In the hypervisor layer,
network components such as routers, switches, VLANs, load
balancers, ﬁrewalls are all deﬁned entirely in software. To each
virtual host deﬁned in/on the hypervisor, a virtual ﬁrewall can
be attached. A package does not enter the network layer of the
virtual hosts unless it successfully passes the ﬁrewall. SDF is
better compared to an Operating System (OS)-based ﬁrewall
(like IP tables or Windows Group Policies). OS-based ﬁrewalls
can only perform their ﬁltering function if the package is
already ”inside” the host.
For an SDF, the rule base is conﬁgured by my means of
policies. A policy deﬁnes the protocol and port that can pass
though the ﬁrewall. The policies are attached to the ﬁrewall. As
the ﬁrewall is attached to only one host, by default, disjointness
for the destination is guaranteed. But, multiple policies can
be attached to one host, and in those policies, overlaps and
conﬂicts of protocols/ports and actions can be deﬁned. Again,
the conscious restriction of design space is required.
The previously proposed artifact can be adjusted for an
SDN context by creating policies for Software Deﬁned Fire-
walls. The policies are the equivalent of the Service Groups.
They must be as ﬁne-grained as possible. For each service
exposed on a host, a policy must be created. Policies cannot
overlap. Instead of creating a destination group, the polices are
being attached to the host. As many policies are attached to
the host as there are services offered by the host. Access to
the host is provided by giving explicit access of a client to the
host. This corresponds to creating a client group as deﬁned in
the artifact. Belonging to the group means you can access the
host, and the policy attached to the host will check authorized
protocols and ports.
A Software Deﬁned Firewall in a Software Deﬁned Context
is the best way to guarantee the ZT ﬁltering strategy. SDF
also offers the most evolvable setup. Add/remove of hosts to
the hypervisor automatically adds/removes the associated host
ﬁrewalls. Add/remove of rules means add/remove of policies
and/or attach/detach of policies. If the policies are created
according to the proposed artifact, evolvability is guaranteed.
IX.
DISCUSSION
By means of discussion, we will cover two items. First, we
will revisit the literature related to the size of the rule base,
followed by a reﬂection on the nature of the CE’s that are still
present when applying our proposed artifact.
14
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

A. Size of the rule base: revisiting the literature
The “Size of the rule base issue” is not treated as an
issue related to the stability of a system under change. To the
best of our knowledge, most contributions do not focus on
this point, whereas it is a corner stone of NS. The different
artifacts all start with ideas similar to “For each rule in the
ﬁrewall, do the following ...”. One might consider such an
approach as a CE in itself. There is attention to reducing
the rule base to a minimum list of rules, which still answer
to the ﬁltering requirements, motivated to the impact of the
size of the rule base on performance. However, in [16] it is
suggested that the actual size of the rule base is not related
to the way the hardware actually processing the rules. This
suggests a decorrelation between the size of the rule base and
the ﬁrewall performance. If this would be the case, why bother
about the reduction of the size of the rule base? In Section VIII
we pointed out that a rule base that has built-in evolvability,
can scale and thus circument the potential performance issues
due to its size. Non-evolvable rule bases cannot scale this
way. Scaling does come at a cost. Either in terms of the
purchase of more physical ﬁrewalls or adding resources to
ﬁrewalls which allow virtualization. The higher cost will result
in a ﬁrewall setup which will behave as is exptected. Security
always comes at a cost. Further research of the literature and
real-life measurements are required to clarify this point.
Looking at the combinatorics of Section IV-D, the design
space is enormous. By applying the artifact, there is a con-
scious reduction of the design space. But the size of the rule
base is still large as for each combination (host, service) a rule
must be created in the rule base.
217.hdj + 1
(14)
The maximum number of services is 217 = 131,072. However,
in reality this number will never be reached. A sample in Engie
(a multinational and world leader in energy services) on 100
servers revealed that on average 39 services are exposed. The
standard deviation in the sample is 14. It can be stated with
a statistical probability of 98% that a host exposes less then
67 services. The sample was taken from a population of 1,000
servers. Those 1,000 serves are currently protected by about
890 ﬁrewall rules. If the artifact would be applied, it would
mean implementing 67,000 rules. However, at Engie, a ZT
model at host level is not applied. Instead, ZT at VLAN level
is present (still ﬁlter at port level, but instad of at host level,
ﬁltering happens at VLAN level = a collection of hosts). If the
realistic assumption is a made that the 1,000 server are spread
over 20 VLAN’s, it would mean that 20 x 67 = 1,340 rules are
required for an evolvability rule base. This would mean 50%
more rules to gain full evolvability.
B. Remaining CE’s
The artifact proposed in the paper is not completely free
of CE. The evaluation has shown that there is are CE’s at the
level of groups. However, these CE’s are not related to the
technical coupling within the rule base but due to the size and
topology of the network. The bigger the network, the more
objects and rules. Such CE’s are considered acceptable given
that:
•
The actions leading to the CE can be automated
(search for, or through, groups)
•
The CE is predictable and is the logical effect of the
change which needs to be applied (remove a client =
look in all groups where the client is present)
CE’s which cannot be automated because their impact is not
predictable are not acceptable as there is no logical link
between the change and the extra work one needs to do to
implement the change. For example, the addition of a rule
to activate a service on the network that would require the
inspection of the whole rule base to ﬁnd conﬂicting rules (not
related to the newly activated service) would be considered as
an unacceptable CE. Note that the proposed artifact facilitates
the removal of such unacceptable CE’s.
X.
CONCLUSION
Firewall rule bases are typically non-evolvable systems.
Tools and literature exist on how to show and potentially
reduce the complexity and conﬂicts in ﬁrewall rule bases,
but practical guidance on how to make a rule base which
has proven evolvability by design, is lacking. Using the NS
paradigm and domain speciﬁc knowledge, we have proposed
an artifact which has the desired evolvability. The most impor-
tant drawback of the resulting rule base could be the size due
to its ﬁne-grained structure, although this should be further
analyzed in future research efforts. In addition to the proposed
artifact, the evolvability implications of ﬁltering strategies and
ﬁrewall placement, has been investigated, showing that the
Software Deﬁned Firewall, promisses evolvability in a multi
ﬁrewall network.
What is currently lacking is an acutal tool that could create,
push and manage ﬁrewall rule bases according to the outlined
principles of this paper. Having such a tool is one thing,
implementing it and proving that it inhances security and
operational efﬁcity related to security, is something completly
different. The creation of a tool in combination with the
organizational impact, are subject for future research.
Another topic for future reseach is the size of the rule
base. More real-life use cases are required to see to what
extend existing rule bases can be transformed into evolvalbe
rule bases, what the size of those rule bases will be and what
the cost if implementing such rule bases would be.
ACKNOWLEDGMENT
The authors would like to thank Stefan Thys, Frederik
Leemans and Stefan Biesbroeck for their help in writing and
editting the article, and Sam Gozin and Bruno De Becker for
providing the Engie operational data.
REFERENCES
[1]
G. Haerens and P. De Bruyn, “Using normalized systems to explore the
possibility of creating an evolvable ﬁrewall rule-base”, The 11th Interna-
tional Conferences on Pervasive Patterns and Applications (PATTERNS),
pp. 7-16, May 2019
[2]
Firemon
whitepaper,
“2017
State
of
the
ﬁrewall”,
URL
https://www.ﬁremon.com/resources/, [retrieved: April, 2019]
[3]
Firemon
whitepaper,
“2018
State
of
the
ﬁrewall”,
URL
https://www.ﬁremon.com/resources/, [retrieved: April, 2019]
[4]
M. Bennet, “Zero Trust Security: A CIO’s Guide to Defending Their
Business From Cyberattacks”, Forrester Research June 2017
[5]
H. Shel and A. Spiliotes, “The State of Network Security: 2017 to 2018”,
Forrester Research November 2017
[6]
Firemon
whitepaper,
“Firewall
cleanup
recommendations”,
URL
https://www.ﬁremon.com/resources/, [retrieved: April, 2019]
[7]
H. Mannaert, J. Verelst, and P. De Bruyn, “Normalized Systems Theory:
From Foundations for Evolvable Software Toward a General Theory for
Evolvable Design”, ISBN 978-90-77160-09-1, 2016
15
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[8]
H. Mannaert, J. Verelst, and K. Ven, “The transformation of requirements
into software primitives: Studying evolvability based on systems theoretic
stability”, Science of Computer Programming: Volume 76, Issue 12, pp.
1210-1222, 2011
[9]
H. Mannaert, J. Verelst, and K. Ven, “Towards evolvable software
architectures based on systems theoretic stability”, Software Practice and
Experience: Volume 42, Issue 1, 2012
[10]
P. Huysmans, G. Oorts, P. De Bruyn, H. Mannaert, and J. Verelst.- “Po-
sitioning the normalized systems theory in a design theory framework”,
Lecture notes in business information processing, ISSN 1865-1348-142,
pp. 43-63, 2013
[11]
G. Haerens, “Investigating the Applicability of the Normalized Systems
Theory on IT Infrastructure Systems”, Enterprise and Organizational
Modeling and Simulation”, 14th International workshop (EOMAS), pp.
123-137, June 2018
[12]
P. Johannesson and E. Perjons, “An Introduction to Design Science”,
ISBN 9783319106311, 2014
[13]
A.R. Hevner, S.T. March, J. Park, and S. Ram, “Design Science in
Information Systems Research”, MIS Quarterly: Volume 38, Issue 1 pp.
75-105, 2004
[14]
P. Eronen and J. Zitting, “An expert system for analysing ﬁrewall
rules”, In Proceedings of the 6th Nordic Workshop on Secure IT Systems
(NordSec 2001), pp. 100–107, November 2001.
[15]
M. Abedin et al., “Detection and Resolution of Anomalies in Firewall
Policy Rules”, In Proceedings of the IFIP Annual Conference Data and
Applications Security and Privacy, 2006, LNCS 4127, pp. 15–29
[16]
Y. Bartal, A. Mayer, K. Nissim, and A. Wool, “Firmato: A novel ﬁrewall
management toolkit”, Proceedings of the 1999 IEEE Symposium on
Security and Privacy, pp. 17-31, Oakland, California, May 1999
[17]
A. Wool, “Architecting the Lumeta ﬁrewall analyser”, In Proceedings of
the 10the USENIX Security Symposium, Washington DC, August 2001
[18]
S. Hinrichs, “Policy-based management: Bridging the gap”, In Proceed-
ings of the 15th Annual Computer Security Applications Conference,
Phoenix, Arizona, December 1999, IEEE Computer Society Press.
[19]
A. Mayer, A. Wool, and E. Ziskind. “Fang: A ﬁrewall analysis engine”,
In Proceedings, IEEE Symposium on Security and Privacy, pp. 177-187,
IEEE CS Press, May 2000
[20]
S. Hazelhurst, “Algorithms for analysing ﬁrewall and router access
lists”, Technical Report TR-WitsCS-1999-5, Department of Computer
Science, University of the Witwatersrand, South Africa, July 1999
[21]
E. Al-Shaer and H. Hamed, “Design and Implementation of ﬁrewall
policy advisor tools”, Technical Report CTI-techrep0801, School of
Computer Science Telecommunications and Information Systems, De-
Paul University, August 2002
[22]
E. Al-Shaer and H. Hamed, “Discovery of policy anomalies in dis-
tributed ﬁrewalls”, In Proceedings of the 23rd Conf. IEEEE Communi-
cations Soc. (INFOCOM 2004), Vol 23, No.1, pp. 2605-2616, March
2004
[23]
E. Al-Shaer and H. Hamed, “Taxonomy of conﬂicts in network security
policies”, IEEE Communications Magazine, 44(3), March 2006
[24]
E. Al-Shaer, H. Hamed, R. Boutaba, and M. Hasan, “Conﬂict classi-
ﬁcation and analysis of distributed ﬁrewall policies”, IEEE Journal on
Selected Areas in Communications (JSAC), 23(10), October 2005
[25]
A. Hari, S. Suri, and G.M. Parulkar, “Detecting and resolving packet
ﬁlter conﬂicts”, In INFOCOM (3),pp. 1203-1212, March 2000.
[26]
D. Monahan EMA, Research Summary: “Network Security Policy Man-
agement tools – Tying Policies to Process, Visibility, Connectivity and
Migration”, https://web.tuﬁn.com/network-security-policy-management-
tools-ema-research, [retrieved: April, 2019]
[27]
Algosec whitepaper, “Firewall Management: 5 challenges every com-
pany must address”, URL https://www.algosec.com/resources/ [retrieved:
April, 2019]
[28]
C. Cunningham and J.Pollard, “The Eight Business and Security Ben-
eﬁts of Zero Trust”, Forrester Reseach November 2017
[29]
W.R. Stevens, “TCP/IP Illustrated”, Volume 1, the Protocols, Addison-
Wesley Publishing Company, ISBN 0-201-63346-9, 1994
[30]
H. Zimmermann and J.D. Day, “The OSI reference model - Proceedings
of the IEEE”, Volume: 71, Issue: 12, Dec 1983
[31]
S.Chen, M. Yoon and Z. Zhang, ”Minimizing the Maximum Firewall
Rule Set in a Network with Multiple Firewalls”, IEEE Transactions on
Computers, Volume 59, No.2, 2010
16
International Journal on Advances in Security, vol 13 no 1 & 2, year 2020, http://www.iariajournals.org/security/
2020, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

