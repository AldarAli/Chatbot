The Dynamic Composition of Independent
Adaptations including Interferences Management
Sana Fathallah Ben Abdenneji, St´ephane Lavirotte, Jean-Yves Tigli, Ga¨etan Rey and Michel Riveill
Laboratory I3S (University of Nice-Sophia Antipolis / CNRS)
B.P. 145 06903 Sophia-Antipolis Cedex - France
{fathalla, stephane.lavirotte, tigli, gaetan.rey, riveill}@unice.fr
Abstract—Nowadays, software systems are becoming ever more
complex and are likely to evolve quickly. A challenge is being able
to adapt these systems and thus to integrate, swap or remove new
functionalities. Compositional adaptation provides a way to tackle
this at runtime. This situation, leads to satisfy new requirements
in software adaptation. Moreover, adaptations entities may be
developed independently and even can be speciﬁed by different
designers. Accordingly, the set of all adaptations that may be
deployed cannot be anticipated at design time. In such case,
they may interfere when they are composed. In this paper, we
propose an associative composition operation to support software
adaptation. In our research, we consider that the adaptation of
a running system is assimilated to the composition of the model
of the initial application (called initial graph) with new model
elements (graphs of adaptations).
Index Terms—software composition; adaptive software; inter-
ference management; graph transformation.
I. INTRODUCTION
Nowadays, software systems must be developed with the
capacity of being able to evolve quickly [1]. Software systems
must react to environments changes and consequently inte-
grate, swap or remove new functionalities. The compositional
adaptation approach [2] allows to change software units. In
compositional adaptation, the applications must be based on
a modular architecture with a loose coupling between the
software units composing it. The loose coupling between
component and its execution environment control facilitates
the dynamic reconﬁguration of components assembly. Accord-
ingly, Component Based Software Engineering is well-suited
for compositional adaptation [3]. We will use throughout
the paper the more general term adaptation or adaptation
entities to point out the modiﬁcation that will be done on the
application.
In this paper, we present an adaptation mechanism that
allows the dynamic composition of adaptation entities. In order
to support such composition, existing approaches consist either
in deﬁning explicitly dependencies between adaptation entities
or either in calculating all possible combinations between them
in order to choose the most appropriate [4]. Since the result of
the composition may depend on the order in which adaptations
are made, the number of combinations to be calculated from n
adaptations may be n!. In this paper we propose an associative
and a commutative composition mechanism that allows to
minimize the number of combination by construction. The
application resulting from adaptations composition will be
always the same, regardless of their order of composition.
Accordingly, there is no need for a designer to explicit
the order when deploying adaptation entities or to calculate
combinations. Using this mechanism, adaptations are added
or removed independently of each other. More speciﬁcally,
all resulting interferences (interactions) between adaptations
entities are handled automatically at the composition step.
Interference is deﬁned as ”a conﬂicting situation where one
adaptation that works correctly in isolation does not work
correctly anymore when it is composed with other adaptation”
[5]. These interferences should be managed in order to ensure
the consistency of the application after the adaptation process.
Moreover, since adaptation mechanism will modify only the
structure of the application, we model software applications
and adaptations entities by graphs. The main reason to choose
graph as a basis formalism is that it can deﬁne software
architecture easily as shown in [6]. The interference resolution
step will operate on the graph by applying a set of graph
transformation rules.
The remainder of this paper is organized as follows: next
section presents some related works. Then, Section III intro-
duces the model of our applications and details the example
that will be used all along the paper to illustrate our approach.
In Section IV, we detail formally our composition process
and how it addresses the issue of interference management.
Particularly, we show the associativity property that allows us
to offer a deterministic solution when we compose adaptation
entities. Then, we describe our implementation showing some
experimental results (Section V). Finally, we conclude in Sec-
tion VI on the contribution of this work and its perspectives.
II. RELATED WORK
Systems adaptation can be triggered by several causes.
Researchers have proposed a variety of methodologies for
the development of self-adaptive systems. This objective can
be achieved using reﬂective architecture-based mechanism
[7]. To fulﬁll software adaptation objective, there is several
representation of adaptations. As a consequence, the process
of the detection and the resolution of interference are related
to the used method. In this section, we mention some of
works that have contributed to tackle the interference problem,
all other related works are out of the scope of this paper.
This problem is considered as the violation of the constraints
deﬁned at design time of the system [7]. A system change
678
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

is valid only if the system satisﬁes the constraints after the
change. Otherwise, the change will be canceled. Barresi et
al. [8] deﬁne explicitly at design time the order in which
adaptation should be applied. This requires the knowledge of
all system adaptation at design time. But we have seen that we
need unanticipated adaptation entities that will be performed at
runtime and that can be loaded and unloaded at runtime. This
requirement has been included in K-Component Model [9].
Dowling et al. use graph transformation rules to separate the
adaptation code from the computational code and to perform
architecture adaptation. Furthermore, they are not interested in
the problem of interference. Similarly, Guennum et al. [10] use
graph transformation rules to perform software adaptation and
propose tree operators to compose rules. These operators allow
deﬁning an order between rules or select only one rule to be
executed. These operators need to be deﬁned at design time
and as a consequence require the knowledge of all possible
adaptations (contradictory with our constraint).
Another related area of research that relies on software
adaptation is the use of AOP (Aspect Oriented Program-
ming). David et al. [11] consider that software adaptation
is a crosscutting concern of the application and use aspects
to encapsulate adaptations code. In this area, the problem
of interference was well deﬁned and several solutions were
proposed. Greenwood et al. [3] investigate a solution to
interferences in the context of AO-Middleware platform. To
do that, they deﬁne interaction contract which is used at
runtime. These contracts express several strategies to resolve
interferences such as priority, precedence and logical operators
(to combine contracts). Despite the use of these contracts
at runtime, their speciﬁcations are made by the developer
who should include all dependent relationships between the
adaptations. This will be a complex task because we con-
sider multi designers approach. Moreover, the strategy of
interference resolution may depend on the runtime state of
application. Dinkelaker et al. [12] deﬁne an extensible ordering
mechanism which can be modiﬁed at runtime. Such approach
still suffers limitation in term of software adaptation because
interference management at runtime needs to be anticipated.
In that direction, Cheung et al. [13] propose a composition
mechanism that repair interference problem in an anticipate
manner. Since interference can occurs at input and/or output
of components, they propose two composition mechanisms,
based on two different languages for adaptations, to handle
these problems separately. But, we have shown previously that
these problems need to be resolved together and not separately.
Their solution can resolve interference either for the output of
component or for the input of component but not for both
interferences types.
Graphs is not only intuitive representation of software
architecture, but are also used to identify errors on the analysis
level. The integration of the paradigm of graph with the aspect-
oriented paradigm has been proposed by Cirarci et al. [14].
They use the graph formalism to identify interference. Graphs
represent the several states of a program, according to different
order of aspect weaving. Interference is detected if the ﬁnal
state changes according to the selected order.
Although all of previously described approaches propose
software adaptations mechanism that support interferences
detection and resolution, none considers a merge process for
computing reasonable system adaptation from a large set of
possible adaptation, which is the main focus in this article.
III. PRELIMINARIES
To be able to present our composition mechanism, we
introduce in this section the model of our software systems.
A. Modelling Software architecture Assemblies Using Graphs
In order to represent structural speciﬁcations of software
systems, several researchers use Business Process Model
(BPM), which embodies also the strategies for accomplishing
software evolution. It provides high-level speciﬁcation that is
independent of the target platform. There exist many notations
to represent BPM [15]. In this paper, we abstract from any
speciﬁc notation and represent a process model as a directed
graph as per in the deﬁnition 1.
Deﬁnition 1.
A process graph G is a set of vertices V
and a set of directed edges E (G = (V, E)). A vertex vi of
V is deﬁned by a tuple (Id(vi), Typ(vi)) where Id(vi) is the
identiﬁer of vi and the attribute Typ(vi) is its type. An edge
ej of E is written as ej = (vi, vk, lj) where lj is a label.
deﬁnition 2 (Successor and Predecessor). Let G = (V, E)
be a directed graph. For each vertex vi ∈ V : we deﬁne the
set of its predecessor vertices as [v0i, ..., vli]•vi where {∀vli ∈
V, (vi, vli) ∈ E} , and the set of its successors (or output)
vertices vi•[v0i, ..., vmi] where {∀vmi ∈ V, (vmi, vi) ∈ E}.
Each vertex has a type and depends on the target platform
language that we represent. In the remainder of this paper we
consider that applications are created as component assemblies
(component can be instantiated when a device appears and
destroyed when the device disappears). Vertices are classiﬁed
into two subclasses: (i) Black box vertices (Typ(v)=’Port’ and
id(v)=’ComponentName:PortName’), representing component
ports (event and method call); (ii) White box vertices (or
connectors), which determine the ﬂow of the execution when
events are triggered. The attribute Typ(v) of a white box
vertex indicates the kind of connectors. We introduce 5 basic
connectors: PAR, SEQ, IF, CALL, DELEGATE. PAR•[vi, vj]
connector performs the concurrent execution of vertices vi and
vj. SEQ•[vi, vj] deﬁnes the order of execution; vi before vj.
IF•[vc, vi, vj] is used to choose a path between vi and vj. If
the vertex vc has the value true, vi will be performed (or se-
lected) otherwise vj will be executed. CALL connector allows
rewriting an existing edge. The connector DELEGATE•[vi]
speciﬁes that the link to the vertex vi will be unique in case
of interference. CALL and DELEGATE are special con-
nectors that will never be instantiated in the ﬁnal application
because they are used only to modify some links. Figure 1
shows an example of the application according to our model.
In order to facilitate the comprehensibility of this paper, we
use a lightweight representation. Each black box component
will be represented by a rectangle on which we add a label
679
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Figure 1.
An example of component assembly graph
on the form ComponentinstanceName : PortName. The
white box vertex will be represented by a rectangle on which
we add a label on the form : ConnectorName.
B. Running Example
We will now present the scenario that will be used through-
out this paper to present our approach. As an example, we
deﬁne a ubiquitous application that relies on variable and com-
municating devices which deﬁne its software infrastructure.
This software infrastructure appears dynamically populated by
the functionalities of these devices. As a consequence, the
application has to be adapted during execution time in order
to consider these changes. As all young people, Bob listens to
music all the time on his Smartphone. Inside his home, he has
an adaptation that redirect the sound from his phone to any
available audio device (Home cinema, speaker, etc.). Bob lives
alone. Today his mother visits him. Bob’s mother had recently
hearing problems; she cannot withstand the high tones. For
this reason, she has an adaptation (reconﬁguration) that will
specify the threshold of the sound level for audio devices in
her surrounding physical environment. Bob doesn’t know that
his mother had hearing problems. He increases the level of
music.
Figure 2.
The graphs of adaptations deﬁned in the running example
We consider that the original application (called the base
assembly) is build from a physical audio device, which is
represented by a Blackbox component AudioHome at software
level. In our use case, there are two sub-assemblies (adapta-
tions) linked to the AudioHome device. The SoundRedirect
adaptation graph is depicted in Figure 2. In order to be
applied, this adaptation requires that there are instances of
PhoneBob* and Audio* components in the initial assembly
(for example, if no component with audio capability is found,
this adaptation will not be woven at all). A simple wildcard ’*’
is used in this example, but more complex regular expression
can be deﬁned (Component instances’ types and component
ports’ names can both be wild-carded). This wildcard will be
replaced by the real device type of the infrastructure. It allows
these adaptations to be applied to real application although its
conﬁguration is not completely known at design time. This
adaptation adds a new edge between the port RedirSound of
the component PhoneBob* and the port Play of the component
Audio*. Through this link the Audio* device will receive the
music to play. Figure 1 shows an example of instance graph
of this adaptation.
The Threshold Level adaptation is depicted in Figure 2.
The adaptation that is not relevant to the application at
the beginning, can become relevant only when its required
components appear in the application assembly (components
tagged in Figure by a ’*’). This adaptation speciﬁes that when
an Audio device is detected, the user can deﬁne using his
phone the threshold for the sound level. The Min vertex is a
new connector, which will be deﬁned in the next section. It
is used to forward the minimal received values from its input
vertices. The CALL vertex allows rewriting existing links.
In the ﬁnal system both adaptations are running in parallel.
Even though the adaptation of Bob’s mother has delineated the
threshold, when Bob will increase the sound, this threshold
will be exceeded. This example illustrates a problem of a
concurrent access to a shared resource (audio device). In this
case, if we apply classical resolution approaches, such as
a precedence strategy, the problem will not be resolved. If
we apply the Threshold Level adaptation before or after the
SoundRedirect adaptation the problem will persist.
IV. A GRAPH-BASED APPROACH FOR ADAPTATIONS
COMPOSITION
In this section, we detail our approach for interference
resolution and the proof of the symmetry property.
A. Approach Overview
Until now, we have presented the adaptation entities graphs.
Since each adaptation entity is based on a set of required com-
ponents, we need to determine the set of relevant adaptations
(adaptations that can be applied). After that, we transform the
abstract description of relevant adaptations into a concrete one
(replacing ’*’ wildcard by the type of real components in the
base assembly). If various components satisfy the requirements
of an adaptation, then it can be applied as many times as there
are combinations of components instances. The combination
function computes all the places in the assembly where adap-
tations can be applied according to different strategies (build
all possible combinations, combine according to components
names, etc.). Subsequently, all these graphs need to be com-
posed with the graph of the base assembly. The composition
mechanism considers then these graphs, in order to generate
a single graph representing the adapted assembly. Despite the
order of graphs composition the ﬁnal graph will be the same
due to the commutativity and the associativity properties.
There are two sub steps in the composition process: the ﬁrst
sub step superimposes all graphs and also identiﬁes potential
interferences. The second sub step is accomplished by the
680
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Merging engine, which resolves these problems using graph
transformation rules. The ﬁnal graph that represents the new
conﬁguration of the system, will be exported to the adaptive
execution platform.
The interference problem is deﬁned through two patterns.
The interference Type 1 is detected when there is a Black Box
vertex that has two or more outgoing edges. The interference
Type 2 is denied as a Black Box vertex that has at least
two incoming edges. In our previous work [16], we have
considered interference Type 1. In this paper, we introduce new
White box vertices and we focus on a new type of interference
that occurs when several adaptation try to access to a shared
component’s ports (Type 2).
B. Superimposition and Interference Detection process
The superimposition operation builds a unique graph GT =
(VT , ET ) from the graph representing the initial assembly
Ginitial and several graphs resulting from the adaptation
instantiation step (GAdap1,...,GAdapN). GT = (((GBase ∪
GAdap1) ∪ GAdap2)... ∪ GAdapN) is the graph with VT =
VBase∪VAdap1∪...∪VAdapN and ET = EBase∪EAdap1∪...∪
EAdapN. When two graphs g1 and g2 share a vertex (vg1 and
vg2 have the same Typ and Id) the superimposition operation:
(1) keeps one vertex vg1 in the resulting graph (2) copies the
incoming edges (respectively the outgoing edges) of the vg2 to
vg1 (by modifying their target vertex and their source vertex
to be vg1). Starting from this point, interferences may appear
in the GT graph.
Interference will occur only when adaptations share at least
one port. This is due to the following constraints, which are
needed to guarantee the associativity and the commutativity
properties: (1) In order to preserve the independency of adap-
tations entities, these later can only share vertices of the base
assembly, (2) Adaptations cannot remove Blackbox vertices
or links explicitly (This may lead to the loss of associativity
and commutativity properties). Vertices are removed only if the
adaptation is withdrawn or components are not available. Thus,
the execution of an adaptation cannot prevent or enable another
adaptation to be performed. Thus, the potential for interference
between adaptations is greatly reduced. We deﬁned two types
of interferences: (1) Control ﬂow interference occurs when
adaptation entities share an output port of the same component
(2) Concurrent method call occurs when adaptation entities
share a method call of a component. In [16] we have already
detailed the process of resolution of interference Type 1. In
this paper, (i) we extend the set of white box vertices, (ii) we
proof the associativity and commutativity properties for these
new connectors, and (iii) we detail the process of resolution
of interference of Type 2.
We have seen in the previous example that the SoundRedi-
rect adaptation and the Threshold Level adaptation provide
an interference problem. These two adaptations share the port
Play of the component AudioHome with the base assembly
graph. Each adaptation sends a different value to this device.
The superimposition of these graphs illustrates an example of
interference of type (2) presented above. To tag this point in
the graph GT , a special vertex has been added in Figure 3.
Figure 3.
The Interference detection step adds a ⊗ vertex to mark the
problem
Thus, what is the resulting behavior when both adaptations
are relevant to be applied? In this case, the system will respect
the threshold deﬁned by the mother? Or will let Bob increases
the level of sound independently of the threshold. In the next
section we detail the resolution process of this problem.
C. Interference management using Graph transformation
rules
The interference management operation addresses the au-
tomatic resolution of interferences with the associativity and
the commutativity properties. To preserve this property, it has
been seen that adaptation entities are applied on the base
assembly GBase, which is free of any adaptation. Conse-
quently, the result of the interference management will be
the same whatever the order of adaptations composition. The
resolution mechanism builds its solution from ⊗ vertices
(added previously in GT graph). We have seen that graphs are
build from two subclasses of vertices: Black box and White
box. Basically, the algorithm used to resolve interferences
browses all ⊗ components in order to run a merging engine
on them [16]. Since we work on graphs, the merging will be
achieved by applying graph transformation rules.
A graph transformation rule has the form of p : L → R and
is applicable to a graph GBase if there is an occurrence of L
in GBase. Using rules deﬁnition, the designer can control the
manner in which adaptation graphs will be merged. Thus, the
semantics of the deployed application will be affected by the
logic of merging given by the designer. Given two vertices,
v1 and v2 (they must share a ⊗ successor or predecessor
vertex), we deﬁne a set of graph transformation rules that
shows how they will be merged according to different possible
conﬁgurations (for example if v1 and v2 share a predecessor
vertex). Thus, we have deﬁned the set of rules to merge each
white box vertex with all other vertices. Compared with our
previous work, we have extended the set of White box vertices
and accordingly their graph transformation rules.
1) Concurrent method call interference resolution: This
kind of interference occurs when at least two ports are
linked to a port of another component in the same time. To
resolve concurrent method call interference, we have deﬁned
new connectors (which have 2 predecessors vertex and one
successor vertex). The ﬁrst connector is [v1, v2]•FW. When
a data come from v1 and/or v2, this connector forward it to
its successor vertex(the method call). In other cases, it would
681
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

be necessary to add an [v1, v2]•AND or [v1, v2]•XCHoice
connectors (the XCHoice connector can be instantiated
according several strategies such as Min, Max, XOR,.. It
allows to choose one data from its input vertices). Similarly to
the Control ﬂow interference resolution, adaptations entities
should specify connectors that should be added for each
method call. Otherwise the merging engine will apply its
default solution (FW connector). The merging algorithm is
deﬁned in algorithm 1.
In order to merge interfering vertices, we ﬁrst need to get
Algorithm 1 Merging(Graph GT )
ListFusvertex : is used to save the list of ⊗ vertex of GT
k : the number of ⊗ vertex in GT
for s = 0 to k = ListFusvertex.getSize() do
Pre= GetPredecessor(ListFusvertex(s))
Vertex v1= Predecessor(0) ;
Vertex v2= Predecessor(1) ;
Rule r=SelectRule(v1, v2)
Boolean res=ExecuteRule(r)
ListFusvertex = getFusV ertex(GT )
end for
the list of ⊗ vertices (ListFusvertex) from GT graph.
Each ⊗ vertex has exactly two predecessor’ vertices (saved
at Pre). Then, we set v1 to the ﬁrst predecessor vertex and
v2 to the second predecessor vertex. Given two vertices v1
and v2, the SelectRule(v1, v2) function starts by searching
the graph transformation rule in the rule database in order to
merge these vertices (using Typ(v1) and Typ(v2) attributes).
If there is no graph transformation rule able to solve this
problem, then the default solution will be applied. For
example, if a designer has deﬁned a permissive policy, all
adaptations will be met at the same time (parallel execution).
This is similar to applying a Forward FW connector to each
adaptation graph. The default solution will replace the ⊗
vertex (which cannot be resolved) by a FW vertex. Next
the function ExecuteRule(r) applies the selected rule r to
GT . This rule merges v1 and v2 and removes the current
⊗ vertex. After this, the merging engine selects the next ⊗
vertex from the list ListFusvertex. Using our case study,
we will show that the merging operation can be propagated
to the successors vertices of v1 or v2 in order to solve the
interference for each vertex. In such case we need to get
the new list ListFusvertex = getFusV ertex(GT ) because
some ⊗ vertices have been added to the graph.
Figure 3 shows an interference on the port Play of the
component AudioHome. Thus, we will apply our merging
algorithm to resolve this problem. The ⊗ vertex has two
predecessors vertices v1 = Min and v2 = PhoneBobLG :
RedirSound. The rule r that will be applied is given in the
top of Figure 4.
Throughout this rule the designer has deﬁned that he wants
rewrite an existent link (due to the CALL use). The trivial
Figure 4.
The Graph transformation rule (R1) and the two steps for
interference resolution
way to do this is achieved by propagating v2 into the second
branch of the Min connector. The rule will reconnect these
vertices using a new ⊗ vertex. R1 rule can be applied in our
example because there is an occurrence of the left graph L
on GT . The matching step will uniﬁed the L graph variables
as following: A:a is PhoneBobLG : RedirSound ; B:b is
PhoneMotherSony : SetV alue port.
Figure 4 shows the result of R1 execution (Step1). First,
⊗ vertex is propagated in Min branch. Since there are still
⊗ vertices, the merging algorithm will continue the resolution
process. In this example, there are a CALL connector and a
port. In that case, the merging will apply a graph transfor-
mation rules that will connect the port to the output vertex
of the CALL connector. We have seen that this connector
allows rewriting an existent link. The graph of components
assembly of the ﬁnal application is depicted in Figure 4, Step
2. We note that CALL connector will not be instantiated in
the ﬁnal assembly because it is used only for the interference
resolution. When we deﬁne adaptation entities, this connector
should be used carefully.
D. The symmetry propriety
Associativity and commutativity properties guarantee a
good independence between adaptation entities, that is to say
that there is no need to deﬁne some explicit dependency
between them since the composition process ensures the con-
sistency of the result. The result of adaptations weaving will be
the same whatever the order of composition. The interference
resolution process must also guarantee this property when it
merges interfering adaptations. Let C be the set of connectors.
The symmetry is deﬁned via three sub-properties:
• Idempotent: ∀c1 ∈ C and c1⊗c1=c1. Merging a con-
nector with it self should return the same connector.
This property is achieved by construction. We have
speciﬁed a graph transformation rule that keep only one
connector when we compose the same connector (i.e.,
SEQ•[a,b]⊗SEQ•[a,b]=SEQ•[a,b] when a̸=b ).
• Commutativity : ∀c1, c2 ∈ C; c1⊗c2=c2⊗c1. It should
not matter in which order connectors are merged. The
682
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

function SelectRule presented previously, select the same
graph transformation rule independently of the order
of its parameter (it means SelectRule(c1,c2)= Selec-
tRule(c2,c1)). This property is ensured at composition
level by construction.
• Associativity:
∀c1, c2, c3
∈
C;
((c1⊗c2)⊗c3)
=(c1⊗(c2⊗c3)). If the merge operation is associative,
then generalization to more than two connectors can be
achieved merely by repeated merges, in any order.
To grantees the determinism of the computed application
and also ensures the consistency of the composed system at
the implementation level, we need to prove the associativity
property. In order to resolve interferences at input port, we
have extended the set of White Box vertices to support new
semantic. Thus, for each new connector, we must prove the
associativity property of its merging rules. A fundamental
question to answer is that ”how associativity can be proved?”
To answer to this question we deﬁne steps to be done for
that end. We choose as example the new connector Min
(we use the notation Newc). Connectors do not necessarily
need to be symmetric (for example SEQ connector is not
symmetric because: when a̸=b, SEQ•[a,b]̸= SEQ•[b,a] but
its composition with itself and other connector is symmetric).
For the proof, we will require demonstrating that the merging
of Newc with any other connector is associative. The ﬁrst step
to do is the deﬁnition of graph transformation rules that specify
the way of merging of the Newc connector with each other
connectors (we have already done the proof for all existent
connectors). After that we need to prove that:
• The merging of Newc with itself is associative. It
means that (Newc⊗ Newc)⊗ Newc = Newc⊗(Newc⊗
Newc).
For
example,
using
our
graph
transfor-
mation rules, we obtain {[a,b]•Min⊗ [a,c]•Min}⊗
[c,b]•Min=[a,b]•Min
⊗
{[a,c]•Min⊗
[c,b]•Min}=
[a,[b,c]•Min]•Min when a̸=b, a̸=c and b̸=c (there are
also other combinations to compute such as [b,c]•Min,
[a,d]•Min...).
• The merging of Newc with all the existent connectors
is also associative. That is to say:
(Newc ⊗ Oldc1) ⊗
Oldc2 = Newc ⊗ (Oldc1 ⊗ Oldc2) where both Oldc1
and Oldc2 ∈{PAR, IF, SEQ, DELEGATE, CALL, FW}
In this paper, we will demonstrate this property for the rule
R1 presented previously. This rule shows the merging of a port
with a MIN connector. Let G1 = [a, CALL]•Min, G2 =
c, G3 = d be the set of input graphs of the composition
operation where a, b, c and d are ports’ components. We will
compose theses graphs as fellows: Comb1 = (G1⊗G2)⊗G3
and Comb2 = G1 ⊗ (G2 ⊗ G3) and we will show that the
resulting graph is the same. There are several conﬁguration to
consider during composition:
case1: c = a and d ̸= a and d ̸= c
Comb1 = ([a, CALL]•Min⊗a)⊗d = [a, CALL⊗
a]•Min ⊗ d = [a, (CALL ⊗ a) ⊗ d]•Min =
[a, a ⊗ d]•Min = [a, [a, d]•FW]•MIN
Comb2
=
[a, CALL]•Min(a
⊗
d)
=
[a, CALL]•Min ⊗ [a, d]•FW
= [[a, CALL ⊗
[a, d]•FW]•Min = [a, [a, d]•FW]•Min
we conclude that comb1 = Comb2
case2: c = d and c ̸= a
Comb1 = ([a, CALL]•Min⊗c)⊗c = [a, CALL⊗
c]•Min ⊗ c
=
[a, (CALL ⊗ c) ⊗ c]•Min
=
[a, c]•Min
Comb2
=
[a, CALL]•Min(c
⊗
c)
=
[a, CALL]•MIN ⊗ c = [[a, CALL ⊗ c]•Min =
[a, c]•MIN
we conclude that comb1 = Comb2
case3: c ̸= a and d ̸= a and d ̸= c
Comb1 = ([a, CALL]•Min⊗c)⊗d = [a, CALL⊗
c]•Min ⊗ d = [[a, (CALL ⊗ c) ⊗ d]•Min =
[[a, c ⊗ d]•Min [a, [c, d]•FW]•MIN
Comb2
=
[a, CALL]•Min(c
⊗
d)
=
[a, CALL]•Min ⊗ [c, d]•FW = [[a, CALL ⊗ [c, d]
•FW]•Min = [a, [c, d]•FW]•Min
we conclude that comb1 = Comb2
We conclude that the rule R1 is associative. The proofs
of the associativity property of the merge function on other
new graph transformation rules are completely identical to the
proofs of the associativity shown for the fusion rule R1. We
do not detail the proof of other rules. To demonstrate that the
merging of each new connector is associative, we compute all
the possible composition combinations (connector with itself
and with existent connectors). In order to facilitate this task,
we have implemented a tool for associativity automatic proof.
The input of this tool is the deﬁnition of the new connector and
its graph transformations rules (we deﬁned the graph of Min
connector and all graph transformation rules of its merging).
As output, it will show in which case this property is failed (if
it exists). Thus, the designer can modify the set of rules that
cause problems to guarantees the property. Using this tools we
have proved that the composition of Min connector with all
previous operators is associative.
V. PRACTICAL ISSUES
The compositional adaptation mechanism presented in this
paper has been implemented in the WComp platform, which
is a middleware for adaptation based on a dynamic compo-
sition of services based on the SLCA (Service Lightweight
component Architecture) model [17] . Components allow the
management of the black box properties of devices. The inter-
action is limited to the use of their required and provided ports
(the direct access to implementation is forbidden). In order to
manage adaptation in a transversal way to produce simultane-
ous modiﬁcations in different points of the application, we use
a paradigm named Aspect of Assembly(AA)[18] (based on
AOP principles). It produces components assembly (graphs)
that will be composed. The merging engine implementation
has been presented in [16] and [19]. The merging engine uses
graph transformation mechanism in order to merge vertices
where interferences have been detected. Various graph trans-
formation tools exist but the most used is AGG (Attributed
Graph Grammar) [20].
683
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

Performance is a decisive factor in self adaptive systems
(ubiquitous systems need to be quickly adapted to consider
their infrastructure changes). For that reason, we measured
the execution time of the composition operation. Then, we
can conclude in which case our solution can be used. The
ruling that the response time is acceptable or not depends
on application’s domains. The results of our experiments
are brieﬂy presented in the rest of this section. Figure 5
Figure 5.
The execution time of the Merging process
shows the execution time of the merging step. From these
experimentations, we conclude that our approach can be used
in application’s domain that don’t require a very low response
time to be adapted. For example, our composition process can
be used in the area of domestic application since it composes
adaptations about 1 second.
VI. CONCLUSION AND FUTURE WORK
The work described in this paper is derived from our expe-
rience in composing independently developed adaptations (but
jointly deployed). In this paper, we introduced a new connector
Min that enables our composition mechanism to handle the
concurrent method call interference problems. Using graph
representation, we formally deﬁned the model of the running
system and the set of its adaptations. Our approach performs
some predeﬁned graph transformation rules that will merge
special vertices of the graph in order to resolve problems.
We provide that this operation is associative as the order of
adaptations compositions does not matter.
Immediate perspective of this work is to provide a well
deﬁned representation of connectors behavior. Model checking
techniques will be applied to ensure that the composition of
synchronous connectors does not violate the behavior of the
target application.
VII. ACKNOWLEDGMENTS
This work is supported by the French ANR Research
Program VERSO in the project ANR-08-VERS-005 called
CONTINUUM.
REFERENCES
[1] B. Cheng, R. de Lemos, H. Giese, P. Inverardi, J. Magee, J. Andersson,
B. Becker, N. Bencomo, Y. Brun, and B. Cukic, “Software engineering
for self-adaptive systems: A research roadmap,” Software Engineering
for Self-Adaptive Systems, pp. 1–26, 2009.
[2] P. McKinley, S. Sadjadi, E. Kasten, and B. Cheng, “A taxonomy of
compositional adaptation,” Rapport Technique num´eroMSU-CSE-04-17,
juillet, 2004.
[3] P. Greenwood, B. Lagaisse, F. Sanen, G. Coulson, A. Rashid, and
E. Truyen, “Interactions in ao middleware,” in Proc. Workshop on ADI,
ECOOP, 2007.
[4] F. Munoz and B. Baudry, “Validation challenges in model composition:
The case of adaptive systems,” ChaMDE 2008, p. 51.
[5] F. Sanen, E. Truyen, and W. Joosen, “Modeling context-dependent aspect
interference using default logics,” in Fifth workshop on Reﬂection, AOP
and Meta-data for Software Evolution, no. 5, 2008, pp. 1–5.
[6] M. Wermelinger, A. Lopes, and J. Fiadeiro, “A graph based architectural
(re) conﬁguration language,” in ACM SIGSOFT Software Engineering
Notes, vol. 26, no. 5.
ACM, 2001, pp. 21–32.
[7] D. Garlan, S. Cheng, A. Huang, B. Schmerl, and P. Steenkiste, “Rain-
bow: Architecture-based self-adaptation with reusable infrastructure,”
Computer, vol. 37, no. 10, pp. 46–54, 2004.
[8] L. Baresi, R. Heckel, S. Th¨one, and D. Varr´ o, “Style-based modeling
and reﬁnement of service-oriented architectures,” Software and Systems
Modeling, vol. 5, no. 2, pp. 187–207, 2006.
[9] J. Dowling, V. Cahill, and S. Clarke, “Dynamic software evolution and
the k-component model,” in Workshop on Software Evolution, 2001.
[10] M. Guennoun, “Architectures dynamiques dans le contexte des applica-
tions `a base de composants et orient´ees service,” 2006.
[11] P. David and T. Ledoux, “An aspect-oriented approach for developing
self-adaptive fractal components,” in Software Composition.
Springer,
2006.
[12] T. Dinkelaker, M. Mezini, and C. Bockisch, “The art of the meta-aspect
protocol,” in Proceedings of the 8th ACM international conference on
Aspect-oriented software development.
ACM, 2009, pp. 51–62.
[13] D. Cheung, J. Tigli, S. Lavirotte, and M. Riveill, “Wcomp: a multi-
design approach for prototyping applications using heterogeneous re-
sources,” in Rapid System Prototyping. Seventeenth IEEE International
Workshop on, 2006, pp. 119–125.
[14] S. Ciraci, W. Havinga, M. Aksit, C. Bockisch, and P. van den Broek,
“A graph-based aspect interference detection approach for uml-based
aspect-oriented models,” Transactions on aspect-oriented software de-
velopment VII, pp. 321–374, 2010.
[15] M. La Rosa, M. Dumas, R. Uba, and R. Dijkman, “Merging business
process models,” On the Move to Meaningful Internet Systems: OTM
2010, pp. 96–113, 2010.
[16] S. Fathallah Ben Bbdenneji, S. Lavirotte, J. Tigli, G. Rey, and M. Riveill,
“Mergeia: A service for dynamic merging of interfering adaptations
in ubiquitous system,” in UBICOMM 2011, The Fifth International
Conference on Mobile Ubiquitous Computing, Systems, Services and
Technologies, 2011, pp. 34–38.
[17] V. Hourdin, J. Tigli, S. Lavirotte, G. Rey, and M. Riveill, “Slca,
composite services for ubiquitous computing,” in Proceedings of the
International Conference on Mobile Technology, Applications, and Sys-
tems.
ACM, 2008, p. 11.
[18] J.-Y. Tigli, S. Lavirotte, G. Rey, V. Hourdin, D. Cheung-Foo-Wo,
E. Callegari, and M. Riveill, “WComp Middleware for Ubiquitous
Computing: Aspects and Composite Event-based Web Services,” Annals
of Telecommunications (AoT), vol. 64, Apr 2009.
[19] S. Fathallah, S. Lavirotte, J.-Y. Tigli, G. Rey, and M. Riveill, “Adap-
tations interferences detection and resolution with graph-transformation
approach,” in the 6th International Conference Sciences of Electronic,
Technologies of Information and Telecommunications(SETIT), ser. ,
Sousse, Tunisia, Nov.
[20] G. Taentzer, “Agg: A graph transformation environment for modeling
and validation of software,” Applications of Graph Transformations with
Industrial Relevance, pp. 446–453, 2004.
684
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-230-1
ICSEA 2012 : The Seventh International Conference on Software Engineering Advances

