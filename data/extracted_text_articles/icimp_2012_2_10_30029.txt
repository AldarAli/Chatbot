Formal Treatment of Distributed Trust in Electronic Voting
Stephan Neumann and Melanie Volkamer
CASED / TU Darmstadt
Hochschulstraße 10
64289 Darmstadt, Germany
Name.Surname@cased.de
Abstract—Electronic voting systems are among the most
security critical distributed systems. Different trust concepts
are implemented to mitigate the risk of conspiracies endanger-
ing security properties. These concepts render systems often
very complex and end users no longer recognize whom they
need to trust. Correspondingly, speciﬁc trust considerations
are necessary to support users. Recently, resilience terms have
been proposed in order to express, which entities can violate
the addressed security properties in particular by illegal col-
laborations. However, previous works derived these resilience
terms manually. Thus, successful attacks can be missed. Based
on this approach, we propose a framework to formally and
automatically derive these terms. Our framework comprises
a knowledge calculus, which allows us to model knowledge
and reason about knowledge of collaborating election entities.
The introduced framework is applied to deduce previously
manually derived resilience terms of three remote electronic
voting systems, namely Polyas, Helios and the Estonian voting
system. Thereby, we were able to discover mistakes in previous
derivations.
Keywords-trust, distributed systems, formal methods, re-
silience, electronic voting, knowledge calculus, conspiracies
I. INTRODUCTION
Recently, the interest in electronic voting systems in-
creases as more and more states implement electronic voting,
both with voting machines as well as remote internet voting
schemes. In this paper, we only consider internet voting
schemes and use the term electronic voting or eVoting
interchangeably. Electronic voting schemes are complex
distributed systems with particularly strict security require-
ments due to the nature of elections. It is therefore of great
importance to evaluate these schemes prior to their use in
legally binding elections.
Numerous analysis and veriﬁcation techniques for elec-
tronic voting have been proposed over the past decades.
The Common Criteria, in particular the Protection Proﬁle for
electronic voting [1], is an international standard for security
evaluation, which has been successfully applied to electronic
voting schemes, see [2] for an example. Additionally, many
researchers evaluated proposed voting schemes, both with
formal methods as in [3], [4], [5] and by cryptographic
means as in [6], [7]. However, these techniques mainly
investigate external attacks and do not address illegal col-
laborations between different entities.
However, speciﬁc trust considerations are necessary be-
cause the implemented trust concepts result in very complex
systems and voters are faced with the problem whom to
trust not to illegally collaborate with other entities. In [8]
Volkamer et al. propose resilience terms to derive which
entities need to be in particular trusted not to collaborate
maliciously in order to ensure security properties. Thus,
resilience terms express how robust a system is against
conspiracies of entities that do not behave properly. Re-
silience terms have shown their beneﬁt in the evaluation of
different systems, while their derivation remains informal
and potential conspiracies can be missed or misinterpreted,
which leads to wrong resilience terms.
In this paper, we review resilience terms and introduce
a logic, which allows us to formally and automatically
derive resilience terms in electronic voting schemes. While
there are many security properties that need to be satisﬁed
by voting schemes, we focus on secrecy as property of
crucial importance to most voting schemes. Our idea is
based on formal methods and knowledge management. We
establish distributed knowledge bases of entities in logical
terms and propose a inference system, which incorporates
the deduction rules to extend the obtained knowledge by
the adversary. We apply our framework for three electronic
voting schemes, namely Polyas, Helios and the Estonian one;
compare the results with those from [8]; and thereby detect
mistakes in the previously established resilience terms.
The remainder of this paper is organized as follows: In
Section II, we review related work in the formal analysis
of electronic voting schemes. In Section III we review the
existing framework on resilience terms as proposed in [8].
In Section IV, we introduce our knowledge calculus, while
Section V is dedicated to the formalization of the secrecy
property. Thereafter, in Section VI we exploit the proposed
knowledge calculus in order to derive resilience terms. In
Section VII, we deduce the resilience term for the three
electronic voting schemes based on our proposal. Section
VIII concludes this paper and shows future directions.
II. RELATED WORK
The formal security evaluation of electronic voting
schemes has been approached by different means. In this
section, we review related literature and check whether these
30
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

works can be adapted to our own needs. As this paper
addresses only internet voting schemes, we do not take into
account the veriﬁcation of voting machines as proposed for
instance in [9].
Several works build upon the applied pi calculus [10]
and its formalization in ProVerif: Backes et al. [3] prove
coercion-resistance of the JCJ protocol. Kremer et al. [4]
prove fairness and eligibility of the FOO 92 [5] protocol and
Cortier et al. [11] adapt the Helios system and prove secrecy
of the system. These techniques assume (or encode this in
the properties speciﬁcation) a ﬁxed scenario, where a given
set of entities is assumed to be trusted not to collaborate
maliciously. The goal of these works is to identify scenarios
in which a security property can be veriﬁed rather than
determining the smallest set of entities that might assure
that property. Therefore, a derivation of resilience terms with
respect to any illegal conspiracies can not be handled by
these techniques without further adaptation.
Jonker et al. [12] propose a formalization of receipt-
freeness in a state-orientated manner, which allows them
to verify receipt-freeness for different electronic voting
schemes. Their formalization is strongly generic, i.e., term
structures underlying the schemes need to be generated
independently for protocols. In [13] and [14] Br¨aunlich et al.
follow the idea of Jonker and use the state-orientated model
to identify state transitions not violating state invariants.
Their main purpose is to support engineers in the design
of protocols in a way that state invariants hold. Due to
the abstract nature of their approach, it is currently not
applicable for voting scheme evaluations.
Finally, we will review whether approaches proposed in
the context of formal trust management can be adapted to our
needs. Trust concepts and management systems have been
approached from different directions; in [15] and [16], the
authors rely on game-theoretic approaches to evaluate the
cost-beneﬁt relation for different entities to collaborate. We
see the value of these approaches mainly in the evaluation
of resilience terms. Once resilience terms have been deter-
mined, the risk or chance of entities ensuring or violating
security properties can be estimated. We refer to [17] and
[18] for a comprehensive overview on trust concepts.
III. EXISTING FRAMEWORK
Electronic voting systems process sensitive data, so dif-
ferent trust concepts were proposed in order to mitigate the
risk of conspiracies endangering security properties such as
integrity or secrecy. There are mainly three trust concepts
applied to electronic voting, namely separation of duty, the
four eyes principle and the multiple execution of a duty.
These trust concepts are usually combined and applied mul-
tiple times. This leads to complex trust distributions where
the question whom to trust not to collaborate maliciously
regarding certain security properties can become hard to
answer.
The evaluation of distributed systems with resilience terms
has been introduced in [19] and adapted to electronic voting
in [8]. Resilience terms allow one to identify which entities a
voter has to trust - in particular not to collaborate maliciously
- in order not to violate an investigated security property.
Terms however need to be determined independently for
different properties. Entities can be voting servers, admin-
istration staff, developers and key holders. The framework
assumes voters to behave properly and, thus, voters are
not considered as entities in this framework1. Resilience
terms can be derived on different levels, where level 1
corresponds to servers or key holders, level 2 to the local
position of components and administration staff of servers
correspondingly, and level 3 to the manufacturer of the
voting software run on the servers. Terms of higher levels
can be (formally) derived based on lower level terms in a
straight-forward manner.
The framework of resilience terms has been applied to
derive resilience terms for different voting systems, namely
the Estonian voting system, the Polyas [20] and the Helios
2.0 [21] system. The framework has been extended in
[22] towards post-processing of these terms by means of
transformation into logical terms and the evaluation of terms
with respect to trust metrics. It allows one to determine the
probability with which an electronic voting system fulﬁlls
a security property. Figure 1(a) shows how resilience terms
can be evaluated with respect to trust metrics. In order to
determine the resilience term, in [8] the authors propose
to manually and informally determine the knowledge of
entities once the voting phase has terminated. These local
knowledge sets of entities are thereby determined from
a worst-case point of view, i.e., entities are assumed not
to behave properly in the sense that they store all terms
they obtain and furthermore they store all visible relations
between terms. Based on the obtained local knowledge sets,
attack scenarios are identiﬁed and the resilience terms are
derived correspondingly. Resilience terms have the form
t = (k1 + · · · + km) out of (N1, . . . , Nm)
where N1, . . . , Nm is the list of identiﬁed entities that are
able to violate a security property if k1 entities out of N1
and . . . and km entities out of Nm collaborate maliciously.
If different terms allow the violation of a security property,
then these terms t1, . . . , tm are separated by the ”; ” symbol,
that is
t1; . . . ; tm.
t1; t2 can be reduced to t1 if t1 = i out of N and t2 =
j out of M with i < j and N ⊂ M holds.
The informal derivation of these terms can miss or mis-
interpret attack scenarios, which leads to wrong resilience
terms. Therefore, in this work, we adapt the framework of
1Correspondingly, the critics in [11] is not justiﬁed.
2
31
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

Distributed Systems
Trustworthiness Terms
PL Terms
PL Terms in Normal Forms
Trust Metrics
Propositional Logic
Formal derivation
Formal derivation
Assessment of probabilities
Manual informal derivation
Worst-case estimation +
(a) Original Research Framework.
Distributed Systems
Trustworthiness Terms
PL Terms
PL Terms in Normal Forms
Trust Metrics
Propositional Logic
Formal derivation
Formal derivation
Assessment of probabilities
Formal Knowledge System
Worst-case estimation
Automated formal derivation
(b) Extended Research Framework.
Figure 1.
Research Framework.
[8] and propose the formal derivation of resilience terms
based on formal knowledge representations. The highlighted
parts of Figure 1(b) integrate our extension into the existing
framework. Due to space constraints, in this paper, we focus
on level 1 while we recall that higher levels can be (formally)
derived in a straight-forward manner.
IV. KNOWLEDGE CALCULUS
In Section II, we reviewed literature in the context of
formal analysis of electronic voting and argued that none of
these approaches can be extended for our purpose. In this
section, we therefore commit on basics to underlie our ideas
and motivate the used methodology. We propose to apply the
concept of knowledge representation and reasoning about
knowledge as it is a well established concept of artiﬁcial
intelligence and has been inﬂuenced and improved by formal
methods. As Dolev-Yao (DY) [23] adversary models have
been successfully used to analyze cryptographic protocols
also in the context of electronic voting, we integrate a DY
adversary model in our approach.
In this section, we ﬁrst introduce the knowledge algebra to
represent terms, which can be known by entities. Thereafter,
the knowledge system is introduced in terms of a state
transition system, which allows the adversary to extend his
knowledge in terms of corrupting election entities. Finally,
reasoning over knowledge is realized by the adversarial
deduction rules used to extend adversarial knowledge. Due
to space constraints, we restrict our attention to entities and
inference rules, which will be used in the following examples
rather than a more comprehensive speciﬁcation.
Correspondingly, we do not settle our work in protocol
analysis but rather see the contribution in trust and knowl-
edge management in the ﬁeld of electronic voting schemes.
A. Knowledge Algebra
In this section, we introduce the algebra composed by
terms and equations making the semantics of terms.
1) Term Signature: We deﬁne the term signature to be
Sig =
 [
i∈N
F i
!
∪ R
where F i represents the function symbols of arity i and
R implements the relation between terms. The signature is
later on used to represent known messages and to formalize
security properties.
We deﬁne a subtype Ent, which embodies entities carry-
ing out an election, namely voters 2 and election services as
well as election authorities, such as key holders. We present
the entities in extracts while a more detailed consideration
depends on the voting scheme under investigation.
Ent
=
{voter(i) | i ∈ N} ∪
(*Voters*)
{KH(i) | i ∈ N} ∪
(*Key holders*)
{BBS} ∪
(*Ballot box server*)
. . .
We refer to roletype as a set of entities of a certain type,
e.g., roleKH = S
i∈N KH(i). The set of voters rolevoter
is abbreviated by V . The complete function symbols are
speciﬁed by the following signature:
F 0
=
Ent ∪ {vote, sk, pk, k, tan, token}
F 1
=
{hash, ss}
F 2
=
{sig, a−enc, enc}
F 4
=
{share}
Apart from entities, the signature provides symbols for votes,
secret keys, public keys, symmetric keys, transaction authen-
tication numbers (TAN), tokens, hash values, symmetric and
asymmetric encryption. We will provide function a−enc
with explicit randomness whenever this is of importance
to the protocol speciﬁcation. The function ss denotes the
secret sharing of a term into different shares. Each share
contains information about the shared term, the index of the
share, as well as information about how many shares need
to be collected in order to reconstruct the shared term and
how many shares exist. Below, we often use asymmetric key
pairs where entities sometimes hold different key pairs for
different use, such as encryption, signature or database key
pairs. By sktype
ent we denote the private key of entity ent to
be used for type.
2) Equations: The semantics of function symbols are
given by the following equations, which we abbreviate by
E.
R(t1, t2) = R(t2, t1)
(1)
ss(
k times
z
}|
{
share(t, i, k, n), . . . , share(t, j, k, n)) = t
(2)
Equation 1 indicates the commutativity of the knowledge
relation. Following the four eyes trust principle, electronic
2Note that voters need to be considered in order to specify the secrecy
property while they still remain incorruptible
3
32
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

voting schemes often distribute secrets among independent
entities in order to mitigate the risk of small conspiracies vi-
olating security properties. Equation 2 prescribes how a dis-
tributed secret can be reconstructed using the secret shares. It
holds ∀share(t, a, k, n), share(t, b, k, n), with i ≤ a, b ≤
j : share(t, a, k, n) ̸= share(t, b, k, n). By tk,n
i
we denote
share(t, i, k, n) .
Signature Sig and the equation set E lead our electronic
voting theory, which underlies the remainder of this paper.
B. Knowledge System
We model the knowledge system as state transition sys-
tem where transitions between states model corruption of
entities. We deﬁne Knowledge to be a set of ground terms
T(Sig), which embodies the local knowledge of an entity.
Global knowledge is deﬁned as composition of the entities’
local knowledge bases.
GlobalKnowledge
::=
Knowledge∗
Accordingly,
the
intruder
knowledge
refers
to
type
Knowledge:
IntruderKnowledge
::=
Knowledge
1) State and Traces: A state is given by an execution
trace, the global knowledge of entities as well as the intruder
knowledge.
State
::=
Trace ×
GlobalKnowledge × IntruderKnowledge
Collaboration is collectively embodied in the adversary,
i.e., the corrupted participants’ knowledge sets pass into ad-
versarial ownership. The execution of our corruption model
is carried out based on the initial distribution of knowledge.
At this point, we only consider one adversarial event, the
corruption of participants, which releases their knowledge
to the adversary.
Event
::=
corrupt(id)
Traces are composed inductively by sequences of events:
Trace
::=
Event.Trace
Initial State: The initial state of a knowledge system
with respect to electronic voting schemes is deﬁned as:
s0
=
ϵ × Kinit × IKinit
Initially, no identity is corrupt, hence the execution trace is
empty. The local knowledge is given by the scheme analysis
and is generally abbreviated by Kinit. After the successful
completion of the voting phase, the adversary’s knowledge,
generally referred to as IKinit, is deﬁned by the network
model and infrastructural details. The initial intruder knowl-
edge might consist of terms, which are publicly known or
which are given by the curious behavior of the adversary,
hence the interception of public channels and public bulletin
boards.
2) Execution Model: Given a state deﬁned by an event
trace tr, the local knowledge states of entities collectively
encoded in K and the adversary knowledge given by a
set of terms IK, the adversary may issue a corrupt event
targeted at entity ID. The execution of this event by the
system results in a state si+1 where tr is extended by the
recent corrupt event, the local knowledge of entities remains
unchanged and the adversary’s knowledge set is extended by
the local knowledge of the corrupted entity.
si = ⟨tr, K, IK⟩
ev = corrupt(ID)
si+1 = ⟨ev.tr, K, IK ∪ K(ID)⟩
C. Adversary Deduction System
Based on the adversarial knowledge resulting from cor-
ruption of entities, we introduce a deduction system that
allows the adversary to extend gained knowledge in a logical
sense, hence based on acquired terms, the adversary is
allowed to extend its knowledge according to an inference
system, which is given by the rules below. As we only
consider secrecy properties, the attacker can only decompose
terms rather than synthesize them.
1) Basic Rules: Knowledge is given by means of sets
over terms, hence elements of knowledge sets are derivable
according to the inference system.
m ∈ IK
IK ⊢E m
2) Asymmetric Encryption Rules: The rule enables the
adversary to decrypt publicly encrypted messages if he holds
the corresponding private key.
IK ⊢E skenc
i
IK ⊢E a−enc(pkenc
i
, m)
IK ⊢E m
3) Symmetric Encryption Rules: The adversary can derive
a message if he holds the encryption of that message and
the corresponding symmetric encryption key.
IK ⊢E k
IK ⊢E enc(k, m)
IK ⊢E m
4) Hash Rules: The adversary is allowed to derive hash
values of messages he holds.
IK ⊢E m
IK ⊢E hash(m)
5) Signature Rules: Signatures reveal the relation be-
tween signer and the signed message.
IK ⊢E sig(ski, m)
IK ⊢ R(i, m)
4
33
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

6) Secret Sharing Rules: We allow the adversary to use
the ss operator in order to reconstruct distributed terms.
IK ⊢E t1
. . .
IK ⊢E tn
IK ⊢E ss(t1, . . . , tn)
7) Relational Rules: Local knowledge sets of entities are
considered to be faithful, i.e., the union of these sets never
allows for inconsistencies. The rules given below specify the
projection on relations and the transitivity of the knowledge
relation.
IK ⊢E R(a, b)
IK ⊢E a
IK ⊢E R(a, b)
IK ⊢E b
IK ⊢E R(t, x)
IK ⊢E R(t, y)
IK ⊢E R(x, y)
V. SECRECY
The term secrecy often refers to different details while
the underlying idea remains mainly the same with respect
to electronic voting. In contrast to classical cryptographic
protocols, secrecy properties of electronic voting schemes
do not require the secrecy of terms, as the public availability
of votes is central to the public nature of elections. In fact,
secrecy in electronic voting resembles the idea of anonymity
in cryptographic protocols, i.e., an adversary should not be
able to link voters and their votes. Therefore, constructing
relations between terms may enable the adversary to violate
secrecy properties and is therefore of central importance in
our approach.
The intruder deduction problem for secrecy denotes the
problem to deduce a term t from a set of terms IK based on
a given inference system. In general, this fact is abbreviated
by
IK ⊢IS t
where IS denotes the corresponding inference system. Let
a state s = ⟨tr, Kinit, IK⟩ be given. The intruder deduction
problem for secrecy in electronic voting refers to
IKs ⊢ R(voter(i), vote(j))
for some i, j ∈ N. Therefore, assumptions about investigated
states have to be made, which subsequentally allows for
resilience term derivation. By logical means this can be
expressed as follows: For a state s = ⟨tr, Kinit, IK⟩,
one needs to ﬁnd min|bound(roler)| for all roler where
Vbound(roler)
i∈roler
corrupt(roler(i)) /∈ tr

such that IKs ⊬
R(voter(i), vote(j)).
VI. DETERMINATION OF RESILIENCE TERMS
The ultimate goal of our approach is to automatically
derive the minimal sets of entities that need to be trusted
in order to ensure the security properties of interest. Before
diving into details of the algorithm, we emphasize that the al-
gorithm assumes a worst-case estimation about the obtained
terminate
(a) Marking Process.
recall
(b) Recursive Call.
...
...
...
...
...
...
...
...
...
attack possible
determined bound
attack excluded
(c) Final Tree.
Figure 2.
The proposed algorithm.
knowledge of local entities. Hence, we manually consider
the entire protocol and formalize relational knowledge and
knowledge of terms that entities might gather if they do
not behave properly. Once, this estimation is available, the
following recursive algorithm is executed:
Assume a scenario with n entities. In such a situation,
the prover is initially called with a collaboration of all n
entities in order to determine if secrecy is violated. If so, n
instances of the prover are called each analyzing a different
collaboration scenario, i.e., each call excludes one entity
from the collaboration. Once, a collaboration can not violate
secrecy, we cut the tree at this point and give the result back.
In case no child of a node can violate secrecy, then this
node is marked and will be used for the ﬁnal computation
as depicted in Figure 2(a). In case some children of a node
can violate the property, while other children can not, the
algorithm is recursively called for the violating children as
shown in Figure 2(b). The ﬁnal output of this algorithm
corresponds to a tree of the form given in Figure 2(c).
Of crucial importance to our proposal is the handling
of entities in identical roles, e.g., key holders. In order to
reduce the computational complexity, the algorithm there-
fore is designed in the following way: Think of a 3 out
of 6 threshold scheme for distributed decryption among
{KH1, . . . , KH6}. We therefore invent a new super entity
KH3,6, which correspond to the reconstructed decryption
key. This entity is used throughout the algorithmic pro-
ceeding. In the ﬁnal k-resilience value, this entity is than
resubstituted by 3 out of {KH1, . . . , KH6}. Finally, marked
notes represent the determined resilience term.
In worst-case the number of prover calls is
#calls(prover) =
n
X
i=1
n
i

.
Note that we follow a top-down approach, although it can
easily be adapted to a bottom-up proceeding.
5
34
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

VII. EVALUATION OF EVOTING SCHEMES
We deploy the calculus in order to evaluate different
electronic voting schemes by means of resilience terms.
We brieﬂy present the voting schemes that have been
investigated also in [8], namely Polyas, Helios and the
Estonian voting system. Thereafter, we deduce the obtained
local knowledge sets from a worst-case, which allows us to
automatically derive the corresponding resilience terms and
contrast these terms with the previously informally derived
terms.
A. Polyas
Polyas is a remote voting system developed by Micromata
in 1996, with which many elections have been carried out.
Polyas comprises the following components:
Printing Service (PS): The PS prints the election material
and sends this material to the voters via postal mail.
Election Registration Server (ERS): The ERS implements
the electoral roll, which is accessed to verify the eligibility
of the voter.
Validation Server (VS): Similar to the ERS, the V S re-
veriﬁes the eligibility of the authenticating voter such that
both the ERS and the V S control each other.
Ballot Box Server (BBS): The BBS stores the encrypted
votes cast by eligible voters.
Tallying Component (TC): The TC is an ofﬂine compo-
nent, which tallies the stored votes in the BBS after the
election has terminated.
Key holders: There are two independent election ofﬁcials
(KH1, KH2), which hold the private key shares correspond-
ing to the public key used to encrypt votes.
Figure 3 depicts the protocol interaction in form of a
sequence diagram. For further information about the pro-
tocol speciﬁcation, we refer to [24], [8], [20]. Note that
the communication between different entities is secured by
https connections. Once, the voting phase has terminated,
the content of the BBS is carried over to the TC, which
is ofﬂine, where the votes are collectively decrypted by the
collaboration of both key holders.
Voter
start
check 
eligibility
TAN
generate random 
token T
T
ack
record T
set TAN 
invalid
T
record T
ack
T
T + request
T
delete T
set ID 
invalid
ack
delete T
success
ID, TAN
encrypt & store 
selection
ERS
VS
BBS
check 
eligibility
success
T + ballot
T + selection
T + selection
T + confirmation
label selected 
vote casted
Figure 3.
Polyas Voting Scheme.
The entities’ knowledge can be formalized in the follow-
ing way:
Election Registration Server: The hash values of TANs
prepared for eligible voters are available to the ERS.
• ∀i ≤ |V | s.t. R(voter(i), tan(j)) : hash(tan(j)) ∈
K(ERS)
All voters’ IDs are available to the ERS.
• ∀i ≤ |V | : voter(i) ∈ K(ERS)
The ERS is aware of the voter-TAN relation.
• ∀i ≤ |V | : R(voter(i), tan(j)) ∈ K(ERS)
The ERS knows the relation between TAN and tokens
generated by the VS.
• ∀i ≤ |V | s.t. R(voter(i), tan(j)) :
R(tan(j), token(k)) ∈ K(ERS)
Printing Service: The PS receives the voting material and
distributes eligible TANs among the voters via postal mail,
hence the service knows:
• ∀i ≤ |V | : R(voter(i), tan(j)) ∈ K(PS)
Validation Server: TANs prepared for eligible voters are
available to the V S.
• ∀i ≤ |V |, s.t. R(voter(i), tan(j)) : tan(j) ∈ K(V S)
Furthermore is the relation between prepared TANs and
prepared tokens known to the V S, as the V S generates these
tokens.
• ∀i ≤ |V | s.t. R(voter(i), tan(j)) :
R(tan(j), token(k)) ∈ K(V S)
Ballot Box Server: The tokens prepared for eligible voters
are available to the BBS.
• ∀i ≤ |V | s.t. R(voter(i), tan(j)),
R(tan(j), token(k)) :
token(k) ∈ K(BBS)
We recall that the local knowledge sets are determined
by a worst-case estimation about the complete protocol
run. Hence, the BBS might store information about votes
together with the respective token used to cast this vote.
• ∀i ≤ |V |, s.t. R(voter(i), token(k)) :
R(token(k), vote(l)) ∈ K(BBS)
The BBS might store the encrypted version of the cast
votes, together with the corresponding tokens used to submit
these votes.
• ∀i ≤ |V |, s.t. R(voter(i), token(k)) :
R(token(k), a−enc(pkDB, vote(l))) ∈ K(BBS)
Tallying Component: The TC obtains the knowledge from
the BBS. The TC furthermore stores the encrypted version
of each cast vote together with the vote.
• ∀i ≤ |V |, s.t. R(voter(i), token(k)),
R(token(k), a−enc(pkDB, vote(l))) :
R(enc(pkDB, vote(l)), vote(l)) ∈ K(TC)
Key holders: The private database key skDB is shared
among two independent key holders.
• ∀i ∈ {1, 2} : sk2,2
DBi ∈ K(KHi), s.t. sk2,2
DB1 ̸= sk2,2
DB2
6
35
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

Resilience Term Derivation: The ﬁrst boundary our
algorithm detects leads to a state s = ⟨tr, Kinit, K(BBS)∪
K(ERS) ∪ . . . ⟩, hence the corruption of the ERS and the
BBS. In s, the relational axioms allow the adversary to
reason in the following way:
IKERS
s
⊢ R(voter(i), tan(j))
IKERS
s
⊢ R(tan(j), token(k))
IKERS
s
⊢ R(voter(i), token(k))
IKBBS
s
⊢ R(token(k), vote(l))
IKs ⊢ R(voter(i), vote(l))
Note, that our algorithm does not investigate any fur-
ther conspiracies where ERS and BBS are involved
as such conspiracies automatically also violate the se-
crecy property. Trace tr with corrupt(PS), corrupt(V S),
corrupt(BBS) ∈ tr results in s, allowing the adversary to
reason in the following way:
IKP S
s
⊢ R(voter(i), tan(j))
IKV S
s
⊢ R(tan(j), token(k))
IKs ⊢ R(voter(i), token(k))
IKBBS
s
⊢ R(token(k), vote(l))
IKs ⊢ R(voter(i), vote(l))
Hence, conspiracies between the PS, the V S and the BBS
allow the adversary to violate the secrecy property.
Finally, the algorithm terminates and returns the following
secrecy resilience term for Polyas:
t
=
2 out of {ERS, BBS};
3 out of {PS, V S, BBS}
The informal resilience term derivation in [8] resulted in the
fact that BBS can guarantee the secrecy of the vote. This
coincides with our result. Furthermore, their result states
that also ERS and V S together can ensure secrecy. As
opposed to our consideration, they did not take into account
the printing service, therefore our second attack is out of
scope for their scenario. Hence, the entities ERS and V S
should not be part of their resilience term for the sake of
consistency.
B. Helios
The Helios voting system has been introduced in [21] by
Ben Adida, while currently Helios version 3.1 is available.
In contrast to prior and later versions, Helios 2.0 is based on
homomorphic tallying [25]. This work is based on Helios 2.0
as this version has already been investigated manually and
a resilience term has been determined [8]. The protocol is
based on the idea of separating ballot preparation/encryption
and authentication. Helios comprises the following compo-
nents:
Election Builder (EB): The EB initially determines can-
didates and eligible voters and provides eligible voters with
their login data and the URL.
Voting JavaScript: The script allows the voter to process
his vote and to interact with the backend of the system.
The JavaScript is launched by the Helios website. The
randomness used to encrypt the voter’s choice is stored
within this script. We assume the script to behave properly
and therefore do not distinguish between voter and his script.
Ballot Veriﬁers (BV): There are three BV , which can be
involved by voters to audit the encryption process.
Authentication Server (AS): The AS allows the voter to
authenticate himself in order to submit his encrypted vote.
Bulletin Board (BB): The BB is a public channel on which
voters may verify if their cast votes are stored.
Tallying Component (TC): According to the multiple exe-
cution of a duty principle, there are two independent ofﬂine
tallying components TC1 and TC2, which tally the stored
votes on the BB once the election has been ﬁnished.
Key holders (KH): There are six independent election
ofﬁcials that hold private key shares in order to decrypt
stored ballots.
An overview over the Helios system is given in Figure 4.
At the beginning of the election, the Helios election builder
Voter / JavaScript
start
selection
AS
BB
generate randomness;
random encryption of 
the vote
hash of the 
encryption
a) audit
a) randomness
b) cast vote
notification
pseudo / pwd
check 
eligibility
ack(AS)
discard 
randomness
pseudo + 
cast ballot
EB
election URL + 
pseudo / pwd
start JavaScript
login request
Figure 4.
Helios Voting Scheme.
sends the voter an invitation e-mail containing a link to the
election website together with his ephemeral login data. At
the end of the election process, the BB contains all voters’
pseudonyms together with the encrypted vote and the hash
value of the encrypted votes such that voters may verify the
process. Once, the election has terminated, the encryptions
are homomorphically summed up and decrypted by at least
three out of six key holders.
The local knowledge sets of the entities are given by:
Election Builder: The EB stores the association between
voter and pseudonym for each voter.
• ∀i ≤ |V | : R(voter(i), pseudo(j)) ∈ K(EB)
Voting JavaScript: The voting java script of voter i stores
the association between the voter’s pseudonym and his vote.
7
36
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

• R(voter(i), pseudo(j)) :
R(pseudo(j), vote(l)) ∈ K(V JSi)
Furthermore, the encryption of this vote together with the
used randomness is stored.
• R(voter(i), pseudo(j)) :
R(pseudo(j), a−enc(vote(l), pkT C, r)) ∈ K(V JSi)
• R(voter(i), pseudo(j)),
R(pseudo(j),
a−enc(vote(l), pkT C, r)) ∈ K(V JSi) :
r ∈ K(V JSi)
Ballot Veriﬁers: We omit the consideration of ballot veri-
ﬁers in the reasoning as the auditing of these servers causes
a new voting and encryption step. These veriﬁers therefore
do not inﬂuence the resilience term.
Authentication Server: The AS obtains the pseudonyms of
eligible voters.
• R(voter(i), pseudo(j)) : pseudo(j) ∈ K(AS)
Bulletin Board: The BB stores and publishes the encrypted
version of the cast votes, together with the corresponding
pseudonym used to submit these votes.
• ∀i ≤ |V | s.t. R(voter(i), pseudo(j)) :
R(pseudo(j), a−enc(pkT C, vote(l), r)) ∈ K(BB)
The BB stores and publishes the hash value of the encrypted
votes, together with the corresponding pseudonym used to
submit these votes.
• ∀i ≤ |V | s.t. R(voter(i), pseudo(j)) :
R(pseudo(j),
hash(a−enc(pkT C, vote(l), r)) ∈ K(BB)
Tallying Component: The TC obtains the knowledge from
the bulletin board.
Key holders: The private database key skT C is shared
among six independent key holders in the following way:
• ∀i ∈ {1, 2} : sk3,3
T C 1 ∈ K(KHi)
• ∀i ∈ {3, 4} : sk3,3
T C 2 ∈ K(KHi)
• ∀i ∈ {5, 6} : sk3,3
T C 3 ∈ K(KHi)
We denote the groups of key holders that hold identi-
cal key shares by KH1, KH2, KH3. We emphasize that
the content of the bulletin board is public, which means
that the attacker after the tallying is aware of relation
R(pseudo(j), a−enc(pkT C, vote(l), r)).
Resilience Term Derivation: The algorithm detects that
in case one key holder of each key holder group is corrupt,
the key skT C can be reconstructed. If additionally the EB
is compromised this leads to state s, which allows the
following reasoning:
IKKH1
s
⊢ sk3,3
T C 1
IKKH2
s
⊢ sk3,3
T C 2
IKKH3
s
⊢ sk3,3
T C 3
IKs ⊢ skT C
IKs ⊢ R(pseudo(l), a−enc(pkT C, vote(m), r))
IKs ⊢ R(pseudo(l), vote(m))
IKEB
s
⊢ R(voter(o), pseudo(l))
IKs ⊢ R(voter(o), vote(m))
Finally, the algorithm terminates and returns the following
secrecy resilience term for the Helios scheme:
t
=
(1 + 1 + 1 + 1) out of
({EB}, {KH1, KH2},
{KH3, KH4}, {KH5, KH6})
Level 1 resilience term in [8] expresses that the authentica-
tion server and one key holder of each group needs to be
trusted, while the authentication server in their consideration
plays the role of our EB. This observation coincides with
our result.
C. Estonian Voting System
In 2005, Estonia was the ﬁrst country in which electronic
elections were legally binding for the municipal elections.
Their system relies on the Estonian ID card, which is both
the regular ID card and a smart card capable of pursuing
legally binding digital signatures. The Estonian electronic
voting system comprises the following components:
Voter Application (VA): Each voter runs a V A on which he
selects his preferred candidates. After this, the application
encrypts the vote by the election key and signs the ballot
with the voter’s private key stored on his national ID card.
Vote Forwarding Server (VFS): The V FS is directly
accessible over the internet and once the voter prepared his
signed ballot, this ballot is sent to the V FS, which then
forwards the ballot to the vote storage server.
Vote Storage Server (VSS): The V SS receives ballots from
the V FS. After the election, the V SS eliminates double
votes and votes from ineligible voters. It then removes all
signatures and stores the unsigned ballots on a CD.
Vote Counting Application (VCA): The V CA reads the
encrypted ballots from the provided CD upon which the key
holders collectively start the tallying process.
Key holders (KH): There are seven key holders among
which four need to collaborate in order to decrypt cast votes.
A simpliﬁed overview of the Estonian internet voting
system is given in Figure 5. Apart from the description pre-
sented here, the Estonian system allows vote updating, which
is omitted in our consideration due to space constraints.
The electronic voting system deployed in Estonia imple-
ments the Estonian postal voting by electronic means. Once,
the election has terminated, the stored encrypted votes in
V SS are burned on a CD and carried over to the V CA.
8
37
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

Voter
signed + 
encrypted vote
VFS
VSS
forward signed + 
encrypted vote
check eligibility, 
remove signatures
success
Figure 5.
Estonian Voting Scheme.
There, the encrypted votes are mixed and decrypted by a
collaboration between four out of seven key holders.
Vote Forwarding Server: The V FS receives signed en-
crypted votes from the voters.
• ∀i ≤ |V | : voter(i) ∈ K(V FS)
• ∀i ≤ |V | s.t. R(voter(i), vote(j)) :
sig(sksig
i
, a−enc(pkV CA, vote(j))) ∈ K(V FS)
Vote Storage Server: The V SS stores the signed encrypted
votes from the V FS.
• ∀i ≤ |V | : voter(i) ∈ K(V SS)
• ∀i ≤ |V | s.t. R(voter(i), vote(j)) :
sig(sksig
i
, a−enc(pkV CA, vote(j))) ∈ K(V SS)
Vote Counting Application: The V CA only receives en-
crypted votes.
• ∀i ≤ |V | s.t. R(voter(i), vote(j)) :
a−enc(pkV CA, vote(j)) ∈ K(V CA)
The V CA stores the relation between encrypted votes and
votes.
• ∀i ≤ |V | s.t. R(voter(i), vote(j)) :
R(a−enc(pkV CA, vote(j)), vote(j)) ∈ K(V CA)
Key holders: The Estonian Voting System implements a
distributed threshold scheme in order to reconstruct the
secret key of the V CA.
• ∀i ∈ {1, . . . , 7} : sk4,7
V CAi ∈ K(V CAi) s.t. sk4,7
V CAk ̸=
sk4,7
V CAl
We emphasize that the tallying of ballots in the V CA is
public, once the key holders provided their keys, which
means that the attacker after the tallying is aware of relation
R(a−enc(pkV CA, vote(j)), vote(j)).
Resilience Term Derivation: The ﬁrst boundary our
proposed algorithm returns is the corruption of the V SS
and the V CA as this allows the following reasoning:
IKV SS ⊢ sig(sksig
i
, a−enc(pkV CA, vote(j)))
IKV SS ⊢ R(voter(i), a−enc(pkV CA, vote(j)))
IKV CA ⊢ R(enc(pkV CA, vote(j)), vote(j))
IK ⊢ R(voter(i), vote(j))
Finally, the algorithm terminates and returns the following
secrecy resilience term for the Estonian internet voting
system:
t
=
(1 + 1) out of {V FS, V SS}, {V CA};
(1 + 4) out of ({V FS, V SS}, {KH1, . . . , KH7})
The informal derivation of the resilience term in [8] led to
the fact that V SS can guarantee the secrecy of the vote. Our
result however shows that also V CA together with 4 out of
T key holders can ensure secrecy. This possibility has not
been discovered in [8].
VIII. CONCLUSION AND FUTURE WORK
This paper takes up the resilience terms proposed by
Volkamer et al. [8] used to evaluate distributed systems.
Based on this approach we developed a knowledge cal-
culus upon a theory adapted to most general electronic
voting schemes. This calculus allows for formal reasoning
over our proposed theory. On the basis of this calculus,
we formalized the secrecy property and described how to
determine resilience terms in this framework. Based on a
worst-case knowledge estimation, we iteratively investigate
collaboration scenarios and thereby deduce the resilience
term. We ﬁnally applied our proposal to three electronic
voting schemes and came up with mistakes in previously
informally derived terms of two of these three schemes.
In future work, we plan to incorporate our theory into
SPASS [26], an automated theorem prover, in order to fully
automatize the deduction, which allows us to run perfor-
mance tests on our proposal. The deﬁned theory therefore
has to be very precise, such that attacks or the absence of
attacks may be decided and proven in an automated way.
In protocol analysis, the secrecy property is undecidable
in the general case. In this work, we consider completely
passive adversaries, for which it has recently been shown
that deciding knowledge in security protocols can be done
in polynomial time under some e-voting theories [27]. We
therefore plan to compare these theories with our own
theories in order to obtain decidability results about our
own theories. In addition, in the future we will consider
the adversary’s capability of linking voters and votes by
means other than the proposed theory, e.g., an adversary
might link voters and votes by IP addresses or even times-
tamps of messages. Furthermore, in order to integrate other
security properties, e.g., integrity, a more adequate adversary
model has to be considered. In future work, we therefore
plan to allow the adversary to become active at an earlier
stage, hence manipulating, dropping or injecting messages
throughout the protocol run, thereby incorporating advances
from the protocol analysis. Due to the nature of elections,
the investigation of electronic voting schemes always comes
along with legal considerations. Therefore, resilience terms
compliant with legal frameworks need to be discussed and
determined in close collaboration with legal scientists.
ACKNOWLEDGMENT
This paper has been developed within the project
”ModIWa2” - Juristisch-informatische Modellierung von In-
ternetwahlen - which is funded by the Deutsche Forschungs-
gemeinschaft (DFG, German Science Foundation).
9
38
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

REFERENCES
[1] Melanie Volkamer and Roland Vogt. Basic set of security
requirements for Online Voting Products.
(BSI-PP-0037).
Common Criteria Protection Proﬁle, 2008.
[2] Hugo Jonker and Melanie Volkamer. Compliance of RIES to
the proposed e-voting protection proﬁle. In First International
Conference on E-voting and Identity, pages 50–61. Springer-
Verlag, 2007.
[3] Michael Backes, Catalin Hritcu, and Matteo Maffei. Auto-
mated veriﬁcation of remote electronic voting protocols in
the applied pi-calculus.
In 21st IEEE Computer Security
Foundations Symposium, pages 195–209. IEEE Computer
Society, 2008.
[4] Steve Kremer and Mark Ryan.
Analysis of an electronic
voting protocol in the applied pi calculus. In 14th European
Symposium On Programming, volume 3444 of LNCS, pages
186–200. Springer, 2005.
[5] Atsushi Fujioka, Tatsuaki Okamoto, and Kazuo Ohta.
A
practical secret voting scheme for large scale elections. In
Proceedings of the Workshop on the Theory and Application
of Cryptographic Techniques: Advances in Cryptology, pages
244–251. Springer-Verlag, 1993.
[6] Jonathan Katz, Steven Myers, and Rafail Ostrovsky. Cryp-
tographic counters and applications to electronic voting. In
Eurocrypt 2001, pages 78–92, 2001.
[7] R. K¨usters, T. Truderung, and A. Vogt. Proving coercion-
resistance of Scantegrity II. In 12th International Conference
on Information and Communications Security, volume 6476,
pages 281–295. Springer, 2010.
[8] Melanie Volkamer and R¨udiger Grimm.
Determine the
resilience of evaluated internet voting systems.
In First
International Workshop on Requirements Engineering for e-
Voting Systems, pages 47 – 54. IEEE Digital Library, 2009.
[9] Komminist Weldemariam, Richard A. Kemmerer, and Adolfo
Villaﬁorita. Formal speciﬁcation and analysis of an e-voting
system.
In Fifth International Conference on Availability,
Reliability and Security, pages 164–171, 2010.
[10] Mart´ın Abadi and C´edric Fournet. Mobile values, new names,
and secure communication. In 28th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, pages
104–115. ACM, 2001.
[11] V. Cortier and B. Smyth. Attacking and ﬁxing Helios: An
analysis of ballot secrecy. In 24th IEEE Computer Security
Foundations Symposium, pages 297 –311, 2011.
[12] H. L. Jonker and E. P. De Vink. Formalising receipt-freeness.
In Information Security, volume 4176 of LNCS, pages 476–
488. Springer, 2006.
[13] Rdiger Grimm, Katharina Hupf, and Melanie Volkamer. A
formal IT-security model for the correction and abort require-
ment of electronic voting. In 4th International Conference on
Electronic Voting, EVOTE, volume 167 of LNI, pages 89–107.
GI, 2010.
[14] Katharina Br¨aunlich and Rudiger Grimm.
Formalization
of receipt-freeness in the context of electronic voting.
In
Sixth International Conference on Availability, Reliability and
Security, pages 119 –126, 2011.
[15] Walid Saad, Tansu Alpcan, Tamer Basar, and Are Hjørungnes.
Coalitional game theory for security risk management.
In
Fifth International Conference on Internet Monitoring and
Protection, pages 35–40. IEEE Computer Society, 2010.
[16] Thomas Moscibroda, Stefan Schmid, and Roger Wattenhofer.
The price of malice: A game-theoretic framework for mali-
cious behavior in distributed systems. Internet Mathematics,
6:125–155, 2009.
[17] Tyrone Grandison and Morris Sloman.
A survey of trust
in internet applications. IEEE Communications Surveys and
Tutorials, 3(4):2–16, 2000.
[18] Sebastian Ries. Trust in Ubiquitous Computing. PhD thesis,
TU Darmstadt, 2009.
[19] Council of Europe. Legal, Operational and Technical Stan-
dards for E-Voting. Recommendation Rec (2004)11 adopted
by the Committee of Ministers of the Council of Europe and
explanatory memorandum. 2004.
[20] Kai Reinhard and Wolfgang Jung. Compliance of POLYAS
with the BSI protection proﬁle - basic requirements for remote
electronic voting systems. In First Conference on E-Voting
and Identity, pages 62–75, 2007.
[21] Ben Adida. Helios: Web-based open-audit voting. In Pro-
ceedings of the 17th conference on security symposium, pages
335–348. USENIX Association, 2008.
[22] Guido Schryen, Melanie Volkamer, Sebastian Ries, and
Sheikh Mahbub Habib. A formal approach towards measuring
trust in distributed systems. In ACM Symposium on Applied
Computing, pages 1739–1745. ACM, 2011.
[23] D. Dolev and A. Yao. On the security of public key protocols.
IEEE Transactions on Information Theory, 29:198–208, 1983.
[24] Maina M. Olembo, Patrick Schmidt, and Melanie Volkamer.
Introducing veriﬁability in the polyas remote electronic voting
system.
In Sixth International Conference on Availability,
Reliability and Security, pages 127–134. IEEE, 2011.
[25] Ben Adida, Olivier Pereira, Olivier De Marneffe, and
Jean Jacques Quisquater.
Electing a university president
using open-audit voting: Analysis of real-world use of Helios.
In Electronic Voting Technology/Workshop on Trustworthy
Elections, 2009.
[26] Christoph Weidenbach, Uwe Brahm, Thomas Hillenbrand,
Enno Keen, Christian Theobalt, and Dalibor Topi´c. SPASS
version 2.0. In 18th International Conference on Automated
Deduction, volume 2392 of LNAI, pages 275–279. Springer,
2002.
[27] Mouhebeddine Berrima, Narjes Ben, Rajeb Veronique Cortier,
Theme Sym, Mouhebeddine Berrima, Narjes Ben Rajeb,
Veronique Cortier, and Equipe projet Cassis. Deciding knowl-
edge in security protocols under some e-voting theories. In
20th International Conference on Rewriting Techniques and
Applications, pages 148–163. Springer, 2009.
10
39
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-201-1
ICIMP 2012 : The Seventh International Conference on Internet Monitoring and Protection

