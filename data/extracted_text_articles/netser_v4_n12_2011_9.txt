Unifom Generators and Combinatorial Designs
Alexis Bonnecaze
Université de la méditerrané,
IML, ERISCS
Marseille, France
Email: bonnecaze@univmed.fr
Pierre Liardet
Université de Provence,
LATP
Marseille, France
Email: liardet@cmi.univ-mrs.fr
Abstract—The concept of randomness is fundamental in
many domains and in particular in cryptography. Intuitively,
a system, which is unpredictable is more difﬁcult to attack
and as a consequence, creating sequences that look like
random represents a major issue. In this paper, we ﬁrst study
theoretically how a source of symbols with positive entropy can
be turned into a true random generator called Bernoulli. We
concentrate on a special type of generators, which consists in
randomly choosing k elements out of n elements. After studying
some existing algorithms, which are of Las Vegas type, we
introduce new constructions from a binary generator taken
as a primary random source of symbols. Our method is based
on combinatorial block designs and we construct algorithms of
Monte Carlo type involving random walks. We analyze in detail
properties of our general method. Several explicit constructions
of k-out-of-n generators are given. We show that the speed
of convergence to the uniform distribution is better than any
known method using algorithms with bounded running times.
Keywords-Random
Generator;
Design;
k-out-of-n
Algo-
rithms; Markov Chain; Random Algorithms;
I. INTRODUCTION
Random or pseudo-random generators of numbers are
omnipresent in cryptography. The concept of randomness
is used for various purposes. Salt and nonce are well known
examples of random values. A nonce (number used once)
is used to check the freshness of a message or as an
initialization vector. In conjunction with password, salt is
frequently used in order to complicate a dictionary attack.
Many cryptographic primitives also require random or pseu-
dorandom inputs like keys or values to make algorithms
probabilistic. It is well known that digital signatures or chal-
lenges in authentication protocols require the use of random
quantities. For these reasons, ﬁnding of good pseudo-random
generator is a stake in ﬁrst importance. There exist in the
literature lots of pseudo-random generators, which imitate
in some sense a sequence of independent random variables
Xn, uniformly distributed like, for example, the Blum Blum
Shub generator (BBS) [5].
However, some applications require more complex gener-
ators, called k-out-of-n generators. They consist in picking
randomly k elements in a set of n elements. The need
for such generators is multifarious. They help to reach
load balancing in certain distributed systems like high-
availability clusters for example. They are also useful in
security protocols, like threshold signatures [27] or time-
stamping schemes [6], [7]. Suppose we decide to create a
service of authentication (signatures and time-stamps). Most
of protocols use the concept of trusted third party even
though it may be difﬁcult to build a third party server that
can be trusted. Indeed a server may be corrupted or victim of
Denial of Service attacks (DoS). Moreover, the problem may
not have a malicious origin but a hardware or software one.
An important requirement of existing protocols is to prevent
the server from failing. In fact, schemes relying on a unique
third party server cannot be fully trusted. Therefore, such a
scheme should use a multi-server architecture that could be
described as follows: the protocol uses n third party servers.
For each request to the system, k servers out of the n servers
are randomly chosen to process the request. These k servers
are said to be the active servers. In this conﬁguration, an
attacker does not know a priori what are the active servers
for a given request. The attack is then much more difﬁcult to
operate. Moreover, the randomness of the generator allows
the system to be load balancing.
The above example is at the origin of this work as
we noticed that the construction of a uniform k-out-of-n
generator from a unbiased (or not) 0-1 valued Bernoulli
generator were not so much studied in the literature where
uniform random number generators in the unit interval are
commonly used. The underlying general problem is in fact
to construct unbiased Bernoulli generators from a binary
Bernoulli one, supporting a possible bias.
The paper is organized as follows. Section II recalls
necessary background, regarding (true) random generators
from a theoretical point of view. To this aim, basic properties
of symbolic Bernoulli dynamical systems are given. They
serve as theoretical models of random sources of symbols
with positive entropies. Section III reviews some existing
solutions of the k-out-of-n problem. Both ﬁrst ones are
very simple and of classical conception, while the third
one called RANKSB algorithm in [17] is due to Nijenhuis
and Wilf. This former algorithm leads to important bias in
comparison to the uniform distribution. Most of them are Las
Vegas algorithms. Section IV is devoted to our constructions
that are supported by Monte Carlo algorithms, hence with
107
International Journal on Advances in Networks and Services, vol 4 no 1 & 2, year 2011, http://www.iariajournals.org/networks_and_services/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

a bounded running times. Such algorithms approach the
uniform distribution exponentially fast. We ﬁrst propose a
generator based on the existence of some special combi-
natorial objects, namely block t-designs or including some
Steiner systems. This construction generates k elements
from a set of n elements in a uniform fashion from a binary
generator. It consists in randomly picking a block, called
word, from the blocks of the design. This word is then
modiﬁed in order to obtain a vector of weight k and length
n with the desired property. We will see that it can be useful
to introduce the notion of block codes, since codewords of
a ﬁxed Hamming weight in some codes hold a design.
The second type of constructions is based on random
walks on a ﬁnite set following the action of a ﬁnite num-
ber of generators of a group acting transitively. The ﬁrst
construction uses the permutation group Sn. The second
construction is very related to the method based on block
designs. The main difference is in the way of randomly
picking a word in the appropriate set. The algorithm makes
use of the automorphism group of the design and executes
a random walk on its blocks.
This article is an extended version of [1]. We present
in detail our methods, including mathematical foundations.
Compare to the conference version, our construction makes
use of block designs and not just Steiner systems. Indeed,
block designs are widespread and, as a consequence, our
construction can be applied for a wide range of parameters
k and n. In order to illustrate our methods, we give several
explicit constructions. For each chosen couple of parameters
k and n, we exhibit a correct design and calculate the speed
of convergence of the generator.
II. RANDOMNESS AND MATHEMATICAL FOUNDATIONS
A. From a binary random number generator to a q-ary one
In [18], the NIST deﬁnes a random bit sequence as
follows. “A random bit sequence could be interpreted as the
result of the ﬂips of an unbiased fair coin with sides that are
labeled “0" and “1," with each ﬂip having a probability of
exactly 1/2 of producing a “0" or “1." Furthermore, the ﬂips
are independent of each other: the result of any previous coin
ﬂip does not affect future coin ﬂips". Similarly, replacing the
set of issues {0, 1} by a given ﬁnite set A, one can deﬁne a
random A-valued sequence as an A-valued independent and
identically distributed random variables Xn(·) with common
law the uniform distribution on A. For our purpose, it is
convenient to translate these notions in term of Bernoulli
dynamical systems. To this aim, we recall basic deﬁnitions
and general results related to symbolic dynamical systems
and entropy.
Assume that A, also called alphabet, is equipped with the
discrete topology, has q elements (or letters) with q ≥ 2, and
set Ω(A) = AZ the product space endowed with the usual
compact product topology. Elements ω of Ω(A) are inﬁnite
bilateral sequences
ω = (. . . , ω−3, ω−2, ω−1; ω0, ω1, ω2, . . . )
with origin pointed at ω0. The alphabet A is usually
endowed with the uniform distribution denoted by U(A)
but we also consider other distributions. The space Ω(A)
is equipped with the σ-algebra of its Borel subsets. Any
probability µ on A, induces the inﬁnite product probability
µ∞ on Ω(A), which is deﬁned from cylinder sets. More
precisely, for any a := a0 . . . an−1 in An, let
[a] := {ω ∈ Ω ; ∀ i ∈ {0, . . . , n − 1}, ωi = ai}
be the cylinder set of base a, then
µ∞(σk[a]) = µ({a0}) . . . µ({an−1})
for any k ∈ Z. The shift σ : Ω(A) → Ω(A) is deﬁned by
σ(ω)n = ωn+1. Now, the triplet B(A, µ) := (Ω(A), σ, µ∞)
is by deﬁnition the Bernoulli (random generator) on A with
source distribution µ. In case µ = U(A) we set U ∞(A)
for µ∞ and B(A, U(A)) is simply denoted by B(A). Let
π0 : Ω(A) → A be the central projection (π0(ω) = ω0), then
the maps B(A)n := π0◦σn deﬁned on the probability space
(Ω(A), U ∞(A)) form an A-valued sequence of independent
random variables identically distributed with distribution law
U(A). This corresponds to a q-ary random number generator
for q = #A.
B. Symbolic random sources, entropy and factors
To ﬁx some notations and for convenience of the reader,
we recall basic deﬁnitions and facts from ergodic theory. For
more details and proofs we refer to the monographs [32]
and [25], and speciﬁc references below. Our mathematical
model of random source of letters in A should be identiﬁed
to a symbolic dynamical system (SDS) with symbols in A,
that is to say a triple (Ω(A), σ, ν) where ν is a Borel measure
on Ω(A), which is σ-invariant, i.e., ν = ν ◦ σ−1. The
entropy of such a system is, by the classical Kolmogorov-
Sinai Theorem or by deﬁnition,
H(σ, ν) := − lim
N
1
N
X
a∈AN
ν([a]) log ν([a])
with the convention 0. log(0) = 0.
Let Ω′ := (Ω(A′), σ′, ν′) and Ω := (Ω(A), σ, ν) be
symbolic dynamical systems. Their direct product is the
SDS Ω × Ω′
= (Ω(A × A′), σ × σ′, ν ⊗ ν′) and so
H(σ × σ′, ν × ν′) = H(σ, ν) + H(σ′, ν′). This construction
means that the source corresponding to Ω and Ω′ are inde-
pendent. If there is a measure preserving map f : Ω′ → Ω
commuting with the shifts, i.e.,
 ν = ν′ ◦ f −1 ,
σ ◦ f = f ◦ σ′ (ν-almost everywhere) ,
(1)
then Ω is said to be a factor of Ω′ with factor map f. In
that case H(σ, ν) ≤ H(σ′, ν′). In the following, the value
108
International Journal on Advances in Networks and Services, vol 4 no 1 & 2, year 2011, http://www.iariajournals.org/networks_and_services/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

H(σ,ν)
H(σ′,ν′) will be called entropy rate and denoted by τ(ν, ν′)
or simply by τ. If f is invertible (up to negligible sets),
with measure preserving inverse map, then Ω is said to
be isomorphic to Ω′ with conjugate map f and if Ω′ is
a Bernoulli random generator, then by extension Ω is also
called a Bernoulli SDS.
We have H(σ−1, ν) = H(σ, ν) and more generally
H(σ±k, µ) = kH(σ, ν) for any natural number k. In fact the
k-th iterate (Ω(A), σk, ν), k ̸= 0, is canonically identiﬁed
with (Ω(Ak), σ(k), ν(k)), where σ(k) is the shift on Ω(Ak)
and ν(k) is induced by ν restricted to cylinder sets of Ω(Ak)
viewed as particular cylinder sets from Ω(A). Therefore
H(σ(k), ν(k)) = kH(σ, ν).
This construction has the following important conse-
quence. Assume that we have got a binary source with
positive entropy h, for example a source extracting from
random jitter in an electrical circuit or quantum effects in
semiconductors or timing of running current process, or a
combination of these sources. Then, we derive a source of
binary blocks of length k having entropy kh.
In case of a Bernoulli system B(A, µ) (hence ν = µ∞
with the above deﬁnition), its entropy is easy to compute:
H(σ, µ∞) = −
X
a∈A
λ({a}) log λ({a}).
In particular H(σ, U ∞(A)) = log(#A).
As a consequence of a deep result of Y. Sinai (see
[28]), if the entropy H(σ′, ν′) of Ω′ = (Ω(A′), σ′, µ′) is
greater than or equal to log #A then there exists a factor f
from (Ω(A′), σ′, µ′) onto the uniform Bernoulli generator
B(A). Properties (1) shows that f is determined by the
central coordinate map f0 = π0 ◦ f since we have f =
(. . . , f−2, f−1; f0, f1, f2, . . . ) with fk = f0 ◦ σk (k ∈ Z).
In particular f0 is constant equal to a on Ca := f −1([a]).
Moreover, all partitions {σ′m(Ca) ; a ∈ A} (m ∈ Z) are
independent in between. Hence, building such a partition is
usually intractable by computer except in particular cases
pointed out below. Another consequence of the above con-
struction and Sinai’s theorem is that, from any given random
binary source of positive entropy, theoretically there exists a
factor built from of a suitable power of this source, which is
B({0, 1}), the factor map consisting in distributing binary
sequences in two parts equally likely and independently in
the time. This is the most hard problem to be solved in
practice for constructing, from a suitable physical random
source, a binary random generator according to the NIST
deﬁnition.
Following results of D. S. Ornstein [19], we recall that the
family of Bernoulli dynamical systems is remarkably stable.
In particular, they are characterized by their entropy (two
such systems of equal entropy are isomorphic), any direct
product of Bernoulli systems and any non trivial iterate (and
also any root) of a Bernoulli system are Bernoulli. Moreover
any factor of a Bernoulli system is also Bernoulli. These
properties imply that any probability algorithm that takes
in input a Bernoulli source and output a random source of
symbols always gives rise to a Bernoulli SDS, isomorphic
to some B(A, µ). In this paper we propose algorithms that
take as inputs the outcomes of an appropriated Bernoulli
source B({0, 1}k) and output a random source of letters in
a given alphabet A whose distribution of letters is exactly
or approximate accurately the uniform distribution. We may
distinguish three sorts of such random algorithms.
(A1) Algorithms that output the uniform distribution on
A in a bounded running time.
(A2) Las Vegas algorithms: they output the uniform
distribution on letters with unbounded running time but with
a ﬁnite expectation.
(A3) Monte Carlo algorithms: they end in a bounded
running time, output a distribution usually distinct to the
uniform distribution but arbitrarily closed to it in term of
total variation.
The following theorem depicts the ﬁrst case.
Theorem 1: If an algorithm of type (A1) takes input from
issues of the source B({0, 1}k) and produce a uniform
Bernoulli source of entropy log2 q, then q = 2s with s ≤ k.
Proof: By assumption, the algorithm can be identi-
ﬁed to a factor maps f with central coordinate map f0
having its values in {0, 1, . . . , q − 1}. That leads to the
partition {f −1
0 ({j}) ;
0 ≤ j < q} of Ω({0, 1}k) with
U(Ak)(f −1
0 ({j}) = 1/q and there exists an integer L ≥ 1
such that each f −1
0 ({j}) is the union of some cylinder sets of
the form CL(a) := {ω ∈ Ω({0, 1}k) ; (∀i)(|i| > L or ωi =
ai+L)}, a0 · · · a2L ∈ ({0, 1}k)2L+1. This implies that q
divides 2kL and since log q ≤ k one has q = 2s with s ≤ k.
Obviously, having in hands a uniform binary source, like
tossing an unbiased coin, for cryptographic applications is
impractical. But such an abstract uniform Bernoulli genera-
tor of binary sequences serves as a benchmark for evaluation
of random generators and pseudo-random generators. In
fact, security of most cryptographic algorithms and protocols
using pseudo-random generators is based on the assumption
that it is infeasible to distinguish use of a suitable binary
pseudo-random number generator (PRNG) from use of a
(truly) random number generator (RNG) deﬁned as the SDS
B({0, 1}). As an example, the pseudorandom generator BBS
has been proven secure in the sense that an attacker cannot
predict, in a reasonable time, the next bit of the outcome
with a probability greater than 1/2 (see [5]).
Putting apart the independency, the ﬁrst major problem is
then to construct generators Gn of elements (called states
or symbols) of a ﬁnite set A, such that the distribution law
Pn of Gn converges to the uniform distribution U(A) on A
as n tends to inﬁnity. In order to quantify this convergence,
we use the total variation distance between Pn and U(A).
109
International Journal on Advances in Networks and Services, vol 4 no 1 & 2, year 2011, http://www.iariajournals.org/networks_and_services/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

This distance is deﬁned by
d(Pn, U(A)) = 1
2
X
a∈A
Pn(a) −
1
#A

where Pn(a) is the probability that the generator Gn out-
comes the state a.
A classical method to solve this problem is to introduce a
transitive and irreducible Markov chain of transition matrix
T, with space of states A, such that the uniform distribution
on A is the stationary distribution of the chain. Constraints
of the problem are essentially on the incidence matrix of the
chain since each state a can only transit on a number τ(a)
of states such that 0 < τ(a) ≤ τmax where τmax is a small
constant compare to #A. The stationary distribution is then
approached by considering Markov random walk on a ﬁnite
graph. In fact, the general theory of ﬁnite Markov chains
shows that (by Perron-Frobenius’s theorem) there exist two
constants C > 0 and ρ ∈]0, 1[ such that for every pair of
states (i, j), one has
(T n)ij −
1
#A
 ≤ Cρn .
(2)
When #A is big, computation of constants C and ρ satis-
fying (2) is generally not effective, even if we assume that
n is large enough. In fact, if m0 is an integer such that for
a constant c ∈]0, 1] we have (T m0)ij ≥ c
1
#A for all pairs
of states (i, j), then inequality (2) becomes
(T n)ij −
1
#A
 ≤ (1 − c)⌊n/m0⌋ .
(3)
More details concerning ﬁnite Markov chains can be found
in [26] or [13]. Random walks on groups or ﬁnite graphs is
treated in [23], [10] and a survey on recent results on the
subject can be found in [24].
III. EXISTING ALGORITHMS
Construction of a k-out-of-n generator greatly depends on
the requirements of the applications. They could involve the
level of security, the amount of resources (CPU, memory,
etc.) needed or the generators used as a primary source of
randomness. In this former case, our reference, the generator
BBS, corresponds to the abstract model B({0, 1}). Given
the set Pn
k := {F ⊂ E ; #F = k} endowed with the
uniform distribution, the ultimate goal is then to construct
from B({0, 1}) a sequence of independent random variables
Xm of distribution Pm such that d(Pm, U(Pn
k )) ≤ Ce−cm
for m ≥ m0, where C, c and m0 are explicit constants
that can be used in practice. Now we review some standard
k-out-of-n generators according to above classiﬁcation A1–
A3.
(1) An algorithm of type (A1) exists if and only if

Fisher-Yates algorithm. This algorithm constructs a k-out-
of-n random generator involving only a uniform Bernoulli
random generator B({0, 1}ℓ) with n ≤ 2ℓ.
(4) RANKSB algorithm proposed in [17] takes into ac-
count some algorithmic constraints (in particular in terms
of CPU and execution time), which are not veriﬁed by
the preceding methods. We give a simpliﬁed version of
RANKSB. It consists in subdividing the interval [1, n] in
k sub-intervals Rj with approximately the same length,
and randomly choose the number rj of elements to be
selected in each Rj. If we don’t take into account that
rj ≤ #Rj, the k-tuple (r1, . . . , rk) of integers rj ≥ 0 such
that r1 + · · · + rk = k follows binomial law constructed
from k independent runs of integers in {0, . . . , n}, with
the uniform law. In order to avoid that rj be greater than
#Rj, we recompute the subdivision in sub-intervals Rj
then in each Rj we select rj elements using method (2),
(3) or any others. The algorithm uses a source of entropy
k log n corresponding to B({1, ..., n}k), to obtain the factor
corresponding to a shift of Bernoulli on the set of k-tuples
(r1, . . . , rk) as above (distributed according to the binomial
law), which is of entropy
Hk := −
X
r1+···+rk=k
1
kk

k
r1, . . . , rk

log
 1
kk

k
r1, . . . , rk

.
When k is small, let us use (2) to pick the rj elements in
Rj so that the corresponding entropy rate is (in average)
assumed closed to 1. The entropy rate of the algorithm is
then Hk/k log n. Since Hk is less than log kk, this entropy
rate is then less than log k/ log n. Notice that if n/k is small,
the output distribution has a non negligible bias.
In the sequel we describe k-out-of-n generators, which
are of Monte Carlo type.
IV. PROPOSED ALGORITHMS
In this section, we propose two types of constructions.
The ﬁrst one is based on some remarkable conﬁgurations
of points in binary vectors spaces, namely, block designs
[15]. It leads to optimal uniform generators and exists for a
wide range of parameter values k and n since designs are
very common. The second type of constructions is based on
random walks on some groups or ﬁnite sets.
A. Block t-design based constructions
A combinatorial block t-design D with parameters t-
(v, k, λ) is an incidence structure (P, B) (where elements of
B, called blocks, are subsets of P) satisfying the following
conditions:
• #P = v,
• ∀ B ∈ B, #B = k,
• ∀ S ⊂ P such that #S = t, #{B ∈ B ; S ⊂ B} = λ.
It is known that a necessary condition for the existence
of a t-design is that
bs = λ

get the output m′. Since we are only concerned by the set
of positions of the 1’s, we may identify it to {1, . . . , b} so
that the elimination of b − k digits 1 is done by selecting at
random, independently of the random choice of m, a subset
of b−k elements in {1, . . . , b}, issuing m′ independently of
the possible λ-blocks m that cover m′. Hence, the algorithm
outputs a random word of length n with Hamming weight
k. Notice that ﬁnding a k-out-of-n generator is equivalent to
ﬁnding a n − k-out-of-n generator. Of course this algorithm
needs uniform random generators on sets of symbols, which
are not necessarily of cardinality a power of 2, hence it is
usually of type (A2).
Example 1: As an example, we explain in detail the
construction of a 5-out-of-24 generator, which is based on
a S(5, 8, 24). In this case, the blocks of the design can be
represented as the words of weight 8 in the extended binary
Golay code G24. Our construction is based on the following
property [16, page 67]: every binary vector of Hamming
weight 5 and length 24 is covered by exactly one word of
G24 of weight 8. It turns out that a random generator in P24
5
is easily obtained from a random generator of the words of
weight 8 of the Golay code (and vice versa).
We recall the main combinatorial properties of G24. In
the sequel W(m) denotes the Hamming weight of a binary
string m (also called vector as element of the underlying
vector space); the weight distribution of G24 is classical and
given by the following table:
weights
0
8
12
16
24
number of words
1
759
2576
759
1
Table 1: Weight distribution of the words of the Golay code G24
A remarkable property of this code is that the set of words
of a given weight forms the blocks of a design. Hence, the
words of weight 8, called octads, form the blocks of a 5-
(24, 8, 1) design and words of weights 12 form the blocks
of a 5-(24, 12, 48) design. It is worth noticing that, in the
case of octads, the parameter λ of the design is equal to 1.
This means that a vector of length 24 and Hamming weight
5 is covered by exactly one octad of the code. Thus, octads
form a Steiner system with parameters S(5, 8, 24). Note that
there exist in G24 other Steiner systems like S(4, 7, 23),
S(3, 6, 22) or S(2, 5, 21), leading to similar constructions
of generators.
Since G24 decode at most three errors, it happens that
when changing three bits from the value 1 to the value 0
in an octad, one can construct

Γn, of space of states G, of transition matrix T given by
Tg,h = Q(gh−1) = P(Γn+1 = g|Γn = h). If the support
of Q generates G, the chain is irreducible and its stationary
distribution is the uniform distribution U(G) on G. From the
identity (Γ0 = {e}), and a sequence of independent random
variables Xn, the walk can be described inductively by Γ1 =
X1, Γn = XnΓn−1, the law of Γn being given by Q(1) = Q
for Γ1 and convolution product Q(m)(g) = Q∗Q(m−1)(g) =
P
h∈G Q(m−1)(gh−1)Q(h) for Γm (≥ 2). Here, we suppose
that the chain is irreducible and aperiodic. Hence there exist
an integer m0 and a constant c > 0 such that T m0
g,h ≥ c
1
#G
and then inequality (3) can be applied. This inequality can
be translated in terms of distance (2), and can be improved
in the case of symmetric walks (Q(g) = Q(g−1)) or for
particular groups previously analyzed in a probabilistic way.
For more details, see [2], [3], [10], [23], [24].
One application in cryptography is the popular stream par-
ity de-skewer. Here G is the additive group {0, 1} := Z/2Z
and Q(0) = 1
2 − β, Q(1) = 1
2 + β with 0 ≤ 2β < 1. Then
T =
1
2J + βS with J :=
1
1
1
1

and S :=
−1
1
1
−1

.
Using JS = SJ = 0, J2 = 2J and S2 = 2S we get the
explicit formula
T n = 1
2J + (2β)nS
and consequently
d(Qn, U({0, 1})) = e−n log(1/2β).
Moreover, for k ≥ 1 ﬁxed, the sequence of random variables
(Γkn)n≥1 deﬁnes the Bernoulli SDS B({0, 1}, Q(k)) whose
entropy is, after simpliﬁcation,
Hk
=
log 2 − 1
2(1 + (2β)k) log(1 + (2β)k)
+1
2(1 − (2β)k) log

1
1 − (2β)k

.
Hence, Hk − log 2 ∼ (2β)2k as k tends to inﬁnity.
2) Random transposition on the symmetric group Sn
and k-out-of-n generators: random walks on the symmetric
group Sn have been intensely studied (see the preceding
references). Consider a uniform Bernoulli generator B(Sn)
on the group of permutations Sn. This generator deﬁnes
a sequence of random variables Σn(·) = B(Sn)n. Then
Cn = Σn({1, . . . , k}) is a sequence of random variables
uniformly distributed in the set Pn
k .
An interesting method to construct generators distinct
from Fisher-Yates shufﬂe algorithm is to choose a set E of
generators of Sn and use a Bernoulli B(E). A result of [10]
states that the speed of convergence is in e−γ when the walk
has a sufﬁciently large number of steps γ: more precisely,
for E = {Id, (1, 2), (1, 2, . . . , n), (n, n − 1, n − 2, . . . , 1)}
one has
d(G(36n3(log n+γ)), U(Sn)) ≤ αe−γ ,
(4)
where α > 0 is a universal constant and for all integers
γ ≥ 0. Then, random variables Γm (see above) represent a
generator converging to the Bernoulli generator B(Sn); it
outputs, at each step, a permutation σ and σ({1, . . . , k}). Let
Γm[k] denotes this generator. Its distribution Q(m)
k
on Pn
k is
given, for each set A of k elements of En = {1, . . . , n}, by
Q(m)
k
(A) =
X
σ∈Sn
σ({1,...,k})=A
Q(m)(σ).
We observe that #{σ ∈ Sn ; σ({1, . . . , k}) = A} = k!(n−
k)! so that
d(Γm, U(Sn))
=
1
2
X
A∈Pn
k
Q(m)
k
(A) − k!(n − k)!
n!

≤
d(Γm[k], U(Pn
k )) .
This last bound validates the construction of Γm[k] with
the same convergence property than that of Γm. However,
this generator is not practical for large value of n, and in
particular for n = 24.
3) Homogeneous symmetric random walk on a ﬁnite set:
Let M be a ﬁnite set of elements and let E be a set of
bijections of M. We set
µ := #M
and
χ := #E.
A general random walk on M with instructions in E is
given by a distribution law L on M and a sequence of E-
valued random variables (Xn)n of given distribution Pn. An
outcome x = (xk)k of the random sequence (Xk)k≥1 leads
to a walk on M consisting to start from an initial point
m0 in M, selected according to the law L (step 0) and the
location of the walk after n steps is mn = xn ◦ xn−1 ◦ · · · ◦
x1(m0). In the sequel, we only pay attention to a Markov
symmetric homogeneous and uniform walk, that means a
walk satisfying the following properties:
(j) The initial point m0 is ﬁxed.
(jj) Symmetry: for all Y in E the inverse map Y −1
belongs to E and the identity map belongs to E.
(jjj) The random variables Xn are independent, with
uniform distribution Pn := U(E).
Therefore, the space of states of the corresponding Markov
chain is M and the stochastic transition matrix T is given
by
Ti,j := #{Y ∈ E ; Y (i) = j}
χ
((i, j) ∈ M2) .
According to property (jj), the matrix T is symmetric and so,
has the uniform distribution on M for stationary probability.
For our applications we assume that
(jv) The chain is mixing.
This assumption is equivalent to the fact that a power of S
has all entries positive. Hence, we may deﬁne the following
important parameter of the chain
κ := min{k ≥ 0 ; ∀ (i, j) ∈ M2, (T k)i,j > 0}.
113
International Journal on Advances in Networks and Services, vol 4 no 1 & 2, year 2011, http://www.iariajournals.org/networks_and_services/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

In other words κ is the minimum number of necessary steps
to go from any state to any state.
Our next goal is to estimate the so called spectral hole
of S. To this aim we use the symmetry of the chain by
considering appropriated quadratic forms on the vector space
RM equipped with the euclidean scalar product denoted by
⟨ξ|ξ′⟩ = P
(i,j)∈M2 ξiξ′
j, with norm || · ||. Each generator
Y in E, acting on M is identiﬁed to an automorphism
of RM permuting the canonical basis. It is represented by
an orthogonal matrix, still denoted by Y . The action of Y
applies at i will be denoted by Y ·i. Explicitly, Y is given by
Yi,j = 1 if j = Y ·i and Yi,j = 0 otherwise. The inverse Y −1
of Y corresponds to the transpose matrix Y ∗. The stochastic
transition matrix T deﬁned above is now given by
T := 1
χ
X
Y ∈E
Y.
By symmetry of T and Perron-Frobenius’s theorem, T has µ
eigenvalues λν (0 ≤ ν < µ) whose the largest one is equal
to 1, with multiplicity 1. Let ρ be the greater eigenvalue of
T distinct from 1, we ordered real eigenvalues as follows:
−1 < λµ−1 ≤ · · · ≤ λ1 = ρ < λ0 = 1 .
Theorem 2: With the preceding deﬁnitions and notations,
we have
−1 + 2
χ ≤ λµ−1
and
ρ ≤ 1 −
4
κ(κ + 1)χ .
Proof.
1. The ﬁrst inequality is easy to prove. By (jj), diagonal
terms of T are equal to 1/χ, hence the matrix
χ
χ−1(T − 1
χI)
is stochastic with eigenvalues χλν−1
χ−1
between −1 and 1. In
particular −1 ≤ χλµ−1−1
χ−1
, which gives −1 + 2
χ ≤ λµ−1, as
expected.
2. The second inequality is more complex to prove. It
relies on the comparison of two quadratic forms on RM.
To every symmetric matrix A indexed on M we as-
sociate the quadratic form QA(ξ) = ⟨Aξ|ξ⟩. Eigenvalues
α0 ≤ α1 ≤ · · · ≤ αµ−1 of A are given by Courant-Fisher
theorem (also called mini-max theorem) [12]:
αν = min
F {m(F) ; dim(F) = ν + 1},
0 ≤ ν < µ,
the minimum being calculated over the set of all subspaces
F of RM of dimension ν + 1 and
m(F) := max{⟨Aξ|ξ⟩ ; ||ξ|| = 1, and ξ ∈ F}.
A straightforward consequence of this theorem is
Corollary 1: Let QA and QA′ two quadratic forms on
RM, of symmetric matrices A and A′ and eigenvalues λν, λ′
ν
respectively (indexed in decreasing order). If for a constant
C > 0 we have QA′ ≤ CQA, then λ′
ν ≤ Cλν for every
index ν, 0 ≤ ν < µ.
For our purpose, choose A = I − T. Then we have
QI−T (ξ)
=
1
2
X
i,j
(ξi − ξj)2Ti,j
=
1
2χ
X
Y ∈E
i∈M
(ξi − ξY ·i)2
The bound will result from the following main lemma.
Lemma 1: Consider the symmetric matrix B = I − 1
µJ
where J has all its coefﬁcients equal to 1. Then
QB ≤ χκ(κ + 1)
4
QI−T .
(5)
Proof.
For
every
pair
(i, j)
of
states,
let
Y i,j
=
Y i,j
k(i,j) · · · Y i,j
0
with Y i,j
0
= I be a composition of elements
of E such that j
= Y i,j·i with k(i, j) minimal. Set
|Y i,j| := k(i, j). We have |Y i,j| ≤ κ and
ξi − ξj =
|Y i,j|−1
X
s=0
(ξ
Y i,j
s
···Y i,j
0
·i − ξ
Y i,j
s+1···Y i,j
0
·i).
Applying Cauchy-Schwarz inequality gives
(ξi − ξj)2 = |Y i,j|
|Y i,j|−1
X
s=0
(ξ
Y i,j
s
···Y i,j
0
·i − ξ
Y i,j
s+1···Y i,j
0
·i)2
≤ χ|Y i,j|
|Y i,j|−1
X
s=0
(ξ
Y i,j
s
···Y i,j
0
·i − ξ
Y i,j
s+1···Y i,j
0
·i)2Tλijs
where λijs := Y i,j
s
· · · Y i,j
0 ·i, Y i,j
s+1 · · · Y i,j
0 ·i .
Multiply these inequalities by 1/µ and add all of them, ﬁrst
by summing on j and then on i. The summation on the left
side simply gives
1
µ
X
(i,j)∈M2
(ξi − ξj)2 = 2QB(ξ).
Hence, the summation on the right side is greater than
2QB(ξ). By collecting all right terms according to the values
taking by |Y i,j| for i ﬁxed we get
(χ/2) 1
µ
κ
X
k=1
k(2QI−T )
since by minimality, there is no loop in the path going from
i to j and constructed from Y i,j. Therefore, summing over i
now leads to the desired inequality QB(ξ) ≤ κ(κ+1)χ
4
QI−T .
Eigenvalues of
1
µJ being 1 and 0, those of B are then
1 (with multiplicity µ − 1) and 0. Then Corollary 1 gives
1 ≤
κ(κ+1)χ
4
(1 − ρ), which is the second inequality of
theorem 2.
Using Theorem
2 and the fact that T is a symmetric
stochastic matrix of order µ, we get the following inequality
T n − 1
µJ

2 ≤

1 −
4
κ(κ + 1)χ
n
,
114
International Journal on Advances in Networks and Services, vol 4 no 1 & 2, year 2011, http://www.iariajournals.org/networks_and_services/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

where
·

2 denotes the quadratic norm of operators. Now
let P (n)
m
be the distribution of the walk obtained from the
state m0, and set
d(n) := max
m∈M d(P (n)
m , U(M)).
Let Im0 be the column vector in RM with all entries
0 except the entry corresponding to m0. From Cauchy-
Schwarz inequality and symmetry of T n,
d(P (n)
m , U(M))
=
1
2
X
j∈M
T n
i,m0 − 1
µ

≤
1
2
√µ
 X
j∈M

T n
i,m0 − 1
µ
21/2
≤
1
2
√µ



T n − 1
µJ

Im0


2 .
Since
||(T n − 1
µJ)Im0||2
≤
|||(T n − 1
µJ)|||2||Im0||2
≤

1 −
4
κ(κ + 1)χ
n
,
we obtain
d(n) ≤
√µ
2

1 −
4
κ(κ + 1)χ
n
that can be transformed into
d(⌈ab + bγ⌉) ≤ e−γ .
(6)
with
a
=
1
2 log µ − log 2
b
=
−
1
log

1 −
4
κ(1+κ)χ
 .
This inequality exhibits the speed of convergence of the
walk to the uniform distribution.
In the next subsection, we apply this general theory to the
speciﬁc case of random walks on the blocks of a design.
4) Random walk using the automorphism group of a
design: We now introduce an efﬁcient uniform k-out-of-n
generator, using a random walk on a block of a k−design.
The walk consists in acting on the block a set E of
appropriate generators of the automorphism group of the
design.
Gk-n(N) Algorithm
INPUT : N
OUTPUT : a binary vector of Hamming weight k and length
n
Choose a block m of weight b among the blocks of a k −
(n, b, λ) design. The automorphism group A of the design
must be transitive on the blocks.
If A is (b − k)-transitive on the blocks,
then
(b.1) replace m by m′, replacing the ﬁrst b − k coordinates
equal to 1 in m by zeros
(b.2) randomly act on m′ the generators of G, N times
(b.3) output the obtained word.
else
(c.1) randomly act on m the generators of G, N times, and
obtain m′
(c.2) randomly choose k coordinates equal to 1 in m′ using
a k-out-of-b generator
(c.3) output the obtained word.
We give in the sequel, examples of constructions for
various parameters k and n.
Example 2: Generator
5-out-of-24
associated
to
the
Mathieu group M24
Let G24 be the extended binary Golay code. The Mathieu
group, M24, is the automorphism group of G24 and can be
generated by the following four permutations acting on the
coordinates of the words of the Golay code:
S : i 7→ i + 1,
V : i 7→ 2i,
U : i 7→ −1/i
and
W :



∞ 7→ 0, 0 7→ ∞,
i 7→ −(i/2)2
if i is a quadratic residu modulo 23,
i 7→ (2i)2
otherwise.
G5-24(N) Algorihm
INPUT : N
OUTPUT : a binary vector of Hamming weight 5 and length
24
(a) choose an octad of G24 : m
(b) replace m by m′, replacing the ﬁrst three coordinates
equal to 1 in m by zeros
(c) randomly act on m′ the four generators or their inverse
or the identity, N times
(d) output the obtained word.
Note that M24 is 5-transitive on octads. This is why step (b)
can be done before acting the generators.
We have now to explicitly construct the random gener-
ator of octads. Since the size of M24 is huge (#M24 =
210.33.5.7.11.23), the speed of convergence of a walk on
the Mathieu group would be mediocre.
Thus we introduce a Markov walk on the set M of octads
by the action of the four aforementioned generators of M24:
S, V , U et W. Let I be the identity. Now we make the walk
symmetrical by taking the following transition set
E := {I, S, S−1, U, V, V −1, W, W −1},
with the uniform probability.
To show that G5-24(N) Algorihm realizes a uniform 5-out-
of-24 generator asymptotically with exponential speediness,
we determine equation (6) with the correct parameters.
115
International Journal on Advances in Networks and Services, vol 4 no 1 & 2, year 2011, http://www.iariajournals.org/networks_and_services/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

We have to calculate the minimal number of times we
have to act elements of E on a given octad in order to obtain
all the octads. Since the walk is symmetric, this number
corresponds to κ. Taking into account that the identity
belongs to E, Table 2 shows that κ = 7.
Number of octads
Numbers of steps
683
6
76
7
Table 2: number of steps to obtain, during the walk, all octads
from a speciﬁc octad
With the above notations, we have µ = 759, χ = 8, and
κ = 7. We obtain
d(292 + 111γ) ≤ e−γ.
The following histogram (Fig. 1) gives a statistical view
of what is going on in the case of a very short walk. It
represents the number N(f) of octads obtained f times
during 7590 walks of length 11 (7590 is equal to ten times
the number of octads). The distribution is rather good.
N(f)
f
Figure 1.
Number N(f) of octads obtained f times during 7590 walks
of length 11
Example 3: Random walk on a ternary Golay code
In the previous example, we focused on the binary Golay
code. There also exists a ternary Golay code with parameters
[12, 6, 6] whose words of Hamming weight equal to 6 yield
a 5-(12, 6, 1) design. The number of blocks of the design
being equal to 132. Thus, with a similar construction, we
can obtain a 5-out-of-12 generator. The automorphism
group of the design is of order 95040 = 26.33.5.11 and
is 5-transitive on the blocks of the design. This group is
generated by the following four permutations on the set of
12 coordinates.
A1 = (5, 9, 12, 7)(6, 10, 11, 8) of order 4
A2 = (3, 12, 7, 9)(4, 6, 10, 8), of order 4
A3 = (1, 3)(4, 8)(7, 11)(9, 12) of order 2
A4 = (2, 4, 5, 8)(6, 9, 10, 12) of order 4
and we consider
E := {A1, (A1)−1, A2, (A2)−1, A3, A4, (A4)−1, I},
where I represents the identity permutation. We have χ = 8
and κ = 6 from Table 3.
Number of blocks
Numbers of steps
74
5
58
6
Table 3: number of steps to obtain, during the walk, all blocks
from a speciﬁc block
With the appropriate parameters, equation (6) becomes
d(146 + 83γ) ≤ e−γ.
Example 4: Generator 2-out-of-31
In this example, we consider a 2-(31, 7, 7) design whose
automorphism group A is not 2-transitive on its blocks.
The number of blocks is 155. The group A is a permutation
group acting on the set of 31 coordinates. It is of order
465 = 3.5.31 and is generated by the following two
permutations
A1 = (1, 16, 15, 13, 9)(2, 18, 19, 21, 25)(3, 20, 23, 29, 10)
(4, 22, 27, 6, 26)(5, 24, 31, 14, 11)(7, 28, 8, 30, 12)
and
A2 = (2, 29, 10, 5, 20, 6, 17, 15, 21, 3, 26, 19, 9, 8, 11)
(4, 23, 28, 13, 27, 16, 18, 12, 30, 7, 14, 24, 25, 22, 31).
Consider the set of generators
E := {A1, (A1)−1, A2, (A2)−1, I}
and act the elements of E on a block m, N times, in order
to obtain a random block m′. This block can be represented
by a vector of weight 7 and length 31.
Computation gives κ = 6 and with the appropriate parame-
ters, equation (6) becomes
d(95 + 52γ) ≤ e−γ .
Then we have to randomly choose 2 coordinates equal to
1 in m’ using a 2-out-of-7 generator. To do this we consider
a 2-(7, 3, 1) design. The automorphism group of the design
is PSL(2, 7) and is 2-transitive on its blocks. We just have
to replace the ﬁrst 1 in m′ by a zero and carry out a walk on
this vector. We then obtain a random vector of weight 2 and
length 31. Notice that generators 2-out-of-31 and 2-out-of-7
can be executed in parallel.
Example 5: 3-out-of-16 generator.
It is important to choose a correct design in order to
carry out the walk. In fact, to obtain a uniform generator,
our method requires to consider designs with automorphism
group that is transitive on the blocks.
116
International Journal on Advances in Networks and Services, vol 4 no 1 & 2, year 2011, http://www.iariajournals.org/networks_and_services/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

We introduce here an example of automorphism group of
a design, which is not transitive on the blocks. The design
is constructed from a Hadamard matrix. Recall that the
order of a Hadamard matrix is necessarily a multiple of 4
and Sylvester construction shows that there exist Hadamard
matrices of order 2i for all positive integer i. Let H be the
following Hadamard matrix of order 16


1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
−
−
−
−
−
−
−
−
1
1
1
1
−
−
−
−
1
1
1
1
−
−
−
−
1
1
−
−
1
1
−
−
1
1
−
−
1
1
−
−
1
1
−
−
−
1
1
−
1
−
−
1
−
−
1
1
1
1
−
−
1
−
−
1
−
1
1
−
−
−
1
1
1
1
−
−
−
−
1
1
−
−
1
1
1
1
−
−
1
−
−
1
−
−
1
1
1
1
−
−
1
−
−
1
1
−
−
1
1
1
−
−
−
−
1
1
1
−
−
1
1
−
1
−
1
−
1
−
1
−
1
−
1
−
1
−
1
−
1
−
1
−
−
1
1
−
−
1
−
1
−
1
1
−
1
−
−
1
1
−
−
1
1
−
−
1
−
1
1
−
1
−
−
1
−
1
−
1
−
1
1
−
1
−
1
−
−
1
1
−
1
−
−
1
−
1
−
1
1
−
1
−
−
1
−
1
−
1
1
−
1
−
−
1
1
−
1
1
1
1
−
−
−
−
−
−
−
−
1
1
1
1


where the symbol "−" stands for "−1". This matrix yields a
3-(16, 8, 3) design with 30 blocks. The automorphism group
is of order 2688 = 27.3.7 and is generated by the following
permutations on the set of 16 coordinates:
A1 = (1, 5)(2, 10)(3, 12, 15, 8, 14, 6)(4, 7, 16, 11, 13, 9)
A2 = (2, 3, 4)(6, 8, 7)(9, 12, 10)(13, 16, 15)
A3 = (5, 10)(6, 9)(7, 12)(8, 11).
When acting the generators on the blocks, we obtain 2 orbits.
One of order 28 and the other one of order 2. It means that
from a given block, it is not possible to obtain all other
blocks during the walk.
Let us now consider the design D whose blocks are the
words of weight 12 of the extended Hamming code of
parameters [16, 12, 3]. This is a 3-(16, 12, 55) design with
140 blocks. The automorphism group of D is a permutation
group A acting on a set of cardinality 16. It is of order
322 560 = 210.32.5.7 and is generated by the following
automorphisms:
A1 = (5, 13)(6, 10)(7, 16)(9, 15)
A2 = (5, 16)(6, 9)(7, 13)(10, 15)
A3 = (3, 6)(4, 7, 10, 12)(8, 13, 15, 14)(9, 11)
A4 = (1, 5)(3, 6)(7, 12)(8, 15)
A5 = (2, 10, 13, 12, 4)(3, 16, 11, 8, 15)(5, 7, 9, 6, 14).
Consider the set of 8 generators
E := {A1, A2, A3, (A3)−1, A4, A5, (A5)−1, I}.
Then, choose a block m of the design and, since Aut(D)
is 3-transitive, just perform a walk on its ﬁrst 3 coordinates
using the elements of E. Here κ = 6 and so we get a random
word of weight 3 and length 16 as desired.
Number of blocks
Numbers of steps
4
4
119
5
19
6
Table 4: number of steps to obtain, during the walk, all blocks
from a speciﬁc block
The speed of convergence is given by
d(148 + 83γ) ≤ e−γ.
V. CONCLUSION
In this paper, we introduced a type of generators, which
has not been deeply studied in the literature. Yet, k-out-of-
n generators have a wide practical interest, particularly for
developing secure applications. Our constructions make use
of t-designs in order to obtain uniformity and run random
walks in order to control the accuracy of convergence.
We proposed methods to efﬁciently construct such gen-
erators and studied in detail special cases. The speed of
convergence of our generators is better than any known k-
out-of-n generators.
ACKNOWLEDGMENT
This work has partially been supported by ANR NUGET.
REFERENCES
[1] Bonnecaze A. and Liardet P., Efﬁcient Uniform k-out-of-n
Generators, ICSNC 2010, Fifth International Conference on
Systems and Networks Communications (ICNS 2010), pp.
177-182.
[2] Aldous D., Random walks on ﬁnite groups and rapidly
mixing Markov chains, Séminaire de Probabilités XVII
(1981/82), Lecture Notes in Mathematics, 1059, Springer,
Berlin (1983), pp. 243-297.
[3] Aldous D., Shufﬂing cards and stopping times, the American
Mathematical Monthly, 93, (1986), pp. 333-348.
[4] Atlas of Finite Group Representations.
http://brauer.maths.qmul.ac.uk/Atlas/v3/
spor/M24/, January 2011.
[5] Blum L., Blum M. and Shub M., A Simple Unpredictable
Pseudo-Random Number Generator, SIAM Journal on Com-
puting, volume 15, May 1986, pp. 364-383.
[6] Bonnecaze A., Liardet P., Gabillon A. and Blibech K.,
Threshold Signature For Distributed Time Stamping Scheme,
Annals of Télécommunications, Volume 62, N. 11-12 (2007),
pp. 1353-1364.
[7] Bonnecaze
A.
and
Trebuchet
P.,
Secure Time-Stamp
Schemes: A Distributed Point Of View, Annals of Télécom-
munications, Volume 61, N. 5-6, (2006), pp. 662-681.
[8] Colbourn C. and Mathon R., Steiner Systems, in Handbook
of Combinatorial Designs, second edition, Discrete Mathe-
matics and Its Applications (2007), pp. 102-110.
[9] http://www.ccrwest.org/cover.html,
January
2011
[10] Diaconis P. and Saloff-Coste L., Comparison techniques for
random walks on ﬁnite groups, The Annals of Probability,
Volume 21, No 4, (1993), pp. 2131-2156.
117
International Journal on Advances in Networks and Services, vol 4 no 1 & 2, year 2011, http://www.iariajournals.org/networks_and_services/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

[11] Durstenfeld R., Algorithm 235: Random permutation, Com-
munications of the Association for Computing Machinery,
volume 7, issue 7, (1964), pp. 420.
[12] Horn R.A. and Johnson R.C., Matrix analysis, Cambridge
Press, Cambridge, 2nd edition, (2008).
[13] Kemeny J. and Snell L., Finite Markov chains, Van Nostrand
company, Princeton, (1960).
[14] Knuth D.E., The Art of Computer Programming, Volume
2: Seminumerical Algorithms, Addison-Wesley, 2nd edition,
(1998).
[15] van Lint J.H. and Wilson R.M, A Course in Combinatorics,
Cambridge University Press (1992).
[16] MacWilliams F.J. and Sloane N.J.A., The Theory of Error-
Correcting Codes North-Holland, Eight impression, (1993).
[17] Nijenhuis A. and Wilf H.S., Combinatorial Algorithms for
Computers and Calculators, Academic Press, Inc., 2nd edi-
tion, (1978).
[18] NIST: A Statistical Test Suite for Random and Pseudo-
random Number Generators for Cryptographic Applications:
http://csrc.nist.gov/publications/nistpubs/
800-22-rev1/SP800-22rev1.pdf, January 2011.
[19] Ornstein D.S., Ergodic theory, randomness and dynamical
systems, Yale Mathematical Monographs No. 5, Yale Univ,
(1974).
[20] Ray-Chaudhuri D.K. and Tianbao Z., A recursive method
for construction of designs, Discrete Mathematics, Volumes
106-107, (1992), pp. 399-406.
[21] Rolland R., Sécurité des générateurs pseudo-aléatoires,
http ://www.acrypta.fr., January 2011.
[22] Rolland R., Personal communication, April 20, 2010.
[23] Saloff-Coste L., Lectures on ﬁnite Markov chains, in Lec-
tures on Probability Theory and Statistics, Ecole d’été de
Probabilités de Saint-Flour XXVI-1996, E. Giné, G.R. Grim-
mett and L. Saloff-Coste (Authors), Lecture Notes in Math,
No. 1665, pp. 301-413.
[24] Saloff-Coste L., Random Walks on Finite Groups, Probability
on discrete structures, 263–346, Encyclopaedia of Mathemat-
ical Sciences, 110, Springer, Berlin. Harry Kesten Editor,
(2004), pp. 263–346.
[25] Shields P., The Ergodic Theory of Discret Sample Paths,
Graduate Studies in Mathematics: 13, American Mathemat-
ical Society, (1996).
[26] Seneta E., Non-negative Matrices and Markov Chains,
Springer Series in Statistics, Springer, Revised Printing
(2006).
[27] Shoup V., Practical Threshold Signatures, EUROCRYPT’00:
Proceedings of the 19th international conference on Theory
and application of cryptographic techniques, Springer-Verlag
(1999), pp. 207-220.
[28] Sinai Ya. G., On a weak isomorphism of transformations
with invariant measure, Matematidheskii. Sbornik. (N.S.), 63
(105), No. 1 (1964), pp. 23-42.
[29] Sloane N.J.A., Encrypting by Random Rotations, Thomas
Beth (Ed.): Cryptography, Proceedings of the Workshop on
Cryptography, Burg Feuerstein, Germany, March 29 - April
2, 1982. Lecture Notes in Computer Science 149 Springer
(1983), pp. 71-128.
[30] Steiner J., (1853), Combinatorische Aufgabe, Journal fur die
Reine und Angewandte Mathematik 45, pp. 181-182 .
[31] Steiner Systems,
http://www.ccrwest.org/cover/steiner.html,
January 2011.
[32] Walters P., An Introduction to Ergodic Theory, Graduate texts
in mathematics: 79, Springer-Verlag (1982).
[33] Yao A., Theory and applications of trapdoor functions. In
Proceedings of the 23rd IEEE Symposium on Foundations
of Computer Science (1982), pp. 80-91.
118
International Journal on Advances in Networks and Services, vol 4 no 1 & 2, year 2011, http://www.iariajournals.org/networks_and_services/
2011, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

