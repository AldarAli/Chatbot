Robust Interactions under System Crashes and Network Failures
of Collaborative Processes with Arbitrary Control Flows
Lei Wang,
Lu´ıs Ferreira Pires
and Marten J. van Sinderen
CTIT, University of Twente,
the Netherlands
Emails: {l.wang-1, l.ferreirapires, m.j.vansinderen}@utwente.nl
Andreas Wombacher
Achmea, the Netherlands
Postbus 866
3700 AW Zeist
Email: andreas.wombacher@achmea.nl
Chi-Hung Chi
CSIRO, Australia
3-4 Castray Esplanade,
Hobart, Tasmania, 7000
Email: chihungchi@gmail.com
Abstract—Due to the possibility of system crashes and network
failures, the design of robust interactions for collaborative busi-
ness processes is a challenge. If a process changes state, it sends
messages to other relevant processes to inform them about this
change. However, server crashes and network failures may result
in a loss of messages. In this case, the state change is performed by
only one process, resulting in global state/behavior inconsistencies
and possibly deadlocks. Our idea to solve this problem is to
(automatically) transform the original processes into their robust
counterparts. We illustrate our solution using a subset of WS-
BPEL. A WS-BPEL process is modeled using a so called Nested
Word Automata (NWA), to which we apply our transformation
solution and on which we perform correctness proof. We have
also analyzed the performance of our prototype implementation.
In our previous work, we assumed that a certain pre-deﬁned
interaction follows the failed interaction. In this work, we lift this
limitation by allowing an arbitrary behavior to follow the failed
interaction, making our solution more generally applicable.
Keywords–robust, collaborative processes, WS-BPEL, interac-
tions, system crash, network failure, automata
I.
INTRODUCTION
The electronic collaboration of business organizations has
grown signiﬁcantly in the last decade. Often data interchange
is based on processes run by different parties exchanging
messages to synchronize their states. If a process changes
state, it sends messages to other relevant processes to inform
them about this change. However, server crashes and network
failures may result in a loss of messages. In this case, the
state change is performed by one process, resulting in global
state/behavior inconsistencies and possible deadlocks. In gen-
eral, a state inconsistency is not recovered by the process
engine that executes the process. This can be seen from a
screen dump of errors from the Oracle process engine 12c
which sends message to an unavailable server (see Figure 1).
Figure 2a shows that normally, a business process is
deployed to a process engine, which runs on the infrastructure
services (OS, database, networks, etc.), where system crashes
and network failures may happen. Our solution to recover
from failures is to transform business processes into their
robust counterparts, as shown in Figure 2b. The robust process
is deployed on the unmodiﬁed infrastructure services and is
recoverable from some interaction failures caused by system
crashes and network failures. Our solution has the following
properties: (1) the application protocols are not modiﬁed. We
do not modify the message format nor message sequence, e.g.,
by adding message ﬁelds that are irrelevant for the application
logic or adding acknowledge messages to the original message
sequence. The service autonomy is kept in that if one party
transforms the process according to our approach and the other
party does not, they can still interact with each other, although
without being able to recover from system crashes and net-
work failures. (2) the process transformation is transparent
for process designers. In this paper, we illustrate our solution
using WS-BPEL [1]. However, other process languages may
be applicable as long as they support similar workﬂow patterns
[2].
This
paper
is
an
extension
of
our
previous
work
[3][4][5][6], where we assumed that a certain pre-deﬁned
interaction follows the failed interaction, i.e., the only sequence
control is assumed that the further interaction is sequentially
following the failed interaction. A technical report [7] is pro-
vided as an online version with more details on the formalism
used and the transformation methods of our approach. In
this paper, we lift this limitation by allowing an arbitrary
behavior to follow the failed interaction, making our solution
more generally applicable. We support conditional control
ﬂow and loops and their arbitrary combination as possible
further interaction after interaction failure. The structure of the
paper is the following: Section II analyzes possible interaction
27
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-387-2
SERVICE COMPUTATION 2015 : The Seventh International Conferences on Advanced Service Computing

Figure 1. Oracle SOA engine interaction errors.
Networks
Operating
System
Process
Engine
Business
Processes
(a) Interaction failures
Networks
Operating
System
Process
Engine
Business
Processes
Robust
Processes
Processes
Transform
(b) Robust process transformation
Figure 2. Our idea to cope with failures.
Initiator
responder
(a) send and receive
Initiator
responder
(b) send-receive case I
Initiator
responder
XSU
XSU
XREQ
XRESP
XRESP
(c) send-receive case II
Figure 3. Process interaction patterns.
failures. Section III proposed our process transformation-based
solution. Section IV validates our solution. Section V discusses
related work and Section VI concludes our paper.
II.
INTERACTION FAILURE ANALYSIS
This section analyzes possible interaction failures of col-
laborative processes caused by system crashes and network
failures.
A. Process Interaction Patterns
Process interaction failures are speciﬁc to interaction pat-
terns. In [8], 13 interaction patterns are identiﬁed. In this paper,
we focus on the send, receive and send-receive patterns. This
limitation is not severe because more complex patterns can
be composed using these basic interaction patterns. Figure 3a
shows an initiator that sends a one-way message to a responder.
The initiator behavior corresponds to the send pattern, while
the responder behavior corresponds to the receive pattern. In
pattern send-receive in Figure 3b the initiator combines one
send and one receive pattern. We call this pattern asynchronous
interaction in the sequel of the paper. In Figure 3c, the initiator
starts a synchronous interaction by sending a request and
getting a response, which characterize the send-receive pattern.
B. Process Interaction Failures
Interaction failures caused by system crashes and network
failures are pending request failure, pending response failure
and service unavailable [4]. As all failures possible in the
interaction patterns of Figure 3a and Figure 3b are covered
by Figure 3c, we look only into the interaction failures of the
interaction pattern in Figure 3c. Service unavailable (marked
as XSU) is caused by a responder system crash or a network
failure of the request message delivery. At process level, the
initiator is aware of the failure through a catchable exception of
the process implementation language. Pending request failure
(marked as XREQ) is caused by initiator system crashes
after sending a request message. The initiator is informed
of the failure after restart, e.g., through catchable exceptions.
However, the responder is not aware of the failure, so that
it replies with the response message and continues execution.
Pending response failure (marked as XRESP ) is caused by a
responder system crash or a network failure of the response
message delivery. In both cases, the responder replies with
the response message (after a restart if the responder system
crashes) and continues execution. However, the connection gets
lost and the initiator cannot receive the response message. The
initiator is aware of this failure after a timeout.
Due to the heterogeneous infrastructure, e.g., different
process engine implementations or network environments, we
have to make the following assumptions concerning the failure
behavior of the infrastructure: 1) Persistent execution state. The
state of a business process (e.g., values of process variables)
are kept persistent and survive system crashes. 2) Atomic
activity execution (e.g., invoke, receive, reply). A system crash
means that the execution is stopped only after the previous
activity is ﬁnished and the next activity has not started.
A restart means that execution resumes from the previous
stopped activity. These assumptions correspond with the de-
fault behavior of the most popular process engines, such as
Apache ODE or Oracle BPEL Process Manager (released as a
component of Oracle SOA Suite). In Apache ODE’s term, this
is named as persistent processes in their default conﬁguration.
Otherwise this conﬁguration can be modiﬁed to “in-memory”
at deployment time [9]. For Oracle BPEL Process Manager,
this is named as “durable” processes, otherwise is named as
“transient” processes. By default all the WS-BPEL processes
are durable processes and their instances are stored in the
so called dehydration tables, which survives system crashes
[10]. 3) Network Failures interrupt the established network
connections and the messages that are in transit get lost.
III.
PROCESS TRANSFORMATION BASED SOLUTION
A. Business Processes
We choose WS-BPEL as process speciﬁcation language
in our work. A WS-BPEL process is a container where
relationships to external partners, process data and handlers
for various purposes and, most importantly, the activities to
be executed are declared. As an OASIS standard, it is widely
used by enterprises. We use Nested Word Automata (NWA)
[11] to describe the underlying semantics of WS-BPEL and use
them as a basis for our formal evaluation. We choose NWA
because we need to model the nested structure of WS-BPEL
syntax. While traditional ﬁnite state automata can be used for
28
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-387-2
SERVICE COMPUTATION 2015 : The Seventh International Conferences on Advanced Service Computing

<process>
</process>
NWA(act)
q0
q1
q2
q3
Figure 4. NWA model of a process.
<if>
true
end_true
NWA(act)
NWA(act)
false
end_false
</if>
(a) if
<pick>
<?m1>
</onMsg>
NWA(act)
NWA(act)
<?mn>
</onMsg>
</pick>
.
.
.
(b) pick
false
</while>
true
end_true
NWA(scope)
<while>
(c) while
<seq>
NWA(act)
</seq>
NWA(act)
next
(d) sequence
Figure 5. NWA model of WS-BPEL structured activities.
describing all possible states of messages, and their sending
and receiving sequences, they lack the capability of describing
nested structures of activities.
An NWA is an automaton that has hierarchical nesting
structures. Formally, an NWA A over an alphabet Σ is a
structure (Q, q0, Qf, P, p0, Pf, δc, δi, δr) consisting of
• a ﬁnite set of (linear) states Q,
• an initial (linear) state q0 ∈ Q,
• a set of (linear) ﬁnal states Qf ⊆ Q,
• a ﬁnite set of hierarchical states P,
• an initial hierarchical state p0 ∈ P,
• a set of hierarchical ﬁnal states Pf ⊆ P,
• a call-transition function δc : Q × Σ 7→ Q × P,
• an internal-transition function δi : Q × Σ 7→ Q, and
• a return-transition function δr: Q × P × Σ 7→ Q.
The deﬁnition of Q, q0, Qf, δi corresponds to the deﬁnition
of a ﬁnite state automata over an alphabet Σ [12]. The alphabet
Σ represents all possible process behaviors, e.g., <process>
∈ Σ represents the starting of a business process, ?mi ∈ Σ
represents receiving a message while !mj ∈ Σ represents
sending a message. An internal transition δi(qi, !mi) = qj
represents that the process replies a message !mi at the state qi
and then enters the state qj. The hierarchical states P, p0, Pf
are used to describe the nesting structure of an NWA. A
call transition δc enters the nested automaton while a return
transition δr leaves the nested automaton. A nested structure
is graphically represented as dashed box. The NWA model of
a WS-BPEL process is shown in Figure 4. A call transition
δc(q0, <process>) = (q1, pa) starts from the initial state and
a return transition δr(q2, pa, </process>) = q3 leads to the
accepted state. The NWA model of an activity NWA(act) is
nested within the NWA of the process. This is described by
the hierarchical state pa.
WS-BPEL activities are divided into two categories,
namely basic and structured activities. The currently supported
structured activities are if, pick, while and sequence, as shown
in Figure 5. The ﬂow (concurrent execution) or the other forms
of loops (RepeatUntil, ForEach) are not considered now and
<sequence>
    <receive variable="m1" ... />
    <!-- some process -->
    <reply variable="m2" ... />
    <pick>
        <onMessage variable="m3".../>
        <onMessage variable="m4".../>
    </pick>
</sequence>
(a) example WS-BPEL snippet
<sequence>
    <receive variable="m1" ... />
    <!-- some process -->
    <reply variable="m2" ... />
    <assign>$copy := $m2</assign>
    <pick>
        <onMessage variable="m3".../>
        <onMessage variable="m4".../>
        <onMessage variable="m1"
>
            <reply variable="copy" 
/>
        </onMessage>
    </pick>
</sequence>
(b) transformation, step I
Figure 6. WS-BPEL example of our solution.
will be considered in future work. Each structured activity
model has exactly one call transition and one return transition
to enter and leave its nested structure(s), which is represented
as a dash box. The detailed explanation of our formalization
is presented in [7].
B. Transformation Method
An operation that can be safely repeated is called idem-
potent [13]. Idempotent operations can be recovered by re-
sending the request message. However, a request resent to
non-idempotent operations (such as bank transfer operations)
triggers potentially incorrect executions. Our solution for non-
idempotent operation is that when a failure happens, a resent
message is replied with a copy of the previous processing
result.
In the example of Figure 6a, the WS-BPEL snippet receives
a message m1, performs some (non-idempotent) processing,
then replies with a message m2. The next incoming messages
could be m3 or m4. If the initiator sends request m3 or
m4, this implies that the initiator has successfully received
the response message m2. If due to an interaction failure, for
example, the initiator crashes and fails to receive the response
message m2, the initiator can recover by resending request
message m1. We then transform the responder process to use
a copy of the previous result as response. Figure 6b shows
that in order to make a copy of the response message, we
use an assign activity to keep the result value in a process
variable $copy. In the pick activity, we add an onMessage
branch to accept the resent message m1 and use the variable
$copy as the response. However, a resent message could be
sent multiple times before the response is ultimately received.
We nest the pick activity in a while to cope with the duplicate
resent message. A detailed discussion is in [7]. Our process
transformation algorithm is presented as follows.
1) Responder Transformation Algorithm: For a WS-BPEL
process, given its NWA model (Q, q0, Qf, P, p0.Pf, δc, δi, δr)
over the alphabet Σ, we assume that the alphabet that rep-
resents the response messages is Σresp and the alphabet that
represents the request messages is Σreq, thus Σreq ⊆ Σ and
Σresp ⊆ Σ. The transformation algorithm is as Figure 7.
The algorithm iterates through all combinations of a state
q, a request message ?mreq and a response message !mresp.
In line 2, we check if the message pair (?mreq, !mresp)
corresponds to the request and response for a synchronous
operation and at state q, the response message !mresp is sent,
29
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-387-2
SERVICE COMPUTATION 2015 : The Seventh International Conferences on Advanced Service Computing

1: for all q ∈ Q, ?mreq ∈ Σreq and !mresp ∈ Σresp do
2:
if (mreq, mresp) is a synchronous message pair and
δi(q, !mresp) is deﬁned in NWA then
3:
save reply(q, !mresp)
4:
N ← next receive(q, !mresp)
5:
for all ?mnext ∈ N and qnext ∈ Q do
6:
if δi(qnext, ?mnext) is deﬁned in NWA then
7:
transform receive(qnext, ?mnext)
8:
else if δc(qnext, ?mnext) is deﬁned in NWA then
9:
transform pick(qnext, ?mnext)
10:
end if
11:
end for
12:
end if
13: end for
Figure 7. Responder process transformation algorithm
represented by a transition δi(q, !mresp). This is the failure
point that the response message may be lost due to interaction
failures and where our transformation method applies. As
deﬁned in line 3, we ﬁrst make a copy of the response message,
as shown in Figure 8. The NWA model of reply activity in
Figure 8a is replaced by an NWA model of a sequence activity
in Figure 8b, in which a reply activity model and an assign
activity model are nested. The assign activity model represents
the copy of the reply message into the variable mcopy. In order
to process the possible resent request message ?mreq due to
the lost of the message !mresp sent at state q, we calculate the
set of all possible next incoming messages, which is deﬁned as
next receive(q, !mresp) in line 4. We construct an automaton
A(!mresp, ?mnext) as in Figure 9 to describe that a process
replies with a message !mresp and waits for some possible
next incoming message ?mnext. δ(q0, !mresp) = q1 models
the reply of the response message !mresp. δ(q1, Σ/Σreq) = q1
represents some process execution in which no messages
are received. δ(q1, ?mnext) = q2 represents that the process
receives an incoming message ?mnext. δ(q2, Σ) = q2 models
any process execution. For the process NWA model, at some
state q, a reply of a message !mresp is represented by an
internal transition δi(q, mresp). We change the initial state
of the process NWA model to from q0 to q, and call this
automaton NWA(q). Starting at q, after replying the message
!mresp, if one possible next incoming message is ?mnext, then
NWA(q) ∩ A(!mresp, ?mnext) ̸= ∅, i.e., the process modeled
by NWA has the behavior described by A(!mresp, ?mnext).
The intersection operation ∩ between an NWA and an
ﬁnite state automaton is deﬁned to check whether the busi-
ness process modeled by the NWA has the message send-
ing and receiving behavior modeled by the automaton. The
intersection operation is based on ﬁnite state automata. We
“ﬂatten” an NWA to a ﬁnite state automaton by skipping
hierarchical information, described as follows. Given a NWA
(Q, q0, Qf, P, p0, Pf, δc, δi, δr) over the alphabet Σ, the “ﬂat-
tened” automaton is A(Q, q0, Qf, Σ, δ), where Q, q0, Qf and
Σ are the same as the NWA, the transition function δ is deﬁned
as
1)
δ(qi1, a) = qi2, if the NWA has an internal transition
δi(qi1, a) = qi2.
2)
δ(qc1, a) = qc2, if the NWA has a call transition
δc(qc1, a) = (p, qc2).
!m_resp                         .
(a) reply activity
<seq> !m_resp
assg
mcopy:=m_resp </seq>
(b) Transformed reply activity
Figure 8. Responder process transformation, reply activity.
?mnext
!mresp
q0
q1
q2
Σ/Σrec
Σ
Figure 9. The automaton A(!mi, ?mnext).
?mnext
(a) Responder, receive activity
<pick>
<?mreq>
</onMsg>
<?mnext>
</onMsg>
</pick>
!mcopy
assg
(success := true)
(b) Transformed responder, part I
false
</while>
assign
(success:=false)
<while>
(success==false)
true
<pick>
</pick>
NWA(pick)
(c) Transformed responder, part II
Figure 10. Responder process transformation, receive activity.
3)
δ(qr1, a) = qr2, if the NWA has a return transition
δr(qr1, p, a) = qr2.
Both call transitions and return transition are treated as ﬂat
transitions that the hierarchical state p is not considered. The
intersection operation can be done between two ﬁnite state
automata, as deﬁned in [12].
We deﬁne the set of all possible next incoming messages
as next receive(q, !mresp) = {?mnext|?mnext ∈ Σreq∧
NWA(q) ∩ A(!mresp, ?mnext) ̸= ∅}.
For all ?mnext ∈ next receive(q, !mresp) and qnext ∈ Q,
if at the state qnext the next incoming message ?mnext
is received, two cases of transition may be deﬁned in
NWA: in a model of a receive activity as an internal tran-
sition δi(qnext, ?mnext) or in the model of a pick ac-
tivity as a call transition δc(qnext, ?mnext). For the ﬁrst
case (line 6), as shown in Figure 10a, the procedure
transform receive(qnext, ?mnext) is introduced as follows.
We replace the transition with a pick activity with two
branches, as shown in Figure 10b. One onMessage branch
models the receive of the resent message ?mreq and the reply
of the result message mcopy. The other onMessage branch
models the receive of the message ?mnext, and after that
we set the ﬂag success to true to indicate that the previous
interaction is ﬁnished successfully. However, a possible loss
of the response message mcopy triggers multiple resending of
the request mreq. Therefore, the pick activity is deﬁned in a
while iteration so that multiple requests ?mreq can be accepted.
Figure 10c shows that the while iteration ends when the ﬂag
success is set to true.
For the second case (line 8), as shown in Figure 11a, the
message ?mnext is one of the messages in m1, ..., mn. Figure
30
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-387-2
SERVICE COMPUTATION 2015 : The Seventh International Conferences on Advanced Service Computing

<pick>
<?m1>
</onMsg>
NWA(act)
NWA(act)
<?mn>
</onMsg>
</pick>
.
.
.
(a) Responder, pick activity
<pick>
<?m1>
</onMsg>
NWA(act)
<?mn>
</onMsg>
</pick>
.
.
.
<?mreq>
<seq>
assg
(success := true)
</seq>
NWA(act)
<seq>
assg
(success := true)
</seq>
</onMsg>
!mcopy
(b) Transformed responder, part I
Figure 11. Responder process transformation, pick activity.
11b shows that we then add a call transition <?mreq > to
model that the process accepts the resent message, and an
internal transition !mcopy to represent the reply using a copy
of the previously cached result mcopy. In the other branches,
the nested NWA(act) is replaced by the model of a sequence
activity, in which we model the assignment of the ﬂag variable
success to true, followed by the original NWA(act). Similarly,
in order to cope with a possible loss of the response message
mcopy, the pick activity model is nested in a while iteration
to handle multiple resent messages, as shown in Figure 10c.
We do not directly prove the correntness of this algorithm,
however, the correctness of the transformed processes by this
algorithm have been proved in section IV.
After the transformation, at some states the responder can
receive more messages than the original process, because the
resent message can be accepted and be replied. However, the
request is not processed again. In this sense, we do not give
malicious initiators any chance of jeopardizing the process by
changing the sequence of requests or sending the same request
multiple times.
2) Initiator Transformation: The initiator transformation
makes it resend the request message whenever a failure hap-
pens. The detailed transformation method is presented in [7].
3) Recoverable Assumption: Assume that (?mreq, !mresp)
is a pair of synchronous request and response messages,
the process receives request message ?mreq, then at state q,
the process sends the response message !mresp. However, if
?mreq ∈ next receive(q, mresp), then one of the next possi-
ble messages is still ?mreq, in this case, the responder cannot
distinguish a resent message due to a failure from a normal
request message. Thus we have to require that in the process
design the condition ?mreq /∈ next receive(q, !mresp) can be
met. However, by following a few process design principles
during the design of the original process, this condition can
be met. An example is, a split of message ?mreq into two
different messages, ?mreq1 and ?mreq2 (for example, one
message is used to send request, the other asks for results). The
initiator sends the two messages back to back. If a responder
receives ?mreq1, then it waits for ?mreq2, rather than waiting
Robust BPEL 
Processes
Original BPEL 
Test Set
Transform
Validate
Fail
Validate
Success
Correctness
Criteria
Figure 12. The setup of the correctness proof.
for ?mreq1 again.
IV.
EVALUATION
This section presents the correctness validation of our
solution. We also evaluate the performance overhead of our
prototype under different workloads.
A. Correctness Validation
The correctness proof shows that the solution introduced
in Section III provides a robust process. The core of the
proof is to deﬁne the correctness criteria for asynchronous and
synchronous interactions and represent them such that they can
be automatically evaluated.
Figure 12 shows the setup of our correctness proof. We
take the test set of 726 example WS-BPEL processes which
implement all possible Internet Open Trading Protocol (IOTP)
interactions [14], and we transform them into the NWA model
of the corresponding robust business process. The proof is
ﬁnished by checking that the NWA process model is a subset of
the correctness criteria, which are modeled as automata. Given
an automaton A(Q, Σ, δ, q0, F), each state in Q represents
a state of the messages sending and receiving status. Set Σ
models of all possible process behaviors, e.g., sending and
receiving messages. δ is transition function: Q × Σ → Q that
models the state transition triggered by process execution, e.g.,
for states qi, qj ∈ Q and !m ∈ Σ, δ(qi, !m) → qj represents
that at state qi, the process replies with message !m and then
enters state qj. The correctness criteria automata models the
set of correct message sending and receiving sequences. We
present the correctness criteria as follows.
1) Initiator Side Correctness Criteria: There are two cri-
teria due to the interaction patterns: the criteria for a single
message sending and the criteria for synchronous request and
response message pair. In this paper, we discuss only the latter
due to the page limitations. The automaton is visualized as
Figure 13a. A correct interaction is regarded as, a request
message ?m1 can be sent at state q0 and can be resent multiple
times at state q1 until a response message !m2 is received at
state q2.
2) Responder Side Correctness Criteria: The property we
want to validate is that any resent message can be accepted
by the transformed process and replied. Given a process,
assume that the synchronous request and response messages
are mj and mi. If the transformed robust process model
is NWA’, for state qi and transition !mi, we have ?mj ∈
next receive(qi, !mi). The idea behind it is that after the reply
message !mi is sent, the robust process can accept possible
resent messages due to failures. In this case, the response
should be sent without reprocessing. The criteria are shown
31
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-387-2
SERVICE COMPUTATION 2015 : The Seventh International Conferences on Advanced Service Computing

!m2
?m1
q0
q1
q2
?m1
Σ
(a) Initiator
?mj
!mi
q0
q1
q2
Σ/next_receive(qi, !mi)
Σ/!mi
!mi
next_receive(qi, !mi)/?mj
q3
Σ
(b) Responder
Figure 13. Correctness criteria of process transformation.
<pick>
<?m3>
</onMsg>
<?m4>
</onMsg>
</pick>
<seq> ?m1 !m2
</seq>
q0
q1
q2
q3
(a) Automaton model of the original process
<pick>
<?m1>
</onMsg>
<?m4>
</onMsg>
</pick>
end_true
q3
<seq> ?m1 !m2
q0
q1
q2
assign 
$copy:=m2 <while> false </while></seq>
true
<?m3>
assign 
$success:=
true
</onMsg>
assign 
$success:=
true
!m2
(b) Automaton model of the transformed process
Figure 14. Illustration of the correctness validation, robust
NWA model of Figure 6.
as Figure 13b. We omit the detailed discussion of this criteria
due to page limitations.
The process control ﬂows can be designed in arbitrary
ways, and since we cannot exhaust all possibilities, we use
a WS-BPEL test set that implements all possible IOTP inter-
actions, which is a total of 726 BPEL processes. After the
transformation of the test processes into automata, we apply
the subset check to evaluate the correctness of the WS-BPEL
test processes, i.e., we prove that for all processes and their
NWA model and criteria automaton A, NWA ∈ A, i.e., all
messages sending and receiving sequences are correct.
We take the process in Figure 6 to illustrate the correctness
validation. An original WS-BPEL snippet shown in Figure 6a
is transformed into the robust counterpart, and their automata
models are shown as Figures 14a and 14b, respectively. At
state q2, where the message !m2 is to be replied, the set
of the possible next incoming messages of the responder is
next receive(q2, !m2) = {?m1, ?m3, ?m4}. The criteria for
the synchronous request ?m1 and the response !m2 is shown as
Figure 15. First, we do a subset check to prove that the original
is not a subset of the criteria. Actually, we can see that the
message sequence (.., ?m1, !m2, .., ?m1, !m2, ..?m3, ..) can be
accepted by the criteria automaton. However, this sequence
cannot be accepted by the model of the original process, since
there is no transition deﬁned for the second ?m1. Second, we
do a subset check to prove the transformed automata model is
a subset of the criteria, i.e., all sending and receiving message
sequences are correct.
?m1
!m1
q0
q1
q2
Σ/{?m1,?m3,?m4}
Σ/!m1
!m2
{?m3,?m4}
q3
Σ
Figure 15. Correctness criteria for the illustrative process.
Initiator
Responder
Performance 
Data Collector
Figure 16. Setup of Performance Test.
TABLE I. PERFORMANCE OVERHEAD.
Origin
Trans
Overhead
Origin
Trans
Overhead
Workload λ = 5
Workload λ = 10
287 ms
379 ms
92 ms
322 ms
452 ms
130 ms
B. Performance Evaluation
In Figure 2 of the whole setup, if the infrastruc-
ture (OS, process engine, hardware and network conﬁgu-
ration) is the same, performance depends mainly on the
process design and the workload, i.e., performance =
Test(ProcessDesign, workload).
We use similar setup of our performance test with our
previous performance tests [15], which is shown in Figure 16.
We use the cloud infrastructure from Amazon EC2. The ini-
tiator and responder processes are deployed on two computing
instances and we use a local client to collect the performance
data.
We evaluated the performance overhead of our transformed
process under different workloads. The number of requests
sent per minute by the local client complies with a Poisson
distribution with parameters λ = 5 and λ = 10 requests per
minute. We used these workloads because according to our
tests under the available hardware and software conﬁgurations,
higher workloads would exhaust the server resources. We
use the open source Apache ODE process engine where an
embedded Derby [16] database is used. The Amazon EC2
instance type is t1.micro with 1 vCPU and 0.594GiB memory.
Each test run lasted for 60 minutes, but only the response
times in the 30 minutes in the middle of this period have been
considered (steady state).
The performance data is shown as Table I. Under the
workload of λ = 5, the average performance overhead of our
transformation mechanism is 92 ms. Under the workload of
λ = 10, the average overhead is 130 ms. We conclude then
that the performance overhead increases with the workload.
However, we expect lower performance overhead when the
infrastructure is scalable, like in a cloud environment.
32
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-387-2
SERVICE COMPUTATION 2015 : The Seventh International Conferences on Advanced Service Computing

V.
RELATED WORK
Solutions based on exception handling [17][18] is process-
speciﬁc. WS-BPEL supports compensations of well-deﬁned
exceptions using exception handlers. However, elaborate pro-
cess handler design requires process-speciﬁc knowledge of
failure types and their related recover strategies. Alternatively,
we try to ease the process designers from dealing with synchro-
nization failures by a transparent process transformation from
a given business process to its recovery-enabled counterpart.
A fault tolerant system can be built by coping with the
occurrence of failures by applying redundancy [13]. Three
kinds of redundancy are possible: information redundancy,
time redundancy and physical redundancy. However, the exist-
ing solution either require more effort of the business process
designers, or additional infrastructure support, or both.
On physical layer, the robust solutions on process engine
level [19][20] dependend on a speciﬁc process engine. We
deﬁned our solution based on the WS-BPEL building blocks
without requiring extensions at the engine level. However, the
transformed process can still be migrated to other standard pro-
cess engines. Reliable network protocols such as HTTPR have
been proposed to provide reliable synchronization. However,
the deployment of these solutions increases the complexity
of the network infrastructure. We assume that system crashes
and network failures are rare events, thus extending the in-
frastructure may introduce too much overhead. Further, the
solutions are not applicable in some outsourced deployment
environments. For example, in some cloud computing envi-
ronments, user-speciﬁc infrastructure conﬁguration to enhance
synchronization is not possible. Dynamic service substitution
[21][22] is a way to perform recovery by replacing the target
services by equivalent services. In [23][24], the QoS aspects
of dynamic service substitution are considered. In our work,
we do not change the business partners at runtime.
Information redundancy recovery is based on replication.
Our cache-based process transformation is information redun-
dant because a cache is a kind of replication. Time redundancy
solutions include web services transactions. The WS-AT [25]
standard speciﬁes atomic web services transactions, while
WS-BA [26] standard speciﬁes relaxed transactions so that
the participant can choose to leave the transaction before
it commits. However, if a transaction rolls back, a process-
speciﬁc compensation is required. Actually, transactions can
deal with well-deﬁned failures. The 2-phase commit distributed
transaction protocol can not deal with system crash (referred
to as cite failure in [27]). However, in a special case of process
in which all participants send vote results to a coordinator, if
the coordinator crashes before sending the vote results to any
participant, all the participants are blocked and the ﬁnal results
of the transaction remain unknown.
VI.
CONCLUSION AND FUTURE WORK
In this paper, we have identiﬁed three types of interaction
failures caused by system crashes and network failures and we
have proposed a process interaction failure recovery method
to cope with system crashes and network failures. This paper
is an extension of our previous work [3][4][5][6], where we
assumed that a certain pre-deﬁned interaction follows the failed
interaction. In this paper, we lift this limitation by allowing
an arbitrary behavior to follow the failed interaction, making
our solution more generally applicable. The challenge is to
accept the resent message due to failures with the arbitrary
control ﬂow of the responder process. We transformed the
business process design into nested word automata model. At
a state that models the reception of an incoming message,
we add an additional transition to accept the resent message
due to failure. We have proved the correctness of our process
transformations and we implemented a prototype to test the
runtime performance of our method. Currently, the transfor-
mation process is semi-automatic. We have implemented the
automatic transformation from a WS-BPEL process to the
NWA model, however, the transformation of the NWA model
to the robust counter part is manually. In future, we will
automate the transformation process and we will investigate
more complex process interaction patterns.
REFERENCES
[1]
OASIS,
Web
Services
Business
Process
Execution
Language,
2nd ed., OASIS, http://docs.oasis-open.org/wsbpel/2.0/OS/wsbpel-v2.0-
OS.html, [retrieved: Feb., 2015], Apr. 2007.
[2]
W.M.P. van der Aalst, A.H.M. ter Hofstede, B. Kiepuszewski, and
A.P. Barros, “Workﬂow patterns,” Distributed and Parallel Databases,
vol. 14, no. 1, Jul. 2003, pp. 5–51.
[3]
L. Wang, A. Wombacher, L. Ferreira Pires, M. J. van Sinderen, and C.-
H. Chi, “An illustrative recovery approach for stateful interaction failure
of orchestrated processes,” in IEEE 16th EDOC Workshops, 2012, pp.
38–41.
[4]
——, “A state synchronization mechanism for orchestrated processes,”
in IEEE 16th Intl. EDOC Conf., 2012, pp. 51–60.
[5]
——, “Robust client/server shared state interactions of collaborative
process with system crash and network failures,” in 10th IEEE Intl.
Conf. on Services Computing (SCC), 2013.
[6]
——, “Robust collaborative process interactions under system crash
and network failures,” Intl. J. of Business Process Integration and
Management, vol. 6, no. 4, 2013, pp. 326–340.
[7]
——, “Robust interactions under system crashes and network failures
of
collaborative
processes
with
arbitrary
control
ﬂows,”
CTIT,
University
of
Twente,
Tech.
Rep.,
2014.
[Online].
Available:
http://documentations123.appspot.com/sc2015/techrep.pdf,
[retrieved:
Feb., 2015]
[8]
A. Barros, M. Dumas, and A. Hofstede, “Service interaction patterns,”
in Business Process Management, ser. Lecture Notes in Computer
Science.
Springer Berlin Heidelberg, 2005, vol. 3649, pp. 302–318.
[9]
Apache ODE, “Create a process,” https://ode.apache.org/creating-a-
process.html#in-memory-execution.
[10]
SOA Technology for beginners and learners, “Transient vs. durable
bpel
processes,”
http://ofmxperts.blogspot.nl/2012/11/transient-vs-
durable-bpel-processes.html, Nov. 2012.
[11]
R. Alur and P. Madhusudan, “Adding nesting structure to words,” J.
ACM, vol. 56, no. 3, May 2009, pp. 16:1–16:43.
[12]
J. E. Hopcroft, Introduction to Automata Theory, Languages, and
Computation, 3rd ed.
Pearson Addison Wesley, 2007.
[13]
A. S. Tanenbaum and M. van Steen, Distributed Systems: Principles
and Paradigms, 2nd ed.
Upper Saddle River, NJ, USA: Prentice Hall,
2006, ch. 8, pp. 321–375.
[14]
J. Schiedung, “Analysing and modelling of IOTP transactions by CPNs
and BPEL,” Master’s thesis, Darmstadt University of Technology, 2004.
[15]
L. Wang, A. Wombacher, L. Ferreira Pires, M. J. van Sinderen, and C.-
H. Chi, “A colloborative processes synchronization method with regards
to system crashes and network failures,” in the 29th Symp. on Applied
Computing (SAC), 2014.
[16]
Apache
Software
Foundation,
“Ode
database
setup,”
http://ode.apache.org/databases.html.
33
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-387-2
SERVICE COMPUTATION 2015 : The Seventh International Conferences on Advanced Service Computing

[17]
N. Russell, W. Aalst, and A. Hofstede, “Workﬂow exception patterns,”
in Advanced Information Systems Engineering, ser. Lecture Notes in
Computer Science, E. Dubois and K. Pohl, Eds.
Springer Berlin
Heidelberg, 2006, vol. 4001, pp. 288–302.
[18]
B. S. Lerner, S. Christov, L. J. Osterweil, R. Bendraou, U. Kan-
nengiesser, and A. E. Wise, “Exception handling patterns for process
modeling,” IEEE Transactions on Software Engineering, vol. 36, no. 2,
2010, pp. 162–183.
[19]
S. Modafferi, E. Mussi, and B. Pernici, “Sh-bpel: a self-healing plug-in
for ws-bpel engines,” in the 1st workshop on Middleware for Service
Oriented Computing.
NY, USA: ACM, 2006, pp. 48–53.
[20]
A. Charﬁ, T. Dinkelaker, and M. Mezini, “A plug-in architecture for
self-adaptive web service compositions,” in IEEE Intl. Conf. on Web
Services, Jul. 2009, pp. 35–42.
[21]
M. Fredj, N. Georgantas, V. Issarny, and A. Zarras, “Dynamic service
substitution in service-oriented architectures,” in IEEE Congress on
Services - Part I, Jul. 2008, pp. 101–104.
[22]
L. Cavallaro, E. Nitto, and M. Pradella, “An automatic approach to
enable replacement of conversational services,” in Service-Oriented
Computing, L. Baresi, C.-H. Chi, and J. Suzuki, Eds.
Springer Berlin
Heidelberg, 2009, vol. 5900, pp. 159–174.
[23]
O. Moser, F. Rosenberg, and S. Dustdar, “Non-intrusive monitoring and
service adaptation for ws-bpel,” in the 17th intl. conf. on World Wide
Web.
NY, USA: ACM, 2008, pp. 815–824.
[24]
F. Moo-Mena, J. Garcilazo-Ortiz, L. Basto-Diaz, F. Curi-Quintal,
S. Medina-Peralta, and F. Alonzo-Canul, “A diagnosis module based
on statistic and qos techniques for self-healing architectures supporting
ws based applications,” in Intl. Conf. on Cyber-Enabled Distributed
Computing and Knowledge Discovery, Oct. 2009, pp. 163 –169.
[25]
OASIS Web Services Transaction (WS-TX) TC, Web Services Atomic
Transaction
(WS-AtomicTransaction),
http://docs.oasis-open.org/ws-
tx/wstx-wsat-1.2-spec.html, [retrieved: Feb., 2015], OASIS Standard,
Rev. 1.2, Feb. 2009.
[26]
——,
Web
Services
Business
Activity
(WS-BusinessActivity),
http://docs.oasis-open.org/ws-tx/wstx-wsba-1.2-spec-os/wstx-wsba-1.2-
spec-os.html, [retrieved: Feb., 2015], OASIS Standard, Rev. 1.2, Feb.
2009.
[27]
M. T. Ozsu, Principles of Distributed Database Systems, 3rd ed. Upper
Saddle River, NJ, USA: Prentice Hall Press, 2007, ch. 12.
34
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-387-2
SERVICE COMPUTATION 2015 : The Seventh International Conferences on Advanced Service Computing

