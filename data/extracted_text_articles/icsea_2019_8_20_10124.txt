Incorporating Petri Nets into DEVS Formalism for Precise System
Modeling
Radek Koˇc´ı and Vladim´ır Janouˇsek
Brno University of Technology, Faculty of Information Technology,
IT4Innovations Centre of Excellence
Bozetechova 2, 612 66 Brno, Czech Republic
email: {koci,janousek}@ﬁt.vutbr.cz
Abstract—Modeling and simulation are part of software de-
velopment because of their ability of system abstraction and
validation. One of the research motivation is oriented towards
more interactivity during system requirements modeling and a
possibility to investigate models under real condition. To achieve
this goal, the system has to be modeled precisely. There is a lot of
suitable paradigms—the paper concentrates especially on Object
Oriented Petri Nets (OOPN) and Discrete-Event Speciﬁcation
(DEVS) formalisms. OOPN constitute an abstract formalism
allowing a natural description of parallelism, synchronization and
non-determinism. The formalism of DEVS constitutes a basis for
a theory of modeling and simulation and can be considered as a
basic platform for multi-paradigm system design. Therefore, the
formalism of OOPN has been incorporated to the formalism of
DEVS.
Keywords–Object Oriented Petri Nets; DEVS; modeling; simu-
lation; interconnection.
I.
INTRODUCTION
Modeling plays an irreplaceable role in the software com-
munity, but its meaning is perceived in different ways. Its
primary task is to better present the domain problem solution,
to facilitate understanding of domain elements and, thus,
simplify the process of system analysis. In this understanding,
the model usually takes the form of static ﬁgures, which are
no longer used after analysis and design, eventually they serve
only as a starting point for implementation. However, the
implementation gradually moves away from these models and
the resulting product no longer corresponds to these models.
At this stage, tool-based testing or analysis cannot be provided
because the used models do not have a sufﬁcient level of
precision in the speciﬁcation of requirements. Some speciﬁed
elements need to be veriﬁed at a later stage of development,
or it is necessary to implement a prototype on which these
actions can already be performed. Both approaches extend the
time required to properly validate requests.
To model and analyze systems under real conditions during
the process of creating requirements and design, it is desirable
that these formal models can be linked to parts of the imple-
mentation that would be subject to the same way of running
control. In order to accurately determine point the system
diverts from expected behavior, we should be able to stop the
simulation and analyze it. We need to have such formalisms
that allow to control model execution.
The most widespread modeling tool is Uniﬁed Modeling
Language (UML) and its variants or adds that reﬁne models
(e.g., Object Constraint Language—OCL [1]) to allow their
simulation (e.g., Executable UML). Generally, these meth-
ods can be called executable modeling [2]. However, the
used formalisms usually lack an inherent relationship between
graphical representation of models and the precise speciﬁcation
of system behavior. There are approaches that attempt to
describe selected UML models in a fully formal way, such
as Foundational Subset for Executable UML Models (fUML)
[3], [4], which can specify a part of UML models by formal
description. On the other hand, this blurs the advantage of
UML, namely graphic notation.
The concept of model based design and executable mod-
eling is mainly applied to cyber physical systems [5] and is
not very widespread for system design and implementation.
This paper is a follow-up to the work on application of formal
models for speciﬁcation and design of software systems [6],
[7], which concentrates on DEVS and Petri nets formalisms.
DEVS is a systems speciﬁcation formalism developed by B.
Zeigler [8]. It constitutes a basis for theory of modeling and
simulation and can be considered as a basic platform for multi-
paradigm modeling and simulation [9]. Object Oriented Petri
Nets (OOPN) constitute a formalism suitable for structure
modeling with graphical notation [10].
If we want to integrate the created models into the real
environment, we must have a suitably adapted interface to
the system in which the considered real environment is im-
plemented. Implementation means its simulation, control of
simulated or real components, communication with a database
or other systems, etc. The formalism of OOPN allow to
incorporate executive code into a model—the code is placed
in transition actions. Such a solution makes it very difﬁcult
to adopt already existing code, complicates the simulation and
analysis of the model and may not be completely conformist
from the designer’s point of view. Another solution is to
select the appropriate interface and delegate code execution
to formalism, which allows direct code incorporation while
adopting a run-time management method. DEVS is such a
formalism, but it becomes less transparent for larger systems
(there is no other form of graphical presentation other than
blocks). Therefore, this paper deals with an incorporation of
OOPN and DEVS formalisms.
The paper is organized as follows. First, we brieﬂy present
formalisms of OOPN and DEVS (Section II). Section III takes
simulation control of both formalisms into account. Section IV
deals with the problem of incorporating OOPN into DEVS-
based framework. The OOPN and DEVS incorporation is
demonstrated on simple example in Section V. At the end,
we discuss results and beneﬁts of presented solution.
184
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

II.
USED FORMALISMS
This section brieﬂy introduces formalisms of OOPN and
DEVS that are taken into account in the paper.
A. Formalism of Object Oriented Petri Nets
Formally,
an
OOPN
is
a
tuple
Π
=
(Σ, Γ, V AR, CONST, c0, oid0),
where
Σ
is
a
system
of classes, Γ is a system of objects, V AR is a set of variables,
CONST is a set of constants, c0 is an initial class, and oid0
is the name of an initial object instantiated from c0.
Σ contains sets of structural elements, which constitute
classes. It comprises classes CLASS, net elements (places
P and transitions T ), class elements (object nets ONET ,
method nets MNET , synchronous ports SY NC, negative
predicates NPRED), and message selectors MSG. We de-
note NET = ONET ∪ MNET .
A class is mainly speciﬁed by an object net (an element of
ONET ), a set of synchronous ports and negative predicates
(a subset of SY NC and NPRED), a set of method nets (a
subset of MNET ), and a set of message selectors (a subset
of MSG) corresponding to its method nets, synchronous
ports, and negative predicates. Object nets describe possible
autonomous activities of objects, while method nets describe
reactions of objects to messages sent to them from the outside.
Synchronous ports are special transitions, which cannot ﬁre
alone but only dynamically fused to some other transitions.
Elements from CLASS and NET describe a structure of
simulation model and have to be instantiated to simulate the
model. For example, the instance of initial class c0 has to be
created with the object identiﬁer oid0. At the same time, there
are created instances of object net. If the message is sent to
the object, an instance of the method net is created.
Let us deﬁne Γ as a structure containing sets of object
identiﬁers OID, and method net instance identiﬁers MID. We
denote ID = OID ∪ MID. Object net is strictly connected
with the class, so that we can identify its instance by object
identiﬁer. We also deﬁne universe U as the set of tuples of
constants, classes, and object identiﬁers. The set of all bindings
of variables used in OOPN is then deﬁned as BIND = {b |
b : VAR −→ U}.
A state of a running OOPN model has the form of marking
of net instances. Marking is represented as the multiset of
token elements. An element of transition marking has a form
of cartesian product ID × T × BIND, where nid ∈ ID
represents the identiﬁer of the method or object net instance,
t ∈ T is a static representation of transition in the net instance
nid, and b ∈ BIND is one element of bound variables. An
element of place marking has a form of cartesian product ID×
P × U, where nid ∈ ID represents the identiﬁer of the net
instance, p ∈ P is a static representation of place in the net
instance nid, and u ∈ U is one element of place content. A
state s is then deﬁne as an item of multiset s ∈ [(ID × T ×
BIND) ∪ (ID × P × U)]MS.
Evaluation of transition ﬁreability is based on high-level
Petri net evaluation—a transition is ﬁreable for some binding
of variables, which are present in the arc expressions of its
input arcs and in its guard expression, if there are enough
tokens in the input places with respect to the values of input arc
expressions and if the guard expression for the given binding
evaluates to true.
B. Formalism of DEVS
DEVS is a formalism which can represent any system
whose input/output behavior can be described as sequence of
events. DEVS is speciﬁed as a structure
M = (X, S, Y, δint, δext, λ, ta)
where
X is the set of input event values,
S is the set of state values,
Y is the set of output event values,
δint : S −→ S is the internal transition function,
δext : Q × X −→ S is the external transition function,
Q = {(s, e) | s ∈ S, 0 ≤ e ≤ ta(s)} is the set of
total states,
e is the time passed since the last transition,
λ : S −→ Y is the output function,
ta : S −→ R+0,∞ is the time advance function.
At any time, the system is in some state s ∈ S. If no
external event occurs, the system is staying in state s for ta(s)
time. If elapsed time e reaches ta(s), then the value of λ(s)
is propagated to the output and the system state changes to
δint(s). If an external event x ∈ X occurs on the input in time
e ≤ ta(s), then the system changes its state to δext(s, e, x).
This way we can describe atomic models. Atomic models
can be coupled together to form a coupled model CM. The
later model can itself be employed as a component of larger
model. This way the DEVS formalism brings a hierarchical
component architecture. Sets S, X, Y are obviously speciﬁed
as structured sets. It allows to use multiple variables for
speciﬁcation of state and we can use input and output ports for
input and output events speciﬁcation, as well as for coupling
speciﬁcation. A lot of extensions and modiﬁcations of the
original DEVS has been introduced, such as parallel DEVS
[11] or dynamic structure DEVS [12] and a lot of simulation
frameworks has been developed.
III.
SIMULATION CONTROL
This section describes basic concepts of simulation control
for OOPN and DEVS formalisms.
A. DEVS Simulation
DEVS simulation is a structure SIMD = (DM, τD, D),
where DM is a DEVS model, τD ∈ N is a model time of
DEVS simulation, and D is a set of solvers. DEVS model
consists of coupled or atomic subcomponents, each such a
component is controlled by its solver. The simulation of DEVS
model is controlled by special root solver. The simulation
control can be described as shown in Figures 1, 2, and 3.
1 τD ← 0
2 ta ← 0
3 while ta ̸= ∞ do
4
call solver on root model
5
ta ← ta from root model
6
if ta ̸= ∞ then
7
τD ← τD + ta
8
end
9 end
Figure 1. DEVS Root Solver Control
185
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

The root solver (Algorithm 1) works in cycle until the time
advance ta gets inﬁnity. In each step, it calls a solver of root
model and updates the model time τD. If there is no component
which is able to do a step, the ta is set to inﬁnity.
1 DM i is a set of subcomponents of the component i
2 ta = ∞
3 foreach m ∈ DM i do
4
call solver on m
5
propagate event values from output ports of m to
connected input ports of subcomponents from
DM i
6
tm ← ta from component m
7
ta ← min(ta, tm)
8 end
Figure 2. DEVS Coupled Solver Control
The solver of coupled component (Algorithm 2) goes
through all subcomponents. For each subcomponent, the solver
calls a subcomponent solver and propagates event values from
its output ports to input ports of connected subcomponents. At
the end, the solver sets ta to be a minimum value of ta of all
subcomponents.
1 m is an atomic DEVS model
2 if ta = 0 then
3
execute the output function λ on m
4
execute the internal function δint on m
5 else
6
if an external event x ∈ X occurs then
7
execute the external function δext on m
8
end
9 end
10 ta ← ta from component m
Figure 3. DEVS Atomic Solver Control
The solver of atomic component (Algorithm 3) tests two
conditions. If its ta = 0, the output and internal functions
are executed. If ta > 0 (the component waits for the event)
and any external event occurs (an input port contains an event
value), the external function is executed. Finally, a new value
of ta is obtained.
B. OOPN Simulation
To
simulate
OOPN,
we
ﬁrst
extend
previously
established
deﬁnitions.
The
system
of
objects
Γ = (OID, MID, PID, FT ID) is extended to identiﬁers of
place instances PID and ﬁred transition instances FT ID.
We denote ID = OID ∪ MID ∪ PID ∪ FT ID. Let deﬁne a
relation @ ⊆ ID × CLASS ∪NET ∪P ∪T , which represent
relationships is an instance of. For example, (a, C1) ∈ @
means that a is an instance of the element named C1. We will
write this relation in the form a@C1. If the instance identiﬁer
is not important, we will type only @C1.
OOPN simulation is a structure SIMΓ = (Π, τΓ, CAL),
where Π is the system of OOPN classes and objects, τΓ ∈ N
is a model time, and CAL = {(t, e) | t ∈ N∧e ∈ FT ID}MS
is a calendar represented by multiset of timed events.
The transition t ∈ T can be ﬁreable for any of possible
bindings P(BIND). If the transition t is ﬁred for the binding
b ∈ P(BIND), three possibilities can occur—(a) the ﬁred
transition is completed immediately (it contains simple action),
(b) the ﬁred transition will wait for speciﬁed time, or (c)
the ﬁred transition will wait for called method ﬁnishing.
The possibilities (b) and (c) imply that the ﬁred transition
ft ∈ FT ID is created.
Three kinds of events can occur during the simulation—
ﬁreable transition (it can be ﬁred), ﬁred transition (it can be
complete, i.e., the method called from this transition ﬁnished),
and timed ﬁred transition (the transition waits for speciﬁed
time). The ﬁrst and second events are called executable events
and the third one is called timed event.
Let deﬁne objeventsΓ : OID → P(T ∪FT ID) determin-
ing executable events over all nets of the object, ϑ determining
a least time of event from the calendar, where
ϑ(C) =

∞,
C = ∅
t,
∃(t, e) ∈ C ∧ ∀(ti, ei) ∈ C : t ≤ ti
and eventsϑ(C) = {e | (t, e) ∈ C ∧ t = ϑ(C)}
determining a set of timed events having least time in the
calendar.
The simulation control is described in Algorithm 4. While
there is possible to do a step (activity = true), the simulator
calls one simulation step.
1 activity ← true
2 while activity = true do
3
call step
4 end
Figure 4. OOPN Simulation Control
The simulation step is described in Algorithm 5. First, it
obtains a set of objects having at least one executable event.
If this set in not empty, the simulator selects an event from
each such an object and ﬁres it. Firing events means that the
transition is ﬁred and completed, or the transition is only ﬁred
(so that the ﬁred transition ft ∈ FT ID arises), or the ﬁred
transition is completed. Second, if the set of objects is empty,
the simulator obtains a set of timed events. If this set is not
empty, it sets a model time τΓ to the value of ϑ and releases
all events waiting at the time ϑ. Releasing timed events means
that they are removed from calendar and becomes executable
events. Third, if there is no event in the calendar, the simulation
is ﬁnished (activity ← false).
IV.
EMBEDDING OOPN INTO DEVS
There are several techniques to integrate various for-
malisms. The most common ones are combination, mapping,
and wrapping. The combination derives a new formalism from
already existing ones by their combination, e.g., DEV&DESS
[13] or Hybrid Petri nets [14]. The mapping approach maps
formalisms to supporting one so that just the supporting
formalism is interpreted. The wrapping approach connects sim-
ulators of different formalisms so that each model is interpreted
by its simulator and simulators communicate with each other
by means of a compatible interface. It is advantageous if one
of the formalisms can be use as a control simulator for all other
formalisms. Since DEVS rigorously deﬁnes the component
interface, it is very suitable to serve as a basic component
186
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

1 objs = {o ∈ OID | objeventsΓ(o) ̸= ∅}
2 if objs ̸= ∅ then
3
foreach o ∈ objs do
4
e ← select an item from objeventsΓ(o)
5
ﬁre e
6
end
7 else
8
ev = eventsϑ(CAL)
9
if ev ̸= ∅ then
10
τΓ ← ϑ(CAL)
11
foreach e ∈ ev do
12
release event e
13
end
14
else
15
activity ← false
16
end
17 end
Figure 5. The OOPN Simulation Step.
platform for multiparadigmatic simulations. Consequently, we
have chosen wrapping to embed the OOPN formalism to the
DEVS formalism.
A. Ports and Places Mapping
Set of input event values X and output event values Y used
in the DEVS formalism can be speciﬁed as structured sets. It
allows to use multiple variables for speciﬁcation of state and
we can use named input and output ports for input and output
events speciﬁcation, as well as for coupling speciﬁcation. Let
us have the structured set X = (VX, X1 × X2 × · · · × Xn),
where VX is an ordered set of n variables and X1 × X2 ×
· · · × Xn denotes a value for each member from the set VX.
We can write the structured set as X = {(v1, v2, . . . , vn)|v1 ∈
X1, . . . , vn ∈ Xn)}. Members v1, v2, . . . , vn are called input
ports for the set X and output ports for the set Y .
DEVS components communicate each other through their
ports—when a new object is placed to the output port of a
component, it is carried to the appropriate input port of the
connected component. The way how to relate DEVS with
OOPN is to map ports and places.
Let MP N = (M, Π, mapinp, mapout) be a DEVS compo-
nent M which wraps an OOPN model Π, c0 ∈ CLASS is an
initial class of the model Π, oid0 ∈ OID is an initial object of
the class c0, VX is an ordered set of input ports of the model
M, and VY is an ordered set of output ports of the model
M. Let deﬁne onetΣ : CLASS → ONET determining an
object net of the class, placesΣ : NET → P(P) determining
a set of places of the net, and placeΓ : ID × P → PID
determining an instance of a place in the net. We divide
places of object net of an initial class c0 into two groups
P inp
c0 , P out
c0
⊆ placesΣ(onetΣ(c0)), where P inp
c0
∩ P out
c0
= ∅.
Then we can deﬁne a mapping of OOPN places into DEVS
ports as bijections mapinp : P inp
c0
→ VX and mapout :
P out
c0
→ VY .
Informally, if an OOPN model is deﬁned as a DEVS
component, then an object net of initial class deﬁnes input
and output places. The initial class is instantiated immediately
the component is created, and the deﬁned places serve as input
or output ports of the component.
B. OOPN Simulation Control Adaptation
In addition to place mapping, the simulation control has to
be adapted too. The OOPN simulator has to deﬁne functions
ta, δext, λ, and δint.
After each step, the simulator checks the time of the
next step by the function timeAdvance (t(a)). It tests three
conditions, as shown in Figure 6: (1) if there is at least one
executable object, the advance time is 0; (2) if there is at least
one timed event with activating time t, the time advance is a
difference of t and current model time τΓ; (3) if there is at
least one value in any place which is mapped as output port,
the advance time is 0 (the output function has to be executed
to propagate values from output ports); (3) otherwise, time
advance is infinity.
1 if ∃o ∈ OID : objeventsΓ(o) ̸= ∅ then
2
return 0
3 else
4
t = ϑ(CAL)
5
if t ̸= ∞ then
6
return t − τΓ
7
else
8
if ∃y ∈ VY : map−1
out(y) is not empty then
9
return 0
10
else
11
return ∞
12
end
13
end
14 end
Figure 6. timeAdvance ta
The external transition function δext is described in Fugure
7. If the component, which wraps OOPN model, receives
an external event (new data in its input ports), the function
extTransition (δext) is called. It takes values out from input
ports and puts them into mapped places.
1 foreach x ∈ VX do
2
p = map−1
inp(x)
3
v ← a value from x
4
if v is not empty then
5
put v into a place placeΓ(oid0, p)
6
end
7 end
Figure 7. extTransition δext
The output function λ is described in Figure 8. If the
component, which wraps OOPN model, has any value to be
put output ports, it takes values from mapped places and puts
them into into appropriate output ports.
The internal function δint is described in Figure 9. It is
modiﬁed simulation step from Figure 5. First, the model time
τΓ is not updated directly by OOPN simulator (see the line
10 in Figure 5), but is set to the model time τD of DEVS
root solver (see the line 1 in Figure 9). Second, the liveness
of simulation is not tested by means of the attribute activity,
but the function ta. Third, the simulation cycle is subordinate
to DEVS root solver, so that the simulation control described
in Figure 4 is not in use.
187
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

1 foreach y ∈ VY do
2
p = map−1
out(y)
3
v ← a value from placeΓ(oid0, p)
4
if v is not empty then
5
put v into an output port y
6
end
7 end
Figure 8. outputFunction λ
1 τΓ ← τD
2 objs = {o ∈ OID | objeventsΓ(o) ̸= ∅}
3 if objs ̸= ∅ then
4
foreach o ∈ objs do
5
e ← select an item from objeventsΓ(o)
6
ﬁre e
7
end
8 else
9
ev = eventsϑ(CAL)
10
if ev ̸= ∅ then
11
foreach e ∈ ev do
12
release event e
13
end
14
end
15 end
Figure 9. intTransition δint
C. Controlling External Events
In the course of simulation, the events arise and are served
inside the model. Nevertheless, DEVS components or OOPN
objects can serve as interfaces to the outer world and the
incidental events from the world can arise. DEVS controlling
uses se-message—a mechanism for a notiﬁcation of the root
solver about a state event, which serves as a request for internal
transition function. This mechanism is used especially in real-
time simulations.
In addition to internal events (ﬁreable transitions, ﬁred
transitions, and timed ﬁred actions), the simulation of OOPN
distinguishes control event (serving method nets instantiation
and destroying) and external event. Because OOPN objects
can communicate with objects from the outer world, OOPN
is able to work with extended set of classes ECLASS =
CLASS ∪ PCLASS, where PCLASS is a set of classes
of product environment. Then, external event represents a
message called from object o@C, where C /∈ CLASS. If
the message is received, the control event instantiates method
net, consequently, new internal events arise, and a signal for
starting simulation cycle in the case of activity = false is
generated. When the OOPN model is wrapped to DEVS com-
ponent, the signal for simulation cycle is simply substituted
for se-message.
V.
DEMONSTRATION OF OOPN EMBEDDING
We demonstrate embedding the OOPN formalism to the
DEVS formalism on a simple example.
A. Model
The model consists of two atomic components D1 and D2.
Each component has one input port inp and one output port
outp (VX = {inp} and VY = {outp}). Component ports are
connected as shown in Figure 10 (on the left).
C0 is_a PN
self hold: 20.
x
inp
outp
x
x
t11
calc: x
x
(#m, x)
return
D1
inp
outp
x
y
t12
p11
(#o, x)
10
(#o, y)
y
(#m, y)
D2
inp
outp
x <= 10
p1
t1
t2
Figure 10. An OOPN-DEVS example.
The DEVS component D2 is atomic component, which
gets a value x at its input port inp, and puts a value x + 1
to its output port outp. Formally, the component D2 deﬁnes
following functions:
δext :
x ← VX(inp)
λ :
x ̸= ∞ =⇒ VY (outp) ← x + 1
δint :
x ← ∞
ta :
(
0,
x ̸= ∞
∞,
x = ∞
The DEVS component D1 wraps an OOPN model Π
consisting of the class C0 (see the Figure 10 on the right).
The OOPN class has an object net and method net calc :. The
object net consists of places p1, inp, and outp, and transitions
t1 and t2. The class C0 is an initial class c0 of the model Π
and oid0 is an initial object. The input port inp is mapped to
the place inp and the output port outp is mapped to the place
outp.
B. Simulation without External Events
First, we will investigate what happens if the model simula-
tion starts and nobody will call the method calc: as an external
event. Possible states of the object oid0 are shown in Figure
11 in the form of place and ﬁred transition marking—p1(10)
means a place p1 with one token a number 10, @t1(x = 10)
means a ﬁred transition t1 with bound variable x = 10.
Simulation steps of components D1 and resp. D2 are
shown in Figure 12 and 13, respectively. Rows represents com-
ponent’s simulation step, columns contain information about
the step: i is step sequence number (over whole simulation),
τD is model time, s is current state,
λ
δext represents results
of stated functions, δint is a new state after executing the
function δint, event represents an event which has been ﬁred
(transition or ﬁred transition with the binding), and ta is time
advance after this step. Since the event, which has been ﬁred,
is relevant only for OOPN component D1, the column event
is not present for the component D2.
188
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

s
object net oid0
s0
p1(10), inp(), outp()
s1
p1(), inp(), outp(), @t1(x = 10)
s2
p1(), inp(), outp(10)
s3
p1(), inp(), outp()
s4
p1(), inp(11), outp()
s5
p1(11), inp(), outp()
Figure 11. List of states of the initial object oid0
There is a special sequence number i = 0 meaning ini-
tialization of components when only δint and ta are executed.
The component D1 ﬁres a transition t1 for bindings x = 10,
switches to a state s1, and its ta is 20, because the ﬁred
transition @t1(x = 10) holds for 20 time units. The component
D2 sets its internal variable x = ∞, stays in a state s0, and
produces ta = ∞ because there is no action to be done.
i
τD
s
λ
δext
δint
event
ta
0
0
s0
none
none
s1
t1(x = 10)
20
1
20
s1
none
none
s2
@t1(x = 10)
0
2
20
s2
Y (outp)←10
none
s3
−
∞
5
20
s3
none
inp←11
s4
−
0
6
20
s4
none
none
s5
t2(y = 11)
∞
Figure 12. Simulation step of the component D1
The next step i = 1 activates the component D1 for a time
20. It ﬁres an event @t1(x = 10), changes to a state s2, and
sets ta = 0 because the event put a value to the place outp
which is mapped to output port—the value has to be added to
mapped output port in next step. Step i = 2 generates a value
10 in the output port outp, switches D1 to a state s3, and sets
ta = ∞ because there is no event.
i
τD
s
λ
δext
δint
ta
0
0
s0
none
none
d0
∞
3
20
s0
none
x←10
d1
0
4
20
s1
Y (outp)←11
none
d2
∞
Figure 13. Simulation step of the component D2
The value is propagated through connection D1.outp →
D2.inp and the external function δext is executed on D2 in
step i = 3. It removes a value from input port inp, puts it
in variable x, and sets ta = 0 because the component has to
process this value in next step. The value is propagated through
connection D2.outp → D1.inp and the external function δext
is executed on D1 in step i = 5. It removes a value from input
port inp and puts it in the place inp. Step i = 6 carries the
value from place inp to place p1 and sets ta = ∞ because
there is no ﬁreable transition (the condition x <= 10 in C0.t1
is not met).
VI.
CONCLUSION
The paper raised a question of modeling systems in real
environments and a need for incorporating executive code into
system models. It also presented the solution based on a com-
bination of Petri nets and DEVS formalisms. The presented
solution makes it possible to associate the formal models
described by High-level Petri nets (not just OOPN) with an
executable code that is incorporated into DEVS formalism
structures. DEVS formalism has the advantage of being an
abstract concept that can be easily adapted to a particular
environment due to the basic structures and principle of the
simulator. In the future, we plan to fully incorporate DEVS
formalism to the implementation of the software modeling tool.
ACKNOWLEDGMENT
This work has been supported by the internal BUT project
FIT-S-17-4014 and The Ministry of Education, Youth and
Sports of the Czech Republic from the National Programme
of Sustainability (NPU II); project IT4Innovations excellence
in science – LQ1602.
REFERENCES
[1]
J. Warmer and A. Kleppe, The Object Constraint Language: Getting
your models ready for MDA.
Longman Publishing, 2003.
[2]
F. Ciccozzi, I. Malavolta, and B. Selic, “Execution of uml models:
a systematic review of research and practice,” Software & Systems
Modeling, vol. 18, no. 3, 2018, pp. 2313–2360.
[3]
S. Mijatov, P. Langer, T. Mayerhofer, and G. Kappel, “A framework for
testing uml activities based on fuml,” in Proc. of 10th Int. Workshop
on Model Driven Engineering, Veriﬁcation, and Validation, vol. 1069,
2013.
[4]
S. Guermazi, J. Tatibouet, A. Cuccuru, E. Seidewitz, S. Dhouib, and
S. G´erard, “Executable modeling with fuml and alf in papyrus: Tooling
and experiments,” in EXE@MoDELS, 2015.
[5]
R. Manione, “A full model-based design environment for the devel-
opment of cyber physical systems,” Design, vol. 3, no. 1, 2019, pp.
1–30.
[6]
R. Koˇc´ı and V. Janouˇsek, “The Object Oriented Petri Net Component
Model,” in The Tenth International Conference on Software Engineering
Advances.
Xpert Publishing Services, 2015, pp. 309–315.
[7]
R. Koˇc´ı and V. Janouˇsek, “Speciﬁcation of Requirements Using Uniﬁed
Modeling Language and Petri Nets,” International Journal on Advances
in Software, vol. 10, no. 12, 2017, pp. 121–131.
[8]
B. Zeigler, T. Kim, and H. Praehofer, Theory of Modeling and Simu-
lation.
Academic Press, Inc., London, 2000.
[9]
D. Cetinkaya, A. V. Dai, and M. D. Seck, “Model continuity in
discrete event simulation: A framework for model-driven development
of simulation models,” ACM Transactions on Modeling and Computer
Simulation, vol. 25, no. 3, 2015, pp. 17:1–17:24.
[10]
V. Janouˇsek and R. Koˇc´ı, “PNtalk: Concurrent Language with MOP,”
in Proceedings of the CS&P’2003 Workshop.
Warsaw University,
Warsawa, PL, 2003.
[11]
A. Chow and B. Zeigler, “Parallel devs: a parallel, hierarchical, modular,
modeling formalism,” in Proceedings of the 30th conference on Winter
simulation, 1994, pp. 716–722.
[12]
F. Barros, B. Zeigler, and P. Fishwick, “Multimodels and dynamic struc-
ture models: An integration of dsde/devs and oopm,” in Proceedings of
the 30th conference on Winter simulation, 1998, pp. 413–420.
[13]
B. Zeigler, “Embedding dev&dess in devs: Characteristic behavior of
hybrid models,” in DEVS Integrative M&S Symposium, 2006.
[14]
H. Alla and R. David, Discrete, Continuous, and Hybrid Petri Nets.
Springer, 2005.
189
Copyright (c) IARIA, 2019.     ISBN:  978-1-61208-752-8
ICSEA 2019 : The Fourteenth International Conference on Software Engineering Advances

