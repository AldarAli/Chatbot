Constructing Parallel Programs Based on Rule Generators
Kiyoshi Akama
Information Initiative Center
Hokkaido University
Hokkaido, Japan
Email: akama@iic.hokudai.ac.jp
Ekawit Nantajeewarawat
Computer Science Program
Sirindhorn International Institute of Technology
Thammasat University
Pathumthani, Thailand
Email: ekawit@siit.tu.ac.th
Hidekatsu Koike
Faculty of Social Information
Sapporo Gakuin University
Hokkaido, Japan
Email: koike@sgu.ac.jp
Abstract—We propose a new architecture of parallel pro-
grams based on the master-worker model of parallel com-
puting. In this architecture, computation is realized by rule
application and rule generation. A master has a set of equiva-
lent transformation rules (ET rules) and solves a problem by
successively applying ET rules to deﬁnite clauses representing
its computation state. A worker has a rule generator and
makes computation by generating ET rules on demand based
on run-time content of the master’s computation states. A
general scheme for constructing parallel programs based on
rule-set generators and rule-generator generators is presented
and a sufﬁcient condition for the correctness of the scheme
is established. Application of our framework to solving a
constraint satisfaction problem is illustrated.
Keywords-parallel computation; program correctness; rule
generation; equivalent transformation
I. INTRODUCTION
Constructing a correct parallel program that makes effec-
tive use of computing resources in a distributed environment
is a nontrivial task. Major difﬁculties include how to strictly
ensure the correctness of computation and how to obtain
substantial efﬁciency gains, in particular under situations
when the response time of distributed processes varies and
is often unpredictable. Such situations happen commonly
in distributed computing environments, owing not only to
a large variety of possibly distributed tasks but also to
other factors such as availability of computing resources and
stability of communication channels, etc.
A. The Proposed Parallel Program Architecture
We propose a new architecture of parallel programs,
where problem solving is carried out through rule appli-
cation and rule generation. The architecture is based on the
master-worker (or parent-child) model of parallel computing,
where one process, referred to as a master (or a parent),
solves a problem by distributing some tasks to other pro-
cesses, referred to as workers (or children). Assume that a
speciﬁcation S is given. The master has a set of equivalent
transformation rules (ET rules) with respect to S and its
computation state is represented as a set of deﬁnite clauses.
The master makes computation by successively applying ET
rules to clauses in its state. A worker has a rule generator
and makes computation by generating ET rules with respect
to S. Having an initial set of ET rules, the master (i) selects
an ET rule from its rule set and applies the rule, or (ii) sends
an atom set to a worker as a request for rule generation, or
(iii) receives an ET rule from a worker and adds it to the
rule set. Based on the given information from the master (a
selected atom set), a worker generates an ET rule using its
rule generator, and returns the rule to the master.
B. Effectiveness of the Proposed Architecture
Using the proposed architecture, the correctness of com-
putation can be guaranteed by combination of correct rules
and correct rule generators. From atom sets observed at run-
time, a master requests its workers to generate specialized
rules on demand. Using specialized rules that are tailored to
run-time content of computation states, substantial efﬁciency
improvement of computation in the master process can
be achieved, i.e., transformation steps can be reduced and
computational explosion can be suppressed. It is difﬁcult
to predict which specialized rules should be generated be-
forehand, and generating all specialized rules in advance at
compile time is impractical because there are usually far
too many possible states and there are usually many possible
specialized rules for each state, only a small part of which is
really used. Distributing run-time rule generation to workers
releases the master from the task of generating specialized
rules, which can take much time even when speciﬁc patterns
of target atoms are already determined.
The initial rule set of a master is prepared in such a
way that it is sufﬁcient for solving a problem, albeit not
efﬁciently, without additional rules obtained from workers.
As a consequence, delayed response of workers and com-
munication failure do not affect the completion of a problem
solving process. Rules obtained form workers contribute to
computation speedup, rather than completion of computa-
tion. Since rules have a precise procedural semantics [1],
the use of rules as messages returned from workers makes
clear the meanings of the messages. A returned rule can
be used any time no matter how the state of the master
is changed during the course of master-worker interaction.
No adjustment of returned rules is required even when the
173
INFOCOMP 2011 : The First International Conference on Advanced Communications and Computation
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-161-8

order of rule-generation requests and the order of the arrival
of their corresponding returned rules do not coincide.
C. Paper Organization and Notation
The paper progresses from here as follows: Section II
establishes a class of speciﬁcations considered herein. Sec-
tion III describes parallel programs in our proposed frame-
work. Section IV presents a scheme for construction of
parallel programs based on rule-set generators and rule-
generator generators, along with its correctness theorem.
Section V provides methods for constructing rule-set gen-
erators and rule-generator generators. Section VI illustrates
application of our framework to solving a constraint satis-
faction problem. Section VII concludes the paper.
The following notation holds thereafter. For any set A,
pow(A) denotes the power set of A. For any sets A and B,
PartialMap(A, B) denotes the set of all partial mappings
from A to B.
II. SPECIFICATIONS
A speciﬁcation provides background knowledge in a
problem domain and deﬁnes a set of queries of interest.
A speciﬁcation considered in this paper is formulated using
the concepts recalled below.
Assume that an alphabet ∆ for ﬁrst-order logic is given.
Let A and G be the set of all ﬁrst-order atomic formulas
(atoms) and that of all ground atoms, respectively, on ∆. Let
S denote the set of all substitutions on ∆. A deﬁnite clause
C on ∆ is an expression of the form a ← Bs, where a ∈ A
and Bs is a (possibly empty) ﬁnite subset of A. The set
{a}∪Bs is denoted by atoms(C); a is called the head of C,
denoted by head(C); Bs is called the body of C, denoted by
body(C); and each element of body(C) is called a body atom
of C. When body(C) = ∅, C is called a unit clause. The set
notation is used in the right-hand side of C so as to stress that
the order of atoms in body(C) is not important. However,
for the sake of simplicity, set braces enclosing body atoms
are often omitted; e.g., a deﬁnite clause a ← {b1, . . . , bn}
is often written as a ← b1, . . . , bn.
A declarative description on ∆ is a set of deﬁnite
clauses.1 The meaning of a declarative description is deﬁned
as follows: Given a deﬁnite clause C and a set G ⊆ G, let
T(C, G) = {head(Cθ) | (θ ∈ S) & (atoms(Cθ) ⊆ G) &
(body(Cθ) ⊆ G)}.
Let D be a declarative description. A mapping TD on
pow(G) is deﬁned by TD(G) = ∪
C∈D T(C, G) for any
G ⊆ G. The meaning of D, denoted by M(D), is then
deﬁned as the set ∪∞
n=1 T n
D(∅), where T 1
D(∅) = TD(∅)
and T n
D(∅) = TD(T n−1
D
(∅)) for each n > 1.
1We call a set of deﬁnite clauses a declarative description in order to
emphasize that no procedural meaning of it is considered.
A speciﬁcation on ∆ is a pair S = ⟨D, Q⟩, where D is a
declarative description, representing background knowledge,
and Q is set of atoms, representing queries. For any q ∈ Q,
the answer to q with respect to S is deﬁned as the set
M(D) ∩ rep(q),
where for any atom a, rep(a) is the set of all ground
instances of a. Let SPEC be the set of all such speciﬁcations.
III. PARALLEL PROGRAMS
A. Rules and Rule Generators
A transformation rule (for short, rule) is a relation on
deﬁnite-clause sets. A rule r transforms a set Cs of deﬁnite
clauses into another set Cs′ of deﬁnite clauses if ⟨Cs, Cs′⟩ ∈
r. Let RULE be the set of all such rules.
Assume that a set R of rules is given. To compute the
answer to a query q using R, a singleton deﬁnite-clause set
Cs0 = {ϕ(q) ← q}
is constructed, where ϕ is a bijective mapping that associates
with each atom a ∈ A an atom obtained from a by replacing
its predicate symbol with a new predicate symbol. Then a
transformation sequence
[Cs0, Cs1, . . . , Csm]
is constructed such that (i) for each i, ⟨Csi, Csi+1⟩ ∈ r for
some rule r ∈ R, and (ii) Csm is a set of unit clauses.
A rule generator is a partial mapping from pow(A) to
RULE. When an atom set A ⊆ A is given as input, a rule
generator yields a rule for transforming some deﬁnite clauses
whose bodies contain instances of A.
B. Parallel Programs
Assume that
• a master has n workers w1, . . . , wn,
• R0 is a set of rules, and
• for each i ∈ {1, . . . , n}, geni is a rule generator.
The pair ⟨R0, [gen1, . . . , genn]⟩ determines a parallel pro-
cedure, consisting of n + 1 processes, which is described
below. Assume that an input query q ∈ A is given.
• The Master Process: The master has a state ⟨Cs, R⟩,
where Cs is a set of deﬁnite clauses and R is a set of
rules, and it works as follows:
– Initially, the master sets
∗ Cs = {(ϕ(q) ← q)}, and
∗ R = R0.
– If Cs contains some non-unit clause, then the
master performs one of the following operations
nondeterministically whenever possible:
∗ Select a non-unit clause C from Cs, select a rule
from R, and update Cs by applying the selected
rule to C.
174
INFOCOMP 2011 : The First International Conference on Advanced Communications and Computation
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-161-8

∗ Select an atom set A from the body of one
clause in Cs and send it to a worker.
∗ Receive a rule r from a worker and add r to R.
– If Cs contains only unit clauses, then the master
outputs the set
∪
{rep(ϕ−1(a)) | (a ←) ∈ Cs}
as the computed answer.
• A Worker Process: A worker wi has a rule generator
geni and has a buffer storing atom sets received from
the master. At any time, it performs the following
operations sequentially:
1) Select one atom set A from the buffer.
2) Generate a rule r = geni(A).
3) Return r to the master.
With a design of more detailed control mechanism, the
procedure thus obtained is converted into a program in a
lower-level language, making optimization of state represen-
tation and memory usage. The lower-level implementation
part is however outside the scope of this paper, and the
pair ⟨R0, [gen1, . . . , genn]⟩ is also regarded as a parallel
program.
IV. A PARALLEL-PROGRAM CONSTRUCTION SCHEME
A scheme for constructing parallel programs using rule-set
generators and rule-generator generators is next described.
A. Rule-Set Generators and Rule-Generator Generators
First, a rule-set generator and a rule-generator generator
are introduced:
• A rule-set generator generates a set of rules from a
given speciﬁcation. It is formalized as a mapping from
SPEC to pow(RULE).
• A rule-generator generator generates from an input
speciﬁcation a rule generator (which is a partial map-
ping from pow(A) to RULE). It is formalized as a
mapping from SPEC to PartialMap(pow(A), RULE).
Based on the concept of an equivalent transformation rule,
the correctness of a rule-set generator and that of a rule-
generator generator are deﬁned:
• A rule r is an equivalent transformation rule (ET rule)
with respect to a declarative description D iff for any
⟨Cs, Cs′⟩ ∈ r, M(D ∪ Cs) = M(D ∪ Cs′).
• A rule-set generator RSG is correct iff for any speci-
ﬁcation S = ⟨D, Q⟩ ∈ SPEC, every rule in RSG(S) is
an ET rule with respect to D.
• A rule-generator generator RGG is correct iff for any
speciﬁcation S = ⟨D, Q⟩ ∈ SPEC and any A ⊆ A,
if RGG(S)(A) is deﬁned, then it is an ET rule with
respect to D.
B. A General Parallel-Program Construction Scheme
Construction of a correct rule-set generator and that of a
correct rule-generator generator provide a general ground-
work for constructing correct parallel programs from speci-
ﬁcations, using the following parallel-program construction
scheme.
1) Construct a correct rule-set generator RSG.
2) Construct correct rule-generator generators RGG1,
. . . , RGGn.
3) From a given a speciﬁcation S ∈ SPEC, construct a
parallel program ⟨R0, [gen1, . . . , genn]⟩ as follows:
• R0 = RSG(S).
• For each i ∈ {1, . . . , n}, geni = RGGi(S).
Even when only one rule-generator generator, say RGG, is
constructed at Step 2, i.e., RGG1 = · · · = RGGn = RGG, n
workers can still be useful for parallel processing since there
are many possible different atom sets to be distributed to
workers. Given a speciﬁcation S and different atom sets A1,
. . . , An, workers with the same rule generator RGG(S) may
produce different ET rules RGG(S)(A1), . . . , RGG(S)(An).
As a larger number of mutually independent rule-gener-
ator generators are available, a larger number of effective
workers can be used, potentially yielding more efﬁcient
parallel computation. The number of effective workers is
evaluated by the multiplication of (i) the number of mutually
independent rule-generator generators and (ii) the number of
atom sets to be sent to workers.
It is shown in [4] that the correctness of a rule-set gener-
ator and that of a rule-generator generator together provide
a sufﬁcient condition for a guarantee of the correctness of a
resulting parallel program. More precisely:
Theorem 1: Suppose that RSG is a correct rule-set gen-
erator and RGG1, . . . , RGGn are correct rule-generator gen-
erators. Then for any S ∈ SPEC, the parallel program
⟨RSG(S), [RGG1(S), . . . , RGGn(S)]⟩
is correct with respect to S.
V. CONSTRUCTING RULE-SET GENERATORS AND
RULE-GENERATOR GENERATORS
There are many possible correct rule-set generators and
many possible correct rule-generator generators. A large
variety of correct parallel programs can thus be constructed
using the scheme of Section IV. At present, several methods
exist for constructing correct rule-set generators and correct
rule-generator generators, some of which are described in
this section.
A. Meta-Computation-Based Generators
Meta-computation [2], [3] is a general purpose method for
generating ET rules from a speciﬁcation. The method takes
a declarative description D and an atom set A ⊆ A as input,
175
INFOCOMP 2011 : The First International Conference on Advanced Communications and Computation
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-161-8

and produces a nonempty output set of ET rules with respect
to D for transforming some deﬁnite clauses whose bodies
contain instances of A. When A is a singleton set containing
the most general atom with respect to some predicate p,2 the
output rule set includes the general unfolding rule for p with
respect to D.
Using meta-computation, a rule-set generator RSG is
constructed as follows: For any S = ⟨D, Q⟩ ∈ SPEC,
• generate a set {A1, . . . , Aq} of atom sets from Q,
• for each i ∈ {1, . . . , q}, construct a rule set Ri from D
and Ai by meta-computation, and
• produce RSG(S) = R1 ∪ · · · ∪ Rq.
Similarly, using meta-computation, a rule-generator gen-
erator RGG is constructed as follows: For any S = ⟨D, Q⟩ ∈
SPEC and any atom set A ⊆ A,
• construct a rule set R from D and A by meta-
computation,
• select a rule r from R, and
• produce RGG(S)(A) = r.
B. Rule Generation Based on Common Specializers
Let S = ⟨D, Q⟩ ∈ SPEC and a singleton atom set {a} ⊆
A be given. Assume that v1, . . . , vq are all the variables that
occur in a. A rule can be generated from S and {a} based
on common specializers as follows:
• Calculate the set G = {aθ | (θ ∈ S) & (aθ ∈ M(D))}.
• For each i ∈ {1, . . . , q}, ﬁnd a common ground term
for vi with respect to G, i.e., ﬁnd a ground term ti such
that for any ρ ∈ S, if aρ ∈ G, then viρ = ti.3
• Let E be the sequence of all equality atoms =(vi, ti)
such that ti is a common ground term for vi with
respect to G.
• Assuming that the sequence E thus obtained is [e1, . . . ,
eq′], where q′ ≤ q, construct a rule
a ⇒ {e1, . . . , eq′}, a.
This rule is applicable to a deﬁnite clause C if there
exist θ ∈ S and an atom b ∈ body(C) such that θ
contains only bindings for variables occurring in a and
aθ = b. When applied, the rule specializes C by the
evaluation of the equality atoms e1θ, . . . , eq′θ.4
VI. AN EXAMPLE
To illustrate application of our framework, a Pic-a-Pix
puzzle5 (Oekaki Logic or Paint by Numbers) of a ﬁxed size
m × n is used as an example problem.
2Given an m-ary predicate p, the most general atom with respect to p
is p(v1, . . . , vm), where the vi are mutually different variables.
3A common ground term for vi with respect to G is unique if it exists.
4When q′ = 0, the rule does not make clause specialization and it is not
used in a master process.
5http://www.conceptispuzzles.com.
Figure 1.
A Pic-a-Pix puzzle.
C1:
pat([], ∗Z) ← zeros(∗Z).
C2:
pat([∗a|∗X], ∗Y ) ← zeros(∗Z), ones(∗a, ∗A), pat(∗X, ∗B),
apps([∗Z, ∗A, ∗B], ∗Y ).
C3:
zeros([0]) ←.
C4:
zeros([0|∗X]) ← zeros(∗X).
C5:
ones(0, []) ←.
C6:
ones(∗n, [1|∗Y ]) ← >(∗n, 0), subtr(∗n, 1, ∗m), ones(∗m, ∗Y ).
C7:
apps([], []) ←.
C8:
apps([∗a|∗X], ∗Y ) ← apps(∗X, ∗Z), app(∗a, ∗Z, ∗Y ).
C9:
app([], ∗Y , ∗Y ) ←.
C10: app([∗a|∗X], ∗Y , [∗a|∗Z]) ← app(∗X, ∗Y , ∗Z).
Figure 2.
Representing background knowledge for Pic-a-Pix puzzles.
A. Problem Representation and Formulating a Speciﬁcation
First, consider the Pic-a-Pix puzzle of size 6×6 in Fig. 1.
It consists of a blank grid and clues, i.e., block patterns, on
the left of every row and on the top of every column, with
the goal of painting blocks in each row and column so that
their length and order correspond to the patterns and there
is at least one empty square between adjacent blocks.
The puzzle in Fig. 1 is represented by a Pic-a-Pix-atom
Pic-a-Pix([[1, 3], [5], [3], [4], [2, 2], [1]],
[[1, 3], [5], [3], [5], [2, 1], [1]],
∗mat),
where ∗mat is a variable. Other 6 × 6 Pic-a-Pix puzzles are
represented as Pic-a-Pix-atoms in a similar way. Let Q6×6
be the set of all such Pic-a-Pix-atoms. The speciﬁcation for
this class of puzzles, denoted by S6×6, is deﬁned by
S6×6 = ⟨{C0} ∪ DLINK ∪ DPIC ∪ DBLT, Q6×6⟩,
where C0 is the deﬁnite clause
C0:
Pic-a-Pix(∗t, ∗y, ∗mat) ←
=(∗t, [∗t1, ∗t2, ∗t3, ∗t4, ∗t5, ∗t6]),
=(∗y, [∗y1, ∗y2, ∗y3, ∗y4, ∗y5, ∗y6]),
matrix(∗t, ∗y, ∗mat), trans(∗mat, ∗tam),
pairing(∗t, ∗mat), pairing(∗y, ∗tam),
DLINK is a declarative description that provides the deﬁ-
nitions of matrix, trans, and pairing, DPIC consists of the
deﬁnite clauses C1–C10 in Fig. 2, and DBLT provides the
deﬁnitions of built-in predicates, such as > and subtr.
176
INFOCOMP 2011 : The First International Conference on Advanced Communications and Computation
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-161-8

C′
0:
Pic-a-Pix([∗t1, ∗t2, ∗t3, ∗t4, ∗t5, ∗t6],
[∗y1, ∗y2, ∗y3, ∗y4, ∗y5, ∗y6],
[[∗a11, ∗a12, ∗a13, ∗a14, ∗a15, ∗a16],
[∗a21, ∗a22, ∗a23, ∗a24, ∗a25, ∗a26],
[∗a31, ∗a32, ∗a33, ∗a34, ∗a35, ∗a36],
[∗a41, ∗a42, ∗a43, ∗a44, ∗a45, ∗a46],
[∗a51, ∗a52, ∗a53, ∗a54, ∗a55, ∗a56],
[∗a61, ∗a62, ∗a63, ∗a64, ∗a65, ∗a66]])
←
pat(∗t1, [0, ∗a11, ∗a12, ∗a13, ∗a14, ∗a15, ∗a16, 0]),
pat(∗t2, [0, ∗a21, ∗a22, ∗a23, ∗a24, ∗a25, ∗a26, 0]),
pat(∗t3, [0, ∗a31, ∗a32, ∗a33, ∗a34, ∗a35, ∗a36, 0]),
pat(∗t4, [0, ∗a41, ∗a42, ∗a43, ∗a44, ∗a45, ∗a46, 0]),
pat(∗t5, [0, ∗a51, ∗a52, ∗a53, ∗a54, ∗a55, ∗a56, 0]),
pat(∗t6, [0, ∗a61, ∗a62, ∗a63, ∗a64, ∗a65, ∗a66, 0]),
pat(∗y1, [0, ∗a11, ∗a21, ∗a31, ∗a41, ∗a51, ∗a61, 0]),
pat(∗y2, [0, ∗a12, ∗a22, ∗a32, ∗a42, ∗a52, ∗a62, 0]),
pat(∗y3, [0, ∗a13, ∗a23, ∗a33, ∗a43, ∗a53, ∗a63, 0]),
pat(∗y4, [0, ∗a14, ∗a24, ∗a34, ∗a44, ∗a54, ∗a64, 0]),
pat(∗y5, [0, ∗a15, ∗a25, ∗a35, ∗a45, ∗a55, ∗a65, 0]),
pat(∗y6, [0, ∗a16, ∗a26, ∗a36, ∗a46, ∗a56, ∗a66, 0]).
Figure 3.
A clause obtained by unfolding C0.
B. Determining the Forms of Exchange Information
The clause C0 is unfolded using DLINK, resulting in the
clause C′
0 in Fig. 3, which contains 6 + 6 pat-atoms in its
body. A copy of each of these pat-atoms is then added to
the body of C′
0. The predicate pat:c is used for denoting a
copy.6 The clause thus obtained is
ˆC′
0 :
head(C′
0) ← body(C′
0) ∪ copy(body(C′
0)),
where copy(body(C′
0)) is the set consisting of the 6+6 added
pat:c-atoms. These pat:c-atoms are designated as messages
that a master sends to workers. The original speciﬁcation
S6×6 is then transformed into the speciﬁcation
S′
6×6 = ⟨{ ˆC′
0, C′
1, C′
2} ∪ DPIC ∪ DBLT), Q6×6⟩,
where C′
1 and C′
2 are the deﬁnite clauses obtained from C1
and C2, respectively, by replacing the predicate pat with the
predicate pat:c.
C. Constructing a Rule Set Using Rule-Set Generators
Using a meta-computation-based rule-set generator, all
rules in Fig. 4 except r6 and also all rules in Fig. 5 are
generated. The rule r6 can be generated using another rule-
set generator, based on a method of ﬁnding a common
specialization from deﬁnite clauses. An unfolding rule corre-
sponding to ˆC′
0 is also generated using a meta-computation-
based rule-set generator.
The rules r1–r17 are specialized rules; they are applicable
to clauses whose bodies contain atoms having certain spe-
ciﬁc patterns. For example, r1 (respectively, r2) is applicable
to any clause containing in its body a pat-atom the ﬁrst
argument of which is an empty (respectively, nonempty)
6For example, the copy of the ﬁrst body atom of C′
0 is pat:c(∗t1, [0,
∗a11, ∗a12, ∗a13, ∗a14, ∗a15, ∗a16, 0]).
r1:
pat([], ∗Z) ⇒ zeros(∗Z).
r2:
pat([∗a|∗X], ∗Y )
⇒ zeros(∗Z), ones(∗a, ∗A), pat(∗X, ∗B), apps([∗Z, ∗A, ∗B], ∗Y ).
r3:
zeros([]) ⇒ {false}.
r4:
zeros([∗a]) ⇒ {=(∗a, 0)}.
r5:
zeros([∗a, ∗b|∗X]) ⇒ {=(∗a, 0)}, zeros([∗b|∗X]).
r6:
zeros(∗X), {pvar(∗X)} ⇒ {=(∗X, [0|∗Y ])}, zeros(∗X).
r7:
ones(0, ∗Y ) ⇒ {=(∗Y , [])}.
r8:
ones(∗n, ∗X), {>(∗n, 0)}
⇒ {=(∗X, [1|∗Y ]), subtr(∗n, 1, ∗m)}, ones(∗m, ∗Y ).
r9:
apps([], ∗Y ) ⇒ {=(∗Y , [])}.
r10: apps([∗a|∗X], ∗Y ) ⇒ apps(∗X, ∗Z), app(∗a, ∗Z, ∗Y ).
r11: app(∗X, ∗Y , []) ⇒ {=(∗X, []), =(∗Y , [])}.
r12: app(∗X, [], ∗Z) ⇒ {=(∗X, ∗Z)}.
r13: app([], ∗Y , ∗Z) ⇒ {=(∗Y , ∗Z)}.
r14: app([∗a|∗X], ∗Y , ∗Z) ⇒ {=(∗Z, [∗a|∗Z1])}, app(∗X, ∗Y , ∗Z1).
r15: app(∗X, [∗a|∗Y ], [∗b|∗Z]), {neq(∗a, ∗b)}
⇒ {=(∗X, [∗b|∗X1])}, app(∗X1, [∗a|∗Y ], ∗Z).
r16: app(∗X, [∗a1, ∗a2|∗Y ], [∗b1, ∗b2|∗Z]), {neq(∗a2, ∗b2)}
⇒ {=(∗X, [∗b1|∗X1])}, app(∗X1, [∗a1, ∗a2|∗Y ], [∗b2|∗Z]).
r17: zeros([∗a|∗X]), app(∗X, [1|∗M], [1|∗R])
⇒ {=(∗a, 0), =(∗X, []), =(∗M, ∗R)}.
r18: app(∗X, ∗Y , ∗Z)
⇒ {=(∗X, []), =(∗Y , ∗Z)};
⇒ {=(∗X, [∗a|∗X1]), =(∗Z, [∗a|∗Z1])}, app(∗X1, ∗Y , ∗Z1).
Figure 4.
Rules for solving Pic-a-Pix puzzles.
r19:
pat:c(∗R, [0, 0|∗S]) ⇒ pat:c(∗R, [0|∗S]).
r20:
pat:c([], [0, 1|∗S]) ⇒ {false}.
r21:
pat:c([], [0]) ⇒.
r22:
pat:c([∗n|∗R], [0, 1, 0|∗S]), {>(∗n, 1)} ⇒ {false}.
r23:
pat:c([∗n|∗R], [0, 1, 1|∗S]), {>(∗n, 1)}
⇒ {subtr(∗n, 1, ∗m)}, pat:c([∗m|∗R], [0, 1|∗S]).
r24:
pat:c([1|∗R], [0, 1, ∗y|∗S]) ⇒ {=(∗y, 0)}, pat:c(∗R, [0|∗S]).
Figure 5.
ET rules for removing useless parts of pat:c-atoms.
list. Both r1 and r2 have no execution part—they make
transformation merely by replacement of body atoms. The
rules r3–r6 are specialized rules for zeros-atoms. Since the
evaluation of the atom false fails, r3 always makes clause
removal when it is applied. Each of r5 and r6 contains both
an execution part and a replacement part. By using a pvar-
atom to constrain its applicability, r6 is only applicable to
a zeros-atom whose argument is a variable. The rule r18 is
a general rule; it is applicable to any clause whose body
contains any arbitrary app-atom. Since r18 has two bodies
in its right side, its application typically splits a clause into
two clauses.
D. Constructing a Rule Generator
Using rule generation based on common specializers
described in Section V-B, a rule generator employed by a
worker is constructed. To illustrate, suppose that a singleton
177
INFOCOMP 2011 : The First International Conference on Advanced Communications and Computation
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-161-8

atom set {a}, where
a = pat:c([1, 3], [0, ∗x1, ∗x2, ∗x3, ∗x4, ∗x5, ∗x6, 0]),
is given to a worker. The worker applies the rules in
Fig. 4 to make a transformation sequence producing the
set G consisting of all ground instances of a that belong
to M({ ˆC′
0, C′
1, C′
2} ∪ DPIC ∪ DBLT). The resulting set G
consists of the following three ground atoms:
• pat:c([1, 3], [0, 1, 0, 1, 1, 1, 0, 0])
• pat:c([1, 3], [0, 1, 0, 0, 1, 1, 1, 0])
• pat:c([1, 3], [0, 0, 1, 0, 1, 1, 1, 0])
From the common part of these atoms, the sequence of
equality atoms [=(∗x4, 1), =(∗x5, 1)] is obtained. Accord-
ingly, the rule
pat:c([1, 3], [0, ∗x1, ∗x2, ∗x3, ∗x4, ∗x5, ∗x6, 0])
⇒ {=(∗x4, 1), =(∗x5, 1)},
pat:c([1, 3], [0, ∗x1, ∗x2, ∗x3, ∗x4, ∗x5, ∗x6, 0])
is generated.
E. Parallel Computation
When the master receives an input problem q ∈ Q6×6, it
creates an initial clause set Cs0 = {ϕ(q) ← q}. When the
computation starts, the master transforms ϕ(q) ← q using
the unfolding rule corresponding to ˆC′
0. This transformation
yields a deﬁnite clause with only pat-atoms and pat:c-atoms
in its body. Using the rules in Fig. 4, which are generated
from DPIC, pat-atoms are successively transformed. By
application of the rules r1 and r2, pat-atoms are all replaced
with some other atoms, while pat:c-atoms do not disappear.
The single-body rules r1–r17 are given priority over the
multi-body rule r18. When no single-body rule is applicable,
the master uses r18, which increases the number of clauses.
Supposing that the master only applies the rules in its
initial rule set without requesting any worker to generate
any additional specialized rule, the answer to the puzzle in
Fig. 1 is obtained after 10,789 rule application steps, 1,520
of which are clause-splitting steps. In comparison, when
workers are used to generate specialized rules on demand
based on the proposed architecture, the total number of rule
application steps in the master process reduces from 10,789
to 512 in our experiment, with the number of clause-splitting
steps reducing from 1,520 to zero.
Employment of specialized rules obtained by rule gen-
eration on demand based on run-time content of computa-
tion states usually decreases problem-solving time greatly.
Compared to application of an existing rule, generation of
a new rule itself may take much time. By distributing the
tasks of run-time rule generation to workers, the master
does not bear the cost of rule generation and, therefore, the
overall computation time in the master process substantially
reduces.
VII. CONCLUSIONS
We establish a theory of direct connection between speci-
ﬁcations and correct parallel programs, which shows a sharp
contrast to the usual parallel logic programming approaches
([5], [6], [7]), where a human programmer constructs a
parallel program based on a speciﬁcation without a guarantee
of correctness. A parallel program in our framework consists
of ET rules and rule generators. If all ET rules and all
rule generators in a parallel program are correct, then the
program is correct. Since there are a large variety of ET rules
and rule generators, our framework provides a large space
of correct parallel programs, which widens the possibility
of ﬁnding an efﬁcient program with a relatively small cost.
ET rules and rule generators are constructed not only by
human programmers, but also by automatic rule generators.
A program construction scheme based on rule-set generators
and rule-generator generators is described. As long as correct
rule-set generators and rule-generator generators are used, a
resulting program always yields correct computation and,
consequently, veriﬁcation of the obtained program, which is
usually a very expensive task, is not necessary.
REFERENCES
[1] K. Akama and E. Nantajeewarawat, Formalization of the
Equivalent Transformation Computation Model, Journal of Ad-
vanced Computational Intelligence and Intelligent Informatics,
10: 245–259, 2006.
[2] K. Akama, E. Nantajeewarawat, and H. Koike, Program Syn-
thesis Based on the Equivalent Transformation Computation
Model, Proc. the 12th International Workshop on Logic Based
Program Synthesis and Transformation, Madrid, Spain, pp.
285–304, 2002.
[3] K. Akama, E. Nantajeewarawat, and H. Koike, Program Gen-
eration in the Equivalent Transformation Computation Model
Using the Squeeze Method, Perspectives of System Informatics,
Lecture Notes in Computer Science, Vol. 4378, pp. 41–54,
Springer-Verlag, Berlin Heidelberg, 2007.
[4] K. Akama, E. Nantajeewarawat, and H. Koike, Constructing
Parallel Programs Based on Rule Generators, Technical Report,
Hokkaido University, Sapporo, Japan, 2011.
[5] J. Chassin de Kergommeaux and P. Codognet, Parallel Logic
Programming Systems, ACM Computing Surveys, 26: 295–336,
1994.
[6] G.
Gupta,
E.
Pontelli,
K.
Ali,
M.
Carlsson,
and
M.
Hermenegildo, Parallel Execution of Prolog Programs: a Sur-
vey, ACM Transactions on Programming Languages and Sys-
tems, 23: 472–602, 2001.
[7] V. Santos Costa, Parallelism and Implementation Technology
for Logic Programming Languages, in Encyclopedia of Com-
puter Science and Technology, Vol. 42, pp. 197–237, Marcel
Dekker Inc., New York, 2000.
178
INFOCOMP 2011 : The First International Conference on Advanced Communications and Computation
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-161-8

