A Model-Based Approach to Validate Conﬁgurations at Runtime
Ludi Akue, Emmanuel Lavinal, Michelle Sibilla
IRIT, Universit´e de Toulouse
118 route de Narbonne
F31062 Toulouse, France
Email: {akue, lavinal, sibilla}@irit.fr
Abstract—Dynamic reconﬁguration is viewed as a promising
solution for today’s large scale and heterogeneous comput-
ing environments. However, considering the critical missions
networked systems support, dynamic reconﬁguration cannot
be achieved unless the accuracy of its behaviors is guar-
anteed. For that reason, dynamic reconﬁguration solutions
should provide validation capabilities to ensure the correctness
and the safety of reconﬁguration activities. Current solutions
mainly address use-case speciﬁc conﬁguration validation or
fail to handle the additional operational validity requirements
induced by dynamic reconﬁguration. In this paper, we describe
a model-based approach for validating conﬁguration changes
at runtime. The approach is based on MeCSV, a metamodel
that allows a platform and vendor-independent speciﬁcation
of a reference model, that is, the conﬁguration schema of the
managed system as well as constraints that should be respected
for structural consistency and operational compliance. We
provide an overview of the MeCSV language and demonstrate
the feasibility of this approach using a messaging platform case
study.
Keywords-dynamic reconﬁguration; conﬁguration validation;
conﬁguration speciﬁcation; model-based approach.
I. INTRODUCTION
The self-management vision has gained a lot of mo-
mentum in networked systems management where it is
viewed as a promising solution for today’s large scale and
heterogeneous computing environments management. This
vision consists mainly in endowing managed systems with
self-adaptation capabilities to maximize their usability [1].
Regardless of the management functional domains (e.g.,
fault, performance, security), dynamic reconﬁguration activi-
ties are the principal means through which self-management
is carried out. However, dynamic reconﬁguration capabili-
ties should not endanger the system’s operation, otherwise
they would nullify the expected beneﬁts: reconﬁguration
validation is one of the fundamental issues that conditions
dynamic reconﬁguration effectiveness [2]. Consequently,
management systems should support online validation to
guarantee the correctness and the safety of reconﬁguration
activities.
This paper complements previous work on deﬁning a
framework for dynamic reconﬁguration validation. In [3],
we argued that runtime reconﬁguration validation should go
beyond traditional structural sanity checks to further assess
the safety of candidate conﬁgurations regarding operational
conditions at hand. For example, when a max request size is
erroneously set smaller than the current number of requests
sent to a process, it can introduce some inconsistencies thus
compromise the system’s operation. In other words, in the
matter of self-conﬁgurable systems, prevailing operational
states can invalidate the suitability of a runtime produced
conﬁguration no matter its structural correctness. Conse-
quently dynamic reconﬁguration validation should consider
an operational applicability validation which consists of
validating proposed conﬁguration changes against the cur-
rent system’s operational state to test the suitability of its
deployment.
In this paper, we present a model-based approach for con-
ﬁguration speciﬁcation that enables a platform-independent
validation of conﬁguration modiﬁcations at runtime.
The approach is based on a metamodel we develop named
MeCSV (Metamodel for Conﬁguration Speciﬁcation and
Validation). MeCSV implements appropriate constructs that
allow vendors or operators to deﬁne their own reference
model that every valid conﬁguration instance should con-
form to, independently from management platforms and
conﬁguration protocols in use.
Indeed, MeCSV provides an intermediate high-level lan-
guage that resolves the heterogeneity of conﬁguration in-
formation and semantics. It also includes rule speciﬁcation
features to deﬁne different types of constraints to be val-
idated dynamically on speciﬁc conﬁgurations produced at
runtime. Finally, MeCSV incorporates constructs to repre-
sent monitored data of interest that will serve to assess the
operational compliance of a given conﬁguration instance.
In particular, one novelty of the metamodel is to include
the capability to express both ofﬂine and online constraints.
The former allows operators to deﬁne structural integrity
rules while the latter allows them to deﬁne rules to be en-
forced regarding operational conditions, necessary to ensure
the operational validity of produced conﬁgurations.
The remainder of the paper is structured as follows:
Section II presents related work and Section III includes
a case study that will be used throughout the article to
illustrate usage examples of the MeCSV metamodel. Section
IV introduces the validation approach we propose, built upon
the MeCSV metamodel whose core constructs are described
in Section V. Finally, Section VI describes implementation
133
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

details of a prototype experiment and Section VII concludes
the paper and identiﬁes future work.
II. RELATED WORK
The need for conﬁguration representation standards and
conﬁguration automation are growing concerns regarding
the complexity of the conﬁguration management of today’s
large-scale and heterogeneous systems [4], [5]. Our work is
at the junction of these two topics as the MeCSV metamodel
enables a generic and vendor-independent conﬁguration
speciﬁcation and runtime validation which is a prerequisite
for conﬁguration automation as well as self-conﬁguration.
Most related work proposes platform-dependent data
models that principally provide structural integrity checks
of functional conﬁguration parameters [2], [6], [7], [8] and
consider to a lower extent the validation of non-functional
conﬁguration parameters whose values depend on ongoing
operational conditions (e.g., QoS, resources utilization). The
novelty of our approach is to provide a language that is
designed speciﬁcally for dynamic validation, it addresses
both structural and operational validity.
The DMTF Common Information Model (CIM) [9] and
the YANG data modeling language [10] include construc-
tions to model conﬁguration data. CIM provides partic-
ularly SettingData and the OCL qualiﬁer constructs that
can be used to indicate conﬁgurations and constraints to
be respected, however, these elements are close to manual
conﬁguration, thus not ﬂexible for a runtime reconﬁguration
environment. YANG provides a ﬂexible data modeling lan-
guage with means to specify structural constraints that will
be enforced at runtime. However, YANG is speciﬁc to the
Network Conﬁguration Protocol (NETCONF) [11].
Our work also relates to PoDIM, a high-level language
that allows to describe conﬁgurations as well as express
the structural constraints that should be respected during
managed objects creation and modiﬁcation [7]. Even though
they also deﬁne a high-level language for conﬁguration
speciﬁcation, the two approaches are different since PoDIM
is used to generate valid conﬁgurations (from rules deﬁned
by an administrator) whereas we validate conﬁgurations
produced by existing management systems. In contrast to
PoDIM, we also addresses the operational compliance issue.
Conﬁguration validation is also addressed as a Constraint
Satisfaction Problem [12], [13]. Nevertheless, the considered
constraints are structural and static and their satisfaction
does not consider the operational environment that can
condition the applicability of generated conﬁgurations. A
runtime validation is still required to assert the operational
compliance of generated conﬁgurations regarding runtime
conditions variations.
III. USE CASE
This section introduces a Message-oriented Middleware
(MOM) use case on which the examples given throughout
the following sections will be based.
MOM systems are proﬁtable to integrate heterogeneous
and distributed applications seamlessly by making use of
messaging servers to mediate communications between
them. One other advantage is that by adding a management
interface, an operator can monitor and manage the sys-
tem’s performance, reliability and scalability without losing
function. Validating a MOM system’s runtime evolving
conﬁgurations is a suitable scenario for the evaluation of
the approach we propose. The formalisms we will rely on
respect the JORAM MOM conﬁguration description [14].
A JORAM platform provides the following conﬁgurable
features: message servers that route and deliver messages,
destinations that are physical storages supporting either a
point to point messaging (queue) or a “publish/suscribe”
messaging (topic), connection factories used to enable client
connections to the message servers according to used con-
nection protocols (e.g., TCP).
Figure 1 presents the distributed JORAM platform conﬁ-
guration example that will be used in Section VI (recon-
ﬁgurations scenarios). It consists of three servers S0, S1,
S2 respectively providing queue-type destination (Qa, Qb,
Qc, Qd and Qe) and TCP connection services to client
applications.
Conﬁguring this example platform consists in conﬁguring
each server, that is setting servers’ local parameters (e.g.,
identiﬁer, name, hostname) and the conﬁguration parameters
of the hosted elements (services, connection factories and
destinations).
  Server S1
JNDI
Server S2
Qd
Qc
Qe
 Server S0
Qa
Qb
Clients
Clients
Clients
Figure 1.
Use case system architecture
The following requirements are considered for the purpose
of the case study:
• Conﬁguration structure: It should respect the platform’s
architecture and the relationships between the conﬁgu-
ration parameters. (Req1)
• Naming service: Connection factories and destinations
should be accessible via a naming service i.e., the plat-
form should provide an accessible JNDI service where
the administered objects should be stored. (Req2)
• Memory optimization: The queue memory should not
run low in memory, i.e., the queue should not be loaded
at more than 80% of its maximum capacity. (Req3)
134
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

IV. CONFIGURATION VALIDATION APPROACH
The goal of our work is to provide means to enable
an automatic conﬁguration validation in self-conﬁgurable
systems. Concretely, we want to build a validation system
capable of automatically asserting the correctness and safety
of conﬁguration data at runtime, that is checking that con-
ﬁguration values remain within authorized bounds and do
not compromise intended service behavior. To meet this
objective, we follow a model-based approach in which we
deﬁne a lightweight, yet consistent metamodel that provides
constructs for a vendor neutral conﬁguration data description
and a constraint-based validity enforcement.
Runtime Configuration Validation
Managed Elements
        Management System
Monitor
Plan
Execute
Analyze
Knowledge
Base
Runtime Validation
<<uses>>
Constraints
Constraints
Constraints
Constraints
Reference Model
MeCSV Metamodel
<<conformsTo>>
Conﬁguration
Structure
State
Parameters
 Validation 
Requests
Validation
Notifications
Modeling artifacts
Operational state 
acquisition
Figure 2.
Proposed model-based conﬁguration validation approach
The aim of this metamodel is ﬁrst, to allow operators
to specify their system’s conﬁgurations thanks to appropri-
ate constructs and rules; second, to enable the automatic
validation of runtime proposed conﬁgurations against this
model independently of both management platforms and
conﬁguration protocols.
As depicted in the upper part of Figure 2, the metamodel
we propose is used to specify a Reference Model that
every possible conﬁguration of the target system should con-
form to. This reference model includes the conﬁguration’s
structure (conﬁguration parameters) as well as the different
constraints every valid conﬁguration should respect. The
novel aspect of these constraints is to cover both structural
integrity and operational applicability validation:
• Structural integrity validation checks the correct struc-
ture and composition of conﬁguration parameters
in terms of authorized values and consistent cross-
components dependencies. For example, checking that
a host-address conﬁguration parameter exists and is
well formed according to the IPv4 or IPv6 format.
• Operational applicability validation checks if the con-
ﬁguration fulﬁlls the runtime operational conditions.
For instance, assessing that Req3 still holds after a
conﬁguration modiﬁcation. This type of validation re-
quires the knowledge of the current runtime context.
The reference model thus includes the concept of state
parameters for the acquisition of necessary monitored
data.
Note that the reference model is to be deﬁned by the hu-
man operator according to system and management require-
ments. Then, it will be used at each dynamic reconﬁguration
decision to verify produced conﬁguration instances.
The reference model can also be modiﬁed, for example
with the addition, removal or modiﬁcation of constraints or
conﬁguration elements at any time during the management
system’s life cycle if needed.
The process for validating proposed conﬁgurations at
runtime will work as follows: the reconﬁguration decision
function of the management system (the Plan block in the
lower part of Figure 2) will interact with the runtime con-
ﬁguration validation. Every produced conﬁguration instance
will be dynamically checked against the reference model
and be consequently validated structurally and operationally
before deployment.
V. MECSV OVERVIEW
This section presents the salient features of the metamodel
depicted in Figure. 3. MeCSV has been formally speciﬁed
as a UML proﬁle [15] to ease the usage of the MeCSV
language and beneﬁt from the abundance of UML modelers.
A. Conﬁguration Data Description
Conﬁguration data are generally described in some conﬁ-
guration ﬁles where their structure is speciﬁed through the
setting of some conﬁguration properties with appropriate
values and options. Additionnally, bindings between sys-
tem’s elements need to be reﬂected in their conﬁgurations,
for example, the coordination of the server’s hostname
value with the machine’s hostname value. This part of the
metamodel represents subsequents concepts to do so.
1) Conﬁguration Parameter: represents quantiﬁable con-
ﬁguration parameters of managed elements; their expression
deﬁnes the conﬁguration data structure. For example, a
message server’s identiﬁer or hostname information.
2) Conﬁguration: acts as a container for conﬁguration
parameters allowing to coordinate them and to group them in
categories. For example, a conﬁguration ﬁle can be modeled
as a single Conﬁguration, or for more ﬂexibility, divided into
multiple Conﬁgurations.
3) Conﬁguration Dependency: represents bindings be-
tween two conﬁguration elements meaning a conﬁguration
parameter of one conﬁguration references a whole or a part
of the other conﬁguration. Typically, a server’s hostname
references its host machine’s name information.
135
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

Figure 3.
Core of the UML proﬁle for the MeCSV metamodel
4) Conﬁguration Composition: allows to divide a main
conﬁguration into partial conﬁgurations. For example, a
message server’s conﬁguration is split into message services,
connection factories and destinations sub-conﬁgurations. It
means that the complete server’s conﬁguration is the collec-
tion of its local conﬁguration parameters and its associated
sub-conﬁgurations.
5) Conﬁguration Metadata: allows to specify metadata
for conﬁguration lifecycle management. For instance, one
could want to tag speciﬁc conﬁgurations as default or initial.
Another example is the visited metadata used in the
JORAM platform to mark deployed conﬁgurations.
B. Connection to the Monitoring Framework
As our work targets a global management environment
where the managed system is both observable and recon-
ﬁgurable, we provide constructs to represent information
about managed elements as well as their monitored state.
A knowledge of the monitored state is required to guide
reconﬁgurations and to assert the operational compliance of
proposed conﬁgurations.
1) Managed element: represents the notion of managed
element commonly deﬁned in several management informa-
tion models. A common pattern is to separate managed ele-
ments representation from conﬁguration modeling, managed
elements containing monitoring-oriented information.
2) State Parameter: models the traditional operational
state attributes like operational status, statistical data, in
sum, any monitored information. Enabling the access to their
values is required to process online constraints. The number
of pending messages or current active TCP connections are
examples of state parameters.
In our approach, Managed Element and State Parameter
are the necessary management building blocks for conﬁ-
gurations and runtime constraints deﬁnition. Their values
are supposed to be provided by an existing monitoring
framework. They are considered as read-only elements.
C. Conﬁguration Validity Enforcement
Deﬁning a conﬁguration data structure does not sufﬁce to
guarantee the validity of formulated conﬁguration instances;
the following elements allow to deﬁne the constraints that
conﬁguration instances should respect.
1) Constraint: represents the restrictions that must be
satisﬁed by a correct speciﬁcation of conﬁgurations accord-
ing to the system’s architecture and management strategies.
Req1, Req2 and Req3 are examples of high-level level
constraints limiting the range of allowable conﬁguration
parameters values. They will be translated into low-level
constraints that can be enforced at runtime.
The Constraint element is subtyped into ofﬂine and online
constraints to support the speciﬁcities of the two types of
conﬁguration validation.
2) Ofﬂine
Constraint:
represents
structural
integrity,
that is rules for architectural compliance. They can be
checked either beforehand at design time or during runtime
and do not involve any check against monitored data.
The following OCL expressions are examples of ofﬂine
constraints derived from Req1: self.jndiName<>null,
serverId−>include(parent.serverId)= true.
The
ﬁrst expression ensures that a queue has a registered name
and the second guarantees that a queue is associated with a
valid server.
3) Online Constraint: deﬁnes rules for the operational
applicability enforcement. Online constraints use state
parameters values to assess the operational compliance of
conﬁguration data. They are necessarily checked at runtime.
self.nbMaxMsg>80% ∗ self.arrivalsCounter,
136
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

JNDIServer−>include(operationalStatus= ON)
are examples of online constraints expressed in OCL.
The former is a translation of Req3, the latter is derived
from Req2 and ensures that the conﬁguration of the system
includes a running JNDI service. They can only be evaluated
against the current value of a queue’s message load and the
operational status of the naming service respectively.
Constraints also have a “constraint level” attribute to
modulate their strictness together with an “active” attribute
to activate or deactivate them depending on the operational
context and management strategies (e.g., critical vs non-
critical).
D. Usage Example
Figure 4 illustrates an application of the MeCSV UML
proﬁle to the modeling of a message queue according to
speciﬁed Req1, Req2 and Req3 in Section III.
Figure 4.
Excerpt of the reference model for a message queue
This reference model contains the conﬁguration structure
of a message queue, the ofﬂine and online constraints that
should be respected and depending state parameters.
VI. EXPERIMENT
This section presents a prototype implementation of the
approach applied to the MOM system conﬁguration in Sec-
tion III. The underlying objective is to evaluate the ability of
MeCSV to serve as a formal speciﬁcation notation, namely
whether a MeCSV reference model can sufﬁce to enable a
runtime conﬁguration validation.
Conﬁguration 
Generator
Monitoring 
Module
Constraint 
Checker
Conﬁguration 
Datastore
Reference Model
Constraint 
Base
?
? ?
?
configuration validation
data acquisition
reference model artefacts
Managed System
Figure 5.
Architecture of a prototype implementation
A. Methodology
The prototype is constituted of three components that
interact automatically as shown in Figure 5:
1) Architecture:
• A conﬁguration generator: it outputs conﬁguration in-
stances according to deﬁned reconﬁguration scenarios.
• A monitoring module: it updates operational state met-
rics according to given monitoring scenarios.
• A constraint checker: it checks related conﬁguration
elements against the reference model. This constraint
checker is speciﬁcally designed to interpret MeCSV
constructs. It can thus process any given conﬁguration
data deﬁned with the MeCSV language.
2) Implementation Details: The prototype was developed
in Java:
• Each MOM system’s element (i.e., servers, destina-
tions,...) has two corresponding Java class represen-
tations for its monitoring and its conﬁguration view.
For instance, a message server is implemented through
a Server class containing its state attributes and a
ServerConﬁg class for its conﬁguration attributes.
• The code of the conﬁguration view is generated from
the deﬁned reference model thanks to MeCSV UML
proﬁle.
• Constraints are implemented as test functions. Their
evaluations consist in appropriate method calls on re-
lated constrained elements.
3) Scenarios:
Reconﬁgurations scenarios: they covered typical per-
formance tuning activities: the addition and removal of
servers, the platform is scaled up and down (from a cen-
tralized conﬁguration of a single server to a distributed
one made of three servers: Figure 1) and the modiﬁcation
of queues’s conﬁguration parameters to adjust the memory
usage, especially the variation of its maximum capacity.
Common structural ﬂaws (missing mandatory values,
omitted dependencies) are introduced programmatically into
generated conﬁgurations to test the constraint-checking.
Monitoring scenarios: they covered operational sta-
tuses variations as generally observed in case of service fail-
ure or communication lost as well as performance decrease
through message load variations than can possibly impact
the platform’s memory usage.
4) Execution: The runtime conﬁguration generator perio-
dically produces a new conﬁguration instance and sends it
to the constraint checker for validation while the monitoring
module arbitrarily updates operational state values according
to monitoring scenarios. The constraint checker evaluates
input conﬁgurations by calling appropriate test functions.
The constraint checker returns an OK message (no found
errors) or a list of violation errors.
137
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

B. Discussion
Thanks to the metamodel, we described a MeCSV re-
ference model of the use case system that comprised the
system conﬁguration schema, state data of interest and
ofﬂine and online constraints that should be respected.
A provided conﬁguration generator produced conﬁguration
instances that were evaluated by a prototype constraint-
checker. Since those conﬁguration data are expressed using
the MeCSV language, the constraint-checker seamlessly
processed them and tested them against the available set
of constraints. Violations were detected and reported during
the execution of the different scenarios.
This preliminary experiment shows that the approach we
propose is feasible. As long as there is a deﬁned MeCSV
reference model of the managed system, and that its runtime
candidate conﬁgurations as well as its monitored data can be
exported using the MeCSV format, our constraint-checker
can be plugged in the related management system and
perform an automatic and platform-neutral conﬁguration
validation.
Yet several points remain to clarify before practical usage:
• The design of the constraint checker: we are currently
studying runtime OCL formats and compilers [16], [17]
and their performance on scalable architectures.
• The interpretation of violation errors: one issue is the
expressiveness of violation errors in order to guide the
re-formulation of a new candidate conﬁguration. This
aspect can be included in the deﬁnition of a protocol
between the reconﬁguration decision and the validator.
VII. CONCLUSION AND FUTURE WORK
Dynamic reconﬁguration is an important issue if we are
to build large, complex and heterogenous systems with an
acceptable level of reliability. However, dynamic reconﬁgu-
ration decisions should be validated before their application
in order to guarantee the system’s accurate operation.
This paper presented a model-based approach that aims
to enforce the validity of runtime conﬁguration changes. We
have shown that conﬁguration validation at runtime goes
beyond structural correction checks to further verify the
operational consistency of conﬁguration modiﬁcations.
We proposed a metamodel (MeCSV) that provides plat-
form and vendor neutral constructs for the speciﬁcation of a
system’s reference model that is the system’s conﬁguration
schema including structural and runtime constraints that
should be respected. A dedicated constraint-checker can
then consume the deﬁned reference model and automatically
validate output conﬁgurations against it.
MeCSV has been implemented as a UML proﬁle and a
preliminary experiment validates the feasibility of its usage
to enable online conﬁguration validation.
Future work intend to carry on our experiments on com-
mon systems to consolidate the genericity of our approach.
Moreover, we are working on a complete framework to
support the metamodel with an adequate runtime constraint
checker.
REFERENCES
[1] J. O. Kephart and D. M. Chess, “The Vision of Autonomic
Computing,” Computer, vol. 36, no. 1, pp. 41–50, 2003.
[2] I. Warren, J. Sun, S. Krishnamohan, and T. Weerasinghe,
“An Automated Formal Approach to Managing Dynamic
Reconﬁguration,” in ASE’06: Inter. Conference on Automated
Software Engineering, 2006, pp. 37–46.
[3] L. Akue, E. Lavinal, and M. Sibilla, “Towards a Validation
Framework for Dynamic Reconﬁguration (short paper),” in
IEEE/IFIP International Conference on Network and Service
Management (CNSM), 2010, pp. 314–317.
[4] D. Oppenheimer, A. Ganapathi, and D. A. Patterson, “Why
do internet services fail, and what can be done about it?” in
Proceedings of the 4th conference on USENIX Symposium on
Internet Technologies and Systems, ser. USITS’03, 2003, pp.
1–1.
[5] P. Anderson and E. Smith, “Conﬁguration tools: working
together,” in Proceedings of the 19th conference on Large
Installation System Administration Conference, 2005.
[6] A. V. Konstantinou, D. Florissi, and Y. Yemini, “Towards
Self-Conﬁguring Networks,” in DANCE’02: DARPA Active
Networks Conference and Exposition, 2002.
[7] T. Delaet and W. Joosen, “PoDIM: A Language for High-
Level Conﬁguration Management,” in LISA, 2007, pp. 261–
273.
[8] P. Goldsack, J. Guijarro, S. Loughran, A. Coles, A. Farrell,
A. Lain, P. Murray, and P. Toft, “The SmartFrog Conﬁguration
Management Framework,” SIGOPS Oper. Syst. Rev., vol. 43,
pp. 16–25, 2009.
[9] “CIM Schema version 2.29.1 - CIM Core,” june 2011.
[10] M. Bjorklund, “YANG - A Data Modeling Language for
the Network Conﬁguration Protocol (NETCONF),” Internet
Engineering Task Force (IETF), RFC 6020, october 2010.
[11] R. Enns, “NETCONF Conﬁguration Protocol,” Internet Engi-
neering Task Force (IETF), RFC 6241, december 2006.
[12] T. Hinrichs, N. Love, C. J. Petrie, L. Ramshaw, A. Sahai, and
S. Singhal, “Using Object-Oriented Constraint Satisfaction for
Automated Conﬁguration Generation,” in DSOM, 2004, pp.
159–170.
[13] L. Ramshaw, A. Sahai, J. Saxe, and S. Singhal, “Cauldron: a
policy-based design tool,” in Policies for Distributed Systems
and Networks, 2006. Policy 2006. Seventh IEEE International
Workshop on, 2006, pp. 113–122.
[14] “Java
(TM)
Open
Reliable
Asynchronous
Messag-
ing
website,”
september
2011.
[Online].
Available:
http://joram.ow2.org/
[15] “OMG Uniﬁed Modeling Language (OMG UML), Super-
structure V2.1.2,” november 2007.
[16] M. Gogolla, M. Kuhlmann, and F. B¨uttner, “A Benchmark
for OCL Engine Accuracy, Determinateness, and Efﬁciency,”
in Proceedings of the 11th international conference on Model
Driven Engineering Languages and Systems, 2008, pp. 446–
459.
[17] C. Avila, A. Sarcar, Y. Cheon, and C. Yeep, “Runtime
Constraint Checking Approaches for OCL, A Critical Com-
parison,” in SEKE, 2010, pp. 393–398.
138
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

