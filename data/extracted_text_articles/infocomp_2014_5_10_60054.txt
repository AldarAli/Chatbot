Trans-Organizational Role-Based Access Control in Android 
Secure Mechanism for Verifying User-Role Assignments of Organizations 
 
Jason Paul Cruz and Yuichi Kaji 
Nara Institute of Science and Technology, Graduate School of Information Science 
Nara, Japan 
E-mail: jpmcruz@ymail.com, kaji@is.naist.jp
 
 
Abstractâ€”The role-based access control (RBAC) is a natural 
and versatile model of the access control principle.  In the real 
world, it is common that an organization provides a service to 
a user who owns a certain role that was issued by a different 
organization. However, such a trans-organizational RBAC is 
not common in a computer network because it is difficult to 
establish 
both 
the 
security 
that 
prohibits 
malicious 
impersonation of roles and the flexibility that allows small 
organizations/individual users to fully control their own roles. 
To solve this problem, this study proposes a mechanism that 
makes use of the hierarchical ID-based encryption scheme and 
the challenge-response authentication protocol. The proposed 
mechanism contributes to achieve both the security and the 
flexibility and it provides additional features that are common 
in physical communication but are not obvious in the 
cyberworld. This study also reports a prototyping system that 
is implemented on Android-enabled mobile devices. The 
proposed 
system 
employs 
the 
needed 
cryptographic 
mechanisms, and 
new technologies, namely, near-field 
communication and two-dimensional codes, are employed to 
realize locally closed communication between devices. 
Keywords-role-based access control; trans-organizational 
role; 
information 
security; ID-based 
encryption; 
service 
coalition; Android. 
I. 
 INTRODUCTION 
The role-based access control (RBAC) [1] is a widely 
accepted framework that describes the access control relation 
among users and services. In RBAC, users are associated 
with roles, and roles are associated with services. This 
framework 
is 
compatible 
with 
the 
access 
control 
requirements of real-world organizations and is employed in 
the computer systems of many organizations/companies. 
However, it must be noted that RBAC is a versatile 
framework, and roles are often used in a trans-organizational 
manner. For example, students are often allowed to be 
admitted to a museum with discounted admission fee. In this 
example, the â€œstudentâ€ role that is issued by an organization 
(school) is used by another organization (museum) to 
determine if a guest is eligible to receive a certain service 
(discounted admission). This kind of trans-organizational use 
of roles is, unfortunately, not common in computer networks. 
Even if one has a certain role that is issued by an 
organization, there is no way to convince a third-party 
organization that he/she really has that role.  
To realize a trans-organizational RBAC mechanism in a 
computer network, two issues should be considered; the 
security and the flexibility. With regard to security, the 
mechanism should prevent malicious users from disguising 
their roles. This requirement is naturally accomplished in 
real-world services with the use of physical certificates, such 
as passports and ID-cards, which are difficult to forge or 
alter. This problem, however, is not obvious in a computer 
system. Digital certificates [2] can be utilized as an analogue 
of physical certificates, but the use of digital certificates is 
not favorable from the viewpoint of realization cost, which 
can discourage small companies and non-profit organizations 
from participating in the framework. Another less 
sophisticated approach to the security problem is to let a 
service-providing organization (the museum in the above 
example) inquire a role-issuing organization (school) about 
the user-role assignment. This approach works fine in some 
cases [3], but a focal point of this approach is the necessity 
for the agreed beneficial relationship among organizations. 
Consequently, it is difficult for a new organization to join the 
partnership, severely restricting the trans-organizational 
utilization of roles. 
The current study aims to develop a practical mechanism 
that realizes the trans-organizational utilization of roles. 
First, we extend the model of RBAC to represent the trans-
organizational usage of roles. This simple extension clarifies 
the components and requirements that are needed in the 
framework of trans-organizational RBAC. Then, we 
investigate a realization of a user-role assignment that is 
secure (users cannot disguise roles), user-oriented (users can 
disclose their roles to any organization), and open (anyone 
can verify if a user has a certain role that is managed and 
issued by another organization). The crucial point of this 
realization is to make use of hierarchical ID-based 
encryption (HIBE) [4][5], which allows an arbitrary string to 
be used as a public encryption key. Our key idea is to define 
correspondence between the roles and keys of HIBE and to 
employ a challenge-response authentication protocol that 
will be used for verifying if a user really has an asserted role.  
The hierarchical nature of HIBE makes our scheme suitable 
for the trans-organizational utilization of roles, and 
furthermore, allows flexible role management operations, 
such as the endorsement and delegation of roles. A prototype 
system of the proposed trans-organizational RBAC will also 
be introduced. For the usability of the trans-organizational 
RBAC, it is highly desirable for a user to be able to carry 
114
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-365-0
INFOCOMP 2014 : The Fourth International Conference on Advanced Communications and Computation

his/her roles all the time. To verify the practicality of the 
proposed scheme, we implemented the proposed system on 
Android-enabled mobile devices. The implementation 
contains the realization of cryptographic functions that are 
essential 
for 
handling 
cryptographic 
keys 
and 
the 
development of a scheme that allows two devices to perform 
the challenge-response authentication by utilizing local and 
closed communication. The prototype demonstrates that the 
proposed scheme is simple, lightweight, and completely 
practical for realizing the trans-organizational RBAC. The 
rest of this paper is organized as follows. Section II 
introduces the RBAC and the different models associated 
with it. Section III discusses the technical aspects of HIBE. 
Section IV presents the structure, procedures, and features of 
the proposed framework. Section V discusses the realization 
and implementation of the proposed system in Android-
enabled devices. Section VI provides the conclusion and 
future work.   
II. 
MODELS FOR THE ROLE-BASED  ACCESS CONTROL 
In the simplest model of the RBAC [1], the access 
structure is defined by three sets and two relations. In this 
paper, we use ğ‘ˆ for the set of users, ğ‘… for the set of roles, 
and ğ‘† for the set of services. A user-role assignment, UA, is a 
subset of ğ‘ˆ Ã— ğ‘…, and a role-service assignment, SA, is a 
subset of ğ‘… Ã— ğ‘†. A user ğ‘¢ is eligible to access a service ğ‘  if 
and only if there is a role ğ‘Ÿ  such that (ğ‘¢, ğ‘Ÿ) âˆˆ UA  and 
(ğ‘Ÿ, ğ‘ ) âˆˆ SA. The access control should be made in such a 
way that services are provided to eligible users only. In 
general, the user-role assignment UA is defined by an entity 
that issues roles in ğ‘…, and the role-service assignment SA is 
defined by an entity that provides the services in ğ‘†. In this 
paper, the former is called a role-issuing entity, and the latter 
is called a service-providing entity. If RBAC is utilized in a 
single organization, then we can regard that the role-issuing 
entity and the service-providing entity are the same identical 
organization, and that the service-providing entity should 
have no difficulty referring to the user-role assignment. In 
this case, the eligibility of a user ğ‘¢ to a service ğ‘  can be 
easily determined. 
On the other hand, in the real world, there are many cases 
wherein a service-providing entity is a different organization 
from a role-issuing entity. As stated in the previous section, a 
school issues the â€œstudentâ€ role to its students, and an 
external organization, such as a museum, provides services 
to users who hold the â€œstudentâ€ role. In this case, the service-
providing 
organization 
(museum) 
is 
a 
completely 
independent organization from the role-issuing organization 
(school), and the service-providing organization is not 
expected to refer to the user-role assignment that was defined 
by the role-issuing organization. To discuss such a situation, 
we first consider an extended model of RBAC. 
The trans-organizational RBAC is defined similarly to 
the usual RBAC, but a set ğ‘‚ of organizations is defined in 
addition to the sets of users, roles, and services. Furthermore, 
the set ğ‘… of roles is partitioned into several subsets, with 
each subset of ğ‘… associated with an element in ğ‘‚, that is, 
ğ‘… = ğ‘…ğ‘œ1 âˆª â‹¯ âˆª ğ‘…ğ‘œğ‘›, where ğ‘œ1, â€¦ , ğ‘œğ‘› âˆˆ ğ‘‚ and ğ‘œğ‘– âˆ© ğ‘œğ‘— = âˆ… if 
ğ‘– â‰  ğ‘—. To make the relation among roles and organizations 
explicit, a role ğ‘Ÿ in ğ‘…ğ‘œğ‘– is written as ğ‘œğ‘–. ğ‘Ÿ. Similarly, the user-
role assignment UA is partitioned into disjoint subsets; UA =
UAo1 âˆª â‹¯ âˆª UAğ‘œğ‘› , where UAğ‘œğ‘– âŠ‚ ğ‘ˆ Ã— ğ‘…ğ‘œğ‘– . Obviously, 
ğ‘œğ‘–. ğ‘Ÿ âˆˆ ğ‘…ğ‘œğ‘–  means that the role ğ‘œğ‘–. ğ‘Ÿ  is managed by the 
organization ğ‘œğ‘–, and the assignment of users to ğ‘œğ‘–. ğ‘Ÿ is fully 
controlled by that organization ğ‘œğ‘–. In the trans-organizational 
RBAC, upon a request from a user ğ‘¢ to a service ğ‘ , the 
service-providing organization needs to check if there is an 
organization ğ‘œğ‘– âˆˆ ğ‘‚  and a role ğ‘œğ‘–. ğ‘Ÿ âˆˆ ğ‘…ğ‘œğ‘–  such that 
(ğ‘¢, ğ‘œğ‘–. ğ‘Ÿ) âˆˆ UAğ‘œğ‘– and (ğ‘œğ‘–. ğ‘Ÿ, ğ‘ ) âˆˆ SA. Assuming that the user 
ğ‘¢  declares the role ğ‘œğ‘–. ğ‘Ÿ  to utilize, then all the service-
providing organization needs to do is check if (ğ‘¢, ğ‘œğ‘–. ğ‘Ÿ) âˆˆ
UAğ‘œğ‘– or not. However, it should be noted that the role-issuing 
organization ğ‘œğ‘–  can be a different organization from the 
service-providing organization in general. The confirmation 
of (ğ‘¢, ğ‘œğ‘–. ğ‘Ÿ) âˆˆ UAğ‘œğ‘– , which is sometimes called an 
authentication, is not as obvious for the service-providing 
organization as in the single-organization case. If the 
confirmation cannot be established, then a malicious user 
may try to access a service by asserting a role that the user 
does not actually have. 
It is essential in the trans-organizational RBAC to realize 
a secure authentication mechanism, and this problem can be 
solved using two approaches. The first approach is to utilize 
digital certificates that are protected by the digital signatures 
of the role-issuing entities. This kind of certificate is 
sometimes called an attribute certificate [2] and is regarded 
as a digitalized version of physical certificates, such as ID-
cards. The problem in this approach is the maintenance cost 
of the public-key infrastructure (PKI) [6][7]. Different from 
written signatures, continuous efforts are essential to keep 
digital signatures secure and functional. PKI is widely 
recognized as expensive, and this cost issue prevents small 
organizations from participating in a PKI-based framework. 
The second, rather political, approach to the authentication 
problem is to arrange a mutual agreement between role-
issuing organizations and service-providing organizations. If 
several organizations share an identical benefit, then they can 
set up a partnership and mutually disclose their user-role 
assignments. A good example of this approach can be found 
in the Shibboleth project [3], but we need to remark that this 
framework is essentially a semi-closed one. An organization 
will not be allowed to join the partnership if that organization 
cannot offer recognizable benefits to the organizations 
involved, consequently limiting the trans-organizational 
utilization of roles. 
III. 
HIERARCHICAL ID-BASED ENCRYPTION 
A public-key encryption is a cryptography that utilizes 
two different keys for encryption and decryption. In a typical 
public-key encryption, such as RSA [8], a user sets up 
his/her key pair by himself/herself. One of the keys in the 
key pair is called an encryption key and is disclosed to the 
public. The other key is called a decryption key and is kept 
secretly by the user. In many cases, the keys are constructed 
from randomly selected information, which means that the 
115
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-365-0
INFOCOMP 2014 : The Fourth International Conference on Advanced Communications and Computation

keys look like random data. A separate mechanism, such as 
PKI, is needed to associate public encryption keys with 
users. However, PKI makes the system complicated and 
costly [6][7]. 
An ID-based encryption [4] is a special public-key 
encryption. Different from the usual public-key encryption, a 
user first chooses his/her encryption key. An interesting point 
in the ID-based encryption is that, under an appropriate 
setting, oneâ€™s identity, such as an e-mail address, can be used 
as an encryption key. After choosing the encryption key, the 
user submits the encryption key to a trusted authority which 
we call a key generator. The key generator examines the 
eligibility of the user and then, upon confirmation of the 
userâ€™s eligibility, computes the decryption key that 
corresponds to the submitted encryption key. Different from 
the usual public-key encryption, the correspondence between 
users and encryption keys becomes obvious if the identities 
of users are chosen as the encryption keys. Consequently, the 
costly mechanism of PKI is not needed in the framework of 
ID-based encryptions [4]. 
The HIBE [5] is an extension of the ID-based encryption 
wherein identities and functions of the key generator are 
realized in a hierarchical manner. In this paper, we write a 
hierarchical identity (abbreviated simply as ID) by a 
sequence of strings ğ‘† = ğ‘ 1. ğ‘ 2. â€¦ . ğ‘ ğ‘› , where ğ‘›  is a non-
negative integer called a level of ğ‘†, and ğ‘ ğ‘– with 1 â‰¤ ğ‘– â‰¤ ğ‘› is 
a string. If an ID ğ‘† = ğ‘ 1. ğ‘ 2. â€¦ . ğ‘ ğ‘›  is a prefix of ğ‘†â€² =
ğ‘ â€²1. ğ‘ â€²â€². â€¦ . ğ‘ â€²ğ‘›â€² , then we say that ğ‘† is a super-ID of ğ‘†â€² and ğ‘†â€² 
is a sub-ID of ğ‘†. In HIBE, an ID can be regarded as an 
encryption key by itself, although, it is sometimes convenient 
to distinguish IDs from encryption keys explicitly. In the 
following discussion, we write ekğ‘†  and dkğ‘†  for the 
encryption and decryption keys that correspond to the 
identity ğ‘†, respectively. In the original ID-based encryption, 
all decryption keys are solely generated by a trusted key 
generator. In HIBE, however, the generation of decryption 
keys is made in a hierarchical manner; the key pair 
(ekğ‘†, dkğ‘†)  for a level-one ID ğ‘† = ğ‘ 1  is generated by a 
designated key generator which we call a root key generator 
and is issued to an appropriate user who is eligible to hold 
the key pair. A user who has a key pair (ekğ‘†, dkğ‘†) for an ID 
ğ‘† can generate a key pair (ekğ‘†â€², dkğ‘†â€²) for an ID ğ‘†â€² that is a 
sub-ID of ğ‘† . The functions used in HIBE are described 
below. There is complicated mathematics behind these 
functions, but we omit them because they are not the subject 
of this study. The main body of HIBE consists of the 
following four procedures: 
Initialize() is a procedure that is executed by the root key 
generator in the initialization of the HIBE system. This 
procedure determines the public and secret parameters used 
in the system. The secret parameter is kept secretly by the 
root key generator, and the public parameter is disclosed to 
the public. The value of the public parameter is used in the 
following three procedures, although we do not write them 
explicitly in the notation for simplicity.  
KeyGenerate( ğ‘º , ( ğğ¤ğ‘ºâ€² , ğğ¤ğ‘ºâ€² )) is a procedure that 
computes the decryption key for the given ID ğ‘† . More 
precisely, the procedure generates dkğ‘† if ğ‘† is a sub-ID of ğ‘†â€™ 
and dkğ‘†â€²  is a correct decryption key of ğ‘†â€² . If not, the 
procedure fails to compute dkğ‘†. We remark that dkğ‘† cannot 
be computed if one does not know a correct decryption key 
of a super-ID of ğ‘†. 
Encrypt( ğ’Œ, ğ’ ) encrypts data ğ‘š  by using ğ‘˜  as an 
encryption key.  
Decrypt(ğ’Œ, ğ’„) decrypts data ğ‘ by using ğ‘˜ as a decryption 
key. 
If (ekğ‘†, dkğ‘†) is a key pair that is correctly generated by 
KeyGenerate and ğ‘ = Encrypt(ekğ‘†, ğ‘š) is an encryption of 
ğ‘š  constructed by using the encryption key ekğ‘† , then 
Decrypt(dkğ‘†, ğ‘) returns ğ‘š. 
HIBE is useful when used in a challenge-response 
authentication protocol. Consider a scenario that involves 
two people, a prover and a verifier. The prover asserts 
himself/herself as a genuine user with an identity ğ‘†, but the 
verifier is not sure if this assertion is true or not. In this case, 
the verifier can determine if the prover is genuine or not by 
executing the following steps. First, the verifier chooses a 
random message ğ‘š , and then encrypts ğ‘š  by using the 
encryption key ekğ‘†  for the asserted ID ğ‘† . The obtained 
ciphertext ğ‘ = Encrypt(ekğ‘†, ğ‘š) , which is called a 
challenge, is passed to the prover. The prover is requested to 
decrypt ğ‘ by using the decryption key dkğ‘†  that a genuine 
user should possess. If the prover returns ğ‘š as the result of 
the decryption, then he/she succeeds to make a correct 
response and is authorized as a user with the identity ğ‘†. If the 
response is wrong, then the prover is rejected. Through this 
challenge-response protocol, the verifier is able to determine 
if the prover has the ID ğ‘†. At this point, it should be noted 
that the ID ğ‘† is indeed a hierarchical identity; the fact that the 
prover posseses the decryption key dkğ‘†  means that 
somebody who had a certain super-ID of ğ‘† authorizes the 
prover to have the identity ğ‘† . In other words, with the 
challenge-response protocol, the prover confirms a â€œchain of 
trustâ€ that originates from the root key generator. This 
scenario is favorable in an open system with many 
unspecified users. 
IV. 
PROPOSED SCHEME 
A. Overview 
We now consider an authentication mechanism that is 
suitable for the trans-organizational utilization of roles. Our 
idea is to represent roles by hierarchical identities that work 
as encryption keys of HIBE. For example, if we would like 
to define a â€œstudentâ€ role of A-university, then a hierarchical 
identity, such as â€œA-univ.studentâ€, is introduced and used as 
an encryption key of HIBE. Decryption keys are managed so 
that users with a role ğ‘Ÿ possess the correct decryption key 
dkğ‘Ÿ of ğ‘Ÿ. A service-providing organization can verify if a 
user has the role ğ‘Ÿ  by examining the user by using the 
challenge-response protocol with ğ‘Ÿ  used as an encryption 
key of HIBE. Note that the service-providing organization 
does not have to know anything about ğ‘Ÿ beforehand and does 
not have to make any contract or inquiry to the role-issuing 
organization that has assigned ğ‘Ÿ to the user because ğ‘Ÿ itself is 
used as an encryption key. This feature makes it easy to 
verify the user-role assignment of users even if the role is 
issued by another organization. In the proposed framework, 
116
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-365-0
INFOCOMP 2014 : The Fourth International Conference on Advanced Communications and Computation

there is no essential difference between users and role-
issuing organizations because they both receive valid key 
pairs from superordinate entities and they both have the 
ability to generate new roles and corresponding key pairs by 
utilizing their keys in possession. However, for an easy 
understanding of the proposed framework and for simplicity, 
we will distinguish users from role-issuing organizations and 
introduce three component procedures that are needed for 
defining a user-role assignment. In the following, we extend 
the hierarchical notions of IDs to roles. If ğ‘Ÿ1 is a super-ID of 
another ID ğ‘Ÿ2, then the role represented by ğ‘Ÿ1 is a super-role 
of the role represented by ğ‘Ÿ2. The term sub-role is defined in 
the same way. 
B. Procedures 
Fig. 1 shows the overall structure of the proposed model. 
In this model, we assume the existence of a designated root 
key generator that is trusted by all users and organizations. 
The root key generator executes Initialize() of HIBE and 
determines the public and secret parameters. The public 
parameter is disclosed to the public and should be accessible 
to all users and organizations. The root key generator secures 
the secret parameter and uses it to generate key pairs for 
level-one roles. 
1) Setting up an organization  
An organization ğ‘œ1 chooses its identity string, say ğ‘†ğ‘œ1, 
and requests the root key generator to approve that the 
organization uses ğ‘†ğ‘œ1 as its identity. If the root key generator 
approves the request, it computes the decryption key dkğ‘†ğ‘œ1 
and sends this key to ğ‘œ1 by using a secure communication 
channel. As a result, ğ‘œ1  possesses a correct key pair 
(ekğ‘†ğ‘œ1, dkğ‘†ğ‘œ1) of its identity ğ‘†ğ‘œ1 . The organization ğ‘œ1  then 
defines the set ğ‘…ğ‘œ1 of roles it should manage. All roles in ğ‘…ğ‘œ1 
must be sub-roles of ğ‘†ğ‘œ1, where the identity ğ‘†ğ‘œ1is regarded as 
a â€œroleâ€. Note that ğ‘œ1 can compute the decryption key of any 
role 
ğ‘œ1. ğ‘Ÿ âˆˆ ğ‘…ğ‘œ1
 by 
utilizing 
the 
function 
of  
KeyGenerate(ğ‘œ1. ğ‘Ÿ, (ekğ‘†ğ‘œ1, dkğ‘†ğ‘œ1)) , because ğ‘œ1  knows the 
correct key pair (ekğ‘†ğ‘œ1, dkğ‘†ğ‘œ1) and ğ‘œ1. ğ‘Ÿ is a sub-ID of ğ‘†ğ‘œ1.  
On the other hand, organizations other than ğ‘œ1 cannot 
compute the decryption key of the role ğ‘œ1. ğ‘Ÿ  because the 
trusty key generator does not disclose dkğ‘†ğ‘œ1  to other 
organizations. Identities of roles in ğ‘…ğ‘œ1 can be open to the 
public, but the corresponding decryption keys must be kept 
secret by organization ğ‘œ1. 
2) Defining a user-role assignment 
To assign a role ğ‘œ1. ğ‘Ÿ to a user ğ‘¢, the organization ğ‘œ1 
gives the key dko1.ğ‘Ÿ  to user u by using a secure 
communication channel. User ğ‘¢  records dko1.ğ‘Ÿ  as the 
decryption key of the role ğ‘œ1. ğ‘Ÿ, and keeps the key secure. 
3) Verifying a user-role assignment 
Assume that a user ğ‘¢  visits a service-providing 
organization ğ‘œ2 and asserts that he/she has the role ğ‘œ1. ğ‘Ÿ that 
was assigned by the role-issuing organization ğ‘œ1 . The 
organization ğ‘œ2 needs to verify if the assertion of user ğ‘¢ is 
true or not. The verification can be done by using the 
challenge-response protocol; the organization ğ‘œ2 chooses a 
random data ğ‘š  and requests user ğ‘¢  to decrypt ğ‘ =
Encrypt(eko1.ğ‘Ÿ, ğ‘š). Note that we are using HIBE, and the 
encryption key eko1.ğ‘Ÿ is the same as (or easily derived from) 
the hierarchical identity ğ‘œ1. ğ‘Ÿ of the asserted role. If the user 
really has the role ğ‘œ1. ğ‘Ÿ , then he/she must possess the 
decryption key dko1.ğ‘Ÿ that is provided by the organization ğ‘œ1 
and should be able to decrypt the challenge ğ‘. Remark that 
the service-providing organization ğ‘œ2 can verify if the user ğ‘¢ 
holds the role ğ‘œ1. ğ‘Ÿ  without querying the role-issuing 
organization ğ‘œ1 and that user ğ‘¢ has little chance to disguise 
his/her role. 
C. Managing Roles 
1) Personalization of roles 
In the proposed framework, the relation between users 
and roles is represented by the possession of cryptographic 
keys by users. This approach involves a possible security 
risk; a leakage of keys. If, for example, a role ğ‘Ÿ is assigned to 
several users, then all those users have the same key dkğ‘Ÿ. If 
one of those users is unconscious of security, then he/she 
may let other persons use the key dkğ‘Ÿ. Such an inappropriate 
usage of keys can obstruct fair and reliable access control. 
To deter such irresponsible behavior of users, a role-issuing 
organization can â€œpersonalizeâ€ a role by appending an 
additional string to the identity of roles. Assume for example 
that there are several students in A-university. In this case, 
instead of using a general role, such as â€œA-univ.studentâ€, the 
university can define personalized roles, such as A-
univ.student.Alice and A-univ.student.Bob, and provide
    
 
Figure 1.  Overview of the proposed structure. 
117
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-365-0
INFOCOMP 2014 : The Fourth International Conference on Advanced Communications and Computation

decryption keys of these roles to Alice and Bob, respectively. 
With this kind of personalization, a student will be more 
conscious of leaking/losing his/her key to another person 
because he/she will have the risk of being identified and 
subsequently punished for irresponsible behavior. The 
theft/loss of keys remains a risk, but such risk also exists for 
ID-cards used in the real world. We cannot say that the 
proposed framework is â€œmore secure thanâ€ but we may say it 
is â€œas secure asâ€ the real-world role management. 
2) Hierarchical issuance of roles 
In the proposed scheme, there is no essential diï¬€erence 
between organizations and users. A user can compute 
decryption keys from the key that he/she already has and 
issue a new sub-role of the role that he/she already has. This 
function can be used to realize some personal activities that 
are not considered in the conventional RBAC approach. One 
possible example is the endorsement of another person. In 
the real world, an endorsement among individuals sometimes 
plays an important role. Semi-closed organizations, such as 
academic societies and golf clubs, have the tradition or 
policy that a newcomer must be endorsed or referred by a 
current member. This mechanism can be realized using the 
proposed scheme. Consider for example that Alice is an 
authorized member of XYZ golf club and is given a 
personalized 
role 
â€œXYZ-golf.member.aliceâ€ 
and 
its 
corresponding decryption key. If Alice would like to endorse 
Bob to the club, then she can generate a new sub-role â€œXYZ-
golf.member.alice.endorsedâ€ 
and 
its 
corresponding 
decryption key. By providing the decryption key to Bob, Bob 
can demonstrate that he is really endorsed by Alice. Using 
the HIBE and the challenge-response authentication, the club 
does not have to inquire Alice for the verification of the 
endorsement. Besides personal endorsement, we conjecture 
that a broad range of personal relations can be implemented 
by utilizing the hierarchical roles. 
V. 
REALIZATION 
The proposed scheme was implemented in Android-
enabled mobile devices. In the proposed scheme, the user-
role assignments are represented by possession of decryption 
keys by users. A role-issuing organization does not have to 
construct and maintain large databases for recording the 
user-role assignments, and it does not have to be bothered by 
inquiries of other organizations with regard to user-role 
assignments. The created Android application implements all 
the functions of the HIBE and the proposed scheme for ease 
of use and accessibility. 
The prototype contains several functions that correspond 
to components in Fig. 1. The functions of the root key 
generator mainly consist of two operations: GenParams and 
RKeyGenerateMaster. GenParams utilizes the Initialize() 
function of HIBE and generates the public and secret 
parameters, where the public parameter is disclosed to the 
public. An organization ğ‘œğ‘– that would like to participate in 
this system chooses its identity, say ğ‘†ğ‘œğ‘–, and asks the root key 
generator to compute the decryption key dkğ‘†ğ‘œğ‘–. The root key 
generator utilizes RKeyGenerateMaster to compute dkğ‘†ğ‘œğ‘– , 
which needs the information of the secret parameter and 
hence this function is accessible to the root key generator 
only. The generated key dkğ‘†ğ‘œğ‘–  is transferred to the 
organization ğ‘œğ‘– through general communication means, such 
as Wi-Fi, Bluetooth, Android Beam, and NFC. The role-
issuing organization ğ‘œğ‘– now has the key pair (ekğ‘†ğ‘œğ‘–, dkğ‘†ğ‘œğ‘–) 
for the ID ğ‘†ğ‘œğ‘–. By using the function of RKeyGenerate, this 
key pair, and the public parameter that has been disclosed, 
the organization ğ‘œğ‘– can compute valid key pairs of sub-IDs of 
ğ‘†ğ‘œğ‘–. A user receives, possibly many, keys from organizations, 
each of which corresponds to a role in an organization. The 
user safely stores these keys in his/her device and accesses 
them for the RKeyGenerate and RoleResponse functions. 
RoleResponse provides the function of the prover for the 
challenge-response authentication and interacts with the 
RoleChallenge function that is invoked by a service-
providing organization. 
The cryptographic operations used in these functions are 
performed using the Java Pairing-Based Cryptography 
(JPBC) library [9], which is a collection of classes and 
methods 
for 
handling 
underlying 
pairing-based 
cryptosystems. Over JPBC, we implemented the HIBE that 
was proposed by Gentry [5]. 
The most complicated but important communication in 
the 
proposed 
scheme 
is 
the 
challenge-response 
authentication between a user and a service-providing 
organization. Several messages must be exchanged between 
two devices, and we provide two different schemes to realize 
this communication, namely, the use of near-field 
communication (NFC) and quick-response (QR) codes. 
NFC is a contactless technology used to transmit small 
amounts of data across short distance. NFC has three modes 
of operation, and this study tackles only P2P mode. NFC 
messages in Android are handled using the NFC Exchange 
Format (NDEF). In the proposed Android application, the 
Intent 
Filters 
that 
listen 
to 
the 
intent 
action of 
NfcAdapter.ACTION_NDEF_DISCOVERED were added to 
the RoleChallenge and RoleResponse activities to be able to 
receive NFC data [10][11]. Only the MIME type of text/plain 
was included in the application as we are only concerned 
with passing and receiving data of type string. Given that at 
least two activities have the same intent filter that responds 
to an NFC tap, users are, by default, prompted to select 
which application in the mobile device to use, making the 
application tedious to use. To solve this problem, the 
foreground dispatch system was utilized. The foreground 
dispatch system is used to make a particular activity have 
priority over other activities. This allows a particular activity 
to become the default receiver when it is on the foreground. 
QR Code is a type of 2D barcode that is capable of 
handling different types of data [12]. This code can 
accommodate high capacity of data in a small area, which is 
sufficient to include the challenge-response data in one code 
symbol. The camera hardware of mobile phones can be used 
as 
scanners 
for 
QR 
codes 
generated 
for 
the 
challenge/response actions. For this implementation, the 
camera hardware of the device was programmed and the 
ZXing (â€œzebra crossingâ€) library, which is an open-source 
library that supports the decoding and generation of 
118
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-365-0
INFOCOMP 2014 : The Fourth International Conference on Advanced Communications and Computation

barcodes, was used to obtain the data [13]. This feature 
allows the interaction of two users without NFC-capable 
devices and without the Internet. 
Typically, the challenge-response authentication is 
carried out as follows: 
1. A user, the prover, opens the application and goes to the 
â€œRole Responseâ€ option. Then, the prover selects the 
base file that contains the public parameter and the role 
file that contains the role he/she wants to use. 
2. A service-providing organization, the verifier, opens the 
application and goes to the â€œRole Challengeâ€ option. To 
start the verification process, the verifier selects the 
same base file and either types the role indicated by the 
prover or obtains the role automatically via NFC (first 
tap). Once the role is received, a random challenge data 
is created.  
3. The verifier then sends this challenge data to the prover 
via NFC (second tap) or by generating a QR code for 
the prover to scan. 
4. After receiving the challenge data via NFC or scanning 
of the Challenge QR Code, a random response data is 
calculated and created in the proverâ€™s device based on 
the role file selected. 
5. The prover then sends this response data to the verifier, 
again, via NFC (third tap) or by generating a QR code 
for the verifier to scan. 
6. After receiving the response data via NFC or scanning 
of the Response QR Code, the Role Challenge indicates 
if the assumed role is verified or is a mismatch. 
Several screen shots of the prototype are shown in Fig. 2. 
Another possibility for the realization of the user-side system 
is through the use of smartcards that are compatible with the 
NFC technology [14]. 
VI. 
CONCLUSION AND FUTURE WORK 
A trans-organizational RBAC is considered and extended 
to represent the trans-organizational usage of roles. The 
proposed scheme provides a secure mechanism for verifying 
the user-role assignments of organizations. The proposed 
scheme was developed on Android-enabled mobile devices 
for ease of use and accessibility. Compared to other similar 
approaches, the proposed scheme provides more flexibility 
and autonomy while maintaining security. This mechanism 
allows 
the 
realization 
of 
many 
collaborative right 
managements that are common in physical communication 
but are difficult to implement over computer networks. Even 
with the given advantages, the proposed scheme remains 
subject to the classical issue of compromised secret keys; the 
proposed scheme is based on the assumption that keys are 
managed appropriately and protected well. If dkğ‘† is 
compromised for an unfortunate reason, the keys of the sub-
roles of S should be redeployed. This problem can be 
mitigated by utilizing the personalized and fixed-term roles, 
but it is encouraged in general to provide more protection for 
the keys of roles of higher-level. Taking such issue into 
consideration, future research will focus on the inclusion and 
integration of expiration dates on the roles. Moreover, the 
prototype will be expanded to non-Android devices, such as 
iPhones and Windows mobile devices, for interoperability.     
REFERENCES 
[1] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E. Youman, 
â€œRole-based access control models,â€ IEEE Computer,  29, 2, 
pp. 38â€“47, 1996. 
[2] S. Farrell and R. Housley, â€œAn internet attribute certificate 
profile or authorization,â€ RFC 3281, 2002. 
[3] The 
Shibboleth 
System, 
accesible 
online: 
http://shibboleth.internet2.edu/ [accessed: 2014-05-08]. 
[4] D. Boneh and M. Franklin, â€œIdentity-based encryption from 
the Weil pairing,â€ Proc. of the Advances in Cryptology 
(CRYPTO) 2001, pp. 213â€“229, 2001. 
[5] C. Gentry and A. Silverberg, â€œHierarchical ID-based 
cryptography,â€ Proc. of the Advances in Cryptology 
(ASIACRYPT) 2002, pp. 548â€“566, 2002. 
[6] C. M. Ellison et al., â€œSPKI certificate theory,â€ RFC 2693, 
1999. 
[7] P. Gutmann, â€œSimplifying public key management,â€ IEEE 
Computer, 37, 2, pp. 101â€“103, 2004. 
[8] R. Rivest, A. Shamir, and L. Adleman, â€œA method for 
obtaining digital signatures and public-key cryptosystems,â€ 
Communications of the ACM, 21, 2, pp. 120â€“126, 1978. 
[9] A. De Caro and V. Iovino, â€œjPBC: Java pairing based 
cryptography,â€ Proc. Of the IEEE Symposium on Computers 
and Communications (ISCC) 2011, pp. 850â€“855, 2011. 
[10] R. 
Meier, 
â€œProfessional 
Android 
4 
Application 
Development,â€ John Wiley & Sons, Inc., Indianapolis, pp. 
693â€“700, 2012. 
[11] S. Komatineni and D. MacLean, â€œPro Android 4,â€ Apress, pp. 
858â€“870, 2012. 
[12] http://www.qrcode.com/en/ [accessed: 2014-05-08]. 
[13] https://github.com/zxing/zxing [accessed: 2014-05-08]. 
[14] M. Scott, N. Costigan, and W. Abdulwahab, â€œImplementing 
cryptographic pairings on smartcards,â€ Proc. of the 
Cryptographic Hardware and Embedded Systems, pp. 134â€“
147, 2006. 
 
   
   
   
 
(a) 
                                                    (b)                                                  (c)                                                  (d) 
Figure 2.  (a) RkeyGenerate, (b) Role Response, (c) Role Challenge, and (d) QR Code functions of the application. 
119
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-365-0
INFOCOMP 2014 : The Fourth International Conference on Advanced Communications and Computation

