Property Based Veriﬁcation of Evolving Petri Nets
Yasir Imtiaz Khan and Ehab Al-shaer
Department of Software and Information Systems
University of North Carolina at Charlotte
Charlotte, USA
Email: ykhan2,alshaer@uncc.edu
Abstract—Software evolution is inevitable in the ﬁeld of informa-
tion and communication technology systems. Existing software
systems continue to evolve to progressively reach important
qualities such as completeness and correctness. Iterative re-
ﬁnements and incremental developments are considered to be
well suitable for the development of evolving systems among
other approaches. The problem with iterative reﬁnements and
incremental development is the lack of support of an adequate
veriﬁcation process. In general, all the proofs are redone after
every evolution, which is very expensive in terms of cost and
time. In this work, we propose a slicing based solution to
add an adequate veriﬁcation process to iterative reﬁnements
and incremental development technique. Our proposal has two
objectives, the ﬁrst is to perform veriﬁcation only on those parts
that may inﬂuence the property satisfaction by the analyzed
model. The second is to classify the evolutions and properties to
identify which evolutions require re-veriﬁcation. We argue that
for the class of evolutions that requires re-veriﬁcation, instead
of verifying the whole system only a part that is concerned by
the property would be sufﬁcient. We use Petri nets as a modeling
formalism and model checking as a veriﬁcation approach to show
the viability of the proposed approach.
Keywords–Software evolution; Re-veriﬁcation; Model checking;
Iterative reﬁnements; Slicing.
I.
INTRODUCTION
Software systems are playing an important role in our
daily life. Companies are spending millions of dollars and
are dependent on them. The software development process
does not stop when a system is delivered, but continues
throughout the lifetime of software. In general, existing soft-
ware systems continue to evolve due to various reasons such
as the emergence of new requirements, performance may
need to be improved, business environment is changing [1]
. According to the survey report conducted by Erlikh
[2],
90% of software costs are software evolution costs and about
75% of all software professionals are involved in some form
of evolution activity. These facts point out the importance of
software evolution and demand tools and techniques for its
better management.
Iterative reﬁnements and incremental developments is
a commonly used technique for handling complex systems
in hardware and software engineering and is considered
well suitable for software development and managing its
evolution. The idea involves creating a new speciﬁcation or
implementation by modifying an existing one [3]. In general,
the modeler provides a ﬁrst model that satisﬁes a set of initial
requirements. Then, the model can undergo several iterations
or reﬁnements until all the requirements are satisﬁed. In most
cases, it is desirable for the developer to be able to assess the
quality of model as it evolves.
The
problem
with
the
iterative
and
incremental
development is that there is no guarantee that after each
iteration or evolution of the model, it will still satisfy the
previously satisﬁed properties.
Considering Petri nets as a modeling formalism and model
checking as a veriﬁcation technique all the proofs are redone
which is very expensive in terms of cost and time. In this
VERIFY SLICED 
PETRI NET MODEL
PETRI NET 
MODEL
PROPERTY
 SLICING  NON-
EVOLVED & 
EVOLVED PETRI 
NET MODELS
RE-VERIFICATION 
REQUIRED?
YES
NOTIFICATION
NO
EVOLUTION 
TO 
PETRI NET 
MODEL
EXTRACTING 
CRITERION PLACES
Figure 1. Process Flowchart property based veriﬁcation of evolving Petri nets
work, we propose a solution to improve the veriﬁcation and
re-veriﬁcation of evolving systems by re-using, adapting and
reﬁning state of the art techniques. Our proposal pursues two
main goals, the ﬁrst is to perform veriﬁcation only on those
parts that may affect the property a model is analyzed for
and the second is to classify evolutions, to identify which
evolutions require re-veriﬁcation. We argue that for a class of
evolutions that require re-veriﬁcation, instead of verifying the
whole system only a part that is concerned with the property
would be sufﬁcient.
Figure 1, gives an overview using Process Flowchart of the
proposed approach, i.e., a slicing based veriﬁcation of evolving
Petri nets. At ﬁrst, veriﬁcation is performed on the sliced Petri
net model by taking a property into an account. Secondly, we
build slices for evolved and non-evolved Petri nets models.
By comparing the resultant sliced models (i.e., Petri net and its
evolved model), it is determined if the evolution has an impact
on the property satisfaction and if it requires re-veriﬁcation. In
the worst case, if an evolution has an impact on the property
301
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

satisfaction only the resultant sliced evolved Petri net model
would be used for the veriﬁcation. The process can be iterated
as per Petri net evolution.
The rest of the paper is structured as follows: in Section II,
we give a informal and formal deﬁnition of Petri nets. In
Section
III, we give formal and informal description of the
slicing algorithm and all the steps of slicing based veriﬁcation
of Petri nets. In Section IV, a slicing based solution is given
for re-veriﬁcation of evolving Petri nets. Details about the
underlying theory and techniques are given for each activity
of the process. In Section V, we discuss related work and a
comparison with the existing approaches. In Section VI, we
draw the conclusions and discuss future work concerning to
the proposed work.
II.
INFORMAL AND FORMAL DEFINITION OF PETRI NETS
Petri nets are a very well known formalism to model and
analyze concurrent and distributed systems indroduced by C.A.
Petri in his Ph.D. Dissertation [4].
p1
p4
p2
p5
p3
t1
t2
t3
t4
1
1
1
3
2
2
1
1
Figure 2. Example of a Petri net model
A Petri net is a directed bipartite graph, whose two
essential elements are places and transitions. Informally,
Petri nets places hold resources (also known as tokens) and
transitions are linked to places by input and output arcs,
which can be weighted. Usually, a Petri net has a graphical
concrete syntax consisting of circles for places, boxes for
transitions and arrows to connect the two. Formally, we can
deﬁne :
Deﬁnition
1. Petri
net: A Petri
Net is:
PN
=
⟨P, T, w, m0⟩ consist of
◦ P and T are ﬁnite and disjoint sets, called places and
transitions, resp.,
◦ a function w : (P × T) ∪ (T × P) → N, assigns weights
to the arcs,
◦ a marking function m0 : P → N .
The semantics of a Petri net expresses the non-deterministic
ﬁring of transitions in the net. Firing a transition means
consuming tokens from a set of places linked to the input
arcs of a transition and producing tokens into a set of places
linked to the output arcs of a transition. A transition can be
ﬁred only if its incoming places have a token quantity greater
or equal to the weight attached to the arc. As shown in Figure
2, transitions t1 and t2 are enabled from the initial marking
and non-deterministically any one of them can ﬁre. Let us
consider that if t1 ﬁres, the result of transition ﬁring will
remove a token from place p1 and adds a token to place p2.
Deﬁnition 2. (Pre(resp.Post) set places(resp.transitions)
of PN): Let pn =< P, T, f, w, m0 > be a Petri net, p ∈ P
a place then, preset and postset of p, noted •p and p•, are
deﬁned as follows:
•p = {t ∈ T/w(t, p) > 0}.
p• = {t ∈ T/w(p, t) > 0}.
Analogously •t and t• are deﬁned. We also note •P and
P• representing pre(resp.post) set of transtions of all the
places in set P. •T and T• are deﬁned Analogously.
III.
ABSTRACT SLICING
Petri net slicing is a syntactic technique, which is used
to reduce a PN model based on a given criteria. A criteria
is a property for which the PN model is analyzed for. A
sliced part is equal to only that part of a PN model that may
affect the criteria. Considering a property over PN model,
we are interested to deﬁne a syntactically smaller PN model
that could be equivalent with respect to the satisfaction of
the property of interest. To do so the slicing technique starts
by identifying the places directly concerned by the property.
Those places constitute the slicing criterion. The algorithm
then, keeps all the transitions that create or consume tokens
from the criterion places, plus all the pre-set places for those
transitions. This step is iteratively repeated for the latter places,
until reaching a ﬁxed point. (It is important to note that the
proposed slicing algorithms preserve certain speciﬁc properties
as we intentionally do not capture all the behaviors to generate
a smaller sliced net). Many algorithms are proposed for slicing
Petri nets and their main objective is to generate reduced sliced
net [5]–[11]. The ﬁrst slicing algorithm to generate reduced
sliced net was proposed by Astrid Rakow by introducing a
notion of reading and non-reading transitions. Later, this idea
was adapted by Khan et al in the context of Algebraic Petri
nets (i.e., an advancement of Petri nets) [6], [10].
Informally, reading transitions do not change the marking
of a place, meaning they consume and produce the same
token. On the other hand, non-reading transitions change the
markings of a place (see Figure 3), meaning they consume and
produce different tokens. A reduced sliced net can be generated
by discarding the reading transitions (as reading transitions
do not impact the behavior of Petri net) and to include only
non-reading transitions. Formally, we can deﬁne reading and
non-reading transitions:
Deﬁnition 6. (Reading(resp.Non-reading) transitions of
Petri nets): Let t ∈ T be a transition in a PN. We call t a
reading-transition iff its ﬁring does not change the marking of
any place p ∈ (•t ∪ t•) , i.e., iff ∀p ∈ (•t ∪ t•), w(p, t) =
w(t, p). Conversely, we call t a non-reading transition iff
w(p, t) ̸= w(t, p).
We extend the slicing proposal of Rakow and Khan et
al by introducing a new notion of neutral transitions. The
abstract slicing algorithm preserves properties expressed in
CTL∗
−X formulas, we refer the interested reader to [12] for
the detailed proofs. Informally, a neutral transition consumes
and produces the same token from its incoming place to an
outgoing place. The cardinality of incoming (resp.) outgoing
arcs of a neutral transition is strictly equal to one and the
302
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

cardinality of outgoing arcs from an incoming place of a
neutral transition is equal to one as well. Another restriction
is that the cardinality of outgoing arcs from the incoming
place of a neutral transition is strictly equal to one and the
reason is that we want to preserve all possible behaviors
of the net. We may loose some behaviors when we merge
incoming and outgoing places if we allow more outgoing arcs
from the incoming place of a neutral transition. The idea is
to use reading transitions and neutral transitions to generate
smaller sliced net.
Deﬁnition 7. (Neutral transitions of Petri nets): Let t ∈
T be a transition in a PN. We call t a neutral-transition iff it
consumes token from a place p ∈• t and produce the same
token to p′ ∈ t•, i.e., t ∈ T ∧ ∃p∃p′/p ∈• t ∧ p′ ∈ t• ∧ |p•| =
1 ∧ |•t| = 1 ∧ |t•| = 1 ∧ w(t, p) = w(t, p′).
t1
1
P2
1
P1
t1
2
P1
2
Neutral Transition
Reading Transition
Figure 3. Neutral and Reading transitions of PN
1) Abstract Slicing Algorithm:: The abstract slicing algo-
rithm starts with a Petri net model and a slicing criterion
Q ⊆ P containing place(s). We build a slice for an Petri net
based on Q by applying the following algorithm:
Algorithm 1: Abstract slicing algorithm
AbsSlicing(⟨P, T, f, w, m0⟩, Q){
T ′ ← {t ∈ T/∃p ∈ Q∧t ∈ (•p∪p•)∧w(p, t) ̸= w(t, p)};
P ′ ← Q ∪ {•T ′} ;
Pdone ← ∅ ;
while ((∃p ∈ (P ′ \ Pdone)) do
while (∃t ∈ ((•p ∪ p•) \ T ′) ∧ w(p, t) ̸= w(t, p)) do
P ′ ← P ′ ∪ {•t};
T ′ ← T ′ ∪ {t};
end
Pdone ← Pdone ∪ {p};
end
while (∃t∃p∃p′/t ∈ T ′ ∧ p ∈• t ∧ p′ ∈ t• ∧ |•t| =
1 ∧ |t•| = 1 ∧ |p•| = 1
∧p ̸∈ Q ∧ p′ ̸∈ Q ∧ w(p, t) = w(t, p′)) do
m(p′) ← m(p′) ∪ m(p);
w(t, p′) ← w(t, p′) ∪ w(t, p);
while (∃t′ ∈• t/t′ ∈ T ′ ) do
w(p′, t) ← w(p′, t) ∪ w(p, t′);
T ′ ← T ′ \ {t ∈ T ′/t ∈ p• ∧ t ∈• p′};
P ′ ← P ′ \ {p};
end
end
return ⟨P ′, T ′, f|P ′,T ′ , w|P ′,T ′ , m0|P ′ ⟩;
}
In the Abstract slicing algorithm, initially T ′ (representing
transitions set of the slice) contains a set of all the pre and post
transitions of the given criterion places. Only the non-reading
transitions are added to T ′. P′(representing the places set of
the slice) contains all the preset places of the transitions in
T ′. The algorithm then, iteratively adds other preset transitions
together with their preset places in the T ′ and P ′. Then, the
neutral transitions are identiﬁed and their pre and post places
are merged to one place together with their markings.
Considering an example Petri net model shown in ﬁgure
4, let us now apply our proposed algorithm on two example
properties (i.e., one from the class of safety properties and
one from liveness properties). Informally, we can deﬁne the
properties:
φ1
: “The cardinality of tokens inside place P3 is always
less than 5”.
φ2
: “Eventually place P3 is not empty”.
Formally, we can specify both properties in the CTL as:
φ1 = AG(|m(P3)| < 5).
φ2 = AF(|m(P3)| = 1).
For both properties, the slicing criterion Q = {P3}, since
P3 is the only place concerned by the properties. The resultant
sliced Petri net can be observed in ﬁgure4, which is smaller
than the original Petri net.
P1
C
t1
t3
t2
t5
t4
P3
P4
P5
P6
P7
P2
2
2
1
1
2
2
1
1
1
1
1
1
1
P12
t2
t4
P3
Example PN-Model
Resultant Sliced PN-Model
1
1
1
Figure 4. Petri net model and resultant sliced model after applying Abstract
slicing algorithm
Let us compare the number of states required to verify
the given properties without slicing and after applying abstract
slicing. The total number of states required without slicing is
985, whereas with the sliced model number of states is 15.
IV.
CLASSIFICATIONS OF EVOLUTIONS
The behavioral model of a system expressed in terms of
Petri nets is subject to evolve, where an initial version goes
through a series of evolutions generally aimed at improving
its capabilities. Informally, Petri nets can evolve with respect
to the structural changes such as: add/remove places, tran-
sitions, arcs, tokens and terms over the arcs. By notation,
different Petri nets will be noted with superscripts such as
pn′ = ⟨P ′, T ′, f ′, w′, m′
0⟩. As there is no guarantee that
after every evolution of a Petri net model, it still satisﬁes the
previously satisﬁed properties. A naive solution is to repeat
model checking after every evolution, which is very expensive
in terms of time and space.
303
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

We propose a slicing based solution to improve the repeated
model checking. Since it has already been proved that a
sliced net is sufﬁcient to verify properties. (Note: We refer
the interested reader to [10], [12], [13] for the detailed proofs
of all the theorems used in this paper and for slicing algo-
rithms). According to our proposed approach, at ﬁrst, slices
pn 
pnSl 
pn’Sl 
re-verif 
pn' 
NO 
YES 
(re-verify on sliced net) 
build slice 
build slice 
evolution 
Figure 5. Overview
are generated for evolved and non-evolved Petri nets models
with respect to the property by the abstract slicing algorithm
as shown in Figure 5. Then, by comparing both sliced nets
it is decided whether re-veriﬁcation is required or not. If the
answer is no then, re-veriﬁcation is not required, whereas if the
answer is yes, then, re-veriﬁcation is performed on the sliced
net. The good thing is that in both cases re-veriﬁcation cost is
improved. To decide for which evolutions re-veriﬁcation is not
required, we divide the evolutions into two major classes (by
comparing both sliced Petri nets models as shown in the Figure
6), i.e., the evolutions that are taking place outside the slice, the
evolutions that are taking place inside the slice. Furthermore,
we divide the evolutions that are taking place inside the slice
into two classes, i.e., the evolutions that disturb and those that
do not disturb the previously satisﬁed properties.
A. Evolutions taking place outside the Slice:
The aim of slicing is to syntactically reduce a model in
such a way that of the best reduced model contains only
those parts that may inﬂuence the property the model is
analyzed for. And if something is happening outside those
parts of the system, then, it is guaranteed that previously
satisﬁed properties are still true. We can generalize the notion,
for all the evolutions that are taking place outside the slice
do not inﬂuence the property satisfaction. Consequently,
re-veriﬁcation can be completely avoided for these evolutions.
We formally specify how to avoid the veriﬁcation if the
evolutions are taking place outside the slice.
EVOLUTIONS TO 
PETRI NETS
EVOLUTIONS TAKING 
PLACE INSIDE SLICE
EVOLUTIONS TAKING 
PLACE OUTSIDE SLICE 
EVOLUTIONS THAT 
DISTURB PROPERTY 
(VERIFICATION)
EVOLUTIONS THAT DO 
NOT DISTURB PROPERTY 
(NO-VERIFICATION)
EVOLUTIONS DO NOT 
DISTURB PROPERTY    
(NO-VERIFICATION)
Figure 6. Classiﬁcation of evolutions to Petri nets
Theorem 1: Let pnsl = ⟨P, T, f, w, m0⟩ be a sliced Petri
net model and pn′
sl = ⟨P ′, T ′, w′, m′
0⟩ be an evolved sliced
Petri net model w.r.t the property φ. pnsl |= φ ⇔ pn′
sl |= φ if
and only if
pnsl = pn′
sl
Informally, this theorem states that if an evolution is taking
place outside the slice then, the evolved Petri net model
preserves the previously satisﬁed properties. According to the
conditions imposed by the theorem, both the sliced net and
evolved sliced net are same and if the Petri net model satisfy
a given property then, this property will also be true in its
evolved model. Conversely, if the Petri net model does not
satisfy a given property then, this property will be false in its
evolved model.
Let us recall the Petri net model and example property
given in the section III. The example property is following
AG(|m(P3)|) < 5). Figure 7, shows some possible examples
of the evolutions to Petri nets model that are taking place
outside the slice. All the places, transitions and arcs that
constitute a slice with respect to the property are shown
with the blue doted lines (remark that we follow the same
convention for all examples). In the example evolution, weight
attached to the arc between transition t2 and place P4 is
changed and shown with the red color. For all such kind of
evolutions that are taking place outside the slice, we do not
require veriﬁcation because they do not disturb any behavior
that may impact the satisfaction of the property.
Evolved Petri net model "changing the weight over the arc and its sliced net"
Petri net model and its sliced net
P1
C
t1
t3
t2
t5
t4
P3
P4
P5
P6
P7
P2
2
2
1
1
2
2
1
1
1
1
1
1
1
C
t3
t2
t5
t4
P3
P4
P5
P6
P7
P12 1
1
2
2
1
1
1
1
1
1
1
C
t3
t2
t5
t4
P3
P4
P5
P6
P7
P12 1
1
3
2
1
1
1
1
1
1
1
P1
C
t1
t3
t2
t5
t4
P3
P4
P5
P6
P7
P2
2
2
1
1
3
2
1
1
1
1
1
1
1
Figure 7. Evolutions to Petri net model taking place outside the slice
B. Evolutions taking place inside the slice:
For all the evolutions that are taking place inside the
slice, we divide them into two classes, i.e., evolutions that
require veriﬁcation and the evolutions that do not require re-
veriﬁcation. Identifying such class of evolutions is extremely
hard due to non-determinism of the possible evolutions. Specif-
ically, in Petri nets small structural changes can impact the
behavior of the model. It is also hard to determine whether
a property would be disturbed after an evolution or it is still
satisﬁed by the model.
304
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

To identify evolutions that are taking place inside the
slice and do not require re-veriﬁcation, we propose to use
the temporal speciﬁcation of properties to reason about
the satisfaction of properties with respect to the speciﬁc
evolutions. For an example, for all the safety properties
speciﬁed by the temporal formula AG(ϕ) or ∃G(ϕ), if ϕ an
atomic formula, using the ordering operators ≤ or < between
the places and their cardinality or tokens inside places, then,
all the evolutions that decrease the tokens from places do
not require re-veriﬁcation because they do not impact the
behavior required for the property satisfaction.
Theorem 2: Let pnsl = ⟨P, T, f, w, m0⟩ be a sliced Petri
net and pn′
sl = ⟨P ′, T ′, w′, m′
0⟩ be an evolved sliced Petri
net model ( in which tokens are decreased from places) w.r.t
the property φ. For all the safety properties speciﬁed by
temporal formulas, i.e., AG(φ) or ∃G(φ), and φ a formula
using ≤ or < ordering operator between the places and their
cardinality or tokens inside places. pnsl |= φ ⇒ pn′
sl |= φ if
and only if
∀p ∈ (P ∩P ′)/m0(p) ≥ m′
0(p)∧T = T ′∧f = f ′∧w = w′
Let us recall the Petri net model and example property
given in the Section III. The example property is following
AG(|m(P3)| < 5), we can avoid the re-veriﬁcation for several
evolutions even if they are taking place inside the slice. Some
possible examples of the evolutions are shown in Figure 8. In
the ﬁrst example, tokens are decreased from a place and in
the second example, tokens are decreased from an arc, but the
property is still satisﬁed.
Evolved Petri net model "decreasing the token from place and its sliced net"
Petri net model and its sliced net
P1
C
t1
t3
t2
t5
t4
P3
P4
P5
P6
P7
P2
2
2
1
1
2
2
1
1
1
1
1
1
1
C
t3
t2
t5
t4
P3
P4
P5
P6
P7
P12 1
1
2
2
1
1
1
1
1
1
1
C
t3
t2
t5
t4
P3
P4
P5
P6
P7
P12 1
1
2
2
1
1
1
1
1
1
1
P1
C
t1
t3
t2
t5
t4
P3
P4
P5
P6
P7
P2
2
2
1
1
2
2
1
1
1
1
1
1
1
Figure 8. Evolutions to Petri net model taking place inside the slice
For all the liveness properties speciﬁed by a temporal
formula ∃ F(ϕ), and if ϕ a formula using the ordering
operators (≥ or >) the places and their cardinality or tokens
inside places and their values, then, for all the evolutions that
increase the token count, it is not required to verify them as
they do not impact the behavior required for the property
satisfaction.
Theorem 3: Let pnsl = ⟨P, T, f, w, m0⟩ be a sliced Petri
net and pn′
sl = ⟨P ′, T ′, w′, m′
0⟩ be an evolved sliced Petri
net model ( in which tokens are increased from places) w.r.t
the property φ. For all the liveness properties speciﬁed by a
temporal formula ∃F(φ), and φ is using the ordering operators
≥ or > between the places and their cardinality or tokens
inside places and their values. pnsl |= φ ⇒ pn′
sl |= φ if and
only if
∀p ∈ (P ∩P ′)/m0(p) ≤ m′
0(p)∧T = T ′∧f = f ′∧w = w′
Evolved Petri net model "increasing the tokens in place and its sliced net"
Petri net model and its sliced net
P1
C
t1
t3
t2
t5
t4
P3
P4
P5
P6
P7
P2
2
2
1
1
2
2
1
1
1
1
1
1
1
C
t3
t2
t5
t4
P3
P4
P5
P6
P7
P12 1
1
2
2
1
1
1
1
1
1
1
C
t3
t2
t5
t4
P3
P4
P5
P6
P7
P12 1
1
2
2
1
1
1
1
1
1
1
P1
C
t1
t3
t2
t5
t4
P3
P4
P5
P6
P7
P2
2
2
1
1
2
2
1
1
1
1
1
1
1
Figure 9. Evolutions to Petri net model taking place inside the slice
Let us consider again Petri net model given in the Sec-
tion III , if we are interested to verify the example property
such as: ∃F(|P3| > 3), veriﬁcation can be avoided completely
for several evolutions even if they are taking place inside the
slice. Some possible examples of the evolutions are shown
in Figure d9. In the ﬁrst and second examples, tokens are
increased but the property is still satisﬁed.
We identiﬁed above that for several speciﬁc evolutions and
properties veriﬁcation could be completely avoided, and for the
rest of evolutions we can perform veriﬁcation only on the part
that concerns the property by following Section ??. Even in
this case we signiﬁcantly improve the veriﬁcation of evolution.
V.
RELATED WORK
Slicing is a technique used to reduce a model syntactically.
The reduced model contains only those parts that may affect
the property the model is analyzed for. Slicing Petri nets is
gaining much attention in the recent years
[5]–[11], [13].
Mark Weiser [14] introduced the slicing term, and presented
slicing as a formalization of an abstraction technique that ex-
perienced programmers (unconsciously) use during debugging
to minimize the program. The ﬁrst algorithm about Petri net
slicing was presented by Chang et al [5]. They proposed an
algorithm on Petri nets testing that slices out all sets of paths,
called concurrency sets, such that all paths within the same
set should be executed concurrently. Astrid Rakow developed
two slicing algorithms for Petri nets, i.e., CTL∗
−X slicing and
Safety slicing in [10]. We introduced the Algebraic Petri net
slicing for the ﬁrst time
[6], [12]. We adapt the notion of
reading and non-reading transitions deﬁned by Rakow [10] in
the context of low-level Petri nets and applied to Algebraic
Petri nets [6]. We extend the previous proposal by introducing
305
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

a new notion of neutral transitions and applied to Algebraic
Petri nets [12]. In this work, we designed abstract slicing
algorithm in the context of low-level Petri nets and used to
reason about the re-veriﬁcation. To the best of your knowledge
this is the ﬁrst proposal to use slicing to improve the re-
veriﬁcation of Petri nets models.
Most of the work regarding the improvement of the re-
veriﬁcation of evolving Petri nets is oriented towards the
preservation of properties. Padberg and several other authors
published extensively on the invariant preservation of APNs by
building a full categorical framework for APNs, i.e., rule-based
reﬁnements [15]–[17]. Padberg consider the notion of a rule-
based modiﬁcation of Algebraic high level nets preserving the
safety properties. The theory of a rule-based modiﬁcation is an
instance of the high-level replacement system. Rules describe
which part of a net are to be deleted and which new parts are
to be added. It preserves the safety properties by extending the
rule-based modiﬁcation of Algebraic Petri nets in contrast to
transition preserving morphisms in [15]. These morphisms are
called the place preserving morphisms by allowing transferring
of speciﬁc temporal logic formulas expressing net properties
from the source to the target net. Lucio presented a prelimi-
nary study on the invariant preservation of behavioral models
expressed in Algebraic Petri nets in the context of an iterative
modeling process [16]. They proposed to extend the property
preserving morphisms in a way that it becomes possible to
strengthen the guards without loosing previous behaviours.
In contrast to the property preservation, the scope of our
work is broader. At ﬁrst, we try to ﬁnd out which evolutions
require re-veriﬁcation independent of the temporal represen-
tations of properties. Secondly, we focus on the speciﬁc
properties and evolutions to improve the re-veriﬁcation. We
do not restrict the type of evolutions and properties to give
more ﬂexibility to a user. It is important to note that our
proposed technique can further reﬁne the previous proposals
about the property preservation. The proposal is to preserve
the morphisms restricted to the sliced part of the net.
VI.
CONCLUSION AND FUTURE WORK
In this work, we developed an approach to improve the
veriﬁcation and re-veriﬁcation of systems modeled in Petri
nets. At ﬁrst, a Petri net model is syntactically reduced based
on the given temporal property. The reduced model which
we call a sliced model constitutes only that part of a model
that may affect the property satisfaction. The sliced model
preserves CTL∗
−X properties. Secondly, we classify evolutions
and properties to determine whether re-veriﬁcation is required
or not. We do not restrict the types of evolutions and the
properties to give more ﬂexibility to the user. Our results show
that slicing is helpful to alleviate the state space explosion
problem of Petri nets model checking and the re-veriﬁcation
of evolving Petri nets.
The future work has two objectives; ﬁrst is to implement
the proposed approach. A tool named SLAPN ( a tool for
slicing Algebraic Petri nets) is under development [18]. It is
important to note that the SLAPN tool is a generic tool over
the Petri net classes such as Petri net, Algebraic Petri nets. It
provides a graphical interface to draw a Petri net or Algebraic
Petri net model together with the temporal description of
properties. It contains the implementation of different slicing
algorithms and a user can select any of them to generate a
sliced Petri net model. The future work consists of imple-
mentation of the classiﬁcation of evolutions and properties
to automate the proposed approach. The second objective of
future work is concerned to enhance the theory of preservation
of properties. The aim is to develop a property preserving
domain speciﬁc language for the evolving Petri nets based on
the slicing and the classiﬁcation of evolutions and properties
proposed in this work.
REFERENCES
[1]
I. Sommerville, Software Engineering: (Update) (8th Edition) (Interna-
tional Computer Science Series).
Addison Wesley, June 2006.
[2]
L. Erlikh, “Leveraging legacy system dollars for e-business,” IT Pro-
fessional, vol. 2, no. 3, pp. 17–23, May 2000.
[3]
C. Larman and V. Basili, “Iterative and incremental developments. a
brief history,” Computer, vol. 36, no. 6, pp. 47–56, 2003.
[4]
C. A. Petri, “Kommunikation mit automaten,” Ph.D. dissertation, Uni-
versität Hamburg, 1962.
[5]
J. Chang and D. J. Richardson, “Static and dynamic speciﬁcation
slicing,” in In Proceedings of the Fourth Irvine Software Symposium,
1994.
[6]
Y. I. Khan and M. Risoldi, “Optimizing algebraic petri net model
checking by slicing,” International Workshop on Modeling and Business
Environments (ModBE’13, associated with Petri Nets’13), 2013.
[7]
M. Llorens, J. Oliver, J. Silva, S. Tamarit, and G. Vidal, “Dynamic
slicing techniques for petri nets,” Electron. Notes Theor. Comput.
Sci.,
vol.
223,
pp.
153–165,
Dec.
2008.
[Online].
Available:
http://dx.doi.org/10.1016/j.entcs.2008.12.037
[8]
A. Rakow, “Slicing petri nets with an application to workﬂow
veriﬁcation,” in Proceedings of the 34th conference on Current trends
in theory and practice of computer science, ser. SOFSEM’08.
Berlin,
Heidelberg: Springer-Verlag, 2008, pp. 436–447. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1785934.1785974
[9]
——, “Slicing and reduction techniques for model checking petri nets,”
Ph.D. dissertation, University of Oldenburg, 2011.
[10]
——, “Safety slicing petri nets,” in Application and Theory of
Petri Nets, ser. Lecture Notes in Computer Science, S. Haddad
and L. Pomello, Eds., vol. 7347.
Springer Berlin Heidelberg,
2012, pp. 268–287. [Online]. Available: http://dx.doi.org/10.1007/
978-3-642-31131-4_15
[11]
W. J. Lee, H. N. Kim, S. D. Cha, and Y. R. Kwon, “A slicing-based
approach to enhance petri net reachability analysis,” Journal of Research
Practices and Information Technology, vol. 32, pp. 131–143, 2000.
[12]
Y. I. Khan and N. Guelﬁ, “Slicing high-level petri nets,” International
Workshop
on
Petri
Nets
and
Software
Engineering
(PNSE’14)
associated with Petri Nets’14), vol. 2, no. 3, pp. 201–220, 2014.
[Online]. Available: http://ceur-ws.org/Vol-1160/
[13]
Y. I. Khan, “Property based model checking of structurally evolving
algebraic petri nets,” Ph.D. dissertation, University of Luxembourg,
2015.
[14]
M. Weiser, “Program slicing,” in Proceedings of the 5th international
conference on Software engineering, ser. ICSE ’81.
Piscataway, NJ,
USA: IEEE Press, 1981, pp. 439–449.
[15]
J. Padberg, M. Gajewsky, and C. Ermel, “Rule-based reﬁnement of high-
level nets preserving safety properties,” in Fundamental approaches to
Software Engineering.
Springer Verlag, 1998, pp. 22 123–8.
[16]
M. A. Q. Z. Levi Lucio, Eugene Syriani and H. Vangheluwe, “Invari-
ant preservation in iterative modeling,” Proceedings of the ME 2012
workshop, 2012.
[17]
S. P. Er, “Invariant property preserving extensions of elementary petri
nets,” Technische Universitat Berlin, Tech. Rep., 1997.
[18]
Y. I. Khan and N. Guelﬁ, “Slapn: A tool for slicing algebraic petri
nets,” International Workshop on Petri Nets and Software Engineering
(PNSE’14) associated with Petri Nets’14), vol. 2, no. 3, pp. 343–345,
2014.
306
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

