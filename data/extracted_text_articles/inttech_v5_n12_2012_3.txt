Quality Analysis of a Chaotic Proven Keyed Hash
Function
Jacques M. Bahi, Jean-François Couchot, and Christophe Guyeux
University of Franche-Comté, FEMTO-ST Institute
Belfort, France
Email: {jacques.bahi, jean-francois.couchot, christophe.guyeux}@univ-fcomte.fr
Abstract—Hash functions are cryptographic tools, which are
notably involved in integrity checking and password storage.
They are of primary importance to improve the security of
exchanges through the Internet. However, as security ﬂaws have
been recently identiﬁed in the current standard in this domain,
new ways to hash digital data must be investigated. In this
document an original keyed hash function is evaluated. It is
based on asynchronous iterations leading to functions that have
been proven to be chaotic. It thus possesses various topological
properties as uniformity and sensibility to its initial condition.
These properties make our hash function satisﬁes established
security requirements in this ﬁeld. This claim is qualitatively
proven and experimentally veriﬁed in this research work, among
other things by realizing a large number of simulations.
Keywords-Keyed Hash Function; Internet Security; Mathemat-
ical Theory of Chaos; Topology.
I. INTRODUCTION
The security and the privacy of data exchanged through the
Internet are guaranteed by protocols that make an adequate use
of a few cryptographic tools as secure pseudorandom number
generators or hash functions. Hash functions are applications
that map words of any lengths to words of ﬁxed lengths (often
256 or 512 bits). These hash functions allow, for instance, to
store passwords in a secure manner or to check whether a
download has occurred without any error. They be designed
to depend from a given parameter, called a key. According to
their ﬁeld of application, the requirements an hash function
has to satisfy can change. They need at least to be very fast,
so that the diffusion of the digest into the set of hash values
occurs (whatever the bias into the inputted message), and so
that a link between a message and its digest is impossible
to establish in practice (confusion). The possibility to use
a key or to distribute the computation on numerous threads
must often be offered in several applications. Finally, in the
computer security ﬁeld, stringent complexity properties have
to be proven, namely the collision, preimage, and second-
preimage resistances, the unpredictability, and the pseudo-
randomness properties. Each of the latter one have a rigorous
formulation in terms of polynomial indistinguishability.
Several hash functions have been proposed as candidates to
be standards in computer science. Such standards are designed
by the scientiﬁc community and selected, after peer studies,
by administrations as the NIST one (National Institute for
Standards and Technologies of the US government). SHA-1
is probably the most widely used hash function. It is present
in a large panel of security applications and protocols through
the Internet.
However, in 2004, MD5 and SHA-0 have been broken. An
attack over SHA-1 has been achieved with only 269 operations
(CRYPTO-2005), that is, 2, 000 times faster than a brute force
attack (that requires 280 operations). Even if 269 operations still
remain impossible to realize on common computers, such a re-
sult, based on a previous attack on SHA-0, is a very important
one: as the SHA-2 variants are algorithmically close to SHA-1
and eventually produce message digests on principles similar
to the MD4 and MD5 message digest algorithms, a new hash
standard based on original approaches is then eagerly awaited.
This is why a SHA-3 contest has been launched these last few
years, to ﬁnd a new, more secure standard for hash functions.
So new original hash functions, or improvements for existing
ones, must be found.
In this context, we have proposed a new hash function in [1],
[2]. Being designed by using discrete dynamical systems, and
taking beneﬁts from various established topological properties,
this new family of hash functions is thus based on a completely
different approach. Among other things, in our proposal, an
ingredient of chaos is added to existing hash functions, in order
to reinforce their properties. Introducing chaos into the design
of hash functions has been already addressed in [3], [4], [5],
[6]. These methods usually transform the initial message into
its padded ﬁxed length version and then translate it into a
real number. Next, with a chosen chaotic map (some chaotic
functions of real variables like logistic, tent, or Arnold’s cat
maps, for instance [7]), methods set the initial algorithm
parameters according to the secret key and start iterations.
Methods are then left to extract some bits from the iterations
results and to juxtapose them to get the hash value. It is then
supposed that the ﬁnal hash function preserves the properties
of chaos. However, the idea of chaotic hash functions has been
controversially discussed in the community [8], [9]. Moreover,
even if these algorithms are themselves proven to be chaotic,
their implementations on ﬁnite machines can result into the
loss of chaos property. Among other things, the main reason
is that chaotic functions (embedded in these researches) only
manipulate real numbers, which do not exist in a computer.
In [2], the hash function we have proposed does not simply
integrate chaotic maps into algorithms hoping that the result
remains chaotic; we have conceived an algorithm and have
mathematically proven that it is chaotic. To do both, our theory
and our implementation are based on ﬁnite integer domains
and ﬁnite states iterations, where only one randomly chosen
element is modiﬁed at each step. This iteration mode is further
referred to as asynchronous mode.
These studies lead to the conclusion that the chaos of
asynchronous iterations is very intense [10]. As this mode
only manipulates binary digits or integers, we have shown
that truly chaotic computer programs can be produced. They
can thus be applied to pseudorandom number generators [11]
and to a complete class of information hiding schemes [12],
26
International Journal on Advances in Internet Technology, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/internet_technology/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

for instance. In this paper, the complete chaotic behavior of
asynchronous iterations is capitalized to produce a truly chaotic
keyed hash function.
This research work is an improvement of a previous article
accepted at the Third International Conference on Evolving
Internet, INTERNET11 (June 19-24, 2011, Luxembourg) [1].
Compared to this research work, the proposed hash function
(Section III) has been completely rethought. It appears now
more as a post-treatment on existing hash functions, to improve
their security (Sections III, IV), than as a hash function de-
signed from scratch. Moreover, the second-preimage resistance
has been proven in Section IV-B and the strict avalanche
criterion has been statistically studied (Section V-C). All these
improvements lead to obviously better scores for the proposed
hash functions, when experimentally evaluating its security.
The remainder of this research work is organized in the
following way. In Section II, basic notions concerning asyn-
chronous iterations and Devaney’s chaos are recalled. Our
keyed hash function is presented in Section III. Performance
analyses are presented in the next two sections: in the ﬁrst one
a qualitative evaluation of this function is outlined, whereas in
the second one it is evaluated experimentally. This research
work ends by a conclusion section, in which our contribution
is summarized and intended future work is mentioned.
II. BACKGROUND SECTION
In this section, we ﬁrst give deﬁnitions of Secure Keyed
One-Way Hash Functions and of the Strict Avalanche Criterion
(SAC), which is a property that such a function has to verify.
Next we give some recalls on Boolean discrete dynamical
systems and link them with topological chaos. Finally, we
establish relations between the algorithm properties inherited
from topological results and the requirements of Secure Keyed
One-Way Hash Function.
A. Secure Keyed One-Way Hash Function
Deﬁnition 1 (Secure Keyed One-Way Hash Function [13])
Let Γ and Σ be two alphabets, let k ∈ K be a key in a given
key space, let l be a natural number, which is the length of
the output message, and let h : K × Γ+ → Σl be a function
that associates a message in Σl for each pair of key, word in
K × Γ+. The set of all functions h is partitioned into classes
of functions {hk : k ∈ K} indexed by a key k and such
that hk : Γ+ → Σl is deﬁned by hk(m) = h(k, m), i.e., hk
generates a message digest of length l.
A class {hk : k ∈ K} is a Secure Keyed One-Way Hash
Function if it satisﬁes the following properties:
1) the function hk is keyed one-way. That is,
a) Given k and m, it is easy to compute hk(m).
b) Without the full knowledge of k, it is
• difﬁcult to ﬁnd m when hk(m) is given; this
property is referred to as preimage resistance;
• difﬁcult to ﬁnd hk(m) when only m is given.
2) The function hk is the keyed collision resistant, that is,
without the knowledge of k it is difﬁcult to ﬁnd two
distinct messages m and m′ s.t. hk(m) = hk(m′). A
weaker version of this property is the second preimage
resistance, which is established if for a given m it is
difﬁcult to ﬁnd another message m′, m ̸= m′, such that
hk(m) = hk(m′).
3) Images of function hk have to be uniformly distributed
in Σl in order to counter statistical attacks.
4) Length l of the produced image has to be larger than
128 bits in order to counter birthday attacks [14].
5) Key space size has to be sufﬁciently large in order to
counter exhaustive key search.
Finally, hash functions have to verify the strict avalanche
criterion deﬁned as follows:
Deﬁnition 2 (Strict Avalanche Criterion [15]) Let
x
and
xi, two n-bit, binary vectors, such that x and xi differ only in
bit i, 1 ⩽ i ⩽ n. Let f be the cryptographic transformation
(hash function applied on vector of bits for instance). Let ⊕
be the exclusive or operator. The f function meets the strict
avalanche criterion if and only if the following property is
established;
∀n. ∀i, j. 1 ⩽ i ⩽ n ∧ 1 ⩽ j ⩽ m ⇒
P

The state-vector xt = (xt
1, . . . , xt
n) ∈ Bn of the system at
discrete time t (also said at iteration t) is further denoted as
the conﬁguration of the system at time t.
In what follows, the dynamics of the system is particularized
with the negation function ¬ : Bn → Bn such that ¬(x) =
(xi, . . . , xn) where xi is the negation of xi. We thus have the
function F¬ that is deﬁned by:
F¬ : J1; nK × Bn
→
Bn
F¬(s, x)j
=

xj if j = s
xj otherwise.
With such a notation, conﬁgurations are deﬁned for times t =
0, 1, 2, . . . by:
 x0 ∈ Bn and
xt+1 = F¬(St, xt) .
(1)
In the space X = J1; nKN × Bn we deﬁne the distance
between two points X = (S, E), Y = ( ˇS, ˇE) ∈ X by
d(X, Y )
=
de(E, ˇE) + ds(S, ˇS), where
de(E, ˇE)
=
n
X
k=1
δ(Ek, ˇEk), and
ds(S, ˇS)
=
9
n
∞
X
k=1
|Sk − ˇSk|
10k
.
If the ﬂoor value ⌊d(X, Y )⌋ is equal to j, then the systems
E, ˇE differ in j cells. In addition, d(X, Y ) − ⌊d(X, Y )⌋ is a
measure of the differences between strategies S and ˇS. More
precisely, this ﬂoating part is less than 10−k if and only if the
ﬁrst k terms of the two strategies are equal. Moreover, if the
kth digit is nonzero, then the kth terms of the two strategies
are different.
In his PhD thesis [10], Guyeux has already proven that:
• The function Gf is continuous on the metric space (X, d).
• The parallel iterations of G¬ are regular: periodic points
of G¬ are dense in X.
• The function G¬ is topologically transitive: for all
X, Y ∈ X, and for all open balls BX and BY centered
in X and Y respectively, there exist X′ ∈ BX and t ∈ N
such that Gt
¬(X′) ∈ BY .
• The function G¬ has sensitive dependence on initial
conditions: there exists δ > 0 such that for any X ∈ X
and any open ball BX, there exist X′ ∈ BX and t ∈ N
such that d(Gt
¬(X), Gt
¬(X′)) > δ.
To put it differently, a system is sensitive to initial conditions
if any point contains, in any neighborhood, another point with
a completely different future trajectory. Topological transitivity
is established when, for any element, any neighborhood of its
future evolution eventually overlaps with any other open set.
On the contrary, a dense set of periodic points is an element
of regularity that a chaotic dynamical system has to exhibit.
We have previously established that the three conditions
for Devaney’s chaos hold for asynchronous iterations. They
thus behave chaotically, as it is deﬁned in the mathematical
theory of chaos [16], [17]. In other words, quoting Devaney
in [16], a chaotic dynamical system “is unpredictable because
of the sensitive dependence on initial conditions. It cannot be
broken down or simpliﬁed into two subsystems, which do not
interact because of topological transitivity. And in the midst
of this random behavior, we nevertheless have an element of
regularity”.
Intuitively, the topologically transitivity and the sensitivity
on initial conditions respectively address the preimage resis-
tance and the avalanche criteria. Section IV formalizes this
intuition.
The next section presents our hash function that is based on
asynchronous iterations.
III. CHAOS-BASED KEYED HASH FUNCTION ALGORITHM
The hash value is obtained as the last conﬁguration resulting
from iterations of G¬. We then have to deﬁne the pair X0 =
((St)t∈N, x0), i.e., the strategy S and the initial conﬁguration
x0.
A. Computing x0
The ﬁrst step of the algorithm is to transform the message in
a normalized n = 256 bits sequence x0. Notice that this size
n of the digest can be changed, mutatis mutandis, if needed.
Here, this ﬁrst step is close to the pre-treatment of the SHA-
1 hash function, but it can easily be replaced by any other
compression method.
To illustrate this step, we take an example, our original text
is: “The original text”.
Each character of this string is replaced by its ASCII code
(on 7 bits). Following the SHA-1 algorithm, ﬁrst we append
the character “1” to this string, which is then
10101001 10100011 00101010 00001101 11111100
10110100 11100111 11010011 10111011 00001110
11000100 00011101 00110010 11111000 11101001.
Next we append the block 1111000, which is the binary
value of this string length (120) and let R be the result. Finally
another “1” is appended to R if and only if the resulting length
is an even number.
10101001 10100011 00101010 00001101 11111100
10110100 11100111 11010011 10111011 00001110
11000100 00011101 00110010 11111000 11101001
1111000.
The whole string is copied, but in the opposite direction:
10101001 10100011 00101010 00001101 11111100
10110100 11100111 11010011 10111011 00001110
11000100 00011101 00110010 11111000 11101001
11110000 00111110 01011100 01111101 00110010
11100000 10001101 11000011 01110111 00101111
10011100 10110100 11111110 11000001 01010011
00010110 010101.
The string whose length is a multiple of 512 is obtained, by
duplicating the string obtained above a sufﬁcient number of
times and truncating it at the next multiple of 512. This string
is further denoted by D. Finally, we split our obtained string
into two blocks of 256 bits and apply to them the exclusive-or
(further denoted as XOR) function, from the ﬁrst two blocks
to the last one. It results a 256 bits sequence, that is in our
example:
00001111 00101111 10000010 00111010 00001110
01100111 01111000 10011101 01010111 00110101
11010100 01101001 11111001 00011011 01001110
00110000 11000111 00101101 10001001 11111001
01100010 10111010 11001110 10101011 10010001
11101110 01100111 00000101 11000100 00011111
01001111 00001100.
The conﬁguration x0 is the result of this pre-treatment and
is a sequence of n = 256 bits. Notice that many distinct
28
International Journal on Advances in Internet Technology, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/internet_technology/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

texts lead to the same string x0. The algorithm detailed in [1]
always appends “1” to the string R. However such an approach
suffered from generating the same x0 when R’s length is 128.
In that case the size of its reverse is again 128 bits leading
a message of length 256. When we duplicate the message,
we obtain a message of length 512 composed of two equal
messages. The resulting XOR function is thus 0 and this
improvement consequently allows us to avoid this drawback.
Let us build now the strategy (St)t∈N that depends on the
original message and on a given key.
B. Computing (St)t∈N
To obtain the strategy S, the chaotic proven pseudorandom
number generator detailed in [18] is used. The seed of this
PRNG is computed as follows: ﬁrst the ASCII code (on 7
bits again) of the key is duplicated enough and truncated to
the length of D. A XOR between D and this chain gives the
seed of the PRNG, that is left to generate a ﬁnite sequence of
natural numbers St in J1, nK whose length is 2n.
C. Computing the digest
To design the digest, asynchronous iterations of G¬ are
realized with initial state X0 = ((St)t∈N, x0) as deﬁned
above. The result of these iterations is a n = 256 bits vector.
Its components are taken 4 per 4 bits and translated into
hexadecimal numbers, to obtain the hash value:
AF71542C90F450F6AE3F649A0784E6B1
6B788258E87654B4D6353A2172838032.
As a comparison if we replace “The original text” by “the
original text”, the hash function returns:
BAD8789AD6924B6460F8E7686A24A422
8486DC8FDCAE15F1F681B91311426056.
We then investigate the qualitative properties of this algo-
rithm.
IV. QUALITY ANALYSIS
We show in this section that, as a consequence of recalled
theoretical results, this hash function tends to verify desired
informal properties of a secure keyed one-way hash function.
A. The Strict Avalanche Criterion
In our opinion, this criterion is implied by the topological
properties of sensitive dependence to the initial conditions, ex-
pansivity, and Lyapunov exponent. These notions are recalled
below.
First, a function f has a constant of expansivity equal to ε
if an arbitrarily small error on any initial condition is always
magniﬁed till ε. In our iteration context and more formally,
the function G¬ veriﬁes the expansivity property if there exists
some constant ε > 0 such that for any X and Y in X, X ̸= Y ,
we can ﬁnd a k ∈ N s.t. d(Gk
¬(X), Gk
¬(Y )) ⩾ ε. We have
proven in [19] that, (X, G¬) is an expansive chaotic system.
Its constant of expansivity is equal to 1.
Next, some dynamical systems are highly sensitive to small
ﬂuctuations into their initial conditions. The constants of
sensibility and expansivity have been historically deﬁned to
illustrate this fact. However, in some cases, these variations
can become enormous, can grow in an exponential manner in
a few iterations, and neither sensitivity nor expansivity are able
to measure such a situation. This is why Alexander Lyapunov
has proposed a new notion able to evaluate the ampliﬁcation
speed of these ﬂuctuations we now recall:
Deﬁnition 3 (Lyapunov Exponent) Let be given an iterative
system x0 ∈ X and xt+1 = f(xt). Its Lyapunov exponent is
deﬁned by:
lim
t→+∞
1
t
t
X
i=1
ln
 f ′ 
2) Proofs of the Second-Preimage Resistance: We will fo-
cus now on a rigorous proof of the second-preimage resistance:
an adversary given a message m should not be able to ﬁnd
another message m′ such that m ̸= m′ and h(m) = h(m′).
More precisely, we will show that a more general instance
of the proposed post-treatment described below preserves this
character for a given hash function.
Let
• k1,k2,n, all in N∗, where k1 is the size of the key, k2 is
the size of the seed, and n is the size of the hash value,
• h : (k, m) ∈ Bk1 × B∗ 7−→ h(k, m) ∈ Bn a keyed hash
function,
• S : k ∈ Bk2 7−→ S(k) ∈ J1, nK a cryptographically
secure pseudorandom number generator,
• K = Bk1 × Bk2 × N called the key space,
• and f : Bn −→ Bn a bijective map.
We deﬁne the keyed hash function H : K × B∗ −→ Bn by
the following procedure
Inputs:
K = (K1, K2, N) ∈ K
m ∈ B∗
Runs:
X = h(K1, m)
for i = 1, . . . , N :
X = Gf(Si(K2), X)
return X
where K1 is the key of the inputted hash function, K2 the seed
of the strategy used in the post-treatment iterations, where N
is for the size of this strategy. We have the following result.
Theorem 1 If h satisﬁes the second-preimage resistance prop-
erty, then it is the case for H too.
To achieve the proof, we introduce the two following
lemmas.
Lemma 1 If f : Bn −→ Bn is bijective, then for any S ∈
J1, nK, the map Gf,S : x ∈ Bn → Gf([S, 1, . . . , 1], x)2 ∈ Bn
is bijective too where Gf(_, _)2 is the second term of the pair
Gf(_, _).
Proof: Since Bn is a ﬁnite set, it is sufﬁcient to prove that
Gf,S is surjective. Let y = (y1, . . . , yn) ∈ Bn and S ∈ J1, nK.
Thus
Gf,S

Figure 1: The original plain-image.
Case 6. We add 1 to the gray value of the pixel located in
position (123,27).
Case 7. We subtract 1 to the gray value of the pixel located
in position (23,127).
The corresponding hash values in hexadecimal format are:
Case 1.
0B4730459FBB5E54A18A9CCD676C8396
365B0104407D98C866FDAA51A07F0E45,
Case 2.
752E28088150B98166D870BC24177342
23A59463D44B83E9808383B30F8B8409,
Case 3.
C10EED0A9D44856847F533E5647D0CCD
2C58A08643E4D3E5D8FEA0DA0E856760,
Case 4.
52BF23429EC3AD16A0C9DE03DF51C420
4466285448D6D73DDFB42E7A839BEE80,
Case 5.
5C639A55E2B26861EB9D8EADDF92F935
5B6214ADC01197510586745D47C888B8,
Case 6.
E48989D48209143BAE306AC0563FFE31
EAB02E5E557B49E3442A840996BECFC1,
Case 7.
EC850438A2D8EA95E691C746D487A755
12BEE63F4DDB4466C11CD859671DFBEB,
These simulation results are coherent with the topological
properties of sensitive dependence to the initial condition,
expansivity, and Lyapunov exponent: any alteration in the
message causes a substantial difference in the ﬁnal hash value.
B. Statistical Evaluation of the Algorithm
We focus now on statistical studies of diffusion and confu-
sion properties. Let us recall that confusion refers to the desire
to make the relationship between the key and the digest as
complex and involved as possible, whereas diffusion means
that the redundancy in the statistics of the plain-text must
be "dissipated" in the statistics of the cipher-text. Indeed, the
avalanche criterion is a modern form of the diffusion, as this
term means that the output bits should depend on the input
bits in a very complex way.
1) Uniform repartition for hash values: To show the diffu-
sion and confusion properties veriﬁed by our scheme, we ﬁrst
give an illustration of the difference of characters repartition
between a plain-text and its hash value, when the original
message is again the Ulalume poem. In Figure 2a, (resp.
in Figure 2b) the X-axis represents ASCII numbers (resp.
hexadecimal numbers) whereas the Y-axis gives for each X-
value its position in the original text (resp. in the digest).
For instance, in Figure 2b, the point (1, 17) means that the
character 1 is present in the digest at position 17 (see Case
1, Section. V-A). We can see that ASCII codes are localized
within a small area (e.g., the ASCII “space” code and the
0
20
40
60
80
100
120
140
ASCII values
0
500
1000
1500
2000
2500
3000
3500
4000
Indices
(a) Original text
0
2
4
6
8
10
12
14
16
Hexadecimal values
0
10
20
30
40
50
60
70
Indices
(b) Digest
Figure 2: Values repartition of Ulalume poem
lowercase characters), whereas in Figure 2b the hexadecimal
numbers of the hash value are uniformly distributed.
A similar experiment has been realized with a message
having the same size, but which is only constituted by the
character “0”. The contrasts between the plain-text message
and its digest are respectively presented in Figures 3a and 3b.
Even under this very extreme condition, the distribution of the
digest still remains uniform. To conclude, these simulations
tend to indicate that no information concerning the original
message can be found into its hash value, as it is recommended
by the Shannon’s diffusion and confusion requirements.
2) Behavior through small random changes: We now con-
sider the following experiment. A ﬁrst message of 1000 bits
is randomly generated, and its hash value of size n = 256
bits is computed. Then one bit is randomly toggled into this
message and the digest of the new message is obtained. These
two hash values are compared by using the hamming distance,
to compute the number Bi of changed bits. This test is
reproduced t = 10, 000 times. The corresponding distribution
of Bi is presented in Figure 4.
As desired, Figure 4 shows that the distribution is centered
around 128, which reinforces the conﬁdence put into the good
31
International Journal on Advances in Internet Technology, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/internet_technology/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

45
46
47
48
49
50
51
ASCII values
0
1
2
3
4
5
6
7
Indices
(a) Original text
0
2
4
6
8
10
12
14
16
Hexadecimal values
0
10
20
30
40
50
60
70
Indices
(b) Digest
Figure 3: Values repartition of the “00000000” message
95
97
99
101
103
105
107
109
111
113
115
117
119
121
123
125
127
129
131
133
135
137
139
141
143
145
147
149
151
153
155
0
100
200
300
400
500
600
Figure 4: Histogram
capabilities of diffusion and confusion of the proposed hash
algorithm. To analyse these results, the following common
statistics are used.
• Mean changed bit number
B = 1
t
t
X
i=1
Bi.
Bmin
Bmax
B
P(%)
∆B
∆P(%)
n = 256
87
167
127.95
49.98
8.00
3.13
n = 512
213
306
255.82
49.97
11.29
2.21
n = 1024
446
571
511.54
49.96
15.97
1.56
Table I: Statistical performances of the proposed hash function
• Mean changed probability
P = B
n .
• ∆B =
r
1
t
Pt
i=1(Bi − B)2.
• ∆P =
r
1
t
Pt
i=1( Bi
n − P)2.
The obtained statistics are listed in Table I where n belongs
to {256; 512; 1, 024}. In that study, starting from a message of
length 1, 000 and its digest, all the messages that have one bit
of difference are further generated and the digest of the new
message is obtained. Obviously, both the mean changed bit
number B and the mean changed probability P are close to the
ideal values ( n
2 bits and 50%, respectively), which illustrates
the diffusion and confusion capability of our algorithm. Lastly,
as ∆B and ∆P are very small, these capabilities are very
stable.
C. Strict Avalanche Criterion Evaluation
This section focuses on checking whether the developed
hash function veriﬁes the strict avalanche criterion, as given
in Deﬁnition 2. Quoting remarks of [15], “Unless n is small,
it would be an immense task to follow this procedure for all
possible vector pairs x and xi”. The authors propose thus the
alternative method of computing a dependence matrix J of
size m × n between the j-th, 1 ⩽ j ⩽ m, element of the
digest and i-th, 1 ⩽ i ⩽ n, element of the original message.
A simulation consists in ﬁrst randomly choosing the size n of
the message to hash (100 values in J1, 1000K for us). Next, a
set of large size r (r = 1, 000 in our case) of messages x is
randomly computed. For each of them, the set {x1, . . . , xn}
is formed such that x and xi only differ in bit i. The set of
m-bit vectors
{f(x) ⊕ f(x1), . . . , f(x) ⊕ f(xn)}
is thus computed where f is the hash function applied on
vector of bits. The value of bit i (either a 1 or a 0) in

a complexity that can be expressed as a polynomial function
of the message length and of the digest size. Finally, we have
statistically established that our function veriﬁes the SAC.
If we now consider our approach as an asynchronous itera-
tions post-treatment of an existing hash function. The security
of this hash function is reinforced by the unpredictability
of the behavior of the proposed post-treatment. Thus, the
resulting hash function, a combination between an existing
hash function and asynchronous iterations, satisﬁes important
properties of topological chaos such as sensitivity to initial
conditions, uniform repartition (as a result of the transitivity),
unpredictability, and expansivity. Moreover, its Lyapunov ex-
ponent can be as great as needed. The results expected in our
study have been experimentally checked. The choices made
in this ﬁrst study are simple: initial conditions designed by
using the same ingredients as in the SHA-1, negation function
for the iteration function, etc. But these simple choices have
led to desired results, justifying that such a post-treatment can
possibly improve the security of the inputted hash function.
And, thus, such an approach should be investigated more
largely.
This is why, in future work, we will test other choices of
iteration functions and strategies. We will try to characterize
topologically the diffusion and confusion capabilities. Other
properties induced by topological chaos will be explored and
their interest for the realization of hash functions will be
deepened. Furthermore, other security properties of resistance
and pseudo-randomness will be proven. We will thus compare
the results of this post-treatment on several hash functions,
among other things with the SHA-3 ﬁnalists [21].
ACKNOWLEDGMENT
The authors are grateful to the anonymous reviewers for
their suggestions to improve the quality of the paper.
REFERENCES
[1] J. M. Bahi, J.-F. Couchot, and C. Guyeux, “Performance analysis of a
keyed hash function based on discrete and chaotic proven iterations,”
in INTERNET 2011, the 3-rd International Conference on Evolving
Internet, Luxembourg, Luxembourg, Jun. 2011, pp. 52–57, best paper
award.
[2] J. M. Bahi and C. Guyeux, “Hash functions using chaotic iterations,”
Journal of Algorithms & Computational Technology, vol. 4, no. 2, pp.
167–181, 2010.
[3] X.-M. Wang, J.-S. Zhang, and W.-F. Zhang, “One-way hash function
construction based on the extended chaotic maps switch,” Acta Physica
Sinica, vol. 52, no. 11, pp. 2737–2742, 2003.
[4] D. Xiao, X. Liao, and Y. Wang, “Improving the security of a parallel
keyed hash function based on chaotic maps,” Physics Letters A, vol. 373,
no. 47, pp. 4346–4353, 2009.
[5] ——, “Parallel keyed hash function construction based on chaotic
neural network,” Neurocomputing, vol. 72, no. 10-12, pp. 2288–2296,
2009, lattice Computing and Natural Computing (JCIS 2007) / Neural
Networks in Intelligent Systems Designn (ISDA 2007).
[6] D. Xiao, F. Y. Shih, and X. Liao, “A chaos-based hash function with both
modiﬁcation detection and localization capabilities,” Communications in
Nonlinear Science and Numerical Simulation, vol. 15, no. 9, pp. 2254–
2261, 2010.
[7] Wikipedia, “List of chaotic maps,” Retrieved June, 2012 from http://en.
wikipedia.org/wiki/List_of_chaotic_maps, 2012.
[8] C. song Zhou and T. lun Chen, “Extracting information masked by chaos
and contaminated with noise: Some considerations on the security of
communication approaches using chaos,” Physics Letters A, vol. 234,
no. 6, pp. 429–435, 1997.
[9] W. Guo, X. Wang, D. He, and Y. Cao, “Cryptanalysis on a parallel
keyed hash function based on chaotic maps,” Physics Letters A, vol.
373, no. 36, pp. 3201–3206, 2009.
[10] C. Guyeux, “Le désordre des itérations chaotiques et leur utilité en
sécurité informatique,” Ph.D. dissertation, Université de Franche-Comté,
2010.
[11] J. M. Bahi, J.-F. Couchot, C. Guyeux, and Q. Wang, “Class of
trustworthy pseudo random number generators,” in INTERNET 2011,
the 3-rd International Conference on Evolving Internet, Luxembourg,
Luxembourg, Jun. 2011, pp. 72–77.
[12] J. M. Bahi, J.-F. Couchot, and C. Guyeux, “Steganography: A class of
secure and robust algorithms,” The Computuer Journal, vol. 55, no. 6,
pp. 653–666, 2012.
[13] S. Bakhtiari, R. Safavi-Naini, and J. Pieprzyk, “Keyed hash functions,”
in Cryptography: Policy and Algorithms, ser. Lecture Notes in Computer
Science.
Springer-Verlag, 1996, vol. 1029, pp. 201–214.
[14] D. Coppersmith, “Another birthday attack,” in CRYPTO, ser. Lecture
Notes in Computer Science, H. C. Williams, Ed., vol. 218.
Springer,
1985, pp. 14–17.
[15] A. F. Webster and S. E. Tavares, “On the design of s-boxes,” in Advances
in Cryptology, ser. CRYPTO ’85.
London, UK, UK: Springer-Verlag,
1986, pp. 523–534.
[16] R. L. Devaney, An Introduction to Chaotic Dynamical Systems, 2nd
Edition.
Boulder, CO: Westview Press, March 2003.
[17] C. Knudsen, “Chaos without nonperiodicity,” The American Mathemat-
ical Monthly, vol. 101, pp. 563–565, 1994.
[18] J. M. Bahi, R. Couturier, C. Guyeux, and P.-C. Héam, “Efﬁcient and
cryptographically secure generation of chaotic pseudorandom numbers
on gpu,” CoRR, vol. abs/1112.5239, 2011.
[19] C. Guyeux, N. Friot, and J. Bahi, “Chaotic iterations versus spread-
spectrum: chaos and stego security,” in Sixth International Conference on
Intelligent Information Hiding and Multimedia Signal Processing (IIH-
MSP 2010), Darmstadt, Germany.
Washington, DC: IEEE Computer
Society, Oct. 2010, pp. 208–211.
[20] C. E. Shannon, “Communication theory of secrecy systems,” Bell Sys-
tems Technical Journal, vol. 28, pp. 656–715, 1949.
[21] M. S. Turan, R. Perlner, L. E. Bassham, W. Burr, D. Chang, S. jen
Chang, M. J. Dworkin, J. M. Kelsey, S. Paul, and R. Peralta, “Status
report on the second round of the sha-3 cryptographic hash algorithm
competition,” National Institute of Standards and Technology, Tech.
Rep. NIST Interagency Report 7764, february 2011, retrieved June,
2012 from http://csrc.nist.gov/groups/ST/hash/sha-3/Round2/documents/
Round2_Report_NISTIR_7764.pdf.
33
International Journal on Advances in Internet Technology, vol 5 no 1 & 2, year 2012, http://www.iariajournals.org/internet_technology/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org

