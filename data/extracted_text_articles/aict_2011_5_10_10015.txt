Multi-Stage Threshold Decoding of High Rate
Convolutional Codes for Optical Communications
Muhammad Ahsan Ullah, Ryousuke Omura, Takuma Sato, and Haruo Ogiwara
Department of Electrical Engineering
Nagaoka University of Technology
Kamitomioka-cho, 1603–1
Nagaoka-shi, Niigata-ken, 940–2188, Japan
Email: {ahsan,omura,t-sato}@comm.nagaokaut.ac.jp and ogiwara@vos.nagaokaut.ac.jp
Abstract— For 100 Gb/s optical transport network, researchers
are searching a suitable error correction coding scheme that can
provide coding gain more than 10 dB at the bit error rate less
than 10−12, provided that the redundancy does not exceed 20
percent. This paper presents a least complex error correction
coding scheme based on iterative threshold decoding called multi-
stage threshold decoding with diﬀerence register (MTD) for the
100 Gb/s optical transport network. High rate (code rate 0.8)
self-orthogonal convolutional codes are considered. The MTD
achieves lower bound error performance of maximum likelihood
decoding at higher bit energy to noise density ratio. The codes
with orthogonal checking 10 and larger satisfy the requirements
of 100 Gb/s optical transport network. The bit error rate of MTD
with parity check decoding becomes less than 1/100 times in the
error ﬂoor region compared to ordinary MTD. The MTD based
decoding with parity check decoding for the code with orthogonal
checking 12 produces 10.60 dB coding gain at the bit error rate
10−15. The coding gain further improves 0.25 dB in the waterfall
region by using 2-step decoding.
Keywords-
threshold
decoding,
convolutional
codes,
self-
orthogonal codes, optical transport network.
I. I
Forward error correction codes (FECs) play an important
role in the newly considered optical transport network (OTN)
with network capacity 100 Gb/s. International telecommuni-
cations union (ITU–T) primarily consider the Reed–Solomon
(RS) codes as FEC [1] in the G.975 recommendation. It con-
siders RS(255,239) code with 7% redundancy. The expected
coding gain is 4 to 5 dB per ﬁbre span, but it is not suﬃcient
for 100 Gb/s OTN operation.
There have been a number of proposals for higher gain
FECs; one is iterated code based on (1023,992,8) BCH code
claimed as the best choice as FEC for 100 Gb/s OTN system
that produced the coding gain around 9.3 dB at the output bit
error rate 10−15 [2]. However, more than 10 dB coding gain is
required for the 100 Gb/s OTN system at the output bit error
rate less than 10−12 with the maximum allowable redundancy
20% [3].
Most of the codes proposed as FECs for the 100 Gb/s OTN
system are block codes and their hard decoding technique
is considered. The low density parity check (LDPC) codes
with soft decoding have been adopted for the 10 Gb/s Eth-
ernet (IEEE 803.3an), WiFi (IEEE 802.11n), WiMAX (IEEE
802.16e) wireless LAN standards and are being considered for
a range of application areas, from optical transport network to
digital storage [3][4]. An LDPC code concatenated with RS
code may be the main candidate as FEC for the 100 Gb/s.
However, the convolutional codes for optical communica-
tions are rarely shown as FEC due to their latency and error
ﬂoor [3]. This paper presents a least complex decoding method
for self-orthogonal convolutional codes that can reduce the
decoding latency by parallel processing and improves the error
ﬂoor performance with concatenation of parity check (PC)
decoding that fulﬁlls the requirements of 100 Gb/s optical
transport network. Moreover, implementation of convolutional
encoding is simpler than the encoding of block codes. In
addition, the proposed decoding is mainly based on the several
shift registers and high speed decoding is expected.
The proposed decoding method is an iterative bit ﬂip-
ping decoding based on the threshold decoding [5] called
multi-stage threshold decoding with diﬀerence register (MTD)
which, is treated as MTD-DR in [6]. Similar decoding idea,
called multi threshold decoding, is shown in [7][8]. They
did not show why and how the threshold value changes in
each iterations. Moreover, necessary information to rebuild the
system is absent.
The iterative decoding based on min-sum decoding, instead
of bit ﬂipping, for the self-doubly orthogonal codes is shown
in [9]. The decoding decision depends on the log likelihood
ratio (LLR) of a posteriori probability and updates it after de-
coding each information bit. Moreover, the LLR increases the
decoding complexity. Instead of LLR value, MTD uses a set of
magnitude of the received signals for decoding an information
bit and updates the binary value of the related signals by the
ﬂipping decision. The decoding latency, however, depends on
the span of information shift register in the encoder and the
average number of iterations.
The lower bound of maximum likelihood (ML) decoding
has been presented in [10] and it is seen that, MTD achieves
lower bound of ML decoding performance at higher bit
energy to noise density ratio, Eb/N0. That means, MTD gives
optimum decoding performance of a given code and the error
ﬂoor experiences due to the number of orthogonal checking
of the code. Moreover, if we allow maximum 1.5% more
redundancy by concatenating parity check code, the bit error
performance in the error ﬂoor becomes less than 1/100 times
87
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6
AICT 2011 : The Seventh Advanced International Conference on Telecommunications

compared to conventional MTD.
Lower the orthogonal checking of a code gives better error
performance in the waterfall region. In this context, the 2-step
decoding, 1st decoding step uses a part of parity bit sequences
(lower number of orthogonal checking) and 2nd decoding step
uses all the parity sequences (all the orthogonal checking of the
code), has been presented for rate 1/2 codes and the decoding
scheme produces more coding gain in the waterfall region [10].
Rest of the paper is arranged as follows. Section II gives
the concepts of iterative threshold decoding with diﬀerence
register. In this section, we give soft decoding algorithms.
Section III gives high rate self orthogonal convolutional codes.
Section IV discusses about 2-step decoding that produces
additional coding gain in the waterfall region. Section V gives
an idea for high speed decoding that reduces total decoding
latency. Section VI gives the bit error performance of decoding
schemes. Section VII gives the decoding complexity in terms
of basic operations (e.g., modulo 2 summation, real number
summation, minimum value searching etc.) and compared
with the complexity of min-sum based decoding scheme and
Section VIII concludes this paper.
II. D C
This
section
provides
decoding
algorithms
of
self-
orthogonal convolutional codes (SOCCs) on the basis of
threshold decoding. Soft decoding algorithms are also given.
A. Multi-Stage Threshold Decoding
A systematic SOCC with the rate R=1/2, shift register length
M and the number of orthogonal checking J is considered. The
orthogonal checking is denoted by the tap connection in the
shift register of the encoder and the code is determined by its
connection positions. Let ga, a=1, 2, ..., J, be a tap connection
position in the shift register involving to generate a parity
bit sequence. The minimum Hamming distance (dmin=J + 1)
depends on the orthogonal checking of the codes [11]. The
dotted section in Figure 1 shows an encoder of the SOCC with
R=1/2, M=8, J=3, dmin=J+1=4. The information bit sequence
u={u0, u1, . . .} is fed to the encoder and generates a parity bit
sequence v={v0, v1, . . .}. The i-th parity bit is determined by
vi =
J
X
a=1
⊕ ui−ga, i = 0, 1, . . .
(1)
where ⊕ is the modulo-2 addition operator in this paper. The
information and the parity bit sequences make a systematic
codeword and is transmitted through the additive white Gaus-
sian noise (AWGN) channel as BPSK signals. The tail biting
termination is used.
Let yu ≜ {yu
0, yu
1, . . .} be received information signals, yv ≜
{yv
0, yv
1, . . .} be received parity signals, ˜u ≜ {˜u0, ˜u1, . . .} be hard
decision information bits and ˜v ≜ {˜v0, ˜v1, . . .} be hard decision
parity bits. The threshold decoding generates a syndrome bit
sequence by the help of received information and parity bit
sequences. The i-th syndrome bit is given by
si = ˜vi ⊕
J
X
a=1
⊕ ˜ui−ga
(2)
CSE
CSE
diﬀerence register
information register
syndrome register encoder
˜u7 ˜u6 ˜u5 ˜u4 ˜u3 ˜u2 ˜u1 ˜u0
..˜u8
s7 s6 s5 s4 s3 s2 s1 s0
..s8
d7 d6 d5 d4 d3 d2 d1 d0
..d8
..˜v8
Fig. 1.
Multi-stage threshold decoder for the Self-orthogonal convolutional
code with m=n=1, J=3, M=8 and R=1/2. CSE means checksum-threshold
element.
Figure 1 shows a hard decision multi-stage threshold de-
coding scheme. The decoder contains an extra shift register
against an information shift register called diﬀerence register
(DR). The DR holds pairwise diﬀerence between the received
and decoded information bits. At the initial stage, DR contains
all zero bits.
The soft decoding MTD (SMTD) calculates the checksum
value from a set of the magnitude of parity signals related to
the information signal under decoding and the magnitude of
the information signal itself [6]. In this case, the checksum
value L j is calculates by
Lj =
J
X
a=1
wj+ga ˜xv
j+ga + wd j ˜xu
j
(3)
where wk represents the magnitude of the signal yv
k and
wdk represents the magnitude of the signal yu
k and the value
˜xu
k ≜(1-2dk) and the value ˜xv
k ≜(1-2sk). If the checksum value
becomes negative, i.e., Lj < 0, the decoding is done by
ﬂipping the information bit. At the same time, related DR and
syndrome bits are inverted. After ﬂipping each information bit,
the Euclidean distance between the received signals and the
decoded codeword, where bits are represented by +1 or -1,
becomes shorter [6].
B. Weighted Bit Flipping Multi-Stage Threshold Decoding
The weighted bit ﬂipping (WBF) algorithm is proposed for
decoding low density parity check (LDPC) codes [12]. By the
similar way, the weighted bit ﬂipping MTD (WMTD) explores
the value wk as the minimum magnitude among the received
signals related to the syndrome bit sk. Then, the checksum
value is calculated by using (3) and the decoding decision is
made accordingly.
C. Combined Soft Decoding Multi-Stage Threshold Decoding
with Feedback
The individual error performance of SMTD and WMTD
is not attractive. The concatenation of WMTD and SMTD
called combined soft decoding MTD with feedback (CMTDF)
produces attractive error performance. Figure 2 shows the
schematic diagram of CMTDF where weighted bit ﬂipping
MTD works ﬁrst and terminates its decoding when no infor-
mation bit is ﬂipped or by the maximum number of iterations.
Then SMTD works by the same manner and feedback again.
88
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6
AICT 2011 : The Seventh Advanced International Conference on Telecommunications

WMTD
SMTD
input
output
PC
Fig. 2.
Schematic diagram of combined soft decoding multi-stage threshold
decoding.
u1
u2
u3
u4
v
Fig. 3.
Self-orthogonal convolutional code type 1 with m=4, J=3, M=12
and code rate R=4/5=80%.
If no information bit is ﬂipped in both component decoders
or completed maximum number of iterations, ﬁnal output is
made.
D. Combined Soft Decoding Multi-Stage Threshold Decoding
with Parity Check Decoding
A parity check decoding is serially concatenated with
CMTDF. The CMTDF with parity check (PC) decoding
achieves attractive bit error performance in the error ﬂoor
region [6]. The PC encoder adds a parity check bit in the
information bit stream after each n1 bits. When parity check
is not satisﬁed, the PC decoder searches the minimum absolute
checksum value, provided by the CMTDF after the ﬁnal
iteration, related to each n1 information bits. The decoding is
done by ﬂipping the information bit related to the minimum
absolute checksum value. In this paper n1 is set to 50 bits.
III. H R S-O C 
This section gives high rate (code rate 80%) SOCCs that can
produce redundancy around 20%. The SOCC is categorized
into two types: 1) the self-orthogonal convolutional codes type
1 and 2) the self-orthogonal convolutional codes type 2 [6].
A. Self-Orthogonal Convolutional Code Type 1
The self-orthogonal convolutional code type 1 (SOCC:TP1)
generates only one parity bit sequence by using m ≥ 1 infor-
mation bit sequences. That means, the encoder of SOCC:TP1
has m information shift registers and each shift register
contains one set of tap connection with Jk (k = 1, 2, ..., m)
elements and the m tap connection sets make a SOCC. The
orthogonal checking distribution of this code is deﬁned by
{J1; J2; . . . ; Jm}. Figure 3 shows an encoder of such code with
m=4, J = J1 = J2 = J3 = J4 = 3 and the shift register
length M=12. The code rate of this code is R=m/(m + 1)
and the code length becomes N=K(m + 1), where K is the
number of information bits in each sequence. The orthogonal
checking distribution of this code is {3; 3; 3; 3}. Unfortunately,
MTD makes an unavoidable error grouping in the decoded
information bit sequences for this type of code and degrades
the error performance [6].
B. Self-Orthogonal Convolutional Code Type 2
The self-orthogonal convolutional code type 2 (SOCC:TP2)
generates n ≥ 2 parity bit sequences by using m ≥ 1
information bit sequences. i.e., an encoder of SOCC:TP2 has
m information shift registers and each shift register contains
n tap connection sets with J(k)
p
(k = 1, 2, ..., m, p = 1, 2, ..., n)
elements and the m × n tap connection sets make the SOCC.
The orthogonal checking distribution of the code is deﬁned
by
{J(1)
1 , J(1)
2 , ..., J(1)
n ; J(2)
1 , J(2)
2 , ..., J(2)
n ; ...; J(m)
1 , J(m)
2 , ..., J(m)
n }.
Figure 4 shows an encoder of SOCC:TP2 with m=12,
n = 3, J = P3
p=1 J(k)
p
= 2 + 2 + 2 = 6 and the shift register
length M=12. The code rate of this code is R=m/(m + n)=
12/15. The orthogonal checking distribution of this code is
{2, 2, 2; 2, 2, 2; 2, 2, 2; 2, 2, 2; 2, 2, 2; 2, 2, 2; 2, 2, 2; 2, 2, 2; 2, 2, 2;-
2, 2, 2; 2, 2, 2; 2, 2, 2}. The SOCC:TP2 successfully breaks
down the error groping and produces better error performance
by the MTD compared to the SOCC:TP1 [6]. Therefore, this
paper only consider the SOCC:TP2 for the encoding schemes.
IV. 2-S D
As is described in Section VI, MTD based decoding
achieves lower bound of ML decoding performance at higher
Eb/N0. That means, error ﬂoor is realized due to the minimum
Hamming distance (J + 1) of the code. On the other hand,
larger the J of a code shifts the waterfall error performance to
higher Eb/N0 and opposite situation is occurred due to smaller
J value [6]. In this context, a 2-step decoding (2SD) has been
proposed [10]. At the 1st decoding step, MTD uses a part of
parity check bits so that decoding is done by approximately
50% of J of the code and the 2nd decoding step works just
like an MTD. The code is constructed such a way that, one
parity sequence is to be generated by approximately Js ≈ J/2
orthogonal checking. Other J − Js orthogonal checking are
distributed evenly for generating rest of the parity sequences.
The 1st decoding does not use a parity sequence which, is
generated by the Js orthogonal checking. MTD works with
the orthogonal checking J − Js in the 1st decoding step and
produces additional coding gain in the waterfall region. The
2nd decoding step then works by the all parity sequences.
In this case, decoding is done by the J orthogonal checking.
By this way of decoding, 0.55 dB additional coding gain is
observed for the code with rate 1/2 [10]. In this paper we
apply this idea for the codes with rate around 80%.
V. H S D
This section gives an idea of parallel processing that speeds
up the decoding process. Since, tail biting termination is used,
the decoding can start from any position of the received
89
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6
AICT 2011 : The Seventh Advanced International Conference on Telecommunications

u1
u2
u3
u4
u5
u6
u7
u8
u9
u10
u11
u12
v1
v2
v3
Fig. 4.
Self-orthogonal convolutional code type 2 with m=12, n=3, J=6, M=12 and code rate R=12/15=80%.
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
..
diﬀerence register
information register
syndrome register
CSE1
CSE2
˜u1
˜u0
˜u19
s1
s0
s3
s7
s4
s8
s19
d1
d0
d19
CSE: Checksum-threshold element
Fig. 5.
Parallel processing of MTD with two checksum-threshold elements. The code with m=n=1, J=3, M=8, R=1/2 and code length N=40.
information sequence. If any syndrome is not commonly
shared to decode other information bit, decoding can take
place in parallel. Among the M positions in the shift register,
only J points are involved to decode an information bit.
When the minimum tap spacing (tap position diﬀerence in
the syndrome register) is more than one, MTD can add
more than one checksum-threshold elements (CSEs) where
diﬀerent CSE decodes diﬀerent information bit at the same
time. Figure 5 shows a simple example of such decoding
scheme for a code with the minimum spacing 3 and two CSEs
are shown. For this code, total 3 bits are decoded by the single
period of shift register clock. In addition, to reduce the error
propagation eﬀect, it is necessary to use information bit length
around twice of shift register length [13]. The length of the
information bit stream is more than two times (20 bits in this
example) of M = 8 value. Therefore, we have possibility to
use another set of CSE with 3 elements in the decoding circuit
and the decoding is done 6 times faster compared to the single
CSE decoding scheme.
VI. P  C S D M-S
T D  2-S D
Simulation results and ML decoding performance of the
codes are presented in this section. In this case, channel is
considered as AWGN and the data modulation is considered as
BPSK. Before going to show the error performance, CMTDF
with parity check (PC) decoding performance is estimated by
using the lower bound of ML decoding of SOCCs and the
simulation results of them with PC decoding.
90
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6
AICT 2011 : The Seventh Advanced International Conference on Telecommunications

TABLE I
S-    2    R=1/2.
Code
# of shift
orthogonal checking
par-
register
distribution
ameter
m
n
J=10
2
2
{5, 5; 5, 5}
M = 104
J=10
5
5
{2, 1, 1, 1, 5; 1, 2, 1, 1, 5; 1, 1, 2, 1, 5;
M = 1000
1, 1, 1, 2, 5; 2, 1, 1, 1, 5}
J=12
6
6
{1, 1, 1, 1, 2, 6; 1, 1, 1, 2, 1, 6;
1, 1, 1, 2, 1, 1, 6; 1, 2, 1, 1, 1, 6;
M = 1000
2, 1, 1, 1, 1, 6; 1, 1, 1, 1, 2, 6}
TABLE II
S-    2    R=4/5.
Code
# of shift
orthogonal checking
par-
register
distribution
ameter
m
n
J=8
8
2
{4, 4; 4, 4; 4, 4; 4, 4; 4, 4; 4, 4;
M = 5000
4, 4; 4, 4}
J=10
8
2
{5, 5; 5, 5; 5, 5; 5, 5; 5, 5; 5, 5;
M = 5000
5, 5; 5, 5}
J=12
8
2
{6, 6; 6, 6; 6, 6; 6, 6; 6, 6; 6, 6;
M = 5000
6, 6; 6, 6}
J=10
12
3
{2, 2, 6; 2, 2, 6; 2, 2, 6; 2, 2, 6;
2, 2, 6; 2, 2, 6; 2, 2, 6; 2, 2, 6;
M=4000
2, 2, 6; 2, 2, 6; 2, 2, 6; 2, 2, 6}
The lower bound of bit error rate of ML decoding is
calculated for the self-orthogonal convolutional code with the
orthogonal checking J by [10]
Pb ⪆ Q

r
2R(J + 1)Eb
N0

(4)
where Q(x) ≜
1
√
2π
R ∞
x e− y2
2 dy and Pb is the bit error rate of
the ML decoding scheme.
Figure 6 shows simulation results of CMTDF for the
code with J=10, m=n=2, M=10000, R=1/2, the code length
N=81600 and the minimum tap spacing 35 bits. The orthogo-
nal checking distribution of the code is shown in Table I. The
dashed line represents the lower bound of ML decoding result
of the code. The error performance of CMTDF coincides with
the lower bound of ML decoding performance in the error
ﬂoor region. The CMTDF concatenated with PC decoding
makes the BER less than 1/100 times of the lower bound
of ML decoding of the SOCC without PC decoding in the
error ﬂoor region. Simulation results of the 2SD are shown
in Figure 7 for the codes with J=10 and 12, M=1000,
R=5/10=6/12=1/2, the code length N=81600. The orthogonal
checking distribution of codes are shown in Table I. The
minimum tap spacing are 4 and 2 for the codes with J=10
and 12, respectively. The 2SD decoding also achieves lower
bound of ML decoding performance for the codes. The 2SD
with parity check decoding makes also the BER less than
1/100 times of the lower bound of ML decoding for the code
without parity check decoding in the error ﬂoor region. From
these observations, we expect that, the MTD based decoding
with parity check decoding can achieve 1/100 times bit error
rate of lower bound of ML decoding (without PC decoding) in
1
2
3
4
10−8
10−6
10−4
10−2
100
BER
Eb/N0 [dB]
CMTDF, J=10
CMTDF, J=10, PC
10−2
ML, J=10
PC, J=10
Fig. 6.
Bit error performance of CMTDF for the SOCC type 2 with m=2,
n=2, J=10, M=10000, R=2/4 and code length N=81600. Code is in Table I.
2
3
10−8
10−6
10−4
10−2
Eb/N0 [dB]
BER
ML, J=10
ML, J=12
J=10,PC
J=12,PC
10−2
10−2
2SD,J=10
2SD,J=10,PC
2SD,J=12
2SD,J=12,PC
Fig. 7.
Bit error performance of 2SD for the SOCC type 2 with m=n=5
for J=10 and m=n=6 for J=12, M=1000, R=5/10=6/12=1/2 and code length
N=81600. Code is in Table I.
the error ﬂoor region. This result will be applied for estimating
the bit error rate of MTD based decoding with PC decoding
at the BER below 10−12.
Figure 8 shows the bit error performance of CMTDF for the
SOCC:TP2 with the code rate R=8/10=4/5, m=8 and n=2. The
shift register length is M=5000 each. The ﬁgure shows the bit
error performance for the codes with J=8, 10 and 12 and the
minimum tap spacing are 2, 5 and 5, respectively. CMTDF
for the codes with rate 80% also achieves the lower bound
of ML decoding performance at higher Eb/N0. The dotted
line connected to the simulation result is the extrapolation of
91
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6
AICT 2011 : The Seventh Advanced International Conference on Telecommunications

3
4
5
10−15
10−10
10−5
Eb/N0 [dB]
BER
ML, J=8
ML, J=10
ML, J=12
CMTDF, J=8
CMTDF, J=10
CMTDF, J=12
Extrapolation
Fig. 8.
Bit error performance of CMTDF for the SOCC type 2 with m=8,
n=2, M=5000, R=4/5 and code length N=105060. Codes are in Table II.
the error performance up to lower bound line, because this
performance is expected. The codes with J=8 gives better
performance in the waterfall compared to the other codes,
but the error ﬂoor is degraded. The 100 Gb/s OTN system
demands at least 10 dB coding gain at the bit error rate less
than 10−12. The CMTDF for the code with J=10 achieves
coding gain 9.0 dB at the BER 10−10. For the code with
J=12, CMTDF produces the coding gain 9.96 dB at the BER
10−13 and 10.20 dB at the BER 10−15. In this point, the
CMTDF for the SOCC:TP2 with J=12 is eﬀective for 100
Gb/s OTN system. The decoding scheme uses average number
of iterations (summation of the average iterations uses by the
WMTD and by the SMTD) 23 at Eb/N0=4.8 dB for the code
with J=12.
Figure 9 shows the bit error performance of CMTDF with
parity check decoding for the same codes mentioned in the
Figure 8. The estimated error performance of CMTDF with
PC decoding is shown by the dashed line with mark ‘PC’
in the ﬁgure. With the PC decoding, CMTDF for the codes
with J=10 produces the bit error rate 10−13 and achieves
the coding gain 10.10 dB. In this case, average number of
iterations is 19.6 at Eb/N0=4.8 dB. The code with J=10 with
parity check decoding satisﬁes the requirement of 100 Gb/s
OTN system. The overall code rate, in this case, is 78.43%.
The same decoding scheme is used for the code with J=12.
The decoding scheme achieves coding gain 10.60 dB at the
BER 10−15 and 23 average number of iterations is used at
Eb/N0=4.8 dB.
Although CMTDF already realizes the lower bound of ML
decoding performance in the error ﬂoor, we have opportunity
to improve error performance in the waterfall region. The 2SD
can produce some extra coding gain in the waterfall region.
Figure 10 shows the bit error performance of 2SD for the codes
with m=12, n=3, J=10 and shift register length M=4000. The
3
4
5
10−16
10−12
10−8
10−4
Eb/N0 [dB]
BER
PC, J=8
PC, J=10
PC, J=12
CMTDF, J=8,PC
CMTDF, J=10,PC
CMTDF, J=12,PC
PC, Extrapolation
Fig. 9.
Bit error performance of CMTDF with PC decoding for the SOCC
type 2 of m=8, n=2, M=5000, R=4/5 and code length N=105060. Codes are
in Table II.
3
3.5
4
4.5
10−15
10−10
10−5
Eb/N0 [dB]
BER
ML, J=10
PC, J=10
2SD, J−2−2−6
CMTDF, J=10
CMTDF, J=10, PC
Extrapolation
2SD, J−2−2−6, PC
Fig. 10.
Bit error performance of CMTDF and 2SD with and without PC
decoding for the SOCC type 2 (m=12, n=3) in Table II. The code length is
130050.
code parameters are shown in Table II. This code provides
the code rate R=12/15=4/5 and the minimum tap spacing
is 4. Figure 10 also shows the comparison of the error
performance between CMTDF and 2SD. Their performance
with PC decoding is also given. The 2SD for the SOCC:TP2
with the code rate 80% produces additional coding gain 0.25
dB compared to CMTDF. The 2SD with PC decoding for the
code achieves coding gain 10 dB at the BER 10−12 and 10.20
dB at the BER 10−13. The 2SD uses 90 average number of
iterations at Eb/N0=4.2 dB and it is expected to decrease at
92
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6
AICT 2011 : The Seventh Advanced International Conference on Telecommunications

larger Eb/N0. The 2SD with parity check for the code with
J=10 satisfy the demands of 100 Gb/s OTN system. Moreover,
the high speed decoding scheme can reduce the total decoding
delay.
The Viterbi and the forward-backward (Bahl, Cocke, Je-
linek, Raviv) algorithms gives the ML decoding of con-
volutional codes. They use trellis states of the code. The
algorithms are suitable for the code with constraint length
less than 20. The proposed decoding scheme handles a large
constraint length (more than 1000) code. Thats why it is not
comparable with them. However, min-sum decoding based
iterative decoding has been shown in [9]. The CMTDF for the
SOCC with rate 1/2 gives the similar decoding performance
[6] of min-sum based decoding. So, it is expected that the
proposed decoding scheme with high rate code also achieves
similar performance with the min-sum decoding.
VII. D C
Table III shows the decoding complexity in terms of basic
operations, e.g., modulo 2 summation, real number summa-
tion, etc. Decoding complexity is deﬁned by the total number
of operations necessary to decode an information bit. The
decoding complexity of min-sum based decoding is calculated
in terms of add-min operations [9] which, can be broken
down to J + 1 modulo 2 summation and J minimum weight
search operations for decoding each information bit. Let,
the 2SD uses (I1, I2) and the min-sum based decoding uses
Itr average number of iterations, respectively, then Table III
summarizes the decoding complexity of 2SD and min-sum
based decoding. Here I1 is the average number of iterations
used in 1st decoding step and I2 is the average number of
iterations used in ﬁnal step of decoding for 2SD.
TABLE III
D   2-   -  D.
Name of
Number of operations necessary
operations
for decoding each information bit
2-step decoding
min-sum based decoding [9]
Modulo 2
≤ J2 + (I1 + I2)(J + 2)
≥ Itr(J3 + 2J2 − J − 2)/2
summation
Min. weight
J(J + 1)
Itr(J3 + J2 − 2J)/2
search
Real number
I1(J − Js) + I2J
ItrJ
summation
The complexity of the proposed decoding scheme depends
on the J2 operations of modulo 2 summation and minimum
weight searching where the min-sum based decoding con-
sumes J3 operations in the same domain. Therefore, the pro-
posed decoding method uses less number of basic operations
than the decoding method given in [9].
VIII. C
This paper focuses on the forward error correction coding
for the 100 Gb/s optical transport network. The optical trans-
port network demands more than 10 dB coding gain at the
BER less than 10−12 by allowable coding rate more than 80%.
Most of the FECs proposed for the network are hard decoding
based block code. This paper has presented a kind of soft deci-
sion bit ﬂipping decoding using self-orthogonal convolutional
codes. The decoding scheme is iterative threshold decoding
called MTD that uses the magnitudes of received signals
for making decoding decision. The combined soft decoding
MTD with feedback (CMTDF) produces lower bound error
performance of ML decoding. The CMTDF for the code with
J=12 produces the coding gain 10.20 dB with rate R=0.8 at
the BER 10−15. It is eﬀective for 100 Gb/s OTN system. When
the code contains extra redundancy (not more than 1.5%) due
to parity check bits, the 2SD with PC decoding makes the
bit error rate 1/100 times compared to the bit error rate of
2SD for the code without extra redundancy. In this case, the
code with J=12 be the best choice for the OTN, because it
achieves 10.60 dB coding gain at the BER 10−15. Although
CMTDF already produces the lower bound of ML decoding
error performance, we have possibility to acquire more coding
gain in the waterfall region. The 2SD decoding can do this.
The 2SD produces 0.25 dB more coding gain compared to
CMTDF for the codes with rate 0.8. The 2SD with parity
check decoding for the SOCC with J = 10 achieves 10 dB
coding gain at the BER 10−12 and 10.20 dB at the BER 10−13.
The SOCC of J=10 concatenated with parity check code will
be another candidate of FECs for the 100 Gb/s OTN system.
Moreover, the proposed decoding scheme is less complex than
the min-sum based decoding scheme. However, it is expected
that, the 2SD for the code with larger orthogonal number
produces more coding gain at the bit error rate less than 10−15.
Unfortunately, ﬁnding such codes with limited span of shift
register is an open problem.
R
[1] ITU–T, Rec. G.975, “Forward error correction for submarine systems,”
Nov. 1996.
[2] J. Justesen, K. J. Larsen and L. A. Pedersen, “Error correcting coding
for OTN,” IEEE Comm. Magazine, vol. 48, no. 9, pp. 70–75, Sep. 2010.
[3] F. Chang, K. Onohara and T. Mizuochi, “Forward error correction for
100 G transport networks,” IEEE Comm. Magazine, vol. 48, no. 3, pp.
s48–s55, Mar. 2010.
[4] S. J. Johnson, Iterative Error Correction: Turbo, Low-Density Parity-
Check and Repeat-Accumulate Codes, Cambridge University Press, First
Ed., 2010.
[5] J. Massey, Threshold Decoding, MIT Press, 1963.
[6] M. A. Ullah, K. Okada, and H. Ogiwara, “Multi-stage threshold decod-
ing for self-orthogonal convolutional codes,” IEICE Trans. Fundamen-
tals, vol. E93-A, no. 11, pp. 1932–1941, Nov. 2010.
[7] V. V. Zolotarev, G. V. Ovechkin, “An eﬀective algorithm of noiseproof
coding for digital communication systems,” Electrosvaz, no. 9, pp. 34–
36, 2003.
[8] http://www.mtdbest.iki.rssi.ru/ (the last access date: Jan. 06, 2011).
[9] C. Cardinal, D. Haccoun, F. Gagnon, “Iterative threshold decoding
without interleaving for convolutional self-doubly orthogonal codes,”
IEEE Trans. Commn., vol. 51, no. 8, pp. 1274–1282, Aug. 2003.
[10] M. A. Ullah and H. Ogiwara, “Performance improvement of multi-stage
threshold decoding with diﬀerence register,” IEICE Trans. Fundamen-
tals, unpublished.
[11] S. Lin, D.J. Costello, Jr., Error Control Coding: Fundamentals and
Applications, Prentice-Hall, Inc. Englewood Cliﬀs, N. J., 1983.
[12] Y. Kou, S. Lin, and M. P. C. Fossorier, “Low-density parity-check codes
based on ﬁnite geometries: a rediscovery and new results,” IEEE Trans.
Inform. Theory, vol. 47, no. 7, pp. 2711–2736, Nov. 2001.
[13] J. P. Robinson, “Error propagation and deﬁnite decoding of convolutional
codes,” IEEE Trans. Inform. Theory, vol. IT-14, no. 1, pp. 121–128, Jan.
1968.
93
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-123-6
AICT 2011 : The Seventh Advanced International Conference on Telecommunications

