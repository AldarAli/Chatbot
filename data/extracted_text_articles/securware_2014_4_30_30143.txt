Enforcing Security Policies on Choreographed Services using Rewriting Techniques
Karim Dahmani
karim.dahmani@fst.rnu.tn
Mahjoub Langar
mahjoub.langar@ift.ulaval.ca
LIP2 Research Laboratory
Faculté des Sciences de Tunis
Tunis, Tunisia
Abstract—This paper presents an automated formal approach
for  enforcing  security  policies  on  a  choreography  of  Web
Services.  We  take  as  input  a  formal  description  of  a
choreography  of  web  services  and  a  security  property
represented by a process, then we define some rewriting rules
and  rewrite  the  two  processes  in  order  to  make  them
synchronize  on  each  communication  action.  This  approach
produces as output  a secure  version  of the  concerned  web
service which behaves like the original one but does not violate
the security property.
Keywords-Web
 
Service
 
Composition
 
Security;
Instrumentation;  Choreography;  Formal  Verification;  End-
Point Calculus.
I.
 INTRODUCTION
Web  Services  (WS)  are  distributed  and  modular
applications that communicate by message passing in order
to complete specific activities. Composition of WS consists
in combining different WS to provide value-added services.
WS composition rules deal with how different services are
composed into a coherent global service. In particular, they
specify the order in which services are invoked, and the
conditions under which a certain service may or may not be
invoked.  Among  the  approaches  investigated  in  service
composition, we distinguish orchestration and choreography.
The orchestration composes available services and adds a
central coordinator (the orchestrater) which is responsible for
invoking and composing the single sub-activities. However
the second one, referred to as WS choreography, does not
assume the exploitation of a central coordinator but rather
defines complex tasks via the definition of the conversation
that  should  be  undertaken  by  each  participant.  Several
proposals exist for orchestration and choreography languages
such as Business Process Execution Language (BPEL) [1]
for  orchestration  and  Web  Service  Choreography
Description  Language  (WS-CDL)  [2]  for  choreography.
Since the orchestration technique uses a central coordinator
that  composes  the  available  services,  it  seems  trivial  to
enforce security policies. So the technique that will be used
in this paper for composing WS is the choreography. One of
the main challenges for researchers in this domain is the
formalization  of  these  composition  languages.  Although,
several contributions have been developed in the last decade
that formalize WS-CDL such as the Global Calculus (GC)
and the End-Point Calculus (EPC) proposed by Carbone et
al. [3], the Choreography Language proposed by N. Busi et
al. [4], The Choreography Description Language proposed
by H. Yang et al. [12] and timed automata proposed by G.
Diaz et al. [5]. The formal specification language used in this
paper is the End-Point Calculus that has been introduced by
Carbone et al. [3]. One of the reasons behind this choice is
that the end-point calculus is a modified version of the pi-
calculus, so its syntax is more familiar and its expressivity is
stronger.
The need of secure WS composition has led to a great
interest from researchers in the last decade. In this paper, we
propose an automated formal approach for the enforcement
of security policies on choreographed services. We take as
input a formal description of the behavior of a participant in
a choreography and a security property. We define rewriting
rules  for  adding  some  special  actions  to  processes  and
security properties in order to ensure synchronization and
consequently  control  the  evolution  of the  behavior  of a
participant.
This  paper  is  structured  as  follows:  in  Section  II,  we
introduce the choreography specification language used in
this topic. In Section III we present the security property
specification  language.  Section  IV  deals  with  the
enforcement approach. The proof of this approach is given in
Section V. Related work is in Section VI and conclusion and
future work are in Section VII.
II.
CHOREOGRAPHY SPECIFICATION LANGUAGE
Carbone et al. [3] have proposed a formal language for
specifying a choreography of WS. This language is the GC.
It describes behaviors of WS from a global viewpoint. GC is
distilled  from  WS-CDL.  Carbone  et  al.  [3]  have  also
proposed  a  second  formal  language:  the  EPC,  which
specifies behaviors of WS from a local viewpoint. Finally, a
projection under some assumptions from GC to EPC have
been proposed by Carbone et al. [3], which is called the End-
Point Projection (EPP). The language adapted in this paper
for formally specifying processes and security properties is
EPC.
A.
Syntax of the End-Point Calculus
EPC  describes  the  behavior  of  each  participant  in  the
choreography from its end-point view. EPC is a variant of
the pi-calculus augmented with the notion of participants
and their local states. We present hereafter the syntax and
formal semantics of EPC where P,Q range over processes,
ch range  over  service  channels,  s range  over  session
channels,  opi range  over  operator  names,  x range  over
89
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-376-6
SECURWARE 2014 : The Eighth International Conference on Emerging Security Information, Systems and Technologies

variables, e range over expressions and  X range over term
variables.
P::=!ch(̃s). P∣ch(ν ̃s). P∣ s▹Σiopi(xi). Pi
∣ s◃op(e).P ∣ x :=e.P∣ P⊕Q∣ P∣Q
∣if e then P else Q ∣(ν s)P
∣rec X.P ∣0
•
!ch(̃s). P
and  
ch(ν ̃s). P
 represent session
initiation.  
!ch(̃s). P
 is  used  for  input  and
ch(ν ̃s). P
 for output.  
!ch(̃s). P
 says that
the service channel ch, which is available to public,
is  ready  to  receive  an  unbounded  number  of
invocations,  offering  a  communication  via  its
freshly  generated  session  channels  
s∈ ̃s.
ch(ν ̃s). P
 is an invocation of a service located
at the service channel  ch and an initiation of a
communication  session  that  will  occur  through
session channels 
s∈ ̃s.
 After a session has been
initiated  between  two  participants  and  freshly
generated  session  channels  have  been  shared
between  them,  they  can  communicate  via  these
channels using the communication constructs.
•
s▹Σiopi(xi). Pi
 is an offer of one of operators
opi
 and a reception of an expression e through
the session channel  s that will be evaluated and
stored in the local variable x. A participant having
this behavior will receive an invocation of one of
its operator names 
opi
 and an expression e. The
value of e is saved in its local variable x. 
For  instance,  a  seller  service  receives  a
confirmation  or  a  cancellation  for  a  purchase  :
s▹confirmPurchase(x1). P
+s▹cancelPurchase(x2).0
•
s◃op(e).P
 sends the expression e and invokes
operator op through the session channel s. Indeed,
a  buyer  service  requests   a  quote  of a  chosen
product  from  a  seller  through  the  channel  s:
s◃quoteRequest(e product). P
 
In  addition,  operator  names  
op1,op2,...
 are
invoked  by  a  message  sender  or  offered  by  a
message  receiver.  Operator  names  in  in-session
communications  are  analogous  to  methods  in
objects [3].
•
x :=e.P
 is the assignment operator. It is a local
operation. It assigns the result of the evaluation of 
the expression e to the variable x. For example, the 
buyer assigns to its variable x the value of the 
quote received from the seller : 
xquote:=equote .P
•
if e then P else Q
 is a choice based  on the
evaluation  of  the  boolean  expression  e.  For
example, the buyer accepts the quote if it is under
1000 
 
 
 
if equote<1000 then s◃accept(equote). P
else s◃reject(equote).0
•
P⊕Q
is the non deterministic choice. When the
choice of the buyer is arbitrary, it would be written
as: 
s◃accept(equote). P⊕s◃reject(equote).0
•
P∣Q
is the parallel composition of processes.
For example,  a  seller  that  offers  his  service  to
buyers should have his service running in parallel
for  new  requesters  
!chseller (s).P∣P '∣P' '∣...
where P',P'',... are processes dealing with different
buyers.
•
(ν s)P
expresses  the  fact  that  the  session
channel  s is local to  P. It is  used  to  restrict a
session  channel  to  be  used  between  only  two
participants that communicate through it.
•
rec X.P
is  the  recursion  operator  used  to
express  repetitive  behaviors.  For  example,  a
participant  having  the  following  behavior  will
always  request  quotes  until  he  receives  an
acceptation
rec X. s◃quoteRequest(e).
s▹accept.P⊕s▹reject.X
.
•
Finally, 
0
 is the inaction.
Processes are located within participants. Participants and
their  composition  are  called  Networks  (written  N,M,...),
whose grammar is given by:
N ::=A[ P]σ∣ N∣M ∣(ν s)N ∣ǫ
.
For more details about the syntax of EPC, the reader can
refer to [3].
B.
Semantics of the End-Point Calculus
In order to minimize the number of reduction rules, we
define
≡
as the least congruence generated from:
P∣0≡P
P∣Q≡Q∣P
(P∣Q)∣R≡P∣(Q∣R)
P⊕P≡P
P⊕Q≡Q⊕P
(P⊕Q)⊕R≡P⊕(Q⊕R)
(ν s)0≡0
(ν s1)(ν s2)P≡(ν s2)(ν s1)P
((ν s) P)∣Q≡(ν s)(P∣Q) (s∉ fn(Q))
A[P]σ≡A[Q]σ (P≡Q)
A[(ν s) P]σ≡(ν s)( A[P]σ)
M∣ǫ≡M
M∣N ≡N∣M
(M ∣N )∣L≡M∣(N∣L)
(ν s)ǫ≡ǫ
(ν s1)(ν s2)M ≡(ν s2)(ν s1)M
((ν s)M )∣N ≡(ν s)(M∣N ) (s∉ fn(N ))
The operational semantics of EPC are given in Figure 1.
•
Init shows how two participants initiate a session by
sharing  new  freshly  generated  session  channels
̃s.
  These  session  channels  are  restricted  to
participants  A and  B using  the binding  operator
ν
.
90
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-376-6
SECURWARE 2014 : The Eighth International Conference on Emerging Security Information, Systems and Technologies

•
Comm  explains  how  a  communication  is
established  between  two  participants:  when  B
invokes the operator  
op j
, which is offered by
A, and sends the expression 
e j
, which will be
evaluated to value  v at  A, then  A receives it and
assigns v to its local variable 
x j.
•
Assign  is  a  local  operation.  Assignment  rule
evaluates an expression e and assigns the result of
this evaluation to variable x in A, then A behaves as
P.
•
IfThenElse evaluates the boolean expression e and
following the result of this evaluation, it behaves
either as 
P1
 or 
P2.
•
Par  shows  the  behavior  of  two  concurrent
processes. 
•
Sum shows the alternative choice behavior.
•
Rec says that if the process  P, within which we
replace  each  occurrence  of  X by  
rec X.P
,
behaves as P' then
rec X.P
will behave as P'.
•
Res restricts the use of session channels  ̃s
 to
the process P in A.
Finally, the following rule says we take the reductions up to
the structural rule:
M ≡M ' M ' → N '
N ' ≡N
M → N
Struct NW
C.
Example
We consider a simplified  version  of a travel reservation
system. The scenario consists of three participants: a traveler,
a travel agent and an airline reservation system. The traveler
is planning for taking a trip. Once the traveler selects a trip,
he submits his choice to the travel agent. The travel agent
checks for seats availability within the airline reservation
system and sends back either a trip cancel or a validation.
The traveler wants to reserve tickets for this trip by sending
payment details to the travel agent. The travel agent now
must verify one more time availability of seats. If the seats
are still available then the airline reservation system accepts
the payment details and sends back to the travel agent tickets
of the trip. The travel agent responds to the traveler either by
tickets of the trip or by canceling the reservation.
The behavior of the traveler is given in EPC by:
chTA(νs).s▹ack.s◃orderTrip(e1).
s▹cancel.0⊕s▹available(x1).s◃book(e2).
s▹cancelBook.0⊕s▹tickets( x2).0
The traveler starts by opening a session with the travel agent
through the public service channel  
chTA
 and initiates a
communication channel s through which the communication
between the traveler and the travel agent will occur. Then,
the traveler receives through s an acknowledgment message
s▹ack
.  After  that,  the  traveler  sends  an  order  trip
s◃orderTrip(e1)
 with expression 
e1
 which contains
details about the chosen trip. At this point, there are two
scenarios:  the  traveler  either  receives  a  cancel  request
s▹cancel
 when  there  are  no  available  seats,  or  an
available message 
s▹available(x1)
 containing details of
the  trip.  In  this  case,  the  traveler  may  book  the  flight
s◃book(e2)
. Finally, traveler receives  tickets message
s▹tickets(x2)
if the transaction has succeed, otherwise
he will receive a cancelBook message .
The behavior of the travel agent is given by: 
! chTA(s).s◃ack.s ▹orderTrip(x1).
chA(ν s' ). s' ▹ack. s' ◃checkSeat(e1).
s' ▹noSeats. s◃cancel.0⊕
s' ▹ seatsOK (x2).s◃available(e2).s▹book (x3).
s' ◃reserve(e3).
s' ▹reserved ( x4). s◃tickets(e4).0⊕
s' ▹notReserved (x5). s◃cancelBook.0
The  travel  agent  offers  his  service  through  
chTA
 by
providing a communication channel s. Once his service is
invoked, he sends an acknowledgment message, receives an
order trip, then contacts the airline service through its public
service channel  
ch A
. The communication between the
airline service and the travel agent occurs through the session
channel  
s'
.  The travel agent looks for available seats
s' ◃checkSeat(e1)
. If there are no available seats then he
receives  noSeats message  
s' ▹noSeats
 and he sends a
cancel message 
s◃cancel
 to the traveler. Otherwise he
receives a seatsOK message 
s' ▹ seatsOK(x2)
 and sends
an  available message  
s◃available(e2)
 to the traveler.
After that, the travel agent receives a book message from the
traveler
s▹book(x3)
 and proceeds to flight reservation
s' ◃reserve(e3).
Depending  on  seats  availability,  he
receives either a confirmation message 
s' ▹reserved (x4)
or a  notReserved message
s' ▹notReserved (x5)
. In the
first case, he sends tickets
s◃tickets(e4)
to the traveler
elsewhere he sends a book cancellation 
s◃cancelBook.
The behavior of the airline is given by:
!ch A(s' ). s'◃ack.s ' ▹checkSeat(x1).
if available( x1) then s' ◃ seatsOk (e1).
s' ▹reserve(x2).if available(x2) then
s' ◃reserved (e2).0 else
s' ◃notReserved (e3).0
else s' ◃noSeats.0
The airline service offers his service through the service
channel  
ch A
. Once his service is invoked, he sends an
acknowledgment message. Then, he receives a  checkSeat
request. Subject to availability, he responds with a seatsOK
or noSeats message. In the first case, he may receive a seat's
booking request
s' ▹reserve(x2).
At this stage, the airline
service  checks  another  time  seats  availability  before
finalizing  the  process  by  either  sending  a  reserved
s' ◃reserved (e2)
or 
s' ◃notReserved (e3)
as notReserved message.
III. SECURITY POLICY SPECIFICATION LANGUAGE
In this Section, we introduce the Security Policy Calculus
(SPC), a formalism  used  for describing security policies.
SPC is considered as a subset of EPC in the sense that it uses
only some operators of EPC. Indeed the operators that are
91
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-376-6
SECURWARE 2014 : The Eighth International Conference on Emerging Security Information, Systems and Technologies

used  in  SPC  are  communication  actions,  recursion,
indeterministic choice and no action. Security policies will
be represented by processes that will monitor the execution
of an another process from EPC.
A.
Syntax
The syntax of SPC is given by:
φ ::= s◃⊕opi.φi∣ s▹Σopi.φi∣φ1⊕φ2 ∣rec X .φ ∣0
•
The construct  
s◃⊕opi.φi
 expresses  the  fact
that  invoking  one  of  operators
opi
through
session channel s is permitted by 
φ
.
•
Next  we  have
s▹Σopi.φi
,
 which  allows
reception of operators 
opi
 through s.
•
The  indeterministic  branching  is  given  by
φ1⊕φ2
.
•
For representing  repeated  behaviors,  we  use  the
recursion operator and
•
finally, 0 denotes the lack of actions.
For describing security properties, we need usually to
express the prohibition of executing some actions. In our
case,  when  we  want  for  example  to  interdict  sending
operation
op1
 through  s we  would  write  this  security
property:
φ=s◃ ⊕
i≠1 opi.0
,  which says that we can invoke
anyone of the operators  
opi
unless
op1
. If we want
this  behavior  to  be  repeatedly  verified  we  would  write
φ=rec X.s◃ ⊕
i≠1 opi. X
. The semantics are the same as
for EPC since SPC is a subset of EPC.
Usually,  we  use  temporal  logics  for  describing  security
properties but when using the security policy calculus we
also reach our goal of expressing any security property that
we want to enforce on the behavior of a WS. Since this
approach introduces a dynamic verification of WS, so the
security properties that we verify in this paper are safety
properties and liveness properties without infinite behavior.
The  reason  behind  this  choice  is  that  some  liveness
properties can only be verified statically.
B.
Shortcuts
For shortness, we will denote by 
ϕs
 and 
ϕs
 the
portions of a security property that respectively allows all
input (output) interactions through s. So 
ϕs=s▹Σ opi(xi)
and ϕs=s◃⊕opi(ei)
.
C.
Example
In the airline reservation system, it is assumed the travel
agent wants to be sure that his service does not send tickets
before the reception of payment details.  The travel agent
receives  payment  details  within  the  book  message
s▹book( x3)
 and sends tickets within the tickets message
s◃tickets(e4)
.  So  we  want  to  ensure  that
s◃tickets(e4)
does  not  occur  before  
s▹book( x3)
.
The security property will be written as follows:
rec X. s◃
⊕
opi≠ticketsopi(ei). X ⊕s▹
Σ
opi≠bookopi(xi). X
⊕ϕs' . X ⊕ϕs' . X ⊕s▹book (x).
(rec Y.ϕs.Y ⊕ϕs .Y ⊕ϕs' .Y ⊕ϕs' .Y )
The security property is written using a recursion. The idea is
to put after each action different from book and tickets the
recursion variable X. Thus, the property will remain invariant
when  executing  these  actions.  It  will  evolve  only  by
executing the book message. In this recursion, one of these 4
blocks will be executed:
•
s◃
⊕
opi≠ticketsopi(ei). X
:  it  prohibits  invoking
tickets operator through s, which is shared between
the  traveler  and  the  travel  agent.  Any  message
different from tickets can be sent.
Figure 1
92
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-376-6
SECURWARE 2014 : The Eighth International Conference on Emerging Security Information, Systems and Technologies

•
s▹
Σ
opi≠book opi(xi). X
:  this  block  prohibits  the
reception of  book operator invocation through the
session  channel  s.  Any  message  different  from
book can be received.
•
ϕs' . X
 and 
ϕs' . X
: all actions are permitted
between the travel agent and the airline reservation
service. The channel s' is a session channel shared
between the travel agent and the airline reservation
system.
•
s▹book (x).rec Y.ϕs.Y ⊕ϕs.Y ⊕ϕs' .Y ⊕ϕs' .Y
this  block  intercepts  the  invocation  of the  book
operator within the travel agent and then we take
off the control on  tickets operator by allowing all
actions between the traveler and the traveler agent
through  s and  the  travel  agent  and  the  airline
reservation system through s' to be executed.
IV.
ENFORCEMENT APPROACH
In  this  Section,  we  will  introduce  our  enforcement
approach using rewriting techniques. This approach consists
in adding some special actions to processes representing the
behavior of a WS and a security property in order to make
them synchronize on each interaction that will occur.
A.
Communication Actions of EPC
Communication  actions  are  used  in  this  context  to
designate interactions of EPC. Interactions of EPC are given
by these two constructs: 
s◃op(e)
 and 
s▹Σopi(xi).
They are distinguished by three criteria:
•
session channel (s),
•
operator name (
opi
),
•
and direction (
s◃
 or 
s▹
).
Indeed, each interaction in EPC occurs through a session
channel that have been freshly generated and shared between
two participants. Within each interaction an operator is either
invoked  or  offered  depending  on  the  direction  of  the
interaction. For instance,  
s◃op1(e)
 is an invocation of
the  operator  
op1
 through  the  session  channel  s,
s' ▹op2(x)
 is  a  reception  of  an  invocation  of  the
operator
 
op2
 
on  the  session  channel
 s'.
The goal of this approach is to monitor the execution of
interactions  inside  a  choreography.  This  goal  will  be
achieved  by  controlling  the  execution  of  communication
actions of EPC.
B.
Synchronization Actions
Synchronization actions are special actions that we add to
the process and to the security property enforced on this
process  in  order  to  ensure  the  interception  of  each
communication action by the monitor. The idea of using
synchronization actions to intercept actions is inspired from
[6].  So,  given  a  communication  action  
s◃op(e)
(respectively
 
s▹Σopi(xi)
),  the  corresponding
synchronization  action  is
 
s◃op(e)
 
(respectively
s▹Σopi(xi)
).
C.
Rewriting Processes
In order to achieve our goal that consists on enforcing a
security property on the behavior of a participant  A in a
choreography,  we  need  to rewrite  its process by adding
synchronization  actions.  Informally,  we  will  add  before
each  communication  action  its  corresponding
synchronization action. Formal rules for rewriting a process
P of EPC are:
〈!ch(̃s).P〉 := ! ch(̃s).〈P〉
〈ch(ν ̃s).P〉 := ch(ν ̃s).〈P〉
〈x :=e.P〉 := x :=e.〈 P〉
〈P⊕Q〉 := 〈P〉⊕〈Q 〉
〈P∣Q〉 := 〈P〉∣〈Q〉
〈if e then P else Q〉 := if e then 〈P〉 else 〈Q 〉
〈rec X.P〉 := rec X.〈P〉
〈s◃op(e). P〉 := s◃op(e). s◃op(e).〈P〉
〈s▹op(x). P〉 := s▹op(x).s▹op(x).〈P〉
D.
Rewriting Security Properties
Rewriting  the  security  property  consists  on  replacing
each communication action by its synchronization action.
Formal rules for rewriting security properties are:
〈s◃⊕opi.φi〉 := s◃⊕opi.〈φi〉
〈s▹Σ opi.φi〉 := s▹Σ opi.〈φi〉
〈φ1⊕φ2〉 := 〈φ1〉⊕〈φ2〉
〈rec X .φ〉 := rec X .〈φ 〉
E.
Restriction Operator
In order to make the rewritten security property 
φ
and
the  rewritten  process  P  synchronize, we  will  define  an
operator of EPC that we call the restriction operator and we
denote by  
P∖φ
. The role of this operator is to let the
process evolve normally when no communication actions is
willing to occur. Before a communication action will occur
P∖φ
will intercept its synchronization action and verify
if  the  security  property  can  evolve  by  executing  this
synchronization action. If it is the case then  P and  
φ
execute this synchronization action. Else  P will block and
will not execute any other actions. An another role of this
enforcement operator is that it hides synchronizations of P
and 
φ
for the rest of the choreography. Thus, executions
of synchronization actions in EPC will be marked by 
τ
as silent actions. Thus our restriction operator does not affect
the evolution of P when no synchronization action is willing
to occur. 
P∖φ
must ensure the synchronization of P and
φ
 on only synchronization actions.
F.
Normal Form of a Process
Every  process  representing  the  local  behavior  of  a
participant in a WS can be written as an internal sum of
processes, which we call the normal form of a process:
P=⊕
i∈I ai.Pi
where 
ai
 range over atomic actions, I is
a finite subset of natural numbers,  and  
Pi
 range over
processes.
Atomic  actions  of  EPC  are:  session  initiation  request
93
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-376-6
SECURWARE 2014 : The Eighth International Conference on Emerging Security Information, Systems and Technologies

(
ch(ν ̃s)
),  session  initiation  offer  (
!ch(̃s)
),
communication input (
s▹op(x)
), communication output
(
s◃op(e)
), assignment (
x :=e
) and synchronization
actions (
s▹op(x)
,
s◃op(e)
).
G.
Simulation
We say that a process P can execute an action a and becomes
P' and we write 
P →
a P'
if, when we write P in its normal
form  (
P=⊕
i∈I ai.Pi
),  there  exists  
j∈I
 such  that
a j=a
 and  
P j≡P'
 where
≡
is  the  structural
equality defined in the semantics of EPC.
H.
Semantics
Reduction  rules  for  making  
P∖φ
progress  when
executing  synchronization  actions  are  given  by:
P
→
s◃op(e) P' φ →
s◃op(e)φ '
A[ P∖ φ]σ →
τ A[ P' ∖φ' ]σ
P
→
s▹op(x )P '
φ
→
s▹op( x)φ'
A[P∖ φ]σ →
τ A[ P' ∖ φ' ]σ
These rules say that each synchronization action of P will be
intercepted  by
φ
and  it  cannot  be  executed  if
φ
prohibits it. If the synchronization action can be executed by
φ
then P becomes silently P' and
φ
becomes
φ'
.
I.
Example
Consider the airline reservation system case study. We will
enforce the security property
φ
defined in the precedent
example on the behavior P of the travel agent defined in the
first  example  of  this  paper.  The  rewritten  process  and
security property are:
P=!chTA(s). s◃ack . s◃ack. s▹orderTrip(x1).
s▹orderTrip(x1).chA(νs ').s' ▹ack .s' ▹ack.
s' ◃checkSeat (e1).s' ◃checkSeat(e1).
(s '▹ noSeat. s' ▹noSeat.s◃cancel .s◃cancel.0)
⊕ s' ▹seatOk (x2).s' ▹seatOk (x2).s◃available(e2).
s◃available(e2).s▹book(x3).s▹book(x3).
s' ◃reserve(e3).s' ◃reserve(e3). s' ▹reserved (x4).
s' ▹reserved( x4).s◃ticket (e4).s◃ticket (e4).0
⊕s' ▹notReserved (x5).s' ▹notReserved (x5).
s◃cancelBook .s◃cancelBook.0
φ=rec X. s◃
⊕
opi≠ticket opi(ei). X ⊕s▹
Σ
opi≠book opi( xi). X ⊕
〈ϕs '〉. X ⊕〈ϕs'〉. X ⊕ s▹book(x).rec Y.〈ϕs〉.Y ⊕〈ϕs〉.Y ⊕
〈ϕs'〉.Y ⊕〈ϕs' 〉.Y
where 
〈ϕs〉=s▹Σ
i op(x), 〈ϕs〉=s◃⊕
i opi(ei)
 and 
similarly for 
〈ϕs' 〉
 and 
〈ϕs' 〉
.
TravelAgent[ P∖ φ]
 will use first Init reduction rule to
open a parallel session then for each communication action,
it will synchronize with  
φ
using the reduction rules of
P∖φ
 and  then  communicates  using  communication
reduction  rules.  We  can  see  easily  that  this  process  P
satisfies the security property 
φ
.
V. PROOF OF THE APPROACH
In this Section, we prove the correctness of our theory by
defining  first  a  partial  order  over  processes  and  the
satisfaction notion.
A.
Definition (Subprocess)
Let P, Q be two processes. We say that P is a subprocess of
Q and we write
P⊆Q
if the following condition hold :
P →
a P' ⇒ Q →
a Q'
  and 
P'⊆Q '
.
B.
Definition (Safe Action, Safe Trace)
A  trace  
ξ
of  EPC  is  a  sequence  of  atomic  actions
executed by a process. An atomic action is said to be safe if
it is not a synchronization action. A trace is said to be safe if
it contains only safe actions.
C.
Definition (Progression of P)
We say that a process  P can progress by executing some
safe actions and a synchronization action a and become Q,
and we write 
P⇥
a
Q
if it exists a safe trace 
ξ
and a
process P' such that 
P →
ξ P'
 and 
P' →
a Q
.
D.
Definition (Satisfaction Notion)
We say that a process P satisfies a security property 
φ
and we write
P≈φ
if for all synchronization action  a
such that
P⇥
a
P '
we have
φ→
a φ'
and 
P'≈φ'
.
E.
Theorem
Let P be a process and
φ
a security property. The 
following properties hold :
•
P∖ φ⊆P
,
•
P∖ φ≈φ
,
•
∀P'≈φ, P '⊆P⇒ P' ⊆P∖ φ
.
F.
Proof
•
The proof is obtained directly from the reduction
rules of our enforcement  operator and  from  the
definition of 
⊆
. Indeed 
P∖ φ
 is defined so
that it cannot execute any actions that P does not
execute it.
•
Let  a be  a  synchronization  action  such  that
P∖φ⇥
a
P ' ∖φ'
. It exists a safe trace 
ξ
 such
that  
P∖φ→
ξ P ' ' ∖ φ
 and  
P' ' ∖φ→
a P ' ∖ φ'
.
But  executions  of  synchronization  actions  by
P' ' ∖φ
 are given  by  In-Sync  and  Out-Sync
rules. Then we have necessarily
φ →
a φ'
.
•
Let  P' be a process satisfying a security property
φ
such that
P'⊆P
. Suppose 
P' →
a P' '
.
As  
P'⊆P
 then  
P→
a Q
.  If  a is  a
synchronization  action  then  from the  hypothesis
94
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-376-6
SECURWARE 2014 : The Eighth International Conference on Emerging Security Information, Systems and Technologies

P'≈φ
 we conclude that  
φ→
a φ '
 and then
P∖φ→
a Q ∖φ'
. If  a is  not  a synchronization
action then 
P∖φ →
a Q ∖φ
.
VI. RELATED WORK
Several  works  have  studied  the  correctness  and
conformance  of
 composition  of  WS  to  security
requirements. 
A. Baouab et al. [7] show a run-time event-based approach
to deal with  the problem of monitoring  conformance  of
interaction  sequences.  When  a violation  is  detected,  the
program shows errors in dashboards. So the program does
not stop before the violation occurred. J. Simmonds et al.
[8]  formalize  sequence  diagrams  to  express  WS
conversations and security requirements and then translate
them  to  nondeterministic  finite  automata  and  generate
monitors from NFA. Their WS conversation is extracted
from the definition of simple services and so they did not
consider the great number of WS conversations that will be
provided with the composition of WS. D. Dranidis et al. [9]
introduced an approach to verify the conformance of a WS
implementation against a behavioral specification, through
the application of testing. The Stream X-machines are used
as  an  intuitive  modeling  formalism  for  constructing  the
behavioral specification of a stateful WS and a method for
deriving test cases from that specification in an automated
way. The test generation method produces complete sets of
test cases that, under certain assumptions,
are guaranteed to reveal all non-conformance faults in a
service implementation under test. However, this approach
only  returns  nonconformance  faults  and  does  not  react
dynamically against these errors. Furhtermore, L. Ardissono
et  al.  [10]  propose  a  monitoring  framework  of  a
choreographed service which supports the early detection of
faults and decide whether it is still possible to continue the
service.
R. Gay et al. [11] have proposed service automata as a
framework  for  enforcing  security  policies  in  distributed
systems.  They  encapsulate  the  program  in  a  service
automaton  composed  of  the  monitored  program,  an
interceptor, an enforcer, a coordinator and a local policy.
The interceptor intercepts critical actions and passes them to
the coordinator that determines whether the action complies
the  security  policy  or  not  and  decides  upon  possible
countermeasures  then  the  enforcer  implements  these
decisions. However the authors do not precise how to detect
critical  actions.  W.  She  et  al.  [13]  have  developped  an
innovative security-aware service composition protocol with
composition-time  information  flow  control,  which  can
reduce  the  execution-time  failure  rate  of  the  composed
composite  services  due  to  information  flow  control
violations. This approach only guarantees that there are no
access  control  violations  at  execution  time  but  do  not
guarantee  that there are not  access  control  violations  at
runtime. Jose A. Martìn et al. [14] developed a framework
based on the partial model checking technique for statically
verifying  whether  a  composition  of  WS  satisfies
cryptographic properties such as secrecy and authenticity.
VII.
CONCLUSION AND FUTURE WORK
The  goal  of  this  research  is  to  introduce  an  automated
formal approach for enforcing dynamically security policies
on a choreography of WS using the rewriting technique. We
used a formal language to express conversations of different
participants and to express also security requirements. Then,
we  have  shown  how  to  restrict  the  progression  of
participant's behavior in order to satisfy security policies.
Future work  is  concentrated  on the optimization  of this
approach by reducing the number of synchronization actions
that have been added to processes. 
REFERENCES
[1]
I.  Corporation,  “Business  process  execution  language  for  web
services bpel-4ws,” http://www.ibm.com/developerworks/library/ws-
bpel/, 2002.
[2]
N. Kavantzas, D. Burdett, G. Ritzinger, T. Fletcher, and Y. Lafon,
“Web services choreography description language version 1.0,” W3C
Working Draft, December 2004.
[3]
M. Carbone,  K.  Honda, and N. Yoshida, “Theoretical aspects of
communication-centred programming,” Electr. Notes Theor. Comput.
Sci., vol. 209, 2008., pp. 125–133.
[4]
N. Busi, R. Gorrieri, C. Guidi, R. Lucchi, and G. Zavattaro, “Towards
a formal framework for choreography,” in WETICE, 2005, pp. 107–
112.
[5]
G. D´ıaz, J. J. Pardo, M.-E. Cambronero, V. Valero, and F. Cuartero,
“Automatic translation of ws-cdl choreographies to timed automata,”
in EPEW/WS-FM, pp. 230–242, 2005.
[6]
M. Langar, M. Mejri, and K. Adi, “Formal enforcement of security
policies on concurrent systems,” J. Symb. Comput., vol. 46, no. 9, pp.
997–1016, 2011.
[7]
A. Baouab, O. Perrin, and C. Godart, “An optimized derivation of
event queries to monitor choreography violations,” in ICSOC, 2012,
pp. 222– 236. 
[8]
J.  Simmonds  et  al.,  “Runtime  monitoring  of  web  service
conversations,” IEEE T. Services Computing, vol. 2, no. 3, 2009, pp.
223–244.
[9]
D. Dranidis, E. Ramollari, and D. Kourtesis, “Run-time verification
of  behavioural  conformance  for  conversational  web  services,”  in
ECOWS, 2009, pp. 139–147.
[10] L.  Ardissono,  R.  Furnari,  A.  Goy,  G.  Petrone,  and  M.  Segnan,
“Monitoring choreographed services,” in Innovations and Advanced
Techniques in Computer and Information Sciences and Engineering,
2007, pp. 283– 288.
[11] R. Gay, H. Mantel, and B. Sprick, “Service automata,” in  Formal
Aspects in Security and Trust, 2011, pp. 148–163. 
[12] H. Yang, X. Zhao, Z. Qiu, G. Pu, and S. Wang, “A formal model for
web service choreography description language (WS-CDL),” in 2006
IEEE  International  Conference  on  Web  Services  (ICWS  2006),
September 2006,  18-22. Chicago, Illinois, USA, 2006, pp. 893–894.
[13] W. She, I. Yen, B. M. Thuraisingham, and E. Bertino, “Security-
aware  service  composition  with  fine-grained  information  flow
control,” IEEE T. Services Computing, vol. 6, no. 3, pp. 330–343,
2013.
[14] J.  A.  Mart´ın,  F.  Martinelli,  I.  Matteucci,  E.  Pimentel,  and  M.
Turuani,  “On  the  synthesis  of  secure  services  composition,”  in
Engineering Secure Future Internet Services and Systems - Current
Research, 2014, pp. 140– 159.
95
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-376-6
SECURWARE 2014 : The Eighth International Conference on Emerging Security Information, Systems and Technologies

