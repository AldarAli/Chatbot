155
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Linear Constraints and Guarded Predicates as a Modeling Language for Discrete
Time Hybrid Systems
Federico Mari, Igor Melatti, Ivano Salvo, and Enrico Tronci
Department of Computer Science – Sapienza University of Rome
Via Salaria 113, 00198 Rome, Italy
Email: {mari,melatti,salvo,tronci}@di.uniroma1.it
Abstract—Model based design is particularly appealing in
software based control systems (e.g., embedded software) design,
since in such a case system level speciﬁcations are much
easier to deﬁne than the control software behavior itself.
In turn, model based design of embedded systems requires
modeling both continuous subsystems (typically, the plant) as
well as discrete subsystems (the controller). This is typically
done using hybrid systems. Mixed Integer Linear Programming
(MILP) based abstraction techniques have been successfully
applied to automatically synthesize correct-by-construction
control software for discrete time linear hybrid systems, where
plant dynamics is modeled as a linear predicate over state,
input, and next state variables. Unfortunately, MILP solvers
require such linear predicates to be conjunctions of linear
constraints, which is not a natural way of modeling hybrid
systems. In this paper we show that, under the hypothesis
that each variable ranges over a bounded interval, any linear
predicate built upon conjunction and disjunction of linear
constraints can be automatically translated into an equivalent
conjunctive predicate. Since variable bounds play a key role
in this translation, our algorithm includes a procedure to
compute all implicit variable bounds of the given linear
predicate. Furthermore, we show that a particular form of
linear predicates, namely guarded predicates, are a natural
and powerful language to succinctly model discrete time linear
hybrid systems dynamics. Finally, we experimentally show the
feasibility of our approach on an important and challenging
case study taken from the literature, namely the multi-input
Buck DC-DC Converter. As an example, the guarded predicate
that models (with 57 constraints) a 6-inputs Buck DC-DC
Converter is translated in a conjunctive predicate (with 102
linear constraints) in about 40 minutes.
Keywords-Model-based software design; Linear predicates;
Hybrid systems
I. INTRODUCTION
Many
embedded
systems
are
Software Based Control Systems (SBCS).
An
SBCS
consists of two main subsystems: the controller and
the
plant.
Typically,
the
plant
is
a
physical
system
consisting,
for
example,
of
mechanical
or
electrical
devices, while the controller consists of control software
running on a microcontroller. In an endless loop, each
T
seconds
(sampling
time),
the
controller,
after
an
Analog-to-Digital (AD)
conversion
(quantization),
reads
sensor
outputs
from
the
plant
and,
possibly
after
a
Digital-to-Analog (DA) conversion, sends commands to
plant actuators. The controller selects commands in order
to guarantee that the closed loop system (that is, the system
consisting of both plant and controller) meets given safety
and liveness speciﬁcations (system level speciﬁcations).
This paper is an extension of the ICSEA 2012 pa-
per [1], and contributes to model based design of embed-
ded software [2]. Software generation from models and
formal speciﬁcations forms the core of model based de-
sign of embedded software. This approach is particularly
interesting for SBCSs, since in such a case system level
speciﬁcations are much easier to deﬁne than the con-
trol software behavior itself. In this setting, correct-by-
construction software generation from (as well as formal
veriﬁcation of) system level speciﬁcations for SBCSs re-
quires modeling both the continuous subsystem (the plant)
and discrete systems (the controller). This is typically done
using hybrid systems (e.g., see [3][4]). Here we focus
on Discrete Time Linear Hybrid Systems (DTLHS) [5][6]
which provide an expressive model for closed loop systems.
A DTLHS is a discrete time hybrid system whose dynamics
is deﬁned as a linear predicate (i.e., a boolean combination
of linear constraints) on its continuous as well as discrete
(modes) variables. A large class of hybrid systems, including
mixed-mode analog circuits, can be modeled using DTLHSs.
System level safety as well as liveness speciﬁcations are
modeled as set of states deﬁned, in turn, as linear predicates.
Moreover, discrete time non-linear hybrid systems may be
properly overapproximated with DTLHSs [7] in such a
way that a controller for the overapproximated system is
guaranteed to work also for the original non-linear system.
In our previous work [8][9], stemming from a constructive
sufﬁcient condition for the existence of a quantized sampling
controller for an SBCS modelled as a DTLHS (which is
an undecidable problem [10]), we presented an algorithm
that, given a DTLHS model H for the plant, a quantization
schema (i.e., how many bits we use for AD conversion)
and system level speciﬁcations, returns the C code [11] of a
correct-by-construction quantized feedback control software
(if any) meeting the given system level speciﬁcations. The
synthesis algorithm rests on the fact that, because of the
quantization process, the plant P is seen by the controller as
a Nondeterministic Finite State Automaton (NFSA) ˆP, that

156
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
is an abstraction of P. The NFSA
ˆP is computed by
solving Mixed Integer Linear Programming (MILP) prob-
lems which contains the deﬁnition of the DTLHS dynam-
ics as a sub-problem. Since available MILP solvers (e.g.,
GLPK [12] and CPLEX [13]) require conjunctive predicates
(i.e., a conjunction of linear constraints) as input, we have
that the DTLHS dynamics must be given as a conjunctive
predicate.
While this is not a limitation for DTLHSs with a not
too complex dynamics, this may turn in an obstruction
for more complex systems. As an example, the dynamics
of the 6-inputs Buck DC-DC Converter of Section VII-A
is described by the conjunction of 102 linear constraints.
However, by allowing disjunction, the same dynamics may
be written as a linear predicate consisting of 45 linear
constraints. Moreover, constants occurring in such a linear
constraint are directly linked to the system physical (known)
parameters, while the ones in the conjunctive predicate must
be suitably computed. This results in a practical limitation
for the effective application of the method in [8][9].
This paper is motivated by circumventing such a limita-
tion, by showing that, under the hypothesis that each variable
ranges over a bounded interval, any linear predicate can
be automatically translated into an equivalent conjunctive
predicate.
Note that it is a reasonable hypothesis to assume variables
describing a DTLHS behavior to be bounded. In fact, control
software drives the plant towards a goal, while keeping it
inside a given desired bounded admissible region. Namely,
bounds on present state variables essentially model the
sensing region, that is the range of values observable by
the sensors. Such a region is usually a bounded rectangular
region (i.e., the Cartesian product of bounded intervals).
Bounds on controllable input variables model the actuation
region, that is the range of values of commands that the
actuators may send to the plant and it is also typically a
bounded rectangular region. Other variables may model both
non-observable plant state variables and uncontrollable in-
puts (i.e., disturbances). Therefore, bounds on such variables
are usually derived from reasonable assumptions or DTLHS
knowledge. On the other hand, next state variable bounds are
typically not explicitly given. However, they may be derived
from all other above mentioned variable bounds (as it will
be shown in Example 4 of Section V).
Finally, note that the application of the methods outlined
here is not limited to the scenario shown above, but may be
applied to nearly all possible usages of MILP solvers in any
ﬁeld.
A. Our Main Contributions
In this paper, we give an algorithm to translate any linear
predicate into an equivalent (as for solving MILP problems,
as it will be shown in Proposition 1 of Section II-B) con-
junctive predicate, i.e., a conjunction of linear constraints.
This allows us to circumvent the limitation mentioned above,
i.e., that conjunctive predicates must be used to describe
DTLHSs dynamics.
We consider predicates built upon conjunctions and dis-
junctions of linear constraints (i.e., inequalities of the shape
Pn
i=1 aixi ≤ b, Section II). In order to translate them into
a conjunctive predicate, we employ a two-stage approach.
First, we show that, at the price of introducing fresh boolean
variables, a predicate can be translated into an equivalent
guarded predicate (Section IV-A), i.e., a conjunction of
guarded constraints of the shape y → (Pn
i=1 aixi ≤ b).
Guarded predicates themselves are shown to be a power-
ful means of modeling DTLHSs dynamics in Section VI.
Second, once a guarded predicate has been obtained (or a
guarded predicate has been directly provided as the input
DTLHS model), we show that it can be in turn translated into
a conjunctive predicate (Section IV-B). This latter translation
needs, as a further input, the (ﬁnite) upper and lower bounds
for each variable in the predicate. To this end, in Section V
we give an algorithm that computes bounds for a variable x
in a given guarded predicate G(X), i.e., either it returns
two values mx, Mx ∈ R such that if G(X) holds, then
mx ≤ x ≤ Mx, or it concludes that such values do not
exist.
An experimental evaluation of the translation algorithm
presented in this paper is in Section VII. As an example, we
show that the linear predicate that models a 4-inputs Buck
DC-DC Converter with 39 linear constraints is translated
into a conjunctive predicate of 82 linear constraints in
slightly more than 3 hours.
Note that there are two available inputs for our translation
algorithm: i) a linear predicate or ii) a guarded predicate.
Namely, if a guarded predicate is provided as input, only
the second stage mentioned above is performed. Our ex-
perimental evaluation also shows that it is more convenient
to use guarded predicates instead of linear predicates when
modeling DTLHSs dynamics. As an example, the guarded
predicate that models a 6-inputs Buck DC-DC Converter
with 57 constraints (including 12 different guards), is trans-
lated into a conjunctive predicate of 102 linear constraints
in about 40 minutes.
B. Paper Outline
The paper is organized as follows. Section II provides the
basic deﬁnitions to understand our approach. In Section III,
we formally deﬁne DTLHSs. In Section IV, our two-steps
approach (from linear predicates to guarded predicates and
then to conjunctive predicates) is outlined, assuming vari-
ables bounds to be known. In Section V, we show how we
automatically compute bounds for all variables in a guarded
predicate, thus completing the description of our approach.
Section VI shows that guarded predicates are a powerful
and natural modeling language for DTLHSs. Section VII
shows experimental results on a meaningful case study,

157
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
namely the multi-input Buck DC-DC Converter. Finally,
Sections VIII and IX conclude the paper, by comparing
the approach presented here with previous work and by
providing concluding remarks and future work.
II. BASIC DEFINITIONS
An initial segment {1, . . . , n} of N is denoted by [n]. We
denote with X = [x1, . . . , xn] a ﬁnite sequence of distinct
variables, that we may regard, when convenient, as a set.
Each variable x ranges on a known (bounded or unbounded)
interval Dx either of the reals (continuous variables) or of the
integers (discrete variables). The set Q
x∈X Dx is denoted
by DX. Boolean variables are discrete variables ranging on
the set B = {0, 1}. If x is a boolean variable we write ¯x
for (1 − x). The sequence of continuous (discrete, boolean)
variables in X is denoted by Xr (Xd, Xb).
The set of sequences of n boolean values is denoted
by Bn. The set Bn
k ⊆ Bn denotes sequences that contains
exactly k elements equal to 1. Given a, b ∈ Bn, we say that
a ≤ b if a is point-wise less or equal to b, i.e., if for all
i ∈ [n] we have that ai ≤ bi. Given a set B ⊆ Bn and
a ∈ Bn we write a ≤ B if there exists b ∈ B such that
a ≤ b and a ≥ B if there exists b ∈ B such that a ≥ b. We
denote with Ones(b) be the set of indexes such that bj = 1,
i.e., Ones(b) = {j ∈ [n] | bj = 1}.
A. Predicates
A linear expression L(X) = Pn
i=1 aixi is a linear
combination of variables in X with rational coefﬁcients. A
constraint is an expression of the form L(X) ≤ b, where b
is a rational constant. We write L(X) ≥ b for −L(X) ≤ −b,
L(X) = b for (L(X) ≤ b) ∧ (−L(X) ≤ −b), and
a ≤ L(X) ≤ b for (L(X) ≤ b) ∧ (L(X) ≥ a).
(Linear) predicates are inductively deﬁned as follows. A
constraint C(X) is a predicate over X. If A(X) and B(X)
are predicates, then (A(X)∧B(X)) and (A(X)∨B(X)) are
predicates over X. Parentheses may be omitted, assuming
usual associativity and precedence rules of logical operators.
A conjunctive predicate is a conjunction of constraints.
A valuation over X is a function v that maps each variable
x ∈ X to a value v(x) in Dx. We denote with X∗ ∈ DX
the sequence of values v(x1), . . . , v(xn). We call valuation
also the sequence of values X∗. Given a valuation X∗, the
value for variable x is X∗(x). Given a predicate P(Y, X),
P(Y, X∗) denotes the predicate obtained by replacing each
occurrence of x with X∗(x). A satisfying assignment to a
predicate P(X) is a valuation X∗ such that P(X∗) holds.
A predicate is said to be satisﬁable if there exists at least
one satisfying assignment. Abusing notation, we denote with
P also the set of satisfying assignments to the predicate
P. P(X) and Q(X) are equivalent, notation P ≡ Q, if
they have the same set of satisfying assignments. P(X) and
Q(Z) are equisatisﬁable, notation P ≃ Q, if P is satisﬁable
if and only if Q is satisﬁable. Finally, two predicates P(X)
and Q(X, Z) are X-equivalent, notation P ≡X Q, if the
following holds for all valuations X∗, Z∗:
1) if P(X∗) holds, then Q(X∗, Z) is satisﬁable;
2) if Q(X∗, Z∗) holds, then P(X∗) holds.
B. Mixed Integer Linear Programming
A Mixed Integer Linear Programming (MILP) problem
with decision variables X is a tuple (max, J(X), A(X))
where X is a list of variables, J(X) (objective function)
is a linear expression over X, and A(X) (constraints) is a
predicate over X. A solution to (max, J(X), A(X)) is a
valuation X∗ such that A(X∗) and ∀Z (A(Z) → (J(Z) ≤
J(X∗))). J(X∗) is the optimal value of the MILP problem.
A feasibility problem is a MILP problem of the form
(max, 0, A(X)). We write also A(X) for (max, 0, A(X)).
In algorithm outlines, MILP solver invocations are denoted
by function feasible(A(X)) that returns 1 if A(X) is satis-
ﬁable and 0 otherwise, and by function optimalValue(max,
J(X), A(X)) that returns either the optimal value of the
MILP problem (max, J(X), A(X)) or ∞ if such MILP
problem is unbounded. We write (min, J(X), A(X)) for
(max, −J(X), A(X)).
Note that available MILP solvers (e.g., GLPK [12] or
CPLEX [13]) require A(X) to be a conjunctive predicate.
However, as explained in Section I, MILP problems arising
in methods like [8][9] are more easily represented as linear
predicates. Thus, we need a translation algorithm from a
linear predicate A to a conjunctive predicate A′ such that a
solution to (max, J, A′) (which may be computed by a MILP
solver) is also a solution to (max, J, A) (which may not be
computed by a MILP solver). To this end, Proposition 1
clariﬁes that X-equivalence between predicates must be
sought.
Proposition 1: Let (max, J(X), A(X)) be a MILP prob-
lem, let B(X, Z) be a conjunctive predicate which is X-
equivalent to A(X) and let ˜J(X, Z) = J(X) + P
z∈Z 0z.
Then for all solutions X∗, Z∗ of (max, ˜J(X, Z), B(X, Z)),
X∗ is a solution of (max, J(X), A(X)). Moreover, for
all solutions X∗ of (max, J(X), A(X)), there exists
Z∗ such that X∗, Z∗ is a solution of (max,
˜J(X, Z),
B(X, Z)). Finally, optimalValue(max, J(X), A(X)) = op-
timalValue(max, ˜J(X, Z), B(X, Z)).
Proof: Let X∗, Z∗ be a solution of (max, ˜J(X, Z),
B(X, Z)). This entails that B(X∗, Z∗) holds, and that
∀X+, Z+ such that B(X+, Z+) holds,
˜J(X∗, Z∗)
≥
˜J(X+, Z+). Suppose by absurd that X∗ is not a solution for
(max, J(X), A(X)). Then, either i) A(X∗) does not hold or
ii) there exist ˜X such that A( ˜X) holds and J(X∗) < J( ˜X).
Case i) is not possible, since B(X∗, Z∗) holds and B(X, Z)
is X-equivalent to A(X). Case ii) is not possible since, by
X-equivalence of B(X, Z) and A(X) and by deﬁnition of
˜J(X, Z), there would exist ˜Z such that B( ˜X, ˜Z) holds and
˜J( ˜X, ˜Z) = J( ˜X) > J(X∗) = ˜J(X∗, Z∗).

158
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
With a similar reasoning, it is possible to prove the other
implication. Finally, equality of optimal values immediately
follows from solutions equivalence and deﬁnition of ˜J.
As a consequence of Proposition 1, the translation algo-
rithm we need must take as input a linear predicate P(X)
and return as output an X-equivalent conjunctive predicate
Q(X, Z). In the following sections, we will show how we
achieve this goal.
III. DISCRETE TIME LINEAR HYBRID SYSTEMS
Discrete Time Linear Hybrid Systems (DTLHS) provide a
suitable model for many SBCS (including embedded control
systems) since they can effectively model linear algebraic
constraints involving both continuous as well as discrete
variables. This is shown, e.g., in Example 1, that presents a
DTLHS model of a buck DC-DC converter, i.e., a mixed-
mode analog circuit that converts the Direct Current (DC)
input voltage to a desired DC output voltage.
Deﬁnition 1: A Discrete Time Linear Hybrid System is a
tuple H = (X, U, Y, N) where:
• X = Xr ∪ Xd is a ﬁnite sequence of real and discrete
present state variables. X′ denotes the sequence of next
state variables obtained by decorating with ′ variables
in X.
• U = U r ∪ U d is a ﬁnite sequence of input variables.
• Y = Y r ∪Y d is a ﬁnite sequence of auxiliary variables.
Auxiliary variables typically models modes (switching
elements) or uncontrollable inputs (e.g., disturbances).
• N(X, U, Y, X′) is a predicate over X ∪ U ∪ Y ∪ X′
deﬁning the transition relation (next state) of the sys-
tem.
Example 1: The buck DC-DC converter [15] is a mixed-
mode analog circuit (Figure 1) converting the DC input
voltage (Vi in Figure 1) to a desired DC output volt-
age (vO in Figure 1). Buck DC-DC converters are used
off-chip to scale down the typical laptop battery volt-
age (12-24) to the just few volts needed by the laptop
processor (e.g., see [15]) as well as on-chip to support
Dynamic Voltage and Frequency Scaling (DVFS) in multi-
core processors. (e.g., see [14]). Because of its widespread
use, control schemes for buck DC-DC converters have been
widely studied (e.g., see [14][15][16]). The typical software
based approach (e.g., see [15]) is to control the switch u
in Figure 1 (typically implemented with a MOSFET, i.e., a
Metal-Oxide-Semiconductor Field-Effect Transistor) with a
microcontroller.
The circuit in Figure 1 can be modeled as a DTLHS
H=(X, U, Y, N) as follows. The circuit state variables are
iL and vC. However we can also use the pair iL, vO as
state variables in H model since there is a linear relationship
between iL, vC and vO, namely: vO =
rCR
rC+RiL +
R
rC+RvC.
Such considerations lead us to the following DTLHS model
R
C
rC
D
iD
L
u
+vu
+vD
iC
+vO
Vi
iL
rL
iu
+vC
Figure 1.
Buck DC-DC converter
H: X = Xr = [iL, vO], U = U d = [u], Y = Y r ∪ Y d
where Y r = [iu, vu, iD, vD] and Y d = [q]. Note how H
auxiliary variables Y stem from the constitutive equations
of the switching elements (i.e., the switch u and the diode D
in Figure 1). From a simple circuit analysis (e.g., see [17])
we have the following equations:
˙iL
=
a1,1iL + a1,2vO + a1,3vD
(1)
˙vO
=
a2,1iL + a2,2vO + a2,3vD
(2)
where the coefﬁcients ai,j depend on the circuit parameters
R, rL, rC, L and C as follows: a1,1 = − rL
L , a1,2 = − 1
L,
a1,3 =− 1
L, a2,1 =
R
rc+R[− rcrL
L + 1
C ], a2,2 =
−1
rc+R[ rcR
L + 1
C ],
a2,3 =− 1
L
rcR
rc+R. Using a discrete time model with sampling
time T and writing x′ for x(t + 1), we have:
i′
L
=
(1 + Ta1,1)iL + Ta1,2vO + Ta1,3vD
(3)
v′
O
=
Ta2,1iL + (1 + Ta2,2)vO + Ta2,3vD.
(4)
The algebraic constraints stemming from the constitutive
equations of the switching elements are the following:
vD
=
vu − Vi (5)
iD
=
iL − iu
(6)
(u = 1) ∨ (vu = Roﬀiu) (7)
(u = 0) ∨ (vu = 0)
(8)
((iD ≥ 0) ∧ (vD = 0)) ∨ ((iD ≤ 0) ∧ (vD = RoﬀiD))
(9)
The transition relation N of H is given by the conjunction
of the linear predicates (3)–(9).
IV. FROM LINEAR TO CONJUNCTIVE PREDICATES
As shown in [8][9], MILP solvers can be used to build
a suitable discrete abstraction of a DTLHS. As shown in
Sections I and II-B (especially in Proposition 1), in order
to do this we need a translation algorithm from linear
predicates to X-equivalent conjunctive predicates. In this
section, we show how we achieve this goal, by designing
a two-steps algorithm. First, in Section IV-A, we introduce
guarded predicates and we show that each predicate P(X)
can be translated into an X-equivalent guarded predicate
Q(X, Z) at the price of introducing new auxiliary boolean
variables Z. Then, in Section IV-B, we show that, under
the hypothesis that each variable ranges over a bounded
interval, each guarded predicate can be in turn translated
into an equivalent conjunctive predicate.

159
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
A. Guarded Predicates
As formalized in Deﬁnition 2, a guarded predicate is
an implication between a boolean variable (guard) and a
predicate.
Deﬁnition 2: Given a predicate P(X) and a fresh boolean
variable z ̸∈ X, the predicate z → P(X) (resp. ¯z →
P(X)) denotes the predicate (z
=
0) ∨ P(X) (resp.
(z = 1) ∨ P(X)). We call z the guard variable and
both z and ¯z guard literals. Let C(X) be a constraint. A
predicate of the form z → C(X) or ¯z → C(X) is called
guarded constraint. A predicate of the form z → C(X) is
called positive guarded constraint, whilst a predicate of the
form ¯z → C(X) is called negative guarded constraint. A
generalized guarded constraint is a predicate of the form
z1 → (z2 → . . . → (zn → C(X)) . . .) A guarded predi-
cate (resp. generalized guarded predicate, positive guarded
predicate) is a conjunction of either constraints or guarded
constraints (resp. generalized guarded constraints, positive
guarded constraints).
To simplify proofs and notations, without loss of gen-
erality, we always assume guard literals to be distinct: a
conjunction z → C1(X) ∧ z → C2(X) is X-equivalent to
the guarded predicate z1 → C1(X) ∧ z2 → C2(X) ∧ z1 =
z ∧ z2 = z, being z1, z2 fresh boolean variables. Moreover,
in algorithm outlines, conjunctive (resp., guarded) predicates
will be sometimes regarded as sets of linear (resp., guarded)
constraints.
By applying standard propositional equivalences, we have
the following facts.
Fact 2: A predicate of the form z → V
i∈[n] Pi(X) is
equivalent to the predicate V
i∈[n](z → Pi(X)).
Fact 3: A generalized guarded constraint z1 → (z2 →
. . . → (zn → C(X)) . . .) is X-equivalent to the positive
guarded predicate (z − P
i∈[n] zi ≥ 1 − n) ∧ (z → C(X)),
where z is a fresh boolean variable.
Proof: Let z be a fresh boolean variable. We have:
z1 → (z2 → . . . → (zn → C(X)) . . .)
≡ z1 ∧ z2 ∧ . . . ∧ zn → C(X)
≡X ((z1 ∧ z2 ∧ . . . ∧ zn) → z) ∧ (z → C(X))
≡ (¯z1 ∨ ¯z2 ∨ . . . ∨ ¯zn ∨ z) ∧ (z → C(X))
≡ z + P
i∈[n](1 − zi) ≥ 1 ∧ (z → C(X))
≡ (z − P
i∈[n] zi ≥ 1 − n) ∧ (z → C(X))
Lemma 4 and its constructive proof allow us to translate
any predicate P(X) to an X-equivalent generalized guarded
predicate Q(X, Z).
Lemma 4: For all predicates P(X), there exists a predi-
cate Q(X, Z) = G(X, Z) ∧ D(Z) such that:
1) P(X) is X-equivalent to Q(X, Z);
2) G(X, Z) and D(Z) (and hence Q(X, Z)) are gener-
alized guarded predicates;
3) each generalized guarded constraint in G(X, Z) is of
the form z1 → z2 → . . . → zm → C(X), with zi ∈ Z
and zi /∈ X for all i ∈ [m].
Proof: The proof is by induction on the structure of the
predicate P(X).
• Case P(X) = C(X) for some linear constraint C(X)
(base of the induction). Then the thesis holds with
G(X, Z) = P(X), D(Z) = 1 and Z = ∅.
• Case P(X) = P1(X) ∧ P2(X) for some predicates
P1(X), P2(X). By inductive hypothesis there exist
Z1, Z2, G1(X, Z1), D1(X, Z1), G2(X, Z2), D2(X, Z2)
such that Pi is X-equivalent to Gi(X, Zi)∧Di(Zi) for
all i ∈ {1, 2}. This entails that P(X) is X-equivalent to
G1(X, Z1)∧G2(X, Z1)∧D1(Z1)∧D2(Z1). By taking
Z = Z1 ∪Z2, G(X, Z) = G1(X, Z1)∧G2(X, Z2) and
D(X, Z) = D1(Z1) ∧ D2(Z2), and recalling that by
inductive hypothesis Gi, Di are generalized guarded
predicates and Zi is the set of boolean variables that
occur positively as guards in Gi (for all i ∈ {1, 2}),
the thesis follows.
• Case P(X) = P1(X) ∨ P2(X) for some predicates
P1(X), P2(X). By inductive hypothesis there exist
Z1, Z2, G1(X, Z1), D1(X, Z1), G2(X, Z2), D2(X, Z2)
such
that
Pi
is
X-equivalent
to
Qi(X, Zi)
=
Gi(X, Zi) ∧ Di(Zi) for all i ∈ {1, 2}. We can always
choose auxiliary boolean variables in such a way that
Z1 ∩ Z2 = ∅.
Taken two fresh boolean variables y1, y2 /∈ Z1 ∪ Z2,
the predicate y1 → Q1(X, Z1) ∧ y2 → Q2(X, Z2) ∧
y1 + y2
≥
1 is X-equivalent to P(X). For all
i ∈ {1, 2}, the predicate
˜Qi(X, Zi, yi) = yi
→
Qi(X, Zi) = yi → (Gi(X, Zi) ∧ Di(Zi)) is not
a generalized guarded predicate. Since Gi(X, Zi)
and Di(Zi) are generalized guarded predicates by
inductive hypothesis, we have that Gi(X, Zi)
=
V
j∈[n] ˜Gi,j(X, Zi) and Di(Zi) = V
j∈[p] ˜Di,j(Zi),
being ˜Gi,j(X, Zi), ˜Di,j(Zi) generalized guarded con-
straints. This allows us to apply Fact 2 to ˜Qi(X, Zi, yi),
obtaining an equivalent predicate Ri(X, Zi, yi)
=
(V
j∈[n] yi → ˜Gi,j(X, Zi)) ∧ (V
j∈[p] yi → ˜Di,j(Zi)).
The thesis follows by taking Z = Z1 ∪ Z2 ∪ {y1, y2},
G(X, Z) = V
i∈{1,2}(V
j∈[n] yi → ˜Gi,j(X, Zi)), and
D(Z) = V
i∈{1,2}(V
j∈[p] yi → ˜Di,j(Zi)) ∧ (y1 + y2 ≥
1). As for point 3, note that this is the only case in
which generalized guarded constraints in G(X, Z) are
generated, and that the generation takes place by adding
boolean fresh guards only. Being the starting predicate
only dependent on X, also point 3 is proved.
Lemma 4 and its constructive proof are exploited in
Algorithm 1, which takes as input a linear predicate P(X)
and outputs the generalized guarded predicates G(X, Z) and
D(Z). The function fresh( ) returns at each invocation a

160
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
(globally) fresh variable. Correctness of Algorithm 1 is given
as a corollary of Lemma 4.
Corollary 5: For all predicates P(X), Algorithm 1 re-
turns ⟨G, D, Z⟩ such that G(X, Z) ∧ D(Z) is X-equivalent
to P and fulﬁlls all properties of Lemma 4.
Proposition 6 and its constructive proof allow us to
translate any predicate P(X) in an X-equivalent positive
guarded predicate Q(X, Z). Moreover, predicate Q(X, Z)
has a special form, i.e., it is the conjunction of two positive
guarded predicates G(X, ˜Z) and D(Z), with ˜Z ⊆ Z. This is
accomplished by ﬁrst translating P(X) in an X-equivalent
generalized guarded predicate ˜Q(X, ˜Z) by using Lemma 4.
Proposition 6: For all predicates P(X), there exists
an X-equivalent positive guarded predicate Q(X, Z) =
G(X, ˜Z) ∧ D(Z), where G and D are positive guarded
predicates and ˜Z ⊆ Z.
Proof: Let ˜Q(X, Z1) =
˜G(X, Z1) ∧ ˜D(Z1) be the
generalized guarded predicate obtained by applying the
proof of Lemma 4 (i.e., by applying Algorithm 1 to
P(X)). Let
˜G(X, Z1)
=
G1(X, Z1) ∧ V
i∈[n](zi,1
→
zi,2
→
. . . zi,qi
→
Ci,1(X))), being G1 a positive
guarded predicate. By Fact 3,
˜G(X, Z1) is (X ∪ Z1)-
equivalent to the positive guarded predicate G1(X, Z1) ∧
V
i∈[n]

˜zi → Ci,1(X) ∧ ˜zi − P
j∈[qi] zi,j ≥ 1 − qi

, where
˜zi /∈ Z1 for all i ∈ [n]. Analogously, by Fact 3 ˜D(Z1) is
Z1-equivalent to the positive guarded predicate D1(Z1) ∧
V
i∈[p]

ˆzi → Ci,2(Z1) ∧ ˆzi − P
j∈[ri] zi,j ≥ 1 − ri

,
where ˆzi /∈ Z1 ∪ {˜zj | j ∈ [n]} for all i ∈ [p]. Thus the
thesis follows by taking:
•
˜Z = Z1 ∪ {˜zj | j ∈ [n]}
• Z = ˜Z ∪ {ˆzj | j ∈ [p]}
• G(X, ˜Z) = G1(X, Z1) ∧ V
i∈[n] ˜zi → Ci,1(X)
• D(Z)
=
D1(Z1)
∧
V
i∈[n] ˜zi − P
j∈[qi] zi,j ≥ 1 − qi

∧
V
i∈[p] ˆzi → Ci,2(Z1) ∧ ˆzi − P
j∈[ri] zi,j ≥ 1 − ri

Proposition 6 and its constructive proof are exploited in
Algorithm 2, which takes as input a linear predicate P(X)
and outputs the positive guarded predicates G(X, ˜Z) and
D(Z). To this aim, Algorithm 1 is used as an auxiliary
procedure. Correctness of Algorithm 2 is given as a corollary
of Proposition 6.
Corollary 7: For all predicates P(X), Algorithm 2 re-
turns ⟨G, D, ˜Z, Z⟩ such that G(X, ˜Z)∧D(Z) is X-equivalent
to P and ˜Z ⊆ Z.
Example 2: Let H be DTLHS in Example 1. Given the
predicate N(X, U, Y, X′) that deﬁnes the transition rela-
tion of H, function PtoG computes the guarded predicate
N gp(X, U, Y, X′) which is (X ∪ U ∪ Y ∪ X′)-equivalent to
N as follows.
Constraints (3)–(6) remain unchanged, as they are linear
constraints in a top-level conjunction. The disjunction (9) is
Algorithm 1 From predicates to generalized guarded pred-
icates (auxiliary for Algorithm 5)
Input: P predicate over X
Output: ⟨G, D, Z⟩ where G(X, Z)∧D(Z) is a generalized
guarded predicate X-equivalent to P(X) (see Lemma 4)
function PtoGG(P, X)
1. if P is a constraint C(X) then return ⟨C(X), ∅, ∅⟩
2. let P = P1 ⋄ P2
(⋄ ∈ {∧, ∨})
3. ⟨G1, D1, Z1⟩ ←PtoGG(P1)
4. ⟨G2, D2, Z2⟩ ←PtoGG(P2)
5. if P = P1∧P2 then return ⟨G1∪G2, D1∪D2, Z1∪Z2⟩
6. if P = P1 ∨ P2 then
7.
y1 ←fresh( ), y2 ←fresh( ), ˜Z ←Z1 ∪ Z2 ∪ {y1, y2}
8.
˜D={y1 →γ|γ ∈D1}∪{y2 →γ|γ ∈D2}∪{y1+y2 ≥1}
9.
˜G = {y1 → γ | γ ∈ G1} ∪ {y2 → γ | γ ∈ G2}
10.
return ⟨ ˜G, ˜D, ˜Z⟩
ﬁrst replaced by the conjunction of linear predicates (10)–
(12) as follows.
z1 →(iD ≥0 ∧ vD =0) (10)
z2 →(iD ≤0 ∧ vD =RoﬀiD) (11)
z1 + z2 ≥ 1
(12)
Then, predicates (10)–(11) are replaced by guarded con-
straints (17)–(20) below, obtained by moving arrows in-
side the conjunctions, as shown by Fact 2. Similarly,
disjunctions (7) and (8) are replaced by guarded lin-
ear constraints (21)–(24) and (26)–(27). Summing up,
N gp(X, U, Y, X′) is given by the conjunction of the fol-
lowing (guarded) constraints:
i′
L
=
(1 + Ta1,1)iL + Ta1,2vO + Ta1,3vD
(13)
v′
O
=
Ta2,1iL + (1 + Ta2,2)vO + Ta2,3vD.
(14)
vD = vu − Vi
(15)
iD = iL − iu
(16)
z1 →(iD ≥0)
(17)
z1 →(vD =0)
(18)
z2 →(iD ≤0)
(19)
z2 →(vD =RoﬀiD)
(20)
z3 →(u=1)
(21)
z4 →(vu =Roﬀiu)
(22)
z5 →(u=0)
(23)
z6 →(vu =0)
(24)
z1+z2 ≥1 (25)
z3+z4 ≥1 (26)
z5+z6 ≥1 (27)
With respect to the statement of Proposition 6, we have
that Z =
˜Z = {z1, z2, z3, z4, z5, z6}, G(X, Z′) is the
conjunction of guarded constraints (13)–(24) and D(Z) is
the conjunction of constraints (25)–(27).
B. From Guarded Predicates to Conjunctive Predicates
Guarded predicates may be translated into equivalent con-
junctive predicates (our ﬁnal target for Proposition 1) once
bounds for all variables occurring in them are known. In
this section, we will show how this translation is performed,
assuming bounds to be known. In Section V, we will show

161
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Algorithm 2 From predicates to positive guarded predicates
(auxiliary for Algorithm 5)
Input: P predicate over X
Output: ⟨G, D, Z, ˜Z⟩ where G(X, ˜Z) ∧ D(Z) is a positive
guarded predicate X-equivalent to P(X) (see Proposi-
tion 6)
function PtoG(P, X)
1. ⟨G, D, Z⟩ ←PtoGG(P, X)
2. ˜G ← ∅, ˜D ← ∅, ˜Z = Z
3. for all γ ∈ G ∪ D do
4.
if γ ≡ z1 → (. . . → (zn → C(W)) . . .) then
5.
w ←fresh( ), Z ← Z ∪ {w}
6.
if W ⊆ X then
7.
˜G ← ˜G ∪ {w → C(W)}, ˜Z ← ˜Z ∪ {w}
8.
else
9.
˜D ← ˜D ∪ {w → C(W)}
10.
˜D ← ˜D ∪ {w − P
i∈[n] zi ≥ 1 − n}
11.
else if vars(γ)⊆ X then
12.
˜G ← ˜G ∪ {γ}
13.
else
14.
˜D ← ˜D ∪ {γ}
15. return ⟨ ˜G, ˜D, Z, ˜Z⟩
how bounds for variables may be computed if some bounds
are already known.
Deﬁnition 3: Let P(X) be a predicate. A variable x ∈ X
is said to be bounded in P if there exist a, b ∈ Dx such that
P(X) implies a ≤ x ≤ b. A predicate P is bounded if all its
variables are bounded. We write sup(P, x) and inf(P, x) for
the minimum and maximum value that the variable x may
assume in a satisfying assignment for P. When P is clear
from the context, we will write simply sup(x) and inf(x).
Given a real number a and a variable x ∈ X over a
bounded interval, we write sup(ax) for a sup(x) if a ≥ 0
and for a inf(x) if a < 0. We write inf(ax) for a inf(x) if
a ≥ 0 and for a sup(x) if a < 0. Given a linear expression
L(X) = Pn
i=1 aixi over a set of bounded variables, we
write sup(L(X)) for Pn
i=1 sup(aixi) and inf(L(X)) for
Pn
i=1 inf(aixi).
Proposition 8: For each bounded guarded predicate P(X)
there exists an equivalent conjunctive predicate Q(X).
Proof: The conjunctive predicate Q(X) is obtained from
the guarded predicate P(X) by replacing each guarded con-
straint C(X) of the shape z → (L(X) ≤ b) in P(X)
with the constraint ˜C(X) = (sup(L(X)) − b)z + L(X) ≤
sup(L(X)). If z = 0 we have C(X) ≡ ˜C(X) since C(X)
holds trivially and ˜C(X) reduces to L(X) ≤ sup(L(X))
that holds by construction. If z = 1 both C(X) and ˜C(X)
reduce to L(X) ≤ b. Along the same line of reasoning,
if C(X) has the form ¯z → (L(X) ≤ b) we set ˜C(X) to
(b − sup(L(X)))z + L(X) ≤ b.
Together with Proposition 6, Proposition 8 implies that
any bounded predicate P(X) can be translated into an X-
equivalent conjunctive predicate, at the cost of adding new
auxiliary boolean variables, as stated in the following propo-
sition.
Proposition 9: For each bounded predicate P(X), there
exists an X-equivalent conjunctive predicate Q(X, Z).
Example 3: Let H be the DTLHS in Example 2. We set
the parameters of H as follows:
rL =0.1Ω
R=5Ω
Vi =15V
L=2 · 10−4H
rC =0.1Ω
Roﬀ =104
T =10−6secs
C =5 · 10−5F
and we assume variables bounds as follows:
−2·104 ≤vu ≤15
−4≤iL ≤4
−1≤vO ≤7 −4≤i′
L ≤96
−2·104 ≤vD ≤0 −1.1≤v′
O ≤17 −4≤iu ≤4 −2≤iD ≤4
By ﬁrst decomposing equations of the shape L(X) = b
in the conjunctive predicate L(X) ≤ b ∧ −L(X) ≤ −b and
then by applying the transformation given in the proof of
Proposition 8, guarded constraints (17)–(24) are replaced by
the following linear constraints:
2z1 − iD ≤ 2 (28)
4 · 104z4 + vu − 104iu ≤ 4 · 104 (29)
6 · 104z4 − vu + 104iu ≤ 6 · 104 (30)
−2.104z1 − vD ≤ 2 · 104 (31)
2.104z2 + vD − 104iD ≤ 2.104 (32)
6.104z2 − vD + 104iD ≤ 6.104 (33)
2 · 104z6 + vu ≤ 15 (34)
2 · 104z4 − vu ≤ 2 · 104 (35)
vD ≤ 0
(36)
4z2 + iD ≤ 4
(37)
z5 + u ≤ 1
(38)
−u ≤ 0
(39)
15z6 + vu ≤ 15
(40)
z3 − u ≤ 1
(41)
u ≤ 1
(42)
V. COMPUTING VARIABLE BOUNDS
In this section, we present two algorithms that check if
a variable x is bounded in a guarded predicate G(X, Z),
where Z is the set of guard variables. If this is the case, both
algorithms return BND (for bounded) and compute a, b ∈
DX such that G(X, Z) implies a ≤ x ≤ b. If this is not the
case, then INFEAS (for infeasible) is returned if G(X, Z) is
unfeasible, and UNB (for unbounded) is returned otherwise.
The ﬁrst algorithm, described in function exhCompute-
Bounds of Algorithm 3, works for all guarded predicates
G(X, Z), where Z is the set of (boolean) variables occurring
as guards in G(X, Z). Namely, it is the naïve algorithm
which, for all valuations Z∗ of B|Z| (line 5), builds the
conjunctive predicate Q(X) = G(X, Z∗). This implies that,
for all guarded constraints ˜G(X, Z) = z → C(X, Z) inside
G, if Z∗(z) is false then Q will not contain ˜G, and will con-
tain only C(X, Z∗) otherwise (line 6). Then, if G(X, Z∗) is
feasible, the upper and lower bounds for x under G(X, Z∗)
are computed (lines 9 and 10). The overall maximum upper
bound and minimum lower bound are ﬁnally returned in
line 15. Unfortunately, this exhaustive procedure requires to
solve 2|Z| MILP problems.
The second algorithm, described in function compute-
Bounds of Algorithm 4, reﬁnes Algorithm 3 in order to

162
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Algorithm 3 Computing variable bounds in a guarded
predicate (auxiliary for Algorithm 5 and 6)
Input: Guarded predicate G(X, Z) and variable x ∈ X.
Output: ⟨µ, inf, sup⟩ with µ ∈ {BND, UNBND, INFEAS},
inf, sup ∈ Dx∪ ⊥.
function exhComputeBounds(G, X, Z, x)
1. let G(X, Z) = V
i∈[n] Gi(X, Z), being each Gi(X, Z)
either a constraint Ci(X, Z) or a guarded constraint
zi → Ci(X, Z), ¯zi → Ci(X, Z)
2. let g(i), for i ∈ [n], be the guard of Gi, if any , or 1
otherwise
3. let c(i, Z∗), for i ∈ [n], be true iff (g(i) = zi∧Z∗(zi) =
1) ∨ (g(i) = ¯zi ∧ Z∗(zi) = 0) ∨ g(i) = 1
4. inf ← +∞, sup ← −∞, f ← 0
5. for Z∗ ∈ B|Z| do
6.
Q(X, Z∗) ← V
i∈[n]∧c(i,Z∗) Ci(X, Z∗)
7.
if feasible(Q(X, Z∗)) then
8.
f ← 1
9.
M ← optimalValue(max, x, Q(X, Z∗))
10.
m ← optimalValue(min, x, Q(X, Z∗))
11.
if M = ∞ ∨ m = ∞ then
12.
return ⟨UNBND, ⊥, ⊥⟩
13.
sup ← max(sup, M), inf ← min(inf, m)
14. if f then
15.
return ⟨BND, inf, sup⟩
16. else
17.
return ⟨INFEAS, ⊥, ⊥⟩
save unnecessary MILP invocations. Differently from Algo-
rithm 3, Algorithm 4 works only in the case that the input
is a positive guarded predicate of form G(X, ˜Z) ∧ D(Z),
where G(X, ˜Z) is a positive guarded predicate, D(Z) is a
conjunctive predicate, and ˜Z ⊆ Z is the set of (boolean)
variables occurring as guards in G(X, ˜Z). However, such
form may be derived from the one output by Algorithm 2
(see Algorithm 5), thus we still have a method to translate
any predicate into a conjunctive predicate.
Algorithm 4 is based on the observation that, if an
assignment Z∗
1 makes true more guards than an assignment
Z∗
2, then the conjunctive predicate G(X, Z∗
1) has more
constraints than G(X, Z∗
2). Therefore, if x is bounded in
G(X, Z∗
2), then it is also bounded in G(X, Z∗
1), and if
G(X, Z∗
2) is unfeasible, then also G(X, Z∗
1) is unfeasi-
ble (Proposition 10). In the following, we establish the
correctness of function computeBounds. We begin with a
proposition on ﬁxing boolean values in a positive guarded
predicate.
V Proposition 10: Let Z = [z1, . . . , zn] and let G(X, Z) =
i∈[n](zi → Ci(X)) be a conjunction of positive guarded
constraints. Then:
1) For any Z∗ ∈Bn, G(X, Z∗) is equivalent to the con-
junctive predicate V
j∈Ones(Z∗)Cj(X).
2) If Z∗
1 ≤ Z∗
2, then G(X, Z∗
2)⇒G(X, Z∗
1).
Proof: Statement 1 easily follows by observing that a
guarded constraint z → C(X) is trivially satisﬁed if z is
assigned to 0 and it is equivalent to C(X) if z is assigned
to 1. Statement 2 follows from the observation that a ≤ b
implies Ones(a) ⊆ Ones(b) and hence G(X, b) has more
constraints than G(X, a).
Algorithm 4 is based on the capability of operating cuts
on the boolean space. Deﬁnition 4 formalizes this concept.
Deﬁnition 4: We say that a set C ⊆ Bn is a cut if for all
b ∈ Bn we have b ≤ C or b ≥ C. Let D(Z) be a predicate
over a set boolean variables Z = Z1 ∪ Z2. A cut C ⊆ B|Z2|
is (D, Z2)-minimal if
• for all c ∈ C, D(Z1, c), is satisﬁable
• for all b < C, D(Z1, b) is not satisﬁable.
Proposition 11 shows how cuts are exploited by Algo-
rithm 4. Namely, to verify that a variable x is bounded in the
positive guarded predicate G(X, ˜Z)∧D(Z), where D(Z) is
a conjunctive predicate, it sufﬁces to check if it is bounded in
the conjunctive predicate G(X, c), for all c that are (D, ˜Z)-
minimal cuts.
Algorithm 4 Computing variable bounds in a positive
guarded predicate (auxiliary for Algorithms 5 and 6)
Input: Positive guarded predicate G(X, ˜Z), conjunctive
predicate D(Z) with ˜Z ⊆ Z set of guards in G(X, ˜Z),
and variable x ∈ X.
Output: ⟨µ, inf, sup⟩ with µ ∈ {BND, UNBND, INFEAS},
inf, sup ∈ Dx∪ ⊥.
function computeBounds(G, D, X, Z, ˜Z, x)
1. C ←∅, r←| ˜Z|, inf ←+∞, sup←−∞, f ← 0
2. r′ ←optimalValue(min, P
i∈[r] zi, D(Z))
3. r′′ ←optimalValue(max, P
i∈[r] zi, D(Z))
4. for k = r′ to r′′ do
5.
end ← 1
6.
for all b ∈ Br
k do
7.
if C ̸≤b then
8.
end ← 0
9.
if feasible(D(Z, c)) then
10.
C
163
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Proposition 11: Let Q(X, Z) = G(X, ˜Z)∧D(Z), where
G(X, ˜Z) is a positive guarded predicate, D(Z) is a conjunc-
tive predicate, and ˜Z ⊆ Z is the set of (boolean) variables
occurring as guards in G(X, ˜Z). Let C be a (D, ˜Z)-minimal
cut and x ∈ X. If, for all c ∈ C, x is bounded in G(X, c),
then x is bounded in Q(X, Z).
Proof: Since C is a (D, ˜Z)-minimal cut, any sat-
isfying assignment (X∗, Z∗) to Q is such that C
≤
˜Z∗. As a consequence, there exists c ∈ C such that
c ≤
˜Z∗. Proposition 10 (point 2) implies that, for all
Z∗ ≥ C, max{x | G(X, Z∗)} ≤ max{x | G(X, c)} and
min{x | G(X, Z∗)} ≥ min{x | G(X, c)}. Therefore, if x
is bounded in Q(X, c) for any c ∈ C, then it is bounded in
Q(X, Z).
Stemming from Proposition 11, function computeBounds
(Algorithm 4) checks if a variable x is bounded in a
guarded predicate by ﬁnding a minimal cut. To limit the
search space, in line 2 (resp. line 3) it is computed the
minimum (resp. maximum) number of 1 that a satisfying
assignment to the predicate D(Z) must have. The loop in
lines 4–18 examines possible assignments to guard variables
in Z, keeping the invariant ∀b < C[¬feasibleG(X, b)] ∧
∀b ≥ C[max{x | G(X, Z)} ≤ max{x | G(X, b)} ∧
min{x | G(X, Z∗)} ≥ min{x | G(X, b)}]. In the loop
in lines 6–17, if the assignment c under consideration is
greater than an assignment in C, no further investigation
are needed (by Proposition 11 x is bounded in Q(X, c)). If
D(Z \ ˜Z, b) is unfeasible, the assignment c is not relevant,
because c ≤ C, for any (D, ˜Z)-minimal cut C. Otherwise, c
is a relevant assignment and it is added to C (line 10). If x is
unbounded in Q(X, c) (lines 13 and 16) we can immediately
conclude that x is unbounded in Q(X, Z). Otherwise, we
update the approximations computed for inf(x) and sup(x)
(line 17). If for all assignments in c ∈ Bn
k we have c ≥ C
(Bn
k is a cut) we are done, C is a (D, ˜Z)-minimal cut, and
inf and sup computed so far are over-approximation of x
bounds in Q(X, Z) (line 18).
The above reasoning gives the proof of correctness for
function computeBounds of Algorithm 4.
Proposition 12: Let G(X, ˜Z) be a positive guarded pred-
icate, D(Z) be a conjunctive predicate, where ˜Z is the set
of guards in G(X, ˜Z) and ˜Z ⊆ Z, and let x ∈ X. Then
function computeBounds of Algorithm 4 returns:
• ⟨UNBND, ⊥, ⊥⟩ if G(X, ˜Z) ∧ D(Z) is unbounded in
x;
• ⟨INFEAS, ⊥, ⊥⟩ if G(X, ˜Z) ∧ D(Z) is unfeasible;
• ⟨BND, a, b⟩ if G(X, ˜Z) ∧ D(Z) is bounded, where a, b
are such that G(X, ˜Z) ∧ D(Z) implies a ≤ x ≤ b.
Example 4: In Example 3 we assumed bounds for each
variable in the DTLHS H introduced in Example 1. Such
bounds has been obtained by ﬁxing bounds for state vari-
ables iL and vO and for auxiliary variables iu, vu, vD and
iD, and then by computing bounds for variables i′
L, v′
O using
Algorithm 4.
Algorithm 5 From predicates to conjunctive predicates
Input: P predicate over X and modality ν ∈ {EXH, CUT}
Output: result µ and conjunctive predicate C(X, Z) such
that C(X, Z) is X-equivalent to P(X) if P(X) is
bounded.
function PtoC(P, X, ν)
1. ⟨G, D, Z, ˜Z⟩ ←PtoG(P, X)
2. ˜D ←GtoC(D, Z, 0, 1)
3. for all x ∈ X do
4.
if ν = CUT then
5.
⟨µ, mx, Mx⟩ ←computeBounds(G, ˜D, X, Z, ˜Z, x)
6.
else
7.
⟨µ, mx, Mx⟩
←exhComputeBounds(G(X, ˜Z) ∧
˜D(Z), X ∪ Z, x)
8.
if µ ̸= BND then
9.
return ⟨µ, ⊥⟩
10. return ⟨BND, GtoC(G, X ∪ Z, m, M)⟩
Function PtoC
of Algorithm 5 presents the overall
procedure that translates a bounded predicate P(X) into
an X-equivalent conjunctive predicate C(X, Z). Function
PtoC
calls functions in Algorithms 1–4 and function
GtoC(A, W, m, M), which translates a bounded guarded
predicate A(W) with known lower bounds m and upper
bounds M for variables in W in a conjunctive predicate,
as shown in the proof of Proposition 8. As a ﬁrst step,
Algorithm 5 translates the input predicate P(X) into an X-
equivalent guarded predicate G(X, ˜Z) ∧ D(Z) by calling
the function PtoG (line 1). Since boolean variables are
trivially bounded (bounds are vectors 0 = ⟨0, . . . , 0⟩ and
1 = ⟨1, . . . , 1⟩), the guarded predicate D can be translated
into a conjunctive predicate ˜D by calling the function GtoC
on D (line 2). To apply function GtoC on G(X, ˜Z), we need
bounds for each variable in X. These bounds are computed
by calling |X| times the function computeBounds and are
stored in the two arrays m, M (lines 3 and 5). If the function
computeBounds ﬁnds that ˜G is unfeasible or some x is
not bounded in ˜G (line 8), the empty constraint is returned
together with the failure explanation (line 9). Otherwise, the
desired conjunctive predicate is returned in line 10.
Correctness of function PtoC of Algorithm 5 is stated in
Proposition 13.
Proposition 13: Let P(X) be a predicate. Then function
PtoC of Algorithm 5 returns:
• ⟨UNB, ⊥⟩ if P(X) is unbounded for some x ∈ X;
• ⟨INFEAS, ⊥⟩ if P(X) is unfeasible;
• ⟨BND, C(X, Z)⟩ if P(X) is bounded, being C(X, Z) a
conjunctive predicate which is X-equivalent to P(X).
Proof: The proof easily follows Propositions 5, 7, 8
and 12.
We end this section by proposing a syntactic check, that
most of the time may be used to compute variable bounds

164
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
avoiding to use the function computeBounds.
Deﬁnition 5: A variable x is explicitly bounded in a pred-
icate P(X), if P(X) = B(x) ∧ ˜P(X), where B(x) = x ≤
b ∧ x≥a, for some constants a and b.
Proposition 14: Let H=(X, U, Y, N) be a DTLHS such
that each variable v∈X ∪U ∪Y is explicitly bounded in N,
and for all x′ ∈X′ there are in N at least two constraints of
the form x′ ≥ L1(X, U, Y ) and x′ ≤ L2(X, U, Y ). Then N
is bounded.
Proof: Since all variables in X, U, and Y are explicitly
bounded in N, they are also bounded in N. Therefore
inf(L1(X, U, Y )) and sup(L2(X, U, Y )) are ﬁnite. Since N
is guarded, it is a conjunction of guarded constraints and
for all x′ ∈ X′ it can be written as x′ ≥ L1(X, U, Y ) ∧
x′ ≤ L2(X, U, Y ) ∧ ˜N(X, U, Y, X′) for a suitable guarded
predicate
˜N. This implies inf(L1(X, U, Y ))
≤
x′
≤
sup(L2(X, U, Y )), which in turn implies that x′ is bounded
in N.
Example 5: Let H1 be the DTLHS ({x}, {u}, ∅, N1),
where N1(x, u, x′) = (0 ≤ x ≤ 3)∧(0 ≤ u ≤ 1)∧(x′ = x+
3u). By Proposition 14, H1 is bounded with inf(x′) = 0 and
sup(x′) = 6. All other variables are explicitly bounded in N.
Explicit bounds on present state and input variables do not
imply that next state variables are bounded. As an example,
let us consider the DTLHS H2 = ({x}, {u}, ∅, N2), where
N2(x, u, x′) = (0 ≤ x ≤ 3) ∧ (0 ≤ u ≤ 1) ∧ (x′ ≥ x + 3u).
Since, for any value of x and u, x′ can assume arbitrary
large values, we have that N2 is not bounded.
VI. GUARDED PREDICATES AS MODELING LANGUAGE
The disjunction elimination procedure given in Algorithm 5
returns a guarded predicate that may contain a large number
of fresh auxiliary boolean variables and this may heavily
impact on the effectiveness of control software synthesis
or veriﬁcation (as well as the complexity of Algorithm 5
itself, since the auxiliary Algorithm 4 depends on the number
of guard variables). On the other hand, guarded predicates,
which are used as an intermediate step in Algorithm 5, are
themselves a natural language to describe DTLHS behavior:
assignments to guard variables play a role similar to modes
in hybrid systems and, by using negative literals as guards,
we can naturally model different kinds of plant behavior
according to different commands sent by actuators.
Example 6: By directly using guarded predicates as mod-
eling language, the DTLHS of Example 1 may be modeled
by the conjunction of guarded constraints (43)–(52).
i′
L
=
(1 + Ta1,1)iL + Ta1,2vO + Ta1,3vD
(43)
v′
O
=
Ta2,1iL + (1 + Ta2,2)vO + Ta2,3vD.
(44)
vD = vu − Vi
(45)
iD = iL − iu
(46)
u→vu =0
(47)
¯u→vu =Roﬀiu
(48)
q →vD =0
(49)
q →iD ≥0
(50)
¯q →vD =RoﬀiD
(51)
¯q →vD ≤0
(52)
Algorithm 6 From guarded predicates to conjunctive pred-
icates
Input: G(X, Z) guarded predicate over X with guards in
Z and modality ν ∈ {EXH, CUT}.
Output: result µ and conjunctive predicate C(X, Z) such
that C(X, Z) is X-equivalent to G(X, Z) if G(X, Z)
is bounded.
function GPtoC(G, X, Z, ν)
1. let G and g be as in lines 1–2 of Algorithm 3
2. if ν = CUT then
3.
ˆZ ← {z ∈ Z | ∃i : g(i) = ¯z ∨ g(i) = z} ∪ {˜z ∈
Z | ∃i : g(i) = ¯z}
4.
Z ← Z ∪ {˜z ∈ Z | ∃i : g(i) = ¯z}
5.
G(X, ˆZ)
←
V
i∈[n]∧g(i)=zi g(i)
→
Ci(X, Z) ∧
V
i∈[n]∧g(i)=¯zi ˜zi → Ci(X, Z)
6.
D(Z)
←
V
i∈[n]∧g(i)=1 Ci(X, Z)
∧
V
z∈Z∧∃i:g(i)=¯z ˜z + z = 1
7. for all x ∈ X do
8.
if ν = CUT then
9.
⟨µ, mx, Mx⟩ ←computeBnds(G, D, X, Z, ˆZ, x)
10.
else
11.
⟨µ, mx, Mx⟩ ←exhComputeBounds(G, X, Z, x)
12.
if µ ̸= BND then
13.
return ⟨µ, ⊥⟩
14. return ⟨BND, GtoC(G, X ∪ Z, m, M)⟩
Note that disjunctions (7)–(9) in Example 1 have been re-
placed by guarded constraints (47)–(52). The resulting model
for the buck DC-DC converter is much more succinct than
the guarded model in Example 2 and it has 2 guard vari-
ables only, rather than 6 as in Example 2 (and 10 guarded
constraints rather than 15).
Algorithm 4 cannot be directly applied to guarded predi-
cates with both positive and negative guard literals. This ob-
struction can be easily bypassed, by observing that a guarded
constraint ¯z → C(X) is (X ∪{z})-equivalent to the positive
guarded predicate (˜z → C(X)) ∧ (˜z + z = 1). On the other
hand, guarded predicates with both positive and negative
guard literals may be directly translated in a conjunctive
predicate by using the exhaustive procedure in Algorithm 3
to compute variable bounds. Both such translations are out-
lined in function GPtoC of Algorithm 6. Namely, if ν =
CUT then the input guarded predicate is translated in a pos-
itive guarded predicate and then Algorithm 4 is used. Oth-
erwise, i.e., if ν = EXH then the exhaustive Algorithm 3 is
used directly on the original guarded predicate. Note that the
above described method to obtain a positive guarded pred-
icate from a guarded predicate (lines 3–6 in Algorithm 6)
doubles the number of variables originally used as negative
guards. Thus, it turns out that it is more convenient to call
function GPtoC with ν = EXH (see experimental results in
Section VII).

165
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Summing up, guarded predicates turn out to be a pow-
erful and natural modeling language for describing DTLHS
transition relations.
VII. EXPERIMENTAL RESULTS ON A CASE STUDY
In this section, we evaluate the effectiveness of our predi-
cate translation functions, i.e., function PtoC of Algorithm 5
and function GPtoC of Algorithm 6. To this end, we im-
plemented such functions in C programming language, us-
ing GLPK to solve MILP problems. We name the resulting
tools PTOC (Predicates to Conjunctive predicates transla-
tor) and GPTOC (Guarded Predicates to Conjunctive pred-
icates translator). We will write calls to functions PtoC
(resp. GPtoC) with ν = ˜ν as PTOC(˜ν) (resp., GPTOC(˜ν)).
PTOC and GPTOC are part of a more general tool named
Quantized feedback Kontrol Synthesizer (QKS) [8][9].
We present the experimental results obtained by using
PTOC and GPTOC on a n-inputs buck DC-DC converter
(described in Section VII-A), that we model with two
DTLHSs Hi = (Xi, Ui, Yi, Ni), with i ∈ [2], such that
X1 = X2, U1 = U2, Y1 ⊂ Y2, N1(X1, U1, Y1, X′
1) is a
predicate, and N2(X2, U2, Y2, X′
2) is a guarded predicate
(X1 ∪U1 ∪Y1 ∪X′
1)-equivalent to N1. All experiments have
been carried out on a 3.00GHz Intel Xeon hyperthreaded
Quad Core Linux PC with 8GB of RAM.
We run PTOC on N1 and GPTOC on N2 for increas-
ing values of n (which entails that the number of guards
increases), in order to show effectiveness of PTOC and GP-
TOC. To this end, both values for parameter ν will be used,
which means that, for each n, 4 experiments are run. In
Section VII-B we show experimental results PTOC. Further-
more, in Section VII-C we show that results obtained with
GPTOC(EXH) are better than those obtained with both GP-
TOC(CUT) and PTOC. That is, the best results are obtained
by exploiting knowledge of the system and modeling it with
guarded predicates, and then using the exhaustive algorithm.
A. Multi-Input Buck DC-DC Converter
A Multi-Input Buck DC-DC Converter [18] (Figure 2),
consists of n power supplies with voltage values V1 <. . .<
Vn, n switches with voltage values vu
1 , . . . , vu
n and current
values Iu
1 , . . . , Iu
n, and n input diodes D0, . . . , Dn−1 with
voltage values vD
0 , . . . , vD
n−1 and current values iD
0 , . . . , iD
n−1
(in the following, we will also write vD for vD
0 and iD for
iD
0 ). As for the converter in Example 1, the state variables
are iL and vO, whereas action variables are u1, . . . , un, thus
a control software for the n-input buck DC-DC converter has
to properly actuate the switches u1, . . . , un. Constant values
are the same given in Example 3.
B. Multi-Input Buck as a Predicate
We
model
the
n-input
buck
DC-DC
converter
with
the
DTLHS
H1
=
(X1, U1,
Y1, N1),
where
X1
=
[iL, vO],
U1
=
[u1, . . . , un],
and
R
+vO
L
iD
Vn
Vn−1
Vi
V1
Iun
Iu
n−1
Iu
i
+vun
un
D0
D1
Di
Dn−1
iL
rL
+vC
C
rC
iC
+vu
i
un−1
ui
+vD
...
...
Iu
1
+vD
1
+vD
i
+vu
n−1
+vD
n−1
+vu
1
u1
Figure 2.
Multi-input Buck DC-DC converter
Y1
=
[vD, vD
1 , . . . , vD
n−1, iD, Iu
1 , . . . , Iu
n, vu
1 , . . . , vu
n].
From a simple circuit analysis (e.g., see [17]), we have that
N1 is the conjunction of linear predicates (53)–(61).
i′
L
=
(1 + Ta1,1)iL + Ta1,2vO + Ta1,3vD
(53)
v′
O
=
Ta2,1iL + (1 + Ta2,2)vO + Ta2,3vD.
(54)
((iD ≥ 0) ∧ (vD = 0)) ∨ ((iD ≤ 0) ∧ (vD = RoﬀiD))
(55)
^
i∈[n]
(ui =0) ∨ (vu
i =0)
(56)
^
i∈[n]
(ui =1) ∨ (vu
i =RoﬀIu
i )
(57)
^
i∈[n−1]
((Iu
i ≥0) ∧ (vD
i =0)) ∨ ((Iu
i ≤0) ∧ (vD
i =RoﬀIu
i ))
(58)
iL =iD+
n
X
i=1
Iu
i
(59)
^
i∈[n−1]
vD =vu
i +vD
i −Vi
(60)
vD =vu
n−Vn
(61)
N1 also contains the following explicit bounds: −4≤iL ≤
4 ∧ −1 ≤ vO ≤ 7∧ −103 ≤ iD ≤ 103 ∧ Vn
i=1−103 ≤ Iu
i ≤
103 ∧ Vn
i=1 −107 ≤ vu
i ≤ 107 ∧ Vn−1
i=0 −107 ≤ vD
i ≤ 107.

166
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Table I
PTOC PERFORMANCE (PREDICATES)
n
r
r′
r′′
k
|cut|
CPUc
Memc
CPUe
Meme
|In|
|Out|
2
12
6
12
11
64
1.07e+00
5.14e+07
3.07e+01
5.14e+07
21
44
3
18
9
18
17
512
9.63e+01
5.15e+07
2.92e+03
5.14e+07
30
63
4
24
12
24
23
4096
1.15e+04
5.15e+07
>1.38e+06
N/A
39
82
We run PTOC(CUT) with parameters N1, X1∪U1∪Y1∪X′
1
for increasing values of n, and we compare its computation
time with that of PTOC(EXH) with the same input param-
eters. Table I shows our experimental results. In Table I,
columns meaning are as follows:
• column n shows the number of buck inputs;
• column r shows the number of guards (see line 1 of
Algorithm 4);
• columns r′, r′′ have the meaning given in lines 2 and 3
of Algorithm 4;
• column k gives the value of k at the end of the outer
for loop of Algorithm 4;
• column |cut| gives the size of cut at the end of the for
loop of Algorithm 4;
• columns CPUc and Memc (resp. CPUe and Meme)
show the computation time in seconds and memory
usage in bytes of PTOC(CUT) (resp., of PTOC(EXH))
• column |In| shows the size of the input predicate, as the
number of linear constraints (i.e., of the linear predicate
atoms) in the input linear predicate N1;
• column |Out| shows the size of the output conjunctive
predicate, as the resulting number of linear constraints
in the output conjunctive predicate.
C. Multi-Input Buck as a Guarded Predicate
We modify the DTLHS H1 of Section VII-B by deﬁn-
ing H2 = (X2, U2, Y2, N2), where X2 = X1, U2 = U1,
Y2 = Y1 ∪ Y ′
2 = Y1 ∪ {q0, . . . , qn−1} and N2 is obtained
from N1 by replacing disjunctions (55)–(58) with guarded
constraints. Thus, N1 is given by the conjunction of guarded
constraints (62)–(76).
i′
L
=
(1 + Ta1,1)iL + Ta1,2vO + Ta1,3vD
(62)
v′
O
=
Ta2,1iL + (1 + Ta2,2)vO + Ta2,3vD.
(63)
q →vD =0
(64)
q →iD ≥0
(65)
¯q →vD =RoﬀiD
(66)
¯q →vD ≤0
(67)
^
i∈[n−1]
qi →vD
i =0
(68)
^
i∈[n−1]
qi →Iu
i ≥0
(69)
^
i∈[n]
ui →vu
i =0
(70)
^
i∈[n−1]
¯qi →vD
i ≤0 (71)
^
i∈[n−1]
¯qi →vD
i =RoﬀIu
i
(72)
^
i∈[n]
¯ui →vu
i =RoﬀIu
i
(73)
iL =iD+
n
X
i=1
Iu
i
(74)
^
i∈[n−1]
vD =vu
i +vD
i −Vi
(75)
vD =vu
n−Vn
(76)
We call both GPTOC(CUT) and GPTOC(EXH) with pa-
rameters N2, X2 ∪ U2 ∪ Y2 ∪ X′
2 for increasing values of n,
and we compare their computation times.
Table II shows our experimental results. Columns mean-
ing in Table II are the same as of Table I. An additional
column |Y2| shows the number of guard variables in N2.
D. Evaluation
Results in Table I show that heuristics implemented in
function computeBounds are indeed effective w.r.t. execut-
ing function exhComputeBounds. In fact, by comparing
columns CPUc and CPUe (and recalling that the only differ-
ence between PTOC(CUT) shown in CPUc and PTOC(CUT)
shown in CPUe is that the former calls function compute-
Bounds whilst the latter calls function exhComputeBounds),
we see that such heuristics provide at least a one-order-of-
magnitude speed-up in variable bounds computation. Such
speed-up rapidly grows with the size of the input. In fact,
for the 4-bits buck DC-DC converter, PTOC(EXH) requires
more than 2 weeks, whilst PTOC(CUT) terminates in about
3 hours. Moreover, we also note that the resulting number
of linear constraints output by PTOC is at most twice the
starting number of linear constraints.
PTOC(CUT) is however not effective on the n-input buck
DC-DC converter for n ≥ 5. In fact, for n = 5, there are
30 boolean guards (i.e., r = 30), and the heuristics do not
provide enough speed-up to obtain termination in a reason-
able time. However, if we directly use guarded predicates as
input language as in Section VII-C, we are able to generate
the conjunctive predicate for both n = 5 and n = 6. This
is due to the smaller number of guard variables used in
Section VII-C than that used in Section VII-B. The negative
impact of auxiliary boolean variables is clearly showed by
the fact that GPTOC(EXH), much slower than GPTOC(CUT)
on a model of the same size, performs better than GP-
TOC(CUT) in this case, because it can work on a model with
half of the variables (see columns |Y2| and r). The same
holds if we compare results of GPTOC(EXH) with those
of PTOC(EXH) and PTOC(CUT). This phenomenon would
be greatly ampliﬁed in a veriﬁcation or control software
synthesis procedure. These results strongly support guarded
predicates as modeling language.

167
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Table II
GPTOC PERFORMANCE (GUARDED PREDICATES)
n
|Y2|
r
r′
r′′
k
|cut|
CPUc
Memc
CPUe
Meme
|In|
|Inpos|
|Out|
2
4
8
4
4
4
16
2.80e-01
5.14e+07
2.50e-01
5.14e+07
17
21
38
3
6
12
6
6
6
64
9.70e-01
5.15e+07
9.70e-01
5.15e+07
24
30
54
4
8
16
8
8
8
256
1.04e+01
5.16e+07
3.41e+00
5.15e+07
31
39
70
5
10
20
10
10
10
1024
1.75e+02
5.17e+07
1.69e+01
5.16e+07
38
48
86
6
12
24
12
12
12
4096
2.55e+03
5.17e+07
8.57e+01
5.17e+07
45
57
102
VIII. RELATED WORK
This paper is an extended version of [1]. With respect
to [1], this paper provides more details in the introduction
and in the related work description, extends basic deﬁnitions
and algorithms descriptions, gives more detailed proofs for
theorems, and provides a revised and enriched version of the
experiments.
MILP
problems
solving
based
abstraction
techniques
have
been
designed
for
the
veriﬁcation
of
Discrete Time Hybrid Automata (DHA)
[5]
and
implemented within the symbolic model checker HYSDEL
[19]. A MILP based DTLHS abstraction algorithm is the
core of automatic control software synthesis from system
level speciﬁcations in [8][9], and it requires DTLHS
dynamics modeled as a conjunctive predicate. The same
limitation
occurs
in
abstraction
techniques
based
on
the Fourier-Motzkin procedure for existential quantiﬁer
elimination [20]. All such approaches may exploit the
translation algorithm presented here in order to improve
their applicability.
Automatic or automatable translation procedures targeting
MILP formulations have been presented in [21] and [22].
Namely, in [22] the authors propose an approach to trans-
late (reformulate in their parlance) mixed integer bilinear
problems (i.e., problems in which constraints may contain
products of a nonnegative integer variable and a nonnegative
continuous variable) into MILP problems. This reformula-
tion is obtained by ﬁrst replacing a general integer variable
with its binary expansion and then using McCormick en-
velopes to linearize the resulting product of continuous and
binary variables. In [21], the authors present an automatic
conversion from deterministic ﬁnite automata to MILP for-
mulations. This allows to efﬁciently combine supervisory
control theory and MILP to automatically generate time-
optimal, collision-free and non-blocking working schedules
for a ﬂexible manufacturing system. Both these works differ
from ours in the starting point of the translation procedure
(and of course in the actual algorithms designed): in [21]
they are interested in translating deterministic ﬁnite au-
tomata, whilst in [22] the goal is to translate mixed integer
bilinear problems. On the other hand, in this paper we are
interested in translating conjunctions and disjunctions of
linear constraints (see Section II-A), thus the approaches
in [21][22] cannot be used in our context.
Many works in the literature deal with automatic spec-
iﬁcation of MILP problems in order to solve customized
synthesis problem. As an example, in [23] the target is a
formal synthesis approach to design of optimal application-
speciﬁc heterogeneous multiprocessor systems. As a further
example, in [24], a topology synthesis method for high
performance System-on-Chip design is presented. Finally,
in [25] the development of a technique to target fresh
water consumption and wastewater generation for systems
involving multiple contaminants is presented. In this paper,
rather than giving a MILP scheme to be properly customized
to solve a problem of a given type, we provide a translation
from a general-purpose predicate to an equivalent MILP
problem.
Finally, we note that the automatic procedure presented
in this paper is reminiscent of Mixed Integer Program-
ming modeling techniques [26] in Operations Research and
boolean formula transformations involved in the conver-
sion of a formula into a conjunctive or disjunctive normal
form [6][27].
IX. CONCLUSIONS AND FUTURE WORK
The results presented in this paper contribute to model
based design of SBCS (most notable, of embedded software)
by proposing an expressive modeling language for DTLHS.
In fact, in our previous work MILP based approaches
have been used to synthesize correct-by-construction control
software for DTLHSs. However, such approaches require
DTLHS dynamics to be modeled as a conjunctive linear
predicate over state, input, and next state variables. This
may turn out to be not practically feasible for DTLHSs with
complex dynamics.
In this paper, we circumvented such a limitation, by giv-
ing an automatic procedure that translates any disjunction-
conjunction of linear constraints into an equisatisﬁable con-
junctive predicate, provided that each variable ranges over a
bounded interval. This last proviso is automatically enforced
by our procedure, since it includes a routine algorithm that,
taking a linear predicate P and a variable x, veriﬁes if x
is bounded in P, by computing (an over-approximation of)
bounds for x.
Finally, our experimental results show the effectiveness
of our approach on an important and challenging case study

168
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
taken from the literature, namely the multi-input Buck DC-
DC Converter. As an example, the linear predicate that
models a 4-inputs buck DC-DC converter with 39 linear con-
straints is translated into a conjunctive predicate of 82 linear
constraints in slightly more than 3 hours. Most notably, our
experimental results show that guarded predicates, which
are used by our translation procedure as an intermediate
language, turn out to be a natural language to succinctly
describe DTLHS dynamics. In fact, the guarded predicate
that models a 6-inputs Buck DC-DC Converter with 57
constraints (including 12 different guards), is translated into
a conjunctive predicate of 102 linear constraints in about 40
minutes.
The presented approach has the main drawback to be
exponential on the number of boolean guards used in the
(initial or intermediate) guarded predicate. As a future work,
we aim to counteract such a limitation by recognizing if the
input predicate is of some known structure. As an example,
if the guarded predicate is composed by k blocks of the same
structure, we may translate just one of such blocks and then
suitably copy the resulting conjunctive predicate k times.
ACKNOWLEDGMENTS
Our work has been partially supported by: MIUR project
DM24283 (TRAMP) and by the EC FP7 projects GA600773
(PAEON) and GA317761 (SmartHG).
ACRONYMS
AD
Analog-to-Digital. 1
DA
Digital-to-Analog. 1
DC
Direct Current. 4
DHA Discrete Time Hybrid Automata. 12
DTLHS Discrete Time Linear Hybrid System. 1, 2, 4, 6,
7, 9–13
DVFS Dynamic Voltage and Frequency Scaling. 4
MILP Mixed Integer Linear Programming. 1–4, 7, 10, 12,
13
NFSA Nondeterministic Finite State Automaton. 1
QKS
Quantized feedback Kontrol Synthesizer. 10
SBCS Software Based Control System. 1
REFERENCES
[1] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “Linear constraints
as a modeling language for discrete time hybrid systems,” in
ICSEA, 2012, pp. 664–671.
[2] T. A. Henzinger and J. Sifakis, “The embedded systems
design challenge,” in FM, ser. LNCS 4085, 2006, pp. 1–15.
[3] R. Alur, C. Courcoubetis, N. Halbwachs, T. A. Henzinger,
P. H. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine,
“The algorithmic analysis of hybrid systems,” Theoretical
Computer Science, vol. 138, no. 1, pp. 3 – 34, 1995.
[4] R. Alur, T. A. Henzinger, and P.-H. Ho, “Automatic symbolic
veriﬁcation of embedded systems,” IEEE Trans. Softw. Eng.,
vol. 22, no. 3, pp. 181–201, 1996.
[5] A. Bemporad and M. Morari, “Veriﬁcation of hybrid systems
via mathematical programming,” in HSCC, ser. LNCS 1569,
1999, pp. 31–45.
[6] F. Mari and E. Tronci, “CEGAR based bounded model
checking of discrete time hybrid systems,” in HSCC, ser.
LNCS 4416, 2007, pp. 399–412.
[7] V. Alimguzhin, F. Mari, I. Melatti, I. Salvo, and E. Tronci,
“Automatic control software synthesis for quantized discrete
time hybrid systems,” in CDC.
IEEE, 2012, pp. 6120–6125.
[8] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “Synthesis of
quantized feedback control software for discrete time linear
hybrid systems,” in CAV, ser. LNCS 6174, 2010, pp. 180–195.
[9] ——, “Model based synthesis of control software from
system level formal speciﬁcations,” ACM Trans. on Soft.
Eng.
and
Meth.,
vol.
To
appear.
[Online].
Available:
http://mclab.di.uniroma1.it/publications/papers/federicomari/
2013/110_FedericoMari2013.pdf
[10] ——, “Undecidability of quantized state feedback control for
discrete time linear hybrid systems,” in Proceedings of the
International Colloquium on Theoretical Aspects of Comput-
ing, ICTAC, ser. LNCS, A. Roychoudhury and M. D’Souza,
Eds., vol. 7521.
Springer-Verlag Berlin Heidelberg, 2012,
pp. 243–258.
[11] ——, “Synthesizing control software from boolean relations,”
Int. J. on Advances in SW, vol. 5, no. 3&4, pp. 212–223, 2012.
[12] “Gnu GLPK Web Page: http://www.gnu.org/software/glpk/,”
last accessed 6 mar 2013.
[13] “CPLEX
Web
Page:
http://www-
01.ibm.com/software/integration/optimization/cplex-
optimization-studio/,” last accessed 6 mar 2013.
[14] W. Kim, M. S. Gupta, G.-Y. Wei, and D. M. Brooks, “En-
abling on-chip switching regulators for multi-core processors
using current staggering,” in ASGI, 2007.
[15] W.-C. So, C. Tse, and Y.-S. Lee, “Development of a fuzzy
logic controller for dc/dc converters: design, computer simu-
lation, and experimental evaluation,” IEEE Trans. on Power
Electronics, vol. 11, no. 1, pp. 24–32, 1996.
[16] V. Yousefzadeh, A. Babazadeh, B. Ramachandran, E. Alar-
con, L. Pao, and D. Maksimovic, “Proximate time-optimal
digital control for synchronous buck dc–dc converters,” IEEE
Trans. on Power Electronics, vol. 23, no. 4, pp. 2018–2026,
2008.
[17] P.-Z. Lin, C.-F. Hsu, and T.-T. Lee, “Type-2 fuzzy logic
controller design for buck dc-dc converters,” in FUZZ, 2005,
pp. 365–370.
[18] M. Rodriguez, P. Fernandez-Miaja, A. Rodriguez, and J. Se-
bastian, “A multiple-input digitally controlled buck converter
for envelope tracking applications in radiofrequency power
ampliﬁers,” IEEE Trans. on Power Electronics, vol. 25, no. 2,
pp. 369–381, 2010.

169
International Journal on Advances in Software, vol 6 no 1 & 2, year 2013, http://www.iariajournals.org/software/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[19] F. Torrisi and A. Bemporad, “HYSDEL — A tool for gener-
ating computational hybrid models for analysis and synthesis
problems,” IEEE Transactions on Control System Technology,
vol. 12, no. 2, pp. 235–249, 2004.
[20] S. K. Jha, B. H. Krogh, J. E. Weimer, and E. M. Clarke,
“Reachability for linear hybrid automata using iterative re-
laxation abstraction,” in HSCC, ser. LNCS 4416, 2007, pp.
287–300.
[21] A. Kobetski and M. Fabian, “Scheduling of discrete event
systems using mixed integer linear programming,” in Discrete
Event Systems, 2006 8th International Workshop on, july
2006, pp. 76 –81.
[22] A.
Gupte,
S.
Ahmed,
M.
S.
Cheon,
and
S.
S.
Dey,
“Solving
mixed
integer
bilinear
problems
using
milp
formulations,”
SIAM
J.
on
Optimization,
vol.
To appear. [Online]. Available: http://www.optimization-
online.org/DB_FILE/2011/07/3087.pdf
[23] S. Prakash and A. C. Parker, “Readings in hardware/software
co-design,” G. De Micheli, R. Ernst, and W. Wolf, Eds.
Norwell, MA, USA: Kluwer Academic Publishers, 2002,
ch. SOS: synthesis of application-speciﬁc heterogeneous
multiprocessor systems, pp. 324–337. [Online]. Available:
http://dl.acm.org/citation.cfm?id=567003.567031
[24] M. Jun, S. Yoo, and E.-Y. Chung, “Mixed integer linear
programming-based optimal topology synthesis of cascaded
crossbar switches,” in Proceedings of the 2008 Asia and
South Paciﬁc Design Automation Conference, ser. ASP-
DAC ’08.
Los Alamitos, CA, USA: IEEE Computer
Society Press, 2008, pp. 583–588. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1356802.1356945
[25] Z. Handani, H. Hashim, S. Alwi, and Z. Manan, “A mixed
integer linear programming (milp) model for optimal design
of water network,” in Modeling, Simulation and Applied
Optimization (ICMSAO), 2011 4th International Conference
on, april 2011, pp. 1 –6.
[26] F. S. Hillier and G. J. Lieberman, Introduction to operations
research.
McGraw-Hill Inc., 2001.
[27] D. Sheridan, “The optimality of a fast cnf conversion and its
use with sat,” in SAT, 2004.

