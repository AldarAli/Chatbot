A Non-repetitive Logic for VeriÔ¨Åcation of Dynamic
Memory with Explicit Heap Conjunction and
Disjunction
Ren¬¥e Haberland
Kirill Krinkin
Saint Petersburg Electrotechnical University ‚ÄùLETI‚Äù
Saint Petersburg, Russia
email: haberland1@mail.ru, kirill.krinkin@fruct.org
Abstract‚ÄîIn this paper, we review existing points-to Separa-
tion Logics for dynamic memory reasoning and we Ô¨Ånd that
different usages of heap separation tend to be an obstacle. Hence,
two total and strict spatial heap operations are proposed upon
heap graphs, for conjunction and disjunction ‚Äì similar to logical
conjuncts. Heap conjunction implies that there exists a free
heap vertex to connect to or an explicit destination vertex is
provided. Essentially, Burstall‚Äôs properties do not change. By
heap we refer to an arbitrary simple directed graph, which
is Ô¨Ånite and may contain composite vertices representing class
objects. Arbitrary heap memory access is restricted, as well
as type punning, late class binding and further restrictions.
Properties of the new logic are investigated, and as a result
group properties are shown. Both expecting and superÔ¨Åcial
heaps are speciÔ¨Åable. Equivalence transformations may make
denotated heaps inconsistent, although those may be detected and
patched by the two generic linear canonization steps presented.
The properties help to motivate a later full introduction of a
set of equivalences over heap for future work. Partial heaps
are considered as a useful speciÔ¨Åcation technique that help
to reduce incompleteness issues with speciÔ¨Åcations. Finally, the
logic proposed may be considered for extension for the Object
Constraint Language.
Keywords. heap logic, points-to heap speciÔ¨Åcation and
veriÔ¨Åcation, spatial heap operation ambiguity.
I. INTRODUCTION
In contrast to automatically allocated memory, which re-
mains in the stack, dynamic memory refers to the main mem-
ory part that is altered by commands such as new, delete
and heap data assignments. The dynamic memory contains
heaps (see deÔ¨Ånition 2.1). Let us Ô¨Årst review a few important
deÔ¨Ånitions and discuss issues with heaps afterwards.
Jones et al. [1] deÔ¨Åne a heap as a contiguous subscripted
datastructure, and also, alternatively, as an organised graph
of ‚Äúdiscontiguous blocks of contiguous words‚Äù. All allocated
memory cells have a reference and the liveness of a cell is
deÔ¨Åned by its reachability. The liveness is independent from
the program statement that creates a dynamic memory cell.
Reynolds [2] deÔ¨Ånes heaps (not to be mixed up with a
single heap) as the union of all mappings of address subsets
to non-empty value cells. Following this deÔ¨Ånition a single
heap would be some addresses pointing to some arbitrary
data structure. Reynolds mentions his intention goes back
to Burstall‚Äôs model [3]. Both refer to trees as implied data
structure - which, at least in Burstall‚Äôs proposition, denotes a
simple heap graph (deÔ¨Ånition 2.2 formally introduces it, for
the moment let us assume it is an arbitrary graph where edges
represent some relationship between heap vertices) as for
instance the expression x
a1,a2,a3/ y denotes some path within
the heap graph in Fig. 1. The graph starts at x and stops at
a heap cell which is also pointed by some local variable y
by visiting a1, a2, a3, which all may have some unspeciÔ¨Åed
content on its way there. Reynolds introduces the ‚Äú‚ãÜ‚Äù-operator
for expressing that two heaps do not share common dynamic
memory regions. In contrast to Burstall Reynolds‚Äô model
is slightly different: all except the start of a path from a
stacked variable denotes its value rather its cell location. As
shown in the graph in Fig. 2 by convention it is agreed that
stacked variables, such as x1, only have outgoing edges, where
all other vertices, such as x2, x3, x4, x5, x6, x7, denote some
concrete heap cell values and may have zero or more incoming
and zero or more outgoing edges.
If we like to parameterise a heap graph so it contained gen-
uine symbolic variables, we rather have to distinguish between
parameterised and Ô¨Åxed variable meanings on each veriÔ¨Åcation
step. Reynolds introduces the ‚Äú,‚Äù-operator to specify paths in
heap graphs. For example, when using ‚Äú,‚Äù the above data-
structure could be fully speciÔ¨Åed by x1 7‚Üí x2, x3, x4, x7 ‚àß
x5 7‚Üí x6, x7. For comparison, the same data structure without
the path-operator ‚Äú,‚Äù would be (x2 7‚Üí x3 ‚ãÜ x4 7‚Üí x7 ‚ãÜ x5 7‚Üí
x6) ‚àß (x1 7‚Üí x2 ‚ãÜ x3 7‚Üí x4 ‚ãÜ x6 7‚Üí x7) ‚Äì we excuse
ourselves variable locations and content were mixed up in this
example for the sake of simplicity. Based on the ‚Äú‚ãÜ‚Äù-operator
x
/ a1
/ a2
/ a3
/ a4
/ a5
`
u
O
y
O
Fig. 1. An arbitrary annotated heap graph with locals x, u and y pointing to
cells with some content a1, a3 and a4
1
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-506-7
ADVCOMP 2016 : The Tenth International Conference on Advanced Engineering Computing and Applications in Sciences

x3
/ x4
!
x1
/ x2
=
x5
/ x6
/ x7
Fig. 2.
Heap graph sample consisting of two simply linked lists forming
inverted cactuses
and ‚Äú7‚Üí‚Äù the so-called Separation Logic was proposed [2],[4]
and implemented [5]. The following example [2] demonstrates
the deÔ¨Ånition of a binary tree predicate (we call a predicate
‚Äúabstract‚Äù whenever it depends on parameters):
tree(l) ::= nil | ‚àÉx.‚àÉy : l 7‚Üí x, y ‚ãÜ tree(x) ‚ãÜ tree(y)
The abstraction parameter l in Fig. 3 is some variable
symbol and tree denotes the recursively deÔ¨Åned predicate
implying the left branch does not intersect with any part of the
right branch, and vice versa. However, strictly speaking this
must not always be the case, since in the above speciÔ¨Åcation
tree(y) might be substituted by tree2(x, y), which could
hypothetically link back to x again and so would breach the
convention made previously ‚Äì luckily, this can be excluded
in most cases, except when references to dynamic memory
are determined on runtime. For example, p[13+offset]
where offset is decidable on runtime only might be such
a scenario. The breach may be avoided for tree2 just by not
passing x neither recalling it globally. Even if the tree entirely
Ô¨Åts into dynamic memory, remember x and y get stacked
once the tree is traversed: Ô¨Årst x, then y is accommodated at
the next available address because of ‚Äú,‚Äù. The authors of this
paper are aware of dropping unbound heap memory access
may induce considerable practical restrictions, however, we
think this restriction can in many cases be overcome by a
modiÔ¨Åcation to the chosen data model.
By convention, whenever a vertex of the heap graph has
at most one outgoing edge, the heap graph is simple, e.g.
linearly-linked lists, trees and arbitrary heap graphs without
multiple edges between two vertices. W.l.o.g. we consider only
pointers that refer to particular heap cells or class objects that
may union several pointers to heap cells. We will further also
consider abstract predicates. In order to decide whether two
heaps indeed do not share a common heap, it is necessary to
check there exists no path from one heap graph to the other.
One alternative to Separation Logic is Shape Analysis [6].
It makes use of transfer functions in order to describe changes
to the heap by every program statement. Another approach, as
being demonstrated by Baby Modula 3 [7], uses a class-free
l
/
&
x
‚Äú,‚Äù

/ ...
y
/ ..._S
_OO
Fig. 3. Heap graph instance for the deÔ¨Ånition of a binary tree. The left x
child points to some content which may not interfere with the content pointed
to by y
object calculus and a single unique result register. This register
stores the result after each single statement and so allows to
refer to the state before and after running a particular state-
ment. Class-objects and their typeable theories are discussed
in [8],[7].
At this point it is worth noting that a points-to model is
considered in this paper due to its locality property w.r.t. heap
graphs, modiÔ¨Åcations do not usually require a full speciÔ¨Åcation
update due to its edge-based graph representation.
The inspiration for this paper, even if coming from a
different context, is [9], where a rather intuitive but incomplete
set of ‚Äùsafe‚Äú symmetry operations on pointers is proposed in
order to prove correctness of more complex pointer manipu-
lations. Safe operations, as rotation or shift, raise big practical
concerns as hard-to predict pointer behaviour even on very
small modiÔ¨Åcations as well as incompleteness gaps on pointer
rotations.
The main purpose of this paper is to present two new
context-free binary operations for heap conjunction and heap
disjunction, to show group properties hold and those can be
used for example for proof simpliÔ¨Åcations on proof rules in
the future.
Section I of this paper gave a brief overview of the topic
and related problems. Section II introduces brieÔ¨Çy Separation
Logic, it introduces a concluded deÔ¨Ånition of heap and heap
graph, and it comes with conventions for class objects and
heap memory alignment. The main part, section III deÔ¨Ånes
heap terms to be interpreted within heap formulae. Pointers
of pointers and arrays are only very brieÔ¨Çy discussed, heap
conjunction is introduced for basic (‚Äùheaplet‚Äú) and generalised
heaps (what is later expressed as heap term) as well as path
accessors (see observation 3.6). Properties of the conjunction
are investigated and established, canonisation steps are demon-
strated in order to overcome transient inconsistency, which
may occur from references no more alive. Heap inversion
is proposed as notational trick. In companion with other
properties it may eventually help to deÔ¨Åne equalities over
heaps and so improve the comparison with expected heaps in
the future. In particular, deÔ¨Åning a partially-ordered set over
conjunct heaps w.r.t. sub-graph inclusion, and distributivity
along with other properties would eventually help to deÔ¨Åne
for instance a satisÔ¨Åability-modulo-theory. Partial speciÔ¨Åcation
is introduced in section IV for objects. Discussions propose
an extension with aliases to the Object Constraint Language.
Finally, conclusions follow a short discussion.
II. HEAP SEPARATING LOGIC
Before going into more detail, let us Ô¨Årst ask whether we
cannot simply turn all dynamically allocated variables into
stacked, as it was proposed, for instance, by [10]. Often this
will indeed work, however, sometimes it is not a good idea
after all, because of performance issues [11], for instance.
More often the nature of the problem forbids general static
assumptions on stack bounds. An overview and numerous
deÔ¨Ånitions of dynamic memory may be found in [1].
2
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-506-7
ADVCOMP 2016 : The Tenth International Conference on Advanced Engineering Computing and Applications in Sciences

The essence of Reynolds‚Äô heap model and properties was
brieÔ¨Çy wrapped up in the previous section. So, one central
problem seems to be expressibility, which is the main purpose
of this paper. This section introduces a heap by referring to a
graph, followed by numerous model discussions and property
observations.
DeÔ¨Ånition 2.1. (concluded from Reynolds) A heap is deÔ¨Åned
as S
A‚äÜAddr A 7‚Üí V aln with n ‚â• 1, A being some address
set and V al is some value domain, for instance, integers or
inductively deÔ¨Åned structures containing A. A heap may be
composed inductively by other heaps as following:
H1 ‚ãÜ H2, where H1 describes some heap graph assertion
H1 = (V1, E1) and in analogy to that H2 = (V2, E2), where
edges E = V √ó V and edges are directed, s.t. iff ‚àÄv1 ‚àà V1,
v2 ‚àà V2 with v1 Ã∏= v2 and cases:
1st (Separation): (v1, v2) /‚àà E1, and (v1, v2) /‚àà E2.
2nd (Conjunction): ‚àÉs ‚àà V1, ‚àÉt ‚àà V2 : (s, t) ‚àà E1 or (s, t) ‚àà
E2 then H1 or H2 contains some ‚ãÜ-separated s 7‚Üí t.
Variables as well as pointers are stored in the stack, where
the content pointed to remains in heap memory (the following
domain equation [5] holds: Stack = V alues ‚à™ Locals).
Heap graph assertions are assertions about the heap graph
constructed by program statements manipulating the dynamic
memory. Those assertions are interpreted as true or false
depending on whether an associated concrete heap corresponds
or not. DeÔ¨Ånition 3.2 will introduce the syntax for heap
assertions.
Regarding deÔ¨Ånition 2.1 the overloading of the binary
operator ‚Äù‚ãÜ‚Äú happens in two ways: one is to express two
heaps do not overlap, and the second way is to express
two heaps are somehow linked together by using transient
symbols. The ‚Äù‚ãÜ‚Äú-operator is a logical and spatial conjunction,
it links two prepositions about heaps together and it describes
heap entities which have some conÔ¨Åguration in space, both
consume different dynamic memory regions. On the one hand,
if we link strictly two separate heaps then we have to Ô¨Ånd a
maximal matching in order to describe the given heap graph
entirely, which is impractical. On the other hand, separation
also seems to be a very elegant way to separate speciÔ¨Åcation
concerns locally: if there is an assertion regarding a particular
data structure in heap, this should involve at most only that
data structures and exclude unaffected ones. After all, the
above initial deÔ¨Ånition seems complicated enough, because it
is ambiguous and it refers to a single heap deÔ¨Ånition, which
should ideally not be too different from Reynolds‚Äô initial and
rather intuitive deÔ¨Ånition of heaps ‚Äì but as we have seen
unfortunately, it is. So, two strict operators would be desired
rather a single ‚Äù‚ãÜ‚Äú, one operator to strictly separate and one
to join heaps. Heaps shall be replaceable with symbolic place-
holders in order to beat ambiguity whilst analysing veriÔ¨Åcation
conditions. Moreover, syntax and semantic intention of heap
expressions shall be uniÔ¨Åed.
Once both heap operators are deÔ¨Åned, properties and equiv-
alences can be established separately. Finally, heap theories
and term algebras may eventually be proposed in future over
both heap operators. In deÔ¨Ånition 2.2 we Ô¨Årst need to formally
deÔ¨Åne what a heap actually is.
The underpinning theory behind [3] is the so-called Sub-
structural Logic [12], which is a higher-order logic, a logic
where, for instance, the contraction rule does no more hold,
constants have in fact turned into predicates that may be
quantiÔ¨Åed (details can be found in [12]). Contraction-freeness
[13] in this context has for our purpose the advantage of non-
repeating heap entities within a heap assertion. By repeating
we directly refer to points-to expressions as deÔ¨Åned later.
DeÔ¨Ånition 2.2. A (Ô¨Ånite) heap graph is a directed connected
graph within the dynamic memory section which may contain
cycles, but must remain simple. Each vertex has a type-
dependent size and an unique memory address, but may not
overlap with other vertices. Every edge represents a relation-
ship, for instance, a pointer to some absolute memory address
or a relative jump Ô¨Åeld displacement.
The absolute addresses are out of interest to the veriÔ¨Åcation.
The heap graph must be pointed by at least one stacked
variable, otherwise the so-deÔ¨Åned graph is considered as
garbage. Stacked variables may also point to one vertex, in
this case all except one variable are aliases of the variable
considered.
The emphasis lies on Ô¨Ånite, since only arbitrary big but
Ô¨Ånite address space shall be considered. The dynamic memory
shall be linearly addressable, however some operations new
and delete shall organise themselves how and where to
allocate or free heap memory. We restrict ourselves pointers
address correctly and sound, and for the purpose of this
paper we neither care too much about an optimal memory
coalescing strategy to pointers that is most likely expanded on
runtime, nor primarily about garbage collection issues. What
we concern about is only that there is a relationship between
a pointer and a pointed-by region within the heap memory
region, it does not even require a pointer contains an absolute
address within the dynamic memory range as it is not the
case with bi-directional XOR-calculated jump-Ô¨Åelds, which
are relative pointer offsets depending on the address provided
‚Äùsomehow‚Äú by an actual vertex address.
Conventions 2.3. Objects are restricted w.l.o.g. to be
a) non-inner objects only. Inner objects may always be
modelled as with associated outer objects, so that there
a)
b)
Fig. 4. Schematic heap graph a) without direction, b) midpoints represent the
substituted graph obtained by encoding source and destination vertices
3
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-506-7
ADVCOMP 2016 : The Tenth International Conference on Advanced Engineering Computing and Applications in Sciences

are references to different locations rather than all objects
being accommodated within one contiguous heap chunk.
b) Object Ô¨Åelds and method names have to be all unique
w.r.t. to its visibility. W.l.o.g. clashing names, for instance
inherited names, are resolved by mangling the origin
name with visibility mode and information from the
deriving class. All references to mangled names need to
be taken into account. This task is primarily done during
the semantic program analysis phase.
c) Due to encapsulation, objects do not grow in size nor-
mally, and due to late binding object references may
keep invariant. However, the size of an object may
spontaneously change. Sub-class objects may suddenly
grow, but they may also shrink, depending on whether
the translating compilation phase does align memory
for non-used Ô¨Åelds or not. If choosing a forced stack-
allocated memory alignment for objects, then an object
which is bound lately and passed alone to some procedure
may better be reordered within its memory chunk, s.t.
the growing part rises upwards on the stack. Because
the separating heap are non-contractive [3], object Ô¨Åelds
speciÔ¨Åed once may not appear again within a conjuncted
heap expression.
d) Arrays as base type are currently ignored. Multiple edges
between the same two vertices are disallowed.
e) Sharing of same heap cells by multiple cells is allowed
to all object Ô¨Åelds.
In order to stay consistent with the following deÔ¨Ånitions, a
simple check for the incidence relationship for memory cells
for a given heap graph needs to be introduced. A given heap
graph is composed of points-to heaplets meaning a directed
edge represents a location points to a heap address which
contains some value. The check requires all these heaplet con-
juncts are traversed and the desired heap graph shall be in an
edge-centric representation. However, whenever we like to de-
termine if two heap vertices are incident with each other or not,
we prefer a vertex-centric model encoding edges. So, we deÔ¨Åne
the following built-in predicates: reaches(x,y), reach-
es(x,Y), reaches(X,y), reaches(X,Y), where x is
a vertex and X denotes a vertex subset of a given heap graph
(y, Y in analogy).
Both interleaved representations in Fig. 4 (the vertex-centric
representation is marked by smaller Ô¨Ålled midpoints on every
edge) are dual and convertible to each other. Midpoints encode
source and destination as one vertex and link with former
neighbouring vertices. Naturally, this mapping is bijective
(proof skipped). Since we in general need to interpret predi-
cates of at least Ô¨Årst order, we could do this now by describing
one heap graph by one conjunction of ‚Äùloc 7‚Üí val‚Äú pairs rather
than more complex forms.
Conventions 2.4. (Heap Alignment) Object Ô¨Åelds do not
overlap, Ô¨Åelds have distinguishing memory addresses. Pointers
to objects and its Ô¨Åelds may alias. An object is expressed com-
monly by the points-to expression x 7‚Üí object(fld1, fld2, ...).
It is agreed w.l.o.g. that object Ô¨Åelds may not be accessed via
arithmetic displacements but only by a valid object access path
using the ‚Äù.‚Äú-operator and valid subordinate Ô¨Åelds. W.l.o.g,
but still for the sake of full computability late binding is
skipped. A full support would imply the use of only the weakest
common heap to be chosen.
III. CONJUNCTION AND DISJUNCTION
Because of deÔ¨Ånitions 2.1, 2.2 and conventions 2.3, 2.4 we
describe a heap now by a term as following.
DeÔ¨Ånition 3.1. A heap term describes heap graphs and is
syntactically deÔ¨Åned as:
T ::=
loc 7‚Üí val
... points-to heaplet
| T ‚ó¶ T
... heap conjunction
| T ‚à• T
... heap disjunction
| true | false | emp
... partial heap spec
| ( T )
... subterm expression
where loc denotes a variable location, a location of a
compound object Ô¨Åeld or a symbol representing some heap
variable, and val denotes some value of any arbitrary domain.
T describes the current heap state.
T can be considered as a formula since we do not restrict
ourselves in not considering variable scopes as long as the
syntax deÔ¨Ånition is obeyed. We further agree on that ‚ó¶ has
lower precedence than ‚à•, so a1‚ó¶a2‚à•a3 ‚â° (a1‚ó¶a2)‚à•a3. For the
sake of notational simplicity, we do refer to loc 7‚Üí val, which
besides is closer to Reynolds‚Äô deÔ¨Ånition rather than Burstall‚Äôs.
However, we really should better refer in practice to the
address of the content being pointed to rather than the direct
domain value, which naturally may be composed. Hence,
we agree without any further notice on some polymorphic
notational helpers, like address(val), which will allow us to
address given values.
true implies certain (remaining) heap term(s) is a tautology,
regardless of the actual term(s). In analogy to that stands
false, which implements a contradiction. emp is a constant
built-in predicate implying a given heap must be empty to be
satisÔ¨Åable. This is why all three may be used to consume all
not explicitly listed ‚ó¶-conjuncted heaplets. The partial speciÔ¨Å-
cation we get allows us to keep heap formulae simple, since we
now may implicitly include all unaffected, but still intended,
heaps belonging together. Partial speciÔ¨Åcations together with
abstract predicates raise modularity. This becomes particularly
of interest for class objects, where all Ô¨Åeld heaplets generate
its own heaplet scope, which is different from the global non-
object scope (see convention 2.4). In fact we just discussed
extensions to our heap term deÔ¨Ånition, which ought to be
summarised:
DeÔ¨Ånition 3.2. Extended heap terms ET are heap terms with
constant formulae, negation and logical conjuncts:
ET ::=
T
... heap term
| p(Œ±)
... abstract predicate call
|¬¨ET
... logical negation
| ET ‚àß ET
... logical conjunction
| ET ‚à® ET
... logical disjunction
4
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-506-7
ADVCOMP 2016 : The Tenth International Conference on Advanced Engineering Computing and Applications in Sciences

The logical conjunctions do not really require more ex-
planations than already said. A predicate call to a previ-
ously deÔ¨Åned predicate may invoke all dependent subcalls,
although predicate calls are not classic procedure calls. An
brief introduction of Prolog using predicates and reasoning a
speciÔ¨Åc Hoare-calculus may be found in [14]. Predicates may
be parameterised by zero or more heap terms bound to the
predicate. Heap terms may be used as input or output terms,
or even both at the same time. Intentionally, heap terms are
used as sub-expressions in logical assertions. The veriÔ¨Åcation
of a predicate retrieves a Boolean value depending on if a
given formula is obeyed.
Observation 3.3. Pointers of pointers are syntactic sugar.
They do not fundamentally extend the expressibility of heap
graph assertions. Their only purpose w.r.t. heap terms is to
have an additional indirection level for increased program-
ming language Ô¨Çexibility. They act as placeholder or symbol
variable for pointer locations.
By pointers of pointers neither the heap graph itself gets
extended nor the referenced heap in comparison with no
pointers of pointers. Symbolic variables and placeholders are
useful, because they may select numerous heaplets at once.
But, the ‚Äù,‚Äú-operator can do this already for linearly-linked
lists and this operator was found superÔ¨Åcial in terms of
expressibility. In addition to that, it should be noted, that
abstract predicates may also perform a selection of numerous
heap cells. Although not too useful in a theoretic manner, the
above conjecture does not necessarily exclude usability gains
in practice.
DeÔ¨Ånition 3.4. Heap conjunction H ‚ó¶ Œ± 7‚Üí Œ≤ is deÔ¨Åned
as heap graph, where G = (V, E) is H‚Äôs heap graph
representation, H is a heap graph, and Œ± 7‚Üí Œ≤ is a points-to
heaplet:
Ô£±
Ô£¥
Ô£¥
Ô£≤
Ô£¥
Ô£¥
Ô£≥
(V ‚à™ {Œ±, Œ≤} ‚à™ Œ≤‚Ä≤,
if isFreeIn(Œ±, H)
E ‚à™ {(Œ±, Œ≤)} ‚à™ {(Œ≤, b)|b ‚àà Œ≤‚Ä≤})
if H = emp
(V = E = ‚àÖ)
false
otherwise
where Œ≤‚Ä≤ = vertices(Œ≤) ‚äÜ V determines all heap graph
vertices being directly pointed by Œ≤, which in case Œ≤ is an
object includes all of the Ô¨Åelds pointing to some vertices. Since
Œ± must be a unique location (for instance an object access
path) there may be only either one or no heap vertex matching
in isFreeIn for a given heap H. The assumption is there is
always exactly one matching free vertex for conjunction when
building up a heap graph from a scratch, otherwise two heaps
are not linkable.
Lets say we would like to join three points-to pairs a, b, c
together (see Fig. 5). First, a must be expressed either purely
by a itself or by emp ‚ó¶ a. Only then b might be connected to
a, iff additionally a contains actually a matching destination
vertex that is not being assigned elsewhere. Once we have a‚ó¶b,
only then the edge c may be connected as announced in the
previous step, and we Ô¨Ånally obtain the heap graph as seen in
‚ó¶
a
/ ‚ó¶

‚ó¶
c
/ ‚ó¶
‚ó¶
b
/ ‚ó¶
O
‚ó¶
a
/ ‚ó¶
b
/ ‚ó¶
c
/ ‚ó¶
heap graph before ...
and after conjunction
Fig. 5. Heap graph before and after heap conjunction.
Fig. 5. Since we may also conjunct any kind of graphs, e.g.,
binary trees, we allow to vary the conjunction ordering as long
as the resulting graph is connected. For instance, a 7‚Üí 5 would
be a valid heap conjunction, but a 7‚Üí 5 ‚ó¶ b 7‚Üí 5 would be not.
Notice that this way we still may express aliases if we want,
for instance the heap graph x ‚ó¶
/ ‚ó¶z
‚ó¶ y
o
could be
expressed as heap term x 7‚Üí z ‚ó¶ y 7‚Üí z.
In Fig. 5 all source and target vertices are simple and not
annotated. In general the vertices may naturally be simple or
compound in case of objects. For the sake of simplicity, only a
one-to-one connection is considered further, however assigning
multiple objects to Ô¨Åelds at once might be a very convenient
method as long as the assignment is unambiguous, especially
when it comes to arrays where a separator might be needed.
Remark: Let Œ¶0 be some heap, then Œ¶ = Œ¶0 ‚ó¶ a0 7‚Üí b0 ‚áî
‚àÉ(am 7‚Üí bm) ‚àà Œ¶0‚àß(am = a0, bm Ã∏= b0‚à®am Ã∏= a0, bm = b0).
Theorem 3.5. H1 ‚ó¶ H2 conjuncts two heaps H1 and H2, if
there exists at least one common vertex in each heap graph
representations. It is agreed by convention H1 ‚ó¶emp = emp‚ó¶
H1 = H1 holds.
Proof. This theorem is actually a generalisation of deÔ¨Ånition
3.4. In contrast to deÔ¨Ånition 3.4, the term on the right-hand side
of the generalisation of ‚ó¶ is searched for a matching vertex.
H1 ‚ó¶ H2 represents one connected heap graph. Both, H1 and
H2 may either be heaplet or a composition of heaplets of
kind a1 7‚Üí b1 ‚ó¶ a2 7‚Üí b2 ‚ó¶ ¬∑ ¬∑ ¬∑ ‚ó¶ an 7‚Üí bn. In order to show
the correctness of the theorem Ô¨Årst we need to show is that
if there is no common element in both heap graphs, then by
deÔ¨Ånition 3.4 we obtain false, which corresponds to what
we would obtain from a conjunction. Otherwise, if we do
have at least one common element, then inductively we do not
bother about further common elements. So, we link both heap
graphs up and the conjunction on heaps refers to connectible
heaps. Further common elements would meld existing heap
graph edges, the melded graph still is simply linked (but with
multiple bridges), otherwise this would mean at least source
or target of a melded heap graph edge would exclusively be
either in H1 or in H2, and in both H1 and H2 at the same time,
which is a contradiction, hence we just showed the theorem
holds.
Regarding the search for a matching element the a ‚ó¶ a-
decider mentioned later will resolve this practical issue.
Observation 3.6. In an abstract predicate locations may be
symbols. In order to increase reuse of abstract predicates for
5
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-506-7
ADVCOMP 2016 : The Tenth International Conference on Advanced Engineering Computing and Applications in Sciences

different locations and different location kinds (primarily for
locals and object Ô¨Åelds) it is agreed, that the Ô¨Åeld accessor
‚Äù.‚Äú is a left-associative binary operator.
Left-associativity means object1.field1.field2.field3 is
internally represented by (((object1).field1).field2).field3.
This way object access paths may be substituted by variable
symbols, which raise modularity and Ô¨Çexibility of access paths
expressions.
Lemma 3.7. G = (‚Ñ¶, ‚ó¶) is a monoid, where ‚Ñ¶ denotes the
set of heap graphs and ‚ó¶ denotes heap conjunction.
Proof. In order to prove G is a monoid we need to show (i) ‚Ñ¶
is closed under ‚ó¶, (ii) ‚ó¶ is associative, and (iii) ‚àÉŒµ ‚àà ‚Ñ¶.‚àÄm ‚àà
‚Ñ¶ : m ‚ó¶ Œµ = Œµ ‚ó¶ m = m.
First of all, by œâ ‚àà ‚Ñ¶ we refer to a connected heap
graph over ‚Äù7‚Üí‚Äú-heaplets as being introduced in deÔ¨Ånition 3.1.
According to deÔ¨Ånition 3.4 ‚àÄœâ ‚àà ‚Ñ¶ : œâ ‚ó¶ œâ = false, which is
deÔ¨Åned. Alternatively, there may be only two cases for some
œâ1, œâ2 ‚àà ‚Ñ¶: if œâ1 and œâ2 do have at least one joining vertex,
then according to theorem 3.5 the resulting heap graph is well-
deÔ¨Åned, otherwise the result is false (meaning œâ1 and œâ2
are disjoint). This way we have just shown that ‚Ñ¶ is closed
under ‚ó¶ and that a ‚Äùmeaningful‚Äú heap graph conjunct may
be obtained by connectible heap graphs. The connection is
established successively.
Second, associativity needs to be demonstrated, namely that
m1 ‚ó¶ (m2 ‚ó¶ m3) = (m1 ‚ó¶ m2) ‚ó¶ m3 holds. When looking at
Fig. 5 we can immediately see the validity of both directions
of the equation, because it does not matter whether a and b
are joined Ô¨Årst, or a is connected to connected b ‚ó¶ c, since the
joining vertex of b remains invariant when altering the connect
ordering.
Now G forms a semi-group, we still need to show there
always exists some neutral element Œµ, so (iii) holds. This
follows, however, immediately from the generalised heap
theorem 3.5.
Remark: From (i) follows that c Ã∏‚àà b ‚àß c Ã∏= a: a 7‚Üí b ‚ó¶
c 7‚Üí d ‚â° false, and that a 7‚Üí b ‚ó¶ a 7‚Üí d ‚â° false holds.
Furthermore, it is intuitively clear that connecting two heap
graphs may be done using different joining vertices, regardless
of which joints are connected Ô¨Årst. The resulting heap graph
shall be the same due to conÔ¨Çuence, due to (ii) and, moreover,
due to the property being demonstrated later in deÔ¨Ånition 3.8.
Remark: Closeness (i) demonstrates the non-repetitiveness
property of a Substructural Logic (the Separation Logic as still
to be shown later) remains.
Theorem 3.8. G = (‚Ñ¶, ‚ó¶) is an Abelian group.
Proof. Due to lemma 3.7, G is a monoid; hence we still need
to show (i) the existence of an inverse element for every heap
graph, s.t.
‚àÄœâ ‚àà ‚Ñ¶.‚àÉœâ‚àí1 ‚àà ‚Ñ¶ : œâ ‚ó¶ œâ‚àí1 = œâ‚àí1 ‚ó¶ œâ = Œµ
(1)
and (ii) ‚ó¶ is commutative.
Let us start to prove the induction with (ii): for the base case
‚Äùloc1 7‚Üí var1‚ó¶loc2 7‚Üí var2 = loc2 7‚Üí var2‚ó¶loc1 7‚Üí var1‚Äú of
deÔ¨Ånition 3.1 the equivalence holds obviously. The inductive
case holds also as long as the conditions on ‚ó¶ are obeyed,
the proof induction can be deduced from Fig. 5, implying
commutativity holds for arbitrarily connected heaps. However,
when it comes to abstract predicate, the boundaries of a ‚ó¶-
connected heap graph term may vanish. This needs to be taken
into consideration by whoever writes the speciÔ¨Åcation.
Now, let us proceed with (i). We do have the problem of
Ô¨Ånding an inverse for whatever heap we get. The question what
it means particularly raises immediately. If we think about
natural numbers as operating carrier set and an attempt to
invert addition, we factually introduce subtraction on integers.
The same happens to complex numbers as an extension of
real numbers. Nobody really is not able to count imaginary
numbers in practice. Nevertheless, this extension seem to
simplify basic calculations signiÔ¨Åcantly in applications. So,
why not assume for the moment and postulate equation (1)
right until found different?
And so, what does it intuitively mean ‚Äùto negate a heap‚Äú
? One could think of negating a points-to predicate affects
only the state or that there is just no such heap reference.
However, it does not really undo a heap reference after all.
A hypothetical ‚Äùnot-points-to‚Äú requires primarily some kind
of a ‚Äùtranscendental heap removal‚Äú ‚Äì at the Ô¨Årst glance this
may indeed sound like a delicate problem, because up to now
we were only specifying what is in the heap. We shall also
be able to specify what is not in, but we had no chance
whatsoever to specify a predicate which states some heap must
be removed ‚Äùsomehow‚Äú. Let us not bother about it too much
for the moment and focus instead only on equation (1). What
this equation actually states is a negated points-to a Ã∏7‚Üí b rela-
tionship, or more generalised some negated heap H‚àí1, s.t. by
convention a 7‚Üí b ‚ó¶ a Ã∏7‚Üí b = emp and a Ã∏7‚Üí b ‚ó¶ a 7‚Üí b = emp,
and more general: H ‚ó¶ H‚àí1 = H‚àí1 ‚ó¶ H = emp. This means
œâ ‚ó¶ œâ‚àí1 removes a heap, and in fact it is an edge removal in
addition to an optional heap graph vertex removal in case there
are no more edges going to/leaving from the corresponding
heap vertex. It is now easy to see why H ‚ó¶ H‚àí1 ‚ó¶ H ‚â° H
holds. For demonstration let us have a look at Fig. 6. The heap
states before inversion d 7‚Üí a ‚ó¶ a 7‚Üí b ‚ó¶ c 7‚Üí b, when applied
‚ó¶(a 7‚Üí b)‚àí1 we obtain d 7‚Üí a ‚ó¶ a 7‚Üí b ‚ó¶ c 7‚Üí b ‚ó¶ (a 7‚Üí b)‚àí1
equals d 7‚Üí a ‚ó¶ a 7‚Üí b ‚ó¶ (a 7‚Üí b)‚àí1 ‚ó¶ c 7‚Üí b equals
d 7‚Üí a ‚ó¶ c 7‚Üí b, which may not occur quite plausible at the
Ô¨Årst view yet, because both pointers do not interfere. Therefore
it is required to perform one generic step.
Canonization step I: If a bridge is removed from between
sub-heap graphs, then the conjunction needs to be replaced by
a heap disjunction.
For the example a bridge is detected between a and b, so ‚ó¶
may be substituted by ‚à• in the remaining heap term, and so the
result appears plausible again. But for sake of completeness
heap graph vertices may need to be removed even completely.
This becomes urgent especially when it comes to object Ô¨Åeld
locations.
6
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-506-7
ADVCOMP 2016 : The Tenth International Conference on Advanced Engineering Computing and Applications in Sciences

a
/ b
d
O
c
O
conjunct:
(a 7‚Üí b)‚àí1
=‚áí
a
( b
d
O
c
O
‚áî
a
b
d
O
c
O
Fig. 6. Heap graph before and after inversion
Canonization step II: Remove some heap graph vertex a
entirely whenever there are no more references to it.
Applying those two canonization steps keeps the chosen
model sound and conÔ¨Çuent (proof skipped here).
Remark: We did not mention heap generalisations explic-
itly in the previous paragraphs, although it remains to the
reader to prove correctness of H ‚ó¶ H‚àí1 ‚â° emp (proof by
induction over ‚ó¶, use the fact that (g1 ‚ó¶ g2)‚àí1 ‚â° g‚àí1
1
‚ó¶ g‚àí1
2
holds, so there exists a homomorphism for .‚àí1 w.r.t. ‚ó¶, refer
to lemma 3.9).
Convention: Condition (i) implies particularly emp ‚ó¶
emp‚àí1 ‚â° emp, because we agree on emp‚àí1 ‚â° emp.
Subsumption: H ‚ó¶ a 7‚Üí b ‚ó¶ (a 7‚Üí b)‚àí1 denotes:
1) unlink edge between a and b
2) unlink/remove a if there are no more uses in H
3) unlink/remove b as well if no more uses in H
The group properties allow us to deÔ¨Åne equalities for the
separated heap theory. This will allow us, for instance, to
deÔ¨Åne arithmetic equalities, which applied will cause faster
convergence to a normalised heap representation. It will lower
the risk of highly bloated veriÔ¨Åcation rules and conclusively
it will lead us to a smaller logic in combination with partial
speciÔ¨Åcation (see section IV). Future work may include heap
arithmetics to be implemented by satisÔ¨Åability-modulo-theory
solvers, which will be integrated to the veriÔ¨Åcation process.
This approach does not only sound promising, but in fact it
was successfully proven concept in several different areas,
particularly for bloated and notoriously incomplete Hoare
logics.
Lemma 3.9. (g1 ‚ó¶ g2)‚àí1 ‚â° g‚àí1
1
‚ó¶ g‚àí1
2
holds for any heaplets
g1 and g2.
Proof. Lets generalise this lemma, let G = g1‚ó¶g2‚ó¶¬∑ ¬∑ ¬∑‚ó¶gn, we
need to show G‚ó¶G‚àí1 = emp. This can be shown by induction
over n. In the base case (n = 1) we have g1 ‚ó¶ g‚àí1
1
‚â° emp,
which holds because of the existence of an inverse. For the
inductive step let G = (g1 ‚ó¶ g2 ‚ó¶ ¬∑ ¬∑ ¬∑ ‚ó¶ gk)
|
{z
}
Gk
‚ó¶gk+1, then G ‚ó¶
G‚àí1 = (Gk ‚ó¶ gk+1) ‚ó¶ (Gk ‚ó¶ gk+1)‚àí1 denotes in the inverse
part a graph extension. The right part of this equation equals
Gk ‚ó¶ G‚àí1
k
|
{z
}
emp
‚ó¶ gk+1 ‚ó¶ g‚àí1
k+1
|
{z
}
emp
‚â°
emp (because of the inductive
inversion property).
DeÔ¨Ånition 3.10. Heap disjunction H ‚à• a 7‚Üí b deÔ¨Ånes heap H
and heaplet a 7‚Üí b which do not interfere, iff GH is the heap
graph of H, GH = (V, E), and for all edges ( , a) Ã∏‚àà E and
there exists no path from b to H, and there is no path back
from H to a.
That is why x.b ‚à• x.c does not hold for any object x with
Ô¨Åelds b and c, if there exists at least one common vertex on
any path from x.b or from x.c.
Let Œ£ = X0‚à•X1‚à• ¬∑ ¬∑ ¬∑ ‚à•Xn with n > 0 and Xj is of form
xj 7‚Üí yj, then Œ£ = Œ£0 ‚à• a0 7‚Üí b0 ‚áî ‚àÄ(aj 7‚Üí bj) ‚àà Œ£0 :
aj Ã∏= a0 ‚àß bj Ã∏= b0.
Theorem 3.11. G = (‚Ñ¶, ‚à•) is a monoid and a group, if ‚Ñ¶ is
the set of heap graphs and ‚à• denotes heap disjunction.
Proof. In analogy to the previous lemma, Ô¨Årst of all,
‚àÄm1, m2 ‚àà ‚Ñ¶ : m1‚à•m2, iff m1 and m2 have no common
joint, which is the case whenever there is no path from m1 to
m2, and there is not even an indirect heap graph surrounding
both m1 and m2. If m1 and m2 are different, then m1‚à•m2
must be a valid heap ‚àà ‚Ñ¶ again, because m1 is from a
different heap graph part than m2, and vice versa, so closeness
holds. Associativity holds obviously. emp may be chosen as
neutral element, so emp‚à•m1 = m1‚à•emp = m1, by default
let emp‚à•emp = emp hold. Last, we agree on the convention
s‚à•s‚àí1 = s‚àí1‚à•s = emp, which behaves similar to ‚ó¶. Heaps in
general obey this rule.
The heap-wise conjunction and disjunction may be ex-
pressed as following:
‚ó¶[B,C]
U ‚ó¶ B ‚à• C
U ‚ó¶ B ‚ó¶ C
‚à•[B,C]
U ‚ó¶ B ‚ó¶ C
U ‚ó¶ B ‚à• C
‚à•[B,C]; ‚ó¶[B,C]; ‚à•[B,C] ‚â° ‚à•[B,C]
(2)
‚ó¶[B,C]; ‚à•[B,C]; ‚ó¶[B,C] ‚â° ‚ó¶[B,C]
(3)
The operations ‚à• and ‚ó¶ are dual and self-inverse as can be
seen from equations (2) and (3), where ‚Äù;‚Äú is the statement
sequentializer. The equations do hold (direct proof, skipped
here), because of its self-inverse character and due to the
assertion that both speciÔ¨Åed heap vertices B and C, in fact,
exist.
Theorem 3.12. Distributivity holds for ‚àÄa, b, c ‚àà ‚Ñ¶ for ‚ó¶ and
‚à•:
(i)
a ‚ó¶ (b‚à•c) = (a ‚ó¶ b)‚à•(a ‚ó¶ c)
(ii)
(b‚à•c) ‚ó¶ a = (b ‚ó¶ a)‚à•(c ‚ó¶ a)
Proof. (direct proof, skipped, take note of Fig. 7).
Remark: Since the neutral element for both operations,
‚ó¶ and ‚à•, is emp, there cannot be deÔ¨Åned a Ô¨Åeld over both
operations, although lemma 3.7, theorem 3.8 and 3.12 hold,
and ‚Ñ¶ is Ô¨Ånite. Particular heaps would be Ô¨Ånite. All operations
applied to Ô¨Ånite heaps would be Ô¨Ånite again.
Remark: In analogy to logical conjuncts ‚àß and ‚à® a
‚à•-normalform exists when the previous equalities are applied.
Lemma 3.9 can be applied for the inversion of generalised
heaps.
In order to optimize reasoning by minimizing graph size,
‚à• should be moved upwards at most in heap terms, e.g., by
7
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-506-7
ADVCOMP 2016 : The Tenth International Conference on Advanced Engineering Computing and Applications in Sciences

(‚àÜ ‚àÜ‚àÜ)
G‚Ä≤‚Ä≤
1
G‚Ä≤
1
(‚àÜ )
G‚Ä≤
2
(‚àÜ‚àÜ)
G1
(‚àÜ)
G2
( )
Fig. 7. A partially-ordered set (poset) can be deÔ¨Åned for heap graphs under
inclusion, the join operator is ‚ó¶.
applying distributivity rules or by reordering points-to heaps
so that the left-hand sides are ordered in lexicographical order
by its location. The motivation behind this is, for instance, to
optimize incremental veriÔ¨Åcation, so only affected heaps may
require re-calculations.
As seen in Fig. 7 a partially-ordered set can always be
deÔ¨Åned over inclusion of heap graphs. Despite there might
be an inÔ¨Åmum deÔ¨Åned as emp and some always existing
supremum, the complete heap graph, the structure is still not
a (complete) lattice due to non-holding connective properties
w.r.t. ‚à• as meet for absorption. The poset G from Fig. 7
contains {G1, G2, G‚Ä≤
1, G‚Ä≤
2, G‚Ä≤‚Ä≤
1} and can be ordered by the
following ascending chains G1 ‚äë G‚Ä≤
1 ‚äë G‚Ä≤‚Ä≤
1, G2 ‚äë G‚Ä≤
1 and
G2 ‚äë G‚Ä≤
2 ‚äë G‚Ä≤‚Ä≤
1. The supremum is G‚Ä≤‚Ä≤
1, inf(G) = emp,
where ‚äë shall be deÔ¨Åned as the heap sub-graph relationship.
Obviously, if two heaps are not disjoint (this denotes emp
because of deÔ¨Ånition 3.4) they may always be connected with
each other in the corresponding Hasse-diagram. This join is
always valid because of (1st contradiction) a 7‚Üí b ‚ó¶ a 7‚Üí d
may not occur after a single heap conjunct, or any composite
heap in general (2nd contradiction) a 7‚Üí b‚à•b 7‚Üí d contradicts
the deÔ¨Ånition of ‚à•. However, it needs to be taken into consider-
ation that the inclusion-ordering mentioned may be destroyed
by applying inverse heaps if used arbitrarily (compare with
previous section), but those may usually, at least at the
moment, be used only in cases where a difference between
expected and actual heap graphs needs to be calculated rather
than a desired heap graph speciÔ¨Åcation, so the locality property
mentioned from section I remains untouched.
IV. PARTIAL HEAP SPECIFICATION
Having said earlier after deÔ¨Ånition 3.1 class objects may
be considered as containers of Ô¨Åelds obj.f1 7‚Üí .. ‚ó¶ obj.f2 7‚Üí
..‚ó¶obj.fn 7‚Üí .., all Ô¨Åelds constitute a scoped heap (in analogy
to single points-to local variables among abstract predicates).
Since class object Ô¨Åelds may not exist independently from
other Ô¨Åelds of the same class, they must by convention be ‚ó¶-
conjuncted. In contrast to locals, object Ô¨Åelds too require a pos-
sibility to specify only parts, hence constants from deÔ¨Ånition
3.2 are parameterised to true(obj) or false(obj). Abstract
predicates modularise speciÔ¨Åcations, they can particularly be
used to specify objects from unrelated objects and locals. W.r.t.
the proposed stack-based implementation of a ‚Äúa ‚ó¶ a‚Äù-decider
incoming and outgoing terms for abstract predicates may be
traced in order to skip re-verÔ¨Åciation of unaffected parts.
DeÔ¨Ånition 4.1. A partial heap speciÔ¨Åcation t(o) for some
object o is deÔ¨Åned as a ‚ó¶-conjunction of all remaining Ô¨Åelds,
possibly none, that are not speciÔ¨Åed until t is used and unfold
in the current object scope. When t is used all actual Ô¨Åelds
are unfold into the surrounding heap speciÔ¨Åcation, which are
not yet been speciÔ¨Åed in terms of the current scope of o.
Example 4.2. Lets say object a has three Ô¨Åelds f1, g1 and
g2, and C[[]] denotes some (implicit) heap term denotation of
type (ET ‚Üí ET) ‚Üí {true, false}, where the Ô¨Årst extended
heap is supposed to be the expected and the second extended
heap is supposed to be the actual heap term then
C[[a.f1 7‚Üí x ‚ó¶ true(a)]] =
C[[a.f1 ‚ó¶ a.g1 ‚ó¶ a.g2]]
=
C[[true(a) ‚ó¶ a.f1 7‚Üí x]] Ã∏=
C[[p(a) ‚ó¶ a.f1 7‚Üí x]]
where p is some abstract predicate denoting true(a). However,
C[[a.f1 7‚Üí x ‚ó¶ p(a)]] would denote equality, because the stack-
oriented recognition Ô¨Ånds all remaining Ô¨Åelds even when
obfuscated beneath several predicate levels. C[[]] is a homo-
morphic mapping regarding ‚ó¶.
Example 4.3. C[[true(a) ‚ó¶ true(a)]] = C[[a.f1 ‚ó¶ a.g1 ‚ó¶ a.g2]]
‚ó¶ C[[true(a)]] = C[[a.f1 ‚ó¶ a.g1 ‚ó¶ a.g2]] ‚ó¶ emp(a).
V. DISCUSSIONS
By exchanging one ambiguous spatial heap operator by two
strict operations, the initial and core properties of a Sepa-
ration Logic did not change essentially, except an unbound
and arbitrary heap inversion as discussed in section IV. The
introduction of a strict normalform allows a linear and local
analysis of the heap terms without an eager comparison of still
non-matched conjuncts.
As mentioned in section III there arises the question of in-
consistency, whether in remote parts of the same speciÔ¨Åcation,
for instance, somewhere up or down relative to the current
abstract predicate calling stack, there are in fact two identical
heaplets or if there are any two pointers with the same location
multiple times. The reason beyond is non-repetitiveness.
This problem may be resolved in general only dynamically
during the veriÔ¨Åcation due to the undecidability of abstract
predicates due to the undecidability of the Halting-problem.
Hence a stack-based analysis for processing abstract pred-
icates is needed very similar to the operational semantics
provided by Warren [15] including processing of symbols and
back-references to the stack parameters, except that abstract
predicates require an adapted reasoning control (see [14]).
Applying Warren‚Äôs approach to strict heap conjunction and
disjunction will decide ‚àÄa.a ‚ó¶ a. Because of ungrounded
symbols, a memoizer may not cope with global states in
abstract predicates.
Prolog is a general purpose logical programming language
[16]. We strongly believe Prolog may be used to reason
8
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-506-7
ADVCOMP 2016 : The Tenth International Conference on Advanced Engineering Computing and Applications in Sciences

about extended heap terms and abstract predicates in order to
resolve key heap veriÔ¨Åcation problems, such as expressibility
restrictions [14]. One advantage of Prolog predicates over
classic one-way functions (as used in [4], for instance) is that
input and output terms may be considered as relation, unioning
exponentially many different combinations of input and output
vectors, skipping only those combinations where a relation is
not deÔ¨Åned. This is often the case when the corresponding
one-way function is either non-invertible, contains cuts or
arithmetic evaluations (e.g. by using the built-in predicate is).
There must be a strong correlation between input and output
vectors, s.t. a bijective mapping exists between both vectors
for the most common deÔ¨Ånition. Besides, Prolog predicates
containing cuts may always be rewritten w.l.o.g. cut-free.
Predicates containing is may be rewritten without as ground
term, e.g. a Church number, as long as it can be represented
as uniÔ¨Åable term, which is feasible even if not too elegantly.
The ‚ÄúObject Constraint Language‚Äù (OCL) [17] is a spec-
iÔ¨Åcation language for class-instantiated objects in companion
with the ‚ÄúUniÔ¨Åed Modeling Language‚Äù. It implements a frag-
ment of the predicate logic, it supports some quantiÔ¨Åcation
of variables and supports collection types and ad-hoc poly-
morphism by sub-classing. It allows life-cycle speciÔ¨Åcation of
objects and class methods. However, OCL does not know of
pointer constraints like aliasing. If pointer constraints were
added to OCL and propagated down to code generation when
compiling user code, for instance, then code performance
could signiÔ¨Åcantly improve (compare with [14]). In com-
bination with abstract predicates the proposed modiÔ¨Åcation
of this paper may be used as proposition for an update of
the recent OCL recommendation w.r.t. the intrinsic points-
to model, particularly referring here to conventions 2.3, and
deÔ¨Ånitions 3.1 and 3.2. Presumably, this would also raise
expressibility, abstraction and higher modularity. Previous
attempts to demonstrate applications of Separation Logic to
Design Patterns can be found for instance in [4].
VI. CONCLUSIONS
At the beginning, the problem of verifying dynamic heap
was introduced. Related problems and the beneÔ¨Åt of the
heap separation model were provided. The description of
points-to assertions corresponds to heap-manipulating program
statements ‚Äì in the chosen model the generated heap graph is
described edge-wise. The problem with the ‚ãÜ-operator was that
it may be used syntactically and semantically in two different
ways: for heap disjunction, but also for heap conjunction. This
caused the described issues. The introduction of two strict
heap operations allows heap terms to be interpreted simple. In
addition to this, partial object speciÔ¨Åcations make it promising
to understand and control better completeness w.r.t. incoming
heaps in heap formulae. Properties of both operations were
investigated and found restrictive, but still Ô¨Çexible enough for
expressing arbitrary heap graphs. The integration of derived
rules to a SMT-solver requires further research. Finally an
extension of the current OCL was proposed.
ACKNOWLEDGEMENT
Some parts of this paper have been prepared within the
scope of project part of the state plan of the Board of Education
and Science of Russia (task # 2.136.2014/K).
REFERENCES
[1] R. Jones, A. Hosking, and E. Moss, The Garbage Collection Hand-
book: The Art of Automatic Memory Management, 1st ed. Chapman &
Hall/CRC Press, 2011.
[2] J. C. Reynolds, Separation Logic: A logic for shared mutable data
structures, in Lecture Notes in Computer Science, Springer, pp. 55‚Äì74,
2002.
[3] R. M. Burstall, Some techniques for proving correctness of programs
which alter data structures, in Machine Intelligence 7, B. Meltzer and
D. Michie (eds.), Edinburgh University Press, Scotland, pp. 23‚Äì50, 1972.
[4] M. Parkinson, Local reasoning for Java, Ph.D. thesis, Cambridge
University, England, 2005, 159p.
[5] J. Berdine, C. Calcagno, and P. W. O‚ÄôHearn, Smallfoot: Modular
automatic assertion checking with Separation Logic, in Lecture Notes
in Computer Science, Springer, pp. 115‚Äì137, 2005.
[6] M. Sagiv, T. Reps, and R. Wilhelm, Parametric shape analysis via 3-
valued logic, ACM Transactions of Programming Language Systems,
vol. 24(3), pp. 217‚Äì298, 2002.
[7] M. Abadi, Baby Modula-3 and a Theory of Object, Systems Research
Center, Digital Equipment Corporation, Technical Report, 1993.
ftp://gatekeeper.research.compaq.com/pub/DEC/SRC/research-
reports/abstracts/src-rr-095.html
[8] M. Abadi and K. R. M. Leino, A Logic of Object-Oriented Programs,
in TAPSOFT ‚Äô97: Proceedings of the 7th International Joint Confer-
ence CAAP/FASE on Theory and Practice of Software Development,
Springer, pp. 682‚Äì696, 1997.
[9] N. Suzuki, Analysis of Pointer ‚ÄùRotation‚Äù, Communications of the
ACM, vol. 25(5), pp. 330‚Äì335, 1982.
[10] B. Meyer, Proving pointer program properties - Part 1: Context and
overview, Part 2: The overall object structure, ETH Z¬®urich, Journal of
Object Technology, 2003.
[11] A. W. Appel, Garbage collection can be faster than stack alloca-
tion, Information Processing Letters, vol. 25(4), pp. 275‚Äì279, 1987.
http://dx.doi.org/10.1016/0020-0190(87)90175-X
[12] K. Dosen, et. al, Substructural Logics, K. Dosen and P. Schroeder-
Heister (eds.) Clarendon Press, Oxford Science Publications, 1993, 386p.
[13] G. Restall, On logics without contraction,‚Äù Ph.D. thesis, Department of
Philosophy, University of Queensland, 1994, 278p.
[14] R. Haberland and S. Ivanovskiy, Dynamically allocated memory ver-
iÔ¨Åcation in object-oriented programs using Prolog, in Proceedings of
the 8th Spring/Summer Young Researchers‚Äô Colloquium on Software
Engineering, A. Kamkin, A. Petrenko, and A. Terekhov (eds.), pp. 46‚Äì
50, 2014.
[15] D. H. Warren, Applied logic - its use and implementation as a program-
ming tool, SRI International, Menlo Park, California, USA, Technical
Report No. 290, 1983.
[16] L. Sterling and E. Shapiro, The Art of Prolog (2nd Edition): Advanced
Programming Techniques. MIT Press, Cambridge, Massachusetts, USA,
1994.
[17] Object Management Group (OMG), Object Constraint Language Spec-
iÔ¨Åcation, version 2.2, Feb 2010, http://www.omg.org/spec/OCL/2.2.
9
Copyright (c) IARIA, 2016.     ISBN:  978-1-61208-506-7
ADVCOMP 2016 : The Tenth International Conference on Advanced Engineering Computing and Applications in Sciences

