212
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Synthesizing Control Software from Boolean Relations
Federico Mari, Igor Melatti, Ivano Salvo, and Enrico Tronci
Department of Computer Science
Sapienza University of Rome
Via Salaria 113, 00198 Rome, Italy
Email: {mari,melatti,salvo,tronci}@di.uniroma1.it
Abstract—Many software as well digital hardware automatic
synthesis methods deﬁne the set of implementations meeting
the given system speciﬁcations with a boolean relation K. In
such a context a fundamental step in the software (hardware)
synthesis process is ﬁnding effective solutions to the functional
equation deﬁned by K. This entails ﬁnding a (set of) boolean
function(s) F (typically represented using OBDDs, Ordered
Binary Decision Diagrams) such that: 1) for all x for which K
is satisﬁable, K(x, F(x)) = 1 holds; 2) the implementation of
F is efﬁcient with respect to given implementation parameters
such as code size or execution time. While this problem has
been widely studied in digital hardware synthesis, little has
been done in a software synthesis context. Unfortunately, the
approaches developed for hardware synthesis cannot be directly
used in a software context. This motivates investigation of
effective methods to solve the above problem when F has to
be implemented with software. In this paper, we present an
algorithm that, from an OBDD representation for K, generates
a C code implementation for F that has the same size as the
OBDD for F and a worst case execution time linear in nr,
being n = |x| the number of input arguments for functions in
F and r the number of functions in F. Moreover, a formal
proof of the proposed algorithm correctness is also shown.
Finally, we present experimental results showing effectiveness
of the proposed algorithm.
Keywords-Control Software Synthesis; Embedded Systems;
Model Checking
I. INTRODUCTION
Many software as well digital hardware automatic syn-
thesis methods deﬁne the set of implementations meeting
the given system speciﬁcations with a boolean relation K.
Given an n-bits (resp., r-bits) binary encoding of states
(resp., actions) of the system as it is usually done in Model
Checking [7] (see Sect. III-B), such relation typically takes
as input the n-bits encoding of a state x and the r-bits
encoding of a proposed action to be performed u, and returns
true (i.e., 1) if and only if the system speciﬁcations are met
when performing action u in state x. In such a context, a
fundamental step in the software (hardware) synthesis pro-
cess is ﬁnding effective solutions to the functional equation
deﬁned by K, i.e., K(x, u) = 1. This entails ﬁnding a tuple
of boolean functions F = ⟨f1, . . . , fr⟩ (typically represented
using OBDDs, Ordered Binary Decision Diagrams [2])
such that 1) for all x for which K is satisﬁable (i.e., it
enables at least one action), K(x, F(x)) = 1 holds, and 2)
the implementation of F is efﬁcient with respect to given
implementation parameters such as code size or execution
time.
While this problem has been widely studied in digital
hardware synthesis [3][4], little has been done in a software
synthesis context. This is not surprising since software
synthesis from formal speciﬁcations is still in its infancy.
Unfortunately the approaches developed for hardware syn-
thesis cannot be directly used in a software context. In
fact, synthesis methods targeting a hardware implementation
typically aim at minimizing the number of digital gates and
of hierarchy levels. Since in the same hierarchy level gates
output computation is parallel, the hardware implementation
WCET (Worst Case Execution Time) is given by the number
of levels. On the other hand, a software implementation will
have to sequentially compute the gates outputs. This implies
that the software implementation WCET is the number of
gates used, while a synthesis method targeting a software
implementation may obtain a better WCET. This motivates
investigation of effective methods to solve the above problem
when F has to be implemented with software.
A. Our Contribution
In this paper, we present an algorithm that, from an
OBDD representation for K, effectively generates a C code
implementation for K that has the same size as the OBDD
for F and a WCET linear in linear in nr, being n = |x| the
number of bits encoding state x and r = |u| the number of
bits encoding action u. This is done in two steps:
1) from an OBDD representation for K we effectively
compute an OBDD representation for F, following the
lines of [5];
2) we generate a C code implementation for F with the
above described properties of code size and WCET.
We formally prove both steps 1 and 2 to be correct.
This allows us to synthesize correct-by-construction con-
trol software, provided that K is provably correct with
respect to initial formal speciﬁcations. This is the case
of [6], where an algorithm is presented to synthesize K
starting from a) the formal speciﬁcation of a Discrete-Time
Linear Hybrid System (DTLHS in the following) modeling
the system (plant) to be controlled, b) its system level
formal speciﬁcations (specifying the goal to be reached
and the safe states to be traversed in order to reach it)

213
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 1.
Control Software Synthesis Flow
and c) the quantization schema (i.e., the number of bits
available for analog-to-digital conversion). The framework
in [6] is depicted in Figure 1. With respect to Figure 1, the
approach proposed in this paper may be used to perform step
3. Thus, this methodology allows a correct-by-construction
control software to be synthesized, starting from formal
speciﬁcations for DTLHSs.
Note that the problem of solving the functional equation
K(x, F(x)) = 1 with respect to F is trivially decidable,
since there are ﬁnitely many F. However, trying to explicitly
enumerate all F requires time Ω(2r2n). By using OBDD-
based computations, we are able to compute F in time
O(r2n) in the worst case. However, in many interesting
cases OBDD sizes and computations are much lower than
the theoretical worst case (e.g., in Model Checking applica-
tions, see [7]).
Furthermore, once the OBDD representation for F has
been computed, a trivial implementation of F could use
a look-up table in RAM. While this solution would yield
a better WCET, it would imply a Ω(r2n) RAM usage.
Unfortunately, implementations for F in real-world cases are
typically implemented on microcontrollers (this is the case,
e.g., for embedded systems). Since microcontrollers usually
have a small RAM, the look-up table based solution is not
feasible in many interesting cases. The approach we present
here will rely on OBDDs compression to overcome such
obstruction.
Moreover, F : Bn → Br is composed by r boolean
functions, thus it is represented by r OBDDs. Such OBDDs
typically share nodes among them. If a trivial implementa-
tion of F in C code is used, i.e., each OBDD is translated as
a stand-alone C function, such inter-OBDDs nodes sharing
will not be exploited. In our approach, we exploit inter-
OBDDs nodes sharing, thus the control software we generate
fully takes advantage of OBDDs compression.
Finally, we present experimental results showing effec-
tiveness of the proposed algorithm. As an example, in less
than 1 second and within 350 MB of RAM we are able
to synthesize the control software for a function K of 25
boolean variables, divided in n = 20 state variables and
r = 5 action variables, represented by an OBDD with
about 6.6 × 104 nodes. Such K represents the set of correct
implementations for a real-world system, namely a multi-
input buck DC/DC converter [8], obtained as described
in [6]. The control software we synthesize in such a case
has about 1.7 × 104 lines of code, whilst a control software
not taking into account OBDDs nodes sharing would have
had about 2.1 × 104 lines of code. Thus, we obtain a 20%
gain towards a trivial implementation.
This paper is organized as follows. In Section III we
give the basic notions to understand our approach. In Sec-
tion IV we formally deﬁne the problem we want to solve.
In Section V we give deﬁnition and main properties of
COBDDs (i.e., Complemented edges OBDDs), on which
our approach is based. Section VI describes the algorithms
our approach consists of, whilst Section VII proves it to be
correct. Section VIII presents experimental results showing
effectiveness of the proposed approach. Finally, Section IX
presents the concluding remarks and gives some ideas for
future work.
II. RELATED WORK
This paper is an extended version of [1]. With respect
to [1], this paper provides more details in the introduction

214
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
and in the related work description, extends basic deﬁni-
tions and algorithms descriptions, shows omitted proofs for
theorems and provides a revised version of the experiments.
Synthesis of boolean functions F satisfying a given
boolean relation K in a way such that K(x, F(x)) = 1 is
also addressed in [3]. However, [3] targets a hardware set-
ting, whereas we are interested in a software implementation
for F. Due to structural differences between hardware and
software based implementations (see the discussion in Sec-
tion I), the method in [3] is not directly applicable here. An
OBDD-based method for synthesis of boolean (reversible)
functions is presented in [4] (see also citations thereof).
Again, the method in [4] targets a hardware implementation,
thus it is not applicable here.
An algorithm for the synthesis of C control software is
also presented in [9]. However, in [9] the starting point
is a (multioutput) boolean function, rather than a boolean
relation. That is to say, the starting point is F rather than K
(with respect to the discussion in Section I-A, it is supposed
that step 1 has already been performed). Moreover, the
algorithm in [9], though OBDD-based, does not generate
a software with the same size of the OBDDs for F, nor
an estimation of its WCET (in the sense explained in
Section I) is provided. Finally, an implementation of the
algorithm in [9] is not provided, thus we cannot make a
direct experimental comparison with our method.
Synthesis of control software is also addressed in [10],
where the focus is on the generation of control protocols.
Such method cannot be applied in our context, where we
need a C software implementation.
In [6], an algorithm is presented which, starting from
a formal speciﬁcation of a DTLHS, synthesizes a correct-
by-construction boolean relation K, and then a correct-by-
construction control software implementation for K (see
Figure 1). However, in [6] the implementation of K is
not described in detail. Furthermore, the implementation
synthesis described in [6] has not the same size of the OBDD
for F, i.e., it does not exploit OBDD nodes sharing.
Many other works in the literature has the goal of syn-
thesizing controllers as boolean relations K, under very
different assumptions for the target dynamic system to be
controlled. Such works do not deal with the effective imple-
mentation of K, thus they may use the approach described
here in order to have an effective software implementation
of K. As an example, the following works may be cited
as closer to ours. In [11] controllers are generated starting
from ﬁnite-state nondeterministic dynamic systems (arising
from planning problems). In [12] a method to synthesize
non-optimal (but smaller in size) controllers is presented.
In [5], an algorithm is presented which computes boolean
functions F satisfying a given boolean relation K in a way
such that K(x, F(x)) = 1. This approach is very similar
to ours. However [5] does not generate the C code control
software and it does not exploit OBDD nodes sharing.
Finally, we note that our work lies in the wider area of
software synthesis, which has been widely studied since a
long time in many contexts. For a survey on such (non-
control) software synthesis works, see [13][14].
III. BASIC DEFINITIONS
In the following, we denote with B = {0, 1} the boolean
domain, where 0 stands for false and 1 for true. We will
denote boolean functions f
: Bn
→ B with boolean
expressions on boolean variables involving + (logical OR),
· (logical AND, usually omitted thus xy = x · y), ¯ (log-
ical complementation) and ⊕ (logical XOR). We will also
denote vectors of boolean variables in boldface, e.g., x =
⟨x1, . . . , xn⟩. Moreover, we also denote with f|xi=g(x) the
boolean function f(x1, . . . , xi−1, g(x), xi+1, . . . , xn) and
with ∃xi f(x) the boolean function f|xi=0(x)+f|xi=1(x).
Finally, we denote with [n] the set {1, . . . , n}.
A. Most General Optimal Controllers
A Labeled Transition System (LTS) is a tuple S
=
(S, A, T) where S is a ﬁnite set of states, A is a ﬁnite set of
actions, and T is the (possibly non-deterministic) transition
relation of S. A controller for an LTS S is a function
K : S ×A → B enabling actions in a given state. We denote
with Dom(K) the set of states for which a control action
is enabled. An LTS control problem is a triple P = (S, I,
G), where S is an LTS and I, G ⊆ S. A controller K for
S is a strong solution to P if and only if it drives each
initial state s ∈ I in a goal state t ∈ G, notwithstanding
nondeterminism of S. A strong solution K∗ to P is optimal
if and only if it minimizes path lengths. An optimal strong
solution K∗ to P is the most general optimal controller (we
call such solution an mgo) if and only if in each state it
enables all actions enabled by other optimal controllers. For
more formal deﬁnitions of such concepts, see [15].
Efﬁcient algorithms, typically reminiscent of early work
on minimum paths by Dijkstra [16], to compute controllers
starting from suitable (nondeterministic) LTS control prob-
lems have been proposed in the literature: e.g., [11] presents
an algorithm to generate mgos, while [12] show an algorithm
for non-optimal (but smaller in size) controllers. Once a
controller K has been computed, solving and implementing
the functional equation K(x, u) = 1 allows a correct-by-
construction control software to be synthesized.
B. Binary Encoding for States and Actions
Vectors of boolean values x ∈ Bn (resp., u ∈ Br) may
be used to represent states s ∈ S (resp., actions a ∈ A)
of an LTS S = (S, A, T) (and thus of a controller for
S) as follows. Let n = ⌊log2(|S|)⌋ + 1. Then, n boolean
values (bits) may be used to represent any s ∈ S. As an
example, in Model Checking applications [7] an order on
S = {s1, . . . , sm} is ﬁxed (let s1 < . . . < sm be such
order), and then the binary encoding η : S → Bn is deﬁned

215
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
as η(si) = b such that Pn
j=1 2j−1bj = i − 1. An analogous
construction may be applied to actions.
C. OBDD Representation for Boolean Functions
A Binary Decision Diagram (BDD) R is a rooted directed
acyclic graph (DAG) with the following properties. Each
R node v is labeled either with a boolean variable var(v)
(internal node) or with a boolean constant val(v) ∈ B
(terminal node). Each R internal node v has exactly two
children, labeled with high(v) and low(v). Let x1, . . . , xn
be the boolean variables labeling R internal nodes. Each
terminal node v represents fv(x) = val(v). Each internal
node v represents fv(x) = xifhigh(v)(x) + ¯xiflow(v)(x),
being xi = var(v). An Ordered BDD (OBDD) is a BDD
where, on each path from the root to a terminal node, the
variables labeling each internal node must follow the same
ordering.
IV. SOLVING A BOOLEAN FUNCTIONAL EQUATION
Let K(x1, . . . , xn, u1, . . . , ur) be the mgo for a given
control problem P
=
(S, I, G). We want to solve
the boolean functional equation K(x, u) = 1 with re-
spect to variables u, that is we want to obtain boolean
functions f1, . . . , fr such that K(x, f1(x), . . . , fr(x)) =
K|u1=f1(x),...,ur=fr(x)(x, u) = 1. This problem may be
solved in different ways, depending on the target imple-
mentation (hardware or software) for functions fi. In both
cases, it is crucial to be able to bound the WCET (Worst
Case Execution Time) of the obtained controller. In fact,
controllers must work in an endless closed loop with the
system S (plant) they control. This implies that, every T
seconds (sampling time), the controller has to determine the
actions to be sent to S. Thus, in order for the entire system
(plant + control software) to properly work, the controller
WCET upper bound must be at most T.
In [3], f1, . . . , fr are generated in order to optimize
a hardware implementation. In this paper, we focus on
software implementations for fi (control software). As it
is discussed in Section I, simply translating an hardware
implementation into a software implementation would re-
sult in a too high WCET. Thus, a method directly tar-
geting software is needed. An easy solution would be
to set up, for a given state x, a SAT problem instance
C = CK1, . . . , CKt, c1, . . . , cn, where CK1 ∧ . . . ∧ CKt
is equisatisﬁable to K and each clause ci is either xi (if
xi is 1) or ¯xi (otherwise). Then C may be solved using a
SAT solver, and the values assigned to u in the computed
satisfying assignment may be returned as the action to be
taken. However, it would be hard to estimate a WCET for
such an implementation. The method we propose in this
paper overcomes such obstructions by achieving a WCET
proportional to rn.
 u0 
 u1 
 x0 
 x1 
 x2 
K
0x17
0x12
0x16
0x10
0x11
0x15
1
0xf
0xe
0x13
0x14
Figure 2.
An mgo example
V. OBDDS WITH COMPLEMENTED EDGES
In this section, we introduce OBDDs with complemented
edges (COBDDs, Deﬁnition 1), which were ﬁrst presented
in [17][18]. Intuitively, they are OBDDs where else edges
(i.e., edges of type (v, low(v))) may be complemented. Then
edges (i.e., edges of type (v, high(v))) complementation
is not allowed to retain canonicity. Edge complementation
usually reduce resources usage, both in terms of CPU and
memory.
Deﬁnition 1. An OBDD with complemented edges (COBDD
in the following) is a tuple ρ = (V, V , 1, var, low, high,
ﬂip) with the following properties:
1) V = {x1, . . . , xn} is a ﬁnite ordered set of boolean
variables;
2) V is a ﬁnite set of nodes;
3) 1 ∈ V is the terminal node of ρ, corresponding to
the boolean constant 1 (non-terminal nodes are called
internal);
4) var, low, high, ﬂip are functions deﬁned on internal
nodes, namely:
• var : V \ {1} → V assigns to each internal node
a boolean variable in V
• high[low] : V \ {1} → V assigns to each internal
node v a high child [low child] (or then child [else
child]), representing the case in which var(v) = 1
[var(v) = 0]
• ﬂip : V \ {1} → B assigns to each internal node
v a boolean value; namely, if ﬂip(v) = 1 then the
else child has to be complemented, otherwise it is
regular (i.e., non-complemented);
5) for each internal node v, var(v) < var(high(v)) and
var(v) < var(low(v)).

216
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
A. COBDDs Associated Multigraphs
We associate to a COBDD ρ = (V, V , 1, var, low, high,
ﬂip) a labeled directed multigraph G(ρ) = (V, E) such that
V is the same set of nodes of ρ and there is an edge (v, w) ∈
E if and only if w is a child of v. Moreover, each edge e =
(v, w) ∈ E has a type type(e), indicating if e is a then edge
(i.e., if w is a then child of v), a regular else edge (i.e., if w
is an else child of v with ﬂip(v) = 0), or a complemented
else edge (i.e., if w is an else child of v with ﬂip(v) = 1).
Figure 2 shows an example of a COBDD depicted via its
associated multigraph, where edges are directed downwards.
Moreover, in Figure 2 then edges are solid lines, regular
else edges are dashed lines and complemented else edges
are dotted lines.
The graph associated to a given COBDD ρ = (V, V , 1,
var, low, high, ﬂip) may be seen as a forest with multiple
rooted multigraphs. In order to select one root vertex and
thus one rooted multigraph, we deﬁne the COBDD restricted
to v ∈ V as the COBDD ρv = (V, Vv, 1, var, low, high,
ﬂip) such that Vv = {w ∈ V | there exists a path from v to
w in G(ρ)} (note that v ∈ Vv).
B. COBDDs Properties
For a given COBDD ρ = (V, V , 1, var, low, high, ﬂip)
the following properties follow from deﬁnitions given above:
1) G(ρ) is a rooted directed acyclic (multi)graph (DAG);
2) each path in G(ρ) starting from an internal node ends
in 1;
3) let v1, . . . , vk be a path in G(ρ), then var(v1) < . . . <
var(vk).
We deﬁne the height of a node v in a COBDD ρ (notation
heightρ(v), or simply height(v) if ρ is understood) as the
height of the DAG G(ρv), i.e., the length of the longest path
from v to 1 in G(ρ).
C. Semantics of a COBDD
In Deﬁnition 2, we deﬁne the semantics J·K of each node
v of a given COBDD ρ as the boolean function represented
by v, given the parity b of complemented edges seen on the
path from a root to v.
Deﬁnition 2. Let ρ = (V, V , 1, var, low, high, ﬂip)
be a COBDD. The semantics of the terminal node 1 with
respect to a ﬂipping bit b is a boolean function deﬁned as
J1, bKρ := ¯b. The semantics of an internal node v ∈ V with
respect to a ﬂipping bit b is a boolean function deﬁned as
Jv, bKρ := xiJhigh(v), bKρ + ¯xiJlow(v), b ⊕ ﬂip(v)Kρ, being
xi = var(v). When ρ is understood, we will write J·K instead
of J·Kρ.
Note that the semantics of a node of a COBDD ρ is
a function of variables in V and of an additional boolean
variable b. Thus, on each node two boolean functions on
V are deﬁned (one for each value of b). It can be shown
(see [15]) that such boolean functions are complementary.
Example 1. Let ρ be the COBDD depicted in Figure 2. If we
pick node 0xe we have J0xe, bK = x2J1, bK + ¯x2J1, b ⊕ 1K =
x2¯b + ¯x2b = x2 ⊕ b.
D. Reduced COBDDs and COBDDs Canonicity
Two COBDDs are isomorphic if and only if there exists a
mapping from nodes to nodes preserving attributes var, ﬂip,
high and low. A COBDD is called reduced if and only if it
contains no vertex v with low(v) = high(v) ∧ ﬂip(v) = 0,
nor does it contains distinct vertices v and v′ such that ρv and
ρv′ are isomorphic. Note that, differently from OBDDs, it is
possible that high(v) = low(v) for some v ∈ V , provided
that ﬂip(v) = 1 (e.g., see nodes 0xf and 0xe in Figure 2).
Theorem 1 states that reduced COBDDs are a canonical
representation for boolean functions (see [17][18]). As a
consequence, software packages implementing COBDDs op-
erations only deal with reduced COBDDs, since this allows
very fast equality tests between COBDDs (it is sufﬁcient
to check if the (root node, ﬂipping bit) pair is the same).
Accordingly, in the following we will deal with reduced
COBDDs only.
Theorem 1. Let f : Bn → B be a boolean function. Then
there exists a reduced COBDD ρ = (V, V , 1, var, low,
high, ﬂip), a node v ∈ V and a ﬂipping bit b ∈ B such that
Jv, bK = f(x). Moreover, let ρ = (V, V , 1, var, low, high,
ﬂip) be a reduced COBDD, let v1, v2 ∈ V be nodes and
b1, b2 ∈ B be ﬂipping bits. Then Jv1, b1K = Jv2, b2K if and
only if v1 = v2 ∧ b1 = b2.
VI. SYNTHESIS OF C CODE FROM A COBDD
Let K(x1, . . . , xn, u1, . . . , ur) be a controller for a given
control problem. Let ρ = (V, V , 1, var, low, high, ﬂip)
be a COBDD such that there exist v ∈ V , b ∈ B such
that Jv, bK = K(x1, . . . , xn, u1, . . . , ur). Thus, V = X ·∪
U = {x1, . . . , xn} ·∪{u1, . . . , ur} (we denote with ·∪ the
disjoint union operator, thus X ∩ U = ∅). We will call
variables xi ∈ X as state variables and variables uj ∈ U as
action variables.
We want to solve the boolean functional equation problem
introduced in Sect. IV targeting a software implementation.
We do this by using a COBDD representing all our boolean
functions. This allows us to exploit COBDD nodes sharing.
This results in an improvement for the method in [5], which
targets a software implementation but which does not exploit
sharing. Finally, we also synthesize the software (i.e., C
code) implementation for f1, . . . , fr, which is not considered
in [5]. This allows us to ﬁnally have a control software for
the starting LTS. If K is an mgo, this results in an optimal
control software for the starting LTS.
A. Synthesis Algorithm: Overview
Our method Synthesize takes as input ρ, v and b such
that Jv, bK = K(x, u). Then, it returns as output a C
function void K(int *x, int *u) with the following

217
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
property: if, before a call to K, ∀i x[i−1]= xi holds (array
indexes in C language begin from 0) with x ∈ Dom(K), and
after the call to K, ∀i u[i−1]= ui holds, then K(x, u) = 1.
Moreover, the WCET of function K is O(nr).
Note that our method Synthesize provides an effective
implementation of the controller K, i.e., a C function which
takes as input the current state of the LTS and outputs the
action to be taken. Thus, K is indeed a control software.
Function Synthesize is organized in two phases. First,
starting from ρ, v and b (thus from K(x, u)), we generate
COBDD nodes v1, . . . , vr and ﬂipping bits b1, . . . , br for
boolean functions f1, . . . , fr such that each fi = Jvi, biK
takes as input the state bit vector x and computes the i-th
bit ui of an output action bit vector u, where K(x, u) = 1,
provided that x ∈ Dom(K). This computation is carried
out in function SolveFunctionalEq. Second, f1, . . . , fr are
translated inside function void K(int *x, int *u).
This step is performed by maintaining the structure of the
COBDD nodes representing f1, . . . , fr. This allows us to
exploit COBDD nodes sharing in the generated software.
This phase is performed by function GenerateCCode.
Thus, function Synthesize is organized as in Algorithm 1.
Correctness for function Synthesize is stated in Theorem 6.
Algorithm 1 Translating COBDDs to a C function
Require: COBDD ρ, node v, boolean b
Ensure: Synthesize(ρ, v, b):
1: ⟨v1, b1, . . . , vr, br⟩ ← SolveFunctionalEq(ρ, v, b)
2: GenerateCCode(ρ, v1, b1, . . . , vr, br)
B. Synthesis Algorithm: Solving a Functional Equation
In this phase, starting from ρ, v and b (thus from Jv, bK =
K(x, u)), we compute functions f1, . . . , fr such that for all
x ∈ Dom(K), K(x, f1(x), . . . , fr(x)) = 1.
To this aim, we follow an approach similar to the
one presented in [5], which is reminiscent of early work
on minimum paths by Dijkstra. Namely, we compute
fi using f1, . . . , fi−1, in the following way: fi(x)
=
∃ui+1, . . . , un
K(x, f1(x), . . . , fi−1(x), 1, ui+1, . . . , un).
Thus, function SolveFunctionalEq(ρ, v, b) computes and re-
turns ⟨v1, b1, . . . , vr, br⟩ such that for all i ∈ [r], Jvi, biK =
fi(x). This is effectively performed by Algorithm 2, where
we use the following COBDDs manipulation functions:
• COBDD APP
(instantiation)
such
that
⟨vAP P ,
bAP P ⟩
=
COBDD APP(xi1,
. . . ,
xik,
v1,
b1,
. . . ,
vk,
bk,
v, b)
if
and
only
if
JvAP P , bAP P K = Jv, bK|xi1=Jv1,b1K,...,xik =Jvk,bkK;
• COBDD EX (existential quantiﬁer elimination) such
that ⟨vEX, bEX⟩ = COBDD EX(xi1, . . . , xik, v, b)
if and only if JvEX, bEXK = ∃xi1, . . . , xik Jv, bK.
We note that efﬁcient (i.e., at most O(|V | log |V |)) al-
gorithms [17][18] exist to compute the above deﬁned func-
tions. Moreover, the above deﬁned functions may create new
COBDD nodes. We assume that such functions also properly
update V , var, low, high, ﬂip inside COBDD ρ (1 and V
are not affected).
Algorithm 2 Solving a boolean functional equation
Require: COBDD ρ, node v, boolean b
Ensure: SolveFunctionalEq(ρ, v, b):
1: for all i ∈ [r] do
2:
Jvi,
biK
←
COBDD EX(ui+1, . . . ,
un,
COBDD APP(u1, . . . , ui, v1, b1, . . . , vi−1, bi−1,
1, 0, v, b))
3: return ⟨v1, b1, . . . , vr, br⟩
Correctness for function SolveFunctionalEq is proved in
Lemma 3.
C. Synthesis Algorithm: Generating C Code
In this phase, starting from COBDD nodes v1, . . . , vr and
ﬂipping bits b1, . . . , br for functions f1, . . . , fr generated
in the ﬁrst phase, we generate two C functions: i) void
K(int *x, int *u), which is the required output func-
tion for our method Synthesize; ii) int K_bits(int *x,
int action), which is an auxiliary function called by
K. A call to K_bits(x, i) returns fi(x), being x[j −
1]= xj for all j ∈ [n]. This phase is detailed in Algs. 3
(function GenerateCCode) and 4 (function Translate). In
such algorithms we suppose to be able to print a node v,
e.g., by printing the exadecimal value of a pointer to v.
Algorithm 3 Generating C functions
Require: COBDD ρ, v1, . . . , vr, boolean values b1, . . . , br
Ensure: GenerateCCode(ρ, v1, b1, . . . , vr, br):
1: print
“int K_bits(int *x, int action) {
int ret_b; switch(action) {”
2: for all i ∈ [r] do
3:
print “case ”, i − 1, “:”
4:
print “ret_b = ”, ¯bi, “; goto L_”, vi,“;”
5: print “}” /* end of the switch block */
6: W ← ∅
7: for all i ∈ [r] do
8:
W ←Translate(ρ, vi, W)
9: print “} K(int* x, int* u) {int i;”
10: print “
for(i=0; i<”,r,“; i++)”
11: print “
u[i] = K_bits(x, i);}”
Details of Function GenerateCCode (Algorithm 3):
Given inputs ρ, v1, b1, . . . , vr, br (output by SolveFunc-
tionalEq), Algorithm 3 works as follows. First, function
int K_bits(int *x, int action) is generated. If
x[j − 1]= xj for all j ∈ [n], the call K_bits(x, i)
has to return fi(x). In order to do this, the graph G(ρvi)
is traversed by taking, in each node v, the then edge if
x[j−1] = 1 (with j such that var(v) = xj) and the else edge

218
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
otherwise. When node 1 is reached, then 1 is returned if and
only if the integer sum c+bi is even, being c the number of
complemented else edges traversed. Note that parity of c+bi
may be maintained by initializing a C variable ret_b to ¯bi,
then complementing ret_b (i.e., by performing a ret_b
= !ret_b statement) when a complemented else edge is
traversed, and ﬁnally returning ret_b.
This mechanism is implemented inside function K_bits
by properly translating each COBDD node ˜v ∈ Sr
i=1 Vvi in
a C code block. Each block is labeled with a unique label
depending on ˜v, and maintains in variable ret_b the current
parity of c+bi as described above. This is done by function
Translate, called on line 8 and detailed in Algorithm 4.
Thus, the initial part of function K_bits consists of a
switch block (generated in lines 1–5 of Algorithm 3),
which initializes ret_b to ¯bi and then jumps to the label
corresponding to node vi. Then, the C code blocks cor-
responding to COBDD nodes are generated in lines 6–8
of Algorithm 3, by calling r times function Translate (see
Algorithm 4) with parameters v1, . . . , vr. Note that W main-
tains the already translated COBDD nodes. Since function
Translate only translates nodes not in W, this allows us to
exploit sharing not only inside each G(ρvi), but also inside
G(ρv1), . . . , G(ρvr ).
Finally, function K is generated in lines 9–11. Function
K simply consists in a for loop ﬁlling each entry u[i]
of the output array u with the boolean values returned by
K_bits(x, i). Correctness of function GenerateCCode
is proved in Lemma 5.
Algorithm 4 COBDD nodes translation
Require: COBDD ρ, node v, nodes set W
Ensure: Translate(ρ, v, W):
1:
if v ∈ W then return W
2: W ← W ∪ {v}
3: print “L_”, v, “:”
4: if v = 1 then
5:
print “return ret_b;”
6: else
7:
let i be such that var(v) = xi
8:
print “if(x[”,i − 1,“]==1)goto L_”, high(v)
9:
if ﬂip(v) then
10:
print “else {ret_b = !ret_b;’’
11:
print “goto L_”, low(v),“;}”
12:
else
13:
print “else goto L_”, low(v)
14:
W ←Translate(ρ, high(v), W)
15:
W ←Translate(ρ, low(v), W)
16: return W
Details of Function Translate (Algorithm 4): Given in-
puts ρ, v, W, Algorithm 4 performs a recursive graph traver-
sal of G(ρv) as follows.
The C code block for internal node v is generated in
lines 3 and 7–13. The block consists of a label L_v: and
an if-then-else C construct. Note that label L_v uni-
vocally identiﬁes the C code block related to node v. This
may be implemented by printing the exadecimal value of a
pointer to v.
The if-then-else C construct is generated so as to
traverse node v in graph G(ρv) in the following way. In
line 8 the check x[i−1]= 1 is generated, being i such that
var(v) = xi. The code to take the then edge of v is also gen-
erated. Namely, it is sufﬁcient to generate a goto statement
to the C code block related to node high(v). In lines 10–11
and 13 the code to take the else edge is generated, in the case
x[i − 1]= 1 is false. In this case, if the else edge is com-
plemented, i.e., ﬂip(v) holds (lines 10–11), it is necessary
to complement ret_b and then perform a goto statement
to the C code block related to node low(v) (lines 10–11).
Otherwise, it is sufﬁcient to generate a goto statement to
the C code block related to node low(v) (line 13).
Thus, the block generated for an internal node v, for
proper i, l and h, has one of the following forms, depending
on ﬂip(v):
• L_v: if (x[i − 1]) goto L_h; else goto
L_l;
• L_v: if (x[i−1]) goto L_h; else {ret_b
= !ret_b; goto L_l;}.
There are two base cases for the recursion of function
Translate:
• v ∈ W (line 1), i.e., v has already been translated into
a C code block as above. In this case, the set of visited
COBDD nodes W is directly returned (line 1) without
generating any C code. This allows us to retain COBDD
node sharing;
• v = 1 (line 4), i.e., the terminal node 1 has been
reached. In this case, the C code block to be generated
is simply L_1: return ret_b;. Note that such a
block will be generated only once.
In all other cases, function Translate ends with the recur-
sive calls on the then and else edges (lines 14–15). Note
that the visited nodes set W passed to the second recursive
call is the result of the ﬁrst recursive call. Correctness of
function Translate is proved in Lemma 5.
D. An Example of Translation
Consider the COBDD ρ shown in Figure 2. Within ρ,
consider mgo K(x0, x1, x2, u0, u1) = J0x17, 1K. By
applying SolveFunctionalEq, we obtain f1(x0, x1, x2) =
J0x15, 1K and f2(x0, x1, x2) = J0x10, 1K. Note that 0xe
is shared between G(ρ0x15) and G(ρ0x10). Finally, by calling
GenerateCCode (see Algorithm 3) on f1, f2, we have the C
code in Figure 3.

219
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
i n t K_bits( i n t *x, i n t action) {
i n t ret_b;
switch(action) {
case 0: ret_b = 0; goto L_0x15;
case 1: ret_b = 0; goto L_0x10;
}
L_0x15:
i f (x[0] == 1) goto L_0x13;
e l s e { ret_b = !ret_b; goto L_0x14;}
L_0x13:
i f (x[1] == 1) goto L_0xe;
e l s e { ret_b = !ret_b; goto L_1; }
L_0xe:
i f (x[2] == 1) goto L_1;
e l s e { ret_b = !ret_b; goto L_1; }
L_0x14:
i f (x[1] == 1) goto L_0xe;
e l s e
goto L_1;
L_0x10:
i f (x[0] == 1) goto L_0xe;
e l s e { ret_b = !ret_b; goto L_0xf; }
L_0xf:
i f (x[1] == 1) goto L_0xe;
e l s e { ret_b = !ret_b; goto L_0xe; }
L_1:
return ret_b;
}
void K( i n t *x, i n t *u) {
i n t i;
for(i = 0; i < 2; i++)
u[i] = K_bits(x, i);
}
Figure 3.
C code for the mgo in Figure 2 as generated by Synthesize
VII. TRANSLATION PROOF OF CORRECTNESS
In this section, we prove the correctness of our approach
(Theorem 6). That is, we show that the function K we gener-
ate indeed implements the given controller K, thus resulting
in a correct-by-construction control software.
We begin by stating four useful lemmata for our proof.
Lemma 2 is useful to prove Lemma 3, i.e., to prove correct-
ness of function SolveFunctionalEq.
Lemma
2.
Let
K
:
Bn × Br
→
B
and
let
f1, . . . , fr
be
such
that
fi(x)
=
∃ui+1, . . . , ur
K(x, f1(x), . . . , fi−1(x), 1, ui+1, . . . , ur) for all i ∈ [r].
Then, x ∈ Dom(K) ⇒ K(x, f1(x), . . . , fr(x)) = 1.
Proof: Let x ∈ Bn be such that x ∈ Dom(K), i.e.,
∃u K(x, u) = 1. We prove the lemma by induction on r.
For r = 1, we have f1(x) = K(x, 1). If f1(x) = 1, we
have K(x, f1(x)) = K(x, 1) = f1(x) = 1. If f1(x) = 0,
we have K(x, f1(x)) = K(x, 0), and K(x, 0) = 1 since
x ∈ Dom(K) and K(x, 1) = 0.
Suppose
by
induction
that
for
all
˜K
:
Bn × Br−1
→
B
˜K(x, ˜f1(x), . . . , ˜fr−1(x))
=
1,
where
for
all
i
∈
[r
−
1]
˜fi(x)
=
∃ui+1, . . . , ur−1 ˜K(x, ˜f1(x), . . . , ˜fi−1(x), 1, ui+1, . . . , ur−1).
We
have
that
x
∈
Dom(K)
implies
that
either
x
∈
Dom(K|u1=0)
or
x
∈
Dom(K|u1=1).
Suppose
x
∈
Dom(K|u1=1)
holds.
We
have
that
K|u1=1(x, ˜f2(x), . . . , ˜fr(x))
=
1,
where
for
all
i
=
2, . . . , r
˜fi(x)
=
∃ui+1, . . . , ur K|u1=1(x, ˜f2(x), . . . , ˜fi−1(x), 1, ui+1, . . . , ur).
By
construction,
we
have
that
f1(x)
=
1
and
fi(x)
=
˜fi(x)
for
i
≥
2,
thus
1
=
K|u1=1(x, ˜f2(x), . . . , ˜fr(x))
=
K(x, f1(x), . . . , fr(x)).
Analogously, if x /∈ Dom(K|u1=1)∧x ∈ Dom(K|u1=0) we
have that f1(x) = 0 and fi(x) = ˜fi(x) for i ≥ 2, thus 1 =
K|u1=0(x, ˜f2(x), . . . , ˜fr(x)) = K(x, f1(x), . . . , fr(x)).
Lemma 3 states correctness of function SolveFunctionalEq
of Algorithm 2.
Lemma 3. Let ρ = (V, V , 1, var, low, high, ﬂip) be
a COBDD with V = X ·∪U, v ∈ V be a node, b ∈ B
be a ﬂipping bit. Let Jv, bK = K(x, u) and r = |U|.
Then function SolveFunctionalEq(ρ, v, b) (see Algorithm 2)
outputs nodes v1, . . . , vr and boolean values b1, . . . , br such
that for all i ∈ [r] Jvi, biK = fi(x) and x ∈ Dom(K)
implies K(x, f1(x), . . . , fr(x)) = 1.
Proof:
Correctness
of
functions
COBDD APP
and
COBDD EX
(and
lemma
hypotheses)
implies
that
for
all
i
∈
[r]
fi(x)
=
∃ui+1, . . . , ur
K(x, f1(x), . . . , fi−1(x), 1, ui+1, . . . , ur).
By Lemma 2 we have the thesis.
Let Translate dup be a function that works as function
Translate of Algorithm 4, but that does not take nodes shar-
ing into account. Function Translate dup may be obtained
from function Translate by deleting line 1 (highlighted in
Algorithm 4) and by replacing calls to Translate in lines 14
and 15 with recursive calls to Translate dup (with no changes
on parameters). Lemma 4 states correctness of function Trans-
late dup.
Lemma 4. Let ρ = (V, V , 1, var, low, high, ﬂip) be a
COBDD, v ∈ V be a node, b ∈ B be a ﬂipping bit, and W ⊆
V be a set of nodes. Then function Translate dup(ρ, v, W)
generates a sequence of labeled C statements B1 . . . Bk such
that k ≥ |Vv| and for all w ∈ Vv: 1) label L_w is in Bi for
some i and 2) starting an execution from label L_w with
∀i ∈ [n] x[i − 1]= xi and ret_b= ¯b, if Jw, bK = fw,b
then a return ret_b; statement is invoked in at most
O(p) steps with ret b = fw,b(x) and p = height(w).
Proof: We prove this lemma by induction on v. Let
v = 1, which implies Jv, bK = ¯b and Vv = {1}. We have that
function Translate dup(ρ, v, W) generates a single block
B1 (thus k = 1 = |V1|) such that B1 =L_1: return
ret_b; (lines 3–5 of Algorithm 4). Since by hypothesis
we have ret_b= ¯b, and since starting from B1 the return

220
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
statement is invoked in O(1) steps, the base case of the
induction is proved.
Let v be an internal node with var(v) = xi and let
f(x)
=
Jv, bK. Since w
∈
Vv if and only if w
=
v ∨ w ∈ Vhigh(v) ∨ w ∈ Vlow(v), by induction hypothesis
we only have to prove the thesis for w = v. We have
that f(x) = xiJhigh(v), bK + ¯xiJlow(v), b ⊕ ﬂip(v)K, i.e.,
f(x) = xiJhigh(v), bK + ¯xiJlow(v), bK if ﬂip(v) = 0 and
f(x) = xiJhigh(v), bK + ¯xiJlow(v),¯bK if ﬂip(v) = 1. Since
f(x) = xif|xi=1(x) + ¯xif|xi=0(x), by Theorem 1 we
have that Jhigh(v), bK = f|xi=1(x), and that Jlow(v), bK =
f|xi=0(x) if ﬂip(v) = 0 and Jlow(v),¯bK = f|xi=0(x) if
ﬂip(v) = 1.
By
lines
3
and
8–13
of
Algorithm
4,
we
have
that
function
Translate dup(ρ, v, W)
generates
blocks
BB11 . . . B1hB21 . . . B2l such that B =L_v: if (x[i −
1] == 1) goto L_high(v); else BE where BE is
either goto L_low(v); if ﬂip(v)
=
0 or {ret_b
= !ret_b; goto L_low(v);} if ﬂip(v)
=
1, and
B11 . . . B1h
(B21 . . . B2l) are generated by the recur-
sive call Translate dup(ρ, high(v), W) in line 14 (Trans-
late dup(ρ, low(v), W) in line 15). By induction hypothesis
and the above reasoning, if the execution starts at label
L_high(v) and ret_b= ¯b, then a return ret_b; state-
ment is invoked in at most O(p − 1) steps with ret b =
f|xi=1(x). As for the else case, we have that starting from
L_low(v) with ret_b= ¯b (ret_b= ¯¯b) if ﬂip(v) = 0
(ﬂip(v) = 1), then a return ret_b; statement is in-
voked in at most O(p−1) steps with ret b = f|xi=0(x). By
construction of block B, starting from label L_v, a return
ret_b; statement is invoked in at most O(p−1+1) = O(p)
steps with ret b = xif|xi=1(x) + ¯xif|xi=0(x) = f(x).
Finally, note that by induction hypothesis h ≥ |Vhigh(v)|
and l ≥ |Vlow(v)|, thus we have that k = 1 + h + l ≥
1 + |Vhigh(v)| + |Vlow(v)| ≥ |Vv|.
Lemma 5 extends Lemma 4 by also considering nodes
sharing, thus stating correctness of function GenerateCCode
of Algorithm 3 and function Translate of Algorithm 4.
Lemma 5. Let ρ = (V, V , 1, var, low, high, ﬂip)
be a COBDD and v1, . . . , vr
∈
V
be r nodes and
b1, . . . , br ∈ B be r ﬂipping bits. Then lines 6–8 of function
GenerateCCode(ρ, v1, b1, . . . , vr, br) generate a sequence of
labeled C statements B1 . . . Bk such that k = | ∪r
i=1 Vvi|
and for all v ∈ ∪r
i=1Vvi: 1) the label L_v is in Bj for
some j and 2) starting an execution from label L_v with
∀j ∈ [n] x[j − 1]= xj and ret_b= ¯b, if Jv, bK = fv,b
then a return ret_b; statement is invoked in at most
O(p) steps with ret b = fv,b(x) and p = height(w).
Proof: We begin by proving that k = | ∪r
i=1 Vvi|.
To this aim, we prove that for each node v ∈ ∪r
i=1Vvi,
a unique block Bv is generated. This follows by how the
nodes set W is managed by function Translate in lines 1–3
of Algorithm 4 and by function GenerateCCode in lines 6–
8 of Algorithm 3. In fact, function Translate, when called
on parameters ρ, v, W, returns a set W ′ ⊇ W, and function
GenerateCCode calls Translate by always passing the W
resulting by the previous call. Since a block is generated for
node v only if v is not in W, and v is added to W only
when a block is generated for node v, this proves this part
of the lemma.
As for correctness, we prove this lemma by induction on
m, being m the number of times that the return W;
statement in line 1 of Algorithm 4 is executed. As base of the
induction, let m = 1 and let ρ, v, W be the parameters of the
recursive call executing the ﬁrst return W; statement.
Then, by construction of function Translate, v has been
added to W in some previous recursive call with parameters
ρ, v, ˜W. In this previous recursive call, a block Bv with
label L_v has been generated. Moreover, for this previous
recursive call, thus for parameters ρ, v, ˜W, we are in the
hypothesis of Lemma 4, which implies that the induction
base is proved.
Suppose now that the thesis holds for the ﬁrst m exe-
cutions of the return W; statement in line 1 of Algo-
rithm 4. Then, by construction of function Translate, v has
been added to W in some previous recursive call with pa-
rameters ρ, v, ˜W. In this previous recursive call, a block Bv
with label L_v has been generated. Let w1, W1, . . . , wm, Wm,
be such that the m recursive calls executing the return
W; statement have parameters ρ, vi, Wi (note that they are
not necessarily distinct). By induction hypothesis, for all i ∈
[m] starting from label L_wi with ∀j ∈ [n] x[j − 1]= xj
and ret_b= ¯b, a return ret_b; statement is invoked
in at most O(p) steps with ret b = fwi,b(x). By Lemma 4
and its proof, the same holds for all v ∈ Vv \{w1, . . . , wm},
thus it holds for all v ∈ Vv.
Finally, Theorem 6 states and proves correctness for func-
tion Synthesize of Algorithm 1.
Theorem 6. Let ρ = (V, V , 1, var, low, high, ﬂip) be a
COBDD with V = X ·∪U, v ∈ V be a node, b ∈ B be a
boolean. Let Jv, bK = K(x, u), r = |U| and n = |X|. Then
function Synthesize(ρ, v, b) generates a C function void
K(int *x, int *u) with the following property: for all
x ∈ Dom(K), if before a call to K ∀i ∈ [n] x[i − 1]=
xi, and after the call to K ∀i ∈ [r] u[i − 1]= ui, then
K(x, u) = 1.
Furthermore, function K has WCET Pr
i=1 O(height(vi)),
being v1, . . . , vr the nodes output by function SolveFunc-
tionalEq.
Proof: Let x ∈ Dom(K) (i.e., ∃u K(x, u) = 1) and
suppose that for all j ∈ [n] x[j − 1]= xj. By lines 9–
11 of Algorithm 3, for all i ∈ [r], u[i − 1] will take
the value returned by K_bits(x, i). In turn, by lines 3
and 4 of Algorithm 3, each K_bits(x, i) sets ret_b

221
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
R
+vO
L
iD
Vi
Vi−1
Vj
V1
Iu
i
Iu
i−1
Iu
j
+vu
i
ui
D0
D1
Dj
Di−1
iL
rL
+vC
C
rC
iC
+vu
j
ui−1
uj
+vD
...
...
Iu
1
+vD
1
+vD
j
+vu
i−1
+vD
i−1
+vu
1
u1
Figure 4.
Multi-input Buck DC-DC converter.
to ¯bi and makes a jump to label L_vi. By Lemma 3 and by
construction of Synthesize, such b1, . . . , br and v1, . . . , vr
are such that that Jv1, b1K = f1(x), . . . , Jvr, brK = fr(x)
and K(x, f1(x), . . . , fr(x)) = 1. By Lemma 5, the se-
quence of calls K_bits(x, 1), . . . , K_bits(x, r)
will indeed return, in at most Pr
j=1 O(height(vi)) steps,
f1(x), . . . , fr(x).
Corollary 7. Let ρ = (V, V , 1, var, low, high, ﬂip) be a
COBDD with V = X ·∪U, v ∈ V be a node, b ∈ B be a
boolean. Let Jv, bK = K(x, u), r = |U| and n = |X|. Then
the C function K output by function Synthesize(ρ, v, b) has
WCET O(rn).
Proof: The corollary immediately follows from Theo-
rem 6 and from the fact that, for all v ∈ V , height(v) ≤ n.
VIII. EXPERIMENTAL RESULTS
We implemented our synthesis algorithm in C program-
ming language, using the CUDD (Colorado University De-
cision Diagram [19]) package for OBDD based computa-
tions and BLIF (Berkeley Logic Interchange Format [20])
ﬁles to represent input OBDDs. We name the resulting tool
KSS (Kontrol Software Synthesizer). KSS is part of a more
general tool named QKS (Quantized feedback Kontrol Syn-
thesizer [6]).
A. Experimental Settings
We present experimental results obtained by using KSS
on given COBDDs ρ1, . . . , ρ5 such that for all i ∈ [5] ρi
represents the mgo Ki(x, u) for a buck DC/DC converter
with i inputs.
The multi-input buck DC-DC converter [21] in Figure 4 is
a mixed-mode analog circuit converting the DC input voltage
(Vi in Figure 4) to a desired DC output voltage (vO in
Figure 4). As an example, buck DC-DC converters are used
off-chip to scale down the typical laptop battery voltage (12-
24) to the just few volts needed by the laptop processor (e.g.,
see [22]) as well as on-chip to support Dynamic Voltage
and Frequency Scaling (DVFS) in multicore processors (e.g.,
see [23]). Because of its widespread use, control schemas
Table I
KSS PERFORMACES
r
CPU
MEM
|K|
|F unsh|
|Sw|
%
1
3.0e-02
1.0e+08
12137
2646
2646
0.0e+00
2
1.1e-01
1.3e+08
25848
5827
5076
1.3e+01
3
1.7e-01
1.8e+08
36430
10346
8606
1.7e+01
4
2.5e-01
2.4e+08
46551
15004
12285
1.8e+01
5
3.6e-01
3.3e+08
65835
21031
16768
2.0e+01
for buck DC-DC converters have been widely studied. The
typical software based approach (e.g., see [22]) is to control
the switches u1, . . . , ui in Figure 4 (typically implemented
with a MOSFET, i.e., a metal-oxide-semiconductor ﬁeld-
effect transistor [24]) with a microcontroller.
In the following experiments, we ﬁx n = |x| = 20 and
we have that ri = |u| = i. Finally, Ki is an intermediate
output of the QKS tool described in [6].
For each ρi, we run KSS so as to compute Synthesize(ρi,
vi, bi) (see Algorithm 1), being Jvi, biK = Ki(x, u). In the
following, we will call ⟨v1i, b1i, . . . , vii, bii⟩, with vji ∈
Vi, bji ∈ B, the output of function SolveFunctionalEq(ρi, vi,
bi). Moreover, we call f1i, . . . , fii : Bn → B the i boolean
functions such that Jvji, bjiK = fji(x). All our experiments
have been carried out on a 3.0 GHz Intel hyperthreaded
Quad Core Linux PC with 8 GB of RAM.
B. KSS Performance
In this section, we will show the performance (in terms
of computation time, memory, and output size) of the al-
gorithms discussed in Section VI. Table I show our experi-
mental results. The i-th row in Table I corresponds to exper-
iments running KSS so as to compute Synthesize(ρi, vi, bi).
Columns in Table I have the following meaning. Column r
shows the number of action variables |u| (note that |x| = 20
on all our experiments). Column CPU shows the computa-
tion time of KSS (in secs). Column MEM shows the memory
usage for KSS (in bytes). Column |K| shows the number
of nodes of the COBDD representation for Ki(x, u), i.e.,
|Vvi|. Column |F unsh| shows the number of nodes of the
COBDD representations of f1i, . . . , fii, without consider-
ing nodes sharing among such COBDDs. Note that we do
consider nodes sharing inside each fji separately. That is,
|F unsh| = Pi
j=1 |Vvji| is the size of a trivial implemen-
tation of f1i, . . . , fii in which each fji is implemented by
a stand-alone C function. Column |Sw| shows the size of
the control software generated by KSS, i.e., the number of
nodes of the COBDD representations f1i, . . . , fii, consid-
ering also nodes sharing among such COBDDs. That is,
|Sw| = |∪i
j=1Vvji| is the number of C code blocks generated
by lines 6–8 of function GenerateCCode in Algorithm 3.
Finally, Column % shows the gain percentage we obtain by
considering nodes sharing among COBDD representations

222
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
for f1i, . . . , fii, i.e., (1 −
|Sw|
|F unsh|)100.
From Table I we can see that, in less than 1 second
and within 350 MB of RAM we are able to synthesize the
control software for the multi-input buck with r = 5 action
variables, starting from a COBDD representation of K with
about 6.6 × 104 nodes. The control software we synthesize
in such a case has about 1.7 × 104 lines of code, whilst
a control software not taking into account COBDD nodes
sharing would have had about 2.1×104 lines of code. Thus,
we obtain a 20% gain towards a trivial implementation.
IX. CONCLUSION AND FUTURE WORK
In this paper, we presented an algorithm which, starting
from a boolean relation K representing the set of implemen-
tations meeting the given system speciﬁcations, generates a
correct-by-construction C code implementing K. This en-
tails ﬁnding boolean functions F such that K(x, F(x)) = 1
holds, and then implement such F. WCET for the generated
control software is linear linear in nr, being r the number
of functions in F and n = |x|. Furthermore, we formally
proved that our algorithm is correct.
We implemented our algorithm in a tool named KSS.
Given our algorithm properties explained above, by using
KSS it is possible to synthesize correct-by-construction
control software, provided that K is provably correct with
respect to initial formal speciﬁcations. This is the case in [6],
thus this methodology, e.g., allows to synthesize correct-
by-construction control software starting from formal spec-
iﬁcations for DTLHSs. We have shown feasibility of our
proposed approach by presenting experimental results on
using it to synthesize C controllers for a multi-input buck
DC-DC converter.
The WCET of the resulting control software may be too
high for some systems in which nr is high, or for which
the control software has to provide actions with an high
frequency. In order to speed-up the WCET, a natural possible
future research direction is to investigate how to parallelize
the generated control software.
ACKNOWLEDGMENTS
This work has received funding both from MIUR project
TRAMP and the FP7/2007-2013 project ULISSE (grant agree-
ment no218815).
REFERENCES
[1] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “From boolean
relations to control software,” in ICSEA 2011, pp. 528–533.
[2] R. Bryant, “Graph-based algorithms for boolean function
manipulation,” IEEE Trans. on Computers, vol. C-35, no. 8,
1986, pp. 677–691.
[3] D. Baneres, J. Cortadella, and M. Kishinevsky, “A recursive
paradigm to solve boolean relations,” IEEE Trans. on Com-
puters, vol. 58, no. 4, 2009, pp. 512–527.
[4] R. Wille and R. Drechsler, “Bdd-based synthesis of reversible
logic for large functions,” in DAC 2009, pp. 270–275.
[5] E. Tronci, “Automatic synthesis of controllers from formal
speciﬁcations,” in ICFEM 1998, pp. 134–143.
[6] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “Synthesis of
quantized feedback control software for discrete time linear
hybrid systems,” in CAV 2010, ser. LNCS 6174, pp. 180–195.
[7] E. M. Clarke, O. Grumberg, and D. A. Peled, Model Check-
ing.
The MIT Press, 1999.
[8] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “Quantized
feedback control software synthesis from system level for-
mal speciﬁcations for buck dc/dc converters,” CoRR, vol.
abs/1105.5640, 2011.
[9] M. Chiodo, P. Giusto, H. Hsieh, A. Jurecska, L. Lavagno,
A. Sangiovanni-Vincentelli, E. Sentovich, and K. Suzuki,
“Synthesis of software programs for embedded control ap-
plications,” IEEE Trans. CAD, vol. 18, 1995, pp. 834–849.
[10] T. Wongpiromsarn, U. Topcu, and R. M. Murray, “Formal
synthesis of embedded control software: Application to ve-
hicle management systems,” in AIAA Infotech@Aerospace,
2011.
[11] A. Cimatti, M. Roveri, and P. Traverso, “Strong planning
in non-deterministic domains via model checking,” in AIPS
1998, pp. 36–43.
[12] V. Alimguzhin, F. Mari, I. Melatti, I. Salvo, and E. Tronci,
“On model based synthesis of embedded control software,”
in EMSOFT 2012, pp. 227–236.
[13] A. Pnueli and R. Rosner, “On the synthesis of an asyn-
chronous reactive module,” in ICALP 1989, pp. 652–671.
[14] A. Girault and ´E. Rutten, “Automating the addition of fault
tolerance with discrete controller synthesis,” Formal Methods
in System Design, vol. 35, no. 2, 2009, pp. 190–225.
[15] ——, “From boolean functional equations to control soft-
ware,” CoRR, vol. abs/1106.0468, 2011.
[16] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein,
Introduction to Algorithms (3. ed.).
MIT Press, 2009.
[17] K. S. Brace, R. L. Rudell, and R. E. Bryant, “Efﬁcient
implementation of a bdd package,” in DAC 1990, pp. 40–45.
[18] S. Minato, N. Ishiura, and S. Yajima, “Shared binary decision
diagram with attributed edges for efﬁcient boolean function
manipulation,” in DAC 1990, pp. 52–57.
[19] “CUDD Web Page,” http://vlsi.colorado.edu/ fabio/CUDD,
last accessed 20th dec 2012
[20] “Berkeley
logic
interchange
format
(BLIF),“
bear.ces.cwru.edu/eecs cad/sis blif.pdf, last accessed 20th
dec 2012.

223
International Journal on Advances in Software, vol 5 no 3 & 4, year 2012, http://www.iariajournals.org/software/
2012, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[21] M. Rodriguez, P. Fernandez-Miaja, A. Rodriguez, and J. Se-
bastian, “A multiple-input digitally controlled buck converter
for envelope tracking applications in radiofrequency power
ampliﬁers,” IEEE Trans. on Power Electronics, vol. 25, no. 2,
2010, pp. 369–381.
[22] W.-C. So, C. Tse, and Y.-S. Lee, “Development of a fuzzy
logic controller for dc/dc converters: design, computer simu-
lation, and experimental evaluation,” IEEE Trans. on Power
Electronics, vol. 11, no. 1, 1996, pp. 24–32.
[23] W. Kim, M. S. Gupta, G.-Y. Wei, and D. M. Brooks, “En-
abling on-chip switching regulators for multi-core processors
using current staggering,” in ASGI 2007.
[24] Y. Cheng and C. Hu, MOSFET Modeling and Bsim3 User’s
Guide. Kluwer Academic Publishers, 1999.

