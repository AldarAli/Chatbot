A Method to Optimize Technical Debt Management in Timed-boxed Processes
Luigi Lavazza, Sandro Morasca and Davide Tosi
Dipartimento di Scienze Teoriche e Applicate
Universit`a degli Studi dell’Insubria
21100 Varese, Italy
Email: luigi.lavazza@uninsubria.it
sandro.morasca@uninsubria.it
davide.tosi@uninsubria.it
Abstract—Technical debt is currently receiving great attention
from researchers, because it is believed to affect software de-
velopment to a great extent. However, it is not yet clear how
technical debt should be managed. This is speciﬁcally true
in time-boxed development processes (e.g., in agile processes
organized into development sprints of ﬁxed duration), where it
is possible to remove technical debt as soon as it is discovered,
or wait until the debt reaches a given threshold, or wait until
a whole sprint can be dedicated to technical debt removal, etc.
We aim at investigating the consequences of different technical
debt management options, especially as far as debt removal
and program enhancements are concerned. We are interested
in the consequences on both the amount of functionality and
the quality of the delivered software. We propose a System
Dynamics model that supports the simulation of various scenarios
in time-boxed software development and maintenance processes.
The proposed model is conceived to highlight the consequences
of management decisions. Since this is our focus, our model
abstracts from a few confounding factors that may be present
in software projects, which would basically introduce some noise
and blur the effect we want to study. Nonetheless, the model can
be easily extended and adapted to represent these other factors
adequately. The proposed model shows how productivity and
product quality depend on the way technical debt is managed.
Our model yields quantitative indications that can support the
estimation of the economic consequences of different management
strategies. Our study shows that different strategies for managing
technical debt in a time-boxed development and maintenance
process may yield different results—in terms of both productivity
and delivered software quality—depending on a few conditions.
Software project managers can use customized System Dynamics
models to optimize the development and maintenance processes,
by making the proper decisions on when to carry out maintenance
dedicated to decreasing the technical debt, and how much effort
should be devoted to such activities.
Keywords–Technical debt; System Dynamics; Technical debt
management.
I.
INTRODUCTION
Both practitioners and researchers are dedicating a growing
amount of attention to Technical Debt (TD). In general, TD
is connected with a lack of quality in the code. The idea is
that, if maintaining a piece of software of “ideal” quality has a
given cost, maintaining a piece of software of “less than ideal”
quality implies an extra cost.
It is also common knowledge that if no action is performed
to improve code quality, a sequence of maintenance interven-
tions will decrease quality, that is, TD increases and the cost of
maintenance increases as well. Not managing TD at all could
lead to code that is not maintainable.
These considerations pose the problem of managing TD:
project managers need to identify the best TD management
strategies and methods, and evaluate their effectiveness before
putting them in practice.
For this purpose, we propose a System Dynamics model
that represents the development of software via a sequence
of time-boxed development phases (e.g., Scrum sprints). Like
any System Dynamics model, the proposed model can be sim-
ulated, thus providing quantitative indications concerning the
effectiveness of development in terms of amount and quality
of code delivered. The proposed model is used in this paper to
illustrate a few development scenarios and the consequences
of TD and the adopted TD management practices.
The paper is organized as follows. In Section II, we
provide background concerning Technical Debt and System
Dynamics. In Section III, we introduce our model of software
development and maintenance, characterized by time-boxed
incremental phases. In Section IV, the model is used to
simulate the behavior of the process when different strategies
for allocating effort to repay the technical debt are used. In
Section V, we discuss the outcomes of simulations, especially
as far as productivity and delivered quality are concerned.
Section VI accounts for related work. Finally, in Section VII
we draw some conclusions and outline future work.
II.
BACKGROUND
In the last few years, TD has received great attention from
researchers. For example, a recent Systematic Mapping Study
on TD and TD management (TDM) covering publications
from 1992 and 2013 detected 94 primary studies to obtain
a comprehensive understanding on the TD concepts and an
overview on the current state of research on TDM [1].
An updated Systematic Mapping Study identiﬁed elements
that are considered by researchers to have an impact on TD
in the industrial environment [2]. The authors classiﬁed these
twelve elements in three main categories: (1) Basic deci-
sion making factors, (2) Cost estimation techniques, and (3)
Practices and techniques for decision-making. They mapped
these elements to the stakeholders’ point of view, speciﬁcally,
for business organizational management, engineering manage-
ment, and software engineering areas.
Several authors proposed deﬁnitions for TD and its inter-
ests. Nugroho et al. [3] deﬁne TD as “the cost of repairing
45
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

quality issues in software systems to achieve an ideal quality
level” and the interests of the debt as “the extra maintenance
cost spent for not achieving the ideal quality level.” Other
works try to empirically correlate TD with software size,
software quality, customer satisfaction, and other software
properties, in the context of enterprise software systems [4].
In a recent Dagstuhl Seminar [5], the following deﬁnition
of TD was proposed: “In software-intensive systems, technical
debt is a collection of design or implementation constructs
that are expedient in the short term, but set up a technical
context that can make future changes more costly or impossi-
ble. Technical debt presents an actual or contingent liability
whose impact is limited to internal system qualities, primarily
maintainability and evolvability.”
The Software Quality Assessment based on Lifecycle Ex-
pectations (SQALE) method [6] addresses a set of external
qualities (like Reliability, Efﬁciency, Maintainability, etc.).
Each of these qualities is associated with a set of requirements
concerning internal qualities, each provided with a “remedia-
tion function,” which represents the cost of changing the code
so that the requirement is satisﬁed. Based on these functions,
the cost of TD is computed for each external quality and for
all qualities.
The Object Management Group has published a beta ver-
sion of the speciﬁcation of a measure of TD principal, deﬁned
as “The cost of remediating must-ﬁx problems in production
code” [7]. The measure can be computed automatically as a
weighted sum of the “violations of good architectural and
coding practices,” detected according to the occurrence of
speciﬁc code patterns. The weight is computed according to the
expected remediation effort required for each violation type.
System Dynamics was developed by Jay Forrester [8] as
a modeling methodology that uses feedback control systems
principles to represent the dynamic behavior of systems. The
elements of System Dynamics models are levels, constants,
auxiliary variables and rates. The dynamics of systems is
determined by how levels work: given a level L, its value
in time is always determined by an equation L(t + ∆t) =
L(t) + (in(t) − out(t))∆t, where in(t) and out(t) are rates.
Levels and rates can concern anything (e.g., people, rabbits,
bricks, lines of code, etc.), depending on the application scope
and goal of the model. The value of a rate at time t is deﬁned
based on the values of auxiliary variables, other rates and
levels at time t. Likewise for auxiliary variables, which are
not necessary, but are useful to write readable models.
The elements of a System Dynamics model are intercon-
nected just like in the real world, to form a network, where
causes and effects are properly represented. Models can be
executed, so that the behavior of the modeled system can be
simulated. Via System Dynamics models it is quite easy to
perform what-if analyses: you obtain different behaviors by
changing the initial state of the system (given by the values of
levels), how rates and variable are computed, how they depend
on each other, etc.
III.
THE PROPOSED MODEL
As already mentioned, the proposed model describes in an
operational way the time-boxed development process, espe-
cially in terms of maintenance activities concerning the reduc-
tion of Technical Debt. The proposed model aims at evaluating
the productivity of development and maintenance activities,
and the quality of the released product. Here productivity is
deﬁned as the ratio of the amount of product—measured in
Function Points (FP) [9][10]—developed in a time period to
the amount of effort/resources used.
To focus on the main objectives, we abstract from all those
aspects of the model that deal with activities and software
products that are not directly connected with TD management.
For instance, in a real process, the productivity of individuals
tends to increase because of learning effects, the number of
developers allocated may change during a project, etc.: we
exclude all of these variables because they would introduce
noise in our investigation, which focuses on the effects of TD
management decisions.
A. Assumptions
The main reason why practitioners and researchers are
interested in TD is that maintaining code burdened with a big
TD (i.e., low-quality code) costs much more than maintaining
code with little TD (i.e., high-quality code). This is because
more work is needed to carry out any code-related activity
when code is of low quality (e.g., difﬁcult to understand, poorly
structured, full of hidden dependencies, etc.).
To account for the relation that links TD to maintenance
cost, we need a measure of TD. To this end, we measure
TD via a “TD index,” an indicator that takes into account the
internal qualities of code that concur to determine the amount
of TD embedded in the code. Here, we are not interested in
deﬁning precisely the TD index, based on the measures of
individual internal qualities, because this is not relevant for
our purposes. Clearly, accurately modeling individual internal
qualities of code would make the model more apt at reproduc-
ing the behavior of real development environments. But this
is not our purpose: we aim at building a model that shows—
at a fairly high level—the effects of decisions concerning TD
management in a generic realistic development environment.
We assume that the TD index ranges between 0 (highest
quality) and 1 (worst quality). The extreme values represent
limiting cases, which may not occur in practice. When the TD
index is 1, maintenance is so difﬁcult that one is better off by
simply throwing away the code and building a new version
from scratch, and productivity is null, i.e., prod = 0. When
the TD index is 0, maintenance activities attain their optimal
productivity prodopt. When 1>TD index>0, prod steadily
increases from 0 to prodopt when the TD index decreases.
Figure 1. Effect of technical debt on productivity.
46
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

The value of productivity for a given value of the TD
index prod(TDindex) can be expressed as prodMult(TDindex)
×prodopt. Figure 1 shows a possible behavior of prod-
Mult(TDindex). We use the function illustrated in Figure 1 to
build models to exemplify our proposal. Other monotonically
decreasing functions that go through points (0, 1) and (1, 0)
could be used as well, but that would not change the way we
build models in our proposal.
Here, we assume that development is carried out in a
time-boxed way. This is coherent with the organization of
development in most agile processes. We assume that the
development is composed of a sequence of “sprints,” each of
which has a ﬁxed duration and involves a constant number
of developers, hence a sprint “consumes” a ﬁxed number of
Person Days (PD). For instance, if sprints last 20 work days
and involve 5 developers, then each sprint “costs” 100 PD. If
at the end of 5 sprints 416 FP are released, we have achieved a
productivity of 416/(5·100)=0.832 FP/PD; if at the end of these
sprints 378 FP are released, we have achieved a productivity
of 378/500=0.756 FP/PD. Quite clearly, in the former case the
management of technical debt was more effective, a higher
productivity was achieved, more functionality was released,
and bigger returns can be expected.
A consequence of our assumptions is that the amount of
effort spent is strictly proportional to development duration,
which can be expressed in number of sprints. Given this
proportionality between effort and the number of sprints, we
can express productivity as the amount of code released after
N sprints. Thus, we measure the productivity values above as
416/5=83.2 FP/Sprint (instead of 416/500=0.832 FP/PD) and
378/5=75.6 FP/Sprint (instead of 378/500=0.756 FP/PD).
During each sprint, the developers can carry out two types
of activities: 1) increase the functionality of the system, by
adding new code, and 2) decrease TD, by refactoring code
structure, removing defects and improving the qualities that
make development and maintenance easier. Since in each
sprint the amount of work is ﬁxed, managers have to decide
what fraction of work has to be dedicated to new code
development—the remaining fraction being dedicated to TD
management. Several different criteria can be used in setting
such fraction, as illustrated in Section IV.
We assume that during each sprint a constant fraction of the
new code affected by quality problems (hence, increasing the
technical debt) is released. This fraction depends on several
factors, like the experience and ability of developers, the
availability of sophisticated tools, problem complexity, etc.
We assume that these factors are constant throughout all the
sprints: in this way, we do not generate noise and we can
highlight the effects of TDM decisions.
B. The Model
The proposed System Dynamics model involves two level
variables: CodeSize (measured in FP) and TDIndex.
The constants in the model are:
nominal_maintenance_productivity, the productivity in
FP/Sprint in ideal conditions, i.e., when the TD index is zero.
We assume that the nominal productivity is 80 FP/Sprint, cor-
responding to 0.1 FP/PersonHour, a fairly typical value [11].
nominal_TDimprovement_productivity, the amount of
code that can be optimized—i.e., whose TD is completely
repaid—in a sprint, when the effort is completely devoted to
TD improvement. We assume that this value is 40 FP/Sprint.
In real developments, this amount is not necessarily constant:
a sprint could be sufﬁcient to “clean” 40 FP or relatively good
code, but not to “clean” 40 FP of very bad quality code.
bad_fraction_of_new_code, the fraction of the new code
(released at the end of each sprint) that contributes to increas-
ing TD. We here assume that the value of this constant is 0.2.
available_effort: the effort available at each sprint. As
already mentioned, we assume it to be a constant. The actual
value is not relevant, however, we can take 100 PD as a
reference value.
The rate and auxiliary variables of the model are:
fraction_of_effort_for_quality_maintenance:
the
fraction
of
available_effort
dedicated
to
repaying
TD.
This
variable
is
computed
via
function
fracEffortForQuality, which has the TD index as an
argument.
quality_maintenance_effort: the effort available for
improving the quality of code in a sprint.
maintenance_effort: the effort available for developing
new code in a sprint.
maintenance_productivity:
the
productivity
of
developing
new
code
in
a
sprint.
It
depends
on
the
nominal_maintenance_productivity,
the
maintenance_effort
and
the
decrease
of
productivity
due
to
the
TD
(computed
via
function
productivity_considering_TD).
TD_dec_rate: the TD decrease rate.
TD_inc_rate: the TD increase rate.
The values of the aforementioned variables are determined
by the following equations:
available_effort=1
fraction_of_effort_for_quality_maintenance=
fracEffortForQuality(TDindex)
quality_maintenance_effort=available_effort*
fraction_of_effort_for_quality_maintenance
maintenance_effort=
available_effort-quality_maintenance_effort
maintenance_productivity=
nominal_maintenance_productivity*
maintenance_productivity_considering_TD(TDindex)
TDimprovement_productivity=
nominal_TDimprovement_productivity*
quality_maintenance_effort
TD_inc_rate=bad_fraction_of_new_code*
maintenance_productivity/CodeSize
TD_dec_rate=TDimprovement_productivity/CodeSize
where the following functions are used:
maintenance_productivity_considering_TD(TDindex):
the loss of productivity due to TD, as described in Figure 1.
fracEffortForQuality(TDindex): this function describes
the strategy used for tackling TD. In Section IV, we use a few
different strategies, hence, a few different function deﬁnitions.
The levels are computed as follows (where all auxiliary
and rate variables are computed at time t):
CodeSize(t+∆t)=CodeSize(t)+
∆t*maintenance_productivity
TDindex(t+∆t)=TDindex(t)+
∆t*(TD_inc_rate-TD_dec_rate))
47
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

IV.
SIMULATING THE MODEL
We simulate the model with a few different TD man-
agement strategies. The considered case is characterized as
follows. Initially, the software system to be maintained has
size 80 FP and its TD index is 0.2 (representing the quality
gap between the “ideal” quality and the actual initial quality
accepted to speed up development and release the product
early). The nominal productivity (i.e., new code development
productivity in ideal conditions, when no extra effort is due
because of TD) is 80 FP/Sprint. The nominal TD repayment
productivity (i.e., the amount of functionality for which the
TD is completely repaid in a sprint) is 40 FP/Sprint. At the
end of every sprint, 20% of the added code is “bad” code.
Our software organization goes through a sequence of 30
maintenance sprints. We assume that there are always enough
new requirements to implement to use up the development
capacity of sprints. This is a situation that occurs quite often
in practice. We also assume that the same amount of effort
is allocated to all sprints. In actual developments, this does
not always happen. Anyway, simulations that do not depend
on variations in the available effort provide better indications
of the effects of TD management strategies, since they do not
depend on accidental phenomena, like the amount of available
workforce.
A. Constant Effort for TD Management
In the ﬁrst simulation, we assume that the considered
software development organization allocates a constant fraction
of the effort available in each sprint, to tackle the technical
debt. It is reasonable to expect that the achieved results depend
on how big the fraction of effort dedicated to TD management
is. Hence, we run the simulation a few times, with different
fractions of the available effort dedicated to TD management,
ranging from zero (i.e., nothing is done to decrease the TD)
to 40%. The main results of the simulation are given in
Figure 2, which shows, from left to right: the functional size
of the software product version released after each sprint;
the functional size increment due to each sprint (i.e., the
enhancement productivity of each sprint); the evolution of the
TD through sprints (i.e., the quality of the software product
versions released after each sprint).
We can examine the achieved results starting with the solid
black lines, which represent the case in which no effort at all is
dedicated to repaying the TD. It is easy to see that the results
obtained by this TD management strategy (a no-management
strategy, actually) are quite bad. In fact, after 30 sprints we get
only 1248 FP: about 500 FP less than the most efﬁcient TD
management strategy. Not only: the ﬁnal product has TD index
= 0.84, that is, a very low quality, probably hardly acceptable
in practice. The effects of TD on maintenance productivity are
apparent: the continuously growing TD makes maintenance
less efﬁcient over sprints and, at the end, more than 60% of
the initial productivity is lost, due to TD. So, just ignoring
the TD is not a good practice. Deﬁnitely, we have to allocate
some effort to decrease the TD, but how much effort should
we dedicate to repaying TD?
By looking at Figure 2, it is easy to see that dedicating 10%
of the available effort to repaying TD improves the situation
with respect to not managing the TD at all: the ﬁnal size (1580
FP) is bigger, and the ﬁnal TD index (0.64) is better, though
not really good. When we dedicate 20% of the available effort
to repaying TD the results improve further: the ﬁnal size (1743
FP) is bigger, and the ﬁnal TD index (0.41) is better, though
still not very good.
In summary, by increasing the fraction of effort dedicated
to repaying TD from 0 to 20% we improve both the amount of
functionality that we are able to release, and the quality of the
software product. Hence, it would be natural to hypothesize
that, by further increasing the fraction of effort dedicated to
repaying TD, we obtain improvements in both the amount and
quality of delivered software. Actually, this is not the case:
when 30% of the available effort is dedicated to repaying
TD, we obtain a fairly good product (the ﬁnal TD index is
0.13, better than it was initially) but the amount of released
functionality is slightly less (1723 FP). When an even bigger
fraction (40%) of effort is dedicated to repying TD, we achieve
practically ideal quality (the ﬁnal TD index is 0.007), but
substantially less functionality (the ﬁnal size being 1517 FP).
The explanation of these results is that it is clear that
increasing the fraction of effort dedicated to TD improvement
improves maintenance productivity by decreasing TD, but at
the same time subtracts effort from enhancement maintenance
activities. Hence, one should look for a trade-off, to achieve
both a reasonably high productivity level and an acceptable
quality level (i.e., a sufﬁciently small TD).
Via a series of simulations, it is possible to ﬁnd the
fraction of effort dedicated to repaying TD that maximizes the
released functionality, hence maintenance productivity. In the
considered case, allocating 24% of the available effort to TD
improvement eventually results in yielding 1758 FP. However,
the ﬁnal TD index is 0.31: not a small debt, and a bigger debt
than initially. So, one could easily prefer to go for a bit less
functionality but a much better code.
Finally, it should be noticed that in the short term—i.e., in
the ﬁrst 10 sprints or less—not managing TD does not seem
to cause relevant negative consequences. For instance, in the
considered case, if the goal is to achieve a 500 FP software
product, not managing the TD may be a viable choice: you
get the product faster than by managing TD. Of course, one
should be sure that no further maintenance will be needed,
otherwise maintenance cost would be quite high, that is, one
has just postponed paying the debt.
B. Variable Effort for TD Management
In the previous section, the fraction of effort dedicated to
quality improvement was ﬁxed, i.e., it was constant over the
sprints. This is not a good managerial choice, for at least the
following two reasons. First, the initial TD could be greater
than in the case described in Section IV-A. Hence, it would
be a good practice to devote a substantial amount of effort
to improve quality at the beginning of development, with
the objective of decreasing the TD, and then proceed with
easier and more productive maintenance. This corresponds to
repaying (all or a substantial part of) the TD in the ﬁrst sprints:
the following sprints will have to pay low or null interests.
Second, the effort dedicated to TD management could be
excessive. Consider the evolution of the TD index through
sprints illustrated in Figure 2: when the fraction of effort
dedicated to quality improvement is 40%, the TD is practically
nil after 10 sprints. In the following sprints, the fraction of
effort for TD management is partly used to balance the increase
48
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

Figure 2. Size of delivered code, Sprint productivity and TD index, depending on a constant fraction of effort allocated to improving the TD.
of debt caused by new code, and part is wasted. This effect is
easy to see when you compare the effects of dedicating 30%
and 40% of the available effort to TD management. After a
few sprints, in both cases the TD index is practically constant
(about 0.18 in the former case, about 0.01 in the latter case).
Maintenance productivity is also constant in the two cases,
but higher in the former case. How is it possible that when
30% of effort is dedicated to TD management, we are using
some effort to manage a higher TD, and still we get a higher
productivity? Because the effort needed to keep TD close to
zero is much less than the allocated 40%: the exceeding part
is wasted.
A better strategy for TD management would be to allocate
to TD improvement a fraction of effort that is larger when the
TD is large and smaller when the TD is little. Of course, there
are various ways to decide the fraction of effort to be dedicated
to decrease TD. We adopt the function shown in Figure 3,
which deﬁnes the fraction of effort for TD improvement as
1 − (1 − TDindex)k. By changing the value of k we decide
how aggressive the approach to debt repayment is: with k =
1 the fraction of the effort dedicated to debt repayment is
proportional to the debt, with k > 1 as soon as TD index raises
above zero, a substantial fraction of the effort (the greater k
the bigger the fraction) is dedicated to decrease TD.
In this section, the fraction of effort dedicated to TD
management is decided at every sprint, as 1−(1−TDindex)3:
a moderately aggressive policy. When debt increases, we try
to decrease it fairly soon, to avoid paying large interests.
Figure 4 shows the results of the simulation. The adopted
policy provides good results: at the end of the sprints we get
1764 FP, more than in any of the simulations performed in
Section IV-A. The ﬁnal TD index is 0.11: a good result.
It is interesting to note that after a few sprints, the TD index
remains constant, and, as a consequence, productivity remains
constant as well. The reason is that, at the beginning of each
sprint, the effort dedicated to TD management is adequate for
repaying the existing TD, but, during the sprint, new TD will
be created. This situation is perpetuated over the sprints. To
completely repay TD, a policy should allocate enough effort
to both repay the existing TD, and to anticipate the new TD,
by performing maintenance in a way that preserves optimal
code structure and quality.
In conclusion, dedicating a large fraction of effort to
decrease the TD in the ﬁrst sprints guarantees optimal results,
in terms of both the amount of functionality delivered and the
delivered quality.
Figure 3. Percentage of effort dedicated to TD improvement, as a function
1-(1-TDindex)k of TD.
C. Managing TD over a Threshold
In time-boxed development, it is often the case that a
sprint is either completely dedicated to enhancement or to
decreasing TD (especially via refactoring). So, the policy for
allocating effort to TD management is simple: if the TD index
is sufﬁciently high, the next sprint will be completely dedicated
to TD repayment; otherwise, the next sprint will be dedicated
completely to maintenance. In our case, if a sprint is dedicated
completely to TD management, developers will be able to
optimize a portion of code 40 FP large. Hence, we can allocate
a sprint to TD management when a portion of code of at least
40 FP is affected by TD.
We simulated development with this criterion for allocating
effort to TD management and we obtained the results illus-
trated in Figure 5. It is easy to see that the ﬁrst sprints are
49
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

Figure 4. Size of delivered code, Sprint productivity and TD index through sprints, when the fraction of effort for TD improvement is 1-(1-TDindex)3.
Figure 5. Size of delivered code, Sprint productivity and TD index through sprints, when sprints are dedicated to either TD management or maintenance.
dedicated to TD improvement and enhancement maintenance
alternatively. Then, when TD has improved enough, we have
a TD improvement sprint every two enhancement sprints.
TD progressively decreases until it becomes practically nil
(oscillating between 0.01 and 0.03). At the end of sprints,
1674 FP are released, that is, a bit less than with the policy
described in Section IV-B. However, the achieved TD index is
much better, compared to the 0.11 achieved in Section IV-B.
V.
DISCUSSION
The results obtained with the different criteria for allocating
effort to TD improvement are summarized in Table I. Note
that in Table I, we have added the results—not given in
Section IV-B—obtained when the fraction of effort dedicated
to TD improvement is 1-(1-TDindex)1/3. In such case, the
fraction of effort dedicated to TD improvement decided at the
beginning of each sprint, is based on the current TD index, but
the approach is not aggressive, on the contrary, a substantial
fraction of effort is dedicated to TD improvement only when
the TD index is relatively large.
The results given in Table I, along with the more detailed
results reported in Section IV, suggest a few observations.
TABLE I. RESULTS WITH VARIOUS CRITERIA
Criterion
Delivered size
Final TD index
Constant (0%)
1248 FP
0.84
Constant (10%)
1580 FP
0.64
Constant (20%)
1743 FP
0.41
Constant (30%)
1723 FP
0.13
Constant (40%)
1517 FP
0.007
1-(1-TDindex)3
1764 FP
0.11
1-(1-TDindex)1/3
1601 FP
0.51
Threshold
1674 FP
0.01–0.03
First, allocating a constant amount of effort to TD im-
provement does not seem a good idea. In fact, if the chosen
fraction of effort allocated to TD improvement is too high or
loo low, the productivity of enhancement maintenance will be
lower than possible. Also, the ﬁnal quality of the product (as
indicated by the TD index) could be quite low. In practice,
allocating a constant amount of effort to TD improvement
works well only if the right fraction of effort is allocated, but
choosing such fraction may not be easy.
On the contrary, computing the amount of effort for TD
improvement at the beginning of each sprint, based on the
current TD index seems very effective, especially as far as
50
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

optimizing the productivity of enhancement maintenance is
concerned.
One could observe that in some situations it may be hard to
separate clearly the effort devoted to enhancements from the
effort devoted to TD improvement. This is particularly true
when developers perform refactoring activities while they are
enhancing the existing code. For this reason, an organization
may want to have sprints entirely dedicated to refactoring
and other TD improving activities, and sprints entirely ded-
icated to enhancements. In this case, the evaluations given
in Section IV-C show that allocating an entire sprint to TD
improvement whenever there is enough TD to absorb one
spring effort provides quite good results, in terms of both
productivity and quality.
In any case, we have to stress that all the presented
strategies for TD management are based on the quantitative
evaluation of TD, which results in the TD index. So, devising
a way to measure TD appears fundamental to managing TD
effectively and efﬁciently.
VI.
RELATED WORK
System Dynamics was ﬁrst applied in Software Engineer-
ing by Abdel-Hamid and Madnick [12], who proposed a model
that accounted for human resource management, software
development, and planning and control. System Dynamics was
then extensively used to model software development and its
management. A survey of System Dynamics applied to project
management was published by Lyneis and Ford [13], while
in [14] De Franca and Travassos propose a set of reporting
guidelines for simulation-based studies with dynamic models
in the context of SE to highlight the information a study of
this type should report.
Cao et al. [15] proposed a System Dynamics simulation
model that considers the complex interdependencies among the
variety of practices used in Agile development. The model can
be used to evaluate—among others—the effect of refactoring
on the cost of implementing changes.
Glaiel et al. [16] used System Dynamics to build the Agile
Project Dynamics model, which captures each of the Agile
main characteristics as a separate component of the model
and allows experimentation with combinations of practices and
management policies.
Although less comprehensive than the mentioned models,
our proposal allows for better undrstanding the consequences
of technical debt and the effectiveness of its management
strategies.
VII.
CONCLUSIONS
The term “Technical Debt” indicates several concepts and
issues related to software development and maintenance. The
latter are complex and multifaceted activities: accordingly, it
is not surprising that managing TD is quite difﬁcult [5].
In this paper, we have provided a formal, executable model
of time-boxed software development, where the effects of TD
are explicitly and quantitatively represented and accounted for.
The model is usable to show—via simulation—the effects that
TD have on relevant issues such as productivity and quality,
depending on how TD is managed, with special reference on
how much effort is dedicated to TD repaiment and when—in
a sequence of sprints—such effort is allocated.
The model can be used to prove or disprove concepts
and hypotheses, to perform what-if analyses, etc. However,
our model is not intended to be used in practical software
project management as-is, becase, the model illustrated above
is too abstract and contains hypotheses that could not match
the target development environment. Whoever wants to use
the presented model for practical project management should
ﬁrst enhance it; examples of models representing all the main
aspects of software development can be found in the papers
by Cao et al. [15] and Glaiel et al. [16].
We plan to extend the presented model in several direc-
tions: to account for different effects of TD on productivity
(i.e., with functions different from the one in Figure 1), to
explicitly model defects, to test different debt management
policies, etc.
ACKNOWLEDGMENT
This work was partly supported by the “Fondo di ricerca
d’Ateneo” funded by the Universit`a degli Studi dell’Insubria.
REFERENCES
[1]
Z. Li, P. Avgeriou, and P. Liang, “A systematic mapping study on
technical debt and its management,” Journal of Systems and Software,
vol. 101, 2015, pp. 193–220.
[2]
C. Fern´andez-S´anchez, J. Garbajosa, A. Yag¨ue, and J. Perez, “Iden-
tiﬁcation and analysis of the elements required to manage technical
debt by means of a systematic mapping study,” Journal of Systems and
Software, vol. 124, 2017, pp. 22 – 38.
[3]
A. Nugroho, J. Visser, and T. Kuipers, “An empirical model of technical
debt and interest,” in Proceedings of the 2nd Workshop on Managing
Technical Debt.
ACM, 2011, pp. 1–8.
[4]
N. Ramasubbu and C. F. Kemerer, “Managing technical debt in enter-
prise software packages,” IEEE Transactions on Software Engineering,
vol. 40, no. 8, Aug. 2014, pp. 758–772.
[5]
P. Avgeriou, P. Kruchten, I. Ozkaya, and C. Seaman, “Managing
technical debt in software engineering (dagstuhl seminar 16162),” in
Dagstuhl Reports, vol. 6, no. 4.
Schloss Dagstuhl-Leibniz-Zentrum
fuer Informatik, 2016, pp. 110–138.
[6]
J. Letouzey, “The SQALE method for evaluating technical debt,” in Pro-
ceedings of the Third International Workshop on Managing Technical
Debt, MTD 2012, Zurich, June 5, 2012, 2012, pp. 31–36.
[7]
“Automated technical debt measure – beta,” Object Management Group,
speciﬁcation ptc/2017-09-08, September 2017.
[8]
J. Forrester, Industrial Dynamics.
Cambridge: MIT Press, 1961.
[9]
A. J. Albrecht, “Function points as a measure of productivity,” in Act
as do 53 rd meeting of GUIDE International Corp., Guidance for users
of integrated data processing equipment conference, Dallas, 1981.
[10]
IFPUG, “Function point counting practices manual, release 4.2,” IF-
PUG, Tech. Rep., 2004.
[11]
L. Lavazza, S. Morasca, and D. Tosi, “An empirical study on the factors
affecting software development productivity,” e-Informatica Software
Engineering Journal, vol. 12, no. 1, 2018, pp. 27–49.
[12]
T. Abdel-Hamid and S. E. Madnick, Software project dynamics: an
integrated approach.
Prentice-Hall, Inc., 1991.
[13]
J. M. Lyneis and D. N. Ford, “System dynamics applied to project
management: a survey, assessment, and directions for future research,”
System Dynamics Review, vol. 23, no. 2-3, 2007, pp. 157–189.
[14]
B. B. Franc¸a and G. H. Travassos, “Experimentation with dynamic
simulation models in software engineering: Planning and reporting
guidelines,” Empirical Software Engineering, vol. 21, no. 3, June 2016,
pp. 1302–1345.
[15]
L. Cao, B. Ramesh, and T. Abdel-Hamid, “Modeling dynamics in agile
software development,” ACM Transactions on Management Information
Systems (TMIS), vol. 1, no. 1, 2010, pp. 5:1–5:27.
[16]
F. S. Glaiel, A. Moulton, and S. E. Madnick, “Agile project dynamics: A
system dynamics investigation of agile software development methods,”
2014.
51
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-668-2
ICSEA 2018 : The Thirteenth International Conference on Software Engineering Advances

