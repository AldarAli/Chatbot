A Distributed Protocol for Wireless Sensor
Networks Based on Multiple-Leader Stackelberg
Network Games
Gautam S. Raj and Volkan Rodoplu
Department of Electrical and Computer Engineering
University of California, Santa Barbara, CA 93106
gautamraj@gmail.com, vrodoplu@ece.ucsb.edu
Abstract—While the past literature on game theory rarely
addresses the implementation of protocols that converge to Nash
equilibria, practical networks must be designed with proto-
cols that correctly address issues of information asymmetries,
hysteresis effects due to these asymmetries, and the fact that
information can propagate only locally on networks. To this
end, we develop a distributed protocol based on multiple-leader
Stackelberg network games to efﬁciently utilize the localized
energy resources of a sensor network. Our protocol arrives at
a Nash equilibrium of the multiple-leader Stackelberg network
game. We demonstrate the performance of our protocol under
a large-scale fading model for the internodal links, and quantify
its control overhead. Through this work, we ﬁnd that there are
considerable differences between centralized implementations of
algorithms that ﬁnd Nash equilibria on networks, and distributed
protocols that can converge to those equilibria in practice.
Index
Terms—network,
Stackelberg,
game,
pricing,
dis-
tributed, protocol
I. INTRODUCTION
Wireless sensor networks are typically conceived of as
collective entities that collect information from an area and
relay it to a collection site (a.k.a. base station) via a multi-
hop network between the sensor nodes. However, decisions in
sensor networks have to be made in a localized and distributed
manner. Each node usually has a limited battery supply that it
has to conserve, and sees different Joules-per-bit costs along
the different links to its neighbors, assuming that each node is
able to dynamically adjust its transmit power level to reach its
neighbors [1]. In addition, sensor networks typically operate
in the low trafﬁc load regime; that is, the key measure is not
the achieved bits-per-second throughput, but rather the bits-
per-Joule capacity [2] of the network, namely the number of
bits that can be sent per Joule of energy to the destination.
As a result, in sensor networks, most of the bandwidth goes
unused, and end-to-end data transmissions typically occur in
an on-demand fashion, initiated either by the source that has
just collected some important data, or “pulled” from the source
by the destination [3].
Game theory models each node as a selﬁsh, autonomous
entity that aims to maximize its own utility. Even though the
nodes in a sensor network have as their common objective,
the reliable end-to-end delivery of sensor data, from the
perspective of distributed, localized protocol design, each node
can be modeled as an entity that also aims to preserve its
battery resources by reﬂecting the energy costs it is incurring
to transfer the information. Then, the most natural setting
in which this locally available information is made visible
to the network is through pricing variables that are locally
determined by the relay nodes.
The application of game theory to routing problems in
wireless sensor and ad hoc networks is not new. Sadagopan
et al. [4] show the construction of an energy-balanced tree
of sensor nodes, modeling each sensor as a selﬁsh entity.
Nurmi [5] models energy-constrained routing in ad hoc net-
works made up of selﬁsh nodes, and lets the source send
along the best path based on its subjective beliefs about the
amount of remaining energy at the relay nodes. Liu et al. [6]
assume that each node forwards with some probability, and
take the end-to-end reliability to be the product of these.
Under a single-source, single-destination model, they develop
a polynomial-time method for deriving a Nash equilibrium
routing path. Sengupta et al. [7] apply non-cooperative game
theory to power control problems in wireless sensor networks,
taking each sensor as a selﬁsh entity. Similarly, Campos-
Nanez et al. [8] develop a game-theoretic approach to power
management in sensor networks, and Kannan et al. [9] model
wireless sensors in a routing game to achieve reliable, energy-
constrained routes through the sensor network. Felegyhazi et
al. [10] examine cooperative packet forwarding in a game-
theoretic framework in multi-domain sensor networks.
None of the above works consider the incorporation of the
source’s utility function into the decisions of a relay node, as
in a Stackelberg framework. In the past, Stackelberg games
have been to applied to wired networks with a single Internet
Service Provider (ISP) [11]–[13], where the ISP (or a group of
multiple ISPs [14]) is the Stackelberg leader, and the network
users are the followers. More recently, this model has also
been applied to wireless networks [15], again under a single-
leader setting. In contrast to these single-leader settings, this
paper utilizes the framework of a “multiple-leader Stackelberg
game”, introduced in [16], in which each relay node acts as a
leader that anticipates the response of the source node that is
currently initiating trafﬁc to the base station.
27
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-231-8
ICSNC 2012 : The Seventh International Conference on Systems and Networks Communications

Fig. 1.
General network topology.
The main contribution of the current paper is the design of
a distributed protocol that converges to a Nash equilibrium
of the multiple-leader Stackelberg game. In fact, the Nash
equilibrium to which our protocol converges is a Pareto-
optimal Nash equilibrium; that is, it is not possible to increase
the utility of any one of the users without decreasing the utility
of another user. (This fact cannot be proved within the scope
of this paper.) Pareto-optimality generalizes scalar capacity
to multiple dimensions. Nash equilibria are desirable because
they constitute stable operation points from the perspectives
of the users in a system. A Nash equilibrium implies that a
user cannot beneﬁt from unilateral deviations (i.e., deviations
by itself) from the operation point of the network. While
this is clearly desirable when users have competing objectives
(as in non-cooperative games), it is also desirable in the
implementation of distributed protocols on sensor networks.
In this paper, we model each relay node as an autonomous
entity that aims to maximize its own utility. However, the
Stackelberg formulation by which each relay node takes into
account the utility of the source node creates the link that ties
that objectives of the nodes together. Hence, the Stackelberg
feature is what makes the protocol useful for application to
sensor networks.
While the past literature on the application of game theory
to networks rarely addresses the implementation of protocols
that converge to Nash equilibria, practical networks must
be designed with protocols that correctly address issues of
information asymmetries between the nodes, hysteresis effects
due to these asymmetries, and the fact that information can
propagate only locally in these networks. This paper makes
an important contribution in this regard in that it explicitly
addresses the design of a distributed protocol that overcomes
these effects, and further quantiﬁes the overhead of this design
in order to show that it is viable. Through this work, we show
that there are considerable differences between centralized
implementations of algorithms that ﬁnd Nash equilibria on
networks, and those that design distributed solutions.
The rest of this paper is organized as follows: In Section II,
we describe our utility and network models. In Section III,
we design a distributed network protocol that converges to
a Nash equilibrium of the multiple-leader Stackelberg game
on this network. In Section IV, we analyze the performance
of this protocol when it is applied to energy-limited, ad hoc
wireless networks. In Section V, we present our conclusions.
II. MODELS AND ASSUMPTIONS
In this paper, we consider a sensor network of N nodes
on an arbitrary topology G. Since the data generation rates
in typical sensor networks (e.g., for habitat monitoring and
sensing) can be as low as a few kilobytes per hour, and
commercial modems (such as Crossbow [17]) typically operate
at relatively high data rates such as 250 Kbits per second,
bandwidth usage is not an issue; however, energy consumption
is of paramount importance. Due to the low data generation
rates, we can focus on the data from a single source to the
destination at a time, as shown in Fig. 1. On this topology, the
Joules-per-bit cost from each node to any one of its neighbors
is ﬁxed, and is independent of the concurrent transmissions
on the other links. The constant Joules-per-bit costs (rather
than e.g., convex costs) hold if the modulation scheme is ﬁxed
(e.g., adaptive modulation is not used). The non-interference
assumption is well-justiﬁed in the low data rate sensor network
scenario (see [18] for a full justiﬁcation, with numerical
examples from sensor network applications.)
Throughout the paper, we focus on a single source at a
time. This is possible because the ratio of the total average
generated data rate to the available bandwidth is very low in
sensor networks. We label the source node as node 1, and the
destination node as node N. We let ℵ denote the node set, and
R denote the set of relay nodes; that is, R = {2, . . . , N − 1}.
In order to reﬂect back to the source the average energy
costs that it bears, each relay node i charges a price pi
per bit, independently of which outgoing link is used for
the transmission. Each pi is a variable under the control of
the relay node i. The total price along any path h from the
source to the destination is the sum of the prices on h, and
this price is assumed to be borne by the source node. These
prices merely constitute a distributed scheme to organize and
efﬁciently utilize the network’s energy resources.
We focus on the utility of the source node each time that
it has accumulated sufﬁcient sensor data to be sent to the
destination. However, as mentioned earlier, since the prices
reﬂect the energy costs of transmission to the relay nodes, the
source node may end up sending a variable number of bits to
the destination, trading off the energy cost of transmission in
the relay nodes against the utility gained by sending sensor
data to the destination. As in [16], we model the utility of the
source node as
u1(b1) = M1b1/α
1
− ptotal
best (p)b1, α > 1, b1 ≥ 0
(1)
In the above equation, the variable b1 is the number of bits
that the source node chooses to send through the network to the
destination node. We call parameter M1 > 0 the “amplitude”
of the utility function. The physical meaning of this parameter
is that it determines how much value we place on sending
sensor data end-to-end. Making this parameter larger means
that we place more value on this, relative to the prices that
are charged (which reﬂect the relay nodes’ energy costs).
The parameter α > 1 governs the curvature of the source’s
utility function. Physically, a small α means that the beneﬁts
of sending more bits continue to remain large even as b1
increases.
The source node always chooses the path with the lowest
price to the destination. Above, ptotal
best (p) is the total price of
the lowest price path from the source to the destination. It is
a function of the vector p, which is the vector of all of the
28
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-231-8
ICSNC 2012 : The Seventh International Conference on Systems and Networks Communications

prices of the relay nodes in the network. Node 1 always acts
to maximize its own utility.
The second part of our model focuses on the utility function
of each relay node. We assume that a relay node i gains
a utility of pi for each bit that it transmits along one of
its outgoing links, and loses a utility equal to the cost of
transmitting along that link. Let hi denote a path of links from
the source to the destination, such that the path goes through
the node i. Let ci,next(hi) denote the cost per bit incurred by
i to transmit on the link that goes out from i and that falls on
the path hi. Note that this cost may depend on both the Joules-
per-bit link cost as well as the remaining battery energy of the
relay node. Hence, the notion of cost cij is general. Then, the
utility of relay node i is
ui(pi) = (pi − ci,next(hi))b[hi]
(2)
where b[hi] is the number of bits that the source node chooses
to send through node i, along the path hi. We see that in
order to achieve a positive utility, it is necessary that node i
set pi > ci,next(hi).
Now, one of the key assumptions in our framework is
that even though prices are used to arrive at a distributed
management of localized resources in a sensor network, over-
all, the sensor network represents a collective effort to send
sensor data end-to-end from the source to the destination.
Hence, it is to the network’s advantage to incorporate the
form of the utility function of the source node into the relay
node’s decisions. Such schemes are generally referred to as
“Stackelberg games” where the leader incorporates into its
own utility function, the form of the utility function of the
follower. Here, the source node is the follower, and each of
the relay nodes acts as a leader, hence, resulting in the novel
form of a multiple-leader Stackelberg game. Based on this
discussion, the utility model of a relay node i is given by
ui(pi; p−i) = (pi − ci,next(hi))b1[hi](pi; p−i)
(3)
where p−i denotes the set of prices of all of the relay nodes
besides i, and b1[hi](pi; p−i) is the number of bits that Node 1
sends through node i via path hi, after it has chosen the lowest
price path and the number of bits to send through that path,
via its maximization of its own utility in (1). (Note that if node
i is not on the lowest price path, then b1[hi](pi; p−i) = 0; that
is, no bits are sent through node i.)
III. DISTRIBUTED PROTOCOL DESIGN
In [16], we described a centralized algorithm to ﬁnd a Nash
equilibrium of the network over an arbitrary topology G of
relay nodes. In this paper, we describe a distributed network
protocol that the nodes can use in practice to converge to a
Nash equilibrium. The distributed protocol that we present
converges to a Nash equilibrium because it implements the
centralized algorithm of [16] whose convergence to a Nash
equilibrium was proved. The main idea behind the convergence
of this protocol is as follows: we designed an algorithm
on a general topology that converged to a Nash equilibrium
by solving a set of price equations via the Jacobi method.
The same Jacobi method is implemented via the distributed
protocol, as will be seen shortly for the serial network. After
this, the competition that occurs between parallel paths within
the network is modeled by the protocol’s dynamically placing
caps on the prices on the currently winning path via the
constraints that occur due to the competition paths. The main
challenge that we have to address in this setting is that each
node can communicate only with its neighbors on the topology
G; hence, no global information channels that can announce
all of the prices of the relay nodes to each other exist. Further,
the source node can become aware of the relay node prices
only through its own links on G, and any announcements by
the source node, of the best current bid (that is, the best current
lowest price path) must propagate to all of the relay nodes via
the links on G.
Finally, the control overhead of the resulting network proto-
col must be small enough to justify its use in sensor networks.
We shall demonstrate this in the next section.
Fig. 2.
SPA Packet
Fig. 3.
DPA Packet
A. Distributed Protocol on a Serial Network
For ease of exposition, we begin by developing the protocol
ﬁrst for the serial network of Fig. 4. In a serial network, every
relay node needs to update its price pi according to (see (11)
in [16]):
∀i ∈ R : p∗
i = (α − 1)
[
∑
j∈R\{i}
p∗
j + c12
]
+ αci,i+1
(4)
The sum of the prices of all of the other relay nodes can be
efﬁciently accumulated as follows: The source node initiates a
“Source Price Accumulate” (SPA) packet, and sends it on its
link to Node 2 in Fig. 4. The ultimate destination of this packet
is Node N. The structure of this packet is shown in Fig. 2.
The second ﬁeld is the iteration number k of the protocol,
which is set to 0 for the ﬁrst SPA that the source ever sends
out. The third ﬁeld of this packet is the “Sum Price From
29
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-231-8
ICSNC 2012 : The Seventh International Conference on Systems and Networks Communications

Fig. 4.
An N-node serial network.
Source” (SPFS), which accumulates the total sum price from
the source node thus far. Node 1 initializes this ﬁeld to c12,
which is the cost of the link from 1 to the next node on which
this SPA is being sent. (This is denoted by c1,next(w) in the
ﬁgure, where w is the path that this SPA travels on.) We shall
now describe the events for the kth iteration. When Node 2
receives the SPA, it records the price accumulated from the
source thus far, and adds its own current price p2[k] to this
ﬁeld. In the 0th iteration, p2[0] = c23, which is the cost of the
link to the next node. The fourth ﬁeld w is an expandable list,
that contains the path through which the SPA has travelled
thus far. Hence, Node 2 also adds its node ID to the path w
in the fourth ﬁeld, and sends the SPA to Node 3. Node 3, and
all of the relay nodes in this sequence continue in a similar
fashion.
When the SPA packet has reached the destination node N,
all of the relay nodes have accumulated the sum of the prices
of the relay nodes to their left on the serial network, via the
SPFS ﬁeld. When Node N receives the SPA, it records the
path w which contains all of the nodes through which the SPA
travelled, as well as the total price, namely the value of the
SPFS ﬁeld, accumulated through the entire path. Then, Node
N initiates a “Destination Price Accumulate” (DPA) packet
toward the source node. The structure of the DPA packet is
shown in Fig. 3. The third ﬁeld in the DPA is the “Sum Price
From Destination” (SPFD), which accumulates the sum of the
prices on the forward links toward the destination. Because
there is only one path from the source to the destination in a
serial network, Node N sets w∗, the “winning path” ﬁeld of the
DPA, to the path w of the SPA that it has just received. Note
that the sixth ﬁeld of the DPA, p(w∗) is an expandable vector
of prices. This ﬁeld is initially empty, and will be updated by
the relay nodes on the winning path w∗, as the DPA travels
back.
When a relay node i receives the DPA, it records the value
of the SPFD ﬁeld. At this point, the relay node i has the sum
of the prices of all of the other relay nodes, obtained from the
SPFS ﬁeld of the SPA, and the SPFD ﬁeld of the DPA. Thus,
it now updates its price pi[k + 1] according to (4). Then, it
adds its current price, pi[k +1] to the SPFD ﬁeld, and sends it
toward the source node. Hence, when the DPA has reached the
source node, all of the relay nodes have updated their prices.
Further, the source has just received the winning path w∗ from
the ﬁfth ﬁeld of the DPA, as well as all of the new prices on
the winning path, namely p(w∗) from the ﬁfth and sixth ﬁelds
of the DPA.
After the source has received the DPA of the kth iteration,
it ﬁrst checks whether the prices on the winning path w∗
have converged. It does this by taking the norm of the
difference between the prices on w∗ in the current and the
previous iterations. If the prices on w∗ have converged, then
Fig. 5.
Example topology.
it terminates the SPA-DPA exchanges, and announces the ﬁnal
path w∗∗ via a separate packet to all of the nodes. Otherwise,
it prepares a new SPA packet, with iteration number k + 1 in
the second ﬁeld, and with the currently winning path w∗ that
it has copied from the DPA into the ﬁfth ﬁeld of the SPA, and
sends this SPA toward the destination.
B. Distributed Protocol on the General Topology
The distributed protocol on the general topology will im-
plement a distributed version of the centralized algorithm in
Fig. 3 of [16]. The centralized algorithm has access to all of
the constraint equations on the least cost path ˜h∗. In contrast,
in the distributed protocol, the nodes do not know the ˜h∗ path
a priori, and have no global picture of the constraints on the
˜h∗ path. Hence, both ˜h∗ and the price constraints have to
be discovered dynamically, while the price competition takes
place among the relay nodes. A part of the main structure
of the protocol is the SPA-DPA exchanges described for the
serial network in the previous subsection. The pseudocode for
the distributed protocol is shown in Figs. 6-9. On a general
topology, on line 12 of Fig. 6, the source initiates an SPA
along each of the paths that emanate from it. On lines 16-26
of Fig. 7, when a relay node i receives an SPA, it ﬁrst checks
the accumulated price thus far (namely the value of the SPFS
ﬁeld) against minSPFS which is an internal variable of i, set
to the minimum SPFS value observed so far. If the value of
the SPFS ﬁeld is greater than the value of minSPFS, then
it discards the SPFS ﬁeld of this SPA. Otherwise, a better
total price from the source up to this relay node has been
discovered; hence, minSPFS is updated to the value of the
SPFS of this SPA.
We shall now describe the protocol for the example network
in Fig. 5. We deﬁne an iteration as one SPA-DPA exchange
from the source back to the source. In iteration 0, the source
starts the competition round by sending an SPA to Nodes 2
and 4. Nodes 2 and 4 record the current path w, and the SPFS
from the SPA. After storing these ﬁelds, they append their
node IDs to the w ﬁeld, and add their link costs to the SPFS
ﬁelds of their respective SPAs. In this example, Node 4 will
add its current price (which is c43 in this iteration), while
Node 2 will add its current price (c23 in this iteration) when
sending to node 3, and c25 when sending to Node 5. Then,
they forward the SPAs to their next nodes, who repeat the
process, until all of the SPAs reach the destination. The set
of “next nodes” of any node i is deﬁned as the set of all of
its neighbor nodes except the ones in the w ﬁeld of the SPA.
(This prevents loops.) These actions are shown on lines 16-26
of Fig. 7.
For the destination node, the Receive function on line 8 of
30
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-231-8
ICSNC 2012 : The Seventh International Conference on Systems and Networks Communications

1
// Internal Variables
2
int K MAX= K MAX; // max iterations
3
int J MAX= J MAX; // max nodes
4
minSPFD[K MAX] = [LARGE,.. .,LARGE]; //min sum price from dest.
5
minW = NULL; //min price route from destination
6
k = 0; //sequence number of SPA
7
p[J MAX][K MAX];
8
δ = DELTA;
9
p[∗][−1] = LARGE;
10
links = this→allOutgoingLinks;
11
// Main Function
12
send SPA(links,k,c1,next(links),1,NULL,NULL,NULL);
13
k++;
14
while (TRUE) {
15
while (Receive(DPA[k])) { //Receive all DPA’s for kth iteration
16
[spfd, w; w∗, p[w∗][k], p[˜h∗][k]] = ExtractFields(DPA[k]);
17
if (spfd < minSPFD[k]) {
18
minSPFD[k]=spfd;
19
minW = w;
20
}
21
} // Got all DPAs for iteration k
22
w∗ = w;
23
if (k == 0)
24
˜h∗ = w;
25
else if (||p[w∗][k] − p[w∗][k − 1]|| < δ | k == K MAX) {
26
send(w∗∗, links); //announce ﬁnal path
27
break;
28
}
29
send SPA(links,k, c1,next(links), 1, w∗, p[w∗][k], p[˜h∗][k]);
30
k++;
31
}
Fig. 6.
Distributed protocol executed by the source node.
Fig. 9 has a built-in timer that stops listening for new SPA
packets after a timeout has been reached. The timeout must
be as long as needed to receive the SPA packets on all of the
closest competition paths, and depends on the network size
N. If all of the nodes were in a linear arrangement, then the
timeout must grow linearly with N. If the nodes are randomly
deployed on a square region, then, since the average number
of hops from a source at one end to a destination at another
grows as O(
√
N), the timeout must grow in this fashion with
respect to N, with the coefﬁcient of the growth larger for a
smaller probability that the SPA’s from not all of the paths
may have arrived by that time. (A design that aims at no loss
from optimality uses a design that grows linearly with N in
all cases.)
In iteration 0, once the destination receives all the SPAs,
it computes the lowest-cost path ˜h∗, by ﬁnding the minimum
SPFS, and using the corresponding w. Then, the destination
creates a DPA and sends it toward the source, on nodes 3 and
5 in Fig. 5, as shown on line 15 of Fig. 9. In iteration 0, each
relay node that receives the DPA records the lowest-cost path
˜h∗, from the w∗ ﬁeld of the DPA, as shown on lines 29-31
of Fig. 7. Each relay node also adds its node ID to the w
ﬁeld, and its current price (which is its link cost in iteration
0) to the SPFD ﬁeld (lines 59-66). At this point, the node can
compute its price for the next iteration, using (4). If the node
sees from the DPA that it is on w∗ for the 0th iteration, it also
appends its price to the p(w∗)[0] and p(˜h∗)[0] ﬁelds of the
DPA (line 60). This is done at each node for each DPA packet
that it receives. Once the source receives all the DPAs, it must
determine the winning path w∗ for iteration 0. To do this, as
shown on lines 15-22 of Fig. 6, it ﬁnds the minimum SPFD
value from all the DPAs, and records the corresponding path
1
// Internal Variables
2
int K MAX= K MAX; // max iterations
3
int J MAX= J MAX; // max nodes
4
minSPFS[K MAX] = [LARGE,. . . ,LARGE] // min sum price from source
5
minW FS[K MAX] = [NULL,. . . ,NULL] // min price path from source
6
minSPFD[K MAX] = [LARGE,. . . ,LARGE] // min sum price from dest
7
minW FD[K MAX] = [NULL,. . . ,NULL] // min price path from dest
8
w∗[K MAX]; // winning path for iteration k
9
˜h∗ = w∗[0]; // lowest cost path
10
priceLocked = FALSE;
11
nodesConstrained = ∅;
12
//Main Function
13
i = this→nodeID;
14
links = this→allOutgoingLinks;
15
while (TRUE) {
16
while (Receive(SPA[k])) {
17
[spfs,w SPA,w∗[k], p[w∗][k], p[˜h∗][k]] = ExtractFields(SPA[k]);
18
if (i /∈ w SPA) { // Prevent loops
19
if (spfs < minSPFS[k])
20
minSPFS[k] = spfs;
21
foreach (link ∈ links)
22
if (link→nodeID == nextNode(˜h∗))
23
send SPA Link(link,k,spfs + p[i][k], w SPA+→ i);
24
else
25
send SPA Link(link,k,spfs + ci,next(link),w SPA+→ i);
26
}
27
}
28
while (Receive(DPA[k])) {
29
[spfd, w DPA, w∗] = ExtractFields(DPA[k]]);
30
if (i /∈ w DPA && spfd < minSPFD[k])
31
minSPFD[k] = spfd;
32
if ((i /∈ ˜h∗) || (nextNode(w DPA) != nextNode(˜h∗)))
33
p[i][k] = ci,next(w DPA); // Return link cost
34
else if (i ∈ w∗[k] && nextNode(w DPA) ∈ w∗[k]) { // On w∗[k]
35
k last = k; // Store last time on best path
36
if (priceLocked)
37
p[i][k + 1] = p[i][k];
38
else if ((nodesConstrained\w∗[k]) ! = ∅) {
39
p[i][k + 1] = p[i][k];
40
willLock = FALSE;
41
}
42
else if (nodesConstrained ⊆ w∗[k] && willLock) {
43
priceLocked = TRUE;
44
p[i][k + 1] = p[i][k];
45
nodesConstrained = ∅;
46
}
47
else if (˜h∗ ∩ w∗[k] ̸= ∅)
48
p[i][k + 1] = p[i][k];
49
else { // Node is not locked, so unfreeze price updates
50
SumOtherPricesOnPath[k] = minSPFS[k] + minSPFD[k];
51
p[i][k + 1] = (α − 1)SumOtherPricesOnPath[k]+αci,next(˜h∗);
52
}
53
}
54
else { // Not on w∗[k]
55
[ϵ, nodesConstrained] =
Surplus(w∗[k last], w∗[k], p[][k last], p[][k], i);
56
p[i][k + 1] = p[i][k] + ϵ
∑
j∈nodesConstrained
(p[j][k] − p[j][k last])
57
willLock=TRUE;
58
} // Finished computing price, now send DPA
59
if (i ∈ w∗ && i ∈ ˜h∗)
60
send DPA(links,k,spfd+p[i][k],(w DPA)+→ i, p[i][k], p[i][k]);
61
else if (i /∈ w∗ && i ∈ ˜h∗)
62
send DPA(links,k,spfd+p[i][k+1],(w DPA)+→ i,NULL, p[i][k+1]);
63
else if (i ∈ w∗ && i /∈ ˜h∗)
64
send DPA(links,k,spfd+p[i][k],(w DPA)+→ i, p[i][k],NULL);
65
else
66
send DPA(links,k,spfd+p[i][k],(w DPA)+→ i,NULL,NULL);
67
}
68
if (Receive(w∗∗)) {
69
if (i ∈ w∗∗) lockedPrice = p[i][k];
70
break;
71
}
72
}
Fig. 7.
Distributed protocol executed by each relay node.
w as w∗.
In iteration 1, the source initiates the SPA using the w∗
and the node prices from iteration 0. Once a relay node i
receives an SPA, it appends its price pi[0] to the SPFS ﬁeld
31
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-231-8
ICSNC 2012 : The Seventh International Conference on Systems and Networks Communications

1
[ϵ,nodesConstrained]=Surplus(w∗(k − 1), w∗(k), p[][l], p[][k], i) {
2
[oldPath,newPath] = FindRemovedSegment(w∗(l), w∗(k), i);
3
cap =
∑
j∈newPath
p[j][k];
4
ϵ =
cap −
∑
j∈oldPath
p[j][l]
∑
j∈oldPath
(p[j][k] − p[j][l])
;
5
}
Fig. 8.
Surplus subroutine for the relay nodes.
1
// Internal Variables:
2
K MAX =
K MAX;
3
minSPFS[K MAX] = [LARGE,. .. ,LARGE];
4
k = 0;
5
// Main function
6
links=this→allOutgoingLinks;
7
while (TRUE) {
8
while (Receive(SPA[k])) {
9
minSPFS = LARGE;
10
[spfs, w, p(˜h∗)] = Extract(SPA[k]); // Uses Sequence No. of SPA
11
if (spfs < minSPFS[k]) {
12
minSPFS[k] = spfs;
13
w∗ = w;
14
} // Got all SPAs for iteration k
15
send DPA(links,k,0,this→nodeID,w∗,NULL,NULL);
16
k++;
17
}
18
}
Fig. 9.
Distributed protocol executed by the destination node.
and its node ID to the w ﬁeld, and forwards the SPA to its
next nodes (lines 16-26, Fig. 7). The destination node now
computes w∗ for iteration 1, by ﬁnding the minimum SPFS
value, and sends out DPAs on all of its outgoing links (lines
8-17, Fig. 9). When a relay node receives a DPA packet for
iteration 1, it checks if it is on w∗, and if so, it appends its
price for the current iteration to p(w∗)[k] and p(˜h∗)[k]. Then,
it computes its price for the next iteration, and forwards the
DPA to its next nodes (lines 59-66, Fig. 7).
Returning to our example in Fig. 5, suppose that in iteration
k, Node 2 receives a DPA in which Node 2 is not on w∗. In
this case, because Node 2 is on ˜h∗, it will append its price
for iteration k to the SPFD and p(˜h∗)[k] ﬁelds, and forward
it to all of its next nodes. Node 2 would like to lower its
price to return to w∗, but it does not know the constraint cap
imposed on it; that is, it does not know c14 + c43. Hence, it
must wait for the SPA in iteration k + 1 to travel on the path
1 → 4 → 3 → 6, and then for a DPA in iteration k + 1 to
inform Node 2 of the prices of the nodes in the constraint,
which is only Node 4 in this case. Once Node 2 receives the
DPA for iteration k + 1, it computes the cap from p(w∗)[k],
and interpolates its price back using the Surplus subroutine of
Fig. 8. Then, it immediately adds this new price to the SPFD
and p(˜h∗)[k] ﬁelds of the DPA, and forwards it to all of its next
nodes. This is done to ensure that Node 2 can return to w∗ as
quickly as possible. Since this is the only constraint imposed
on it in Fig. 5, Node 2 will return to w∗ in iteration k + 2.
Because the constraint cap is satisﬁed with equality, Node 2
can now lock its price for the remainder of the iterations (lines
54-58, Fig. 7).
In general, we may have multiple relay nodes that together
exceed some constraint cap. In this case, we would like all the
nodes that are capped by the same constraint to act together to
reduce their prices, such that the sum of their prices is exactly
equal to the cap. Any contiguous segment of nodes that is
removed from ˜h∗ has encountered some constraint imposed
on it. We denote this segment of nodes on ˜h∗ by R1, and the
constraining set of nodes by C1. In the Surplus subroutine of
Fig. 8, FindRemovedSegment on line 2 returns the contiguous
set of removed nodes R1, of which relay node i is a member.
On line 3, node i sums the prices of the nodes in C1 to
determine the constraint cap that is imposed on it, and on
line 4, it computes the surplus.
When multiple nodes exceed this constraint cap, increasing
any of the nodes’ prices would violate the cap; hence, we
freeze the price updates for all the nodes on R1 (lines 42-
46, Fig. 7). However, after this, if only a subset of the nodes
in R1 has returned to w∗, this implies that there is another
constraint acting on them (lines 38-41, Fig. 7). We denote this
smaller subset by R2, and the new set of constraining nodes
by C2. At this point, we temporarily freeze the prices of all
the nodes that have returned to w∗, namely R1\R2. Then, the
nodes in R2 interpolate their prices again (lines 54-58, Fig. 7),
using the new segment of contiguous nodes and the new cap,
imposed by C2. Let m be the number of nodes on segment
R1. Then, after O(m2) applications of this procedure, all of
the relevant constraints for R1 will have been discovered, and
hence, all the nodes on ˜h∗ will have returned to w∗.
Although all the nodes on R1 have returned to w∗, their
prices are not in Nash equilibrium: Even though we initially
set the sum of the prices for the nodes on R1 equal to the
cap C1 with equality, at the end of the above procedure, this
is no longer the case. In fact, only the last set of nodes in
the procedure to return to w∗ are set exactly equal to the ﬁnal
cap. In Fig. 7, the variable willLock is TRUE only for this
set of nodes. Hence, we permanently lock the prices of the
last nodes to return to w∗, and allow all the other nodes in
R1 to resume monopoly pricing (lines 42-46, Fig. 7). This
process continues for the rest of the nodes until the prices of
the nodes have converged, or until KMAX has been reached
(lines 25-28, Fig. 6).
IV. SIMULATION RESULTS
We simulate the distributed protocol of Section III, using
the same random node placement and link costs as of the
centralized protocol simulations, as in [16]. The dominant
factor in the convergence to Nash equilibrium is the number
and structure of the competing paths; however, it is difﬁcult
to characterize analytically the dependence of the convergence
rate upon such a complex factor. As a remedy, we examine the
convergence rate of the protocol via the simulation studies in
this section. It should be noted that the simulation studies in
this section should be read as a sequel to the simulation studies
in [16]. We also compute the control overhead of our protocol
and show that it is reasonable for use in sensor networks.
Figs. 10(a) and 10(d) show ensemble average results taken
over 200 simulations with N = 50 nodes, and α = 1.5,
while Figs. 10(b) and 10(c) display particular realizations.
For Figs. 10(a) and 10(d), an average over 200 simulations is
sufﬁcient since both the oscillations of the price in Fig. 10(a),
32
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-231-8
ICSNC 2012 : The Seventh International Conference on Systems and Networks Communications

and the monotonic decrease of the price of the winning path
in Fig. 10(d) display their clear trends.
Fig. 10(a) shows the price of the currently winning path w∗
as a function of the number of iterations, when the distributed
protocol of Section III is used. We see three successive peaks,
which correspond to price-adjusting cycles. The ﬁrst peak
corresponds to the price increase in the ﬁrst iteration. Because
the price of all the nodes are initially free to change, this
peak corresponds to every node’s incrementing its price, and
consequently is the largest. Each successive peak is lower,
because as more nodes lock their prices, there are fewer nodes
raising their prices. In addition, some of the networks we
average converge within 1 or 2 price-adjusting cycles, thereby
reducing the average height of the latter peaks. It takes 18
iterations for the average price to converge. The difference
between the ﬁnal sum price and the initial path cost is the
ensemble average of the sum of the surplus of all relay nodes.
We calculate the control overhead of our protocol as fol-
lows: Let np denote the number of price iterations until
convergence. Per iteration, each relay transfers 1 SPA and
1 DPA packet. Let N denote the number of nodes in the
network. Then, ⌈log2(N)⌉ bits are needed to encode the node
IDs. The maximum possible number of hops in the network
is N −1. Let bp denote the number of bits of quantization for
the price, in ﬁxed-point representation. Then, in the ﬁelds of
an SPA (or DPA) packet, it takes ⌈log2(np)⌉ bits to encode
the number of iterations so far, ⌈log2(N)⌉ bits times ⌈N − 1⌉
hops to encode the path of node IDs, the same number of
bits to encode the winning path, bp bits times N − 1 hops
to encode the prices on the winning path, and bp bits times
N − 1 to encode the prices on the lowest cost path. This
worst-case control overhead analysis thus shows that a total
of ⌈log2(np)⌉ + 2(N − 1)⌈log2(N)⌉ + 2bpN bits per SPA (or
DPA) packet. Hence, per iteration, each relay node transfers a
control overhead of twice this amount (1 SPA and 1 DPA), that
is, a total of 2(⌈log2(np)⌉+2(N−1)⌈log2(N)⌉+2bpN) bits of
control overhead until convergence to the equilibrium prices.
Hence, the control overhead grows as O(N log∈(N)) for
large-scale sensor network deployments. However, assuming
midsize deployments, the exact numbers might be more im-
portant than asymptotic growth. For example, for a network of
100 sensor nodes, and with bp = 8 bits, and np = 10 iterations,
the control overhead is 5980 bits. Let f be the fraction of the
tolerable control overhead compared with sensor network data.
Then, if f = 0.01, then 598 kbits of sensor data need to be
accumulated for the control overhead to be justiﬁed.
Fig. 10(b) shows the effects of large-scale fading on suc-
cessive price competition rounds when the distributed protocol
is used. We have used a log-normal distribution to model
fading on the links between the relay nodes. (Since the
sensor nodes are stationary in many settings, the source of
the lognormal shadowing variations that we model are due to
the variations of the obstacles in between, e.g., in an urban
setting. When sensor nodes are placed over such a terrain, the
channel between the nodes is rarely static, but rather show
signiﬁcant variations due to the variations in the urban clutter
5
10
15
20
25
30
0
20
40
60
80
100
120
Average Sum Price, 200 Networks, 50 Nodes, α=1.50
Iteration
Price
 
 
Sum Price
Path Cost
(a) Convergence of the distributed
protocol.
10
20
30
40
50
0
20
40
60
80
Price Competition Rounds Over Time, N=50
Time
Price
 
 
σ2=1
(b) Convergence of sum price over
time under fading.
0
200
400
600
800
1000
0
10
20
30
40
Total Price of Winning Path Over Time, N=50
Time
Price
 
 
σ2=1
(c) Equilibrium prices over time under
fading.
0
2
4
6
8
0
10
20
30
Winning Path Sum Price, N=50
σ2
Price
 
 
α=1.5
(d) Trend in total winning-path price
with fading parameter σ.
Fig. 10.
Simulation results for the distributed protocol.
in between.) Speciﬁcally, the link costs are recomputed each
round as cij = d4
ij×10(Lij/10), where Lij ∼ N(0, σ2), and are
independent for each link ij, and at each round. It is assumed
that the coherence time is longer than the convergence time;
that is, the link costs are ﬁxed within each competition round.
We see that for the same network, varying link costs can
have an impact on both the equilibrium price, and the rate
of convergence. In the second competition round, three price-
adjusting cycles are needed to reach a Nash equilibrium,
whereas only two are needed in the ﬁrst and third. (Note that
in our control overhead calculation, we allowed for up to 10
iterations, and the simulations show that this maximum still
holds under fading. Hence, the control overhead calculation
is still valid.) Fig. 10(c) shows the variation of equilibrium
prices under fading.
In Fig. 10(d), we see that large-scale fading reduces the total
price of the winning path. As the variance of the Lij increases,
the winning-path sum price decreases. Because large-scale
fading reduces the costs of some of the links in the network,
the protocol is able to take advantage of this and ﬁnd new
lower-cost paths as σ increases.
V. CONCLUSION AND FUTURE WORK
We have presented a distributed protocol for wireless sensor
networks, based on multiple-leader Stackelberg games. These
games allow the relay nodes, each of which acts as a Stack-
elberg leader, to incorporate the utility function of the source
into their utilities. We have designed a distributed protocol to
arrive at a Nash equilibrium of the game. We have also shown
the convergence of the protocol to the Nash equilibrium as a
function of time, and quantiﬁed its control overhead. In our
future work, we aim to generalize this model to a network
33
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-231-8
ICSNC 2012 : The Seventh International Conference on Systems and Networks Communications

with multiple source and multiple destinations.
REFERENCES
[1] V. Rodoplu and T. Meng, “Minimum energy mobile wireless networks,”
IEEE J. Select. Areas Commun., vol. 17, no. 8, pp. 1333 – 1344, Aug.
1999.
[2] ——, “Bits-per-joule capacity of energy-limited wireless networks,”
IEEE Transactions on Wireless Communications, vol. 6, no. 3, pp. 857–
865, 2007.
[3] C. Intanagonwiwat, R. Govindan, D. Estrin, J. Heidemann, and F. Silva,
“Directed diffusion for wireless sensor networking,” IEEE/ACM Trans.
Netw., vol. 11, no. 1, pp. 2–16, 2003.
[4] N. Sadagopan, M. Singh, and B. Krishnamachari, “Decentralized utility-
based sensor network design,” Mobile Networks and Applications,
vol. 11, pp. 341–350, 2006.
[5] P. Nurmi, “Modeling energy constrained routing in selﬁsh ad hoc
networks,” in Proceeding from the 2006 workshop on Game theory for
communications and networks, ser. GameNets ’06.
ACM, 2006.
[6] H. Liu and B. Krishnamachari, “A price-based reliable routing game
in wireless networks,” in GameNets ’06: Proceeding from the 2006
workshop on Game theory for communications and networks.
ACM,
2006, p. 7.
[7] S. Sengupta, M. Chatterjee, and K. Kwiat, “A Game theoretic framework
for power control in wireless sensor networks,” IEEE Transactions on
Computers, vol. 59, no. 2, pp. 231–242, 2010.
[8] E. Campos-Nanez, A. Garcia, and C. Li, “A Game-theoretic approach to
efﬁcient power management in sensor networks,” Operations Research-
Baltimore, vol. 56, no. 3, pp. 552–561, 2008.
[9] R. Kannan and S. Iyengar, “Game-theoretic models for reliable path-
Length and energy-constrained routing with data aggregation in wireless
sensor networks,” IEEE Journal on Selected Areas in Communications,
vol. 22, no. 6, pp. 1141–1150, 2004.
[10] M. Felegyhazi, J. Hubaux, and L. Buttyan, “Cooperative packet for-
warding in multi-domain sensor networks,” in Third IEEE International
Conference on Pervasive Computing and Communications Workshops,
2005. PerCom 2005 Workshops, 2005, pp. 345–349.
[11] Y. Korilis, A. Lazar, and A. Orda, “Achieving network optima using
Stackelberg routing strategies,” IEEE/ACM Transactions on Networking
(TON), vol. 5, no. 1, pp. 161–173, 1997.
[12] T. Bas¸ar and R. Srikant, “A Stackelberg network game with a large
number of followers,” Journal of Optimization Theory and Applications,
vol. 115, no. 3, pp. 479–490, 2002.
[13] H. Shen and T. Bas¸ar, “Differentiated Internet pricing using a hierarchi-
cal network game model,” Proceedings of the 2004 American Control
Conference, vol. 3, pp. 2322–2327 vol.3, July 2004.
[14] S. Shakkottai and R. Srikant, “Economics of network pricing with
multiple ISPs,” IEEE/ACM Trans. Netw., vol. 14, no. 6, pp. 1233–1245,
2006.
[15] M. Bloem, T. Alpcan, and T. Bas¸ar, “A Stackelberg game for power
control and channel allocation in cognitive radio networks,” in Proc.
IEEE ICST, 2007, pp. 1–9.
[16] V. Rodoplu and G. Raj, “Computation of a nash equilibrium of multiple-
leader stackelberg network games,” in 2010 Fifth International Con-
ference on Systems and Networks Communications, ICSNC 2010, pp.
232–237.
[17] “MICAz OEM edition data sheet,” Crossbow, San Jose, CA, USA.
[18] V. Rodoplu and T. Meng, “Core capacity region of energy-limited, delay-
tolerant wireless networks,” IEEE Transactions on Wireless Communi-
cations, vol. 6, no. 5, pp. 1844–1853, 2007.
34
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-231-8
ICSNC 2012 : The Seventh International Conference on Systems and Networks Communications

