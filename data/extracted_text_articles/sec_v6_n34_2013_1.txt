88
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Firewall Analysis by Symbolic Simulation:
Advanced Optimizations
Arno Wagner
Consecom AG
Zurich, Switzerland
arno@wagner.name
Abstract—There are two primary tasks when doing a
Layer 4 ﬁrewall security analysis. First, unifying a chain
of ﬁrewalls on a given network path into a single one to
eﬃciently determine what it allows to pass and what it
drops, and second, comparing a ﬁrewall with a security
policy. Both tasks are work-intensive and error-prone
if performed manually and become infeasible in the
presence of large ﬁrewall rule sets. To automate the
process of unifying a chain of ﬁrewalls, we have created
the Consecom Network Analyzer that uses symbolic
simulation with an interval representation to generate
a uniﬁed equivalent ﬁrewall in a normalized, simple and
ﬂat form. The uniﬁcation process is also suitable to im-
plement comparison with a policy, by representing the
policy in a special way in the form of a ﬁrewall rule set.
We show the suitability of this approach for ﬁrewalls
with large conﬁgurations by giving benchmarks based
on deployed rule sets. In addition, we demonstrate
the eﬀects of diﬀerent optimization techniques on run-
time and memory footprint, including the use of an
advanced optimization technique that builds on ideas
from geometrical search to reduce unnecessary rule
applications by means of interval search trees. The Con-
secom Network Analyzer has been used successfully for
a number of industrial security reviews.
Keywords-Network Security; Firewall Analysis; Sym-
bolic Simulation; Interval Search Trees.
I. Introduction
This work describes the Consecom Network Analyzer
(CNA), which is the result of a collaboration between
academia and industry. It is an invited extension of results
previously published in [1]. The main improvement is the
use of Interval Search Trees as additional optimization
technique, as described in Section VII.
The CNA is a tool-set that greatly reduces the eﬀort,
and thereby cost, for practical ﬁrewall security analysis in
the presence of ﬁrewalls with large rule sets. A ﬁrewall
security analysis is one type of network security review.
It is often done on network Layer 4, for example for TCP
and UDP traﬃc. Figure 1 shows the basic scenario. The
typical steps to be done include:
1) Normalize ﬁrewall conﬁgurations
2) Identify critical network paths
3) Identify ﬁrewalls along each critical path
4) Determine network reachability on each critical path
5) Compare reachability and security requirements
6) Identify non-compliant ﬁrewall rules
The primary motivation for creating the CNA lies in
steps 4, 5 and 6. In step 4, the CNA calculates the
reachability in a uniﬁed simple format. Each element of
the combined reachability is annotated with the ﬁrewall
rules that give raise to it. If a formalized or easy to
formalize security policy is available, it can be compared
automatically to the actual network reachability using the
CNA. As such a security policy is often not available in
practice, step 5 may still need to be done manually or can
be only partially automatized.
S
D
. . .
FW 1
FW n
Fig. 1.
Unidirectional reachability along a critical network path.
Figure 2 shows the typical data ﬂow for a ﬁrewall
analysis task. The Rule-Set Converter is not part of the
core CNA system and has to be adapted for each diﬀerent
ﬁrewall description format. The CNA uses a normalized
symbolic Layer 4 format internally that is based on in-
tervals. As core contribution of this paper, we show this
representation is suitable for calculating reachability even
in the presence of large ﬁrewall conﬁgurations. To this end,
we present benchmark calculations on deployed rule-sets.
The CNA has been used successfully in several industrial
ﬁrewall security reviews.
raw
Converter
Calculation
Reachability
rule sets
Policy
Comparator
Reachability
Policy
violations
rule
sets
Network
FW
formalized Policy
normalized
Rule−Set
Fig. 2.
Typical analysis data-ﬂow with the CNA.
The rest of the paper is organized as follows: Section
II introduces our network and ﬁrewall model, and the

89
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
symbolic representation used. Section III gives the opera-
tions used for single ﬁrewalls. Section IV explains how to
calculate unidirectional reachability. A complexity analysis
is sketched brieﬂy in Section V. Section VI describes
the implementation, while Section VI states benchmark
results and the eﬀects of diﬀerent optimization techniques.
Section VII explains how interval search trees can be
used to speed up the CNA core loop and justiﬁes their
eﬀectiveness with a separate set of benchmarks. Section
VIII explains how to extend the approach to two-sided
reachability and to automated comparison with a policy.
The paper ﬁnishes with a discussion of related work in
Section X and a conclusion in Section XI.
II. Approach
The reachability calculation process starts with a repre-
sentation of the initial reachability (disregarding ﬁrewalls),
which will often be unconstrained. This initial reachability
is then successively reduced by applying ﬁrewall rules. The
end-result is a ﬂat, uniﬁed representation of the ﬁrewall-
chain, restricted by the initial reachability.
A. Network Model
We are primarily interested in network reachability as
restricted by ﬁrewalls. Given a source network S, sequence
of ﬁrewalls FW1, . . . , FWn and a destination network
D (see also Figure 1), we say that D is reachable from
S if there are network packets that can traverse FW1,
. . ., FWn without being dropped by any FWi. Note that
some attacks will need two-sided reachability. For example
services used over TCP can usually only be attacked if
response packets can traverse the ﬁrewall sequence in
reverse order. See Section VIII-A for a discussion on how
to check for two-sided reachability.
We restrict the packet information visible to ﬁrewalls to
IP addresses and ports, which results in a Layer 4 model.
Each protocol is treated separately, although it is possible
to mix protocols, for example by doing a forward analysis
with TCP and a backward analysis with ICMP in order
to determine whether an ICMP response to a TCP packet
would get through. This situation arises, for example,
when determining whether a ﬁrewall conﬁguration allows
port scanning. Routing is out of scope for this work, as we
do not see it as a security mechanism; see Section IV-A
for a brief discussion.
B. Subspaces, Boxes and Intervals
Reachability is represented by subspaces of
M = {src IPs} × {src ports} × {dst IPs} × {dst ports}
with the four ﬁelds representing the corresponding IP
v4 layer 4 header address ﬁelds for TCP and UDP, and
the port ﬁelds being misused to represent ICMP Type
and Code for ICMP. Other layer 4 protocols that ﬁt this
scheme can also be represented.
We organize these subspaces into sets of axis-aligned
hyperrectangles in M, also called axis aligned boxes [2],
[3]. In this paper, boxes will always be axis-aligned, hence
we will simply call them boxes for short.
Note that any non-empty subspace of M that has an
interval for each of its 4 components trivially is a box. At
the same time, any subspace of M can be represented as
the union of a set of boxes. A subspace A of M can hence
be represented by
A
⊆
M and
A
=
{b1, . . . , bn} with bi ∈ M and bi is a box.
The matching expressions of a ﬁrewall rule can be
represented by a single box. Security policies can also be
represented this way, by giving a set of boxes that speciﬁes
forbidden reachability. If the intersection between network
reachability and a policy represented this way is non-
empty, then the policy is violated. In the implementation,
boxes can have attached information. In particular, trace
information can be attached in order to document which
ﬁrewall rules were applied to a box. Trace information
is critical to determine why a speciﬁc box is in the ﬁnal
reachability or why it was dropped.
A box can be represented as a 4-tuple of intervals, which
allows symbolic computations. As far as we know, Eronen
and Zitting [4] were the ﬁrst to use intervals in this context.
Box example:
b = (10.0.0.0 − 10.0.0.255, 1024 − 65535, 10.1.1.1, 80)
We use intervals with wrap-around, where IP and port
number spaces are regarded as circles. This facilitates
representing complements and reduces the number of el-
ements in the complement of a box, see below. Figures
3 and 4 gives graphical examples of three boxes in two
dimensions represented this way. Some textual examples
for intervals with wrap-around are:
• Port interval [81, 80) represents all ports except port
80, i.e., port 81-65535 and port 0-79. Without wrap-
around this complemented interval would need to be
represented as [0, 80) and [81, 65535)
• IP interval [127.0.0.256, 127.0.0.0) represents all IP
addresses except 127.0.0.0 − 127.0.0.255.
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
A
B
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
C
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
Fig. 3.
Boxes in two dimensions.

90
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
D
D
E
E
F
F
F
F
Fig. 4.
Boxes with wrap-around in two dimensions.
C. Firewall Model
The CNA uses a simple ﬁrewall model, where each
ﬁrewall consists of a linear sequence of rules r that each
have a box describing their applicability and one of the
target actions accept or drop, with a default drop at the
end of sequence. This corresponds to the “simple” model
used in [5].
D. Rule Application and Set Operations
In order to apply a ﬁrewall rule r = (b, <action>) to
a subspace A = {b1, . . . , bn} ⊆ M, we intersect b with
the diﬀerent bi in turn and apply the action to the result
A ∩ {b} = {b ∩ b1, . . . , b ∩ bn}.
The usual set operations are deﬁned on boxes and, by
extension, on subspaces of M. Some deserve additional
comments.
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
Fig. 5.
Box intersections in two dimensions.
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
4
7
0 1 2 3
5 6
1
2
3
4
5
6
7
0
x2
x1
4
7
0 1
3
5 6
1
2
3
4
5
6
7
0
x2
x1
2
Fig. 6.
Box intersection in two dimensions with wrap-around.
Intersection: Intersecting two boxes in d dimensions can
have up to 2d result boxes. Figures 5 and 6 illustrates this
in two dimensions. For b1, b2 ∈ M, the intersection b1 ∩ b2
may consist of up to 16 boxes as M has 4 dimensions.
Box complement: The complement of an interval is
derived by adjusting the boundaries. The complement of
a box is derived by complementing each interval in turn
and setting all other intervals to full range. Hence, a 4-
dimensional box has up to four boxes as its complement.
Without wrap-around, the complement of a box could have
up to 8 elements.
Subtraction: Calculating a − b for boxes a and b is done
by using the relation a − b = a ∩ ¯b from set calculus.
III. Restricting Reachability by a Single
Firewall
The core operations used in determining reachability
through a single ﬁrewall are apply_firewall() and ap-
ply_rule(), shown in Figure 7 in simpliﬁed form. The
task of apply_firewall() is to take a given reachability
description, stated as a set of boxes, called here a Work
Set (WS) and, using the rules of the ﬁrewall, determine
both an Accept Set (AS), which is the part of the WS
that can pass the ﬁrewall, and a Drop Set (DS) that is
the part of the WS that cannot pass the ﬁrewall. AS
and DS are represented as sets of boxes. The function
apply_rule() forms the basis of apply_firewall() and
implements calculation of the intersection I between a
given rule and WS. The intersection I is then added to
the AS for an accept rule or to the DS for a drop rule.
apply_firewall(WS, FW):
AS := ∅
/* Accept Set */
DS := ∅
/* Drop Set
*/
for r ∈ in FW:
/* r: box of a rule */
I := apply_rule(WS, r)
WS := WS - I
/* reduce Work Set
*/
if r is accept:
AS := AS ∪ I
if r is drop:
DS := DS ∪ I
return(AS, DS)
apply_rule(WS, r):
I := ∅
for b ∈ WS:
/* b is a box */
i := b ∩ r
I := I ∪ i
return(I)
Fig. 7.
Pseudo-code for apply_firewall() and apply_rule() (sim-
pliﬁed).
Building on these two operations, more complex oper-
ations can be constructed. Note that apply_rule() may
attach trace information to boxes, for example to docu-
ment rule application. If desired, the full history of each
box can be recorded in the trace. This allows to determine
the speciﬁc ﬁrewall rules that are responsible for a box
being in the ﬁnal reachability and represents information
needed in any report about ﬁrewall conﬁguration issues.
IV. Unidirectional Reachability Computation
Pseudo-code for the calculation of unidirection reach-
ability through a sequence of ﬁrewalls is given in Figure
8.

91
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
We will typically choose the initial reachability as un-
restricted. This is a sound practice, as network routing
can usually not be regarded as a security feature and
quite a few customers cannot specify source network S
and destination network D with the required exactness.
Starting with full, unconstrained reachability will ensure
the ﬁnal results only rely on the given ﬁrewall conﬁgu-
rations. A more restricted initial reachability can still be
used when appropriate. Ports are unconstrained in the
initial reachability.
A. Comments on Routing
A frequent issue that crops up when doing a ﬁrewall
security analysis in the ﬁeld is that often routing is mixed
with ﬁrewalling. This view gives ﬂawed results. There are
several reasons:
• The primary task of routing is to get packets to a
speciﬁc destination, while the primary task of a ﬁre-
wall is to prevent packets reaching a speciﬁc destina-
tion. Routing conﬁguration and ﬁrewall conﬁguration
hence have diametrically opposed primary tasks and
this is reﬂected in procedures and mind-sets.
• Due to the diﬀerent primary tasks, often the teams
responsible for routing and for ﬁrewalls are diﬀerent.
• While ﬁrewall conﬁgurations are handled securely and
all updates are done with the security model in mind,
routing conﬁgurations are typically changed with the
network model in mind and handled in a less secure
fashion. Routing is hence easier to compromise.
• Sometimes customers cannot even specify the IP
ranges of S and D precisely, but have precise ﬁrewall
information. This may sound surprising, but if routing
delivers more to a physical target network than ex-
pected, this is not necessarily a problem. For ﬁrewalls,
it is a critical error.
• Routing works on Layer 3, while ﬁrewalls work on
Layer 4. Mixing the two complicates things and in-
creases maintenance eﬀort.
• Firewall conﬁgurations often do not include informa-
tion about physical or virtual interfaces, but solely
refer to layer 4 information. If routing were regarded
as a security feature, interface information would be
needed in addition and would be critical for security.
This would also complicate ﬁrewall conﬁguration and
make network security critically dependent on the
details of physical or virtual network cabling.
Overall, it is far more practical to separate routing and
ﬁrewalls and to require that all restrictions on reachability
must be implemented by ﬁrewalls placed into the critical
network paths. This is especially true for customers with
complex ﬁrewall conﬁgurations.
It should be noted that with this approach, the ques-
tion arises whether a speciﬁc ﬁrewall actually is on the
critical network paths it is supposed to be on. Answering
S
D
. . .
FW 1
FW n
in:
S, D
/* Source, Destination networks */
FW1, ..., FWn
/* firewalls
*/
out: ASn
/* final reachability */
DS1,. . .,DSn
/* Drop Sets
*/
WS1 := S × <all> × D × <all>
(AS1, DS1) := apply_firewall(WS1, FW1)
WS2 := AS1
(AS2, DS2) := apply_firewall(WS2, FW2)
WS3 := AS2
...
(ASn, DSn) := apply_firewall(FWn − 1, WSn − 1)
Fig. 8.
Pseudo-code for calculating unidirectional reachability with
apply_firewall() for the scenario shown in Figure 1.
this question requires a network topology analysis and is
outside of the scope of this work.
It should also be noted that network scanning always
takes routing into account and is restricted by it. This is
a fundamental limitation of network scanning that is not
present in ﬁrewall simulation approaches.
V. Algorithmic Complexity
We brieﬂy sketch the complexity analysis idea. For
a worst-case scenario, start with one box and a single
ﬁrewall with n drop rules. Each drop rule can split (asymp-
totically) at most one element of the Work Set into a
maximum of 2d (with dimension d = 4) non-overlapping
parts that are kept in the working set. Hence, each rule
increases the size of the working set by a maximum of
16, giving an overall space complexity of the result of
16 ∗ n ∈ O(n) for n ﬁrewall rules. As each successive rule
application has to work on 16 more boxes, time complexity
is 1 ∗ 16 + 2 ∗ 16 + . . . + n ∗ 16 = 16 ∗ (1 + 2 + . . . + n) =
16
2 n(n − 1) ∈ O(n2). A very similar argument applies to
accept rules and mixed rule-sets.
In comparison, in [6], the authors need worst case eﬀort
O(n4) to build a Firewall Decision Diagram (FDD) for n
ﬁrewall rules with the same ﬁrewall model as we use. It
is reasonable to expect that this worst-case is extremely
unlikely to happen in practice.
In [5], the authors claim a worst case complexity of
O(n) for processing a ﬁrewall with n rules in their “simple
model”. However, they wrongly assume constant eﬀort for
set operations on their accept (A) and drop (D) sets.
While the BDDs used in [5] are often very eﬃcient in
practice, they do not have constant worst case eﬀort for set

92
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
TABLE I
Benchmarks
No
Firewall or
rule-set size
benchmark results
Firewall
raw
nor-
opt.
Python
input opt.
trace
core-loop
sequence
malized
baseline
reduction
ported to C
1
S
27
2’000
180
4:52min
12MB
3.9s
6MB
3.2s
6MB
0.07s
6MB
2
M
67
23’000
8300
1752 min
184MB
346min
84MB
148min
48MB
29s
18MB
3
L
170
27’000
3100
2392min
292MB
21:54min
26MB
12:45min
18MB
2.8s
10MB
4
S, M
64min
34MB
191s
14MB
156s
13MB
1.8s
13MB
5
M, S
1870min
186MB
347min
84MB
146min
48MB
29s
19MB
6
M, L
5000min
187MB
660min
77MB
250min
56MB
38s
21MB
7
S, M, L
205min
58MB
370s
16MB
305s
16MB
4s
16MB
operations and the stated complexity analysis is therefore
incorrect.
VI. Implementation, Optimization and
Benchmarks
The CNA is implemented in Python 3 [7] with C
extensions. This allows a clean and ﬂexible OO design
and facilitates targeted optimization. IP addresses and
port numbers are represented directly by Python integers.
Boxes are represented as Python 8-tuples (representing
4 intervals) and encapsulated into class objects in order
to allow attachment of traces, annotations and ﬁrewall
rule actions. Subspaces are represented as Python lists.
The pure-Python prototype is relatively slow and has high
memory consumption, but can already be used for security
reviews involving ﬁrewalls with small and medium-sized
rule-sets.
First, note that in the absence of Network Address
Translation (NAT), which is rarely deployed in security
critical networks, ﬁrewalls can be arbitrarily reordered, as
exactly those packets that make it through all of them are
part of the ﬁnal reachability space. In particular, a good
selection of the ﬁrst ﬁrewall to be processed can have sig-
niﬁcant performance beneﬁts. Benchmarks must therefore
always be seen together not only with the relevant ﬁrewall
conﬁgurations, but also their processing order.
A. Benchmarks
In order to determine performance and to examine the
performance impact of diﬀerent optimizations, we give
a selection of benchmark results1 in Table I. Times are
CPU times including input data parsing and result output.
Memory sizes are the whole process memory footprint,
excluding shared areas (libraries). The calculations were
done using Linux (Debian Squeeze 32bit) on an AMD
Phenom II X4 970 CPU with 3.5GHz, using only one CPU
at a time. Memory was set to the 4GB memory model
1While in theory there is no diﬀerence between theory and practice,
in practice there is and benchmark results are very much subject
to this limitation. Hence the stated benchmark results only give a
rough idea about runtime, memory footprint and eﬀects of diﬀerent
optimizations.
and the machine was running kernel 3.4.7 from kernel.org
without any special optimizations. Python version used
was 3.1.
Lines 1, 2, 3 of Table I describe the ﬁrewall conﬁgura-
tions used. These are ﬁrewall conﬁgurations deployed in
the real world. They have a ﬂat form (no sub-chains) and
a default-drop policy.
Line 4 and following lines of Table I give benchmarks for
diﬀerent ﬁrewall combinations. The order of the ﬁrewalls is
important as the ﬁrst one has to be completely represented
in memory, which causes eﬀort O(|FW1|2) (where |FWk|
is the number of rules in ﬁrewall FWk). The eﬀort for each
additional ﬁrewall in the chain is O((|WSi|+|FWi|)·|FWi|)
and hence higher in the worst case. But when starting
with a ﬁrewall with small rule-set, we observed that a later
combination with a ﬁrewall with a large rule-set does often
not increase the WS size signiﬁcantly, as most rules of the
larger ﬁrewall do not apply. For that case, the complexity
goes eﬀectively down to O(|WSi| · |FWi|), which is a lot
smaller than O(|FWi|2) if |FWi| is large but |WSi| is small.
If the ﬁrewall processed ﬁrst has a much larger rule-set
than the others, we have observed that processing it will
often dominate the runtime.
The columns “rule-set size” give the number of rules in
the raw input in vendor format (including groupings, lists,
etc.), the normalized number of rules without optimization
and the optimized rule-set size. Benchmarks are given only
for TCP for brevity, UDP and ICMP analysis have compa-
rable results. We do not have benchmarks for comparison
against a policy, as we do not have a suﬃciently formalized
policy and hence looking directly at reachability was more
eﬃcient. Comparison with a policy would incur eﬀort
comparable to adding one more ﬁrewall conﬁguration in
the size of the negated policy speciﬁcation. The idea is that
nothing must be able to pass through the given ﬁrewall
chain and an additional ﬁrewall representing the negated
policy, with the negated policy representing all forbidden
traﬃc.
As can be seen in Table I, each evaluated optimization
step has signiﬁcant impact on observed run-time. The ﬁnal
implementation with all optimizations included has very
reasonable performance even in the presence of ﬁrewalls

93
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
with large rule-sets.
B. Firewall Evaluation Sequence Optimization
The benchmarks demonstrate that the selection of the
ﬁrst ﬁrewall to be processed has a huge impact on perfor-
mance. For the ﬁrst ﬁrewall, the Work Set can grow for
each rule application as it has to be completely represented
in memory, while for later ﬁrewalls only rules that have
a non-empty intersection with the Work Set can increase
Work Set size by splitting elements already contained in
it.
If the ﬁrst ﬁrewall contains a large number of rules
that allow traﬃc through that is later dropped by the
other ﬁrewalls, then all these irrelevant rules will cause
signiﬁcant load on the memory allocator that can be
avoided with a diﬀerent selection for the ﬁrst ﬁrewall to be
processed. Our experiences show that the most restrictive
ﬁrewall conﬁguration should be processed ﬁrst. In many
scenarios, this will be the smallest ﬁrewall conﬁguration,
measured in number of rules.
C. Rule-Set Representation Optimization
Firewall conﬁgurations in a vendor-format often allow
more complex speciﬁcations, such as lists or groupings
of multiple sources, destinations or services. Decomposing
such input rules into rules using a single box each can
results in a number of normalized rules that is a lot
higher than needed. The reason is that many resulting
rules will be overlapping or adjacent in such a way that
they can be combined. The column “opt.” under “rule-
set size” in Table I states the reduced number of rules
after optimization and the column “input opt.” gives the
improved run times and memory footprints. The runtime
for the input optimization itself is small, as it only works
with a focus of one raw input rule at a time.
Note that global box combination would be possible,
but combining boxes from diﬀerent raw rules has two
problems: First, if both accept and drop rules are present,
the combination algorithm has to take rule sequence into
account. And second, in this approach a box cannot be
labeled with the single raw ﬁrewall rule it originated from.
This makes the identiﬁcation of policy-violating rules in
the end-result diﬃcult.
D. Trace Reduction
While the original prototype retained traces for all
operations that changed a box, it turns out these full traces
are only beneﬁcial for debugging. In a security analysis,
only accept and drop actions are relevant and hence it
is enough to add trace information to a box when it is
added to the Accept Set or Drop Set. It is not necessary
to trace when boxes are reduced or split in the Work Set.
Hence, traces were reduced accordingly. This also means
that there can be at most one trace entry per ﬁrewall
in each box contained in the result. The column “trace
reduction” in Table I states the additional performance
gains. Note that trace reduction was benchmarked with
input optimization applied as well.
E. Core-Loop Ported to C
In a last step, the core loop function apply_rule()
was ported to C and embedded into the Python code.
Contrary to Figure 7, WS, AS and DS are passed to
apply_rule() and are manipulated in-place according to
the rule action. This puts expensive operations, such as
data-structure manipulations, into the C code. No other
special optimizations were done for the C code and in
particular the standard GNU libc memory allocator was
used. The column “core-loop ported to C” in Table I states
ﬁnal performance ﬁgures. Note that trace reduction and
rule-set representation optimization was applied as well.
In addition, we performed a benchmark calculation for
deployed ﬁrewall conﬁguration “XL”. It has a normalized
rule-set size of 2.8 million rules, which reduces to 300’000
rules after input optimization. Raw rule number is 95.
Representing conﬁguration XL in memory took 20h of
CPU time and resulted in a memory footprint of 900MB.
This shows that ﬁrewall conﬁgurations of this size can still
be processed with the CNA with reasonable eﬀort.
The C code can keep box description eﬃciently in
structs and does not need any wrapping and unwrapping of
tuple elements and can therefore speed up execution mas-
sively, while at the same time reducing memory footprint
signiﬁcantly. However, the unit tests written in Python can
still be applied by exposing the interval and box operations
implemented in C to Python via the class interface. This
helped signiﬁcantly in the optimization eﬀort.
VII. Advanced Optimization
The algorithm described so far compares each working
set element against each rule. This leads to eﬀort linear in
the size of the Work Set and linear in the size of the rule
set. This is problematic for large inputs. At the same time,
for typical ﬁrewall rule sets, most elements of any given
Work Set do not intersect most rules and hence a large
part of the eﬀort is wasted. If it were possible determine
a subset of the Work Set that has a higher likelihood of
intersecting a given rule r eﬃciently, a signiﬁcant speed-up
could be obtained. One such possibility is represented by
interval search trees.
A. Interval Search Trees
Diﬀerent types of interval search trees are known. They
include trees that support searching with a point, where
the result consists of all intervals in a given set that
include the point, and searching with an interval, where
the result includes all intervals that intersect the given
search interval. We need the second variant.

94
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
TABLE II
Benchmarks: Work Set as Array vs. Work Set as interval search tree
No
Firewall or Firewall sequence
rule-set size(s) (opt.)
array
interval search tree
1
A
100
0.06s, 8.5MB
0.06s, 8.5MB
2
B
7.5k
4.8s, 27MB
1.2s, 28MB
3
C
1.3M
163h, 15GB
96min, 15GB
4
A,B
100, 7.5k
1s, 22MB
1s, 22MB
5
B,C
7.5k, 1.3M
16:05min, 2.6GB
2:47min, 2.6GB
6
A,B,C
100, 7.5k, 1.3M
2:49min, 2.6GB
2:45min, 2.6GB
As we want to represent the Work Set in an interval
search tree, we also need eﬃcient insertion and deletion of
intervals from an already constructed tree. Unfortunately,
many interval search tree variant do not support these
operations eﬃciently and to the best or our knowledge,
no multi-dimensional interval search tree variant can sup-
port insertion, deletion and searching with an interval,
eﬃciently.
Due to these restrictions, we selected the interval trees
from [8], Section 14.3. These are one-dimensional interval
search trees constructed from balanced trees and support
all operations we need eﬃciently. In [8], they are con-
structed on top of red-black trees as they are claimed
to be simpler to implement than alternatives. As an
implementation using AVL trees generally gives a smaller
tree-height, we adapted the idea from [8] to AVL trees and
used them as basis for our implementation.
The complexity of performing an interval search on an
interval search tree with n elements is O(k · log(n)), with
k the number of results. For large k, the overall eﬀort is
bound by n, as each tree element is at most inspected once.
For example, when the search result includes the full set of
tree elements, the eﬀort is only O(n) and not O(n·log(n)).
As one-dimensional interval search trees can only handle
one component of the 4 diﬀerent dimensions represented
in a box, the idea is to use the most selective dimension
of the set of multi-dimensional sets in the interval search,
and then iterate linearly over the results as before. For
typical large ﬁrewall rule sets, the most selective interval
is the destination IP address interval. It is possible to use a
diﬀerent dimension. It would also be possible to use several
interval search trees for the diﬀerent dimensions, and
then, for a given rule, perform the interval search in each
dimension and then continue processing with the smallest
result. It should be noted that using one-dimensional
interval trees does not decrease the theoretical worst-case
complexity of the algorithm and hence eﬀectiveness has to
be demonstrated by benchmark calculations.
B. Adjusting the Implementation
The core loop modiﬁed to use an interval search tree
is shown in Figure 9. The WS, AS and DS are now kept
as elements of an interval search tree, diﬀerent from the
linear array that was used before. The key eﬀort reduction
lies in reducing the Work Set size in apply_rule() by per-
forming an interval search on the complete Work Set with
the destination IP interval of the rule r. Only elements
of the WS that intersect this interval in their destination
IP component are added to the WS_reduced and have the
complex box intersection algorithm applied to them.
apply_firewall(WS, FW):
AS := ∅
/* Accept Set */
DS := ∅
/* Drop Set
*/
for r ∈ in FW:
/* r: box of a rule */
I := apply_rule(WS, r)
WS := WS - I
/* reduce Work Set
*/
if r is accept:
AS := AS ∪ I
if r is drop:
DS := DS ∪ I
return(AS, DS)
apply_rule(WS, r):
I := ∅
WS_reduced := interval_search(WS, r)
for b ∈ WS_reduced:
/* b is a box */
i := b ∩ r
I := I ∪ i
return(I)
Fig. 9.
Pseudo code from Figure 7 modiﬁed for interval search trees
C. Rules in an Interval Search Tree
An alternative to putting the Work Set elements into
an interval search tree is putting the rules into one. The
core loop in apply_rule() of Figure 9 would then have to
be changed to select an element of the Work Set and then
apply all rules to it in turn. The set of all rules would ﬁrst
be restricted using the interval search tree to those rules
that intersect, for example, the destination IP interval of
the Work Set element being processed.
At a ﬁrst glance, this looks attractive: the rule-set does
not change and hence tree construction does only happen
once and no additions or deletions are performed on the
tree. Unfortunately, the use of the interval search tree for
the rules changes the application order of the rules. Rule
sets with accept and drop rules can change their semantics
whenever an accept and a drop rule are switched with
regard to application order.

95
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
This means that while it is possible to apply the idea of
using interval search trees for the rule sets, it only works
correctly for rule sets that are all accept or all drop rules,
with a possible ﬁnal drop or accept, respectively. While
many rule sets observed in practice have this form, some
of the largest ones we have encountered do not and hence
we are unwilling to accept this limitation.
A second, less problematic, limitation is that if rule
application order is changed, it becomes more diﬃcult
to determine which rule actually accepted or dropped
a speciﬁc packet. This ambiguity arises when a speciﬁc
packet could have been accepted (dropped) by a rule
R1 or a rule R2, but rule order determines which one
actually does it. This becomes meaningful if it is necessary
to determine which rule exactly processed a packet, for
example if the packet is to be tagged for policy-based
routing or a similar application.
D. Benchmarks for the Interval Search Tree Optimization
As the CNA is subject to on-going optimization, the
experimental setup and base-line have changed. In partic-
ular redundant element copying and ineﬃcient handling of
element traces has been eliminated, resulting in a diﬀerent
baseline than thr one given in Table I. At the same time
an updated benchmark ﬁrewall set was used that is similar
in nature to the older one used for Table I, but changes
all ﬁrewalls to some degree and includes one much larger
ﬁrewall rule set. To prevent accidental confusion of the
benchmark rule sets in the two tables, the ﬁrewalls in Table
II have been named diﬀerently.
The Benchmarks in Table II were performed on an
AMD Phenom II core with 3.4GHz core clock and 32GB
available memory. The benchmarks were compiled and run
in 64 bit mode, using gcc 4.7.2, Python 3.1.3 on Linux
kernel 3.10.11. The characteristics of this setup are very
similar to the one used for Table I, except for the 64 bit
memory model.
The second column of Table II gives the ﬁrewall or
ﬁrewall sequence processed left-to-right. Single ﬁrewalls
are given as the process of representing a single ﬁrewall
in memory is the same as processing it as the ﬁrst element
of a chain. The 3rd column lists the optimized rule-set
sizes, similar to the 5th column of Table I. For a sequence
of ﬁrewalls, the individual sizes are stated. The 4th column
of Table II gives the runtimes and memory footprint with
the classical array-based Work Set representation. These
numbers include the full process including input parsing
and result output. Finally, the last column of Table II lists
execution time and memory footprint with the Work Set
placed into an interval search tree.
E. Discussion
As can be seen, for some benchmarks, the advantage
of using interval search trees is signiﬁcant. In particular
for computations with large reachabilities and hence large
Work Set sizes, a massive speed improvement can be
observed.
For computations with small Work Sets, like the ﬁrewall
sequences ABC or AB, the speed-up is small or non-
existent. The main reason is that storing the Work Set
in an interval search tree is slower than storing it in an
array. At the same time we do not observe any measurable
slow-down due to the use of interval search trees and the
memory footprint remains nearly the same.
The benchmark results support the claim that repre-
senting the Work Set in an interval search tree is supe-
rior, as the overhead created by the tree is compensated
by smaller box intersection eﬀort even in cases where
restrictive ﬁrewalls are processed ﬁrst and small Work
Sets ensue. Tests with a synthetic, tiny ﬁrst ﬁrewall that
generates a Work Set of only 4 elements combined with
ﬁrewalls B and C from Table II conﬁrm that even in this
extreme case, use of interval search trees does not slow
down the computation to any measurable degree. Hence
there is no need to retain the old, array-based Work Set
representation.
As the optimization using interval search tree retains
the full ﬂexibility and expressiveness of the original CNA
implementation, and does not increase memory consump-
tion or CPU load even in the worst cases examined, use of
interval search trees represents a signiﬁcant improvement
in the usefulness of the CNA for the processing and
analysis of large ﬁrewall rule sets.
VIII. Performing Advanced Analysis Tasks
There are two common analysis tasks we have not yet
described in detail. One is checking for presence or absence
of bidirectional reachability. This answers the question
whether a connection can be established through a series
of ﬁrewalls. The second one is checking a chain of ﬁrewalls
for compliance with a formalized policy. While we have
anticipated this task earlier, we now describe how to
perform it.
A. Computing Two-Sided Reachability
Two-sided Reachability allows determining whether an
agent in the source network S can use a service oﬀered
in the destination network D that needs a connection, for
example any service oﬀered over TCP, or a response, as for
example TCP port scanning, where TCP SYN packets are
sent and potentially answered by ICMP packets. It allows
limited comparison with scan results (for example from
nmap [9]), which are sometimes used to verify a ﬁrewall
deployment. Figure 10 gives the idea on how to obtain a
two-sided reachability result.
B. Verifying Policy Compliance
Policies can be represented as an undesired reachability
U, with the meaning that if anything in U ⊆ M is actually
reachable through the ﬁrewalls, then the policy is violated.

96
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
S
D
. . .
FW 1
FW n
1.
2.
3.
swap
src, dst
in: S, D, FW_0, ..., FW_n
out: AS2n (final reachability), DS0,...,DS2n
WS0 := S × <all> × D × <all>
(AS0, DS0) := apply_firewall(FW0, WS0)
WS1 := AS0
...
(ASn, DSn) := apply_firewall(FWn − 1, WSn − 1)
WSn + 1 := swap_src_and_dst(ASn)
(ASn + 1, DSn + 1) :=
apply_firewall(FWn, WSn + 1)
WSn + 2 := ASn + 1
...
(AS2n, DS2n) :=
apply_firewall(FW2n − 1, WS2n − 1)
Fig. 10.
Calculating bidirectional reachability.
A ﬁrewall representing U is constructed by adding
accept rules for all traﬃc components that are undesirable
and a ﬁnal drop rule that drops everything else. In a sense,
this ﬁrewall acts as a ﬁlter that only leaves the undesired
components of the actual reachability through a sequence
of ﬁrewalls.
To test policy compliance, the actual network reacha-
bility A on each critical network path is calculated. Let V
be the policy-violating reachability. Then V = A∩U. If V
is non-empty, all elements of V represent violations. The
non-compliant ﬁrewall rules can be identiﬁed by looking
at the trace information attached to elements of V , which
they inherit from A.
A rarer compliance test is whether desired reachability
is actually present. It can be used to determine which
ﬁrewall of a ﬁrewall chain blocks desired traﬃc. Here, the
desired reachability R is intersected with the subspace
D that represents all dropped packets. If the intersection
V = D∩R is nonempty, then parts of R will be dropped by
some ﬁrewall drop rule and will not be part of the network
reachability. As above, the problematic ﬁrewall rules can
be identiﬁed from the traces attached to elements (boxes)
of V , which they inherit from D.
Other compliance tests are possible and can be imple-
mented when needed.
IX. Lessons Learned
Input Data: When converting ﬁrewall conﬁguration
data from customers, we found that signiﬁcant eﬀort may
be needed to account for deviations from expected format
convention and outright errors. We expect that for large
ﬁrewall conﬁgurations some manual adaption may be hard
to avoid. In seems that in their desire to accommodate
customer requests, ﬁrewall vendors sometimes allow their
customers to do things that are not advisable with regard
to clean structuring and consistency, such as overlapping
network groups, empty network groups and increasingly
more action keywords in new versions. Some of these
require manual intervention in order to map them to a
uniﬁed ﬁrewall model. In addition, the right mapping may
depend on the actual analysis task to be performed.
Software Engineering: Both, prototyping in Python
and providing full, meaningful unit-tests provided hugely
beneﬁcial in creating a correctly working prototype and
in making sure optimizations did not introduce additional
errors. As the same time, keeping the Python-layer as
“glue” on top of the implementation of the core loop in
C allows for very eﬃcient conﬁguration and scripting of
arbitrary analyses. The chosen implementation approach
can be qualiﬁed as a success and is highly recommended
for similar projects.
Performance: We found that run-time and memory
footprint allow analysis of large and very large ﬁrewalls
on standard hardware. This result is unexpected, as the
underlying problems are algorithmically not eﬃcient. We
theorize that the reason lies in the fact that real-world
ﬁrewall deployments only sparingly use most of the possi-
bilities that ﬁrewalls oﬀer (for example, mixing accept and
drop rules excessively) as the ﬁrewall conﬁguration still has
to be created and maintainable by human beings.
X. Related Work
Reachability Analysis: One alternative to using the
CNA is network scanning, for example with nmap [9].
It should be noted however that this suﬀers from the
limitations that routing aﬀects scanning and that normal
scanning cannot ﬁnd undesired unidirectional reachability.
Algorithmic Firewall Analysis: It is possible to for-
malize ﬁrewall functionality with a suitable logic and then
use approaches from automated theorem proving to derive
properties and check against violation of conditions. Work
in this area includes FIREMAN [5] by Yuan, Mai, Su,
Chen, Chuah and Mohapatra, which uses a BDD (Binary
Decision Diagram) representation. The idea of using BDDs
is developed further by Liu and Gouda [6], [10], with the
introduction of Firewall Decision Diagrams (FDDs).
A diﬀerent approach based on Decision Diagrams is
described by Liu in [11]. It allows the checking of prop-
erties given a speciﬁc ﬁrewall rule set. The properties are
formalized as ﬁrewall rules with wildcards, e.g., that no
traﬃc must ﬂow to or from IP address 1.2.*.*. This
formalization has a close relation to our policy checking
approach where we formalize a policy as an additional
ﬁrewall. Unfortunately, [11] only tested performance for

97
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
small real-world ﬁrewall rule-sets up to 661 rules and hence
a meaningful performance comparison with our approach
is not possible.
Firewall
Models: Leporati and Ferretti [12] use
Tissue-like P Systems to model connected sets of ﬁrewalls.
In [13], Bourdier and Cirstea employ rewrite systems
to model ﬁrewall ﬁltering and translation rules. Bera,
Dasgupta and Ghosh [14] is an example for the use of a
Boolean SAT solver to verify ﬁrewall ruleset properties.
Firewall Redundancy Analysis: Firewall redun-
dancy analysis is aimed at identifying and removing re-
dundancies in a ﬁrewall ruleset, such as rules that have
overlapping boxes. While a proliﬁc theoretical ﬁeld, its
relevance to practice is minor. For example, [15], [16] and
[17] deal with this aspect of ﬁrewall analysis.
Query Engines: The query-engine of Mayer, Wool
and Ziskind [18] answers questions on whether a speciﬁc
packet would traverse a set of ﬁrewalls by using a rule-
based simulator. This is mostly useful to determine the
impact of speciﬁc ﬁrewall conﬁguration changes. Its value
in a complete ﬁrewall security analysis is limited. The
Margrave Tool [19] uses a similar approach.
Commercial Tools: A commercial ﬁrewall analyzer is
oﬀered by AlgoSec [20]. This tool seems to be targeted at
maintenance and administration of large numbers (up to
1000) of ﬁrewalls. Commercial ﬁrewall maintenance tools
with limited audit capabilities are also oﬀered by Tuﬁn
[21] and FireMon [22].
XI. Conclusion and Future Work
We have designed and implemented the CNA (Con-
secom Network Analyzer), a tool that calculates network
reachability through a series of ﬁrewalls given as a Layer
4 abstraction by symbolic simulation. The primary use
is for real-world security audits that examine ﬁrewalls
with large rule-sets. While using set operations to model
ﬁrewalls is simple, to the best of our knowledge we are the
ﬁrst to demonstrate that an abstraction based on inter-
vals is eﬃcient enough to calculate reachability through
large deployed ﬁrewall conﬁgurations in practically useful
time and with moderate memory footprint, while at the
same time retaining the capability to annotate each result
sub-set with a full trace of the applied ﬁrewall rules.
Automated result annotation is essential when analyzing
ﬁrewall chains that include ﬁrewalls with a large number
of rules.
We also have demonstrated the eﬀect of a series of
implementational and algorithmic optimizations on exe-
cution time and memory-footprint. The last step is the
application of ideas from geometrical search to use one-
dimensional interval search trees for reduction of ineﬀec-
tive rule applications to Work Set elements. The bench-
marks given include performance on large ﬁrewall rule sets
actually deployed in real applications.
One possible direction for future work is further in-
vestigation into how multi-dimensional geometric search
structures could be used to improve eﬃciency even more.
Primary issues are that most known multi-dimensional
search structures do not handle updates (additions and
deletions) eﬃciently. Using these structures for the CNA
would mean ﬁnding design and implementation trade-oﬀs
that work well for real problems, even if their theoretical
worst-case performance is bad.
A second possibility for future work is the adaption of
the CNA IPv6 addresses. With the current system, this
can be done by swapping out 32 bit unsigned integers for
128 bit unsigned integers in the C code. Python already
handles all integers as long-numbers and no change in
the Python code would be needed. However, input-parsing
and result output would have to be adapted. However,
the larger memory footprint may have signiﬁcant impact
on the actual implementation and may require speciﬁc
additional optimizations to retain eﬃciency.
Finally, the CNA could be extended to handle subchains
in ﬁrewall rule sets. At this time, subchains can be handled
by a preprocessing step. A native implementation of sub-
chains into the CNA core code by adding suitable rule ac-
tions could speed up processing of subchains signiﬁcantly.
Acknowledgments: We thank the Swiss KTI and Con-
secom AG for funding parts of this work and the anony-
mous reviwers for their helpful suggestions.
References
[1] A. Wagner and U. Fiedler, “Firewall Analysis by Symbolic Sim-
ulation,” in The Seventh International Conference on Internet
Monitoring and Protection (ICIMP 2012), 2012, pp. 95–100.
[2] “Wikipedia:
Hyperrectangle,”
http://en.wikipedia.org/wiki/
Hyperrectangle, last visited December 2013.
[3] H. S. M. Coxeter, Regular Polytopes, 3rd ed.
New York: Dover,
1973.
[4] P. Eronen and J. Zitting, “An Expert System for Analyzing
Firewall Rules,”in Proc. 6th Nordic Worksh. Secure IT Systems,
2001, pp. 100–107.
[5] L. Yuan, J. Mai, Z. Su, H. Chen, C.-N. Chuah, and P. Mo-
hapatra, “FIREMAN: A Toolkit for FIREwall Modeling and
ANalysis,” in IEEE Symposium on Security and Privacy, 2006,
pp. 199–213.
[6] A. X. Liu and M. G. Gouda, “Diverse Direwall Design,” in
IEEE Transactions on Parallel and Distributed Systems, 19(8),
August 2008.
[7] “The Python Homepage,” http://python.org/, last visited De-
cember 2013.
[8] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein,
Introduction to Algorithms, 3rd ed.
Mit Press, 2009.
[9] “Nmap Security Scanner,” http://nmap.org/, last visited De-
cember 2013.
[10] A. X. Liu and M. G. Gouda, “Firewall Policy Queries,” in IEEE
Transactions on Parallel and Distributed Systems, 20(6), June
2009.
[11] A. X. Liu, “Formal Veriﬁcation of Firewall Policies,” in 2008
IEEE International Conference on Communications, ICC ’08,
2008, pp. 1494 – 1498.
[12] A. Leporati and C. Ferretti, “Modelling and Analysis of Fire-
walls by (Tissue-like) P Systems,” in Romanian Journal of
Information Science and Technology, Vol. 13, No 2, 2010, pp.
169–180.

98
International Journal on Advances in Security, vol 6 no 3 & 4, year 2013, http://www.iariajournals.org/security/
2013, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[13] T. Bourdier and H. Cirstea, “Symbolic Analysis of Network
Security Policies Using Rewrite Systems,” in Symposium on
Principles and Practices of Declarative Programming, 2011, pp.
77–88.
[14] P. Bera, P. Dasgupta, and S. Ghosh, “Formal Analysis of Secu-
rity Policy Implementations in Enterprise Networks,” in Inter-
national Journal of Computer Networks and Communications
(IJCNC), Vol. 1, No. 2, 2009, pp. 56–73.
[15] S. Pozo, A. Varela-Vaca, and R. Gasca,“A Quadratic, Complete,
and Minimal Consistency Diagnosis Process for Firewall ACLs,”
in 24th IEEE International Conference on Advanced Informa-
tion Networking and Applications, 2010.
[16] K. Karoui, F. B. Ftima, and H. B. Ghezala, “Formal Speciﬁca-
tion, Veriﬁcation and Correction of Security Policies Based on
the Decision Tree Approach,” in International Journal of Data
and Network Security 08/2013; 3(3):92-111, 2013.
[17] P. Rajkhowa, S. M. Hazarika, and G. R. Simari,“An Application
of Defeasible Logic Programming for Firewall Veriﬁcation and
Reconﬁguration,” in Quality, Reliability, Security and Robust-
ness in Heterogeneous Networks, Lecture Notes of the Institute
for Computer Sciences, Social Informatics and Telecommunica-
tions Engineering, Volume 115, 2013, pp. 526–542.
[18] A. J. Mayer, A. Wool, and E. Ziskind,“Oﬄine ﬁrewall analysis,”
Int. J. Inf. Sec., vol. 5, no. 3, pp. 125–144, 2006.
[19] T. Nelson, C. Barratt, D. J. Dougherty, K. Fisher, and S. Kr-
ishnamurthi, “The Margrave Tool for Firewall Analysis,” in
USENIX Large Installation System Administration Conference
(LISA), 2010.
[20] “Algosec Homepage,”http://www.algosec.com/, last visited De-
cember 2013.
[21] “tuﬁn Homepage,” http://www.tuﬁn.com/, last visited Decem-
ber 2013.
[22] “FireMon Homepage,” http://www.ﬁremon.com/, last visited
December 2013.

