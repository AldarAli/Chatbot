Construction Principles for Well-behaved Scalable Systems
Peter Ochsenschläger∗ and Roland Rieke∗†
∗Fraunhofer Institute for Secure Information Technology SIT, Darmstadt, Germany
†Philipps-Universität Marburg, Germany
Email: peter-ochsenschlaeger@t-online.de, roland.rieke@sit.fraunhofer.de
Abstract—We formally deﬁne scalable systems as
uniformly monotonic parameterised systems and mo-
tivate this deﬁnition. With respect to such scalable
systems, we focus on properties, which rely on speciﬁc
component types and a speciﬁc number of individual
components for these component types but not on
the speciﬁc individuality of the individual compo-
nents. We characterise well-behaved scalable systems
by those systems which fulﬁl such a kind of property
if already one prototype system (depending on the
property) fulﬁls that property. Self-similar uniformly
monotonic parameterised systems have the above
desired property. Therefore, we deﬁne well-behaved
scalable systems as self-similar scalable systems. This
paper presents a formal framework that provides con-
struction principles for well-behaved scalable systems.
It gives suﬃcient conditions to specify a certain kind
of basic well-behaved scalable systems and shows how
to construct more complex systems by the composi-
tion of several synchronisation conditions.
Keywords-uniformly parameterised systems; mono-
tonic parameterised systems; behaviour-abstraction;
self-similarity of behaviour.
I. Introduction
Scalability is a desirable property of a system. In [1],
four aspects of scalability are considered, i.e., load
scalability, space scalability, space-time scalability, and
structural scalability. In our paper, we focus on structural
scalability, which is “the ability of a system to expand in
a chosen dimension without major modiﬁcations to its
architecture” [1]. Examples of systems that need to be
highly scalable comprise grid computing architectures and
cloud computing platforms [2], [3]. Usually, such systems
consist of few diﬀerent types of components and for each
such type a varying set of individual components exists.
Component types can be deﬁned in such a granularity
that individual components of the same type behave in
the same manner, which is characteristic for the type. For
example, a client-server system that is scalable consists
of the component types client and server and several sets
of individual clients as well as several sets of individual
servers. Let us now call a choice of sets of individual
components an admissible choice of individual component
sets, iﬀ for each component type exactly one set of
individual components of that type is chosen. Then,
a “scalable system” can be considered as a family of
systems, whose elements are systems composed of a
speciﬁc admissible choice of individual component sets.
In this paper, we focus on the dynamic behaviour of
systems, which is described by the set of all possible
sequences of actions. This point of view is important
to deﬁne security requirements as well as to verify
such properties, because for these purposes sequences of
actions of the system have to be considered [4], [5], [6]. For
short, we often will use the term system instead of systems
behaviour if it does not generate confusions. With this
focus, scalable systems are families of system behaviours,
which are indexed by admissible choices of individual
component sets. We call such families parameterised
systems. In this paper, we deﬁne well-behaved scalable
systems as a special class of parameterised systems and
develop construction principles for such systems. The
main goal for this deﬁnition is to achieve that well-
behaved scalable systems fulﬁll certain kind of safety
properties if already one prototype system (depending on
the property) fulﬁlls that property (cf. Section III). To
this end, construction principles for well-behaved scalable
systems are design principles for veriﬁability [7].
Considering the behaviour-veriﬁcation aspect, which
is one of our motivations to formally deﬁne well-behaved
scalable systems, there are some other approaches to be
mentioned. An extension to the Murϕ veriﬁer to verify
systems with replicated identical components through a
new data type called RepetitiveID is presented in [8]. A
typical application area of this tool are cache coherence
protocols. The aim of [9] is an abstraction method
through symmetry, which works also when using variables
holding references to other processes. In [10], a method-
ology for constructing abstractions and reﬁning them by
analysing counter-examples is presented. The method
combines abstraction, model-checking and deductive
veriﬁcation. A technique for automatic veriﬁcation of
parameterised systems based on process algebra CCS
[12] and the logic modal mu-calculus [13] is presented
in [11]. This technique views processes as property
transformers and is based on computing the limit of
a sequence of mu-calculus [13] formulas generated by
these transformers. The above-mentioned approaches
demonstrate that ﬁnite state methods combined with de-
ductive methods can be applied to analyse parameterised
32
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-319-3
ICONS 2014 : The Ninth International Conference on Systems

systems. The approaches diﬀer in varying amounts of
user intervention and their range of application. A survey
of approaches to combine model checking and theorem
proving methods is given in [14]. Far reaching results
in verifying parameterised systems by model checking
of corresponding abstract systems are given in [15], [16].
It is well known that the general veriﬁcation problem
for parameterised systems is undecidable [17], [18]. To
handle that problem, we present (a) a formal framework
to specify parameterised systems in a restricted manner,
and (b) construction principles for well-behaved scalable
systems.
In Section II, scalable systems are formally deﬁned.
Section III and Section IV give suﬃcient conditions to
specify a certain kind of basic well-behaved scalable
systems. Section V shows how to construct more complex
well-behaved scalable systems by the composition of
several synchronisation conditions. Concluding remarks
and further research directions are given in Section VI.
The proofs of the theorems in this paper are given in [19].
II. Characterisation of Scalable Systems
The behaviour L of a discrete system can be formally
described by the set of its possible sequences of actions.
Therefore, L ⊂ Σ∗ holds where Σ is the set of all actions
of the system, and Σ∗ (free monoid over Σ) is the set of
all ﬁnite sequences of elements of Σ, including the empty
sequence denoted by ε. This terminology originates from
the theory of formal languages [20], where Σ is called the
alphabet (not necessarily ﬁnite), the elements of Σ are
called letters, the elements of Σ∗ are referred to as words
and the subsets of Σ∗ as formal languages. Words can be
composed: if u and v are words, then uv is also a word.
This operation is called the concatenation; especially
εu = uε = u. A word u is called a preﬁx of a word v
if there is a word x such that v = ux. The set of all
preﬁxes of a word u is denoted by pre(u); ε ∈ pre(u)
holds for every word u. Formal languages which describe
system behaviour have the characteristic that pre(u) ⊂ L
holds for every word u ∈ L. Such languages are called
preﬁx closed. System behaviour is thus described by
preﬁx closed formal languages. Diﬀerent formal models
of the same system are partially ordered with respect to
diﬀerent levels of abstraction. Formally, abstractions are
described by alphabetic language homomorphisms. These
are mappings h∗ : Σ∗ −→ Σ′∗ with h∗(xy) = h∗(x)h∗(y),
h∗(ε) = ε and h∗(Σ) ⊂ Σ′ ∪ {ε}. So, they are uniquely
deﬁned by corresponding mappings h : Σ −→ Σ′ ∪{ε}. In
the following, we denote both the mapping h and the
homomorphism h∗ by h. We consider a lot of alphabetic
language homomorphisms. So, for simplicity we tacitly
assume that a mapping between free monoids is an
alphabetic language homomorphism if nothing contrary
is stated. We now introduce a guiding example.
Example 1. A server answers requests of a family of
clients. The actions of the server are considered in the
following. We assume with respect to each client that a
request will be answered before a new request from this
client is accepted. If the family of clients consists of only
one client, then the automaton in Fig. 1(a) describes the
system behaviour S ⊂ Σ∗, where Σ = {a,b}, the label a
depicts the request, and b depicts the response.
1
2
a
b
(a) Actions at a server with
respect to a client
0
1
2
3
a1
b1
a2
b2
a2
b2
a1
b1
(b) Two clients served concurrently
by one server
Figure 1.
Scalable client-server system
Example 2. Fig. 1(b) now describes the system behaviour
S{1,2} ⊂ Σ∗
{1,2} for two clients 1 and 2, under the
assumption that the server handles the requests of diﬀerent
clients non-restricted concurrently.
For a parameter set I and i ∈ I let Σ{i} denote pairwise
disjoint copies of Σ. The elements of Σ{i} are denoted
by ai and ΣI := S
i∈I
Σ{i}, where Σj ∩ Σk = ∅ for j ̸= k.
The index i describes the bijection a ↔ ai for a ∈ Σ and
ai ∈ Σ{i}.
Example 3. For ∅ ̸= I ⊂ N with ﬁnite I, let now SI ⊂ Σ∗
I
denote the system behaviour with respect to the client set
I. For each i ∈ N S{i} is isomorphic to S, and SI consists
of the non-restricted concurrent run of all S{i} with i ∈ I.
It holds SI′ ⊂ SI for I′ ⊂ I.
Let I1 denote the set of all ﬁnite non-empty subsets
of N (the set of all possible clients). Then, the family
(SI)I∈I1 is an example of a monotonic parameterised
system.
If the example is extended to consider several servers,
which are depicted by natural numbers, then, e.g.,
I2 := {˚I × ˆI ⊂ N×N|˚I ̸= ∅ ̸= ˆI, with ˚I, ˆI ﬁnite}
is a suitable parameter structure.
I2 used in the example above shows how the component
structure of a system can be expressed by a parameter
structure using Cartesian products of individual compo-
nent sets. The following Deﬁnition 1 abstracts from the
intuition of a component structure.
Deﬁnition 1 (parameter structure). Let N be a count-
able (inﬁnite) set and ∅ ̸= I ⊂ P(N)\{∅}. I is called a
parameter structure based on N.
33
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-319-3
ICONS 2014 : The Ninth International Conference on Systems

For scalable systems it is obvious to assume that
enlarging the individual component sets does not reduce
the corresponding system behaviour. More precisely: let
I and K be two arbitrary admissible choices of individual
component sets, where each individual component set in
I is a subset of the corresponding individual component
set in K. If SI and SK are the corresponding systems’
behaviours, then SI is a subset of SK. Families of systems
with this property we call monotonic parameterised
systems. The following deﬁnition formalises monotonic
parameterised systems.
Deﬁnition 2 (monotonic parameterised system). Let I
be a parameter structure. For each I ∈ I let LI ⊂ Σ∗
I be
a preﬁx closed language. If LI′ ⊂ LI for each I,I′ ∈ I
with I′ ⊂ I, then (LI)I∈I is a monotonic parameterised
system.
As we assume that individual components of the
same type behave in the same manner, SI and SK are
isomorphic (equal up to the names of the individual
components), if I and K have the same cardinality. This
property we call uniform parameterisation. With these
notions we deﬁne scalable systems as uniformly monotonic
parameterised systems. Monotonic parameterised systems
in which isomorphic subsets of parameter values describe
isomorphic subsystems we call uniformly monotonic
parameterised systems.
Deﬁnition 3 (isomorphism structure). Let I be a
parameter structure, I,K ∈ I, and ι : I → K a bijection,
then let ιI
K : Σ∗
I → Σ∗
K the isomorphism deﬁned by
ιI
K(ai) := aι(i) for ai ∈ ΣI.
(1)
For each I,K ∈ I let B(I,K) ⊂ KI a set (possibly
empty) of bijections. BI = (B(I,K))(I,K)∈I×I is called
an isomorphism structure for I.
Deﬁnition 4 (scalable system). Let (LI)I∈I a mono-
tonic parameterised system and BI = (B(I,K))(I,K)∈I×I
an isomorphism structure for I.
(LI)I∈I is called uniformly monotonic parameterised
with respect to BI iﬀ
LK = ιI
K(LI) for each I,K ∈ I and each ι ∈ B(I,K).
Uniformly monotonic parameterised systems for short
are called scalable systems.
Example 4. Let I = I2.
B2(˚I × ˆI,˚
K × ˆK) := {ι ∈ (˚
K × ˆK)(˚
I×ˆI) |it exist bijections
˚ι : ˚I → ˚
K and ˆι : ˆI → ˆK with ι((r,s)) = (˚ι(r),ˆι(s))
for each (r,s) ∈ (˚I × ˆI)}
for ˚I × ˆI ∈ I2 and ˚
K × ˆK ∈ I2 deﬁnes an isomorphism
structure B2
I2.
III. Well-behaved Scalable Systems
To motivate our formalisation of well-behaved, we
consider a typical security requirement of a scalable client-
server system: Whenever two diﬀerent clients cooperate
with the same server then certain critical sections of the
cooperation of one client with the server must not overlap
with critical sections of the cooperation of the other client
with the same server. If for example both clients want
to use the same resource of the server for conﬁdential
purposes, then the allocation of the resource to one of the
clients has to be completely separated from the allocation
of this resource to the other client. More generally, the
concurrent cooperation of one server with several clients
has to be restricted by certain synchronisation conditions
to prevent, for example, undesired race conditions.
According to this example, we focus on properties
which rely on speciﬁc component types and a speciﬁc
number of individual components for these component
types but not on the speciﬁc individuality of the indi-
vidual components. Now, we want to achieve that a well
behaved scalable system fulﬁls such a kind of property if
already one prototype system (depending on the property)
fulﬁls that property. In our example, a prototype system
consists of two speciﬁc clients and one speciﬁc server.
To formalise this desire, we consider arbitrary I and K
as in the deﬁnition of monotonic parameterised system.
Then we look at SK from an abstracting point of
view, where only actions corresponding to the individual
components of I are considered. If the smaller subsystem
SI behaves like the abstracted view of SK, then we
call this property self-similarity or more precisely self-
similarity of scalable systems, to distinguish our notion
from geometric oriented notions [21] and organisational
aspects [22] of self-similarity. In [5], it is shown that
self-similar uniformly monotonic parameterised systems
have the above desired property. Therefore, we deﬁne
well-behaved scalable systems as self-similar uniformly
monotonic parameterised systems. We now formally look
at LI from an abstracting point of view concerning
a subset I′ ⊂ I. The corresponding abstractions are
formalised by the homomorphisms ΠI
I′ : Σ∗
I → Σ∗
I′.
Deﬁnition 5 (self-similar monotonic parameterised sys-
tem). For I′ ⊂ I let ΠI
I′ : Σ∗
I → Σ∗
I′ with
ΠI
I′(ai) =

ai |
ai ∈ ΣI′
ε |
ai ∈ ΣI \ΣI′.
A monotonic parameterised system (LI)I∈I is called self-
similar iﬀ ΠI
I′(LI) = LI′ for each I,I′ ∈ I with I′ ⊂ I.
Deﬁnition 6 (well-behaved scalable system). Self-
similar scalable systems for short are called well-behaved
scalable systems.
A fundamental construction principle for systems
34
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-319-3
ICONS 2014 : The Ninth International Conference on Systems

satisfying several constraints is intersection of system
behaviours. This emphasises the importance of the
following theorem.
Theorem 1 (intersection theorem). Let I be a parameter
structure, BI an isomorphism structure for I, and T ̸= ∅.
i) Let (Lt
I)I∈I for each t ∈ T be a monotonic param-
eterised system, then ( T
t∈T
Lt
I)I∈I is a monotonic
parameterised system.
ii) Let (Lt
I)I∈I for each t ∈ T be a scalable system with
respect to BI, then ( T
t∈T
Lt
I)I∈I is a scalable system
with respect to BI.
iii) Let (Lt
I)I∈I for each t ∈ T be a self-similar mono-
tonic parameterised system, then ( T
t∈T
Lt
I)I∈I is a
self-similar monotonic parameterised system.
Weak additional assumptions for well-behaved scalable
systems imply that such systems are characterised by
parametrisation of one well-deﬁned minimal prototype
system. More precisely:
Deﬁnition 7 (minimal prototype system). Let I be a
parameter structure based on N. For I ∈ I and n ∈ N let
τ I
n : Σ∗
I → Σ∗ the homomorphisms given by
τ I
n(ai) =
 a |
ai ∈ ΣI∩{n}
ε |
ai ∈ ΣI\{n}
.
For a singleton index set {n}, τ {n}
n
: Σ∗
{n} → Σ∗ is an
isomorphism and for each n ∈ I ∈ I holds
ΠI
{n} = (τ {n}
n
)−1 ◦τ I
n.
(2)
If now (LI)I∈I is a well-behaved scalable system with
respect to (B(I,K))(I,K)∈I×I with {n} ∈ I for n ∈ I ∈ I
and B(I,K) ̸= ∅ for all singleton I and K, then because
of (2) holds
LI ⊂
\
n∈I
(τ I
n)−1(L) for each I ∈ I,
where L = τ {n}
n
(L{n}) for each n ∈ S
I∈I
I.
L is called the minimal prototype system of (LI)I∈I.
Deﬁnition 8 (behaviour-family ( ˙L(L)I)I∈I generated
by the minimal prototype system L and the parameter
structure I). Let ∅ ̸= L ⊂ Σ∗ be preﬁx closed, I a
parameter structure, and
˙L(L)I :=
\
i∈I
(τ I
i )−1(L) for I ∈ I.
The systems ˙L(L)I consist of the “non-restricted con-
current run” of all systems (τ {i}
i
)−1(L) ⊂ Σ∗
{i} with i ∈ I.
Because τ {i}
i
: Σ∗
{i} → Σ∗ are isomorphisms, (τ {i}
i
)−1(L)
are pairwise disjoint copies of L.
Theorem 2 (simplest well-behaved scalable systems).
( ˙L(L)I)I∈I is a well-behaved scalable system with respect
to each isomorphism structure for I based on N and
˙L(L)I =
\
i∈N
(τ I
i )−1(L) for each I ∈ I.
IV. Construction of Well-behaved Systems by
Restriction of Concurrency
Now, we show how to construct well-behaved systems
by restricting concurrency in the behaviour-family
˙L.
In Example 3, holds SI = ˙L(S)I for I ∈ I1. If, in the
given example, the server needs speciﬁc resources for the
processing of a request, then - on account of restricted
resources - an non-restricted concurrent processing of
requests is not possible. Thus, restrictions of concurrency
in terms of synchronisation conditions are necessary. One
possible but very strong restriction is the requirement
that the server handles the requests of diﬀerent clients in
the same way as it handles the requests of a single client,
namely, on the request follows the response and vice
versa. This synchronisation condition can be formalised
with the help of S and the homomorphisms ΘI as shown
in the following example.
Example 5. Restriction of concurrency on account
of restricted resources: one “task” after another. All
behaviours with respect to i ∈ I inﬂuence each other. Let
¯SI := SI ∩(ΘI)−1(S) =
\
i∈I
(τ I
i )−1(S)∩(ΘI)−1(S)
for I ∈ I1, where generally, for each index set I, ΘI :
Σ∗
I → Σ∗ is deﬁned by ΘI(ai) := a, for i ∈ I and a ∈ Σ.
From the automaton in Fig. 1(b), it is evident that
¯S{1,2} will be accepted by the automaton in Fig. 2(a).
0
1
2
a1
b1
a2
b2
(a) Automaton accepting ¯S{1,2}
0
i
ai
bi
(b) Automaton accepting ¯SI
Figure 2.
Automata accepting ¯S{1,2} and ¯SI
Given an arbitrary I ∈ I1, then ¯SI is accepted by an
automaton with state set {0} ∪ I and state transition
relation given by Fig. 2(b) for each i ∈ I.
From this automaton, it is evident that ( ¯SI)I∈I1 is
a well-behaved scalable system, with respect to each
isomorphism structure BI1 for I1.
Example 6. A restriction of concurrency in the extended
example where a family of servers is involved is more
complicated than in the case of ( ¯SI)I∈I1. The reason
for that is that in the simple example the restriction of
35
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-319-3
ICONS 2014 : The Ninth International Conference on Systems

concurrency can be formalised by a restricting inﬂuence
of the actions with respect to all parameter values (i.e.,
the entire ΣI). When considering the restriction of
concurrency in the extended example, the actions inﬂuence
each other only with respect to the parameter values, which
are bound to the same server.
Let the ﬁrst component of the elements from N×N in
the parameter structure I2 denote the server, then the
actions from Σ{r}×ˆI inﬂuence each other for given r ∈ ˚I
with ˚I × ˆI ∈ I and thus restrict the concurrency.
For the formalisation of this restriction of concurrency,
we now consider the general case of monotonic param-
eterised systems ( ˙L(L)I)I∈I. As already observed in
(2), for each well-behaved scalable system (LI)I∈I there
exists (under weak preconditions) a system ( ˙L(L)I)I∈I
with LI ⊂ ˙L(L)I for each I ∈ I, where L = τ {n}
n
(L{n})
for each n ∈ I ∈ I. Moreover, in context of Deﬁnition 8
it was observed that ˙L(L)I consists of the non-restricted
concurrent run of pairwise disjoint copies of L.
In conjunction, this shows that an adequate restriction
of concurrency in ( ˙L(L)I)I∈I can lead to the construction
of well-behaved scalable systems. Therefore, the restrict-
ing inﬂuence of actions with respect to speciﬁc parameter
values described above shall now be formalised.
Deﬁnition 9 (inﬂuence structure). Let T ̸= ∅ and I a
parameter structure. For each I ∈ I and t ∈ T a sphere
of inﬂuence is speciﬁed by E(t,I) ⊂ I. The family
EI = (E(t,I))(t,I)∈T ×I
is called inﬂuence structure for I indexed by T.
The non-restricted concurrent run of the pairwise
disjoint copies of L will now be restricted in the following
way: For each t ∈ T the runs of all copies k with k ∈ E(t,I)
inﬂuence each other independently of the speciﬁc values
of k ∈ E(t,I). With respect to our extended example
(several servers) with I2, the spheres of inﬂuence E(t,I)
are generalisations of the sets {r} × ˆI, where I = ˚I × ˆI
and t = (r,s) ∈ ˚I × ˆI.
Generally, for each t ∈ T the intersection
˙L(L)I ∩(τ I
E(t,I))−1(V )
(3)
formalises the restriction of the non-restricted concurrent
run of the copies of L within
˙L(L)I by the mutual
inﬂuence of each element of E(t,I).
Deﬁnition 10 (behaviour of inﬂuence and inﬂuence
homomorphisms). In (3), the behaviour of inﬂuence V
is a preﬁx closed language V ⊂ Σ∗, and for I,I′ ⊂ N the
homomorphism τ I
I′ : Σ∗
I → Σ∗ is deﬁned by:
τ I
I′(ai) =
 a |
ai ∈ ΣI∩I′
ε |
ai ∈ ΣI\I′
.
(4)
The homomorphisms τ I
E(t,I) are called the inﬂuence
homomorphisms of EI.
Deﬁnition 11 (behaviour-family (L(L,EI,V )I)I∈I gen-
erated by the minimal prototype system L, the inﬂuence
structure EI, and the behaviour of inﬂuence V ). Because
the restriction (3) shall hold for all t ∈ T, the restricted
systems L(L,EI,V )I are deﬁned by the preﬁx closed
languages
L(L,EI,V )I := ˙L(L)I ∩
\
t∈T
(τ I
E(t,I))−1(V ) for I ∈ I.
Deﬁnition 11 shows how synchronisation requirements
for the systems ˙L(L)I can be formalised by inﬂuence
structures and behaviour of inﬂuence in a very general
manner. Since, similar to the well-behaved scalable
systems ( ˙L(L)I)I∈I, in the systems (L(L,EI,V )I)I∈I
each L(L,EI,V ){i} shall be isomorphic to L for each
{i} ∈ I, V ⊃ L has to be assumed. Therefore, in general
we assume for systems (L(L,EI,V )I)I∈I that V ⊃ L ̸= ∅.
Note that τ I
I′ are generalisations of τ I
n and ΘI, because
τ I
n = τ I
{n} and ΘI = τ I
I = τ I
N
(5)
for each I ⊂ N and n ∈ N.
Further
requirements,
which
assure
that
(L(L,EI,V )I)I∈I are well-behaved scalable systems, will
now be given with respect to EI, BI, L and V . Assuming
T = N and ε ∈ V the scalability property is assured by
the following technical requirements for EI and BI:
Theorem 3 (construction condition for scalable sys-
tems). Let I be a parameter structure based on N,
EI = (E(n,I))(n,I)∈N×I be an inﬂuence structure for
I, and let BI = (B(I,I′))(I,I′)∈I×I be an isomorphism
structure for I. Let ε ∈ V ⊂ Σ∗,for each I ∈ I and n ∈
N let E(n,I) = ∅, or it exists an in ∈ I with E(n,I) =
E(in,I), and for each (I,I′) ∈ I ×I,ι ∈ B(I,I′) and i ∈
I holds
ι(E(i,I)) = E(ι(i),I′).
Let E(t,I′) = E(t,I) ∩ I′ for each t ∈ T and I,I′ ∈
I,I′ ⊂ I. Then (L(L,EI,V )I)I∈I is a scalable system
with respect to BI and
L(L,EI,V )I = ˙L(L)I ∩
\
n∈I
(τ I
E(n,I))−1(V )).
Example 7. Let I be a parameter structure based on N,
and for I ∈ I let ¯E(i,I) := I for i ∈ N.
¯EI := ( ¯E(i,I))(i,I)∈N×I satisﬁes the assumptions
of Theorem 3 for each isomorphism structure BI. (6)
It
holds
(ΘI)−1(V ) = (τ I
¯
E(i,I))−1(V ) for each i ∈
N,I ∈ I, and V ⊂ Σ∗.
Therefore, L(L, ¯EI,V )I = ˙L(L)I ∩(ΘI)−1(V ) for I ∈ I.
Especially, ¯SI = L(S, ¯EI1,S)I for each I ∈ I1.
36
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-319-3
ICONS 2014 : The Ninth International Conference on Systems

Example 8. For the parameter structure I2, and for
˚I × ˆI ∈ I2 let
E2((˚n, ˆn),˚I × ˆI) :=
 {˚n}× ˆI |
˚n ∈ ˚I
∅ |
˚n ∈ N\˚I
.
E2
I2 := (E2((˚n, ˆn),˚I × ˆI))((˚n,ˆn),˚
I×ˆI)∈(N×N)×I2
(7)
satisﬁes the assumptions of Theorem 3 for the isomor-
phism structure B2
I2.
(L(S,E2
I2,S)I)I∈I2 is the formalisation of the extended
example (several servers) with restricted concurrency.
In order to extend Theorem 3 with respect to self-
similarity, an additional assumption is necessary. This is
demonstrated by the following counter-example.
Example 9. Let G ⊂ {gr,gi,gs}∗ the preﬁx closed lan-
guage, which is accepted by the automaton Fig. 3(a).
Let H ⊂ {gr,gi,gs}∗ the preﬁx closed language, which is
accepted by the automaton in Fig. 3(b). It holds ∅ ̸= G ⊂ H
but (L(G, ¯EI1,H)I)I∈I1 is not self-similar, e.g.,
Π{1,2,3}
{2,3} (L(G, ¯EI1,H){1,2,3}) ̸= (L(G, ¯EI1,H){2,3}
because gr1gi1gr2gr3 ∈ L(G, ¯EI1,H){1,2,3}, and hence
gr2gr3 ∈ Π{1,2,3}
{2,3} (L(G, ¯EI1,H){1,2,3}),
but
gr2gr3 /∈
(L(G, ¯EI1,H){2,3}.
1
2
3
gr
gi
gs
(a) Automaton accepting G
1
2
3
4
5
6
7
9
8
gr
gi
gs
gr
gs
gr
gi
gi
gs
gs
gs
(b) Automaton accepting H
Figure 3.
Counterexample
Deﬁnition 12 (closed under shuﬄe projection). Let
L,V ⊂ Σ∗. V is closed under shuﬄe projection with respect
to L, iﬀ
ΠN
K[(
\
n∈N
(τ N
n )−1(L))∩(ΘN)−1(V )] ⊂ (ΘN)−1(V )
(8)
for each subset ∅ ̸= K ⊂ N. We abbreviate this by
SP(L,V ).
Remark 1. It can be shown that in SP(L,V ) N can be
replaced by each countable inﬁnite set.
Remark 2. If L and V are preﬁx closed with ∅ ̸= L ⊂ V ,
then it is easy to show that SP(L,V ) follows from self-
similarity of (L(L, ¯EI1,V )I)I∈I1.
With Deﬁnition 12 we are now able to formulate
our main result for constructing well-behaved scalable
systems deﬁned by a single synchronisation condition.
Theorem 4 (construction condition for well-behaved
scalable systems). By the assumptions of Theorem 3
together with SP(L,V )
(L(L,EI,V )I)I∈I
is a well-behaved scalable system.
Example 10. For k ∈ N let the preﬁx closed language
Fk ⊂ {a,b}∗ be deﬁned by the automaton in Fig. 4(a).
0
1
k-1
k
a
b
a
b
(a) Automaton for Fk ⊂ {a,b}∗
0
1
2
3
ac
as
bs
bc
(b) One client, one server
Figure 4.
Automata at diﬀerent abstraction levels
With respect to Example 1, F1 = S holds. It can
be shown that SP(S,Fk) holds for each k ∈ N. With
Theorem 4 now, by
(6) and
(7) especially, the sys-
tems (L(L, ¯EI1,Fk)I)I∈I1 and (L(L,E2
I2,Fk)I)I∈I2 are
uniformly monotonic parameterised and self-similar.
These are the two cases of the guiding example where the
concurrency of the execution of requests is bounded by k.
Theorem 4 is the main result for constructing well-
behaved scalable systems deﬁned by a single synchronisa-
tion condition. The following section shows how this result
together with the Intersection Theorem can be used for
constructing more complex well-behaved scalable systems
deﬁned by the combination of several synchronisation
conditions, as for example well-behaved scalable systems
consisting of several component types.
V. Well-behaved Scalable Systems Generated
by a Family of Influence Structures
Up to now, the examples were considered at an
abstraction level, which takes into account only the
actions of the server (or the servers, depending on the
choice of the parameter structure).
Example 11. For a ﬁner abstraction level, which addi-
tionally takes into account the actions of the clients, a
ﬁner alphabet, e.g., ˇΣ = {ac,bc,as,bs} and a preﬁx closed
language ˇS ⊂ ˇΣ∗ is needed, which, e.g., is deﬁned by the
automaton in Fig. 4(b).
In general, a ﬁner relation for system speciﬁcations at
diﬀerent abstraction levels can be deﬁned by alphabetic
language homomorphisms.
Deﬁnition 13 (abstractions). In general, let ˇL ⊂ ˇΣ∗ and
L ⊂ Σ∗ be preﬁx closed languages. We call ˇL ﬁner than
L or L coarser than ˇL iﬀ an alphabetic homomorphism
ν : ˇΣ∗ → Σ∗ exists with ν(ˇL) = L.
37
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-319-3
ICONS 2014 : The Ninth International Conference on Systems

For each parameter structure I and I ∈ I ν deﬁnes
an homomorphism νI : ˇΣ∗
I → Σ∗
I by νI(ai) := (ν(a))i for
a ∈ ˇΣ and i ∈ I, where (ε)i := ε.
Let now EI be an inﬂuence structure for I indexed
by N which is the base of I, and let ∅ ̸= L ⊂ V ⊂ Σ∗ be
preﬁx closed. (L(L,EI,V )I)I∈I induces a restriction of
the concurrency in ( ˙L(ˇL)I)I by the intersections
˙L(ˇL)I ∩(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )] for each I ∈ I. (9)
If ˇτ I
I′ : ˇΣ∗
I → ˇΣ∗ is deﬁned analogously to τ I
I′ for I,I′ ⊂
N by
ˇτ I
I′(ai) =
 a |
a ∈ ˇΣ and i ∈ I ∩I′
ε |
a ∈ ˇΣ and i ∈ I \I′
,
then holds τ I
I′ ◦νI = ν ◦ ˇτ I
I′. From this it follows that
(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )] =
\
t∈N
(ˇτ I
E(t,I))−1(ν−1(V ))
and therewith
˙L(ˇL)I ∩(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )] = L(ˇL,EI,ν−1(V ))I
(10)
for each I ∈ I. Notice that ∅ ̸= ˇL ⊂ ν−1(V ) ⊂ ˇΣ∗ is preﬁx
closed. So if (L(L,EI,V )I)I∈I fulﬁls the assumptions of
Theorem 3, then this holds for (L(ˇL,EI,ν−1(V ))I)I∈I
as well and the system
( ˙L(ˇL)I ∩(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )])I∈I,
(11)
which is deﬁned by the intersections (9), is a scalable
system. The following general theorem can be used to
prove self-similarity of such systems.
Theorem 5 (inverse abstraction theorem). Let ϕ : Σ∗ →
Φ∗ be an alphabetic homomorphism and W,X ⊂ Φ∗, then
SP(W,X) implies SP(ϕ−1(W),ϕ−1(X)).
Generally,
by
(8),
SP(ν−1(L),ν−1(V ))
implies
SP(X,ν−1(V ))
for
each
X ⊂ ν−1(L).
Especially
SP(ˇL,ν−1(V )) is implied by SP(L,V ) on account of
Theorem 5. So, by Theorem 5, if (L(L,EI,V )I)I∈I fulﬁls
the assumptions of Theorem 4, then
(L(ˇL,EI,ν−1(V ))I)I∈I
= ( ˙L(ˇL)I ∩(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )])I∈I
(12)
is a well-behaved scalable system.
The intersections in (9) formalise restriction of con-
currency in ( ˙L(ˇL)I)I∈I under one speciﬁc aspect (one
speciﬁc synchronisation condition), which is given by
ν, EI, and V . Restriction of concurrency under several
aspects (several synchronisation conditions) is formalised
by the intersections
˙L(ˇL)I ∩
\
r∈R
(νI
r )−1[
\
t∈N
(τ I
Er(t,I))−1(Vr)]
for each I ∈ I based on N, R ̸= ∅ is the index set of the
aspects. The family of aspects restricting concurrency is
given by
• a family (νr)r∈R of alphabetic homomorphisms νr :
ˇΣ∗ → Σ(r)∗ for r ∈ R,
• a family (Er
I)r∈R of inﬂuence structures Er
I =
(Er(t,I))(t,I)∈N×I indexed by N for r ∈ R, and
• a family (Vr)r∈R of inﬂuence behaviours Vr ⊂ Σ(r)∗
for r ∈ R.
From (10) it follows now
˙L(ˇL)I ∩
\
r∈R
(νI
r )−1[
\
t∈N
(τ I
Er(t,I))−1(Vr)]
=
\
r∈R
L(ˇL,Er
I,ν−1
r
(Vr))I
for each I ∈ I. Because of the intersection theorem, the
uniform monotonic parameterisation and self-similarity
of the system
( ˙L(ˇL)I ∩
\
r∈R
(νI
r )−1[
\
t∈N
(τ I
Er(t,I))−1(Vr)])I∈I
(13)
can be inferred from respective properties of the systems
(L(ˇL,Er
I,ν−1
r
(Vr))I)I∈I for each r ∈ R.
Using (11) and (12), this requires the veriﬁcation of
the assumptions of Theorem 4 for
(L(νr(ˇL),Er
I,Vr)I)I∈I
for each r ∈ R. If I is based on N =×
k∈K
Nk, where K
is a ﬁnite set and each Nk is countable, then along the
lines of I2, a parameter structure IK can be deﬁned
for this domain. Such IK ﬁt for systems consisting of
ﬁnitely many component types. Each subset K′ ⊂ K
with ∅ ̸= K′ ̸= K deﬁnes a bijection between N and
(×
k∈K′
Nk) × ( ×
k∈K\K′
Nk). By this bijection, for each of
these K′ an inﬂuence structure EK′
IK is deﬁned like E2
I2
that satisﬁes the assumptions of Theorem 3 with respect
to an isomorphism structure BK
IK deﬁned like E2
I2.
VI. Conclusions and Further Work
This paper presented a formal framework to construct
well-behaved scalable systems. The basic parts of that
framework are formalisations of parameter structures,
inﬂuence structures and isomorphisms structures. To-
gether with so-called prototype systems and behaviours
of inﬂuence these structures formally deﬁne scalable sys-
tems, if certain conditions are fulﬁlled. Scalable systems
38
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-319-3
ICONS 2014 : The Ninth International Conference on Systems

are called well-behaved, iﬀ their behaviour is self-similar.
A suﬃcient condition for such self-similarity is given in
terms of prototype systems and behaviours of inﬂuence.
A deeper analysis of this condition is subject of a
forthcoming paper of the authors. One of our motivations
for the formal deﬁnition of well-behaved scalable systems
was the veriﬁcation of behaviour properties. Usually,
behaviour properties of systems are divided into two
classes: safety and liveness properties [23]. Intuitively,
a safety property stipulates that “something bad does
not happen” and a liveness property stipulates that
“something good eventually happens”. In [5], it is shown,
that for well-behaved scalable systems a wide class of
safety properties can be veriﬁed by ﬁnite state methods.
To extend this veriﬁcation approach to reliability or
general liveness properties, additional assumptions for
well-behaved scalable systems have to be established. In
[24], such assumptions have been developed for uniformly
parametrised two-sided cooperations. To generalise these
ideas to a wider class of well-behaved scalable systems is
subject of further work.
Acknowledgement
Roland Rieke developed the work presented here in
the context of the projects MASSIF (ID 257475) being
co-funded by the European Commission within FP7 and
the project ACCEPT (ID 01BY1206D) being funded by
the German Federal Ministry of Education and Research.
References
[1] A. B. Bondi, “Characteristics of scalability and their
impact on performance,” in Workshop on Software and
Performance, 2000, pp. 195–203.
[2] S. Bullock and D. Cliﬀ, “Complexity and emergent
behaviour in ICT systems,” Hewlett-Packard Labs, Tech.
Rep. HP-2004-187, 2004.
[3] J.
Weinman,
“Axiomatic
Cloud
Theory,”
http://www.joeweinman.com/Resources/Joe_
Weinman_Axiomatic_Cloud_Theory.pdf,
July
2011, [retrieved: Dec, 2013].
[4] P. Zegzhda, D. Zegzhda, and A. Nikolskiy, “Using graph
theory for cloud system security modeling,” in Computer
Network Security, ser. LNCS, I. Kotenko and V. Skormin,
Eds.
Springer, 2012, vol. 7531, pp. 309–318.
[5] P. Ochsenschläger and R. Rieke, “Security properties
of self-similar uniformly parameterised systems of coop-
erations,” in Parallel, Distributed and Network-Based
Processing (PDP), 2011 19th Euromicro International
Conference on, 2011, pp. 640–645.
[6] S. Schneider, “Security Properties and CSP,” in IEEE
Symposium on Security and Privacy.
IEEE Computer
Society, 1996, pp. 174–187.
[7] A. Avizienis, J.-C. Laprie, B. Randell, and C. E.
Landwehr, “Basic concepts and taxonomy of dependable
and secure computing,” IEEE Trans. Dependable Sec.
Comput., vol. 1, no. 1, 2004, pp. 11–33.
[8] C. N. Ip and D. L. Dill, “Verifying Systems with Repli-
cated Components in Murϕ,” Formal Methods in System
Design, vol. 14, no. 3, 1999, pp. 273–310.
[9] F. Derepas and P. Gastin, “Model checking systems of
replicated processes with SPIN,” in Proceedings of the
8th International SPIN Workshop on Model Checking
Software (SPIN’01), ser. LNCS, M. B. Dwyer, Ed., vol.
2057.
Toronto, Canada: Springer, 2001, pp. 235–251.
[10] Y. Lakhnech, S. Bensalem, S. Berezin, and S. Owre,
“Incremental veriﬁcation by abstraction,” in TACAS, ser.
Lecture Notes in Computer Science, T. Margaria and
W. Yi, Eds., vol. 2031.
Springer, 2001, pp. 98–112.
[11] S. Basu and C. R. Ramakrishnan, “Compositional anal-
ysis for veriﬁcation of parameterized systems,” Theor.
Comput. Sci., vol. 354, no. 2, 2006, pp. 211–229.
[12] R. Milner, Communication and Concurrency, ser. Inter-
national Series in Computer Science.
NY: Prentice Hall,
1989.
[13] J. C. Bradﬁeld, “Introduction to modal and temporal
mu-calculi (abstract),” in CONCUR, ser. Lecture Notes
in Computer Science, L. Brim, P. Jancar, M. Kretínský,
and A. Kucera, Eds., vol. 2421.
Springer, 2002, p. 98.
[14] T. E. Uribe, “Combinations of Model Checking and
Theorem Proving,” in FroCoS ’00: Proceedings of the
Third International Workshop on Frontiers of Combining
Systems.
London, UK: Springer, 2000, pp. 151–170.
[15] E. M. Clarke, M. Talupur, and H. Veith, “Environment
abstraction for parameterized veriﬁcation,” in VMCAI,
ser. Lecture Notes in Computer Science, E. A. Emerson
and K. S. Namjoshi, Eds., vol. 3855.
Springer, 2006, pp.
126–141.
[16] M. Talupur, “Abstraction techniques for parameterized
veriﬁcation,” Ph.D. dissertation, Computer Science De-
partment, Carnegie Mellon University, 2006, CMU-CS-
06-169.
[17] K. R. Apt and D. C. Kozen, “Limits for automatic veri-
ﬁcation of ﬁnite-state concurrent systems,” Inf. Process.
Lett., vol. 22, no. 6, May 1986, pp. 307–309.
[18] I. Suzuki, “Proving properties of a ring of ﬁnite-state
machines,” Inf. Process. Lett., vol. 28, no. 4, Jul. 1988,
pp. 213–214.
[19] P.
Ochsenschläger
and
R.
Rieke,
“Proofs
for:
Construction
Principles
for
Well-behaved
Scalable
Systems,”
http://private.sit.fraunhofer.de/~rol/
Proofs-Well-behaved-Scalable-Systems.pdf,
2013,
[retrieved: Dec, 2013].
[20] J. Sakarovitch, Elements of Automata Theory.
Cam-
bridge University Press, 2009.
[21] K. Falconer, Fractal Geometry: Mathematical Founda-
tions and Applications.
Wiley, 2003.
[22] N. Agoulmine, Autonomic Network Management Princi-
ples: From Concepts to Applications.
Elsevier Science,
2010.
[23] B. Alpern and F. B. Schneider, “Deﬁning liveness,”
Information Processing Letters, vol. 21, no. 4, October
1985, pp. 181–185.
[24] P. Ochsenschläger and R. Rieke, “Reliability Aspects
of Uniformly Parameterised Cooperations,” in ICONS
2012, The Seventh International Conference on Systems,
Reunion Island.
IARIA, 2012, pp. 25–34.
39
Copyright (c) IARIA, 2014.     ISBN:  978-1-61208-319-3
ICONS 2014 : The Ninth International Conference on Systems

