Secret Key Sharing and Rateless Coding for
Practical Secure Wireless Transmission
Wei Liu†1, Chunjie Duan‡, Yige Wang‡, Toshiaki Koike-Akino‡, Ramesh Annavajjala‡, and Jinyun Zhang‡
† Department of EECS, Syracuse University, Syracuse, NY 13244, USA
‡ Mitsubishi Electric Research Laboratories (MERL), Cambridge, MA 02139, USA
Email: wliu28@syr.edu, {duan, yigewang, koike, annavajjala, zhang}@merl.com
Abstract—We discuss a secure wireless communication scheme,
focusing on designing two major components: the key generation
and the coding scheme. To achieve high key matching rate,
we propose a feed-forward and feed-back quantization. The
proposed scheme offers 1 dB improvement over the best known
schemes. We also propose a universal quantization scheme
with feed-forward/feed-back and show that its performance is
the same as, or better than the other schemes which require
prior distribution information. For rate-adaptive coding, we
propose the use of rateless codes. Our evaluations show that
the rateless code can offer signiﬁcant performance gain over a
low-density parity-check (LDPC) code. Moreover, we implement
a soft input rateless decoder which offers additional gains. The
overall security performance of our design based on these two
components signiﬁcantly outperforms existing designs.
Keywords - Secret key generation; Wireless communica-
tions; Quantization; Rateless codes; Rate compatible codes.
I. INTRODUCTION
A security system is only as good as its weakest part, fre-
quently, the Key Management System (KMS), which consists
of the key management, key derivation, storage and distribution
[20]. Unfortunately, designing a good KMS is an extremely
hard problem and not all designers agree on how to construct it.
This problem is exacerbated with the current trend of moving
into the “Internet of Things” and ”cyber physical systems”,
where large scale, complex, ad-hoc, often infrastructure-less
wireless sensor networks and the broadcast nature of the
channels makes the problem much harder to tackle.
Most commonly used key management techniques are based
on public key cryptography and requires a Public key Infras-
tructure (PKI). PKI is generally not suitable for ad-hoc systems
where a) infrastructure is not guaranteed; b) key derivation
functions are computation intensive and therefore cannot be
carried out in low power and low cost devices such as wireless
sensor nodes; and c) designing a key storage scheme that
survives frequent system and node reboot is also challenging.
Physical-Layer Security (PLS) has been proposed [23, 24]
with the hope to address this problem. It is envisioned that by
establishing security at the physical or link layer, a network
wide KMS is no longer needed, or can be greatly simpliﬁed
and we can potentially remove the requirement of having a PKI
in the network, that would result in a simple and cost/power
efﬁcient yet secure network.
Most of the PLS schemes proposed so far fall into two
categories: a) generating secret keys from correlated sources
1This work is done during the author’s internship at MERL
based on wireless channel reciprocity, and then applying tradi-
tional cryptography and b) adapting transmission rate to the
information-theoretic channel capacity to achieve a positive
secrecy capacity.
In the former category, where Alice and Bob try to generate a
pair of secret keys based on correlated observations X n and Y n
respectively, as illustrated in Fig. 1. Assume that Alice and Bob
can communicate through an unauthenticated public channel
which might be observed by an eavesdropper, Eve, who might
have side information Z n which can be correlated with X n
and Y n. The information-theoretical study of this problem
was provided by Maurer [1] and Ahlswede and Csisz´ar [2],
where the secrecy capacity deﬁned as the maximum key
generation rate is given for the special case when Eve has
no side information Z n, and lower bounds and upper bounds
on the secrecy capacity are provided for general cases. While
the theoretical aspects of this problem are well understood,
there is a growing interest in designing practical secret key
generation algorithms to approach the secrecy capacity of the
key generation rate.
One way to design such algorithms is to exploit the inherent
randomness in the wireless channel between two nodes as the
source for extracting secret key sequences [3–12]. The security
of these schemes relies on the reciprocity principle of the radio
wave propagation which states that the multipath properties
of the radio channel such as channel gains, phase shifts and
delays at any point in time are identical in both direction of
the communication link [8]. In addition, these properties are
intrinsically spatially speciﬁc in a multipath radio environment
due to the scatter effects. An eavesdropper at a third location
more than a few wavelengths away from the two legitimated
users will observe a different and uncorrelated radio channel
[13]. As a result, the two legitimated users can generate a secret
key based on the shared common randomness which is unavail-
able to the eavesdropper. Among these schemes, channel gain
information [4, 5, 7–12] is the most commonly used. Most of
these existing algorithms on key generation from channel gain
measurements consist three steps: quantization, information
reconciliation [14], and privacy ampliﬁcation [15]. The purpose
of quantization is to convert the real channel measurements
into binary bit strings. Information reconciliation is aimed
at generating an identical random sequence between the two
legitimated users by communicating through the public channel
and privacy ampliﬁcation is used to extract a perfect secure key
from the identical random sequence agreed in the information
reconciliation stage. As the foundation of the whole process,
348
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

designing a good quantization algorithm is crucial. In this
paper, we focus on the quantizer design. The purpose is to
generate two binary sequences at two legitimated users with
bit mismatch rate as small as possible.
Traditional quantization schemes such as equiprobable quan-
tization [4] and level crossing quantization [7] have the lim-
itation of high bit mismatch probability or low key genera-
tion rate. Moreover, these quantization schemes do not take
advantage of the public channel. Recently, Wallace et al.
[16] proposed a new quantization algorithm utilizing a one-
way communication over the public channel and achieved a
signiﬁcant improvement in the bit mismatch probability. The
over-quantization algorithm proposed in [12] used a similar
idea to achieve higher key generation rate within 1.1 bits from
the secret key capacity.
Schemes in the latter category are all based on the principle
that data transmitted at a rate exceeding the channel capacity
cannot be decoded by the receiving end. Many papers derive
the secrecy capacity for various channels including wire-
tap channels [21], broadcast channels [22], multiple access
channels [26], relay broadcast channels [24], fading channels
[23], etc. Fundamentally, to achieve a positive secrecy capacity,
it is required that the channel capacity of the eavesdroppers
be lower than that of the intended receivers. This limits the
practicality of these types of schemes, as it is nearly impossible
to guarantee such a condition in wireless environment. Some
attempts have been made to address this. For instance, Pinto et
al. showed in [27] that if physical security can be guaranteed
(e.g., a small area around the intended receiver is secured
from eavesdroppers), secrecy capacity is improved. Advanced
transmission schemes are also proposed to improve the secrecy
capacity, e.g., the secrecy capacity improvement with MIMO
precoding is analyzed in [25]. Beamforming and artiﬁcial
jamming noise injection are shown to improve the secrecy
capacity [28], with the assumption that certain knowledge of
the eavesdropper’s channel is available to the transmitter.
To the best of our knowledge, however, there is yet a
practical way of guarantees that legitimate receivers have
favorable channels, and the research in this area suffers from
being limited to mostly just theoretical analysis.
In this paper, we propose a secure transmission scheme by
combining both ideas. The nodes ﬁrst carry out key generation
using the quantization schemes that offers high bit matching
rate (BMR), and then carry out secure transmissions by scram-
bling data to create an artiﬁcial channel that is favorable to the
legitimate node pairs, and then apply rate adaptive coding with
a rate tightly coupled to instantaneous capacity.
The ﬁrst focus of the design is the key generation process,
in particular, quantization schemes that allow an independently
generated keys pair to have high BMR. Motivated by the
theoretical analysis in [1,2], we propose a quantization algo-
rithm by exploiting the public channel through two-way com-
munications; more speciﬁcally, feed-forward and feed-back
quantization. For the case that the channel measurements are
Gaussian distributed, the proposed algorithm improves around
1 dB at high signal-to-noise ratio (SNR) over the best known
scheme [16]. Moreover, we propose a universal quantization
scheme with feed-forward and feed-back for the general case
Xn
Yn
Alice
Bob
X
Y
Z
Eve
Zn
Fig. 1.
Secret key sharing between Alice and Bob.
when the two end nodes do not know the prior distribution. It is
demonstrated through simulations that the proposed universal
scheme works asymptotically close to the case with known
prior information.
The second focus of the design is the transmission scheme,
where we propose applying channel scrambling and rateless
coding to achieve the maximum achievable secrecy capacity.
The key management of PLS scheme proposed in this paper
is simple, as the link keys are generated locally between two
communicating nodes and are used locally. A node only need to
store and update the keys to its immediate (one hop) neighbors.
PLS schemes such as the one discussed in this paper can be
seamlessly integrated with existing security mechanisms in the
upper layer to enhance the overall security level of wireless
systems.
The rest of the paper is organized as follows. Section II gives
an overview of the transmission scheme and the node design. In
Section III, we introduce the system model for key generation.
Section IV introduces the new quantization algorithm which
uses the feed-forward and feed-back scheme. The universal
quantization scheme is detailed in Section V. Coding with
rateless codes is discussed in Section VI. We conclude this
paper in Section VII.
II. SECURE TRANSMISSION WITH MISMATCHING KEYS
The transmitter and the receiver under consideration have the
structure shown in Fig. 2. Both legitimate nodes, Alice and
Bob, implement a Key Generator block. Each key generator
produces a secret key string, i.e., KA and KB. The transmitter
encodes a message M with an inner code and then scrambles
the coded message C with its secret key, KA. The scrambled
data S will be transmitted directly, or alternatively, coded
with an outer code before being transmitted over the wireless
channel.
Correspondingly, a decoder implemented in the receiver to
decode the outer code is necessary. The receiver descrambles
the output of the outer decoder RB with the secret key gener-
ated by its own key generator, KB, and feed the descrambled
message CB to its inner code decoder. The receiver’s inner
decoder decodes the message. We also assume Eve has full
knowledge of the transmission scheme and is equipped with
the same functional block as in a legitimate receiver. Eve may
be able to produce a key, KE, descramble and decode the
receiver message.
In the proposed receiver, rate adaptive codes are used as
the inner code to maximize the secrecy capacity. We focus
on the performance of rateless codes in this paper. During
349
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

HAB
INNER
RATE
ADAPTIVE
ENCODER
KA
NACK/ACK
M
C
MB
SCBL
feedback
Alice
Bob
Eve
~
KEY
GENERATOR
OPTIONAL
OUTERCODE
ENCODER
S
INNER
DECODER
KB
C
DEͲSCBL
KEY
GENERATOR
OPTIONAL
OUTERCODE
ENCODER
RB
SB
ME
INNER
DECODER
KE
DEͲSCBL
KEY
GENERATOR
OPTIONAL
OUTERCODE
ENCODER
RE
SE
~
HAE
Fig. 2.
Transmitter and receiver structures.
the transmission of a message M, the transmitter’s encoder
continues sending out the coded stream S until the receiver has
successfully decoded the message, ˜
M. A feedback channel is
needed for the receiver to send an acknowledgement (ACK)
or a negative ACK (NACK) back to the transmitter. The
mechanism of rateless codes guarantees that the rate of the
transmission matches the instantaneous capacity.
The process of key generation needs to be carried out before
any secure data transmissions. Alice and Bob ﬁrst perform key
generations. Both nodes transmit sounding signals alternatively
to enable the other side to perform channel estimations. Key
pairs need to be updated periodically but not necessary at
every data transmission. The update frequency is determined
by the overhead. In most cases, the data packets are preceded
by preambles so that the receiver can estimate the channel
for coherent detections. Therefore, this allows the key gen-
eration/update be integrated into the transmission period and
further reduces the overhead.
The overall secrecy capacity of such a scheme is determined
by two factors:
1) The difference of the key matching rates
2) The closeness of the coding rate
The former item dictates the maximum secrecy capacity while
the latter item affects the achievable secrecy capacity. They
both need to be optimized such that overall security can be
maximized. The following sections describe how they can be
optimized separately.
III. SECRET KEY GENERATION
A. Secret Key Generation Based on Channel Measurements
Alice and Bob want to share a secret key by measuring the
channel response between them. With a channel reciprocity,
the channel estimates of Alice and Bob are highly correlated.
We can model Alice and Bob’s observations, X n and Y n, as
independent and identically distributed (i.i.d.) n repetitions of
dependent random variables, X and Y , from a joint distribution
f(X, Y ). Based on those correlated observations X n and Y n,
Alice and Bob generate a secret key by communicating over
a public channel, while the messages transmitted through the
public channel may be observed by eavesdroppers. We assume
that the eavesdropper, Eve, can only observe the channel with-
out any message modiﬁcations, i.e., a passive eavesdropper.
The messages transmitted through the channel (possibly two
way) are denoted as V.
In this paper, we focus on the case when X and Y are jointly
Gaussian; more speciﬁcally,
X = G + WA,
Y = G + WB,
(1)
where G ∼ N(0, P), WA ∼ N(0, NA) and WB ∼ N(0, NB)
denote the channel response, the estimation error at Alice and
the estimation error at Bob, respectively. For simplicity, we
consider the case of NA = NB = N.
IV. QUANTIZATION WITH FEED-FORWARD AND
FEED-BACK
In this section, we discuss a quantization-based key gener-
ation algorithm. We use a core quantization module based on
a scalar equiprobable quantizer because of its lightweight and
its property of maximum entropy.
A. Algorithm Description
Our secure key sharing algorithm consists of the following
ﬁve steps.
1) Initialization phase: Alice and Bob agree on the quan-
tization level L and the feed-forwarding level m. Both Alice
and Bob use the same equiprobable scalar quantizer, which is
designed for a zero-mean and unit-variance Gaussian random
variable. For the L-level quantizer, the quantization boundary
qi to indicate L intervals, (q0, q1], (q1, q2], · · · , (qL−1, qL), is
chosen such that [4]
Q(qi) ≜
 ∞
qi
1
√
2π exp

−x2
2

dx = L − i
L
,
(2)
for any i ∈ ZL, where Q(·) denotes the Gaussian tail function
and ZL ≜ {0, 1, · · · , L − 1} denotes an integer set. Here, we
350
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

set q0 = −∞ and qL = ∞. Gray coding is used for mapping
the quantizer indices to bits.
For generating feed-forwarding information, each quantiza-
tion interval (qi−1, qi] is further split into m sub-intervals,
(ti−1,0, ti−1,1], (ti−1,1, ti−1,2], · · · , (ti−1,m−1, ti−1,m], where
ti−1,0 = qi−1 and ti−1,m = qi, such that each sub-interval
(ti−1,k, ti−1,k+1] for k ∈ Zm has an identical probability of
Q(ti−1,k) − Q(ti−1,k+1) =
1
mL.
(3)
For each sub-interval, we index them by 0, 1, · · · , m − 1 in an
ascending order.
2) Channel sounding phase: Alice and Bob sequentially
send known training signals to each other in order to measure
the channel between Alice and Bob. Given each channel
estimate Xi and Yi for any i ∈ Nn (where n denotes the total
number of measurement times), Alice and Bob individually
quantize them into log2(L)-bit indices KA(i) and KB(i),
using the L-level equiprobable scalar quantizer. Note that the
quantization is done with a power normalization of β =
1
√P +N
to have unity variance for quantizing data. The quantized data
at i ∈ Nn is then given as
KA(i) =

j : βxi ∈ (qj, qj+1]

,
KB(i) =

j : βyi ∈ (qj, qj+1]

,
(4)
where Nn ≜ {1, 2, . . ., n} is a positive integer set. After n
observations, Alice and Bob obtain n log2(L)-bit quantized
information, KA = [KA(1), KA(2), · · · , KA(n)] and KB =
[KB(1), KB(2), · · · , KB(n)], respectively.
3) Feed-forward phase: Alice generates a log2(m)-bit feed-
forwarding data Va(i) from Xi such that Va(i) is the sub-
interval index of the interval KA(i), more speciﬁcally, we can
write Va(i) for any i ∈ Nn as follows:
Va(i) =

j : βxi ∈ (tKA(i),j, tKA(i),j+1]

.
(5)
Through the public channel, Alice then sends an n log 2(m)-bit
message, Va = [Va(1), Va(2), · · · , Va(n)] towards Bob where
each sub-interval index Va(i) can be expressed by its binary
natural code representation with log2(m) bits. We propose one
additional step termed feed-back phase to further improve the
bit mismatch rate.
4) Feed-back phase: Upon receiving the feed-forward in-
formation Va from Alice and his own observation Y n, Bob
employs a maximum a posteriori probability (MAP) estimation
of KA. In the MAP estimation, for each Yi = yi and Vai = vai
(for any i ∈ Nn), Bob searches for the index ji such that
ji = argmax
j∈ZL
Pr

βXi ∈ (qj, qj+1)|Yi = yi, Vai = vai

.
(6)
With the MAP estimate ji and the original quantized data
KB(i), Bob generates feed-back information Vb(i) which is set
to be one if ji ̸= KB(i) and zero otherwise, for each i ∈ Nn.
The feed-back message Vb = [Vb(1), Vb(2), · · · , Vb(n)] of n
bits is sent to Alice through the public channel.
5) Key generation phase: Based on the feed-back message
Vb, Alice skips the corresponding KA(i) if Vb(i) = 1, for i ∈
Nn, and sets the remaining as her secret key KA. Similarly, for
each i ∈ Nn, Bob also skips the corresponding indices KB(i)
if Vb(i) = 1 and produce his secret key using the remaining
bits.
B. Discussions
1) MAP estimation: We call the algorithm described above
MAP with feed-back key generation algorithm. For the case
that Xn and Y n are jointly Gaussian as in (1), by noticing
that Pr(Vai = vai|Yi = yi) is a constant for given yi and vai,
we have
Pr(βXi ∈ (qj−1, qj]|Yi = yi, Va(i) = vai)
∝ Pr(βXi ∈ (qj−1, qj], Va(i) = vai|Yi = yi)
= Pr(βXi ∈ (tj−1,vai, tj−1,vai+1]|Yi = yi)
= Q
	 1
β tj−1,vai − μi
σi

− Q
	 1
βtj−1,vai+1 − μi
σi

,
(7)
where μi = ρyi, ρ =

P
P +N and σi =

(P + N)(1 − ρ2).
The last equality comes from the fact that (Xi|Yi = yi) ∼
N(μi, σ2
i ).
Hence, the MAP estimation in (6) is equivalent to ﬁnd the in-
dex j ∈ ZL such that interval (tj,vai, tj,vai+1] is the closest one
to μi = ρyi in the sense of Euclidean distance. Or equivalently,
Bob will decide ji = j ∈ ZL if yi ∈ (¯qj, ¯qj+1] = 1
ρ(˜qj, ˜qj+1],
where
˜qj =
⎧
⎪
⎨
⎪
⎩
1
2(tj−1,vai+1 + tj,vai),
1 ≤ j ≤ L − 2,
−∞,
j = 0,
∞,
j = L − 1.
(8)
We remark here that the process of ﬁnding new quantization
regions for Bob according to feed-forward bits is slightly
different from the one described in [16]. In [16], a middle
point as in (8) is chosen as the new quantization region while
the optimal one should multiply a coefﬁcient of
1
ρ.
The procedure of ﬁnding ji is illustrated in Fig. 3 for L = 4
and m = 2. Initial quantization codebook for both Alice and
Bob is (−∞, q1], (q1, q2], (q2, q3], (q3, ∞). The observations of
Alice and Bob are X and Y , respectively. In this example,
Alice will quantize her observation into a two-bit information
Ka = [0, 1] and send a feed-forwarding data Va = 0 towards
Bob. By observing Va = 0, Bob calculates his MAP codebook
(−∞, ¯q1], (¯q1, ¯q2], (¯q2, ¯q3], (¯q3, ∞) using (8), and ﬁnds ji = 1
to generate the feed-back information.
2) Security: Transmitting the messages Va and Vb through
the public channel does not result in release of information
about the secret key. This is because Va(i) is equiprobable,
namely Pr(Va(i) = vai) = 1/L, and Vb(i) indicates only the
positions of the skipped bits.
3) Simulation results: Fig. 4 shows the performance of the
algorithm described above (with 106 runs). As we can see from
this ﬁgure, interaction between two nodes signiﬁcantly im-
proves the key agreement performance in bit mismatch rate at
high SNR (higher than 10 dB), where SNR is deﬁned as P/N.
The introduction of feed-back phase brings approximately 1
dB gain over the scheme without feed-back. To compare the
performance with the result by Wallace et al. [16], we also
plot MAP without feed-back scheme in which the feed-back
step is dropped in the algorithm. The 1-bit feed-forwarding
in [16], though slightly different from the MAP without feed-
back scheme as discussed above, achieves almost the same
performance as the optimal MAP scheme. It is shown by
351
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

0
0
0
0
0
0
0
0
00
00
01
01
11
11
10
10
1
1
1
1
1
1
1
1
βX
βY
t0,1
t0,1
q1
q1
t1,1
t1,1
q2
q2
t2,1
t2,1
q3
q3
t3,1
t3,1
¯q1
¯q2
¯q3
Fig. 3.
MAP with feed-back quantizer.
0
5
10
15
20
25
30
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
SNR in dB
Bit Mismatch Rate
Bit mismatch rate for different quantization schemes
 
 
MAP with feed−back: m=2
MAP withoud feed−back: m=2
1 bit feedforwarding (Wallace et al)
Fig. 4.
Bit mismatch rate for 2-bits quantization.
simulation that the average number of skipped bits is relatively
small (less than 15%).
V. UNIVERSAL KEY GENERATION ALGORITHM
The algorithm described in the previous section assumes
prior knowledge of the joint distribution of X n and Y n is
available to the nodes. However, in most of the practical
applications, we might not have such information. In this
section, we deal with this issue by introducing a universal
key generation scheme in which no prior knowledge about the
underlying joint distribution is required. The core quantization
module is a universal equiprobable quantizer described below.
A universal equiprobable scalar quantizer for an arbi-
trarily distributed random sequence X n is a set of in-
tervals [q0, q1), [q1, q2), · · · , [qL−1, qL], and the boundary qi
(for i
∈
ZL) can be calculated as
follows. Let us
sort Xn
=
[X1, X2, · · · , Xn] into an ascending order
[X(1), X(2), · · · , X(n)] and dividing it into L intervals with
each interval containing equal number of X i’s, and then pick
the boundary points in an ascending order as q 0, q1, · · · , qL,
that is, q0 = X(1), q1 = X(⌊n/L⌋), · · · , qL = X(n).
A. Algorithm Description
The universal key generation algorithm is described in the
following steps. We suppose that Alice and Bob pre-agree on
the quantization level L and the feed-forward data level m.
1) Channel sounding phase: For each Xi and Yi (i ∈ Nn),
Alice and Bob quantize their estimated channel information
into log2(L)-bit data KA(i) and KB(i) using the universal
equiprobable scalar quantizer described above. Gray coding
is used for mapping the quantizer indices to bits. Notice
that, Alice and Bob’s quantization codebook might not be the
same. After n channel measurements, Alice and Bob obtain
an n log2(L)-bit data KA = [KA(1), KA(2), · · · , KA(n)] and
KB = [KB(1), KB(2), · · · , KB(n)].
2) Feed-forwarding
phase:
Alice
generates
feed-
fowarding
data
by
using
the
universal
equiprob-
able
quantizer
to
indicate
m-level
sub-intervals
[qi−1, ti−1,1), [ti−1,1, ti−1,2), · · · , [ti−1,m−1, qi). Let us index
the sub-intervals by 0, 1, · · · , m−1 for each sub-interval in an
ascending order. Alice then sends an n log2(m)-bit message,
Va = [Va(1), Va(2), · · · , Va(n)] towards Bob through the
public channel.
3) Feed-back phase: For each i ∈ Nn, using the feed-
forward data Va(i) = vai, Bob decides his estimation of Alice’s
index by ji = j ∈ ZL if yi ∈ (¯qj, ¯qj+1), where
¯qj =
⎧
⎪
⎨
⎪
⎩
median[tj−1,vai+1, tj,vai),
1 ≤ j ≤ L − 2,
−∞,
j = 0,
∞,
j = L − 1.
(9)
Here, the median operation of an ordered set (t j−1,vai+1, tj,vai)
as in (9) can be implemented by looking into the ordered
sequences [X(1), X(2), · · · , X(n)] and picking the middle point
such that it divides interval (tj−1,vai+1, tj,vai) into two sub-
regions with equal number of sequences. Notice that this is
a little different from (8) where a Euclidean middle point
of two boundaries of (tj−1,vai+1, tj,vai) is chosen. Bob then
sets Vb(i) = 1 if ji ̸= KB(i) and Vb(i) = 0 otherwise,
for each i ∈ Nn, and sends an n-bit feed-back message
Vb = [Vb(1), Vb(2), · · · , Vb(n)] to Alice through the public
channel.
4) Key generation phase: Using the feed-back message V b,
Alice skips the corresponding KA(i) if Vb(i) = 1 (for each
i ∈ Nn), and sets the remaining as her secret key. As for Bob,
for each i ∈ Nn, he skips the indices KB(i) if Vb(i) = 1 and
sets it as his secret key.
B. Simulation results
Fig. 5 plots the performance of the universal key generation
algorithm described above with 1-bit (i.e., m = 2) feed-
forwarding (with 105 runs). Here, we assume the underlying
joint distribution of X and Y is given by (1). To compare the
performance, we also present the result of MAP with feed-
back algorithm with m = 2 as in the previous section. As we
can see from the ﬁgure, the universal scheme works almost as
well as the MAP with feed-back scheme. Fig. 6 shows the per-
formance of the universal key generation algorithm when the
underlying source is uniformly distributed and the estimation
noise is assumed Gaussian. For this case, the universal scheme
outperforms the MAP with feed-back algorithm designed for
Gaussian priors as in Section III.
VI. SECURE CODING WITH RATELESS CODES
If a positive secrecy capacity can be established, it is
necessary that the transmitter shall transmit at a rate R that
352
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

0
5
10
15
20
25
30
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
SNR
BER
2bits SQ for Gaussian sources with Gaussian noise
 
 
MAP with feedback
Universal quantization with feedback
Universal quantization without feedback
Fig. 5.
BER for 2-bits universal quantization for Gaussian source.
0
5
10
15
20
25
30
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
SNR
BER
Universal quantization for uniform sources with Gaussian noise
 
 
MAP with feedback
Universal quantization with feedback
Universal quantization without feedback
Fig. 6.
BER for 2-bits universal quantization for uniform source.
equals the CAB to achieve the allowed maximum secrecy
capacity. Unfortunately, it is difﬁcult to estimate accurately
CAB, and moreover, the instantaneous capacity CAB(t) varies.
Automatic Repeat Request (ARQ) is generally used to deal
with instantaneous channel capacity variation. However, it is
inefﬁcient as information from previous transmission is thrown
away. Hybrid ARQ (HARQ) using rate-compatible codes com-
bines the original packet and the retransmitted packet(s) and is
slightly more efﬁcient. The issue with typical rate compatible
code is the large granularity of the effective rates, For instance,
a convolutional code may be punctured to obtain rates of
R = 7/8, R = 3/4 and R = 1/2. Certain degree of secrecy
capacity is sacriﬁced because of the coarse granularity.
Rateless codes, on the other hand, allows the transmitter
to gradually reduce the rate. Combining it with HARQ, we
can theoretically match the transmission rate to the exact
instantaneous capacity as the number of bits transmitted can
be arbitrarily small and we can adjust the rate at a much ﬁner
granularity.
A. Channel Scrambling for Positive Secrecy Capacity
To obtain positive secrecy capacity, the transmitter simply
scrambles the coded data stream with the key it produced
using the scheme discussed above. The received stream is
descrambled with the receiver’s key. This is similar to a one-
time pad encryption. Our scheme, however, does NOT require
keys to be exactly the same.
Note that in the case of a perfectly matched key pairs, the
output after descrambling is the original received message.
Mismatching bits in the keys will result in erroneous bits and
the scrambling-descrambling process is equivalent to a binary
symmetric channel (BSC), and the key mismatch rate is the
crossover rate of the BSC channel. Because the eavesdropper’s
channel has zero, or low correlation with the channel between
Alice and Bob, the crossover rate is much higher, and hence a
much worse channel for the eavesdropper.
The
artiﬁcial
BSC
channels
created
by
scrambling-
descrambling, can be combined with the wireless channels
between nodes, or treated separated if we insert an outer
channel code. For clarity, we consider the wireless channel
noise free in the following discussion.
B. Overview of Rateless Codes
Rateless codes, also known as Fountain codes, are a class of
codes with no ﬁxed coding rate. The transmitter can generate
a potentially limitless sequence of encoding symbols from
a given set of information symbols. The receiver starts to
decode after receiving a sufﬁcient number of symbols from the
channel. If it fails decoding, it will collect more symbols and
start decoding again. The process is repeated until decoding
succeeds. The transmitter keeps sending more symbols until
receiving an ACK of successful decoding from the receiver.
The number of symbols required for successful decoding
depends on the quality of the channel. Rateless codes are
especially useful for those cases where channel statistics are
not known and ﬁxed-rate codes do not work well.
The ﬁrst class of practical rateless codes, Luby Transform
(LT) codes [17], is invented in 1998. LT codes can be
represented by Tanner graph and decoded using the belief
propagation algorithm, like low-density parity-check (LDPC)
codes. Given k information symbols, an encoding symbol of
LT codes can be generated by ﬁrst picking a degree d at random
according to some distribution. Then select d distinct informa-
tion symbols uniformly and XOR them to form an encoding
symbol. The transmitter and the receiver should share the same
random seed so that the decoder could construct the same
code graph as the encoder. Luby shows the Robust Soliton
distribution has excellent performance on erasure channel, but
the disadvantage is that the decoding complexity is high, i.e.,
O(k ln k).
One problem with LT codes is that they exhibit an error ﬂoor
phenomenon. This can be ﬁxed by Raptor codes proposed by
Shokrollahi [18], which combine LT codes with outer LDPC
codes. Raptor codes show no noticeable error ﬂoors, however
their rate is slightly bounded away from capacity.
C. Code Parameters and Decoding Scheme
In this paper, we focus on LT codes with the following
degree distribution [18].
μ(x) = 0.007969x + 0.493570x2 + 0.166220x3 + 0.072646x4
+ 0.082558x5 + 0.056058x8 + 0.037229x9
+ 0.055590x19 + 0.025023x65 + 0.0003135x66.
(10)
The main advantage of this distribution is that its decoding
complexity grows only as O(k). However this leads to a small
353
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

fraction of information symbols that are not involved in any
encoding symbols. Then the bit error rate does not go to zero
even when k goes to inﬁnity. Nevertheless in practice, LT codes
with the degree distribution in (10) still work well.
Decoding LT codes is similar to LDPC codes. Since infor-
mation symbols are not transmitted, at the decoder side, they
do not have any observation, thereby no a priori information.
Different from information symbols, encoding symbols have a
priori information, which is denoted by log likelihood ratios
(LLRs) [29]:
L = ln Pr(s = 1|rc, rk)
Pr(s = 0|rc, rk),
(11)
where rc is the observation from the channel and rk is the
observation from the key. An a priori information is used for
the initialization of decoding. Let the LLRs of received data
from the channel be Lc and the LLRs of the key be Lk. Then,
we have [29]
L = 2 tanh−1
	
tanh
	Lc
2

tanh
	Lk
2


.
(12)
If the reliability of key is unknown, then K b can be treated
as error free, i.e., Lk is inﬁnity. For this case, (12) can be
rewritten as
L = (1 − 2Kb)Lc,
(13)
where Kb is the corresponding bit in the key string of the
receiver.
D. Simulation Results
We consider a time-variant channel and compare the per-
formance of a ﬁxed-rate LDPC code and an LT code with
the degree distribution in (10). In this simulation, we assume
the channel between Alice and Bob is a binary symmetric
channel (BSC) with crossover probability p. To consider the
time-variant property in wireless channels, we assume that p
is uniformly distributed over an interval of [0.01, 0.06], and
is ﬁxed for every 100 blocks while keep changing during the
entire simulation (105 blocks).
In each block, 1000 bits are transmitted using either an LT
code with or a ﬁxed-rate LDPC code, whose degree distribution
is optimized according to [19]. To make fair comparison, the
parameters of the time-variant channel are the same for both
codes. This can be achieved by saving the values of p in the
ﬁrst round of simulation and use it directly in the second round.
If decoding fails, the scheme using LT codes can request
more bits from the transmitter to achieve an arbitrary small
probability of decoding error. Hence, a reasonable procedure
is to set a retransmission threshold nt at the decoder side. If
the total number of received bits exceeds this threshold and
there are still bit errors, the decoder will report a block error.
Fig. 7 shows the simulation result of the two codes, wherein
the y-axis is the probability of block error and the x-axis is
the inverse of the code rate. For LDPC codes, we set a rate
of 0.65, 0.6 or 0.55, with an optimization degree [19]. For LT
codes, the rate is calculated using the average code-length in
the entire 105 blocks. Note that, if a block error is reported,
nt is chosen as the code-length in that block and a block
error is collected. In this ﬁgure, the red curve corresponds
1.5
1.55
1.6
1.65
1.7
1.75
1.8
1.85
1.9
10
−4
10
−3
10
−2
10
−1
10
0
1/R
Block error probability
Comparison of rateless code and LDPC code for BSC with p∈[0.01,0.06]
 
 
Rateless code
LDPC code
Rateless code with soft LLR
Fig. 7.
Comparison of LT code and LDPC code for p ∈ [0.01, 0.06].
2.1
2.2
2.3
2.4
2.5
2.6
2.7
2.8
2.9
3
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
1/R
Block error probability
Comparison of rateless code and LDPC code for BSC with p∈[0.06,0.11]
 
 
Rateless code
LDPC code
Rateless code with soft LLR
Fig. 8.
Comparison of LT code and LDPC code for p ∈ [0.06, 0.11].
to the case where the LLRs of the key are known while
the blue one corresponds to the case without key reliability
information. As we can see from the ﬁgure, the LT code
achieves better performance. The probability of block error
converges to zero much faster than the ﬁxed-rate LDPC code.
Moreover, key reliability information helps decoding and hence
achieves better performance. The same observation can be
made in another simulation where p is assumed to be uniformly
distributed in [0.06, 0.11] as shown in Fig. 8.
VII. CONCLUSION
We described a transceiver design which can improve
physical-layer security for practical wireless communications.
The design combines the channel reciprocity based key gener-
ation and rate-adaptive coding. The design does not require a
perfectly matched key pair. By scrambling the transmitted data
and de-scrambling the received data with the independently
generated keys, we guarantee the legitimate receiver to have
a preferable channel compared to eavesdroppers, therefore a
positive secrecy capacity.
To improve the overall security, we optimized the key gener-
ation and secure transmissions separately. The secrecy capacity
is maximized by minimizing key mismatch rate between two
legitimate nodes. We introduced the notion of feed-forward and
feed-back techniques into our quantizer design and proposed
an MAP estimator with feed-back quantization scheme that
achieves 1 dB improvement over the best known scheme in
354
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

the high SNR regimes. Moreover, for the cases that the two
legitimated nodes do not have any prior information about the
underling statistical distribution, we proposed a universal quan-
tization scheme with feed-forward and feed-back information.
It has been veriﬁed by simulations that the proposed universal
scheme can achieve the same performance as algorithms which
require prior information.
We then investigated the scheme of applying rateless codes
for secure transmissions. Rateless codes can potentially over-
come the uncertainty from the key generation as well as
channel variation. The performance of the proposed scheme is
compared with a ﬁxed-rate LDPC code. It is demonstrated in
the simulation that the proposed scheme achieves a signiﬁcant
improvement over LDPC codes.
REFERENCES
[1] U. Maurer, “Secret key agreement by public discussion from common
information,” IEEE Trans. Inf. Theory, vol. 39, no. 3, pp. 733–742, 1993.
[2] R. Ahlswede and I. Csiszar,
“Common randomness in information
theory and cryptography–part I: secret sharing,” IEEE Trans. Inf. Theory,
vol. 39, no. 4, pp. 1121—1132, 1993.
[3] A. A. Hassan, W. E. Stark, J. E. Hershey, and S. Chennakeshu, “Cryp-
tographic key agreement for mobile radio,”
Elsevier Digital Signal
Processing Magazine, vol. 6, pp. 207–212, 1996.
[4] C. Ye, A. Reznik, and Y. Shah, “Extracting secrecy from jointly Gaussian
random variables,” IEEE Int’l Symp. Inf. Theory, pp. 2593–2597, July
2006.
[5] R. Wilson, D. Tse, and R. A. Scholtz, “Channel identiﬁcation: secret
sharing using reciprocity in UWB channels,” IEEE Trans. Information
Forensics and Security, vol. 2, no. 3, pp. 364–375, Sept. 2007.
[6] A. Sayeed and A. Perrig,
“Secure wireless communications: secret
keys through multipath,” IEEE Int’l Conf. Acoustic, Speech & Signal
Processing (ICASSP), pp. 3013–3016, Apr. 2008.
[7] S. Mathur, W. Trappe, N. Mandayam, C. Ye, and A. Reznik, “Radio-
telepathy: extracting a secret key from an unauthenticated wireless
channel,” ACM SigMobile Int’l Conf. Mobile Computing and Networking
(Mobicom), Sept. 2008.
[8] S. Jana, S. P. Nandha, M. Clark, S. K. Kasera, N. Patwari, and
S. Krishnamurty, “On the effectiveness of secret key extraction using
wireless signal strength in real environments,”
ACM SigMobile Int’l
Conf. Mobile Computing and Networking (Mobicom), Sept. 2009.
[9] T. Aono, K. Higuchi, T. Ohira, B. Komiyama, and H. Sasaoka, “Wireless
secret key generation exploiting reactance-domain scalar response of
multipath fading channels,” IEEE Trans. Antennas Propagation, no. 53,
pp. 3776–3784, Nov. 2005.
[10] B. Azimi-Sadjadi, A. Kiayias, A. Mercado, and B. Yener, “Robust key
generation from signal envelopes in wireless networks,”
ACM Conf.
Computer and Communications Security, pp. 401–410, Nov. 2007.
[11] M. A. Tope and J. C. McEachen, “Unconditionally secure communi-
cations over fading channels,”
Military Communications Conference
(MILCOM), pp. 54–58, Oct. 2001.
[12] C. Ye, S. Mathur, A. Reznik, Y. Shah, W. Trappe, and N. B. Mandayam,
“Information-theoretically secret key generation for fading wireless chan-
nels,” IEEE Trans. Information Forensics and Security, vol. 5, no. 2,
pp. 240–254, June 2010.
[13] G. D. Durgin, “Space-Time Wireless Channels,” Prentice Hall, Upper
Saddle River, NJ, 2002.
[14] G. Brassard and L. Salvail, “Secret-key reconciliation by public discus-
sion,” Advances in Cryptology–EUROCRYPT, pp. 410–423, 1994.
[15] C. H. Bennett, G. Brassard, C. Crepeau, and U. Maurer, “Generalized
privacy ampliﬁcation,” IEEE Trans. Inf. Theory, vol. 41, no. 6, pp. 1915–
1923, Nov. 1995.
[16] J. W. Wallace, C. Chen, and M. A. Jensen, “Key generation exploiting
MIMO channel evolution: algorithms and theoretical limits,” European
Conf. Antennas and Propagation (EuCAP), Berlin, Germany, March
2009.
[17] M. Luby, “LT Codes,” 43rd Annual IEEE Symposium on Foundations
of Computer Science, 2002.
[18] A. Shokrollahi,
“Raptor codes,”
IEEE Transactions on Information
Theory, vol. 52 , no. 6, pp. 2551–2567, 2006.
[19] T. J. Richardson, M. A. Shokrollahi, and R. L. Urbanke, “Design of
capacity-approaching irregular low-density parity-check codes,”
IEEE
Transactions on Information Theory, vol. 47, no. 2, pp. 619–637, 2001.
[20] R. Moskowitz,
“Key management protocols-value, cost, and future
prooﬁng”, doc.: 15-10-0877-00-0hip-Turorial-KeyManagementProtocols,
Nov. 8, 2010. Last access Nov., 2010.
[21] A. D. Wyner “ The wire-tap channel”, The Bell System Technical Journal,
vol. 54, pp. 1355-1387, Oct. 1975.
[22] I. Csisz´ar and J. K¨orner,
“Broadcast channels with conﬁdential mes-
sages”, IEEE Trans. Inform. Theory, IT-24, no. 3, pp. 339-348, May
1978.
[23] Y. Liang, H. V. Poor, and S. Shamai (Shitz). “Secure communication over
fading channels”,
IEEE Transactions on Information Theory, Special
Issue on Information Theoretic Security, 54(6), 2470-2492, June 2008.
[24] Y. Liang and G. Kramer. “Rate regions for relay broadcast channels”,
IEEE Transactions on Information Theory, Special Issue on Models,
Theory and Codes for Relaying and Cooperation in Communication
Networks, 53(10), 3517-3535, Oct. 2007.
[25] T. Koike-Akino, A. F. Molisch, C. Duan, Z. Tao, and P. Orlik, “Capacity,
MSE and secrecy analysis of linear block precoding for distributed an-
tenna systems in multi-user frequency-selective fading channels”, IEEE
Transactions on Communications., Mar. 2011.
[26] R. Liu, I. Maric, R. D. Yates, and P. Spasojevic,
“The discrete
memoryless multiple access channel with conﬁdential messages”, IEEE
ISIT2006, Seattle, July 2006.
[27] Pedro C. Pinto, Joao Barros, and Moe Z. Win, “Secure Communication
in Stochastic Wireless Networks”, http://arxiv.org/abs/1001.3697, Jan.
2010. Last access date Oct., 2010.
[28] S. Goel and R. Negi, “Guaranteeing Secrecy using Artiﬁcial Noise”,
IEEE Transactions on Wireless Communications, vol. 7, no. 6, pp. 2180-
2189, June 2008
[29] John G. Proakis,
“Digital Communications”,
McGraw-Hill Sci-
ence/Engineering/Math; 4th edition, 2000
355
SENSORCOMM 2011 : The Fifth International Conference on Sensor Technologies and Applications
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-144-1

