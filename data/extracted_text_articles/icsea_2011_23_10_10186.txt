From Boolean Relations to Control Software
Federico Mari, Igor Melatti, Ivano Salvo, and Enrico Tronci
Department of Computer Science
Sapienza University of Rome
Via Salaria 113, 00198 Rome, Italy
Email: {mari,melatti,salvo,tronci}@di.uniroma1.it
Abstract—Many software as well digital hardware automatic
synthesis methods deﬁne the set of implementations meeting
the given system speciﬁcations with a boolean relation K. In
such a context a fundamental step in the software (hardware)
synthesis process is ﬁnding effective solutions to the functional
equation deﬁned by K. This entails ﬁnding a (set of) boolean
function(s) F (typically represented using OBDDs, Ordered
Binary Decision Diagrams) such that: 1) for all x for which K
is satisﬁable, K(x, F(x)) = 1 holds; 2) the implementation of
F is efﬁcient with respect to given implementation parameters
such as code size or execution time. While this problem has
been widely studied in digital hardware synthesis, little has
been done in a software synthesis context. Unfortunately the
approaches developed for hardware synthesis cannot be directly
used in a software context. This motivates investigation of
effective methods to solve the above problem when F has to
be implemented with software. In this paper, we present an
algorithm that, from an OBDD representation for K, generates
a C code implementation for F that has the same size as the
OBDD for F and a worst case execution time linear in nr,
being n = |x| the number of input arguments for functions in
F and r the number of functions in F.
Keywords-Control Software Synthesis; Embedded Systems;
Model Checking
I. INTRODUCTION
Many software as well digital hardware automatic synthe-
sis methods deﬁne the set of implementations meeting the
given system speciﬁcations with a boolean relation K. Such
relation typically takes as input (the n-bits encoding of) a
state x of the system and (the r-bits encoding of) a proposed
action to be performed u, and returns true (i.e., 1) iff the
system speciﬁcations are met when performing action u in
state x. In such a context a fundamental step in the software
(hardware) synthesis process is ﬁnding effective solutions to
the functional equation deﬁned by K, i.e., K(x, u) = 1. This
entails ﬁnding a tuple of boolean functions F = ⟨f1, . . . , fr⟩
(typically represented using OBDDs, Ordered Binary Deci-
sion Diagrams [1]) s.t. 1) for all x for which K is satisﬁable
(i.e., it enables at least one action), K(x, F(x)) = 1 holds,
and 2) the implementation of F is efﬁcient with respect
to given implementation parameters such as code size or
execution time.
While this problem has been widely studied in digital
hardware synthesis [2][3], little has been done in a software
synthesis context. This is not surprising since software
synthesis from formal speciﬁcations is still in its infancy.
Unfortunately the approaches developed for hardware syn-
thesis cannot be directly used in a software context. In
fact, synthesis methods targeting a hardware implementation
typically aim at minimizing the number of digital gates and
of hierarchy levels. Since in the same hierarchy level gates
output computation is parallel, the hardware implementation
WCET (Worst Case Execution Time) is given by the number
of levels. On the other hand, a software implementation will
have to sequentially compute the gates outputs. This implies
that the software implementation WCET is the number of
gates used, while a synthesis method targeting a software
implementation may obtain a better WCET. This motivates
investigation of effective methods to solve the above problem
when F has to be implemented with software.
In this paper we present an algorithm that, from an OBDD
representation for K, effectively generates a C code imple-
mentation for K that has the same size as the OBDD for F
and a WCET linear in linear in nr, being n = |x| the size
of states encoding and r = |u| the size of actions encoding.
This allows us to synthesize correct-by-construction control
software, provided that K is provably correct w.r.t. initial
formal speciﬁcations. This is the case of [4], where an algo-
rithm to synthesize K starting from the formal speciﬁcation
of a Discrete-Time Linear Hybrid System (DTLHS in the
following) is presented. Thus this methodology allows a
correct-by-construction control software to be synthesized,
starting from formal speciﬁcations for DTLHSs.
Note that the problem of solving the functional equation
K(x, F(x)) = 1 w.r.t. F is trivially decidable, since there
are ﬁnitely many F. However, trying to explicitly enumerate
all F requires time Ω(2r2n) (being n the number of bits
encoding state x and r the number of bits encoding state
u). By using OBDD-based computations, our algorithm
complexity is O(r2n) in the worst case. However, in many
interesting cases OBDD sizes and computations are much
lower than the theoretical worst case (e.g., in Model Check-
ing applications, see [5]).
Furthermore, once the OBDD representation for F has
been computed, a trivial implementation of F could use
a look-up table in RAM. While this solution would yield
a better WCET, it would imply a Ω(r2n) RAM usage.
Unfortunately, implementations for F in real-world cases are
528
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

typically implemented on microcontrollers (this is the case,
e.g., for embedded systems). Since microcontrollers usually
have a small RAM, the look-up table based solution is not
feasible in many interesting cases. The approach we present
here will rely on OBDDs compression to overcome such
obstruction.
Moreover, F : Bn → Br is composed by r boolean
functions, thus it is represented by r OBDDs. Such OBDDs
typically share nodes among them. If a trivial implementa-
tion of F in C code is used, i.e., each OBDD is translated as
a stand-alone C function, OBDDs nodes sharing will not be
exploited. In our approach, we also exploit nodes sharing,
thus the control software we generate fully takes advantage
of OBDDs compression.
Finally, we present experimental results showing effec-
tiveness of the proposed algorithm. As an example, in less
than 1 second and within 70 MB of RAM we are able
to synthesize the control software for a function K of
24 boolean variables, divided in n = 20 state variables
and r = 4 action variables, represented by a OBDD with
about 4 × 104 nodes. Such K represents the set of correct
implementations for a real-world system, namely a multi-
input buck DC/DC converter [6], obtained as described
in [4]. The control software we synthesize in such a case
has about 1.2×104 lines of code, whilest a control software
not taking into account OBDDs nodes sharing would have
had about 1.5 × 104 lines of code. Thus, we obtain a 24%
gain towards a trivial implementation.
This paper is organized as follows. In Section III we give
the basic notions to understand our approach. In Section IV
we formally deﬁne the problem we want to solve. In Sec-
tion V we give deﬁnition and main properties of COBDDs
(i.e., Complemented edges OBDDs), on which our approach
is based. Section VI describes the algorithms our approach
consists of. Finally, Section VII presents experimental results
showing effectiveness of the proposed approach.
II. RELATED WORK
Synthesis of boolean functions F satisfying a given
boolean relation K in a way s.t. K(x, F(x)) = 1 is also
addressed in [2]. However, [2] targets a hardware setting,
whereas we are interested in a software implementation
for F. Due to structural differences between hardware and
software based implementations (see the discussion in Sec-
tion I), the method in [2] is not directly applicable here. An
OBDD-based method for synthesis of boolean (reversible)
functions is presented in [3] (see also citations thereof).
Again, the method in [3] targets a hardware implementation,
thus it is not applicable here.
In [4], an algorithm is presented which, starting from
formal speciﬁcations of a DTLHS, synthesizes a correct-
by-construction boolean relation K, and then a correct-by-
construction control software implementation for K. How-
ever, in [4] the implementation of K is not described in
detail. Furthermore, the implementation synthesis described
in [4] has not the same size of the OBDD for F, i.e., it does
not exploit OBDD node sharing.
In [7], an algorithm is presented which computes boolean
functions F satisfying a given boolean relation K in a way
s.t. K(x, F(x)) = 1. This approach is very similar to ours.
However [7] does not generate the C code control software
and it does not exploit OBDD node sharing.
Therefore, to the best of our knowledge this is the ﬁrst
time that an algorithm synthesizing correct-by-construction
control software starting from a boolean relation (with the
characteristics given in Section I) is presented.
III. BASIC DEFINITIONS
In the following, we denote with B = {0, 1} the boolean
domain, where 0 stands for false and 1 for true. We will
denote boolean functions f
: Bn
→ B with boolean
expressions on boolean variables involving + (logical OR),
· (logical AND, usually omitted thus xy = x · y), ¯ (log-
ical complementation) and ⊕ (logical XOR). We will also
denote vectors of boolean variables in boldface, e.g., x =
⟨x1, . . . , xn⟩. Moreover, we also denote with f|xi=g(x) the
boolean function f(x1, . . . , xi−1, g(x), xi+1, . . . , xn) and
with ∃xi f(x) the boolean function f|xi=0(x)+f|xi=1(x).
Finally, we denote with [n] the set {1, . . . , n}.
1) Most General Optimal Controllers: A Labeled Tran-
sition System (LTS) is a tuple S = (S, A, T) where S is
a ﬁnite set of states, A is a ﬁnite set of actions, and T is
the (possibly non-deterministic) transition relation of S. A
controller for an LTS S is a function K : S × A → B
enabling actions in a given state. We denote with Dom(K)
the set of states for which a control action is enabled. An
LTS control problem is a triple P = (S, I, G), where S
is an LTS and I, G ⊆ S. A controller K for S is a strong
solution to P iff it drives each initial state s ∈ I in a goal
state t ∈ G, notwithstanding nondeterminism of S. A strong
solution K∗ to P is optimal iff it minimizes path lengths. An
optimal strong solution K∗ to P is the most general optimal
controller (we call such solution an mgo) iff in each state it
enables all actions enabled by other optimal controllers. For
more formal deﬁnitions of such concepts, see [8].
Efﬁcient algorithms to compute mgos starting from suit-
able (nondeterministic) LTSs have been proposed in the
literature (e.g., see [9]). Once an mgo K has been com-
puted, solving and implementing the functional equation
K(x, u) = 1 allows a correct-by-construction control soft-
ware to be synthesized.
2) OBDD Representation for Boolean Functions: A Bi-
nary Decision Diagram (BDD) R is a rooted directed acyclic
graph (DAG) with the following properties. Each R node
v is labeled either with a boolean variable var(v) (internal
node) or with a boolean constant val(v) ∈ B (terminal node).
Each R internal node v has exactly two children, labeled
with high(v) and low(v). Let x1, . . . , xn be the boolean
529
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

variables labeling R internal nodes. Each terminal node v
represents fv(x) = val(v). Each internal node v represents
fv(x) = xifhigh(v)(x) + ¯xiflow(v)(x), being xi = var(v).
An Ordered BDD (OBDD) is a BDD where, on each path
from the root to a terminal node, the variables labeling each
internal node must follow the same ordering.
IV. SOLVING A BOOLEAN FUNCTIONAL EQUATION
Let K(x1, . . . , xn, u1, . . . , ur) be the mgo for a given
control problem P = (S, I, G). We want to solve the
boolean functional equation K(x, u) = 1 w.r.t. variables u,
that is we want to obtain boolean functions f1, . . . , fr s.t.
K(x, f1(x), . . . , fr(x)) = K|u1=f1(x),...,ur=fr(x)(x, u) =
1. This problem may be solved in different ways, depending
on the target implementation (hardware or software) for
functions fi. In both cases, it is crucial to be able to bound
the WCET (Worst Case Execution Time) of the obtained
controller. In fact, controllers must work in an endless closed
loop with the system S (plant) they control. This implies
that, every T seconds (sampling time), the controller has to
decide the actions to be sent to S. Thus, in order for the
entire system (plant + control software) to properly work,
the controller WCET upper bound must be at most T.
In [2], f1, . . . , fr are generated in order to optimize
a hardware implementation. In this paper, we focus on
software implementations for fi (control software). As it
is discussed in Section I, simply translating an hardware
implementation into a software implementation would re-
sult in a too high WCET. Thus, a method directly tar-
geting software is needed. An easy solution would be
to set up, for a given state x, a SAT problem instance
C = CK1, . . . , CKt, c1, . . . , cn, where CK1 ∧ . . . ∧ CKt
is equisatisﬁable to K and each clause ci is either xi (if
xi is 1) or ¯xi (otherwise). Then C may be solved using a
SAT solver, and the values assigned to u in the computed
satisfying assignment may be returned as the action to be
taken. However, it would be hard to estimate a WCET for
such an implementation. The method we propose in this
paper overcomes such obstructions by achieving a WCET
proportional to rn.
V. OBDDS WITH COMPLEMENTED EDGES
In this section, we introduce OBDDs with complemented
edges (COBDDs, Deﬁnition 1), which were ﬁrst presented
in [10][11]. Intuitively, they are OBDDs where else edges
(i.e., edges of type (v, low(v))) may be complemented. Then
edges (i.e., edges of type (v, high(v))) complementation
is not allowed to retain canonicity. Edge complementation
usually reduce resources usage, both in terms of CPU and
memory.
Deﬁnition 1. An OBDD with complemented edges (COBDD
in the following) is a tuple ρ = (V, V , 1, var, low, high,
ﬂip) with the following properties: i) V = {x1, . . . , xn}
is a ﬁnite set of ordered boolean variables; ii) V
is a
ﬁnite set of nodes; iii) 1 ∈ V is the terminal node of
ρ, corresponding to the boolean constant 1 (non-terminal
nodes are called internal); iv) for each internal node v,
var(v) < var(high(v)) and var(v) < var(low(v)); v)
var, low, high, ﬂip are functions deﬁned on internal nodes,
namely: var : V \ {1} → V assigns to each internal node a
boolean variable in V, high[low] : V \ {1} → V assigns to
each internal node v a high child [low child] (or true child
[else child]), representing the case in which var(v) = 1
[var(v) = 0], ﬂip : V \ {1} → B assigns to each internal
node v a boolean value; namely, if ﬂip(v) = 1 then the else
child has to be complemented, otherwise it is regular (i.e.,
non-complemented).
COBDDs associated multigraphs: We associate to a
COBDD ρ = (V, V , 1, var, low, high, ﬂip) a labeled
directed multigraph G(ρ) = (V, E) s.t. V is the same set of
nodes of ρ and there is an edge (v, w) ∈ E iff w is a child of
v. Moreover, each edge e ∈ E has a type type(e), indicating
if e is a then, a regular else, or a complemented else edge.
Figure 1 shows an example of a COBDD depicted via its
associated multigraph, where edges are directed downwards.
Moreover, in Figure 1 then edges are solid lines, regular
else edges are dashed lines and complemented else edges
are dotted lines.
The graph associated to a given COBDD ρ = (V, V , 1,
var, low, high, ﬂip) may be seen as a forest with multiple
rooted multigraphs. In order to select one root vertex and
thus one rooted multigraph, we deﬁne the COBDD restricted
to v ∈ V as the COBDD ρv = (V, Vv, 1, var, low, high,
ﬂip) s.t. Vv = {w ∈ V | there exists a path from v to w in
G(ρ)} (note that v ∈ Vv).
Reduced COBDDs: Two COBDDs are isomorphic iff
there exists a mapping from nodes to nodes preserving at-
tributes var, ﬂip, high and low. A COBDD is called reduced
iff it contains no vertex v with low(v) = high(v)∧ﬂip(v) =
0, nor does it contains distinct vertices v and v′ such that ρv
and ρv′ are isomorphic. Note that, differently from OBDDs,
it is possible that high(v) = low(v) for some v ∈ V ,
provided that ﬂip(v) = 1 (e.g., see nodes 0xf and 0xe in
Figure 1). In the following, we assume all our COBDDs to
be reduced.
COBDDs properties: For a given COBDD ρ = (V, V ,
1, var, low, high, ﬂip) the following properties follow from
deﬁnitions given above: i) G(ρ) is a rooted directed acyclic
(multi)graph (DAG); ii) each path in G(ρ) starting from an
internal node ends in 1; iii) let v1, . . . , vk be a path in G(ρ),
then var(v1) < . . . < var(vk).
A. Semantics of a COBDD
In Deﬁnition 2, we deﬁne the semantics J·K of each node
v of a given COBDD ρ as the boolean function represented
by v, given the parity b of complemented edges seen on the
path from a root to v.
530
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

Deﬁnition 2. Let ρ = (V, V , 1, var, low, high, ﬂip)
be a COBDD. The semantics of the terminal node 1
w.r.t. a ﬂipping bit b is a boolean function deﬁned as
J1, bKρ := ¯b. The semantics of an internal node v ∈ V
w.r.t. a ﬂipping bit b is a boolean function deﬁned as
Jv, bKρ := xiJhigh(v), bKρ + ¯xiJlow(v), b ⊕ ﬂip(v)Kρ, being
xi = var(v). When ρ is understood, we will write J·K instead
of J·Kρ.
Example 1. Let ρ be the COBDD depicted in Figure 1. If we
pick node 0xe we have J0xe, bK = x2J1, bK + ¯x2J1, b ⊕ 1K =
x2¯b + ¯x2b = x2 ⊕ b.
Theor. 1 states that COBDDs are a canonical representa-
tion for boolean functions (see [10][11]).
Theorem 1. Let f : Bn → B be a boolean function. Then
there exist a COBDD ρ = (V, V , 1, var, low, high, ﬂip), a
node v ∈ V and a ﬂipping bit b ∈ B s.t. Jv, bK = f(x).
Moreover, let ρ = (V, V , 1, var, low, high, ﬂip) be a
COBDD, let v1, v2 ∈ V be nodes and b1, b2 ∈ B be ﬂipping
bits. Then Jv1, b1K = Jv2, b2K iff v1 = v2 ∧ b1 = b2.
VI. SYNTHESIS OF C CODE FROM A COBDD
Let K(x1, . . . , xn, u1, . . . , ur) be the mgo for a given
control problem. Let ρ = (V, V , 1, var, low, high, ﬂip)
be a COBDD s.t. there exist v ∈ V , b ∈ B s.t. Jv, bK =
K(x1, . . . , xn, u1, . . . , ur). Thus, V = X ·∪ U = {x1, . . . ,
xn} ·∪{u1, . . . , ur} (we denote with ·∪ the disjoint union
operator, thus X ∩ U = ∅). We will call variables xi ∈ X
as state variables and variables uj ∈ U as action variables.
More in-depth details may be found in [8].
A. Synthesis Algorithm: Overview
Our method Synthesize takes as input ρ, v and b s.t.
Jv, bK = K(x, u). Then, it returns as output a C function
void K(int *x, int *u) with the following prop-
erty: if, before a call to K, ∀i x[i − 1]= xi holds (array
indexes in C language begin from 0) with x ∈ Dom(K), and
after the call to K, ∀i u[i−1]= ui holds, then K(x, u) = 1.
Moreover, the WCET of function K is O(nr).
Note that our method Synthesize provides an effective
implementation of the mgo K, i.e., a C function which takes
as input the current state of the LTS and outputs the action
to be taken. Thus, K is indeed a control software.
Function Synthesize is organized in two phases. First,
starting from ρ, v and b (thus from K(x, u)), we generate
COBDD nodes v1, . . . , vr and ﬂipping bits b1, . . . , br for
boolean functions f1, . . . , fr s.t. each fi = Jvi, biK takes
as input the state bit vector x and computes the i-th bit
ui of an output action bit vector u, where K(x, u) = 1,
provided that x ∈ Dom(K). This computation is carried
out in function SolveFunctionalEq. Second, f1, . . . , fr are
translated inside function void K(int *x, int *u).
This step is performed by maintaining the structure of the
COBDD nodes representing f1, . . . , fr. This allows us to
exploit COBDD node sharing in the generated software. This
phase is performed by function GenerateCCode.
Thus function Synthesize is organized as in Algorithm 1.
Correctness for function Synthesize is stated in Theor. 2.
Algorithm 1 Translating COBDDs to a C function
Require: COBDD ρ, node v, boolean b
Ensure: Synthesize(ρ, v, b):
1: ⟨v1, b1, . . . , vr, br⟩ ← SolveFunctionalEq(ρ, v, b)
2: GenerateCCode(ρ, v1, b1, . . . , vr, br)
B. Synthesis Algorithm: Solving a Functional Equation
In this phase, starting from ρ, v and b (thus from Jv, bK =
K(x, u)), we compute functions f1, . . . , fr s.t. for all x ∈
Dom(K), K(x, f1(x), . . . , fr(x)) = 1.
To
this
aim,
we
follow
an
approach
similar
to
the
one
presented
in
[7].
Namely,
we
compute
fi
using
f1, . . . , fi−1,
in
the
following
way:
fi(x)
=
∃ui+1, . . . , un
K(x, f1(x), . . . , fi−1(x), 1, ui+1, . . . , un).
Thus, function SolveFunctionalEq(ρ, v, b) computes and re-
turns ⟨v1, b1, . . . , vr, br⟩ s.t. for all i ∈ [r], Jvi, biK = fi(x).
C. Synthesis Algorithm: Generating C Code
In this phase, starting from COBDD nodes v1, . . . , vr and
ﬂipping bits b1, . . . , br for functions f1, . . . , fr generated
in the ﬁrst phase, we generate two C functions: i) void
K(int *x, int *u), which is the required output func-
tion for our method Synthesize; ii) int K_bits(int
*x, int action), which is an auxiliary function called
by K. A call to K_bits(x, i) returns fi(x), being x[j −
1]= xj for all j ∈ [n]. This phase is detailed in Algs. 2
(function GenerateCCode) and 3 (function Translate).
Given inputs ρ, v1, b1, . . . , vr, br (output by SolveFunc-
tionalEq), Algs. 2 and 3 work as follows. First, function
int K_bits(int *x, int action) is generated. If
x[j − 1]= xj for all j ∈ [n], the call K_bits(x, i)
has to return fi(x). In order to do this, K_bits(x, i)
traverses the graph G(ρvi) by taking, in each node v, the
then edge if x[j − 1] = 1 (with j s.t. var(v) = xj) and
the else edge otherwise. When node 1 is reached, then 1 is
returned iff the integer sum c+bi is even, being c the number
of complemented else edges traversed. Parity of c + bi is
maintained by initializing a C variable ret_b to ¯bi, then
complementing ret_b when a complemented else edge is
traversed, and ﬁnally returning ret_b.
Thus, Algs. 2 and 3 generate K_bits in order to obtain
the above described behavior. Namely, for all vi output by
the ﬁrst phase (function SolveFunctionalEq), GenerateC-
Code calls Translate with parameters ρ, vi, W, where W
maintains the set of nodes already translated in C code.
This results, for all such vi, in a recursive graph traversal of
G(ρvi) where, for each internal node w /∈ W which was not
already translated, a C code block B = B1B2 is generated
s.t. B1 is of the form L_w: if (x[j−1]) goto L_h;
531
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

(line 7 of Algorithm 3) and B2 has one of the following
forms: i) else goto L_l; (if ﬂip(w) = 0, line 9 of
Algorithm 3) or ii) else {ret_b = !ret_b; goto
L_l;} (otherwise, line 8 of Algorithm 3). For the terminal
node, the block L_1: return ret_b; is generated.
Note that maintaining the set of already translated nodes
W allows us to fully exploit COBDDs nodes sharing.
Algorithm 2 Generating C functions
Require: COBDD ρ, v1, . . . , vr, boolean values b1, . . . , br
Ensure: GenerateCCode(ρ, v1, b1, . . . , vr, br):
1: print
“int K_bits(int *x, int action) {
int ret_b; switch(action) {”
2: for all i ∈ [r] do
3:
print
“case ”, i − 1, “: ret_b = ”, ¯bi, “;
goto L_”, vi,“;”
4: print “}” /* end of the switch block */
5: W ← ∅
6: for all do i ∈ [r] W ←Translate(ρ, vi, W) done
7: print
“} K(int*x,int*u){int
i;for(i=0;i<”,r,“;i++)u[i]=K_bits(x,i);}”
Algorithm 3 COBDD nodes translation
Require: COBDD ρ, node v, nodes set W
Ensure: Translate(ρ, v, W):
1: if v ∈ W then return W
2: W ← W ∪ {v}, print “L_”, v, “:”
3: if v = 1 then
4:
print “return ret_b;”
5: else
6:
let i be s.t. var(v) = xi
7:
print “if(x[”,i − 1,“]==1)goto L_”, high(v)
8:
if ﬂip(v) then print “else {ret_b = !ret_b;
goto L_”, low(v),“;}”
9:
else print “else goto L_”, low(v)
10:
W ←Translate(ρ, high(v), W)
11:
W ←Translate(ρ, low(v), W)
12: return W
Algorithm Correctness: Correctness of our approach,
i.e., of function Synthesize in Algorithm 1, is stated by Th. 2
(for the proof, see [8]).
Theorem 2. Let ρ = (V, V , 1, var, low, high, ﬂip)
be a COBDD with V
= X ·∪U, v
∈ V
be a node,
b ∈ B be a boolean. Let Jv, bK = K(x, u). Then function
Synthesize(ρ, v, b) generates a C function void K(int
*x, int *u) with the following property: for all x ∈
Dom(K), if before a call to K ∀i ∈ [n] x[i − 1]= xi, and
after the call to K ∀i ∈ [r] u[i−1]= ui, then K(x, u) = 1.
Furthermore, function K has WCET O(nr).
An Example of Translation: Consider the COBDD ρ
shown in Figure 1. Within ρ, consider mgo K(x0, x1,
x2, u0, u1) = J0x17, 1K. By applying SolveFunctionalEq,
we obtain f1(x0, x1, x2) = J0x15, 1K and f2(x0, x1,
 u0 
 u1 
 x0 
 x1 
 x2 
K
0x17
0x12
0x16
0x10
0x11
0x15
1
0xf
0xe
0x13
0x14
Figure 1.
An mgo example
i n t K_bits( i n t *x, i n t action) { i n t ret_b;
switch(action) { case 0: ret_b = 0; goto L_0x15;
case 1: ret_b = 0; goto L_0x10; }
L_0x15: i f (x[0] == 1) goto L_0x13;
e l s e { ret_b = !ret_b; goto L_0x14; }
L_0x13: i f (x[1] == 1) goto L_0xe;
e l s e { ret_b = !ret_b; goto L_1; }
L_0xe:
i f (x[2] == 1) goto L_1;
e l s e { ret_b = !ret_b; goto L_1; }
L_0x14: i f (x[1] == 1) goto L_0xe;
e l s e
goto L_1;
L_0x10: i f (x[0] == 1) goto L_0xe;
e l s e { ret_b = !ret_b; goto L_0xf; }
L_0xf:
i f (x[1] == 1) goto L_0xe;
e l s e { ret_b = !ret_b; goto L_0xe; }
L_1: return ret_b; }
void K( i n t *x, i n t *u) { i n t i;
for(i = 0; i < 2; i++) u[i] = K_bits(x, i); }
Figure 2.
C code for the mgo in Figure 1 as generated by Synthesize
x2) = J0x10, 1K. Note that 0xe is shared between G(ρ0x15)
and G(ρ0x10). Finally, by calling GenerateCCode (see Algo-
rithm 2) on f1, f2, we have the C code in Figure 2.
VII. EXPERIMENTAL RESULTS
We implemented our synthesis algorithm in C program-
ming language, using the CUDD package for OBDD based
computations and BLIF ﬁles to represent input OBDDs. We
name the resulting tool KSS (Kontrol Software Synthesizer).
KSS is part of a more general tool named QKS (Quantized
feedback Kontrol Synthesizer [4]).
1) Experimental Settings: We present experimental re-
sults obtained by using KSS on given COBDDs ρ1, . . . , ρ4
s.t. for all i ∈ [4] ρi represents the mgo Ki(x, u) for a buck
DC/DC converter with i inputs (see [6] for a description of
this system), where n = |x| = 20 and ri = |u| = i. Ki is
an intermediate output of the QKS tool described in [4].
For each ρi, we run KSS so as to compute Synthesize(ρi,
vi, bi) (see Algorithm 1). In the following, we will call
⟨v1i, b1i, . . . , vii, bii⟩, with vji ∈ Vi, bji ∈ B, the out-
532
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

Table I
KSS PERFORMACES
r
CPU
MEM
|K|
|F unsh|
|Sw|
%
1
2.2e-01
4.5e+07
12124
2545
2545
0.0e+00
2
4.2e-01
5.3e+07
25246
5444
4536
1.7e+01
3
5.2e-01
5.9e+07
34741
10731
8271
2.3e+01
4
6.3e-01
6.5e+07
43065
15165
11490
2.4e+01
put of function SolveFunctionalEq(ρi, vi, bi). Moreover,
we call f1i, . . . , fii : Bn → B the i boolean functions s.t.
Jvji, bjiK = fji(x). All our experiments have been carried
out on a 3.0 GHz Intel hyperthreaded Quad Core Linux PC
with 8 GB of RAM.
2) KSS Performance: In this section we will show the
performance (in terms of computation time, memory, and
output size) of the algorithms discussed in Section VI. Ta-
ble I show our experimental results. The i-th row in Table I
corresponds to experiments running KSS so as to compute
Synthesize(ρi, vi, bi). Columns in Table I have the following
meaning. Column r shows the number of action variables |u|
(note that |x| = 20 on all our experiments). Column CPU
shows the computation time of KSS (in secs). Column MEM
shows the memory usage for KSS (in bytes). Column |K|
shows the number of nodes of the COBDD representation for
Ki(x, u), i.e., |Vvℓi|. Column |F unsh| shows the number of
nodes of the COBDD representations of f1i, . . . , fii, without
considering nodes sharing among such COBDDs. Note that
we do consider nodes sharing inside each fji separately.
That is, |F unsh| = Pi
j=1 |Vvji| is the size of a trivial imple-
mentation of f1i, . . . , fii in which each fji is implemented
by a stand-alone C function. Column |Sw| shows the size
of the control software generated by KSS, i.e., the number
of nodes of the COBDD representations f1i, . . . , fii, con-
sidering also nodes sharing among such COBDDs. That is,
|Sw| = |∪i
j=1Vvji| is the number of C code blocks generated
by lines 5–6 of function GenerateCCode in Algorithm 2.
Finally, Column % shows the gain percentage we obtain by
considering node sharing among COBDD representations for
f1i, . . . , fii, i.e., (1 −
|Sw|
|F unsh|)100.
From Table I we can see that, in less than 1 second
and within 70 MB of RAM we are able to synthesize the
control software for the multi-input buck with r = 4 action
variables, starting from a COBDD representation of K with
about 4 × 104 nodes. The control software we synthesize
in such a case has about 1.2 × 104 lines of code, whilest
a control software not taking into account COBDD nodes
sharing would have had about 1.5×104 lines of code. Thus,
we obtain a 24% gain towards a trivial implementation.
VIII. CONCLUSION AND FUTURE WORK
We presented an algorithm and a tool KSS implementing
it which, starting from a boolean relation K representing
the set of implementations meeting the given system speci-
ﬁcations, generates a correct-by-construction C code imple-
menting K. This entails ﬁnding boolean functions F s.t.
K(x, F(x)) = 1 holds, and then implement such F. WCET
for the generated control software is linear linear in nr, being
r the number of functions in F and n = |x|. KSS allows
us to synthesize correct-by-construction control software,
provided that K is provably correct w.r.t. initial formal spec-
iﬁcations. This is the case in [4], thus this methodology, e.g.,
allows to synthesize correct-by-construction control software
starting from formal speciﬁcations for DTLHSs. We have
shown feasibility of our proposed approach by presenting
experimental results on using it to synthesize C controllers
for a buck DC-DC converter.
In order to speed-up the resulting WCET, a natural possi-
ble future research direction is to investigate how to paral-
lelize the generated control software, as well as to improve
don’t-cares handling in F.
Acknowledgments: This work has received funding both
from MIUR project TRAMP and the FP7/2007-2013 project
ULISSE (grant agreement no218815).
REFERENCES
[1] R. Bryant, “Graph-based algorithms for boolean function
manipulation,” IEEE Trans. on Computers, vol. C-35, no. 8,
pp. 677–691, 1986.
[2] D. Baneres, J. Cortadella, and M. Kishinevsky, “A recursive
paradigm to solve boolean relations,” IEEE Trans. Comput.,
vol. 58, pp. 512–527, April 2009.
[3] R. Wille and R. Drechsler, “Bdd-based synthesis of reversible
logic for large functions,” in DAC, 2009, pp. 270–275.
[4] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “Synthesis of
quantized feedback control software for discrete time linear
hybrid systems,” in CAV, ser. LNCS 6174, 2010, pp. 180–195.
[5] E. M. Clarke, O. Grumberg, and D. A. Peled, Model Check-
ing.
The MIT Press, 1999.
[6] F. Mari, I. Melatti, I. Salvo, and E. Tronci, “Quantized
feedback control software synthesis from system level for-
mal speciﬁcations for buck dc/dc converters,” CoRR, vol.
abs/1105.5640, 2011.
[7] E. Tronci, “Automatic synthesis of controllers from formal
speciﬁcations,” in ICFEM.
IEEE, 1998, pp. 134–143.
[8] F.
Mari,
I.
Melatti,
I.
Salvo,
and
E.
Tronci,
“From
boolean functional equations to control software,” CoRR, vol.
abs/1106.0468, 2011.
[9] A. Cimatti, M. Roveri, and P. Traverso, “Strong planning
in non-deterministic domains via model checking,” in AIPS,
1998, pp. 36–43.
[10] K. S. Brace, R. L. Rudell, and R. E. Bryant, “Efﬁcient
implementation of a bdd package,” in DAC, 1990, pp. 40–
45.
[11] S. Minato, N. Ishiura, and S. Yajima, “Shared binary decision
diagram with attributed edges for efﬁcient boolean function
manipulation,” in DAC, 1990, pp. 52–57.
533
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

