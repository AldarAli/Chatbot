Reasoning About Consistency of Relational
Knowledge Bases
Tadeusz Pankowski
Institute of Control and Information Engineering
Pozna¬¥n University of Technology
Pozna¬¥n, Poland
Email: tadeusz.pankowski@put.poznan.pl
Abstract‚ÄîWe study a translation of relational database into
an extended DL knowledge base that is both sound and com-
plete with respect to semantics preservation. The issue is of
special importance while creating Web of Data, where relational
databases are exposed in the Web to be searched, integrated
and exchanged without loss of information and semantics. Our
approach considers all fundamental requirements of DL/OWL
knowledge bases such as OWA and rejecting the UNA. We
propose a system of axioms for representing database integrity
constraints, which guarantees information and semantics preserv-
ing data-to-knowledge exchange.
Keywords‚Äîknowledge bases; data integration; integrity con-
straints; data exchange; ontology-based data management.
I.
INTRODUCTION
In this paper, we study the problem of transforming a
relational databases to Description Logic (DL) knowledge
bases. We propose a method to realize such a transformation
and study its correctness. The translation is correct if in the
target knowledge base both information and semantics are
preserved. The problem of representing a relational database
in a DL knowledge base has gained in importance in recent
years, mainly due to the emergence of the Semantic Web. It is
expected that the Semantic Web enables web-wide integration
of data coming from various sources, also referred to as Web of
Data. The Web Of Data can be formally perceived as a giant
DL knowledge base (or DL ontology) K = (T , A), where
T is a set of axioms modeling the intensional knowledge
(the TBox axioms), and A is a set of assertions forming
the extensional knowledge (the ABox assertions) [1]. It is
expected that in such a knowledge base the underlying source
repositories are represented as precisely as possible and that
distributed execution of queries over these repositories is
possible allowing for so called ontology-based data access [2].
Most of the data exposed in the Web are originally stored in
relational databases, and have to be mapped or translated to
Resource Description Framework (RDF)/Ontology Web Lan-
guage (OWL) representations. Sometimes we face an inverse
problem ‚Äì Web data are to be stored in a relational database, so
the relational structures and constraints have to be discovered.
Thus, the similarities and differences between databases and
knowledge bases has been an important and attractive Ô¨Åeld of
research since many years [3], [4], [5], [6].
Related work. Some recent results of representing relational
databases in the Semantic Web are surveyed in [7]. There
are two approaches to integrating relational databases with
the Semantic Web: (1) direct mapping [8], [9] ‚Äì consists in
translating the database contents and its schema directly to
representations in Semantic Web languages, i.e., in RDF and
OWL, in result an ontology is created from the database;
(2) mapping to ontology [2] ‚Äì assumes the existence of a
shared domain ontology and a language for mapping database
schema to this ontology. Then, the extensional layer of the
database is represented by RDF graph in a form of a set
of semantic triples (subject, predicate, object) [10]. The in-
tensional layer is captured by means of axioms speciÔ¨Åed in
OWL [11] or RDFS [10]. The direct mapping of relational
database schema to OWL DL is the subject of the current
draft of the W3C Group [12]. A formal basis for RDF(S)
and OWL provides Description Logic (DL), that is a family
of knowledge representation languages [13] being usually a
decidable subset of Ô¨Årst-order logic. A relationship between
relational databases and DL knowledge bases are studied in [6].
There are three main differences between databases and knowl-
edge bases making the translation between them difÔ¨Åcult [5],
[4]: (a) databases are based on the Closed Word Assumption
(CWA) while knowledge bases follow usually the Open World
Assumption (OWA); (b) databases make the Unique Name
Assumption (UNA) while knowledge bases usually do not
accept it; (c) integrity constraints in databases are interpreted
as checks while in knowledge bases all rules are interpreted
as deductive rules. It turns out that incorporating integrity
constraints into knowledge bases is the most challenging issue.
To deal with the problem, the following three approaches have
been proposed: (a) introduction of epistemic operators K and A
into the knowledge base, to capture the semantics of integrity
constraints by restricting interpretation of some formulas to the
‚Äùstate‚Äù of the knowledge base, i.e., to ‚Äùwhat the knowledge
base knows‚Äù [14]; (b) knowledge bases are restricted only to
those, which accept UNA [15], (c) deÔ¨Åning an extended DL
knowledge base (EKB), where the set T of TBox axioms is
divided into standard TBox axioms, S, and integrity constraint
TBox axioms, C; semantics of S and C are deÔ¨Åned in different
ways.
Contribution. In this paper we will use the notion of
EKB to represent a relational database in DL. We deÔ¨Åne a
data-to-knowledge exchange (dk-exchange) system that deÔ¨Ånes
translation of relational database schema, its integrity con-
straints and instances into an extended DL knowledge base.
The resulting extended DL knowledge base is referred to as a
relational knowledge base (RKB). This approach provides an
automatic translation and a relational schema is mechanically
transformed into TBox axioms. However, for the approach to
be meaningful, some assumptions must be made about the way
283
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-283-7
ICCGI 2013 : The Eighth International Multi-Conference on Computing in the Global Information Technology

in which the underlying relational database has been created.
To this order we assume that the relational database under con-
sideration implements a conceptual model developed using ER
(Entity-Relationship) or its extension EER (Expanded Entity-
Relationship) approach [16], [17]. Additionally, we assume
that all relationships in ER schema are binary and one-to-many.
It means that any many-to-many relationship is replaced with
two one-to-many relationships. Such the replacement is always
possible and commonly applied to form UML class diagrams
[18].
In Figure 1, the EER diagram describes students, courses
and exams taken by students [9]. In particular, a student is a
specialization of a person. Every entity set in Figure 1 (b),
i.e., Person, Student, Exam, and Course, has a key (identiÔ¨Åer).
Other attributes will be speciÔ¨Åed below in SQL deÔ¨Ånition.

	

	






	

	





Fig. 1.
EER diagrams of a university domain. (a) Exam is a many-to-many
relationship, (b) Exam is a member in two one-to-many relationships [9].
A speciÔ¨Åcation of the EER diagram in Figure 1 (b) using
SQL notation is given in Figure 2.
create table Person(
PId int primary key,
Name char(20));
create table Course(
CId char(5) primary key);
create table Student(
SId int primary key foreign key references Person(PId),
Faculty char(20) not null);
create table Exam(
EId int primary key,
ESId int foreign key references Student(SId),
Course char(5) foreign key references Course(CId),
Grade char(1));
Fig. 2.
SQL speciÔ¨Åcation of the EER diagram in Figure 1 (b) [9].
We assume that a relational database is created with the
following assumptions: (1) The ER methodology is followed,
and all relationships are binary and one-to-many. Any primary
key and any foreign key consists of exactly one column. (2) A
single and partial specialization (inheritance) between entity
sets is allowed. (3) The Ô¨Ånal database schema is deÔ¨Åned in
SQL with the following integrity constraints: unique, not-
null, primary key, and foreign key. Some combinations of
primary keys and foreign keys will be referred to as inheritance
constraints (see the deÔ¨Ånition of SId column in Student table).
Analysis of relational database schema suggests a possible
translation of this schema into an ontology. Some natural
semantic interpretations of schema elements and integrity
constraints and their translation into extended DL knowledge
base (or an OWL ontology), are:
‚Ä¢
Both relation names and attribute type names become
atomic concepts (class names).
‚Ä¢
Attributes become atomic roles (object property
names) connecting individuals in classes correspond-
ing to relation names, with individuals in classes
corresponding to attribute type names.
‚Ä¢
Integrity constraints become TBox axioms, divided
properly between standard TBox axioms and TBox
ic-axioms.
The main novelty of this paper is that we propose a system
of standard TBox axioms and TBox ic-axioms, such that the
Ô¨Ånal dk-exchange system is both sound and complete with
respect to semantics preservation. We show how consistency
of the resulting relational knowledge base can be veriÔ¨Åed.
The structure of the paper is as follows. In Section II,
we review some deÔ¨Ånitions concerning relational databases
(RDB). In Section III, we discuss a relational knowledge base
and translation of RDB to RKB. Dk-exchange system and
its fundamental property concerning semantics preservation
is discussed in Section IV. Checking consistency of RKB is
discussed in Section V. Section VI concludes the paper.
II.
RELATIONAL DATABASES
A. Schemas and instances
A (relational) database schema (db-schema) is a pair
(R, IC), where R = {R1, . . . , Rn} is a relational schema
consisting of a set of relation symbols, and IC is a set of
integrity constraints over R. Each relation symbol R ‚àà R
has a type, which is a nonempty Ô¨Ånite set U of attributes,
denoted att(R) = U. Without loss of generality, we can
assume that types of relation symbols are pairwise disjoint (this
can be achieved, for example, by preÔ¨Åxing attribute names with
relation symbols), arity(R) denotes the cardinality of att(R).
Let Const be a countable inÔ¨Ånite set of constants, and
NULL be a reserved symbol not in Const.
DeÔ¨Ånition 2.1: An instance I of a relational schema R is
a Ô¨Ånite multiset of facts (or ground atoms) of the form R(A1 :
c1, . . . , Am : cm), where R ‚àà R, att(R) = {A1, . . . , Am},
and ci ‚àà Const ‚à™ {NULL}, 1 ‚â§ i ‚â§ m. By Inst(R) is
denoted the set of all instances of R. The set of all values
from Const ‚à™ {NULL} occurring in I is referred to as the
active domain of I and is denoted adom(I).
‚ñ°
An instance of R corresponds to the notion of Codd table [4].
Since an instance is a multiset, thus the concept of duplicates
284
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-283-7
ICCGI 2013 : The Eighth International Multi-Conference on Computing in the Global Information Technology

within a table is captured (as in SQL databases). Because the
NULL value can occur in instances, the three-valued logic is
used in SQL databases, where besides TRUE and FALSE, the
UNKNOWN logical value is also needed [4].
DeÔ¨Ånition 2.2: Let DB = (R, IC, I) be a (relational)
database with a db-schema (R, IC) and an instance I of R.
DB is consistent, if I satisÔ¨Åes (is a model of) all integrity
constraints, denoted I |= IC. Otherwise we say that DB is
inconsistent.
‚ñ°
B. Integrity constraints
Integrity constraints in databases play a dual role. On the
one hand, they describe all possible worlds, and, on the other
hand, they describe the allowed states of the database [4].
Integrity constraints can be used in data reasoning tasks, such
as checking the correctness of database data, as well as in
schema reasoning tasks, such as computing query containment
(or subsumption).
We assume that IC = Unique‚à™NotNull ‚à™PKey ‚à™FKey ‚à™
Inherit, where: Unique, NotNull, PKey, FKey, and Inherit
are sets of, respectively, unique, not-null, primary key, foreign
key, and inheritance integrity constraints.
Let R be a relational schema, R ‚àà R be a relation symbol
of type att(R) = {A1, . . . , Am}, and Ak ‚àà att(R).
1) Unique integrity constraint: A unique integrity con-
straint is an expression of the form unique(R, Ak). An in-
stance I of R is consistent with unique(R, Ak), iff for every
i, 0 ‚â§ i ‚â§ m, I satisÔ¨Åes the formula
R(t1) ‚àß R(t2) ‚àß t1.Ak = t2.Ak ‚àß t1.Ai Ã∏= NULL
‚àßt2.Ai Ã∏= NULL ‚áí t1.Ai = t2.Ai.
(1)
Note that the occurrence of NULLs affects the interpretation of
the satisfaction of unique(R, A). An instance I with NULLs is
consistent with unique(R, A), if there is such a replacement
of NULLs with constants (every occurrence of NULL can be
replaced with different constant) that the result instance is
consistent with unique(R, A).
Example 2.3: Let R(A, B) denote a relation symbol R
of type {A, B} and unique(R, A) be a unique integrity
constraint. Let I1, I2 (Figure 3) be instances of R. Then, I1 is
consistent with unique(R, A), while I2 is not.
I1 :
A
B
a
b
a
b
a
NULL
NULL
c
NULL
NULL
I2 :
A
B
a
b
a
c
NULL
b
NULL
c
NULL
NULL
Fig. 3.
Consistent, I1, and inconsistent, I2, instances of R(A, B) with
respect to unique(R, A)
2) Not-null integrity constraint:
A not-null integrity
constraint is an expression of the form notnull(R, Ak). An
instance I of R is consistent with notnull(R, Ak), if for any
fact R(t) ‚àà I, t.Ak is a constant, i.e., iff I satisÔ¨Åes the formula
R(t) ‚áí t.Ak Ã∏= NULL.
3) Primary key integrity constraint:
A primary key
integrity constraint is an expression of the form pkey(R, Ak).
An instance I of R is consistent with pkey(R, Ak) iff it is
consistent with unique(R, Ak), and notnull(R, Ak).
4) Foreign key integrity constraint: Let R, R‚Ä≤ ‚àà R,
A ‚àà att(R), and A‚Ä≤ ‚àà att(R‚Ä≤). A foreign key integrity
constraint is an expression of the form fkey(R, A, R‚Ä≤, A‚Ä≤).
An instance I of R is consistent with fkey(R, A, R‚Ä≤, A‚Ä≤) iff I
satisÔ¨Åes unique(R‚Ä≤, A‚Ä≤), and I satisÔ¨Åes the following existence
constraint
R(t) ‚àß t.A Ã∏= NULL ‚áí ‚àÉt‚Ä≤.(R‚Ä≤(t‚Ä≤) ‚àß t‚Ä≤.A‚Ä≤ = t.A).
(2)
5) Inheritance
constraint:
A
pair
(pkey(R, A),
fkey(R, A, R‚Ä≤, A‚Ä≤)) is referred to as an inheritance constraint.
It speciÔ¨Åes that some entities in a class CR‚Ä≤ corresponding to
the table R‚Ä≤, can be specialized in a class CR corresponding
to the table R (or that each entity in CR inherits from, exactly
one, entity in CR‚Ä≤). An instance I of R is consistent with
(pkey(R, A), fkey(R, A, R‚Ä≤, A‚Ä≤)) iff it is consistent with
pkey(R, A) and fkey(R, A, R‚Ä≤, A‚Ä≤).
For example, (see Figure 1), the inheritance constraint
(fkey(Student, SId), fkey(Student, SId, Person, PId))
speciÔ¨Åes that a student is uniquely identiÔ¨Åed by SId, and
simultaneously SId refers to a person identiÔ¨Åed by PId.
It means, that description of a person is contained in part
in the Person table, and in part in the Student table (we
say that Person objects are specialized as Student objects).
Then, the composition (s, p) of a tuple s describing a student
and a corresponding tuple p describing a person (such that
s.SId = p.PId) fully describes a person under consideration.
III.
RELATIONAL KNOWLEDGE BASES
To carry out reasoning procedures about properties of
relational databases (such as preservation of semantics during
data exchange) it is useful to represent the relational database
by means of a knowledge base. However, a traditional DL
knowledge base understood as a pair (T , A) is unable to model
integrity constraints [6]. The reason is two-fold: Ô¨Årstly, axioms
in T are interpreted under the standard Ô¨Årst-order semantics
and are treated as deductive rules and not as checks, and
secondly, the UNA (Unique Name Assumption) is not accepted
in general in DL knowledge bases, it means that two different
individual names can denote the same individual.
A. Syntax of relational knowledge bases
In this section, we deÔ¨Åne a relational knowledge base
(RKB) that is a DL knowledge base adequately representing
a relational database. RKB is based on the concept of EKB
[6]. We propose and discuss a system of TBox axioms,
which properly represents a relational database deÔ¨Åned in the
previous section.
DeÔ¨Ånition 3.1: A relational knowledge base is a tuple R =
(N, S, C, A), where:
1)
N is the vocabulary (or signature) of R, consisting
of a set NInd of individual names, a set NCl of class
285
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-283-7
ICCGI 2013 : The Eighth International Multi-Conference on Computing in the Global Information Technology

names (or atomic concepts), a set NOP of object
property names (or atomic roles).
2)
S is a Ô¨Ånite set of standard TBox axioms, which are
treated as deductive rules and can infer new assertions
(see Table I).
3)
C is a Ô¨Ånite set of integrity constraint TBox axioms.
These axioms act as checks and are used to check
whether a set of assertions implied by A and S,
satisÔ¨Åes conditions speciÔ¨Åed by C (see Table II).
Axioms in C cannot imply new assertions.
4)
A is a set of ABox assertions, which consists of
factual knowledge about universe of discourse, i.e.,
properties of individual objects.
Creating vocabulary. Let (R, IC) be a db-schema, Const
be a countably inÔ¨Ånite set of constants, and ‚àÜVar be a
countable inÔ¨Ånite set of labeled nulls disjoint from the set
of constants; labeled nulls, denoted X, X1, X2, ..., are used as
‚Äùfresh‚Äù Skolem terms, which are placeholders for unknown
values, and can thus be seen as variables [19]. Then the
vocabulary N = NCl ‚à™ NOP ‚à™ NInd, is created as follows:
1)
Distinguished class names Tuple, and Val, are in-
serted into NCl. These names are independent of a
concrete db-schema: Tuple is a class of individual
names called tuple names (or tuples), and Val is a
class of individual names called attribute value names
(or attribute values).
2)
For each relational symbol R ‚àà R, there is a class
name CR ‚àà NCl; this class is a subclass of Tuple,
CR ‚äë Tuple.
3)
For each attribute A ‚àà att(R), R ‚àà R, there is a class
name CA ‚àà NCl being a subclass of Val (CA ‚äë Val),
and an object property name PA ‚àà NOP; the object
property PA connects a tuple in CR with an attribute
value in CA.
4)
A set NInd of individual names consists of the union
of Const and ‚àÜVar. We assume that the UNA does
not hold.
Creating standard TBox axioms. The set S of standard
TBox axioms is given in Table I. Since each axiom in S is a
deductive rule then the assertion on the right hand side of any
FOL rule is inserted into the set A ‚à™ S, i.e., into the closure
of A with respect to S.
TABLE I.
STANDARD TBOX AXIOMS OF RELATIONAL KNOWLEDGE
BASE
Constraints of relational db
DL
FOL
S1
R ‚àà R
CR ‚äë Tuple
CR(x) ‚áí Tuple(x)
S2
A ‚àà att(R), R ‚àà R
CA ‚äë Val
CA(v) ‚áí Val(v)
S3
range of PA
‚àÉP ‚àí
A ‚äë CA
PA(x, v) ‚áí CA(v)
S4
domain of PA
‚àÉPA ‚äë CR
PA(x, v) ‚áí CR(x)
S5
unique(R, A)
(func P ‚àí
A )
PA(x1, v1) ‚àß PA(x2, v2)
unique constraint
‚àßv1 = v2 ‚áí x1 = x2
S6
(pkey(R, A),
PA ‚äë PA‚Ä≤
PA(x, v) ‚áí PA‚Ä≤(x, v)
fkey(R, A, R‚Ä≤, A‚Ä≤))
inheritance constraint
(S1) and (S2) belong to translation of facts that R ‚àà R
and A ‚àà att(R); they say that appropriate tuple names and
attribute value names are to be inserted into, respectively,
classes Tuple and Val. (S3) and (S4) belong to translation
of the fact that A ‚àà att(R), where: (S3) deÔ¨Ånes the range
of the object property PA corresponding to an attribute A of
the relational symbol R, and (S4) deÔ¨Ånes the domain of this
object property. (S5) is the result of translation of a unique
constraint unique(R, A), and enforces equality between x1
and x2, if hold all PA(x1, v1), PA(x2, v2), and v1 = v2 (A
in R has the key property for not null values). (S6) results
of the translation of an inheritance constraint of the form
{pkey(R, A), fkey(R, A, R‚Ä≤, A‚Ä≤)}, and says that extension of
PA is to be inserted into the extension of PA‚Ä≤.
Creating integrity constraint TBox axioms. The set C of
TBox ic-axioms is given in Table II. Note that ic-axioms are
checks, so we expect that the value of such an axiom is either
TRUE or FALSE.
TABLE II.
INTEGRITY CONSTRAINT TBOX AXIOMS OF RELATIONAL
KNOWLEDGE BASE
Constraints of relational db
DL
FOL
C1
disjointness
Tuple ‚äë ¬¨Val
Tuple(x) ‚áí ¬¨Val(x)
C2
A ‚àà att(R), R ‚àà R
(func PA)
PA(x1, v1)
functional property
‚àßPA(x2, v2)
‚àßx1 = x2 ‚áí v1 = v2
C3
notnull(R, A)
CR ‚äë ‚àÉPA
CR(x) ‚áí ‚àÉv.PA(x, v)
not-null property
C4
fkey(R, A, R‚Ä≤, A‚Ä≤)
‚àÉP ‚àí
A ‚äë ‚àÉP ‚àí
A‚Ä≤
PA(x1, v)
foreign key
‚áí ‚àÉx2.PA‚Ä≤(x2, v)
C5
(pkey(R, A),
CR ‚äë CR‚Ä≤
CR(x) ‚áí CR‚Ä≤(x)
fkey(R, A, R‚Ä≤, A‚Ä≤))
inheritance constraint
(C1) tests disjointness of Tuple and Val. (C2) belongs to
translation of A ‚àà att(R) and checks if PA has the functional
property. (C3) is the result of translation of notnull(R, A)
constraint and tests if any tuple name in CR is connected
via PA with some value name. (C4) is the result of trans-
lation of a foreign key constraint, fkey(R, A, R‚Ä≤, A‚Ä≤), and
tests the inclusion of the set of value names in the ‚Äùsecond
column‚Äù of PA in the set value names in the ‚Äùsecond column‚Äù
of PA‚Ä≤. (C5) belongs to the result of the translation of
{pkey(R, A), fkey(R, A, R‚Ä≤, A‚Ä≤)}, and tests the inclusion of
CR in CR‚Ä≤.
Creating ABox assertions ABox assertions are expressions
of the form: C(a), P(a1, a2), a1 = a2, where C ‚àà NCl, P ‚àà
NOP, and a, a1, a2 ‚àà NInd. Translation of an instance I of R
can be performed using Algorithm 1
Algorithm 1 Creating ABox assertions
Input:
Instance I of R, and an empty ABox A.
Output:
ABox assertions in A representing I.
for each R(t) ‚àà I
UR,t := {A ‚àà att(R) | t.A Ã∏= NULL}
X := a fresh labeled null in ‚àÜVar
if UR,t = ‚àÖ then
A := A ‚à™ CR(X)
else
for each A ‚àà UR,t
A := A ‚à™ PA(X, t.A)
end
B. Semantics of relational knowledge bases
The semantics of R is deÔ¨Åned in the standard way [13] by
means of the interpretation I = ‚ü®‚àÜI,.I ‚ü©, where ‚àÜI is a non-
empty set of individuals, and .I is an interpretation function
286
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-283-7
ICCGI 2013 : The Eighth International Multi-Conference on Computing in the Global Information Technology

assigning to every vocabulary element (i.e., to every individual
name, class name or property name) elements in ‚àÜI, subsets
of ‚àÜI, or binary relations over ‚àÜI, respectively. Semantics of
complex expressions is deÔ¨Åned inductively in a set-theoretical
manner based on semantics of simpler expressions.
The difference between standard TBox axioms in S and
TBox ic-axioms in C, appears mainly in deÔ¨Ånition of consis-
tency [6]. A relational knowledge base R = (N, S, C, A) is
consistent, if
1)
A ‚à™ S has a model, i.e., there is at least one inter-
pretation I in which all formulas belonging to A‚à™S
are satisÔ¨Åed, written I |= A ‚à™ S; and
2)
any minimal Herbrand model of A‚à™S is also a model
of C, i.e., the entailment A ‚à™ S |=mHm C holds.
Intuitively, (1) says that there is no any contradiction
between assertions in A and the general knowledge in S.
In (2), a Herbrand model of A ‚à™ S contains in fact all the
knowledge base knows. This model is a Ô¨Ånite set of assertions
since A is Ô¨Ånite (see Algorithm 1), and axioms in S are
existential-free and without functional symbols (see Table I).
IV.
DATA-TO-KNOWLEDGE EXCHANGE SYSTEMS
A data-to-knowledge exchange (dk-exchange system) sys-
tems we deÔ¨Åne as a mapping M = (œÑ, Œ£), from relational
databases to relational knowledge bases, such that for each
db-schema (R, IC) and every instance I of R,
M(R, IC, I) = (œÑ(R, IC), Œ£(I)) = (N, S, C, A),
where œÑ(R, IC) = (N, S, C), and Œ£(I) = A.
One of the most challenging issues in dk-exchange is to
show that the semantics of the source data is not lost by
the transformation into a knowledge base. The preservation
of semantics of a dk-exchange system M = (œÑ, Œ£) can be
understood in two ways:
1. Soundness of dk-exchange systems with respect to
semantics preservation. M
=
(œÑ, Œ£) is sound w.r.t. se-
mantics preservation if every consistent database (R, IC, I)
is transformed into a consistent relational knowledge base
(N, S, C, A), i.e.,
I |= IC ‚àß œÑ(R, IC) = (N, S, C) ‚àß Œ£(I) = A ‚áí A ‚à™ S |=mHm C.
2. Completeness of dk-exchange systems with respect to
semantics preservation. M = (œÑ, Œ£) is complete w.r.t. se-
mantics preservation if every inconsistent database (R, IC, I)
is transformed into an inconsistent relational knowledge base
(N, S, C, A), i.e.,
I Ã∏|= IC ‚àß œÑ(R, IC) = (N, S, C) ‚àß Œ£(I) = A ‚áí A ‚à™ S Ã∏|=mHm C.
We can show that a dk-exchange system M = (œÑ, Œ£),
where: (1) œÑ creates a vocabulary N, a set of standard TBox
axioms S, a TBox ic-axioms C; and (2) Œ£ creates ABox A, in
the way described in Section III-A, is both sound and complete
w.r.t. semantics preservation ([9]).
Let I be an instance of R (satisfying or not integrity
constraints in IC). Let M(R, IC, I) = (N, S, C, A). Let
us denote S0 = {S1, S2, S3}, and C0 = {C1}. Then the
following properties can be shown:
1)
M such that S = S0 ‚à™ {S5} and C = C0 ‚à™ {C2} is
sound and complete w.r.t. unique integrity constraint
preservation.
2)
M such that S = S0 ‚à™ {S4} and C = C0 ‚à™ {C3} is
sound and complete w.r.t. not-null integrity constraint
preservation.
3)
M such that S = S0 ‚à™ {S4, S5} and C = C0 ‚à™
{C2, C3} is sound and complete w.r.t. primary key
integrity constraint preservation.
4)
M such that S = S0 ‚à™{S5} and C = C0 ‚à™{C2, C4}
is sound and complete w.r.t. foreign key integrity
constraint preservation.
5)
M such that S = S0 ‚à™ {S4, S5, S6} and C =
C0 ‚à™ {C2, C3, C4, C5} is sound and complete w.r.t.
inheritance integrity constraint preservation.
V.
CHECKING CONSISTENCY OF RELATIONAL
KNOWLEDGE BASES
Now, we will consider the problem of verifying whether a
given relational knowledge base is consistent. The problem is
signiÔ¨Åcant if data from many databases is transformed into a
repository in a form of DL assertions, and we are interested if
this repository poses a ‚Äùrelational nature‚Äù, i.e., whether satisÔ¨Åes
a set of standard- and ic-axioms being result of some dk-
exchange. We will use the chase procedure that was developed
as a method for investigating data dependencies [4] and data
exchange [19]. This will be done in two steps: (1) We chase a
minimal Herbrand model H of A ‚à™ S. Since S is existential-
free (thus it is also weakly acyclic), and with no function
symbols ‚Äì we can obtain a Ô¨Ånite solution in a polynomial
time. (2) We will test satisfaction of C in H.
The chase producing H from A is deÔ¨Åned by Algorithm
2. By h we denote a homomorphism that maps constants to
themselves and variables into the set Const ‚à™ ‚àÜVar.
Algorithm 2 Chasing a minimal Herbrand model of A ‚à™ S
Input:
A ‚Äì a set of assertions;
S ‚Äì a set of standard TBox axioms.
Output:
H ‚Äì a minimal Herbrand model of A ‚à™ S.
(1)
H0 := A; i := 0;
(2)
for each Œæ := (œÜ(x, v) ‚áí œà(x, v)) ‚àà S
(3)
while Hi Ã∏|= Œæ do
(4)
for each homomorphism h over (x, v)
(5)
if Hi |=h œÜ(x, v)
(6)
do Hi
Œæ,h
‚àí‚Üí Hi+1;
i := i + 1;
end
end
end
(7)
H := Hi+1
Chase steps ‚Äì comments to Algorithm 2
1)
H0 is initiated with A ‚Äì line (1).
2)
Let Œæ ‚àà S be an axiom of the form œÜ(x, v) ‚áí
œà(x, v) ‚Äì line (2).
3)
If Œæ is not satisÔ¨Åed by Hi, then there is a ho-
momorphism h over (x, v) mapping variables in x
into ‚àÜVar and variables in v into Const, such that
287
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-283-7
ICCGI 2013 : The Eighth International Multi-Conference on Computing in the Global Information Technology

Hi |= h(œÜ(x, v)) and Hi Ã∏|= h(œà(x, v)). Then, we
say that Œæ is applicable to Hi with h ‚Äì lines (3‚Äì5).
4)
The new state of H is equal to Hi ‚à™ h(œà(x, v)), and
the result of applying Œæ to Hi with h is then denoted
as Hi
Œæ,h
‚àí‚Üí Hi+1 ‚Äì line (6).
5)
The Ô¨Ånal result is denoted by H ‚Äì line (7).
The dk-chasing described by Algorithm 2 produces A ‚à™ S
as a closure of A w.r.t. S, and is denoted by A
S
‚àí‚Üí H, meaning
that all applicable axioms in S have been applied to H.
Example 5.1: Given a set of assertions
A = {PId(X1, 1), Name(X1, john), PId(X2, 2), Name(X2, ann),
PId(X3, 3), Name(X3, eva), Course(X4, db), SId(X5, 1),
Faculty(X5, math), SId(X6, 3), EId(X7, 1), ESId(X7, 3),
Course(X7, db), Grade(X7, A)},
verify if it is a representation of an instance of a university
database in Figure 1. For this database schema we have
R = {P(erson), C(ourse), S(tudent), E(xam)},
IC = {pkey(P, PId), pkey(C, CId), pkey(S, SId), pkey(E, EId),
notnull(S, Faculty), fkey(S, SId, P, PId),
fkey(E, ESId, S, SId), fkey(E, Course, C, CId)},
and implicitly in IC are integrity constraints implied by
primary keys and foreign keys (i.e., uniques and not-nulls).
In result of translation, we have œÑ(R, IC) = (N, S, C),
where S is a set of standard TBox axioms of the form given
in Table I, and C is a set of TBox ic-axioms of the form given
in Table II. We will use names, respectively, R and A to denote
a class CR and an object property PA. In particular, (S4), (S5)
and (S6) generate the following axioms:
(a) PId(x, v) ‚áí P(x),
(b) PId(x1, v1) ‚àß PId(x2, v2) ‚àß v1 = v2 ‚áí x1 = x2,
(c) SId(x, v) ‚áí PId(x, v).
Then, in H, being the result of the chase procedure, the
following set of derived assertions is included:
A‚Ä≤ = {P(X1), P(X2), P(X3), C(X4), S(X5), S(X6), E(X7),
PId(X5, 1), PId(X6, 3), X1 = X5, X3 = X6)}.
Now, it is easily seen that all ic-axioms generated by (C4) and
(C5) are satisÔ¨Åed in H. However, the ic-axiom
(d) S(x) ‚áí ‚àÉv.Faculty(x, v),
corresponding to notnull(S, Faculty) ‚àà IC, is not satisÔ¨Åed.
Thus, (N, S, C, A) do not correspond to any consistent in-
stance of the database in Figure 1.
‚ñ°
VI.
CONCLUSION
In this paper, we studied the problem of representing
relational databases in extended DL knowledge bases in a way
that satisÔ¨Åes both information and semantics preservation. We
mainly focused on semantics preservation meaning that a con-
sistent database is mapped into consistent knowledge base (the
soundness), and any inconsistent database is mapped into in-
consistent knowledge base (the completeness). The importance
of the problem is met while creating Web of Data integrating
data coming from many distributed and heterogeneous sources
[20], [21], [22]. Then, the knowledge base (ontological) layer
is used to reason about the data, the metadata and queries in
data integration and data exchange procedures [1].
REFERENCES
[1]
T. Pankowski, ‚ÄúData Exchange Between Relational Knowledge Bases
In The Web Of Data,‚Äù in 15th International Conference on Enterprise
Information Systems (ICEIS), July 04 - 07, 2013 - Angers, France.
INSTICC Press, 2013, pp. 1‚Äì6.
[2]
A. Poggi, D. Lembo, D. Calvanese, G. De Giacomo, M. Lenzerini, and
R. Rosati, ‚ÄúLinking data to ontologies,‚Äù in Journal on Data Semantics
X.
Springer-Verlag, 2008, pp. 133‚Äì173.
[3]
J. D. Ullman, Principles of Database and Knowledge-Base Systems,
Vol. I/II.
Computer Science Press, 1988/1989.
[4]
S. Abiteboul, R. Hull, and V. Vianu, Foundations of Databases.
Read-
ing, Massachusetts: Addison-Wesley, 1995.
[5]
R. Reiter, ‚ÄúTowards a logical reconstruction of relational database
theory,‚Äù in On Conceptual Modelling. Perspectives from ArtiÔ¨Åcial
Intelligence, Databases, and programming Languages, 1982, pp. 191‚Äì
233.
[6]
B. Motik, I. Horrocks, and U. Sattler, ‚ÄúBridging the gap between OWL
and relational databases,‚Äù Journal of Web Semantics, vol. 7, no. 2, 2009,
pp. 74‚Äì89.
[7]
J. Sequeda, S. H. Tirmizi, ¬¥O. Corcho, and D. P. Miranker, ‚ÄúSurvey
of directly mapping SQL databases to the Semantic Web,‚Äù Knowledge
Eng. Review, vol. 26, no. 4, 2011, pp. 445‚Äì486.
[8]
J. Sequeda, M. Arenas, and D. P. Miranker, ‚ÄúOn Directly Mapping
Relational Databases to RDF and OWL (Extended Version),‚Äù CoRR,
vol. abs/1202.3667, 2012, pp. 1‚Äì17.
[9]
T. Pankowski, ‚ÄúSemantics Preservation In Data-To-Knowledge Ex-
change From Relational Databases To Knowledge Bases.‚Äù (submitted),
2013.
[10]
RDF Vocabulary Description Language 1.0: RDF Schema, 2004,
www.w3.org/TR/rdf-schema/ .
[11]
OWL
2
Web
Ontology
Language.
Structural
SpeciÔ¨Åcation
and
Functional-Style Syntax, 2009, www.w3.org/TR/owl-syntax.
[12]
M. Arenas, A. Bertails, E. Prud‚Äôhommeaux, and J. Sequeda, ‚ÄúA Direct
Mapping of Relational Data to RDF,‚Äù 2012, http://www.w3.org/TR/rdb-
direct-mapping.
[13]
F. Baader, D. Calvanese, D. McGuinness, D. Nardi, and P. Petel-
Schneider, Eds., The Description Logic Handbook: Theory, Implemen-
tation and Applications.
Cambridge University Press, 2003.
[14]
F. M. Donini, M. Lenzerini, D. Nardi, W. Nutt, and A. Schaerf, ‚ÄúAn
epistemic operator for description logics,‚Äù Artif. Intell., vol. 100, no.
1-2, 1998, pp. 225‚Äì274.
[15]
D. Calvanese, G. D. Giacomo, D. Lembo, M. Lenzerini, and R. Rosati,
‚ÄúData complexity of query answering in description logics,‚Äù Artif.
Intell., vol. 195, 2013, pp. 335‚Äì360.
[16]
P. P. Chen, ‚ÄúThe entity-relationship model - toward a uniÔ¨Åed view of
data,‚Äù ACM Transactions on Database Systtems, vol. 1, no. 1, 1976,
pp. 9‚Äì36.
[17]
R. Elmasri and S. B. Navathe, Fundamentals of Database Systems.
Redwood City: The Benjamin/Cummings, 1994.
[18]
UniÔ¨Åed Modeling Language. Resource Page, 2005, www.uml.org/.
[19]
R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa, ‚ÄúData exchange:
semantics and query answering,‚Äù Theor. Comput. Sci, vol. 336, no. 1,
2005, pp. 89‚Äì124.
[20]
T. Pankowski, ‚ÄúUsing Data-to-Knowledge Exchange for Transforming
Relational Databases to Knowledge Bases,‚Äù in RuleML 2012, LNCS
7438.
Springer, 2012, pp. 256‚Äì263.
[21]
G. Brzykcy, J. Bartoszek, and T. Pankowski, ‚ÄúSchema Mappings and
Agents‚Äô Actions in P2P Data Integration System,‚Äù Journal of Universal
Computer Science, vol. 14, no. 7, 2008, pp. 1048‚Äì1060.
[22]
T. Pankowski, ‚ÄúSemantics preservation in schema mappings within data
exchange systems,‚Äù in Knowledge Engineering, Machine Learning and
Lattice Computing with Applications, Revised Selected Papers, KES
2012, LNAI 7828.
Springer, 2013, pp. 88‚Äì97.
288
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-283-7
ICCGI 2013 : The Eighth International Multi-Conference on Computing in the Global Information Technology

