Static Stuttering Abstraction for Object Code Veriﬁcation
Naureen Shaukat∗, Sana Shuja∗, Sudarshan Srinivasan†, Shaista Jabeen∗ and Mohana Asha Latha Dubasi†
∗Department of Electrical Engineering
COMSATS University, Islamabad , Pakistan
Email: nsawan23@gmail.com, sanashuja@comsats.edu.pk, shaista.sj@comsats.edu.pk
†Department of Electrical and Computer Engineering
North Dakota State University, Fargo, USA
Email: sudarshan.srinivasan@ndsu.edu, mohanaashalatha.duba@ndsu.edu
Abstract—The biggest challenge in the formal veriﬁcation of an
embedded system software is the complexity and large size of
the implementation. The problem gets even bigger when the
embedded system is an Internet of Things (IoT) device that is
running intricate algorithms. In Reﬁnement-based veriﬁcation,
both speciﬁcation and implementation are expressed as transition
systems. Each behavior of the implementation transition system
is matched with the speciﬁcation transition system with the help
of a reﬁnement map. The reﬁnement map can only project
those values that are responsible to label the current state
of the system. When the reﬁnement map is applied at object
code level, several instructions map to a single state in the
speciﬁcation transition system called stuttering instructions. The
concept of Static Stuttering Abstraction (SSA) is a novel idea
that focuses on ﬁltering common multiple segments of these
stuttering instructions. The patterns are then replaced by mergers
that preserve the behavior of the original object code and
extensively reduce the size of the object code. The smaller code
size also gives the lesser number of stuttering transitions and
eventually more discernible matching between the speciﬁcation
and implementation of transition systems. We have implemented
SSA technique on two platforms using infusion pump as a case
study and the technique has proved consistent in considerably
reducing the size and complexity of the implementation transition
system.
Keywords–Formal veriﬁcation; static stuttering abstraction; stut-
tering instructions; reﬁnement map; infusion pump.
I.
INTRODUCTION
One of the pivotal entities in the ecosystem of Internet
of Things (IoT) is an embedded system due to its capa-
bility of receiving data from sensors and making decisions
independently. From a cell phone to an automobile, all are
comprised of an embedded system; that collects, and senses
data received, collates that data to be analyzed, and conse-
quently perform necessary functions. The functionality of the
embedded system not only encompasses basic I/O, but it also
involves complex communication protocols that consent other
indispensable peripherals to communicate over shared buses
and gateways. Hence, with IoT embedded devices are built
on intricate algorithms, which make the veriﬁcation process
even more complicated. Safeguarding these embedded systems
against errors is an inevitable task especially in those devices
that prevent life-threatening ailments like pacemakers and
insulin pumps. Such devices can cause severe consequences if
the software or hardware malfunctions, making these medical
devices safety critical. For example, from 2001 to 2017, the
Food and Drug Administration (FDA) has issued 54 Class-1
recalls on infusion pumps due to software errors [1]. Hence, an
embedded system which is a thing on the IoT running complex
algorithms, techniques need to be devised for reducing the
complexity and the capacity of veriﬁcation efforts.
An embedded system is comprised of a hardware and a
software. The software is a complex piece of code that is
prone to errors due to the translation process that converts the
high-level code to assembly code. Assembly code is the object
code, which is larger in size and complexity as compared
to its high-level counterpart. The biggest challenge in the
application of formal veriﬁcation techniques is the large size of
the code being executed on the embedded system. Therefore,
the success and efﬁciency of formal veriﬁcation techniques
are highly dependent on the reduction of the size of the code
leading to the need for an abstraction technique to minimize
the length of the code.
The abstraction technique is a transformation of the object
code that will signiﬁcantly reduce the complexity of the
veriﬁcation process. In this paper, we propose a novel ab-
straction technique called Static Stuttering Abstraction (SSA).
As the name suggests, this technique is applied to the object
code directly. The abstraction is developed in the context of
reﬁnement-based veriﬁcation, a formal veriﬁcation technique.
In reﬁnement-based veriﬁcation, both the speciﬁcation and the
implementation of the system are expressed as Transition Sys-
tems (TS). The speciﬁcation TS is the behavior of the system
expressed as states and transitions, whereas the implementation
TS is obtained after the software is symbolically simulated at
the object code level. The implementation TS is therefore very
large as compared to the speciﬁcation TS, as several transitions
of the implementation TS map to a single transition of the
speciﬁcation TS. These several transitions of the implementa-
tion TS that map to a single transition of the speciﬁcation TS
are called stuttering transitions. Stuttering transitions usually
arise from the execution of stuttering instructions, which are
instructions that do not directly modify the state of the system
as is visible at the speciﬁcation level.
The idea with stuttering abstraction is that a ﬁnite sequence
of stuttering instructions can be merged into one. Such a
merger will still preserve the functional behavior of the original
implementation TS but will be reduced in size. We call the
segment obtained due to the merger an abstracted stuttering
segment. Also, we call the reduced TS obtained using such
mergers as the abstracted implementation TS. In this paper, we
present a methodology to apply abstractions on the stuttering
instructions of the implementation TS named static stuttering
abstraction (SSA).
The rest of this paper is organized as follows. Background
is presented in Section II. Section III details related work. The
abstraction technique is described in Section IV. Section V de-
102
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

tails the case studies and gives veriﬁcation results. Conclusion
and future work are noted in Section VI.
II.
BACKGROUND
In reﬁnement-based formal veriﬁcation, both the imple-
mentation and speciﬁcation are expressed as a TS. A TS is
deﬁned as follows [2].
Deﬁnition 1: A TS M is a 3-tuple ⟨S, R, L⟩, where S is
the set of states, R is the transition relation, which is the set
of all state transitions, and L is a labeling function that deﬁnes
what is visible at each state. A state transition is of the form
⟨w, v⟩, where w, v ∈ S.
MM S and MM I denote the speciﬁcation TS and implemen-
tation TS respectively. MM S is an explicit representation of
the requirements of the system thus containing the minimal
number of states and transitions. On the other hand, in MM I
a single execution of an instruction in the object code makes up
for one or more transitions in MM I. Therefore, in reﬁnement-
based formal veriﬁcation techniques, the biggest challenge is
matching a small set of transitions of MM S to a large set of
transitions of MM I.
The abstraction technique is developed in the context
of Well-Founded Equivalence Bisimulation (WEB) reﬁne-
ment [2]. A key idea in WEB reﬁnement is the notion of
reﬁnement maps, which are functions that map implementa-
tion states to speciﬁcation states. The speciﬁcation TSs are
constructed simple and the states include only the predicates
relevant to the property being veriﬁed. Whereas, the imple-
mentation states for object code comprise all the registers in
the target micro-controller and memory locations of relevance.
Therefore, there is big difference in the abstraction-level of the
speciﬁcation and implementation. Reﬁnement maps essentially
extract the relevant variables from the implementation state to
construct the corresponding speciﬁcation state.
The idea with WEB reﬁnement is to match transitions of
the implementation with transitions of the speciﬁcation. Given
an implementation transition ⟨w, v⟩, checking if this transition
matches with a speciﬁcation transition is achieved by applying
the reﬁnement map function r() to both states of the implemen-
tation transition. The resulting transition ⟨r(w), r(v)⟩ should
correspond to a speciﬁcation transition. However, there are four
possibilities. The ﬁrst possibility is the one mentioned above,
that when the reﬁnement map is applied, the implementation
transition does correspond to a speciﬁcation transition. Such an
implementation transition is called a non-stuttering transition.
The second possibility is that one or both of r(w) and r(v)
do not map to any valid speciﬁcation state. This points to
a bug. The third possibility is that both r(w) and r(v) map
to the same speciﬁcation state. In this situation, ⟨w, v⟩ is still
considered to be a correct transition, but one that is not making
visible progress w.r.t. the speciﬁcation TS. Such a transition is
called a stuttering transition. The fourth possibility is that both
r(w) and r(v) map to speciﬁcation states, but ⟨r(w), r(v)⟩
does not correspond to any speciﬁcation transition and ⟨w, v⟩
is not a stuttering transition (as described above). The fourth
case again corresponds to a bug in the implementation.
The common operations in high-level code are translated
to the same set of instructions in the assembly code. Thus, a
single set of instructions may have large multiple numbers
of occurrences, which correspond to a large piece of the
assembly code. The idea of SSA is to identify common
multiple occurrences of two or more stuttering instructions
named as patterns and reduce the length of the pattern by
replacing it with a merger that is a single line instruction
but encompasses all the operations performed by the list of
instructions in the pattern. Therefore, a pattern comprising of
3 stuttering instructions occurring 100 times in the code will
reduce 200 lines of the code and consequently the size of
MM I.
III.
RELATED WORK
There are a number of previous approaches that exploit
the notion of stuttering to improve veriﬁcation scalability. An
algorithm is presented by Groote and Wijs [3] to check the
equivalence between two transition systems based on stutter-
ing. Ray et al. [4] show how to verify concurrent programs
using reﬁnement-based on stuttering trace containment. A
method for the functional correctness of hardware and low-
level software is developed based on reﬁnement-based testing
by Jain and Manolios [5]. Stuttering is introduced in the
context of probabilistic automata by Delahaye et al. [6]. While
the above approaches employ stuttering, they do not apply it
to static object code, which is the focus of our work.
Timed Well-Founded Simulation (TWFS) reﬁnement for
veriﬁcation of real-time Field Programmable Gate Array
(FPGA) is presented by Jabeen et al. [7]. Reachable states of
the FPGA are identiﬁed using manually generated invariants,
without employing abstractions. This approach is feasible for
FPGA only and not for object code with a very large number of
instructions as the manual characterization of reachable states
for object code is impractical.
Theory of automata is employed to stimulate discrete timed
systems and continuous timed systems by Rabinovich [8]. The
concept of stuttering is described, but stuttering abstraction is
not addressed.
Stuttering invariant properties are expressed using spec-
iﬁcation languages by Etessami [9] and Dax et al. [10].
The properties distinguish behaviors of systems regardless of
their stuttering or non-stuttering nature. The properties can be
veriﬁed using a model checker.
A similar idea of stuttering abstraction is presented by
Nejati et al. [11], but static abstraction is not considered.
Stuttering equivalence is employed in the context of the
model checking to present an abstraction technique by De-
Leon and Grumberg [12]. This abstraction technique is applied
dynamically to the transition system and not statically to the
object code.
Our abstraction is applicable to recurring patterns of object
code instructions that are responsible for millions of transitions
in real-time systems. Reﬁnement-based veriﬁcation, which is
a general form of equivalence veriﬁcation is known to scale
well for low-level design artifacts. As can be seen from
the experimental results, the object code that constitutes the
implementation TS is considerably reduced. Next, we explain
SSA.
IV.
AUTOMATIC STATIC STUTTERING ABSTRACTION
A. Static Stuttering Abstraction (SSA)
The need to develop an abstraction technique for the object
code is to ensure efﬁciency and scalability of the veriﬁcation
103
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

process. One of the challenges in reﬁnement-based veriﬁcation
is the complex behavior of the object code. SSA ensures
that the object code is transformed into a comparatively
smaller piece of code; which consequently reduces the
complexity and effort involved in the veriﬁcation process.
SSA is applied after the high-level code is translated to object
code, then patterns comprising of stuttering instructions si
called stuttering patterns sp with the multiple numbers of
occurrences are identiﬁed. The pattern is called a stuttering
pattern because none of the instructions in the pattern update
the values projected by the reﬁnement map. Let’s take
stepper motor as an example for the speciﬁcation transition
system. The pins of the embedded system (LPC1768) that are
responsible for rotating a 4-lead stepper motor and changing
the current state is connected to the 4 rightmost pins of
general purpose I/O, i.e., LPC GPIO1. So as long as the
assembly instruction does not change the contents of the
register associated with LPC GPIO Port 1 (LPC GPIO1),
the instruction is a stuttering instruction si. An example of a
segment containing a non-stuttering instruction is given below:
0x0000067A
2001
MOVS
r0,0x08
0x0000067C
4953
LDR
r1,[pc,332] ; @0x000007CC
0x0000067E
6388
STR
r0,[r1,0x38]
The
ﬁrst
instruction
in
the
above
segment
moves
the
binary 1000 in r0, the second instruction loads the base
memory address of the peripheral registers of LPC1768. The
third instruction is a store instruction that stores a value of
the binary 1000 in rightmost 4 bits of LPC GPIO1 (to
the address calculated by adding an offset of 38 to the base
address of 0x000007CC in order to access the address of
GPIO Port1 register). Moving a value of 4 in LPC GPIO1
asserts the leftmost lead of the stepper motor, and hence
the stepper motor will take a step and the implementation
transition system gets a new state. The STR instruction
is hence a non-stuttering instruction ni, as it has changed
the state of the system. This implementation state can be
matched to a speciﬁcation state by employing the reﬁnement
map and extracting the rightmost four bits of the register
LPC GPIO1 and mapping them to the speciﬁcation states.
The reason for not abstracting a segment with a non-stuttering
instruction ni is to preserve the independence and behavior
of the system, as in a merger a single instruction is supposed
to depict multiple parallel operations.
The stuttering patterns sp on the other hand, comprise of
stuttering instructions si only. These patterns are observed
and are replaced by mergers that preserve the functional
behavior of the original MM I, but will be reduced in size.
Below is an example of sp,
0x00000622
4968
LDR
r1, [r3,416]; @0x000007C4
0x00000624
2001
ADDI
r1, 0x04,
0x00000626
6008
STR
r1, [r3,416]
The above pattern is a set of instructions that essentially
update the contents of a memory location 0x000007C4 by
adding 4 to it. Modern processors are not equipped to do
such operations in 1 clock cycle. However, we replace these
3 instructions with a single merger as given below,
0x00000622
7968125
LAS
[r3,416], 0x04
The merger is given a new name LAS abbreviated from
Load-Add-Store and is assigned a new opcode for reference.
Merger LAS is updating the contents of a memory location
0x000007C4 by directly adding 4 to it in a single instruction.
An interesting thing to note here is that the original pattern
occupies addresses 0x00000622 to 0x00000626, whereas the
merger is only contained at 0x00000622. If each instruction
in the original code gives rise to 100 stuttering transitions
thus causing a total of 300 stuttering transitions, the merger
only corresponds to 100 stuttering transitions. In SSA, we
are not concerned with the implementation of the merger on
the actual processor. Rather the merger is the abstraction that
enables more scalable veriﬁcation. A library is maintained for
stuttering patterns and the corresponding mergers with the
type of operation, name of instruction and the opcode shown
in Table I.
B. Procedure of SSA
Algorithm 1 shows a procedure that applies SSA to the
object code. The inputs to the procedure are,
1)
Initial object code ﬁle(init obj code)
2)
A matrix (path opc mat) that contains information
regarding opcode of instructions involved in each
pattern is shown in Figure 1.
Figure 1. Patterns Opcode Matrix
Each row contains information about the pattern. The
ﬁrst column depicts the instruction types in a pattern.
The ﬁrst row in M contains the pattern LDR-STR,
which based on the observation and research has
the highest number of frequency in the assembly
ﬁle. The second column of pattern LDR-STR (row
1) contains the opcode of LDR, the third column
contains the opcode of STR. As this pattern only
contains 2 instructions so rest of the columns get
no opcode values (X). Similarly, row 2 has pattern
MOV-STR that has the second highest number of
occurrences, second and third columns of row 2 get
opcodes values for MOV and STR respectively. Same
goes for the rest of the rows and columns.
3)
Reﬁnement map (ref−map)
The procedure Stutt Abs outputs the updated object code
upd obj code, which reﬂects the abstracted implementation
TS. The total number of patterns count is calculated statically
through a function No−of−Rows (line 2). It is equal to the total
104
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

number of rows in matrix patt opc mat. Nc keeps a record
of the number of patterns that have been abstracted so far in
the algorithm. Its initial value is 0 and maximum value must
be equal to count. Value of Nc will be incremented by one
when the search for a pattern starts in init obj code (line 4).
It will be incremented when the search for a pattern in object
code completes. sp is the number of lines in each pattern. It
is computed through a function patt size (line 6). Function
counts the total number of numeric values in each row. Its
value must be greater than 2. Nopc is a variable that is used
to keep track of the number of lines in each pattern (line 7).
Function Next − Ins − Fetcher is used to ﬁnd the Next
instruction Ic in init obj code (line 8). Opc represents the
opcode of an instruction Ic and is calculated through function
Opc−Cal (line 9).
In order to abstract the instructions, Opc must match with
already deﬁned opcode in patt opc mat (line 10). If both
opcodes are matched (line 10), the instruction Ic is stored in
buff (line 11) else algorithm will set Nopc to 0 (line 26),
initialize the buffer buff again, and go to step 6 (line 28) to ﬁnd
the pattern in rest of the object code. To abstract instructions
stored in the buff, Nopc must be equal to sp (line 12). It
indicates that all the required instructions in a pattern are stored
in the buff. If sp ̸= buff, control will go to step 6 again (line
23).
In order to abstract instructions stored in the buff, it is
required that they all should be stuttering instructions. The
stuttering or non-stuttering nature of instructions is computed
using a function ref map (line 13). Output res of function
ref map will be ‘1’ if instructions in the buff are stuttering
and ‘0’ in case of non-stuttering instructions. If instructions
in the buff are stuttering (line 15), init obj code is updated
by abstracted instruction through a function mrg (lines 16-
17). Instructions in buff cannot be abstracted if they are non-
stuttering (line 18) and the algorithm will start searching for a
pattern in rest of the object code (lines 19-20). obj code end
is representing the end of an object code. It is computed using
function code comp (line 27) and the initial value is 0. The
algorithm will repeat until each pattern consisting of stuttering
instructions is not abstracted in whole object code (line 28).
The whole algorithm will repeat until Nc become equal to
count (line 29).
The abstracted Object Code depicts the functionality of the
original object code and it does not change the essence of the
original object code.
V.
CASE STUDY AND RESULTS
We have implemented SSA on the object code of an
infusion pump. The basic functionality of an infusion pump
is to inject medicine, which is done using a stepper motor.
This behavior is modeled on an ARM Cortex-M3 based NXP
LPC1768 microcontroller, and the assembly code is obtained.
The number and type of patterns observed and caught by the
automatic SSA are given in Table II. The assembly ﬁle is
comprised of 335 lines of code for one cycle of execution,
which after applying SSA is reduced to 234 instructions.
The result conﬁrms that stuttering abstraction reduces
30.3% of the object code. To show that the algorithm can work
consistently on another platform, infusion pump object code
was developed for another platform ATMega382P microcon-
troller. In this case, 26.1% of object code is reduced through
1: procedure Stutt Abs(init obj code, patt opc mat, ref−
map)
2:
count = No−of −Rows(patt opc mat)
3:
repeat
4:
Nc++;
5:
repeat
6:
sp ←patt− size(patt opc mat(Nc, :));
7:
Nopc++;
8:
Ic ← Next−Ins−Fetcher(init obj code);
9:
Opc←Opc−Cal(Ic);
10:
if [Opc=patt opc mat(Nc, Nopc)] then
11:
buff(Nopc)←Ic;
12:
if [sp = Nopc] then
13:
res←ref − map(buff)
14:
N opc = 0;
15:
if [res = 1] then
16:
upd obj code←mrg(buff,init obj code);
17:
init obj code← upd obj code;
18:
else
19:
buff −initialized−again;
20:
again−go−to−step6;
21:
else
22:
again−go−to−step6;
23:
else
24:
N opc = 0;
25:
buff −initialized−again;
26:
again−go−to−step6;
27:
obj code end←code comp(init obj code);
28:
until !(obj code end = 1)
29:
until !(Nc =count)
30: return upd obj code
Figure 2. Procedure for Static Stuttering Abstraction
SSA. The results in Table II depict that SSA consistently
reduces the size of the object code, this is for one execution
cycle of the code, whereas in real-time systems the object
code is executed in an inﬁnite loop. Also, the reduction in
object code will considerably reduce the number of stuttering
transitions, which is a huge problem in reﬁnement-based
veriﬁcation.
VI.
CONCLUSION AND FUTURE WORK
We have developed SSA and shown that the technique can
be effectively applied to object code. We have demonstrated
static abstractions on object code of infusion pump controller
implemented on two different micro controller platforms to
reason about the consistency and efﬁciency of the proposed
algorithm. The results demonstrate that static abstraction once
applied on stuttering instructions is capable of reducing one-
third of the object code, which exponentially reduces the
number of stuttering transitions in the implementation tran-
sition system. In the context of model checking, several other
abstraction techniques have been developed but they have not
targeted a very large state space like object code.
In the future, we plan to explore the combination of
dynamic stuttering abstraction and static stuttering abstraction
and experimentally evaluate this combination. Dynamic stutter-
ing abstraction is the technique where the abstraction is applied
to the transition system obtained by symbolically simulating
105
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

TABLE I. PATTERNS AND THE MERGERS OF AN LPC1768 OBJECT CODE FOR INFUSION PUMP
Serial
Number
No of Instructions
in Pattern
Frequency Of Pattern
No. of
Lines
Reduced
Instruction Type
Instruction Opcode
Abstracted
Merger Label
Merger
Opcode
(ASCII)
Merger
Opcode
(Binary)
1
2
13
13
LDR (PC)
STR
[01001]
[01100]
LST
768384
01110110
2
2
3
3
MOVS
STR
[00100]
[01100]
MST
778384
01110111
3
2
2
2
LSLS
STR
[00000]
[01100]
STL
838476
10000110
4
3
15
30
MOVS
LDR (PC)
STR
[00100]
[01001]
[01100]
OMS
797783
01111001
5
3
2
4
MOVS
MOV (32 Bit)
STR
[00100]
[F04F]
[01100]
VMS
867783
10000110
6
4
9
27
LDR (PC)
LDR (REGISTER)
CMP
BNE
[01001]
[00100]
[00101]
[11010001]
BCL
666776
01100110
7
2
7
7
LDR (PC)
LDR (REGISTER)
[01001]
[00100]
TLR
847682
10000100
8
3
3
6
LDR (PC)
LDR (REGISTER)
STR
[01001]
[00100]
[01100]
RSL
828376
10000010
9
2
2
2
LDR (PC)
STR (32 Bit)
[01001]
[F8C1]
DLS
687683
01101000
10
2
4
4
LST (User Deﬁned)
TLR (User Deﬁned)
[01110110]
[10000100]
NLT
787684
01111000
11
2
1
1
MOV (32-Bit)
LDR (Register)
[F04F]
[00100]
CML
677776
01100111
12
2
2
2
LST (User-Deﬁned)
LST (User-Deﬁned)
[01110110]
[01110110]
ELT
697684
01101001
13
2
2
1
OMS (User-Deﬁned)
OMS (User-Deﬁned)
[01111001]
[01111001]
FOS
707983
01110000
TABLE II. RESULTS OBTAINED ON LPC1768 AND ATMEGA382P
Metrics
LPC1768
ATMEGA382P
Number of Lines in Original Object Code
336
524
Number of Lines reduced in Original Object Code
102
139
Number of Lines in Abstracted Object Code
234
385
Total Number of patterns that are abstracted in Object Code
13
21
Percentage of Object Code Abstraction
30.3%
26.5%
the object code.
ACKNOWLEDGMENT
This publication was funded by a grant from the United
States Government and the generous support of the American
people through the United States Department of State and the
United States Agency for International Development (USAID)
under the Pakistan - U.S. Science & Technology Cooperation
Program. The contents do not necessarily reﬂect the views of
the United States Government.
REFERENCES
[1]
“Medical
Device
Recalls,”
2017,
URL:
https://www.fda.gov/
MedicalDevices/Safety/ListofRecalls/ucm535289.htm
[accessed:
Nov,2018].
[2]
P. Manolios, “Mechanical veriﬁcation of reactive systems,” PhD thesis,
University of Texas at Austin, 2001.
[3]
J. F. Groote and A. Wijs, “An O(m log n) Algorithm for Stuttering
Equivalence and Branching Bisimulation,” CoRR, vol. abs/1601.01478,
2016.
[4]
S. Ray and R. Sumners, “Speciﬁcation and Veriﬁcation of Concurrent
Programs Through Reﬁnements,” J. Autom. Reasoning, vol. 51, no. 3,
2013, pp. 241–280.
[5]
M. Jain and P. Manolios, “An Efﬁcient Runtime Validation Framework
based on the Theory of Reﬁnement,” CoRR, vol. abs/1703.05317, 2017.
[6]
B. Delahaye, K. G. Larsen, and A. Legay, “Stuttering for Abstract
Probabilistic Automata,” J. Log. Algebr. Program., vol. 83, no. 1, 2014,
pp. 1–19.
[7]
S. Jabeen, S. Srinivasan, and S. Shuja, “Formal veriﬁcation methodol-
ogy for real-time Field Programmable Gate Array,” IET Computers &
Digital Techniques, vol. 11, no. 5, 2017, pp. 197–203.
[8]
A. M. Rabinovich, “Automata over continuous time,” Theor. Comput.
Sci., vol. 300, no. 1-3, 2003, pp. 331–363.
[9]
K. Etessami, “Stutter-Invariant Languages, omega-Automata, and Tem-
poral Logic,” in Computer Aided Veriﬁcation, 11th International Con-
ference, CAV ’99, Trento, Italy, July 6-10, 1999, Proceedings, 1999,
pp. 236–248.
[10]
C. Dax, F. Klaedtke, and S. Leue, “Speciﬁcation Languages for Stutter-
Invariant Regular Properties,” in Automated Technology for Veriﬁcation
and Analysis, 7th International Symposium, ATVA 2009, Macao, China,
October 14-16, 2009. Proceedings, 2009, pp. 244–254.
[11]
S. Nejati, A. Gurﬁnkel, and M. Chechik, “Stuttering Abstraction for
Model Checking,” in Third IEEE International Conference on Software
Engineering and Formal Methods (SEFM 2005), 7-9 September 2005,
Koblenz, Germany, 2005, pp. 311–320.
[12]
H. De-Leon and O. Grumberg, “Modular Abstractions for Verifying
Real-Time Distributed Systems,” Formal Methods in System Designg,
vol. 2, 1993, pp. 7–43.
106
Copyright (c) IARIA, 2018.     ISBN:  978-1-61208-683-5
CYBER 2018 : The Third International Conference on Cyber-Technologies and Cyber-Systems

