Transforming XPath Expressions into Relational Algebra Expressions With Kleene 
Closure 
Yangjun Chen 
Dept. Applied Computer Science, University of Winnipeg 
515 Portage Ave., Winnipeg, Manitoba, Canada, R3B 2E9 
y.chen@uwinnipeg.ca 
 
 
 
Abstract—In the problem of translating XPath expressions into 
SQL queries, the most challenging part is to find a way to 
minimize the use of least fixpoint (LFP) operators when a DTD 
graph contains cycles. In this paper, we address this issue and 
present a new algorithm to do the task based on the 
recognition of a kind of DTD graphs, which can be reduced to 
a single node by contracting nodes into their parents one by 
one. For this kind of DTD graphs, not only the corresponding 
relational algebra expressions can be efficiently generated, but 
the use of LFP operators can also be minimized. For those 
DTD graphs that are not reducible, we devise a different 
algorithm which is less efficient than the algorithm for 
reducible graphs, but more efficient than any existing method. 
Keywords: XML, XPath, Query Processing 
I. 
 INTRODUCTION 
With the widespread of XML both as a document format 
and as a data exchange format, the interest in querying XML 
data stored in relational databases has increased. With this 
comes the need for answering XML queries in a relational 
database system, by translating XML queries to SQL 
statements [11, 19, 21]. It is quite different from the 
prevailing methods for evaluating twig joins [7, 8, 9, 10, 11]. 
Let D be a DTD (Document Type Definition). Let R be a 
relational schema defined for D by using the shared-inlining 
technique [24], denoted as a mapping f: D → R. Denote by 
D all the XML documents conforming to D. Denote by R 
all the possible relational states of R. Then, the storage of a 
set of documents conforming to D in DB(R) (a database 
with the relational schema R) can be considered as a 
mapping derived from f, denoted as  fs: 2D  → R. 
Given an XPath expression Q, what we want is to find 
an equivalent relational algebra expression Q’, which can be 
evaluated against DB(R), such that for any document d ∈ D, 
Q on d can be answered by Q’ on fs({d}). That is, the set of 
nodes selected by Q on T equals the set of tuples selected by 
Q’ on fs({d}). We denote this by 
 
Q(T) = Q’(fs ({d})). 
When a DTD is simply a tree or a DAG (directed acyclic 
graph), a simple translation can be conducted by 
enumerating all matching paths of the input XPath 
expression in the DTD, sharing common subpaths, rewriting 
the paths as relational algebra expressions, and taking a 
union of all of them [12]. However, when a DTD contains 
recursive element type definition, the problem becomes 
challenging [4, 5]. In this case, the interaction between 
recursion in the DTD and recursion (descendant-or-self axis, 
represented by ‘//’) in an XPath expression significantly 
complicates the translation.  
In the past decade, a lot of work has been done on 
querying XML data stored in relational databases such as 
those discussed in [7, 9, 10, 12, 14, 23]. However, as 
surveyed in [15], in all these methods, except the strategies 
proposed in [14, 25], the problem of translating recursive 
XML queries over recursive DTD is not addressed. 
The method discussed in [14] is capable of translating 
path queries with ‘//’ to a sequence of SQL queries using the 
SQL’99 recursion operator. However, the SQL queries 
produced by [14] tend to be large and complicated and 
cannot be effectively optimized. Also, as pointed out by Fan 
et al. [25], the method is applicable only to a very limited 
class of path expressions. 
In [25], Fan et al. proposed a different method. The main 
idea of this method is to transform an XPath expression to 
an extended XPath expression, in which some variables may 
be used to represent sub-expressions. In addition, any ‘//’ is 
replaced with a Kleene closure. Given an extended XPath 
expression, a sequence of relational algebra expressions can 
be easily created. The time complexity of this process is 
bounded by O(|D|3|Q|log|D|). When translated to an 
extended XPath expressions, a Kleene closure of the form: 
E* corresponds to a sub-expression of the form: A//B in an 
XPath expression, and E represents all the paths from A to B 
in the corresponding DTD graph. 
However, the generated expressions are also very large 
with many unnecessary joins involved. For example, for the 
graph shown in Fig. 1, the regular expression generated by 
Fan’s algorithm [25] for the path from v1 to v1 would be  
 
e0 ∪ e0* ∪ ((e1 ∪ e0*⋅e1)/( e4⋅e0*⋅e1)* ⋅ (e4 ∪ e4⋅e0*)). 
 
But the minimized regular expression for this is (e0 ∪ e4 
∪ e2)*. In the Appendix, we will make a sample trace to 
show how Fan’s algorithm [25] works in generating such a 
complicated expression over the above graph. 
It is obvious that the Kleene closure is a very costly 
operation. It dominates the whole query evaluation time. So, 
Fig. 1. A directed graph 
e4
e3 
e2 
e1
v3
v1 
v2 
e0
114
DBKDA 2011 : The Third International Conference on Advances in Databases, Knowledge, and Data Applications
Copyright (c) IARIA, 2011              ISBN:978-1-61208-115-1

it is necessary to reduce the size of E such that as few joins 
as possible are involved. 
In this paper, we propose a new algorithm to mitigate the 
problem to some extent. We will recognize a class of DTD 
graphs G, for which a reduction sequence of nodes: v1, 
v2, …, vn = r can be found such that G can be reduced to a 
single node r, where n is the number of G’s nodes. For this 
kind of DTD graphs, we can create a relational algebra 
expression in O(mlogn) time, where m is the edges of G. 
More importantly, we can always find a way to generate 
minimized relational algebra expressions for them. For 
those non-reducible graphs, we propose a different 
algorithm. Although it is less efficient than the algorithm for 
the reducible graphs, it is more efficient than any existing 
strategies. 
The paper contains five sections. In Section 2, we review 
DTDs, XPath expressions, and schema-based mapping from 
XML to relations. In Section 3, we concentrate on the 
recursion in XPath expressions. Section 4 is devoted to the 
general process for transforming XPath queries to relational 
algebra expressions. Finally, the paper concludes in Section 
5. 
II. 
BASIC CONCEPTS 
In this section, we review DTDs and XPath expressions, 
as well as the XML data storage in relational databases to 
provide a discussion background. 
- DTD 
Abstractly, an XML DTD can be considered as a triple 
<H, S, r>, where H is a set of element types (corresponding 
to element tag names); r is the root type; and S is a set of 
rules defining the types in H. That is, for any type A in H, 
S(A) (the definition of A) is an expression: 
 
β ::=  ε | B | β, β | (β | β) | β*,  
where ε is the empty word, B represents a type in H 
(referred to as a subelement or child type of A), and ‘|’, ‘,’ 
and ‘*’ denote disjunction, concatenation, and the Kleene 
star, respectively. We refer to A → S(A) as the production of 
A. 
We will represent a DTD D as a graph, called the DTD 
graph of D and denoted by GD, as done in [24]. In GD, each 
node stands for a distinct element type and each edge for a 
parent/child relationship. In addition, an edge (A, B) is 
marked with ‘*’ if B is enclosed in a definition of A with the 
form: β*.  
As an example, see the DTD graph shown in Fig. 2, 
representing a DTD: <H, S, dept> with 
 
H = {dept, course, cno, title, time, prereq, takenBy, 
 
 
taughtBy, professor, pno, pname, teaching, student, 
sno, sname, qualified}, and 
 
S defined as follows: 
 
dept → course* 
course → cno, title, time, prereq, takenBy, taughtBy 
 
prereq → course* 
 
takenBy → course* 
 
taughtBy → professor* 
 
student → sno, sname, qualified 
 
qualified → course* 
 
professor → pno, pname, teaching 
 
teaching → course* 
 
In the above DTD graph, we handle each attribute as a 
primitive element type for simplicity. But it obviously does 
not lose any generality. 
A DTD is recursive if it has an element type that is 
defined (directly or indirectly) in terms of itself. When 
represented as a graph, it will contain a few nested and 
overlapping cycles. So the DTD shown in Fig. 2 is recursive. 
- XPath expressions 
XPath [6] is a popular language for querying XML data. 
It has been used in many XML applications and in some 
other languages for querying and transforming XML data, 
such as XQuery and XSLT. In this paper, we address a 
practical fragment of XPath, in which each path in a 
predicate can be compared with a constant, but not with 
another path, given as below: 
 
p ::= . | A | * | p/p | p//p | p[q] | 
 
q ::= p | p δ c | ¬q | q ∨ q | q ∧ q 
 
δ ::= ‘=’ | ‘!=’ | ‘>’ | ‘>=’ | ‘<’ | ‘<=’ 
where ‘.’, A, and * denote the self-axis, a type (element tag 
name) and a wild card, respectively. ‘/’ and ‘//’ are child-
axis and descendant-or-self-axis, respectively; and [q] is a 
predicate (also referred to as a qualifier), in which c is a 
constant and δ represents a comparison relation. For 
example, the following XPath expression 
 
/dept/course[title = ‘XML’ or 
 
(¬(time = 2008) and prereq = ‘CS2201’)]//professor 
selects the professor who taught a course either with title 
‘XML’ or with the prerequisite ‘CS2201’ but not in 2008. 
Such an XPath expression can be represented as a tree with 
five kinds of nodes: axis-tag nodes (at-node), logical-AND 
nodes (∧-node), logical-OR nodes (∨-node), logic-negation 
node, and constant node: 
• at-node: An axis-tag node in the tree stands for one 
location step. It has the content /tag or //tag. 
• ∧-node: A logical-AND node connects two or more child 
subtrees with AND logic. 
• ∨-node: A logical-OR node connects two or more child 
subtrees with OR logic. 
• ¬-node: A logical-negation node negates the result of its 
unique subtree. 
dept
course
cno title 
taughtBy 
pno pname teaching
sno sname qualified
student 
professor
takenBy 
time prereq
Fig. 2. A DTD graph 
*
*
*
*
*
*
115
DBKDA 2011 : The Third International Conference on Advances in Databases, Knowledge, and Data Applications
Copyright (c) IARIA, 2011              ISBN:978-1-61208-115-1

• C-node: A constant node is a value of the form: = c, != c, 
< c, > c, <= c, or >= c.  
For example, the above XPath expression can be 
represented as a tree shown in Fig. 3. 
 
For any at-node v, we use v.axis and v.tag to refer to the 
axis (‘/’ or ‘//’) and the tag appearing in v, respectively. In 
addition, we define some operations on query tree nodes: 
children(v) – returns all child nodes of v; 
parent(v) – returns the parent of v; 
atChildren(v) – returns a set of at-nodes in the subtree 
rooted at v, which are reachable without traversing through 
other at-nodes. 
atParent(v) – returns the nearest ancestor at-node of v. 
For example, given the query tree in Fig. 3, we have 
children(v1)  = {v2, v11}, parent(v5) = v2, atChildren(v1)  = 
{v3, v7, v9, v11}, atParent(v9) = v1. 
- Mapping a DTD into a relation schema 
In order to store a set of XML documents (conforming 
to a certain DTD D) in a relational database, we will first 
establish a map f: D → R from D to a relational schema R. 
To this end, we will first removed all the edges marked with 
‘*’ in GD, dividing it into several node-disjoint components: 
G1, …, Gk. Each Gj is then mapped to a relation schema Rj 
in R, which has three attributes: ID (identifier of elements), 
P (parent of the current element) and V (for the values of all 
the other attributes). If Gj has more than one incoming edges, 
we will use a parentCode attribute [24] to distinguish 
among different parents. 
From f, one can easily derive a data mapping fs: 2D  → R, 
representing the storage of a set of documents in DB(R). 
Let d be a document conforming to D. Then, in fs({d}) (the 
database storing d), a tuple (id, p, v) in a relation with a 
certain schema RA represents an element in d with its 
identifier equal to id, its parent element identifier to p, and 
all its attribute values represented by v. For example, the 
DTD shown in Fig. 1 can be mapped to four relation 
schemas: Rd, Rc, Rp, and Rs, representing dept, course, 
professor, and student, respectively. These four relation 
schemas are connected as shown in Fig. 3(a). In Fig. 3(b), 
we show a sample database, in which for each relation only 
values for ID and P are displayed. (See [24] for a detailed 
discussion.) 
 
III. 
ON THE RECURSION IN XPATH 
The most difficult issue in translation of XPath 
expressions is the treatment of //-axis. In this section, we 
mainly address this problem. The discussion of a general 
process for the transformation is shifted to the next section. 
A. Reducible subgraphs 
Consider an XPath query A//B over a DTD D. This 
query, when evaluated at an A-element in a document T 
conforming to D, is to find all B-elements which are the 
descendants of the A-element. To do this, Fan et al. [25] 
proposed an algorithm to create a sequence of extended 
XPath expressions to represent all the paths connecting A to 
B. (An extended XPath is a regular XPath expression [18] 
with variables being used.) As shown in the introduction, an 
extended XPath expression generated by Fan et al. [25] can 
be very large. 
To mitigate this problem, we recognize a class of graphs, 
for which not only the corresponding relational algebra 
expressions can be efficiently created, but the use of LFP 
operations is minimized. 
First, we notice that what we want is to produce an 
expression for a graph containing all the paths from a node 
α to another nodeβ in a certain graph G. We call such a 
graph an αβ-graph, denoted as G[α, β].  Obviously, every 
node in G[α, β] is reachable from α. 
Definition 1 An αβ-graph G[α,β] is reducible if it can be 
reduced to a graph consisting of a single node by means of 
the following transformations: 
O1 (Remove a loop): If e is an edge such that head(e) = 
tail(e), delete e. (Note that for an edge e = (a, b), head(e) 
= a and tail(e) = b.) 
O2 (Remove a node): If u ≠ α is a node such that all edges e 
with tail(e) = u have head(e) being a same node v, 
contract u into v by deleting u and all edges from v to u, 
and converting any edge e with head(e) = w into an edge 
e’ with head(e’) = v and tail(e’) = tail(e). (We remark 
that v may be connected to u by multiple edges.) 

 
If in a certain step we cannot find a node (≠ α) which 
has only one parent, the process gets stuck. Then the 
corresponding αβ-graph is non-reducible. Since for the αβ-
graph in the graph shown in Fig. 4(a) the reduction can 
always be conducted, it is reducible. 
To check whether an αβ-graph is reducible, we do the 
following operation repeatedly. 
1. Remove all the loops. 
2. Check each u in the αβ-graph to see whether O2 can be 
applied to it. If it is the case, contract it.  
Obviously, this process requires O(n2 ) time, where n is 
the numbers of the nodes of the αβ-graph. 
From the above discussion, we can see that for a 
reducible αβ-graph a reduction sequence of nodes: v1, v2, …, 
vn = α can be found such that the αβ-graph can be reduced 
to α by removing vi in the sequence. For convenience, we 
call α the root of the αβ-graph. For example, for the G[Rc, 
Rp] shown in Fig. 5, the reduction sequence of the nodes is: 
Rs, Rp, Rc. Its root is Rc. 
Accordingly, we also get a sequence of graphs: G0, 
G1, …, Gn-1 such that G0 is the original αβ-graph and Gi = 
Gi-1/{vi} for i > 0 (see Fig. 5 for illustration). For an edge e 
∈ Gi, we use headi(e) and taili(e) to represent its head and 
tail in Gi, respectively. We notice that for the same edge e 
appearing in Gi and Gj with i ≠ j, it is possible that headi(e) 
≠ headj(e). For instance, in G0 (see Fig. 5), head0(e2) = Rs. 
But in G1, head1(e2) = Rc. However, for any e, if it appears 
in G0, G1, …, Gi for some i, we must have tail0(e) = tail1(e) 
= … = taili(e). 
In the graph reduction process, we can associate each 
node v with three data structures to facilitate the creation of 
relational algebra expressions: 
loop(v): a set of edges such that for each e in the set 
there exists Gi for some i such that we have headi(v) = 
taili(v). 
non-loop(v): a set of edges, along which v is contracted 
into another node. (Remember that we may have multiple 
edges in a graph.) 
contractor(v): a node, into which v is contracted. 
Since each node has only one contractor, the contraction 
process can be represented by a tree (called a contraction 
spanning tree and denoted as CST), in which there is an 
edge from v to u if u is contracted into v. 
Example 1 In the graph reduction process shown in Fig. 5, 
a set of data structures will be constructed, as shown in Fig. 
6(a). Fig. 6(b) shows the corresponding CST tree. 
 
In order to generate an expression for a reducible αβ-
graph, we explore the correspnding CST tree bottom-up. 
During the traversal of the CST, for each encountered node 
v, the associated data structures are used to generate an 
expression for it, which is then utilized to create an 
expression representing all the paths from the root to v.  
Algorithm gen-expression(T) (*T is a CST.*) 
begin 
1. search T bottom-up; 
2. for each encountered node v do 
3. { Ev ← φ; Qv ← φ; 
4.  
for each e ∈ non-loop(v) do 
5.  
 {Ev ← Ev ∪ 
( )
Rhead0 e
 
( )
Rtail0 e
;} 
6.  
for each e ∈ loop(v) do 
7.  
{let v1 → … → vk be the path from v to head0(e) in T; 
8.  
 Q ← 
1v
E ⋈ … ⋈
kv
E ; 
9.  
 Qv ← Qv ∪  Q  ⋈
( )
Rhead0 e
⋈
( )
Rtail0 e
; 
10.  
} 
11.  
Ev ← Ev ⋈ Qv*; 
12. } 
13. for each node v do 
14. { let u1 → … → uj be the path from α to v in T; 
15.  
Eα-v ←  
u1
E ⋈ … ⋈
u j
E ; 
16. } 
End 
The algorithm works in two phases. The first phase 
consists of lines 1 - 12. The second phase consists of lines 
13 - 16. In the first phase, we create an expression for each 
node v. In the second phase, for each node v, the expression 
representing all paths from the root to it is generated by 
using the expressions generated in the first phase. 
Example 2 Applying the above algorithm to the CST tree 
and the data structures shown in Fig. 6, we will generate the 
following expressions step by step. 
first phase: 
Step 1:  access Rs. loop(Rs) = φ. non-loop(Rs) = {e3}. 
 
 Es = Rc ⋈ Rs. 
Step 2:  access Rp. loop(Rp) = φ. non-loop(Rp) = {e1}. 
 
 Ep = Rc ⋈ Rp. 
Step 3:  access Rc. loop(Rp) = {e0, e2, e4}. 
 
 head0(e0) = Rc. head0(e2) = Rs. head0(e4) = Rp. 
 
 head0(e3) = Rpub. 
 
 Ec = (Rp ⋈ Rp ∪ 
 
  
(Rc ⋈ Rs) ⋈ (Rs ⋈ Rc) ∪ 
Rc 
e4 
e1 
Rc
remove loop e0 
contract Rs  into Rc 
remove loop e2 
contract Rp  into Rc 
remove loop e4 
Fig. 5. Illustration of graph reduction 
G2: 
Rs 
Rc 
Rp 
e4 
e3 
e2 
e1 
e0 
Rc 
Rp
e4
e1
e2 
G0 = G(Rc, Rp): 
G1: 
loop(v)
non-loop(v)
contractor(v)
Rs 
 
e3 
Rc 
Rp 
 
e1 
Rc 
Rc 
e0, e2, e
 
 
Rc 
Rs
Rp 
(a) 
Fig. 6. Data structures and contraction tree
(b)
117
DBKDA 2011 : The Third International Conference on Advances in Databases, Knowledge, and Data Applications
Copyright (c) IARIA, 2011              ISBN:978-1-61208-115-1

 
 
 
(Rc ⋈ Rp) ⋈ (Rp ⋈ Rc))* 
 
  
= (Rp ∪ Rc ⋈ Rs ∪ Rc ⋈ Rp)* 
second phase: 
Step 4:  Ec-s = Ec  ⋈ Es. 
Step 5:  Ec-p = Ec  ⋈ Ep. 
Step 6:  Ec-c = Ec  ⋈ Ec= Ec. 

Initialization (lines 1 – 5): 
E(0) = 
⎥
⎥
⎥
⎦
⎤
⎢
⎢
⎢
⎣
⎡
φ
φ
8
3
5
12
2
4
1
e
e
e
e
e
e
e
 
First iteration (k = 1): 
E(1) = 
⎥
⎥
⎥
⎦
⎤
⎢
⎢
⎢
⎣
⎡
⋅
⋅
∪
⋅
∪
⋅
∪
4
3
1
3
8
3
4
2
5
1
2
12
2
4
1
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
I
 
Second iteration (k = 2): 
E(2) =
(
)
(
) (
)
(
) (
)
⎥
⎥
⎥
⎦
⎤
⎢
⎢
⎢
⎣
⎡
⋅
∪
∗
⋅
∪
⋅
⋅
∪
∪
⋅
∗
⋅
∪
⋅
⋅
∪
⋅
∪
∗
⋅
∪
4
2
5
1
2
12
1
3
8
4
3
1
2
12
1
3
8
3
4
2
5
1
2
12
2
4
1
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
I
 
Third iteration (k = 3): 
E(3)=
(
)
(
) (
)
(
) (
)
(
) ⎥
⎥
⎥
⎦
⎤
⎢
⎢
⎢
⎣
⎡
⋅
∪
∗
⋅
∪
⋅
⋅
∪
∪
⋅
∗
⋅
∪
⋅
⋅
∪
⋅
∪
∗
⋅
∪
4 *
2
5
1
2
12
1
3
8
4
3
1
2
12
1
3
8
3
4
2
5
1
2
12
2
4
1
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
I
 

v = ‘/tag’: Let v1, …, vk be the children of v. Let Fi be the 
relational algebra expression Fi for Q[vi] (i = 1, …, k).  If 
‘tag’ appears in at least one Fi , return F1 ⋈ … ⋈ Fk. 
Otherwise, return tag ⋈ F1  ⋈ … ⋈ Fk. 
Example 4 Applying the above process to the query tree 
shown in Fig. 3, we will get a tree shown in Fig. 8 after the 
first two steps. 
After the third step, we will get the following 
expression: 
dept ⋈ (σtitle=XML(course) ∪ ((course - 
σyear=2008(course)) ∩ σprereq=CS2001(course)) ⋈ E.  
[32] W. Fan, J.X. Yu, J. Li, B. Ding and L. Qin, Query Translation from 
XPath to SQL in the Presence of Recursive DTDs. The VLDB Journal 
(2009) 18:857-883. 
[33]  R. Elmasri and S.B. Navathe, Fundamentals of Database Systems, 
3rd edition, Addison-Wesley, 5th edition, 2007. 
APPENDIX 
In the Appendix, we describe Fan’s algorithm [25] and 
apply it to a simple graph to see how it works. Especially, 
showing that even for a simple graph the created regular 
expression can be very large. 
In Fan’s algorithm, the nodes in a graph are numbered, 
and a variable M[i, j, k] is used to store the expression 
representing all paths from node i to node j via nodes whose 
numbers are less than or equal to k. 
Through a nested loop, the algorithm checks all possible 
values for i, j, and k; and for each combination the value of 
the corresponding M[i, j, k] is established. Therefore, it is a 
brute-force algorithm. 
Algorithm CycleE(G, A, B) 
Input: a graph G with n nodes, and two nodes A and B in G. 
Output: a regular expression representing all paths from A to 
B in G. 
begin 
1. 
for i = 1 to n do { 
2. 
for j = 1 to n do { 
3. 
 if i = j 
4. 
then M[i, j, 0] ← φ; 
5. 
else if i ≠ j and (i, j) is an edge e in G 
6. 
then M[i, j, 0] ← e; 
7. 
else M[i, j, 0] ← φ; }} 
8. 
for k = 1 to n do { 
9. 
 for = 1 to n do { 
10.   for j = 1 to n do { 
11. 
if M[i, k, k - 1] ≠ φ and M[k, j, k -1] ≠ φ 
12. 
then M[i, j, k] ← M[i, j, k - 1] ∪ 
 
 
M[i, k, k - 1]⋅ M[k, k, k - 1]*⋅ M[k, j, k - 1]; 
13. 
else M[i, j, k] ← M[i, j, k - 1]; }}} 
14. return M[A, B, n]; 
end 
In the algorithm, all M[i, j, 0]’s are first initialized (lines 
1 – 7). Then M[i, j, k]’s with k ≥ 1 are calculated, by 
inspecting M[i, j, k - 1],  M[i, k, k - 1], and M[k, j, k -1], 
including all possible cycles, i.e.,  M[k, k, k - 1]* (lines 8 -
13). 
The following example helps for illustration. 
Example 5 In this example, we apply the algorithm to the 
graph shown in Fig. 9, and trace the computation process. 
 
 
k = 1, i = 1, j = 1. 
M[i, k, k-1] = M[1, 1, 0] = e0 
M[k, j, k-1] = M[1, 1, 0] = e0 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[1, 1, 1] = M[1, 1, 0] ∪ (M[1, 1, 0]⋅M[1, 1, 0]*⋅M[1, 1, 0]) 
= e0 ∪ (e0⋅e0*⋅e0 ) = e0 ∪ e0*. 
k = 1, i = 1, j = 2. 
M[i, k, k-1] = M[1, 1, 0] = e0 
M[k, j, k-1] = M[1, 2, 0] = e1 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[1, 2, 1] = M[1, 2, 0] ∪ (M[1, 1, 0]⋅M[1, 1, 0]*⋅M[1, 2, 0]) 
= e1 ∪ (e0⋅e0*⋅e1) = e1 ∪ e0*⋅e1. 
k = 1, i = 1, j = 3. 
M[i, k, k-1] = M[1, 1, 0] = e0 
M[k, j, k-1] = M[1, 3, 0] = e3 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[1, 3, 1] = M[1, 3, 0] ∪ (M[1, 1, 0]⋅M[1, 1, 0]*⋅M[1, 3, 0]) 
= e3 ∪ (e0⋅e0*⋅e3) = e3 ∪ e0*⋅e3. 
k = 1, i = 2, j = 1. 
M[i, k, k-1] = M[2, 1, 0] = e4 
M[k, j, k-1] = M[1, 1, 0] = e0 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[2, 1, 1] = M[2, 1, 0] ∪ (M[2, 1, 0]⋅M[1, 1, 0]*⋅M[1, 1, 0]) 
= e4 ∪ (e4⋅e0*⋅e0) = e4 ∪ e4⋅e0*. 
k = 1, i = 2, j = 2. 
M[i, k, k-1] = M[2, 1, 0] = e4 
M[k, j, k-1] = M[1, 2, 0] = e1 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[2, 2, 1] = M[2, 2, 0] ∪ (M[2, 1, 0]⋅M[1, 1, 0]*⋅M[1, 2, 0]) 
= φ ∪ (e4⋅e0*⋅e1) = e4⋅e0*⋅e1. 
k = 1, i = 2, j = 3. 
M[i, k, k-1] = M[2, 1, 0] = e4 
M[k, j, k-1] = M[1, 3, 0] = e3 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[2, 3, 1] = M[2, 3, 0] ∪ (M[2, 1, 0]⋅M[1, 1, 0]*⋅M[1, 3, 0]) 
= φ ∪ (e4⋅e0*⋅e3) = e4⋅e0*⋅e3 
k = 1, i = 3, j = 1. 
M[i, k, k-1] = M[2, 1, 0] = e4 
M[k, j, k-1] = M[1, 1, 0] = e0 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[3, 1, 1] = M[3, 1, 0] ∪ (M[3, 1, 0]⋅M[1, 1, 0]*⋅M[1, 1, 0]) 
= e4 ∪ (e4⋅e0*⋅e0) = e1 ∪ e4⋅e0* 
k = 1, i = 3, j = 2. 
M[i, k, k-1] = M[3, 1, 0] = e2 
M[k, j, k-1] = M[1, 2, 0] = e1 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[3, 2, 1] = M[3, 2, 0] ∪ (M[3, 1, 0]⋅M[1, 1, 0]*⋅M[1, 2, 0]) 
= φ ∪ (e2⋅e0*⋅e1) =  e2⋅e0*⋅e1 
k = 1, i = 3, j = 3. 
M[i, k, k-1] = M[3, 1, 0] = e2 
M[k, j, k-1] = M[1, 3, 0] = e3 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[3, 3, 1] = M[3, 3, 0] ∪ (M[3, 1, 0]⋅M[1, 1, 0]*⋅M[1, 3, 0]) 
= φ ∪ (e2⋅e0*⋅e3) =  e2⋅e0*⋅e3 
k = 2, i = 1, j = 1. 
M[i, k, k-1] = M[1, 2, 1] = e1 ∪ e0*⋅e1 
M[k, j, k-1] = M[2, 1, 1] = e1 ∪ e4⋅e0* 
M[i, j, k] = M[i, j, k-1] ∪ (M[i, k, k-1]⋅M[k, k, k-1]*⋅M[k, j, k-1]) 
M[1, 1, 2] = M[1, 1, 1] ∪ (M[1, 2, 1]⋅M[2, 2, 1]*⋅M[2, 1, 1]) 
= e0 ∪ e0* ∪ ((e1 ∪ e0*⋅e1) ⋅ (e4⋅e0*⋅e1)* ⋅ (e4 ∪ e4⋅e0*)). 
