A Representation of Certain Answers for Views and
Queries with Negation
Victor Felea
Department of Computer Science
”Al. I. Cuza” University
Iasi, Romania
Email: felea@infoiasi.ro
Abstract—The paper is about databases content processing,
namely query processing. Certain answers are very important in
the study of the data complexity of the problem of answering
queries using materialized views and constitute a semantics of
query answers in mediated integration systems. The computing of
these answers depends on database and view models, and the case
when the negation occurs was not studied. In this paper, we give
a representation of certain answer sets where both the query and
the views are expressed in conjunctive form with negation. Using
this representation, a method to compute the certain answers for
the open-world and close-world assumptions is given.
Keywords–views; queries; negation; certain answers.
I. INTRODUCTION
In many data-management applications such as data-
integration from different sources, data warehousing, query
optimization, the problem of view-based query processing
is central. The study of this problem implies the considera-
tion of several main notions as answering and rewriting.
Answering means the computing the tuples satisfying the
query in all databases consistent with the views. Rewriting
is a reformulating of the query in terms of the views, and then
evaluating the rewriting over the views extensions. In general
terms, the problem of rewriting is as follows: given a query
Q on a database schema S, expressed in a language L, and a
set V of views on S, can we answer Q using only V?
A lot of results have been reported in the last years and
many methods have been studied(see a survey in [1]). One
of the approach of view-based query processing problem is
the query-answering approach, where so-called certain tuples
([2]) are computed. Certain tuples are the tuples that satisfy
the query in all databases consistent with the views, on the
basis of the view deﬁnitions and the view extensions.
In [2],[3], some aspects and applications of the problem of
answering queries using views, and algorithms are presented.
Some authors study the problem of view-based query process-
ing in a context where databases are semistructured, and both
the queries and the views are expressed as regular path queries
in [4],[5]. A tableau technique is used for computing query an-
swers in [6]. In [7], the authors study the complexity of query
answering considering key and inclusion dependencies. The
problem of answering queries using views, when queries and
views are in conjunctive form with arithmetic comparisons,
are analyzed in [8].
The structure of the paper is following: in Section II, we
discuss the main papers concerning to the computing of certain
answer sets, in Section III, we specify the basic deﬁnitions
and notations used in the paper. In Section IV, we give a
representation of certain answer sets in case of open-world
assumption. A method to compute certain answer sets in
cases of open-world and close-world assumptions is given
in Sections V and VI, respectively. The problem of time
complexity to compute certain answers is analyzed in Section
VII. Finally, Section VIII concludes the paper.
II. STATE OF THE ART
In the relational model, a query Q1 is said to be contained
in the query Q2 if Q1 produces a subset of the answers of
Q2, for any database. In the context of data integration, we
say that Q1 is contained in Q2 relative to a set of views V if,
for any set I of instances of V, the certain answers of Q1 are a
subset of the certain answers of Q2. In [2], the authors study
the complexity of computing certain answers in case when
views and queries are in conjunctive form, conjunctive form
with inequality, non-recursive datalog, datalog or ﬁrst order
formula. In case when the query is expressed in datalog, and
does not contain comparison predicate, and the views are in
conjunctive form, the set of certain answers can be obtained
by so called a query plan, which is a datalog program whose
extensional relations are the source relations. More precisely,
the maximally contained query plans deﬁned in [9] compute
the certain answers of the query [2]. In [10], using certain
answers, the authors deﬁne relative containment, which
formalizes the notion of query containment relative to the
sources that occur to the data-integration system. In [11], the
containment of two queries is studied. In [5], the authors
study the problem of answering queries using materialized
views in the presence of negative atoms in views. By our
best knowledge, the problem to compute the certain answer
set in case when the negation occurs in views or query was
not considered yet in literature.
Let us give a motivated example.
Example 1 Let us consider the relational schema S consisting
of {COMP, CON, PROD, ITEM},where
COMP represents the companies and has comp-id as an
identiﬁcation code of a company, and comp-name is the name
of the company,
CON represents the contracts between companies, and has
142
DBKDA 2011 : The Third International Conference on Advances in Databases, Knowledge, and Data Applications
Copyright (c) IARIA, 2011              ISBN:978-1-61208-115-1

as attributes con-id the identiﬁcation code of the contract, b-
comp, the beneﬁciary of the contract con-id, and f-comp is
the supplier of the contract con-id (the values of b-comp and
f-comp are company codes),
PROD represents the products, and has prod-id as the
identiﬁcation code of a product, and prod-name the product
name,
ITEM represents items speciﬁed by the contracts, and has
as attributes: con-id1, the code of a contract, prod-id1, the
code of a product. We consider the following view: ﬁnd
contracts x1, companies x2, and products x3 such that x2 is
the beneﬁciary company of x1 and the product x3 occurs as
item of the contract x1, and there exists a contract y2 such
that the product x3 does not occur in the contract y2.
Using the schema S, we can expressed this view deﬁnition
as:
V (x1, x2, x3) : −CON(x1, x2, y1), CON(y2, y3, x2),
PROD(x3, y4), ITEM(x1, x3), ¬ITEM(y2, x3),
where the character ’,’ between two literals means logical
conjunction. Let us consider the query: ﬁnd all companies z
such that there exist two contracts t1 and t3, where one of
them contains z as the beneﬁciary and another as supplier
and there exists a products t5 such that one or another from
contracts t1 and t3 does not contain the product t5. We
expressed this query as follows:
Q : q(z) : −CON(t1, z, t2), CON(t3, t4, z),
PROD(t5, t6), (¬ITEM(t1, t5) ∨ ¬ITEM(t3, t5))
It is clear that the query Q is equivalent with a union
of queries in conjunctive form. Let I be an extension of
V , where I = {w1, w2}, and w1 = (1,′ S2′,′ P2′), and
w2 = (2,′ S3′,′ P3′). We are interested to compute the certain
answers corresponding to I, V and Q.
In this paper, we compute the certain answer sets in two
cases: under the open-world assumption (OWA) and under
the closed-world assumption (CWA) in case when views are
in conjunctive form, and query is a union of conjunctive form,
and both can contain negative literals.
III. BASIC DEFINITIONS AND NOTATIONS
Let Dom be a countable inﬁnite domain for databases. A
view deﬁnition has the following form:
V (x) : −R1(u1), . . . , Rk(uk), ¬Rk+1(uk+1), . . . ,
¬Rk+p(uk+p),
(1)
where x is a vector of variables. These variables are called
free in the view V , The vectors ui consists of variables or
constants, 1 ≤ i ≤ k + p. All constants are considered in
Dom. There are two restrictions about variables or constants
that occur in the view. The ﬁrst one is: each variable that
occurs in x, it must appear also in at least a vector ui,
1 ≤ i ≤ k, that means it also appears in the positive part
of the view deﬁnition. This is called the safe property of
the view. The second one is: each variable or constant that
occurs in the negated part of the view deﬁnition, must
occur in its positive part. This property is called as safeness
property of negation. The symbols Ri are relational symbols,
1 ≤ i ≤ k + p. All variables from ui, 1 ≤ i ≤ k + p, that
are different from variables from x, are called existentially
quantiﬁed variables. Let us denote by fV (x, y) the right part
of the view deﬁnition V . A query Q in conjunction form with
negation has a similar form as view deﬁnition. Let us denote
by q(z) the head of the query, and fq(z, t), the right hand
part of the query, where t denote all existentially quantiﬁed
variables from the query. In an integration system the views
are called sources. If sources have non-relational data models,
we can use wrappers [12] to create relational view of data.
In the following deﬁnition we present the notion of certain
answer in two cases: (OWA) and (CWA).
Deﬁnition 1: Let Q be a query and V = {V1, . . . , Vm}
be a set of view deﬁnitions over the database schema S =
{R1, . . . , Rs} (all relational symbols from S are used in at
least Vi). Let wi be an extension of the view deﬁnition Vi,
for each i, 1 ≤ i ≤ m. Let I = {w1, . . . , wm}. The tuple t is
a certain answer for I, V, and Q under OWA if t ∈ Q(D),
for all databases D deﬁned on Dom such that I ⊆ V(D).
The tuple t is a certain answer for I, V and Q under CWA
if t ∈ Q(D) for all databases D deﬁned on Dom such that
I = V(D).
In an intuitive sense, a tuple is a certain answer of the query
Q, if it is an answer for any of the possible database instances,
which are consistent with the given extensions of the views.
Concerning the number of view deﬁnitions, and the number
of extensions of the views from V we distinguish three cases:
(I)V consists of a single view deﬁnition denoted V , and I
consists of m extensions of V , denoted w1, . . . , wm.
(II)V consists of multiple deﬁnitions of a view V , denoted
V (x) : −f i
V (x, y), 1 ≤ i ≤ h, and I consists of m extensions
of the view deﬁnitions of V .
(III) V consists of multiple view deﬁnitions of the views
V1, . . . , Vq and I consists of m extensions, an extension
corresponds to a view deﬁnition of any view Vi, 1 ≤ i ≤ q.
For the sake of the presentation, let us consider the case
(I), the approaches of the cases differ only in notation.
In the case of the open-world assumption, we express the
relation I ⊆ V(D) that it is equivalent to: wi ∈ V (D), for each
i, 1 ≤ i ≤ m, where D is a database deﬁned on Dom. Then
there exists a mapping ν from the set of all variables from x
and y into Dom such that the following relations yield:
νpos(fV (x, y)) ⊆ D, νneg(fV (x, y))∩D = ∅, νx = wi, (2)
where ν(c) = c, for a constant c,
pos(fV (x, y))= {R1(u1), . . . , Rk(uk)} and
neg(fV (x, y))= {Rk+1(uk+1), . . . , Rk+p(uk+p)}
We denote by Rel(fV (x, y)), the set of all relational symbols
that occur in the conjunction fV (x, y)). For a mapping ν
having the property from (2), we denote by fV (wi, y) the
143
DBKDA 2011 : The Third International Conference on Advances in Databases, Knowledge, and Data Applications
Copyright (c) IARIA, 2011              ISBN:978-1-61208-115-1

result of replacing all free variables x′ from x with ν(x′). For
two different vectors wi and wj,the existentially quantiﬁed
variables of type y are independent, hence we take the sets
of variables for y disjoint. So, we denote by fV (wi, yi) orfi,
the expression fV (x, y), where y is replaced by yi and the
set of all variables from yi is disjoint from the set from yj,
that means yi ∩ yj = ∅ for all i, j, 1 ≤ i ̸= j ≤ m. Let us
denote by C the set of all elements from Dom, that appear
in the vectors wi, 1 ≤ i ≤ m and in fV (x, y). Let Y be the
set of all variables from y1, . . . , ym. Let π be a partition of
the set C ∪ Y , and Classπ the set of the classes deﬁned by
the partition π. We denote by ≡π the congruence relation
deﬁned by the partition π, namely: we have t ≡π t′ if there
exists a set M from Classπ such that t, t′ ∈ M. In the paper
we only need partitions with the property: for two different
constants c and c′,we have c ̸≡π c′. These partitions are called
C-partitions. It is clear that for a C-partition a class contains
at most a constant. For a partition π on C ∪ Y , we consider
a mapping from C ∪ Y into Classπ denoted ϕπ called the
canonical onto mapping and deﬁned by ϕπ(t) = [t]π, where
[t]π means the class that contains t. The mapping ϕπ is
extended naturally to a vector w′ = (t1, . . . , tr) on C ∪ Y
by ϕπ(w′)=(ϕπ(t1), . . . , ϕπ(tr)). For an atom R(w′), we
consider ϕπ(R(w′))=R(ϕπ(w′)). For a set of atoms S having
the form R(w′), we deﬁne ϕπ(S)={ϕπ(R(w′))|R(w′) ∈ S}.
Associated to a C-partition π, we deﬁne two databases having
elements from Classπ, and denoted T min
π
, T max
π
, in the
following manner:
T min
π
= ∪i=m
i=1 ϕπpos(fV (wi, yi))
(3)
T max
π
= {ϕπR(w)|R ∈ Rel(fV (x, y)), w on C ∪ Y }−
∪i=m
i=1 ϕπneg(fV (wi, yi))
(4)
We denote by Mπ the set of all databases between T min
π
and
T max
π
,i.e.,:
Mπ = {T|T min
π
⊆ T ⊆ T max
π
}
For a conjunction of literals fi, we need to consider a formula
denoted φ(fi), whose basic elements have the form (ti ̸= tj),
where ti and tj are elements from C ∪ Y . Let fi hav-
ing the form: fi = R1(z1), . . . , Rk(zk), ¬Rk+1(zk+1), . . . ,
¬Rk+p(zk+p). Let Rk+j(zk+j) be an atom that occurs in the
negated part of fi. Let us consider the case when Rk+j occurs
in the positive part of fi, with the indexes α1, . . . , αq, that
means we have: Rk+j=Rα1=. . .=Rαq, and Rk+j ̸= Rβ for
each β ∈ {1, 2, . . . , k} − {α1, . . . , αq}.
Associated to the atom Rk+j(zk+j), we consider the formula
denoted φj
i and deﬁned as follows:
φj
i = (zk+j ̸= zα1) ∧ . . . ∧ (zk+j ̸= zαq)
where the expression (zl
̸=
zs) denotes the following
disjunction: (t1
l ̸= t1
s)∨. . .∨(tr
l ̸= tr
s), with zl = (t1
l , . . . , tr
l ),
zs = (t1
s, . . . , tr
s). In case when Rk+j does not occur in
the positive part of fi, then we consider φj
i = TRUE. The
formula φ(fi)is deﬁned as the conjunction of all formulas φj
i,
for 1 ≤ j ≤ p, that means φ(fi) = φ1
i ∧ . . . ∧ φp
i . Now, let us
consider the conjunction of all formulas φ(fi), 1 ≤ i ≤ m,
denoted φ(fV ), that means: φ(fV ) = φ(f1) ∧ . . . ∧ φ(fm).
Let us consider an example concerning these formulas.
Example 2 Let V and I be deﬁned in Example 1. To be
short, let us rewrite the predicates CON, PROD, ITEM
by R1, R2, R3, respectively. We have: V (x1, x2, x3)
:
− R1(x1, x2, y1), R1(y2, y3, x2), R2(x3, x4), R3(x1, x3),
¬R3(y2, x3). f1=fV (w1, y)=R1(1,′ S2′, y1), R1(y2, y3,′ S2′),
R2(′P2′, y4), R3(1,′ P2′), ¬R3(y2,′ P2′). The formula φ(f1)
corresponds to the atom R3(y2,′ P2′) and φ(f1) = (y2 ̸= 1).
For the formula f2 we take y-variables as: y5, y6, y7.y8. We ob-
tain φ(f2) = (y6 ̸= 2). Finally, φ(fV ) = (y2 ̸= 1) ∧ (y6 ̸= 2).
We remark that the formula φ(fV ) express the satisﬁability
property of the formula fV . In the following we deﬁne
formally the logic value of a formula for a C-partition.
Deﬁnition 2: Let π be a C-partition deﬁned on C ∪ Y and
φ(fV ) the formula constructed for fV , as we have mentioned
above. We deﬁne the logic value of φ(fV ) for π, denoted
π(φ(fV )), as follows:
(i) If φ = (t ̸= t′), where t and t′
∈ C ∪ Y , then
π(φ) = TRUE if there is no class E from Classπ such that
t, t′ ∈ E, i.e., [t]π ̸= [t′]π.
(ii) π(φ1∧φ2) = π(φ1)∧π(φ2), π(φ1∨φ2) = π(φ1)∨π(φ2).
We remark that for a C-partition π , we have π(φ(fV )) =
TRUE if and only if ϕπ(fi(wi, yi)) is satisﬁable ([12]) for
each i, 1 ≤ i ≤ m, where ϕπ is the canonical onto mapping
corresponding to π. For a database D deﬁned on Dom, we
consider val(D) the set of all values that occur in the atoms
of D. Formally,
val(D) = {v|∃R(w) ∈ D, v is a component of w}.
Let us denote by f1 · f2 the composition of the mappings
f1 and f2, where (f1 · f2)(x) = f1(f2(x)).
IV. A REPRESENTATION OF CERTAIN ANSWER SETS
UNDER OWA
Firstly, we point out a proposition about two databases that
are in a particular relation.
Proposition 1: Let D′ and D be two databases over the
schema S such that D′ ⊆ D and for each atom R(w) ∈
D − D′, there exists a component v belonging to w such
that v ̸∈ val(D′). Then for each query Q having Rel(Q) ⊆
Rel(V), we have Q(D′) ⊆ Q(D).
Proof: Let u be from Q(D′). This implies there exists a
substitution θ from the variables of Q into Dom such that:
θpos(Q) ⊆ D′, θneg(Q) ∩ D′ = ∅ and θz = u,
(5)
where the head of the query Q is q(z). The hypothesis,
the second statement from (5), and the safeness property of
negation imply θneg(Q) ∩ D = ∅, hence u ∈ Q(D).
The following theorem points out some properties concerning
the C-partitions from Part(C ∪ Y ) and some sous-databases
144
DBKDA 2011 : The Third International Conference on Advances in Databases, Knowledge, and Data Applications
Copyright (c) IARIA, 2011              ISBN:978-1-61208-115-1

of a database D.
Theorem 1: Let V be a set of view deﬁnitions on the
schema S, I an extension of V, and D a database on Dom
such that I ⊆ V(D), and Rel(D) ⊆ Rel(V). Let φ(fV ) be the
formula constructed for I and V. There exist a C-partition π
from Part(C ∪ Y ) such that π(φ(fV )) = TRUE, a database
D′ such that D′ ⊆ D, and a bijective mapping ψπ from
Classπ into val(D′) having the following properties:
(i) For each atom R(w) from D − D′, the vector w has at
least a component t such that t ̸∈ val(D′).
(ii) For any query Q such that Rel(Q) ⊆ Rel(V), we have:
Q(D′) ⊆ Q(D) and ψ−1
π Q(D′) = Q(ψ−1
π (D′)).
(iii) Let T = ψ−1
π (D′). We have T ∈ Mπ.
(iv) I ⊆ V(D′).
Proof: Let V, I, D as in the hypothesis of the Theorem
such that I ⊆ V(D). This inequality is equivalent to the
statement: V (wi) ∈ V(D) for each i, 1 ≤ i ≤ m. This means:
(∃τi)(τi : C ∪ yi− > Dom)[D |= τif(wi, yi)], 1 ≤ i ≤ m
(6)
Moreover, we assumed that τi(c) = c for each element c from
C. Let us emphasize the atoms from fi:
f(wi, yi) = A1 ∧ . . . ∧ Ah ∧ ¬Ah+1 ∧ . . . ¬Ah+p
(7)
The relation D |= τif(wi, yi) is equivalent to:
τiAj ∈ D, 1 ≤ j ≤ h and τiAh+l ̸∈ D, 1 ≤ l ≤ p
(8)
Since for i ̸= j we have yi ∩ yj = ∅, there exists a mapping
τ from C ∪ Y into Dom such that τ(c) = c for each c from
C, and τ(yα) = τi(yα), where yα ∈ yi. Associated to the
mapping τ, we deﬁne a partition denoted π, and deﬁned as
follows: t ≡π t′ if τ(t) = τ(t′),where t, t′ ∈ C ∪ Y . Since
the statements from (6) are true, it follows that π(φ(fV )) =
TRUE. Let V ′ be the set of all values from τ(C ∪ Y ). Let
D′ be the database deﬁned as follows:
D′ = {R(w)|R(w) ∈ D, R ∈ Rel(V ) and
w contains only values from V ′}
(9)
It is clear that val(D′) = V ′, and the databases D, D′ satisfy
the statement (i) from the Theorem. Using this statement and
Proposition 1, we obtain Q(D′) ⊆ Q(D) for each query Q.
Now, let us deﬁne a bijective mapping denoted ψπ from
Classπ into val(D′), as follows; ψπ([t]π) = τ(t). Let us
denote by ψ−1
π
the inverse mapping of ψπ. Let us show the
second part of the condition (ii). Let Q be a query deﬁned on
S and, having the form:
Q : q(z) : −S1( ew1), . . . , Sl( ewl), ¬Sl+1( ewl+1), . . . ,
¬Sl+r( ewl+r)
(10)
Let q(w) be from Q(D′). There exists a substitution θ from
the set of all variables from Q into V ′ such that the following
statements yield:
θSi( ewi) ∈ D′, 1 ≤ i ≤ l, θSl+i( ewl+i) ̸∈ D′, 1 ≤ i ≤ r,
θ(z) = w
(11)
Since the mapping ψ−1
π
is injective, from the relation (11),
we get:
ψ−1
π (θSi( ewi)) ∈ ψ−1
π (D′), 1 ≤ i ≤ l, ψ−1
π (θSl+i( ewl+i))
̸∈ ψ−1
π (D′), 1 ≤ i ≤ r, ψ−1
π (θ(z)) = ψ−1
π (w)
(12)
From the relations (12), we infer the substitution θ′ =
θ · ψ−1
π
satisﬁes the relations (11) with θ′ instead of θ and
ψ−1
π (D′) instead of D′. This means the following statement
is true:
ψ−1
π (q(w)) ∈ Q(ϕ−1
π (D′))
(13)
The relation(13)implies ψ−1
π (Q(D′)) ⊆ Q(ψ−1
π (D′))
(14)
The inclusion Q(ψ−1
π (D′)) ⊆ ψ−1
π (Q(D′)) follows in a
similar manner, because ψ−1
π
is bijective. Now, let us consider
the statement (iii). Let T = ψ−1
π (D′). Since the mapping τ
satisﬁes the relation τ(∪i=m
i=1 pos(f(wi, yi))) ⊆ D′, we obtain
the following inclusion:
(τ · ψ−1
π )(∪i=m
i=1 pos(f(wi, yi))) ⊆ ψ−1
π (D′)
(15)
On the other hand, we get τ · ψ−1
π
= ϕπ.
Therefore, from (15), we obtain: T min
π
⊆ T
(16)
Since the relation τ(∪i=m
i=1 neg(f(wi, yi)))∩D′ = ∅ holds, we
obtain:
ϕπ(∪i=m
i=1 neg(f(wi, yi))) ∩ ψ−1
π (D′) = ∅
(17)
Moreover, we have:
ψ−1
π (D′) ⊆ {ϕπR(w)|R ∈ Rel(V ), w is on C ∪ Y }
(18)
The relations (17) and (18) imply ψ−1
π (D′) ⊆ T max
π
(19)
From the statements (16) and (19), we obtain T ∈ Mπ. The
statement (iv) results because the relation (6) is satisﬁed for
the database D′.
The following theorem speciﬁes the properties of C-partitions.
Theorem 2: Let π be a C-partition from Part(C ∪Y ) such
that π(φ(fV )) = TRUE. Let T be an element from Mπ. For
each injective C − mapping ψ from Classπ into Dom, we
have:
(i) I ⊆ V(D′), where D′ = ψ(T).
Proof: We consider the substitution τ from C ∪ Y into
Dom, deﬁned as: τ = ϕπ · ψ. Let τi be the substitution
obtained from τ by projection on C ∪ yi, 1 ≤ i ≤ m. We
must show that:
D′ |= τif(wi, yi), for each i, 1 ≤ i ≤ m
(20)
Since T is a database from Mπ, we get for each i, 1 ≤ i ≤ m:
ϕπpos(f(wi, yi)) ⊆ T and ϕπneg(f(wi, yi)) ∩ T = ∅ (21)
Applying the mapping ψ to the ﬁrst relation from (21), we
obtain:
τpos(f(wi, yi)) ⊆ D′, hence τipos(f(wi, yi)) ⊆ D′
(22)
145
DBKDA 2011 : The Third International Conference on Advances in Databases, Knowledge, and Data Applications
Copyright (c) IARIA, 2011              ISBN:978-1-61208-115-1

Since the mapping ψ is injective, from the second relation
from (21), we get:
τneg(f(wi, yi)) ∩ D′ = ∅, hence we have:
τineg(f(wi, yi)) ∩ D′ = ∅
(23)
The statements (22) and (23) imply (20), therefore we have
I ⊆ V(D′).
In the following we emphasize other property of C-partitions
and injective mappings.
Proposition 2: Let π be a C-partition on C ∪ Y such that
π(φ(fV )) = TRUE. Let D1 be a database deﬁned on Classπ,
and ψ an injective mapping from Classπ into Dom. We have
ψ(Q(D1)) = Q(ψ(D1)), for each query Q expressed as a
union of conjunctive form, and having Rel(Q) ⊆ Rel(V ).
Proof: Let Q be a query having the form like as in (10),
and ψ an injective mapping from Classπ into Dom. The
answer of Q for T is as follows:
Q(T) = {θq(z)|θpos(Q) ⊆ T and θneg(Q) ∩ T = ∅} (24)
From this relation, we get:
ψ(Q(T)) = {(θ · ψ)q(z)|θpos(Q) ⊆ T and
θneg(Q) ∩ T = ∅}
(25)
Let eu be from ψ(Q(T)). There exists θ a mapping from the
variables of Q into Classπ such that eu = (θ · ψ)q(z), and θ
satisﬁes the statements from (25). Since ψ is injective, from
these relations, we obtain (θ · ψ)pos(Q) ⊆ ψ(T) and (θ ·
ψ)neg(Q) ∩ ψ(T) = ∅. These imply: eu = (θ · ψ)q(z) ∈
Q(ψ(T)). Therefore, we have obtained ψ(Q(T)) ⊆ Q(ψ(T)).
The inverse inclusion is inferred similarly.
Before we give the theorem about a representation of
certain answers, we need to give some further notations.
Let P = {π1, . . . , πp} be the set of all C-partitions from
Part(C ∪ Y ) such that πi(φ(fV )) = TRUE. For a partition
πi, we denote by Sπi the intersection of all answers of
the query Q for databases T
from Mπi, that means:
Sπi = ∩{Q(T)|T ∈ Mπi}. Let A = (Sπ1, . . . , Sπp). Let ψi
be an injective mapping from Classπi into Dom, 1 ≤ i ≤ p.
Let B be the vector (ψ1, . . . , ψp) and Ans(B) = ∩i=p
i=1ψi(Sπi).
Let V Mapp be the set of all vectors having the form B, and
RCertAnsO the intersection of all Ans(B) for all B from
V Mapp, i.e., RCertAnsO = ∩{Ans(B)|B ∈ V Mapp}.
Let us denote by CertAnsO(V, I, Q), the set of all certain
answers for V, I, Q. In the following theorem, we give a
characterization of this certain answer set.
Theorem 3: Let V, I, Q be a set of view deﬁnitions,
an instance of V
and a query, respectively. We have
CertAnsO(V, I, Q)=RCertAnsO.
Proof:
Firstly,
let
w
be
a
vector
from
CertAnsO(V, I, Q). To show that w
∈
RCertAnsO.
Let B be a vector of injective mappings, B= (ψ1, . . . , ψp),
where ψi is a mapping from Classπi into Dom. Let T be an
element from Mπi. Let us denote the database ψi(T) by D
′
i.
By Theorem 2, we have I ⊆ V(D
′
i). Using the hypothesis,
we obtain w ∈ Q(D
′
i) = Q(ψi(T)) = ψi(Q(T)). We get
w ∈ ψi(Sπi), for each πi from P and mapping vector B,
therefore w ∈ RCertAnsO.
Inversely, assume that w ∈ RCertAnsO. To show that w
∈ CertAnsO(V, I, Q). Let D be a database on Dom such
that I ⊆ V(D). We must show that w ∈ Q(D). By the
hypothesis, we have w ∈ Ans(B), for each B from V Mapp,
hence we obtain:
w ∈ ψi(Sπi), for each i, 1 ≤ i ≤ p, and for each B.
(26)
Using Proposition 2, we get: w ∈ ψi(Q(T)),
for each
T
∈
Mπi. Using Theorem 1, we have: there exist a
partition πi, a mapping ψπi, and a database D′ such
that D′
⊆
D, I
⊆
V(D′), where ψπi is a mapping
from Classπi into val(D′). In the relation (26) we take
ψπi, instead of ψi. Thus, using Proposition 2, we have:
w
∈
ψπi(Q(T))=Q(ψπi(T))=Q(ψπi(ψ−1
πi (D′)))=Q(D′).
Since Q(D′) ⊆ Q(D), we obtain w ∈ Q(D).
V. CERTAIN ANSWERS UNDER OWA
Based on the results of the precedence section, we give
in this section a method to construct the set of all certain
answers for V, I, Q. Since we considered each constant
from C belongs to the domain Dom, we have C ⊆ Dom.
Moreover, for each π a C-partition on C ∪ Y , we have
|C| ≤ |Classπ|, where |C| denote the cardinality of C.
Regarding to the vectors having components from Classπ,
we need to introduce a condition denoted Cond and deﬁned
in the following.
Deﬁnition 3: Let ew = (w1, . . . , wp), where wj ∈ Sπj, and
wj = (tj1, . . . , tjr), 1 ≤ j ≤ p. We say that the vector ew
satisﬁes the condition Cond if the following statements yield:
(i) The class tji contains a constant denoted cαji for all j, 1 ≤
j ≤ p, and i, 1 ≤ i ≤ r,
(ii) Let tjl = [cαjl]πl, 1 ≤ l ≤ r, 1 ≤ j ≤ p. Then we have:
cα1l = . . . = cαpl, for each l, 1 ≤ l ≤ r.
In the following, we point out some properties of the vector
ew that satisfy the condition Cond from Deﬁnition 3.
Proposition 3: Let ew = (w1, . . . , wp), where wj ∈ Sπj,
1 ≤ j ≤ p. We have: the vector ew satisﬁes the condition Cond
if and only if there exists a unique injective C−mapping from
Classπj into Dom, denoted ψj, for each j, 1 ≤ j ≤ p such
that ψ1(w1) = . . . = ψp(wp).
Remark 1: Let ew = (w1, . . . , wp), where wj
∈ Sπj,
1 ≤ j
≤ p. The vector ew produces a certain answer,
denoted PROD( ew), under OWA if and only if ew satisﬁes
the condition Cond. In this case, we have from Proposition 3,
PROD( ew)=ψ1(w1).
We can easy construct a procedure that computes the set of
all certain answers for V, I, Q.
Example 3 Let us consider I, V and Q as in Example 1.
Using the results of Sections IV and V, we obtain that w = (1)
and w = (2) are certain answers under OWA.
146
DBKDA 2011 : The Third International Conference on Advances in Databases, Knowledge, and Data Applications
Copyright (c) IARIA, 2011              ISBN:978-1-61208-115-1

VI. CERTAIN ANSWERS UNDER CWA
In this section, we point out some theorems necessary to
represent sets of certain answers under CWA. The proofs
of these theorems are similar to that of Theorems 1, 2, 3,
therefore they are omitted. Firstly, we need to consider a new
notion regarding to a database T deﬁned on Classπ, where
π is a C-partition.
Deﬁnition 4: Let I = {w1, . . . , wm}, π a C-partition such
that π(φ(fV )) = TRUE and T an element from Mπ. We
say that T is closed with respect to I, if for each substitution
θ from the variable set of Q into Classπ such that T |=
θfV (x, z), there exists a tuple wj from I such that η(θ(x)) =
wj, where η is the mapping from Classπ into C ∪ Y deﬁned
by: η([t]π) = c if c ∈ [t]π and η([t]π) = y otherwise, where
y is a variable from the class [t]π.
Remark 2: Let I, π and T as in Deﬁnition 4. We have:
(i) For each i, 1 ≤ i ≤ m, there exists a substitution θi from
the variable set of Q into Classπ such that T |= θifV (x, z)
and η(θi(x)) = wi, where the mapping θi is speciﬁed in
Deﬁnition 4.
Proof: We specify the substitution θi. If x = x1 . . . xh,
z = z1 . . . zp, wi = t1 . . . th, where tj ∈ Dom, yi =
yγ1 . . . yγp (the vector yi consists of the y-variables from the
expression fV (wi, yi)). The mapping θi is deﬁned as follows:
θi(xj) = [tj]π, 1 ≤ j ≤ h and θi(zj) = [yγj]π, 1 ≤ j ≤ p.
Now, we give the results regarding the representation of
certain answer sets under CWA.
Theorem 4: Let V be a set of view deﬁnitions, I an exten-
sion of V, and D a database on Dom such that I = V(D). Let
φ(fV ) be the formula constructed for I and V. There exist a C-
partition π from Part(C ∪Y ) such that π(φ(fV )) = TRUE,
a database D′ ⊆ D, and an injective mapping ψπ from Classπ
into val(D′) having the following properties:
(i) and (ii) as in Theorem 1,
(iii)′ Let T = ψ−1
π (D′). We have T ∈ Mπ, and T is closed
with respect to I (Deﬁnition 4).
(iv)′ I = V(D′).
Theorem 5: Let π be a C-partition from Part(C ∪Y ) such
that π(φ(fV )) = TRUE. Let T be a database from Mπ that
is closed with respect to I. Then for each injective C-mapping
ψ from Classπ into Dom, we have:
(i) I = V(D′), where D′ = ψ(T).
Now, we use the notations speciﬁed for the case OWA, with
except the following: Sπi instead of Sπi, CertAnsC(V, I, Q)
instead of CertAnsO(V, I, Q), and RCertAnsC instead of
RCertAnsO, where
Sπi = ∩{Q(T)|T ∈ Mπi and T is closed w.r.t. I}.
Theorem 6: Using the notations speciﬁed above, we have
CertAnsC(V, I, Q)=RCertAnsC.
VII. TIME COMPLEXITY TO COMPUTE CERTAIN ANSWERS
It is known that the total number of partitions of an
n−element set is the Bell number Bn, such that the following
recursion equation yields ([13]): Bn+1 = Σk=n
k=0Bk. Using the
induction, we get the following inequalities: Bn > 2n for each
n ≥ 5 and Bn < nn for each n > 1. The second inequality
implies Bn < 2n2, for each n > 1. On the other hand, the
number of C-partitions deﬁned on C ∪ Y is greater than the
number of the partitions on Y . It results that the number
of C-partitions deﬁned on C ∪ Y is of the type O(2p(|Y |)),
where p is a polynomial. Let us discuss the number of all
elements from Mπ, where π is a ﬁxed C-partition on C ∪ Y .
Let yπ = |Classπ|, and r the maximum of the arities of
the relational symbols from V . Then the cardinality of the
set T max
π
(in relation (4))has the form: O(yr
π). Therefore, the
number of the elements from Mπ has the form O(2yr
π). It is
clear that yπ ≤ |C ∪ Y |. For a query Q having l variables,
and T an element from Mπ, the number of the substitutions
from V ar(Q) into Classπ is yl
π. Using these relations, and
the constructions for certain answers under OWA and CWA,
speciﬁed in Sections V and VI, we obtain that the time
complexity to compute these certain answers is EXPTIME.
VIII. CONCLUSION
We have presented a representation of certain answers corre-
sponding to a set of view deﬁnitions, a set of extensions of the
view deﬁnitions, and a query. Two situations were considered:
open-world assumption and close-world assumption. Using
this representation, a method to compute the certain answers
under the two assumptions was given.
REFERENCES
[1] A. Y. Halevy, Answering Queries Using Views: A survey, VLDB Journal,
vol. 10, nr. 4, 2001, pp. 270-294.
[2] S. Abiteboul and O. M. Duschka, Complexity of answering queries using
materialized views, in PODS, 1998, pp.254-263.
[3] S. Flesca and S. Greco, Rewriting queries using views, IEEE Trans.
Knowledge Data Engineering 13(6), 2001, pp.980-995.
[4] D. Calvanese, G. De Giacomo, M. Lenzerini, and M. Y. Vardi, View-based
query processing:On the relationship between rewriting, answering and
losslessness, Theoretical Computer Science, 371, 2007, pp. 169-182.
[5] D. Calvanese, G. De Giacomo, M. Lenzerini, and M. Y. Vardi, Answering
Regular Path Queries Views, Proc. of the 16th IEEE Int. Conf. on Data
Engineering, ICDE, 2000, pp. 389-398.
[6] G. Grahne, and A. O. Mendelson, Tableau technique for querying
information sources through global schemas, Proc. of the 7th Int. Conf.
on Database Theory, ICDT’99, in LNCS, vol. 1540, Springer 1999, pp.
332-347.
[7] A. Call, D. Lembro, and R. Rosati, Query rewriting and answering under
constraints in data integration systems, IJCAI-03, 2003, pp.16-21.
[8] F. Afrati, C. Li, and P. Mitra, Rewriting queries using views in the
presence of arithmetic comparisons, Theoretical Computer Science, 368,
2006, pp.88-123.
[9] O. M. Duschka, M. R. Genesereth, and A. Levy, Recursive Query Plans
for Data Integration, J. of Logic Programming 2000, 43(1), pp. 49-73.
[10] T. Millstein, A. Halevy, and M.Friedman, Query containment for data
integration systems, JCSS vol.66, 2003, pp. 20-39.
[11] Wei F. and Lausen G.: Containment of Conjunctive Queries with Safe
Negation. In ICDT, (2003), LNCS, vol.2572, 346-360.
[12] J. Hammer, H. Garcia-Molina, S. Nestorov, R. Yerneni, M. M. Breunig,
and V. Vassalos, Template-based wrappers in the TSIMMIS system, Proc.
of ACM SIGMOD, 1997, pp. 532-535.
[13] R.A.Brualdi, Introductory Combinatorics (4th edition ed.), Pearson
Prentice Hall, ISBN 0131001191, 2004.
147
DBKDA 2011 : The Third International Conference on Advances in Databases, Knowledge, and Data Applications
Copyright (c) IARIA, 2011              ISBN:978-1-61208-115-1

