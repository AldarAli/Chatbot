113
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Reliability Evaluation of Erasure Coded Systems
under Rebuild Bandwidth Constraints
Ilias Iliadis
IBM Research – Zurich
8803 R¨uschlikon, Switzerland
Email: ili@zurich.ibm.com
Abstract—Modern storage systems employ erasure coding redun-
dancy and recovering schemes to ensure high data reliability
at high storage efﬁciency. The widely used replication scheme
belongs to this broad class of erasure coding schemes. The
effectiveness of these schemes has been evaluated based on the
Mean Time to Data Loss (MTTDL) and the Expected Annual
Fraction of Data Loss (EAFDL) metrics. To improve the reliability
of data storage systems, certain data placement and rebuild
schemes reduce the rebuild times by recovering data in parallel
from the storage devices. It is often assumed that there is
sufﬁcient network bandwidth to transfer the data required by the
rebuild process at full speed. In large-scale data storage systems,
however, the network bandwidth is constrained. This article
obtains MTTDL and EAFDL of erasure coded systems analytically
for arbitrary rebuild time distributions and for the symmet-
ric, clustered, and declustered data placement schemes under
network rebuild bandwidth constraints. The resulting reliability
degradation is assessed and the results obtained establish that the
declustered placement scheme offers superior reliability in terms
of both metrics. Efﬁcient codeword conﬁgurations that achieve
high reliability in the presence of network rebuild bandwidth
constraints are identiﬁed.
Keywords–Storage;
Reliability;
Data
placement;
MTTDL;
EAFDL; RAID; MDS codes; Information Dispersal Algorithm; Pri-
oritized rebuild; Repair bandwidth; Network bandwidth constraint.
I.
INTRODUCTION
In today’s large-scale data storage systems, data redun-
dancy is introduced to ensure that data lost due to device and
component failures can be recovered. Appropriate redundancy
schemes are deployed to prevent permanent loss of data
and, consequently, enhance the reliability of storage systems
[1]. The effectiveness of these schemes has been evaluated
based on the Mean Time to Data Loss (MTTDL) [2-21] and,
more recently, the Fraction of Data Loss Per Year (FDLPY)
[22] and the equivalent Expected Annual Fraction of Data
Loss (EAFDL) reliability metrics [23-25]. Analytical reliability
expressions for MTTDL were obtained predominately using
Markovian models, which assume that component failure and
rebuild times are independent and exponentially distributed.
In practice, however, these distributions are not exponential.
To cope with this issue, system reliability was assessed in
[17][19][24][25] using an alternative methodology that does
not involve Markovian analysis and considers the practical
case of non-exponential failure and rebuild time distributions.
Moreover, the misconception reported in [26] that MTTDL
derivations based on Markovian models provide unrealistic
results was dispelled in [27] by invoking improved MTTDL
derivations that yield satisfactory results, and also by draw-
ing on prior work that obtains MTTDL analytically without
involving Markovian analysis.
Earlier works have predominately considered the MTTDL
metric, whereas recent works have also considered the EAFDL
metric [23][24][25]. The introduction of the latter metric was
motivated by the fact that Amazon S3 considers the durability
of data over a given year [28], and, similarly, Facebook [29],
LinkedIn [30] and Yahoo! [31] consider the amount of data
lost in given periods.
To protect data from being lost and to improve the reliabil-
ity of data storage systems, replication-based storage systems
spread replicas corresponding to data stored on each storage
device across several other storage devices. To improve the
low storage efﬁciency associated with the replication schemes,
erasure coding schemes that provide a high data reliability as
well as a high storage efﬁciency are deployed. Special cases
of such codes are the Redundant Arrays of Inexpensive Disks
(RAID) schemes, such as RAID-5 and RAID-6, that have been
deployed extensively in the past thirty years [2][3].
State-of-the-art data storage systems [32-35] employ more
general erasure codes that affect the reliability, performance,
and the storage and reconstruction overhead of the system.
In this article, we focus on the reliability assessment of
erasure coded systems in terms of the MTTDL and EAFDL
metrics. These metrics were analytically derived in [25] for the
symmetric, clustered, and declustered data placement schemes
under the assumption that there is sufﬁcient network bandwidth
to transfer the data required by the rebuild process at full speed.
For instance, in the case of a declustered placement, redundant
data associated with the data stored on a given device is placed
across all remaining devices in the system. In this way, the re-
build process can be parallelized, which in turn results in short
rebuild times. The restoration time can be minimized provided
there is sufﬁcient network rebuild bandwidth available. In
large-scale erasure coded storage systems, however, the rebuild
operations generate a signiﬁcant amount of network trafﬁc that
interferes with user-generated network trafﬁc [36]. A common
practice to cope with growing network trafﬁc is to throttle the
network bandwidth available for recovery operations, which
leads to the network bandwidth being constrained. This in
turn results in a reliability degradation, the extent of which
is minimized by employing a prioritized rebuild process that
ﬁrst rebuilds the most-exposed to failure data [25][32].
The effect of network rebuild bandwidth constraints on the
reliability of replication-based storage systems was studied in
[9][16]. It was found that system reliability was signiﬁcantly

114
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
reduced when replicas are spread over a higher number of
devices than what the network rebuild bandwidth can support
at full speed during a parallel rebuild process. The reliability of
erasure coded systems in the absence of bandwidth constraints
was assessed in [25]. The MTTDL and EAFDL metrics
were obtained analytically for the symmetric, clustered, and
declustered data placement schemes based on a general frame-
work and methodology. In this article, we recognize that this
methodology also holds in the case of network rebuild band-
width constraints and apply it to derive enhanced closed-form
reliability expressions for the MTTDL and EAFDL metrics
for these placement schemes in the presence of such rebuild
bandwidth constraints. Subsequently, we provide insight into
the effect of the placement schemes and the impact of the
available network rebuild bandwidth on system reliability.
The validity of this methodology for accurately assessing the
reliability of storage systems was conﬁrmed by simulations in
several contexts [15][16][17][19][23]. It was demonstrated that
theoretical predictions for the reliability of systems comprised
of highly reliable storage devices are in good agreement with
simulation results. Consequently, the emphasis of the present
work is on the theoretical assessment of the effect of network
rebuild bandwidth constraints on the reliability of erasure
coded systems. Moreover, this work extends the reliability
results obtained in [16] for the special case of replication-based
storage systems to the more general case of erasure coded
systems.
The key contributions of this article are the following.
We consider the reliability of erasure coded systems under
network rebuild bandwidth constraints that was assessed in
our earlier work [1] for deterministic rebuild times. In this
study, we extend our previous work by also considering
arbitrary rebuild times. We show that the codeword lengths
that optimize the MTTDL and EAFDL metrics are similar.
Furthermore, we derive the asymptotic analytic expressions
for the MTTDL and EAFDL reliability metrics when the
number of devices becomes large. We then obtain analytically
the optimal codeword lengths corresponding to large storage
systems. We subsequently establish theoretically that, for large
storage systems that use a declustered placement scheme, both
metrics are optimized when the codeword length is about 60%
of the storage system size, regardless of the rebuild bandwidth
constraints.
The remainder of the article is organized as follows. Sec-
tion II describes the storage system model and the correspond-
ing parameters considered. Section III presents the adaptation
of a general framework and methodology for deriving the
MTTDL and EAFDL metrics analytically for the case of
erasure coded systems under network rebuild bandwidth con-
straints. Closed-form expressions for the symmetric, clustered,
and declustered placement schemes are derived. In Section IV,
the data placement schemes that offer the best reliability are
identiﬁed and the resulting optimal system conﬁgurations are
speciﬁed in Section V. Section VI presents numerical results
demonstrating the effectiveness of the erasure coding redun-
dancy schemes for improving system reliability. It also assesses
the sensitivity to the network rebuild bandwidth constraints
under various codeword conﬁgurations. Section VII provides
a discussion of the applicability of the results obtained. Finally,
we conclude in Section VIII.
II.
STORAGE SYSTEM MODEL
Modern data storage systems use erasure coded schemes
to protect data from device failures. When devices fail, the
redundancy of the affected data is reduced and eventually lost.
To avoid irrecoverable data loss, the system performs rebuild
operations that use the data stored in the surviving devices
to reconstruct the temporarily lost data, thus maintaining the
initial data redundancy. We proceed by brieﬂy reviewing the
basic concepts of erasure-coding and data-recovery procedures
of such storage systems. To assess their reliability, we consider
the model used in [25], and adopt and extend the notation.
More precisely, the storage system considered here comprises
n storage devices (nodes or disks), with each device storing
an amount c of data, such that the total storage capacity of the
system is n c.
A. Redundancy
User data is divided into blocks (or symbols) of a ﬁxed size
(e.g., sector size of 512 bytes) and complemented with parity
symbols to form codewords. We consider (m, l) maximum
distance separable (MDS) erasure codes, which are a mapping
from l user-data symbols to a set of m (> l) symbols, called
a codeword, having the property that any subset containing
l of the m symbols of the codeword can be used to decode
(reconstruct, recover) the codeword. The corresponding storage
efﬁciency seff is given by
seff = l
m .
(1)
Consequently, the amount U of user data stored in the system
is given by
U = seff n c = l n c
m
.
(2)
Our notation is summarized in Table I. The parameters are
divided according to whether they are independent or derived,
and are listed in the upper and lower part of the table,
respectively.
The m symbols of each codeword are stored on m distinct
devices, such that the system can tolerate any ˜r − 1 device
failures, but ˜r device failures may lead to data loss, with
˜r = m − l + 1 .
(3)
From the above, it follows that
1 ≤ l < m
and
2 ≤ ˜r ≤ m .
(4)
Examples of MDS erasure codes are the following:
Replication: A replication-based system with a replication
factor r can tolerate any loss of up to r − 1 copies of some
data, such that l = 1, m = r and ˜r = r. Also, its storage
efﬁciency is equal to s(replication)
eff
= 1/r.
RAID-5: A RAID-5 array comprised of N devices uses an
(N, N − 1) MDS code, such that l = N − 1, m = N and
˜r = 2. It can therefore tolerate the loss of up to one device,
and its storage efﬁciency is equal to s(RAID-5)
eff
= (N − 1)/N.
RAID-6: A RAID-6 array comprised of N devices uses an
(N, N − 2) MDS code, such that l = N − 2, m = N and
˜r = 3. It can therefore tolerate a loss of up to two devices,
and its storage efﬁciency is equal to s(RAID-6)
eff
= (N − 2)/N.
Reed–Solomon: It is based on (m, l) MDS erasure codes.

115
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
TABLE I.
NOTATION OF SYSTEM PARAMETERS
Parameter
Deﬁnition
n
number of storage devices
c
amount of data stored on each device
l
number of user-data symbols per codeword (l ≥ 1)
m
total number of symbols per codeword (m > l)
(m, l)
MDS-code structure
s
symbol size
k
spread factor of the data placement scheme, or
group size (number of devices in a group) (m ≤ k ≤ n)
b
average reserved rebuild bandwidth per device
Bmax
upper limitation of the average network rebuild bandwidth
X
time required to read (or write) an amount c of data at an average
rate b from (or to) a device
FX(.)
cumulative distribution function of X
Fλ(.)
cumulative distribution function of device lifetimes
seff
storage efﬁciency of redundancy scheme (seff = l/m)
U
amount of user data stored in the system (U = seff n c)
˜r
minimum number of codeword symbols lost that lead to an irrecov-
erable data loss (˜r = m − l + 1 and 2 ≤ ˜r ≤ m)
Nb
maximum number of devices from which rebuild can occur at full
speed in parallel (Nb = Bmax/b)
φ
bandwidth constraint factor
“
φ = min
“ Nb
k , 1
””
Beff
effective average network rebuild bandwidth
fX(.)
probability density function of X (fX(.) = F ′
X(.))
µ−1
mean time to read (or write) an amount c of data at an average rate
b from (or to) a device (µ−1 = E(X) = c/b)
λ−1
mean time to failure of a storage device
(λ−1 =
R ∞
0 [1 − Fλ(t)]dt)
Note that the RAID-10 and RAID-01 storage systems are
non-MDS in that they can sustain a single disk failure and
potentially a second one. Similarly, the nested two-dimensional
RAID-5 systems, such as RAID 51, use non-MDS erasure
codes in that they can sustain any three device failures, but
also certain other subsets of more than three device failures
[21].
B. Symmetric Codeword Placement
According to a symmetric codeword placement, each code-
word is stored on m distinct devices with one symbol per
device. In a large storage system, the number of devices n is
usually much larger than the codeword length m. Therefore,
there are many ways in which a codeword of m symbols can
be stored across a subset of the n devices. For each device
in the system, the redundancy spread factor k denotes the
number of devices over which the codewords stored on that
device are spread [19]. The system effectively comprises n/k
disjoint groups of k devices. Each group contains an amount
U/k of user data, with the corresponding codewords placed
on the corresponding k devices in a distributed manner. Each
codeword is placed entirely in one of the n/k groups. Within
each group, all

116
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Figure 2.
Rebuild under declustered placement.
most-exposed codewords has lost by reading m − ˜r + 1 of
the remaining symbols. In a distributed rebuild process, the
codeword symbols lost by failed devices are reconstructed by
reading surviving symbols from a number, say ˜k, of surviving
devices and storing the recovered symbols in the reserved spare
space of the ˜k surviving devices, as shown in Figure 2.
A certain proportion of the device bandwidth is reserved
for data recovery during the rebuild process, where b denotes
the actual average reserved rebuild bandwidth per device. This
bandwidth is usually only a fraction of the total bandwidth
available at each device, the remaining bandwidth being used
to serve user requests. Thus, the lost symbols are rebuilt in par-
allel using the rebuild bandwidth b available on each surviving
device. During this process, it is desirable to reconstruct the
lost codeword symbols on devices in which another symbol
of the same codeword is not already present. Assuming that
the system is at exposure level u (as described in Section
II-D below), bu (≤ b) denotes the average rate at which the
amount of data that needs to be rebuilt (repair trafﬁc) is written
to selected device(s). Also, denote the cumulative distribution
function of the time X required to read (or write) an amount
c of data from (or to) a device by FX(.) and its corresponding
probability density function by fX(.). The kth moment of X,
E(Xk), is then given by
E(Xk) =
Z ∞
0
tkfX(t)dt ,
for k = 1, 2, . . . .
(6)
In particular, 1/µ denotes the average time required to read
(or write) an amount c of data from (or to) a device, given by
1
µ ≜ E(X) = c
b .
(7)
In a distributed rebuild process involving ˜k devices, per-
forming a rebuild at full speed consumes an average network
bandwidth of ˜k b. Let Bmax (≥ b) denote the available average
network bandwidth for rebuilds. Then, the effective average
network rebuild bandwidth used by rebuilds, Beff(˜k), cannot
exceed Bmax and is therefore given by
Beff(˜k) = min(˜k b, Bmax) = min(˜k, Nb) b ,
(8)
where Nb speciﬁes the effective maximum number of devices
from which rebuild can occur in parallel at full speed, and is
given by
Nb ≜ Bmax
b
.
(9)
Figure 3.
Rebuild under clustered placement.
Note that Nb may not be an integer; it only represents the
effective maximum number of devices from which distributed
rebuild can occur at full speed.
A similar reconstruction process is used for other symmet-
ric placement schemes within each group of k devices, except
for clustered placement. When clustered placement is used,
the codeword symbols are spread across all k = m devices in
each group (cluster). Therefore, reconstructing the lost symbols
on the surviving devices of a group will result in more than
one symbol of the same codeword on the same device. To
avoid this, the lost symbols are reconstructed directly in spare
devices as shown in Figure 3. In these reconstruction processes,
decoding and re-encoding of data are assumed to be done on
the ﬂy, so the reconstruction time is equal to the time taken
to read and write the required data to the devices. Note also
that alternative erasure coding schemes have been proposed to
reduce the amount of data transferred over the storage network
during reconstruction (see [37][38] and references therein).
D. Exposure Levels and Amount of Data to Rebuild
At time t, Dj(t) denotes the number of codewords that
have lost j symbols, where 0 ≤ j ≤ ˜r. The system is at
exposure level u (0 ≤ u ≤ ˜r), where
u =
max
Dj(t)>0 j.
(10)
The system is at exposure level u if there are codewords with
m − u symbols left, but there are no codewords with fewer
than m − u symbols left in the system, that is, Du(t) > 0,
and Dj(t) = 0, for all j > u. These codewords are referred
to as the most-exposed codewords. At t = 0, Dj(0) = 0 for
all j > 0, and D0(0) is the total number of codewords stored
in the system. Device failures and rebuild processes cause the
values of D1(t), · · · , D˜r(t) to change over time, and when a
data loss occurs, D˜r(t) > 0. Device failures cause transitions
to higher exposure levels, whereas rebuilds cause transitions to
lower ones. Let tu denote the time of the ﬁrst transition from
exposure level u − 1 to exposure level u, and t+
u the instant
immediately after tu. Then, the number Cu of most-exposed
codewords when entering exposure level u, u = 1, . . . , ˜r, is
given by Cu = Du(t+
u ). For u = 1, according to [25, Equation
(8)], it holds that C1 = c/s, where s denotes the symbol size.
For u ≥ 2, according to [25, Equations (6) and (27)], the

117
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
expected value of Cu is given by
E(Cu | α1, . . . , αu−1) = c
s
u−1
Y
j=1
Vj αj ,
for u = 2, . . . , ˜r ,
(11)
where Vj represents the fraction of the most-exposed code-
words at exposure level j that have symbols stored on a
newly failed device that causes the exposure level transition
j → j + 1. Note that this fraction is dependent only on the
codeword placement scheme. Also, αj denotes the fraction of
rebuild time Rj still left when another device fails causing the
exposure level transition j → j + 1. Unconditioning (11) on
α1, . . . , αu−1 yields
E(Cu) = c
s


u−1
Y
j=1
Vj

 E


u−1
Y
j=1
αj

 ,
for u = 2, . . . , ˜r .
(12)
Analytic expressions for the reliability metrics of interest
were derived in [25] using the direct path approximation,
which considers only transitions from lower to higher exposure
levels [15][17][19]. This implies that each exposure level is
entered only once.
E. Failure and Rebuild Time Distributions
We adopt the model and notation considered in [25]. The
lifetimes of the n devices are assumed to be independent and
identically distributed, with a cumulative distribution function
Fλ(.) and a mean of 1/λ. We consider real-world distributions,
such as Weibull and gamma, as well as exponential distri-
butions that belong to the large class deﬁned in [17]. Note
that, although the model considered here does not account
for correlated device failures, their effect can be assessed by
enhancing the model according to the approach presented in
[14]. This issue, however, is beyond the scope of this article.
The storage devices are characterized to be highly reliable in
that the ratio of the mean time 1/µ to read all contents of a
device (which typically is on the order of tens of hours), to
the mean time to failure of a device 1/λ (which is typically
at least on the order of thousands of hours) is very small, that
is,
λ
µ = λ c
b
≪ 1 .
(13)
We consider storage devices the cumulative distribution
function Fλ satisﬁes the condition
µ
Z ∞
0
Fλ(t)[1 − FX(t)]dt ≪ 1,
with λ
µ ≪ 1 ,
(14)
such that the MTTDL and EAFDL reliability metrics of erasure
coded storage systems tend to be insensitive to the device
failure distribution, that is, they depend only on its mean 1/λ,
but not on its density Fλ(.). They are, however, sensitive to
the distribution FX(.) of the device rebuild times [25].
III.
DERIVATION OF MTTDL AND EAFDL
The MTTDL metric assesses the expected amount of time
until some data can no longer be recovered and therefore is
irrecoverably lost, whereas the EAFDL assesses the fraction of
stored data that is expected to be lost by the system annually.
The EAFDL is obtained as the ratio of the expected amount
of user data lost normalized to the amount of user data to the
mean time to data loss [23, Equation (6)]:
EAFDL =
E(H)
U · MTTDL ,
(15)
where H denotes the amount of user data lost, given that a data
loss has occurred, and with the MTTDL expressed in years.
The MTTDL(Bmax) and EAFDL(Bmax) metrics are derived
as a function of Bmax based on the framework and methodol-
ogy presented in [25]. More speciﬁcally, this methodology uses
the direct path approximation and does not involve Markovian
analysis. It holds for general failure time distributions, which
can be exponential or non-exponential, such as the Weibull
and gamma distributions that satisfy condition (14). Note
that this framework is general because it is also valid in
the case where the network rebuild bandwidth is constrained.
The only parameters that are affected by the network rebuild
bandwidth constraint are the rebuild rates and, accordingly,
those parameters that are dependent on them, such as the
rebuild times. Analytic expressions for the two metrics of
interest were derived in [25, Equations (49) and (50)] as
follows:
MTTDL(Bmax) ≈
1
n λ
(˜r − 1)!
(λ c)˜r−1
[E(X)]˜r−1
E(X ˜r−1)
˜r−1
Y
u=1
bu(Bmax)
˜nu
1
V ˜r−1−u
u
, (16)
and
EAFDL(Bmax) ≈
m λ (λ c)˜r−1 1
˜r !
E(X ˜r−1)
[E(X)]˜r−1
˜r−1
Y
u=1
˜nu
bu(Bmax) V ˜r−u
u
, (17)
where ˜nu represents the number of devices at exposure level
u whose failure before the rebuild of the most-exposed code-
words causes an exposure level transition to level u + 1. As
mentioned above, bu, the average rate at which the amount of
data that needs to be rebuilt at exposure level u is written to
selected device(s), is dependent on Bmax, the upper limitation
of the average network rebuild bandwidth.
The expected amount E(Q) of data lost upon a ﬁrst-device
failure is given by [25, Equation (47)]
E(Q) ≈ l c (λ c)˜r−1 1
˜r !
E(X ˜r−1)
[E(X)]˜r−1
˜r−1
Y
u=1
˜nu
bu
V ˜r−u
u
,
(18)
where E(X ˜r−1) is obtained by (6). Subsequently, the expected
amount E(H) of data lost, given that a data loss has occurred,
is given by [25, Equation (48)]
E(H) ≈
 
l
˜r
˜r−1
Y
u=1
Vu
!
c .
(19)
Central to the derivation of E(Q) and E(H) is the assess-
ment of the amount H of user data lost, that is, the amount of
user data stored in the most-exposed codewords when entering
exposure level ˜r that can no longer be recovered and therefore
is irrecoverably lost. In [25, Equation (22)] it was assumed that

118
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
each of the most-exposed codewords loses all its l symbols of
user data, that is,
H = C˜r l s ,
(20)
where C˜r is the number of the most-exposed codewords when
entering exposure level ˜r, and s is the symbol size. This clearly
overestimates the amount of data lost, especially when the
number of user-data symbols l in each of the most-exposed
codewords is greater than the number of lost symbols ˜r. We
proceed to revise the derivation of H. Let nl denote the
number of user-data symbols irrecoverably lost in a typical
most-exposed codeword. As devices are equally likely to fail,
and given that the fraction of user-data symbols in a codeword
is equal to l/m, a moment’s reﬂection reveals that the expected
number of user-data symbols irrecoverably lost is given by
E(nl) = l
m ˜r =
˜r
m l .
(21)
Consequently, for a number C˜r of most-exposed codewords,
the expected amount E(H | C˜r) of user data lost is given by
E(H | C˜r) = C˜r E(nl) s
(21)
=
C˜r
˜r
m l s ,
(22)
which in turn, by unconditioning on C˜r, yields
E(H) = E(C˜r) ˜r
m l s .
(23)
From the above, it follows that in each of the most-exposed
codewords, the expected fraction fl of the user-data symbols
that are lost is given by
fl ≜ E
nl
l

= E(nl)
l
= ˜r
m
(3)
= m − l + 1
m
.
(24)
The resulting expressions for E(Q), EAFDL, and E(H) can
now be obtained by multiplying (18), (17), and (19) with fl,
which yields
E(Q) ≈
l
m c (λ c)˜r−1
1
(˜r − 1) !
E(X ˜r−1)
[E(X)]˜r−1
˜r−1
Y
u=1
˜nu
bu
V ˜r−u
u
,
(25)
where E(X ˜r−1) is obtained by (6),
EAFDL(Bmax) ≈
λ (λ c)˜r−1
1
(˜r − 1) !
E(X ˜r−1)
[E(X)]˜r−1
˜r−1
Y
u=1
˜nu
bu(Bmax) V ˜r−u
u
,
(26)
and
E(H) ≈
 
l
m
˜r−1
Y
u=1
Vu
!
c .
(27)
Remark 1: From (16), (26), and (27), and given that
E(X) = c/b, it follows that MTTDL and EAFDL are depen-
dent on the (m−l)th moment of the rebuild time distribution.
Furthermore, given that E(Xm−l) ≥ [E(X)]m−l, random
rebuild times result in lower MTTDL and higher EAFDL
values than deterministic rebuild times do. In contrast, the
expected amount E(H) of user data lost, given that a data
loss has occurred, is not dependent on λ, b and c nor on the
rebuild time distribution. Moreover, E(H) is not dependent
on bu and therefore is not affected by the limitation on the
network rebuild bandwidth; it is only dependent on the storage
efﬁciency and data placement scheme. Moreover, MTTDL is
dependent on n, but EAFDL and E(H) are not.
Remark 2: The analytic expressions for the MTTDL and
EAFDL reliability metrics were derived in [25] in the absence
of network rebuild bandwidth constraints. Consequently, they
correspond to the case of Bmax = ∞, where the two metrics
are denoted by MTTDL(∞) and EAFDL(∞), respectively.
From (16) and (17), or the enhanced expression (26), it
follows that
MTTDL(Bmax)
MTTDL(∞)
=
EAFDL(∞)
EAFDL(Bmax) = θ ,
(28)
where θ represents the reliability reduction factor that assesses
the reliability degradation due to a network rebuild bandwidth
constraint, and is given by
θ ≜
˜r−1
Y
u=1
bu(Bmax)
bu(∞)
.
(29)
Equation (28) suggests that the reliability reduction factor
for EAFDL is the same as the one for MTTDL. At ﬁrst glance,
and given the different nature of the MTTDL and EAFDL
metrics, this seems to be counterintuitive. The reason for this
result is that network rebuild bandwidth constraints effectively
prolong the duration of the rebuild times, which equally
affects the MTTDL and EAFDL metrics. More speciﬁcally,
at exposure level u, and according to [25, Equations (43) and
(44)], the transition probability Pu→u+1 from exposure level
u to u + 1 is proportional to the rebuild time Ru, which
in turn is inversely proportional to the average rebuild rate
bu. Thus, constraining the average rebuild rates bu increases
the probability of data loss PDL. Consequently, the reliability
metrics are equally affected given that, according to [25,
Equations (14) and (15)], MTTDL and EAFDL are inversely
proportional and proportional to PDL, respectively. Note also
that the corresponding amount of data lost H is dependent only
on the data placement scheme and is therefore not affected by
the prolongation of the rebuild times.
Remark 3: From (29), and given that bu(Bmax) decreases
with decreasing Bmax, it follows that θ decreases with increas-
ing ˜r or decreasing Bmax.
Remark 4: From (12), (23), and (27), it follows that
E


˜r−1
Y
j=1
αj

 = 1
˜r .
(30)
Note that the variables α1, . . . , α˜r−1 are generally inde-
pendent and approximately uniformly distributed between 0
and 1 such that E(αu) ≈ 1/2, u = 1, . . . , ˜r − 1 [23, 25].
In this context, however, this assumption would lead to the
erroneous result E(Q˜r−1
j=1 αj) = 1/2˜r−1, which is smaller than
the correct one by a factor of 2˜r−1/˜r. This is analogous to
the factor of 2r−1/r that was derived for replication-based
storage systems in Section V.E of [23]. It turns out that when
a data loss has occurred, the variables α1, . . . , α˜r−1 are not
distributed identically. Further insight regarding this subtle
issue is provided in the relevant discussion of that section.

119
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Assuming that the system has reached exposure level u, we
deduce from (30) that
E


u−1
Y
j=1
αj

 = 1
u ,
for u = 2, . . . , ˜r .
(31)
A. Symmetric Placement
We consider the case where the redundancy spread factor
k is in the interval m < k ≤ n. The special case k = m,
which corresponds to the clustered placement scheme, has to
be considered separately for the reasons discussed in Section
II-B1. As discussed in [25, Section IV-B], the prioritized
rebuild process at each exposure level u recovers one of the
u symbols that each of the most-exposed codewords has lost
by reading m − ˜r + 1 of the remaining symbols from the
˜nu surviving devices in the affected group. According to [25,
Equation (51)], it holds that
˜nsym
u
= k − u .
(32)
Furthermore, in the absence of a network rebuild bandwidth
constraint, the total write bandwidth, which is also the average
rebuild rate bu, is given by [25, Equation (52)]
bsym
u (∞) =
˜nsym
u
m − ˜r + 2 b
(3)
= ˜nsym
u
b
l + 1 ,
u = 1, . . . , ˜r − 1 .
(33)
However, in the presence of a network rebuild bandwidth
constraint Bmax and according to (8) with ˜k = ˜nu = ˜nsym
u ,
the average rebuild rate bu is given as a function of Bmax by
bsym
u (Bmax) = Beff(˜nu)
l + 1
= min(˜nu b, Bmax)
l + 1
= min(˜nu, Nb) b
l + 1
(32)
=
min(k − u, Nb) b
l + 1
, for u = 1, . . . , ˜r − 1 .
(34)
Substituting (33) and (34) into (29) yields
θ sym =
˜r−1
Y
u=1
min(k − u, Nb)
k − u
.
(35)
Note that when Nb ≥ k − 1, the system reliability is not
affected because all rebuilds are performed at full speed, and
therefore the factor θ is equal to 1. However, when Nb <
k − 1, it may not be possible for some of the rebuilds to be
performed at full speed, and therefore the factor θ will be
less than 1, which affects the system reliability. Consequently,
the reliability reduction factor θ depends on the bandwidth
constraint factor φ which is given by
φ ≜ min
Nb
k , 1

(9)
= min
Bmax
k b , 1

, with 0 ≤ φ ≤ 1 .
(36)
From (34), (35), and (36), and recognizing that min(k −
u, Nb) = min(min(k−u, k), Nb) = min(k−u, min(k, Nb)) =
min(k min(1, Nb/k), k −u) = min(k φ, k −u), it follows that
bsym
u (Bmax) =
min

φ
1− u
k , 1

(k − u) b
l + 1
, for u = 1, . . . , ˜r−1 ,
(37)
and
θ sym =
˜r−1
Y
u=1
min

φ
1 − u
k
, 1

.
(38)
Using (38) and the fact that MTTDL(∞) is given by [25,
Equation (54)], (28) yields
MTTDLsym
k (Bmax) ≈
1
n λ

b
(l + 1) λ c
m−l
(m − l)!
[E(X)]m−l
E(Xm−l)
m−l
Y
u=1
 k − u
m − u
m−l−u
m−l
Y
u=1
min

φ
1 − u
k
, 1

,
(39)
where Bmax is expressed via φ given by (36).
Note that, for a deterministic rebuild time distribution,
for which it holds that E(Xm−l) = [E(X)]m−l, and for a
replication-based system, for which m = r and l = 1, and
by virtue of (35) and (38), Equation (39) is in agreement with
Equation (24) of [16], where c/b = 1/µ.
Using (38) and the fact that EAFDL(∞) is obtained by
multiplying [25, Equation (55)] with the expected fraction fl
of the user-data symbols that are contained in the irrecoverable
codewords and are lost, by virtue of (24), (28) yields
EAFDLsym
k (Bmax) ≈ λ
(l + 1) λ c
b
m−l
1
(m − l)!
E(Xm−l)
[E(X)]m−l
m−l
Y
u=1
m − u
k − u
m−l+1−u, m−l
Y
u=1
min

φ
1 − u
k
, 1

,
(40)
where Bmax is expressed via φ given by (36).
Moreover, E(H) can be obtained by multiplying [25,
Equation (56)] with fl, which, according to (24), yields
E(H)sym
k
≈
 
l
m
m−l
Y
u=1
m − u
k − u
!
c
(41)
= l (m − 1)! (k − m + l − 1)!
m (k − 1)! (l − 1)!
c .
(42)
For given l, m, n, and φ, the redundancy spread fac-
tors or, equivalently, the optimal group sizes that maximize
MTTDLsym, EAFDLsym, and E(H)sym are given by the fol-
lowing propositions.
Proposition 1: For given l, m, n, and φ, and for any λ, c,
b, and rebuild time distribution of X, the value of k (m+1 ≤
k ≤ n), denoted by ˆks, that maximizes MTTDLsym
k
is given
by
ˆks =

















any j ∈ [m + 1, n] ∩ Dn , which includes j = km ,
for m − l = 1 and φ ≥ 1 − 1
n
any j ∈ [m + 1,
1
1−φ] ∩ Dn , which includes j = km ,
for m − l = 1 and 1 −
1
km ≤ φ < 1 − 1
n
km ,
for m − l = 1 and φ < 1 −
1
km
n ,
for m − l ≥ 2 ,
(43)

120
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
where Dn is the set of the divisors (factors) of n, that is,
Dn ≜ { j : j | n} ≡

j : j ∈ N
and
n
j ∈ N

, (44)
and km is the smallest integer in the interval Ik = [m + 1, n]
that divides n, that is,
km ≜ min
j
{ j ∈ Ik ∩ Dn} .
(45)
Proof: See Appendix A.
Proposition 2: For given l, m, n, and φ, and for any c, λ,
and rebuild time distribution of X, EAFDLsym
k
and E(H)sym
k
are decreasing in k and are therefore minimized when k = n.
Proof: Considering l, m, and n to be ﬁxed, it follows from
(40) that EAFDLsym
k
is inversely proportional to the function
Bk given by
Bk ≜
m−l
Y
u=1
(k − u)m−l−u min(k φ, k − u) .
(46)
Note that each of the terms in the product is increasing
in k, which implies that Bk is also increasing in k and,
consequently, EAFDLsym
k
is decreasing in k. Furthermore, it
follows from (41) that E(H)sym
k
is also decreasing in k.
Remark 5: From the preceding two propositions it follows
that, for l + 1 < m < k ≤ n, MTTDLsym
k
is maximized and
EAFDLsym
k
and E(H)sym
k
are minimized by the declustered
placement scheme, that is, when k = n.
An approximate expression for the reliability reduction
function is given by the following lemma.
LEMMA 1: For large values of k, m, l, and m − l, θ sym
can be approximated as follows:
log

121
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
The term EAFDLsym
approx(∞) is obtained by multiplying
the corresponding term obtained in [25] with the expected
fraction fl of the user-data symbols that are contained in the
irrecoverable codewords and are lost. Consequently, the term
log

122
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
For an exponential rebuild time distribution, for which it
holds that E(Xm−l) = (m − l)! [E(X)]m−l, and for a RAID-
6 array comprised of N devices, such that n = k = m = N
and l = N − 2, for φ ≥ seff = l/m and by virtue of (7), (68)
yields
MTTDLclus, exp
RAID-6
≈
µ2
N(N − 1)(N − 2)λ3 ,
(70)
which is the same result as that reported in [3]. That result
was derived using a continuous-time Markov chain (CTMC)
model with the repair rate equal to µ, which is not dependent
on the number of failed devices. This is analogous to our model
where lost symbols are written to a spare device at an average
rate of b, which is ﬁxed and is not dependent on the number of
failed devices, and the rebuild time distribution is exponential.
In contrast, in [39], the Mean Time Between Failures
(MTBF) was derived using a CTMC model and assuming that
the repair rate of each failed device is ﬁxed, which implies
that the total repair rate is proportional to the number of failed
devices. In the case where λ ≪ µ, [39, Equation (1.1)] with
k replaced by l and n by N yields
MTBF ≈
1
l λ

123
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
EAFDLdeclus(Bmax) ≈ λ
(l + 1) λ c
b
m−l
1
(m − l)!
E(Xm−l)
[E(X)]m−l
m−l
Y
u=1
m − u
n − u
m−l+1−u, m−l
Y
u=1
min

φ
1 − u
n
, 1

,
(83)
where Bmax is expressed via φ given by (36) with k = n, and
E(H)declus ≈
 
l
m
m−l
Y
u=1
m − u
n − u
!
c
(84)
= l (m − 1)! (n − m + l − 1)!
m (n − 1)! (l − 1)!
c .
(85)
Approximate expressions for the reliability metrics of in-
terest are given by the following propositions.
Proposition 7: For large values of n, m, l, and m − l,
MTTDLdeclus normalized to 1/λ can be approximated as fol-
lows:
log

124
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
k ≤ n), denoted by ˆk, that maximizes MTTDLk is given by
ˆk =

































m ,
for m − l = 1 and n = j m , for some j ∈ N
ˆks ,
for m − l = 1 and n ̸= j m , for all j ∈ N
m ,
for l = 1, m = 3, n = 3 j with 2 ≤ j ≤ 11 ,
and φ < 2√n−2
n
m ,
for l = 2, m = 4, n = 8, φ < 3
√
3
8
= 0.649
m ,
for l = 2, m = 4, n = 12, φ <
√
5
4 = 0.559
m ,
for l = 3, m = 5, n = 10, φ < 4
√
2
5
√
3 = 0.653
m ,
for l = 1, m = 4, n = 8, φ < 1
4
3q
15
7 = 0.322
n ,
otherwise ,
(91)
where ˆks is given by (43).
Proof: See Appendix C.
B. Minimizing EAFDL
To obtain the optimal EAFDL value and identify the cor-
responding optimal placement, we consider the following two
cases. If m does not divide n, then, according to Proposition
2, the optimal EAFDL value is obtained by the declustered
placement (k = n). If m divides n, then we need to compare
the EAFDLdeclus value with the EAFDLclus value obtained by
the clustered placement with k = m. From (83) and (74), it
follows that the ratio rdeclus,EAFDL
clus,EAFDL
of these two values is given
by
rdeclus,EAFDL
clus,EAFDL
≜ EAFDLdeclus
EAFDLclus
≈ (l + 1)m−l (l − 1)!
(m − 1)! min
m φ
l
, 1
m−l
m−l
Y
u=1
m − u
n − u
m−l+1−u 
min

φ
1 − u
n
, 1

.
(92)
Remark 9: It follows from (92) that the placement that
minimizes EAFDL is not dependent on λ or c. Moreover, the
ratio rdeclus,EAFDL
clus,EAFDL
is dependent on b and Bmax only through φ,
that is, the ratio Bmax/b.
The optimal placement is given by the following proposi-
tion.
Proposition 11: For any l, m, n (n > m), φ, λ, c, b, and
rebuild time distribution of X, the value of k (m ≤ k ≤ n)
that minimizes the EAFDLk is equal to n, which corresponds
to the declustered placement scheme.
Proof: See Appendix D.
C. Minimizing E(H)
To obtain the optimal E(H) value and identify the corre-
sponding optimal placement, we consider the following two
cases. If m does not divide n, then, according to Proposition
2, the optimal E(H) value is obtained by the declustered
placement (k = n). If m divides n, then we need to compare
the E(H)declus value with the E(H)clus value obtained by the
clustered placement with k = m.
From (75) and (84) and using (89), it follows that
rdeclus,H
clus,H
≜ E(H)declus
E(H)clus ≈
m−l
Y
u=1
m − u
n − u
< 1 .
(93)
Remark 10: It follows from (92) that the placement that
minimizes E(H) is not dependent on λ, c, b, Bmax (or,
consequently, φ), nor on the rebuild time distribution of X.
The optimal placement is given by the following proposi-
tion.
Proposition 12: For any l, m, n (n > m), φ, λ, c, b, and
rebuild time distribution of X, the value of k (m ≤ k ≤ n)
that minimizes the E(H)k is equal to n, which corresponds
to the declustered placement scheme.
Proof: Immediate from (93).
V.
OPTIMAL SYSTEM CONFIGURATION
We address the issue of maximizing the reliability of a
system storing an amount U of user data under a given storage
efﬁciency seff and bandwidth constraint factor φ. The required
number of devices n is then determined by (2). Consequently,
the parameters to be speciﬁed are l, m, and k. However, these
parameters are dependent. More speciﬁcally, according to (1),
l = seff m. Also, given l and m, the optimal value ˆk of k
was obtained in Section IV. Consequently, to maximize system
reliability, it sufﬁces to determine the appropriate value m∗ of
m for the optimal codeword length. Then the optimal value
k∗ for the parameter k is obtained by Propositions 10, 11,
and 12. Next, using a speciﬁc example, we will show that for
MTTDL, we may ﬁnd that m∗ ≤ k∗ < n, which implies that
optimality may be achieved by multiple groups, whereas for
EAFDL and E(H), optimality is always achieved by a single
group as expressed by the following proposition.
Proposition 13: For any n, λ, c, b, Bmax (and, conse-
quently, φ), and rebuild time distribution of X, the optimal
value k∗ for the parameter k that minimizes the EAFDL or
the E(H) is equal to n.
Proof: Let us ﬁrst consider the EAFDL metric, where
m∗ and k∗ are the values that minimize it. We consider
the following two cases for m∗. If m∗ < n, then, invoking
Proposition 11 with m = m∗, the value of k (m∗ ≤ k ≤ n)
that minimizes the EAFDLk is equal to n, which implies that
k∗ = n. If m∗ = n, then, owing to (5), it follows that
m∗ = k∗ = n. Similarly, from Proposition 12, it follows that
the optimal value k∗ for the parameter k that minimizes the
E(H) is equal to n.
Consequently, for EAFDL and E(H), the optimal place-
ment is always the clustered or declustered one, whereas for
MTTDL it may also be the symmetric one.
An alternative way to determine the optimal values m∗
and k∗ for the parameters m and k, respectively, is ﬁrst to
determine the optimal codeword length m∗
k for any given k.
Note that from (39), (40), and (41), it follows that m∗
k depends
on k, but not on the storage system size n. Subsequently,
the optimal value of k∗ can be determined by considering all
possible values for k, along with the corresponding values m∗
k,
and identifying the pair (k, m∗
k) that optimizes the reliability
metric.

125
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
10
20
30
40
50
10
−3
10
−2
10
−1
10
0
10
1
10
2
10
3
Number of Devices (n)
λ MTTDL
 
 
seﬀ = 1/2
seﬀ = 3/4
seﬀ = 7/8
(a) Optimal MTTDL
0
10
20
30
40
50
0
0.2
0.4
0.6
0.8
1
Number of Devices (n)
k*/n
 
 
seﬀ = 1/2
seﬀ = 3/4
seﬀ = 7/8
(b) k∗/n
0
10
20
30
40
50
0
0.2
0.4
0.6
0.8
1
Number of Devices (n)
m*/ k*
 
 
seﬀ = 1/2
seﬀ = 3/4
seﬀ = 7/8
(c) m∗/k∗
Figure 4.
Optimization of MTTDL vs. number of devices for seff = 1/2, 3/4, and 7/8; λ/µ = 0.001, φ = 0.001 and deterministic rebuild times.
0
10
20
30
40
50
10
−3
10
−2
10
−1
10
0
10
1
10
2
10
3
Number of Devices (n)
EAFDL / λ
 
 
seﬀ = 1/2
seﬀ = 3/4
seﬀ = 7/8
(a) Optimal EAFDL
0
10
20
30
40
50
0
0.2
0.4
0.6
0.8
1
Number of Devices (n)
k*/n
 
 
seﬀ = 1/2
seﬀ = 3/4
seﬀ = 7/8
(b) k∗/n
0
10
20
30
40
50
0
0.2
0.4
0.6
0.8
1
Number of Devices (n)
m*/ k*
 
 
seﬀ = 1/2
seﬀ = 3/4
seﬀ = 7/8
(c) m∗/k∗
Figure 5.
Optimization of EAFDL vs. number of devices for seff = 1/2, 3/4, and 7/8; λ/µ = 0.001, φ = 0.001 and deterministic rebuild times.
0
10
20
30
40
50
10
−3
10
−2
10
−1
10
0
10
1
10
2
10
3
Number of Devices (n)
E(H) / c
 
 
seﬀ = 1/2
seﬀ = 3/4
seﬀ = 7/8
(a) Optimal E(H)
0
10
20
30
40
50
0
0.2
0.4
0.6
0.8
1
Number of Devices (n)
k*/n
 
 
seﬀ = 1/2
seﬀ = 3/4
seﬀ = 7/8
(b) k∗/n
0
10
20
30
40
50
0
0.2
0.4
0.6
0.8
1
Number of Devices (n)
m*/ k*
 
 
seﬀ = 1/2
seﬀ = 3/4
seﬀ = 7/8
(c) m∗/k∗
Figure 6.
Optimization of E(H) vs. number of devices for seff = 1/2, 3/4, and 7/8; λ/µ = 0.001 and φ = 0.001.
Next, we consider a storage system for which it holds
that λ/µ = λ c/b = 0.001 and φ = 0.001. We identify the
optimal group sizes k∗ and the optimal codeword lengths m∗
that optimize the MTTDL metric for various system sizes,
assuming that the rebuild time distribution is deterministic.
The optimal normalized λ MTTDL, EAFDL/λ, and E(H)/c
values along with the corresponding normalized values k∗/n
and m∗/k∗ are shown in Figures 4, 5, and 6, respectively, as
a function of system size. From Figure 4(a) we observe that,
for a given storage efﬁciency seff, MTTDL initially decreases
and then increases as n increases. For seff = 7/8, MTTDL
starts increasing when n ≥ 115, which is not shown in the
ﬁgure. Figure 4(b) shows the ratio of k∗ to n. Given that
k∗ ≤ n, the maximum value of this ratio is equal to 1. Also,
k∗ cannot be less than the minimum codeword length, which is
equal to 2, 4 and 8, for seff = 1/2, 3/4 and 7/8, respectively.
Therefore, k∗/n cannot be less than 2/n, 4/n and 8/n, as
indicated by the dotted lines for seff = 1/2, 3/4 and 7/8,
respectively. Note that when a point lies on a dotted line,
that is, when k∗ is equal to the minimum codeword length,
then the optimal codeword length m∗, which according to (5)
cannot exceed k∗, is also equal to the minimum codeword
length. This implies that k∗ = m∗ and the optimal placement
is the clustered one. In this case, the ratio m∗/k∗ is equal
to 1, as shown in Figure 4(c). For instance, for n = 8 and
seff = 3/4, k∗/n = 0.5, that is, k∗ = m∗ = 4, and MTTDL
is maximized when we consider two groups with a clustered
placement within each group. However, we see in Figure 4(b)
that, for n = 10 and seff = 3/4, k∗/n is still equal to 0.5,
which means that the optimal group size is now equal to 5, and

126
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
0.2
0.4
0.6
0.8
1
10
−40
10
−30
10
−20
10
−10
10
0
Bandwidth Constraint Factor (φ)
Reliability Reduction Factor (θ)
 
 
˜r = 2
˜r = 4
˜r = 8
˜r = 16
˜r = 32
(a) k = 40
0
0.2
0.4
0.6
0.8
1
10
−40
10
−30
10
−20
10
−10
10
0
Bandwidth Constraint Factor (φ)
Reliability Reduction Factor (θ)
 
 
˜r = 2
˜r = 4
˜r = 8
˜r = 16
˜r = 32
˜r = 64
(b) k = 100
0
0.2
0.4
0.6
0.8
1
10
−40
10
−30
10
−20
10
−10
10
0
Bandwidth Constraint Factor (φ)
Reliability Reduction Factor (θ)
 
 
˜r = 2
˜r = 4
˜r = 8
˜r = 16
˜r = 32
˜r = 64
˜r = 128
(c) k = 200
Figure 7.
Reliability reduction factor vs. bandwidth constraint factor for various values of ˜r; symmetric placement.
0
0.2
0.4
0.6
0.8
1
10
−40
10
−30
10
−20
10
−10
10
0
Bandwidth Constraint Factor (φ)
Reliability Reduction Factor (θ)
 
 
˜r = 2
˜r = 4
˜r = 8
˜r = 16
˜r = 32
(a) m = 40
0
0.2
0.4
0.6
0.8
1
10
−40
10
−30
10
−20
10
−10
10
0
Bandwidth Constraint Factor (φ)
Reliability Reduction Factor (θ)
 
 
˜r = 2
˜r = 4
˜r = 8
˜r = 16
˜r = 32
˜r = 64
(b) m = 100
0
0.2
0.4
0.6
0.8
1
10
−40
10
−30
10
−20
10
−10
10
0
Bandwidth Constraint Factor (φ)
Reliability Reduction Factor (θ)
 
 
˜r = 2
˜r = 4
˜r = 8
˜r = 16
˜r = 32
˜r = 64
˜r = 128
(c) m = 200
Figure 8.
Reliability reduction factor vs. bandwidth constraint factor for various values of ˜r; clustered placement.
the optimal codeword length remains equal to 4. In this case it
holds that m∗/k∗ = 0.8, as shown in Figure 4(c), and MTTDL
is maximized when we consider two groups with a symmetric
placement within each group. Note also that for seff = 1/2
and for system sizes that contain an even number of devices
not exceeding 12, MTTDL is maximized by considering group
sizes of two under a clustered placement (k∗ = m∗ = 2). By
contrast, for an odd number of devices, MTTDL is maximized
by considering a single group and the declustered placement
(k∗ = n). In particular, the optimal codeword lengths are
m∗ = 2, 2, 4, 6, and 6 for n = 3, 5, 7, 9, and 11, respectively.
But when the number of devices exceeds 12, MTTDL is
maximized by considering a single group under declustered
placement and codewords whose lengths are about 60% of
the system size (k∗ = n and m∗ ≈ 0.6 n). For seff = 7/8 and
n = 42, it turns out that k∗ = 14 or, equivalently, k∗/n = 1/3,
and m∗ = 8 or, equivalently, m∗/k∗ = 4/7. Thus, MTTDL
is maximized by considering three groups with a group size
of 14 and a symmetric placement of codewords of length 8
containing seven user-data symbols each. Considering l = 7,
m = 8, and n = 42, we conﬁrm the optimal value of k
by invoking (91), which in this case yields ˆk =
ˆks, then
using (43), which yields ˆks = km, and ﬁnally using (45),
which yields km = 14. In general, the declustered placement
is optimal, except in the cases of small n and φ where another
placement may be optimal. However, this does not happen
in the case of minimizing the EAFDL and E(H) metrics.
According to Proposition 13, and as shown in Figures 5(b)
and 6(b), for all values of n, EAFDL and E(H) are minimized
by a single group (k∗ = n) and the clustered or declustered
placement depending on whether n is equal to or exceeds the
minimum codeword length, respectively.
VI.
NUMERICAL RESULTS
First, we assess the reduction in reliability owing to
bandwidth constraints. The reliability reduction factor θ is
obtained by (38) and (67) for the symmetric and clustered
placements, respectively, and shown in Figures 7 and 8 as a
function of the bandwidth constraint factor. For a symmetric
placement scheme, Figure 7 demonstrates that as the group
size k increases, the reliability reduction factor θ decreases and
the magnitude of the reduction is more pronounced for larger
values of ˜r. Clearly, if codewords are spread over a higher
number of devices than what the network rebuild bandwidth
can support at full speed during a parallel rebuild process,
the system reliability is affected and a drastic reliability
degradation occurs as the system size increases. In contrast,
according to Remark 7, the reliability of a clustered placement
scheme remains unaffected for φ ≥ l/m = (m − ˜r + 1)/m.
This is due to the fact that the effective rebuild bandwidth is
signiﬁcantly smaller because the rebuilds are not distributed,
but performed directly on a spare device. However, as Figure
8 demonstrates for φ < l/m, the reliability reduction factor
drops sharply, especially for large values of ˜r.
Next, we consider a storage system of a given size and
assess its reliability for various codeword conﬁgurations, stor-
age efﬁciencies, and network rebuild bandwidth constraints.
In particular, we consider a system containing 120 devices
under a declustered placement scheme (k = n = 120), which
according to Remark 5 is optimal within the class of symmetric
schemes. The amount U of user data stored is determined by

127
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
20
40
60
80
100
120
10
0
10
50
10
100
10
150
10
200
10
250
m
λ MTTDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
20
40
60
80
100
120
10
0
10
50
10
100
10
150
10
200
10
250
m
λ MTTDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
20
40
60
80
100
120
10
0
10
50
10
100
10
150
10
200
10
250
m
λ MTTDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
20
40
60
80
100
120
10
0
10
50
10
100
10
150
10
200
10
250
m
λ MTTDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 9.
Normalized MTTDL vs. codeword length for seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; n = k = 120, λ/µ = 0.001 and deterministic rebuild
times.
0
20
40
60
80
100
120
10
−250
10
−200
10
−150
10
−100
10
−50
10
0
m
EAFDL / λ
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
20
40
60
80
100
120
10
−250
10
−200
10
−150
10
−100
10
−50
10
0
m
EAFDL / λ
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
20
40
60
80
100
120
10
−250
10
−200
10
−150
10
−100
10
−50
10
0
m
EAFDL / λ
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
20
40
60
80
100
120
10
−250
10
−200
10
−150
10
−100
10
−50
10
0
m
EAFDL / λ
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 10.
Normalized EAFDL vs. codeword length for seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; n = k = 120, λ/µ = 0.001 and deterministic rebuild
times.
the storage efﬁciency seff via (2). As discussed in Section II-E,
the analytical reliability results obtained are accurate when the
storage devices are highly reliable, that is, when the ratio λ/µ
of the mean rebuild time 1/µ to the mean time to failure
of a device 1/λ is very small. We proceed by considering
systems for which it holds that λ/µ = λ c/b = 0.001 and
the distribution of the rebuild time X is deterministic, that is,
E(Xm−l) = [E(X)]m−l.
The combined effect of the network rebuild bandwidth con-
straint and the storage efﬁciency on the normalized λ MTTDL
measure is obtained by (82) and shown in Figure 9 as a func-
tion of the codeword length. In particular, when the codeword
length is equal to the system size (m = k = n), the placement
becomes clustered and the normalized λ MTTDL measure is
obtained by (68). Four cases for the network rebuild bandwidth
constraint were considered: φ = 1 corresponds to the case
where there is no network rebuild bandwidth constraint given
that Nb ≥ k = 120 or, equivalently, Bmax ≥ k b = 120 b;
φ = 0.1, φ = 0.01, and φ = 0.001 correspond to the
cases where Nb = 0.1 k = 12, Nb = 0.01 k = 1.2, and
Nb = 0.001k = 0.12 or, equivalently, Bmax = 0.1 k b = 12 b,
Bmax = 0.01 k b = 1.2 b, and Bmax = 0.001 k b = 0.12 b,
respectively. The values for the storage efﬁciency are chosen
to be fractions of the form z/(z + 1), z = 1, . . . , 7, such that
the ﬁrst point of each of the corresponding curves is associated
with the single-parity (z, z + 1)-erasure code, and the second
point of each of the corresponding curves is associated with
the double-parity (2z, 2z + 2)-erasure code.
For all values of φ considered, we observe that MTTDL
increases as the storage efﬁciency seff decreases. This is
because, for a given m, decreasing seff implies decreasing l,
which in turn implies increasing the parity symbols m − l and
consequently improving the MTTDL. Furthermore, for a given
storage efﬁciency seff, MTTDL decreases by orders of mag-
nitude as the maximum permitted network rebuild bandwidth
decreases. We now proceed to identify the optimal codeword
length m∗ that maximizes MTTDL for a given bandwidth
constraint and storage efﬁciency. The optimal codeword length
is dictated by two opposing effects on reliability. On the one
hand, larger values of m imply that codewords can tolerate
more device failures, but on the other hand, they result in a
higher exposure degree to failure as each of the codewords
is spread across a larger number of devices. In Figure 9,
the optimal values m∗ are indicated by the circles, and the
corresponding codeword lengths are indicated by the vertical
dotted lines. By comparing Figures 9(a), (b), (c), and (d),
we deduce that as φ decreases, so do the optimal codeword
lengths. For example, in the case of seff = 3/4 and φ = 1,
the maximum MTTDL value of 4×1078 is obtained when
m = m∗ = 92. However, in the case of φ = 0.1, the maximum
MTTDL value of 6×1057 is obtained for m∗ = 84. The reason
for the reduction of the optimal codeword length is that ˜r
increases with increasing m for a given value of seff, which,
according to Remark 3, results in a lower reliability reduction
factor. Thus, the reliability reduction factor corresponding to
m = 92 is lower than the one corresponding to m = 84,
which in turn causes MTTDL for m = 92 to no longer be
optimal as it becomes lower than the one for m = 84. Note
that for m = 84 and seff = 3/4, it follows from (1) and
(3) that l = 63 and ˜r − 1 = 21. From (38), and given that
u ≤ ˜r − 1 = 21 ≪ k = 120, such that φ/(1 − u/k) ≈ φ, it
now follows that θ ≈ φ˜r−1 = 0.121 = 10−21, which implies
that the reliability is reduced by 21 orders of magnitude. In
the cases of φ = 0.01 and φ = 0.001, the maximum MTTDL
values of 6×1037 and 8×1019 are obtained for m∗ = 76 and
m∗ = 68, respectively.
The combined effect of the network rebuild bandwidth
constraint and the storage efﬁciency on the normalized
EAFDLdeclus/λ measure is obtained by (74) and (83), and

128
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
20
40
60
80
100
120
10
−25
10
−20
10
−15
10
−10
10
−5
10
0
m
E(H) / c
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8
0
20
40
60
80
100
120
10
−25
10
−20
10
−15
10
−10
10
−5
10
0
m
E(H) / c
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) seff = 1/5, 1/4, 1/3, and 1/2
Figure 11.
Normalized E(H) vs. codeword length; n = k = 120.
shown in Figure 10 as a function of the codeword length.
We observe that EAFDL increases as the storage efﬁciency
seff decreases. Furthermore, for a given storage efﬁciency seff,
EAFDL increases by orders of magnitude as the maximum
permitted network rebuild bandwidth decreases. In fact, for
φ = 0.01 and φ = 0.001, Figures 10(c) and (d) show that the
EAFDL can be greater than 1.
Remark 11: Although the fraction of data loss never ex-
ceeds 1, EAFDL can exceed 1 because it expresses the
annual fraction of data loss, which also takes into account
the frequency of data losses.
Similarly to the case of MTTDL, by comparing Figures
10(a), (b), (c), and (d), we observe that as φ decreases, so
do the optimal codeword lengths. For example, in the case of
seff = 3/4 and φ = 1, the minimum EAFDL value of 10−84
is obtained when m = m∗ = 88. However, in the case of
φ = 0.1, the minimum EAFDL value of 2×10−64 is obtained
for m∗ = 80, which implies that the reliability is reduced
by 20 orders of magnitude. In the cases of φ = 0.01 and
φ = 0.001, the minimum EAFDL values of 7×10−45 and
10−27 are obtained for m∗ = 72 and m∗ = 64, respectively.
By comparing Figures 9 and 10, we deduce that in general the
optimal codeword lengths m∗
MTTDL (for MTTDL) and m∗
EAFDL
(for EAFDL) are similar.
The effect of the storage efﬁciency on the normalized
E(H)/c measure is obtained by (75) and (84), and shown
in Figure 11 as a function of the codeword length. Note that
according to Remark 1, neither the network rebuild bandwidth
constraint nor the rebuild time distribution affects this metric.
We observe that E(H) increases as the storage efﬁciency seff
increases.
Remark 12: From (27), and recalling (1), (5) and the fact
that Vu is a fraction, we deduce that E(H)/c ≤ seff < 1,
which implies that E(H) < c.
Reducing Bmax or, equivalently, φ affects the optimal
codeword lengths for MTTDL and EAFDL as follows.
Proposition 14: For given n, k, and seff, and for the
MTTDL and EAFDL reliability metrics, the optimal codeword
length m∗ decreases with decreasing φ.
Proof: Consider two bandwidth constraint factors φ1 and
φ2 with φ1 > φ2. Let m∗
1 and m∗
2 be the corresponding optimal
codeword lengths for the MTTDL metric. We shall now show
that m∗
1 ≥ m∗
2.
As m∗
1 is the optimal codeword length for φ1, it holds
that MTTDL(φ1, m)
≤
MTTDL(φ1, m∗
1) for all m
≥
m∗
1. Also, from (1) and (3), it holds that ˜r
=
(1 −
seff) m + 1, which implies that as m increases, so does
˜r. From (29), it follows that θ(2)/θ(1)
=
Q˜r−1
u=1
bu(φ2)
bu(φ1),
which, owing to the fact that bu(φ2)
≤
bu(φ1)
∀ u,
decreases with increasing ˜r or, equivalently, m. Conse-
quently, θ(2)
m /θ(1)
m
≤ θ(2)
m∗
1/θ(1)
m∗
1 for all m ≥ m∗
1. Also,
it follows from (28) that MTTDL(φ2,m)/MTTDL(φ1,m)
=
θ(2)
m /θ(1)
m
for
all
values
of
m.
From
the
preced-
ing,
it
follows
that
MTTDL(φ2,m)/MTTDL(φ1,m)
=
θ(2)
m /θ(1)
m ≤ θ(2)
m∗
1/θ(1)
m∗
1 = MTTDL(φ2,m∗
1)/MTTDL(φ1,m∗
1)≤
MTTDL(φ2,m∗
1)/MTTDL(φ1,m) for all m ≥ m∗
1. Thus,
MTTDL(φ2,m) ≤ MTTDL(φ2,m∗
1) for all m ≥ m∗
1, which in
turn implies that m∗
2 ≤ m∗
1. The proof for EAFDL is similar
to that for MTTDL and is therefore omitted.
Figures 12 and 13 show the difference between the optimal
codeword lengths for MTTDL and EAFDL. They demonstrate
that the optimal codeword length for MTTDL is generally
greater than or equal to that for EAFDL, with the difference
being equal either to z + 1, the denominator of the storage
efﬁciency fraction, or to 0. This implies that the optimal
codeword lengths m∗
EAFDL for EAFDL are either equal to or
slightly smaller than and adjacent to the optimal codeword
lengths m∗
MTTDL for MTTDL. However, for small values of φ,
such as φ = 0.001, m∗
MTTDL can be smaller than m∗
EAFDL, as
observed in Figure 12(d). This occurs only for certain group
sizes that are smaller than 120, whereas for k ≥ 120, the
optimal codeword lengths follow the general trend discussed
above. For example, in the case of k = 120, φ = 0.001, and
seff = 1/2, Figure 9(d) shows that the maximum value of
MTTDL is achieved when the codeword length m is equal
to 74, which implies that m∗
MTTDL = 74. Also, Figure 10(d)
shows that the minimum value of EAFDL is achieved when
the codeword length m is equal to 72, which implies that
m∗
EAFDL = 72. The value of 72 is adjacent to 74 because
when seff = 1/2, m cannot be equal to 73. Consequently,
the difference of the optimal codeword lengths for EAFDL
and MTTDL is given by 74 – 72 = 2, indicated by a circle in
Figure 12(d). Similarly, for k = 120 and seff = 2/3, Figures
9(d) and 10(d) show that both the optimal MTTDL and the

129
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
20
40
60
80
100 120 140
−30
−20
−10
0
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
20
40
60
80
100 120 140
−30
−20
−10
0
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
20
40
60
80
100 120 140
−30
−20
−10
0
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
20
40
60
80
100 120 140
−30
−20
−10
0
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 12.
The difference between m∗
MTTDL and m∗
EAFDL vs. group size for various storage efﬁciencies; λ/µ = 0.001 and deterministic rebuild times.
0
20
40
60
80
100 120 140
0
2
4
6
8
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(a) φ = 1
0
20
40
60
80
100 120 140
0
2
4
6
8
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) φ = 0.1
0
20
40
60
80
100 120 140
0
2
4
6
8
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(c) φ = 0.01
0
20
40
60
80
100 120 140
0
2
4
6
8
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(d) φ = 0.001
Figure 13.
The difference between m∗
MTTDL and m∗
EAFDL vs. group size for seff = 1/5, 1/4, 1/3, and 1/2; λ/µ = 0.001 and deterministic rebuild times.
0
20
40
60
80
100
120
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
20
40
60
80
100
120
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
20
40
60
80
100
120
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
20
40
60
80
100
120
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 14.
r∗ for MTTDL vs. group size for seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; λ/µ = 0.001 and deterministic rebuild times.
0
20
40
60
80
100
120
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
20
40
60
80
100
120
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
20
40
60
80
100
120
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
20
40
60
80
100
120
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 15.
r∗ for EAFDL vs. group size for seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; λ/µ = 0.001 and deterministic rebuild times.
optimal EAFDL are obtained when the codeword length is
equal to 69, that is, m∗
MTTDL = m∗
EAFDL = 69. In this case, the
difference of the optimal codeword lengths for EAFDL and
MTTDL is equal to 0 , indicated by a circle in Figure 12(d).
To investigate the behavior of the optimal codeword length
m∗
k with increasing group size k, we proceed by considering
the normalized optimal codeword length r∗, namely, the ratio
of m∗
k to k:
r∗ ≜ m∗
k
k
.
(94)
The r∗ values for the MTTDL and EAFDL metrics are shown
in Figures 14 and 15, respectively, for various storage efﬁcien-
cies and network rebuild bandwidth constraints. According to
Proposition 14, for any storage efﬁciency seff and for any given
group size k, the optimal codeword lengths and, consequently,
the r∗ values decrease with decreasing φ. Also, when the
bandwidth constraint factor φ is small, the r∗ values ﬁrst
decrease and then gradually increase with increasing k. The
initial decrease is due to the fact that the optimal codeword
length m∗ remains ﬁxed and equal to z + 1, which is the
minimum possible codeword length for the storage efﬁciency

130
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 16.
r∗ for MTTDL vs. group size k → ∞, seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; λ/µ = 0.001 and deterministic rebuild times.
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 17.
r∗ for EAFDL vs. group size k → ∞, seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; λ/µ = 0.001 and deterministic rebuild times.
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(a) φ = 1
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) φ = 0.1
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(c) φ = 0.01
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(d) φ = 0.001
Figure 18.
r∗ for MTTDL vs. group size k → ∞, seff = 1/5, 1/4, 1/3, and 1/2; λ/µ = 0.001 and deterministic rebuild times.
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(a) φ = 1
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) φ = 0.1
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(c) φ = 0.01
0
200 400 600 800 1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(d) φ = 0.001
Figure 19.
r∗ for EAFDL vs. group size k → ∞, seff = 1/5, 1/4, 1/3, and 1/2; λ/µ = 0.001 and deterministic rebuild times.
fractions z/(z + 1), z = 1, . . . , 7. For example, in the case of
seff = 7/8 and φ = 0.001, m∗ = 8 for k ≤ 115 in the case of
MTTDL, or for k ≤ 80 in the case of EAFDL, as shown in
Figures 14(d) and 15(d), respectively.
The r∗ values for the MTTDL and EAFDL metrics for
various values of the storage efﬁciency seff and for large values
of k are shown in Figures 16, 17, 18, and 19. We observe that,
for a given storage efﬁciency and as k increases, the r∗ values
for MTTDL and EAFDL approach a common value, denoted
by r∗
∞ and indicated by a small bullet. The r∗
∞ value is given
by the following proposition.
Proposition 15: As k increases, the r∗ values for MTTDL
and EAFDL approach r∗
∞ that satisﬁes the following equation:
Q(h, r∗
∞) = 0 ,
(95)
where Q(h, x) is given by
Q(h, x) ≜ hx + log

[(1 − h)(1−h)2xh2]x(1 − hx)h(1−hx)
,
(96)
and h and x are given by (49) and (50), respectively.

131
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
100
200
300
400
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8
0
100
200
300
400
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Group Size (k)
r*
 
 
∞
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) seff = 1/5, 1/4, 1/3, and 1/2
Figure 20.
r∗ for E(H) vs. group size k → ∞.
TABLE II.
r∗
∞ VALUES FOR VARIOUS seff
seff
r∗
∞
MTTDL and EAFDL
E(H)
0
=
0
0.648419
0.5
10−4
=
0.0001
0.648404
0.499795
10−3
=
0.001
0.648265
0.498520
10−2
=
0.01
0.646985
0.490770
10−1
=
0.1
0.637940
0.456298
1/8
=
0.125
0.636043
0.450268
1/7
=
0.142857
0.634788
0.446383
1/6
=
0.166667
0.633224
0.441637
1/5
=
0.2
0.631212
0.435664
1/4
=
0.25
0.628500
0.427826
1/3
=
0.333333
0.624638
0.416889
1/2
=
0.5
0.618499
0.4
2/3
=
0.666667
0.613720
0.387097
3/4
=
0.75
0.611679
0.381625
4/5
=
0.8
0.610543
0.378586
5/6
=
0.833333
0.609818
0.376650
6/7
=
0.857143
0.609316
0.375307
7/8
=
0.875
0.608946
0.374322
1 − 10−1
=
0.9
0.608440
0.372971
1 − 10−2
=
0.99
0.606713
0.368368
1 − 10−3
=
0.999
0.606549
0.367928
1 − 10−4
=
0.9999
0.606532
0.367884
1
=
1
0.606531 = 1/√e
0.367879 = 1/e
Proof: It follows from (51) that, for large values of
k, k2 W(h, x)/2 is the dominating term. Thus, MTTDL is
maximized when W(h, x) is maximized. According to the
arguments in Appendix F of [25], it therefore holds that [25,
Equation (165)]
r∗
∞ = arg max
0<x≤1 W(h, x) .
(97)
Consequently, r∗
∞ is obtained as the unique root of the equation
Q(h, x) = 0, with respect to x, in the interval (0, 1], that is,
[25, Equation (176)]
Q(h, r∗
∞) = 0 , with r∗
∞ ∈ (0, 1] ,
(98)
where Q(h, x) is given by (96) [25, Equation (105)]. From
(55), it follows that the same rationale applies in the case of
EAFDL.
The r∗ values for the E(H) metric are shown in Figure 20
for various storage efﬁciencies and also for large group sizes.
Clearly, the optimal codeword lengths for E(H) are generally
 seff
 r∞*
0
0.2
0.4
0.6
0.8
1
0.6
0.61
0.62
0.63
0.64
0.65
(a) MTTDL and EAFDL
0
0.2
0.4
0.6
0.8
1
0.35
0.4
0.45
0.5
 seff
 r∞*
(b) E(H)
Figure 21.
r∗
∞ vs. seff.
signiﬁcantly shorter than those for MTTDL and EAFDL. We
observe that, for a given storage efﬁciency and as k increases,
the r∗ values for E(H) oscillate and approach a common
value, denoted by r∗
∞ and indicated by a small bullet.
Remark 13: The r∗
∞ values are not affected by the band-
width constraint factor φ and depend only on the storage
efﬁciency seff. This is because the resulting reliability reduction
factor θ, according to (47), is of the order O(k), whereas the
MTTDL and EAFDL reliability metrics, according to (51) and
(55), are of the order O(k2), which is higher. Note that this also
holds when the average network rebuild bandwidth is upper
limited by Bmax, such that the bandwidth constraint factor φ
is no longer constant, but, for large values of k and according

132
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
50
100
150
200
1
2
4
6
10
16
Group Size (k)
rEAFDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
50
100
150
200
1
2
4
6
10
16
Group Size (k)
rEAFDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
50
100
150
200
1
2
4
6
10
16
Group Size (k)
rEAFDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
50
100
150
200
1
2
4
6
10
16
Group Size (k)
rEAFDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 22.
The EAFDL efﬁciency ratio rEAFDL vs. group size; λ/µ = 0.001 and deterministic rebuild times.
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(a) φ = 1
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) φ = 0.1
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(c) φ = 0.01
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(d) φ = 0.001
Figure 23.
The EAFDL efﬁciency ratio rEAFDL vs. group size; λ/µ = 0.001 and deterministic rebuild times.
to (36), is inversely proportional to k. In this case, according
to (119), the resulting reliability reduction factor θ is of the
order O(k log(k)), which is still smaller than the order O(k2).
Also, according to Remark 1, the E(H) metric is not affected
by the bandwidth constraint factor, which implies that the r∗
∞
value for E(H) is given by [25, Equation (107)]
r∗
∞ =
1
h + (1 − h)− 1−h
h
,
(99)
with h given by (49).
The r∗
∞ values for the reliability metrics considered were
initially derived in [25] and are included in this paper in
Table II and Figure 21 for completeness. Note that the
r∗
∞ values for the MTTDL and EAFDL are in the interval
[e−1/2 = 0.606, 0.648], whereas those for E(H) are in the
interval [e−1 = 0.368, 0.5]. Also, the r∗
∞ values decrease with
increasing storage efﬁciency seff.
Next we examine the increase of the EAFDL metric if,
instead of the optimal codeword lengths m∗
EAFDL, we use the
codeword lengths m∗
MTTDL that optimize the MTTDL metric.
From the preceding, it generally follows that m∗
MTTDL is either
equal or adjacent to m∗
EAFDL, that is, m∗
MTTDL = m∗
EAFDL+z+1.
We deﬁne the EAFDL efﬁciency ratio rEAFDL as the ratio of
EAFDL(m∗
MTTDL) to EAFDL(m∗
EAFDL), that is,
rEAFDL ≜ EAFDL(m∗
MTTDL)
EAFDL(m∗
EAFDL) ,
(100)
where EAFDL(m) denotes the EAFDL corresponding to a
codeword length m.
The EAFDL efﬁciency ratios rEAFDL as a function of k
for various storage efﬁciencies and network rebuild bandwidth
constraints are shown in Figures 22 and 23. We observe that
for the storage efﬁciencies considered in Figure 22 and as
k increases, the EAFDL efﬁciency ratios follow a periodic
pattern and, for φ = 1, are always less than a factor of
4. Moreover, as φ decreases, the EAFDL efﬁciency ratios
tend to be less than a factor of 2, except in a few cases
where they are signiﬁcantly higher. Nevertheless, in all cases
they are less than a factor of 16, which implies that using
codewords of length m∗
MTTDL yields the maximum possible
(optimal) MTTDL and also an EAFDL that is either optimal
or of the same order. The maximum value is shown in Figure
22(d) obtained when φ = 0.001, seff = 7/8, and k = 115.
In this case, it holds that m∗
MTTDL = 8 and m∗
EAFDL = 40,
such that EAFDL(m∗
EAFDL)/λ = EAFDL(40)/λ = 0.032 and
EAFDL(m∗
MTTDL)/λ = EAFDL(8)/λ = 0.487, which in turn
yields an EAFDL efﬁciency ratio rEAFDL of 0.487 / 0.032 =
15.2. Also, as the storage efﬁciency decreases, the EAFDL
efﬁciency ratio rEAFDL increases, as shown in Figure 23. For
any given storage efﬁciency and bandwidth constraint factor,
rEAFDL follows a periodic pattern and for seff > 1/4 = 0.25,
rEAFDL tends to be less than a factor of 10. Consequently, using
codewords of length m∗
MTTDL yields an EAFDL that is of the
same order of magnitude as the optimal one.
Next, we consider a system where the distribution of
the rebuild time X is exponential, for which it holds that
E(Xm−l) = (m − l)! [E(X)]m−l. The combined effect of
the network rebuild bandwidth constraint, the storage efﬁ-
ciency, and the codeword length on the reliability measures
considered is similar to the case of deterministic rebuild
times. Furthermore, similar to the case of deterministic rebuild
times, the optimal codeword lengths m∗
EAFDL for EAFDL are
generally either equal to or slightly shorter than and adjacent
to the optimal codeword lengths m∗
MTTDL for MTTDL, as
demonstrated in Figures 24 and 25.
The r∗ values for the MTTDL and EAFDL metrics are
shown in Figures 26 and 27, respectively, for various stor-
age efﬁciencies and network rebuild bandwidth constraints.
According to Remark 13 and Remark 13 of Appendix F
of [25], as k increases, and for any storage efﬁciency and
bandwidth constraint factor, the r∗ values for MTTDL and

133
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
50
100
150
200
250
300
−50
−40
−30
−20
−10
0
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
50
100
150
200
250
300
−50
−40
−30
−20
−10
0
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
50
100
150
200
250
300
−50
−40
−30
−20
−10
0
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
50
100
150
200
250
300
−50
−40
−30
−20
−10
0
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 24.
The difference between m∗
MTTDL and m∗
EAFDL vs. group size for various storage efﬁciencies; λ/µ = 0.001 and exponential rebuild times.
0
50
100
150
200
250
300
−2
0
2
4
6
8
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(a) φ = 1
0
50
100
150
200
250
300
−2
0
2
4
6
8
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) φ = 0.1
0
50
100
150
200
250
300
−2
0
2
4
6
8
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(c) φ = 0.01
0
50
100
150
200
250
300
−2
0
2
4
6
8
10
Group Size (k)
m*
MTTDL − m*
EAFDL 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(d) φ = 0.001
Figure 25.
The difference between m∗
MTTDL and m∗
EAFDL vs. group size for seff = 1/5, 1/4, 1/3, and 1/2; λ/µ = 0.001 and exponential rebuild times.
0
50
100
150
200
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
50
100
150
200
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
50
100
150
200
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
50
100
150
200
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 26.
r∗ for MTTDL vs. group size for seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; λ/µ = 0.001 and exponential rebuild times.
0
50
100
150
200
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
50
100
150
200
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
50
100
150
200
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
50
100
150
200
0
0.2
0.4
0.6
0.8
1
Group Size (k)
r*
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 27.
r∗ for EAFDL vs. group size for seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; λ/µ = 0.001 and exponential rebuild times.
EAFDL approach a common value that is the same as the r∗
∞
value obtained in the case of deterministic rebuild times, which
only depends on seff and is listed in Table II.
The EAFDL efﬁciency ratios rEAFDL are shown in Figures
28 and 29 as a function of k for various storage efﬁciencies
and network rebuild bandwidth constraints. We observe that
as k increases, the EAFDL efﬁciency ratios follow a periodic
pattern, as in the case of deterministic rebuild times. In
particular, for the storage efﬁciencies considered in Figure 28,
the EAFDL efﬁciency ratios tend to be less than a factor
of 3, except in a few cases where they are signiﬁcantly
higher. The maximum value is shown in Figure 28(d) ob-
tained when φ = 0.001, seff = 7/8, and k = 179. In
this case, it holds that m∗
MTTDL = 8 and m∗
EAFDL = 56,
such that EAFDL(m∗
EAFDL)/λ = EAFDL(56)/λ = 0.00167
and EAFDL(m∗
MTTDL)/λ
=
EAFDL(8)/λ
=
0.31285,
which in turn yields an EAFDL efﬁciency ratio rEAFDL of
0.31285 / 0.00167 = 187. Also, as the storage efﬁciency de-
creases, the EAFDL efﬁciency ratio rEAFDL increases, as shown
in Figure 29. Nevertheless, for seff > 1/4 = 0.25, rEAFDL tends
to be less than a factor of 10. Consequently, using codewords
of length m∗
MTTDL yields an EAFDL that is of the same order

134
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 28.
The EAFDL efﬁciency ratio rEAFDL vs. group size for seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; λ/µ = 0.001 and exponential rebuild times.
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(a) φ = 1
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) φ = 0.1
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(c) φ = 0.01
0
200
400
600
800
1000
10
0
10
1
10
2
Group Size (k)
rEAFDL
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(d) φ = 0.001
Figure 29.
The EAFDL efﬁciency ratio rEAFDL vs. group size for seff = 1/5, 1/4, 1/3, and 1/2; λ/µ = 0.001 and exponential rebuild times.
of magnitude as the optimal one.
Figures 30 to 33 show the ratio of the optimal codeword
length m∗
exp for the exponential distribution to the optimal
codeword length m∗
det for the deterministic distribution for
various storage efﬁciencies and network rebuild bandwidth
constraints. We observe that this ratio never exceeds 1 and
approaches 1 as k increases. This implies that, regardless of
the rebuild bandwidth constraint, the optimal codeword length
for the exponential distribution is generally smaller than the
optimal codeword length for the deterministic distribution.
This can be intuitively explained as follows. As previously
mentioned, higher values of m result in a greater exposure
degree to failure as each of the codewords is spread across
a larger number of devices. The variation of exponentially
distributed rebuild times results in increased vulnerability win-
dows and therefore worse reliability. To reduce the exposure
degree to failures, codewords should be spread across a shorter
number of devices, which implies a shorter optimal codeword
length. Also, lower values of the bandwidth constraint factor
φ result in increased vulnerability windows, which in turn
result in shorter optimal codeword lengths. In particular, we
observe that the ratio of the optimal codeword lengths gener-
ally decreases with decreasing bandwidth constraint factor φ.
However, when the optimal codeword lengths m∗
exp and m∗
det
reach the value of the minimum codeword length, then the
ratio becomes equal to 1, as shown in Figures 30(d) and 31(d)
for the case of k = 50 and for seff = 5/6, 6/7 and 7/8.
VII.
DISCUSSION
The symmetric and declustered data placement schemes
reduce rebuild times by recovering data in parallel from the
storage devices. In particular, for large-scale data storage
systems, the rebuild times become extremely short. The model
presented copes with this issue by considering the realistic case
of network rebuild bandwidth constraints, which effectively
prolong the duration of rebuild times.
Although erasure coding schemes provide high data relia-
bility and storage efﬁciency, the rebuild process involves I/O
operations and network transfers that increase the consumption
of device and network bandwidth. In particular, large MDS
codes pose a challenge to the usage of network resources given
that a lost symbol is recovered via an (m, l) erasure code by
transferring a large number of l symbols from l surviving
devices over the network. Although this may not be critical
in purely archival tiers, recovering large amounts of data in
active tiers results in additional trafﬁc over increased time
periods, which has an impact on the latency of the foreground
workload and therefore affects system performance. This issue,
also known as the repair bandwidth problem, has prompted the
development of alternative erasure coding schemes that aim to
reduce the amount of data transferred over the storage network
during reconstruction (see [37][38] and references therein).
They result in smaller amounts of data being read from the
surviving devices and therefore in shorter rebuild times and
higher reliabilities. However, in the case of functional repairs,
a lost user-data symbol is replaced by an appropriate parity
symbol, which now implies that reading such a user-data
symbol can no longer be performed directly, but indirectly
by accessing l symbols. Although this may be practical for
archival tiers, it negatively affects the performance of the
workloads encountered in active tiers. Therefore, emphasis is
placed on exact repairs that preserve user data and maintain the
erasure code in systematic form. The effect of these methods
on system reliability is beyond the scope of this article and is
a subject of further investigation.
The analytical ﬁndings of this work are relevant for the
case of large erasure-coded data centers where a signiﬁcant
percentage of nodes fail each day [40]. Subsequently, the data
recovery operations generate an excessive rebuild trafﬁc that
competes with the huge amount of trafﬁc generated by the
frequent access of a large number of storage devices [36]. To
ensure a desired performance level, the network bandwidth
devoted to the repair trafﬁc must be contained. Furthermore,

135
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 30.
Ratio m∗
exp to m∗
det for MTTDL vs. group size for seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; λ/µ = 0.001.
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(a) φ = 1
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(b) φ = 0.1
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(c) φ = 0.01
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/2
seﬀ = 2/3
seﬀ = 3/4
seﬀ = 4/5
seﬀ = 5/6
seﬀ = 6/7
seﬀ = 7/8
(d) φ = 0.001
Figure 31.
Ratio m∗
exp to m∗
det for EAFDL vs. group size for seff = 1/2, 2/3, 3/4, 4/5, 5/6, 6/7, and 7/8; λ/µ = 0.001.
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(a) φ = 1
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) φ = 0.1
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(c) φ = 0.01
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(d) φ = 0.001
Figure 32.
Ratio m∗
exp to m∗
det for MTTDL vs. group size for seff = 1/5, 1/4, 1/3, and 1/2; λ/µ = 0.001.
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(a) φ = 1
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(b) φ = 0.1
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(c) φ = 0.01
0
200
400
600
800
1000
0
0.2
0.4
0.6
0.8
1
Group Size (k)
m*
exp / m*
det 
 
 
seﬀ = 1/5
seﬀ = 1/4
seﬀ = 1/3
seﬀ = 1/2
(d) φ = 0.001
Figure 33.
Ratio m∗
exp to m∗
det for EAFDL vs. group size for seff = 1/5, 1/4, 1/3, and 1/2; λ/µ = 0.001.
for performance reasons, the codeword length should be kept
relatively short, otherwise a large number of parity updates
will interfere with the normal user trafﬁc, resulting in a
performance degradation. More speciﬁcally, Google’s GFS as
well as QFS use an RS(9,6) code that achieves a storage
efﬁciency of 66% [32, 41], Facebook uses an RS(14,10) code
that achieves a storage efﬁciency of 71% [34], and Windows
Azure uses an LRC(16,10) code, which is not an MDS code,
that achieves a storage efﬁciency of 75% [33]. Note that these
systems initially used a three-way replication by storing three
copies of all data, which achieved a storage efﬁciency of 33%.
Consequently, to keep the storage overhead low, the erasure-
code parameter values should be chosen such that the storage
efﬁciency is in the range from 0.66 to 0.75.
VIII.
CONCLUSIONS
Data storage systems use erasure coding schemes to recover
lost data and enhance system reliability. However, network
rebuild bandwidth constraints may degrade reliability. A gen-
eral methodology was applied for deriving the Mean Time to
Data Loss (MTTDL) and the Expected Annual Fraction of
Data Loss (EAFDL) reliability metrics analytically. Closed-
form expressions capturing the effect of a network rebuild

136
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
bandwidth constraint were obtained for the symmetric, clus-
tered and declustered data placement schemes. We established
that the reliability of storage systems is adversely affected by
the network rebuild bandwidth constraints. The declustered
placement scheme was found to offer superior reliability in
terms of both metrics. We subsequently conducted an investi-
gation of the reliability achieved by this scheme under various
codeword conﬁgurations. The results demonstrated that both
metrics are optimized by similar codeword lengths. For large
storage systems that use a declustered placement scheme, the
optimized codeword lengths are about 60% of the storage
system size, independently of the network rebuild bandwidth
constraints. The analytical reliability expressions derived can
be used to identify redundancy and recovery schemes as well as
data placement conﬁgurations that can achieve high reliability.
The results can also be used to adapt the data placement
schemes when the available network rebuild bandwidth or the
number of devices in the system changes so that the system
maintains a high level of reliability.
Extending the methodology developed to derive the relia-
bility of erasure coded systems in the presence of unrecover-
able latent errors is a subject of further investigation. Moreover,
owing to the parallelism of the rebuild process, the model
considered here yields very short rebuild times for large system
sizes. Taking into account the fact that the rebuild times cannot
be shorter than the actual failure detection times requires a
more sophisticated modeling effort, which is also part of future
work.
APPENDIX A
OPTIMAL ˆks FOR MTTDLsym
Proof of Proposition 1.
As mentioned in Section II-B, the system comprises n/k
disjoint groups of k devices. We ﬁrst obtain the optimal value
for k by relaxing the constraint that n/k be an integer, that
is, by considering all the integer values for k in the interval
Ik = [m + 1, n]. We subsequently impose the constraint and
obtain the optimal value ˆks. Note that the constraint that n/k
be an integer translates to k ∈ Ik ∩ Dn, where Dn is the set
of all integers that divide n, as deﬁned in (44). Also, km, as
deﬁned in (45), represents the smallest integer in the interval
Ik = [m + 1, n] that divides n. Thus, km ∈ Dn, n ∈ Ik,
n ∈ Dn, and therefore n ∈ Ik ∩ Dn.
Considering l, m, and n to be ﬁxed, it follows from (39)
that MTTDLsym
k
is approximately proportional to the function
Ak given by
Ak ≜
m−l
Y
u=1
(k − u)m−l−u
m−l
Y
u=1
min

φ
1 − u
k
, 1

.
(101)
Consequently, the value of k in the interval [m + 1, n] that
maximizes MTTDLsym
k
also maximizes Ak. Depending on the
values of m and l, we consider the following two cases:
Case 1: m − l = 1. From (101) it follows that Ak =
min

φ
1− 1
k , 1

≤ 1, which is decreasing in k.
Depending on the value of φ, the following three subcases
are considered:
(a) φ ≥ 1 − 1
n ⇔ n ≤
1
1−φ. In this case, Ak achieves its
maximum value of 1 for all k for which
φ
1− 1
k ≥ 1 ⇔ k ≤
1
1−φ,
that is, for all k that do not exceed the value of
1
1−φ. Thus,
Ak is maximized for all k in the interval Ik = [m + 1, n].
Subsequently, imposing the constraint that n/k be an integer
translates to k ∈ Ia = Ik ∩ Dn. Note that Ia is not empty
because n ∈ I and n ∈ Dn. Furthermore, km ∈ Ia.
(b) 1 − 1
n > φ ≥ 1 −
1
km
⇔
km ≤
1
1−φ < n. In this
case, Ak achieves its maximum value of 1 for all k for which
φ
1− 1
k ≥ 1 ⇔ k ≤
1
1−φ, that is, for all k that do not exceed the
value of
1
1−φ. Thus, Ak is maximized for all k in the interval
I = [m + 1,
1
1−φ], which also includes km. Subsequently,
imposing the constraint that n/k be an integer translates to
k ∈ Ib = I ∩ Dn. Note that Ib is not empty because km ∈ I
and km ∈ Dn, and therefore km ∈ Ib.
(c) 1 −
1
km > φ ≥ 1 −
1
m+1 ⇔ m + 1 ≤
1
1−φ < km. In
this case, Ak achieves its maximum value of 1 for all k for
which
φ
1− 1
k ≥ 1 ⇔ k ≤
1
1−φ, that is, for all k that do not
exceed the value of
1
1−φ. Thus, Ak is maximized for all k in
the interval I = [m + 1,
1
1−φ], which does not include km.
Consequently, none of the values in the interval I divide n.
Subsequently, imposing the constraint that n/k be an integer
translates to considering values of k that exceed km, in which
case Ak =
φ
1− 1
k < 1. As Ak is decreasing in k, we deduce
that Ak is maximized when k = km.
(d) φ < 1 −
1
m+1
⇔
m + 1 >
1
1−φ. In this case, it
holds that
φ
1− 1
n < · · · <
φ
1− 1
k < · · · <
φ
1−
1
m+1 < 1 , for
m + 1 < k < n. Therefore, Ak =
φ
1− 1
k , ∀ k ∈ [m + 1, n], and
Ak is maximized when k = m + 1. Subsequently, imposing
the constraint that n/k be an integer translates to k = km.
Case 2: m − l ≥ 2. It holds that k > m = (m − l) + l ≥
m−l +1 and, therefore, k ≥ m−l +2. From (101) it follows
that
Ak =
"m−l−1
Y
u=1
(k − u)m−l−1−u min(k φ, k − u)
#
min
 
φ
1 − m−l
k
, 1
!
. (102)
Depending on the value of φ, the following two subcases
are considered:
(a) φ ≥ 1 − m−l
k
⇔ k ≤ m−l
1−φ . In this case, it holds that
min

φ
1− m−l
k , 1

= 1, and
Ak =
m−l−1
Y
u=1
(k − u)m−l−1−u min(k φ, k − u) .
(103)
Note that each of the terms in the product is increasing in k,
which implies that Ak is also increasing in k, for k ≤ kf,
where kf ≜ ⌊ m−l
1−φ ⌋.
(b) φ ≤ 1 − m−l
k
⇔
k ≥
m−l
1−φ . In this case, it holds
that min

φ
1− m−l
k , 1

=
φ
1− m−l
k . Also, for u < m − l, it holds

137
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
that k − u > k − (m − l) = k (1 − m−l
k ) ≥ k φ, such that
min(k φ, k − u) = k φ. From (102), it now follows that
Ak =
"m−l−1
Y
u=1
(k − u)m−l−1−u k φ
#
φ
1 − m−l
k
= φm−l
"m−l−1
Y
u=1
(k − u)m−l−1−u
#
k m−l
k − (m − l) . (104)
We proceed by recognizing that the last term in (104) is
increasing in k, for k ≥ m−l+2. This is a direct consequence
of the fact that the function f(x) =
xm−l
x−(m−l) is increasing in
x ∈ [ (m−l)2
m−l−1, ∞], and the fact that m − l + 2 ≥ (m−l)2
m−l−1 for
m − l ≥ 2. Moreover, each of the terms in the product is
increasing in k, which implies that Ak is also increasing in k,
for k ≥ kc, where kc ≜ ⌈ m−l
1−φ ⌉.
To conclude that Ak is increasing in the entire range of
k, it sufﬁces to show that Akf ≤ Akc. Clearly, this condition
holds when kf = kc, that is, when m−l
1−φ is an integer. If m−l
1−φ
is not an integer, then it holds that
kf < m − l
1 − φ < kc = kf + 1 ,
(105)
which in turn implies that
1 − m − l
kf
< φ < φc ≜ 1 − m − l
kc
.
(106)
Furthermore, using the relation kf ≥ m − l + 2 > m − l − 1,
we deduce that m−l−1
kf
< m−l
kf +1 = m−l
kc
= 1 − φc , that is,
φc < 1 − m − l − 1
kf
.
(107)
For u ≤ m − l − 1, and combining (106) and (107) yields
kf −u ≥ kf −(m−l −1) = kf (1− m−l−1
kf
) > kf φc > kf φ,
such that min(kf φ, kf −u) = kf φ. Thus, (103) can be written
as follows:
Akf =
m−l−1
Y
u=1
[(kf − u)m−l−1−ukf φ]
= φm−l−1
"m−l−1
Y
u=1
(kf − u)m−l−1−u
#
kf
m−l−1
(106)
< φm−l
"m−l−1
Y
u=1
(kf − u)m−l−1−u
#
kf
m−l
kf − (m − l) .
(108)
Also, from (104) we get
Akc = φm−l
"m−l−1
Y
u=1
(kc − u)m−l−1−u
#
kc
m−l
kc − (m − l) .
(109)
From (108) and (109), and given that kf < kc, it follows that
Akf < Akc.
From the above, we conclude that when m − l ≥ 2, Ak is
increasing in k and, therefore, is maximized when k = n.
APPENDIX B
APPROXIMATE DERIVATION OF θ sym
Proof of Lemma 1.
From (3) and (38), and using (49) and (50), it follows that
log (θ sym) =
hxk
X
u=1
log

min

φ
1 − u
k
, 1

.
(110)
Given that
φ
1− u
k ≤ 1 ⇔ u ≤ (1 − φ)k, (110) yields
log (θ sym) =
bφk
X
u=1
log

φ
1 − u
k

=
bφk
X
u=1
log(φ) −
bφk
X
u=1
log

1 − u
k

= bφ k log(φ) −
bφk
X
u=1
log

1 − u
k

,
(111)
where bφ = min(1−φ, hx) as deﬁned in (48). For large values
of k, the preceding summation can be approximated using
Lemma 1 of [25], which states that for small values of ǫ, that
is, when ǫ approaches 0, and for any function f(y), it holds
that [25, Equation (122)]
ǫ
α/ǫ
X
j=1
f(jǫ) ≈
Z
α+ ǫ
2
ǫ
2
f(y) dy ,
∀ α ∈ R .
(112)
For α = bφ and f(y) = log(1 − y), (112) yields
ǫ
bφ/ǫ
X
j=1
log(1 − jǫ) ≈
Z
bφ+ ǫ
2
ǫ
2
log(1 − y) dy .
(113)
Also, from Equations (128), (129), and (133) of [25], it follows
that
Z
bφ+ ǫ
2
ǫ
2
log(1 − y) dy = log
 
(1 − ǫ
2)1− ǫ
2
(1 − bφ − ǫ
2)1−bφ− ǫ
2
!
− bφ
≈ log
 
1
(1 − bφ)1−bφ
!
− bφ + log(1 − bφ)
2
ǫ −
bφ
8(1 − bφ)
ǫ2 .
(114)
Substituting (114) into (113), and setting ǫ = 1/k, yields
bφk
X
j=1
log

1 − j
k

≈ −
h
log

(1 − bφ)1−bφ
+ bφ
i
k
+ 1
2 log(1 − bφ) −
bφ
8(1 − bφ) k
.
(115)
Note that for large values of k, the last term of the right-hand
side of (115) is negligible and therefore can be ignored. Sub-
stituting (115) into (111) yields the following approximation:
log

138
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
which yields (47).
Remark 14: When the average network rebuild bandwidth
is upper limited by Bmax, the bandwidth constraint factor φ is
no longer constant, but, for large values of k and according to
(36), is given by
φ = Bmax
k b
(9)
= Nb
k ,
(117)
which in turn implies that φ tends to 0 as k increases.
Consequently, for large values of k, (48) yields
bφ = hx .
(118)
Substituting (117) and (118) into (116) yields
log

139
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
by the clustered placement scheme (rsym,MTTDL
clus,MTTDL < 1) only in
the following cases:
1) m = 3, n = 3 j with 2 ≤ j ≤ 11, and φ < G = 2√n−2
n
,
2) m = 4, n = 8,
and φ < G = 3
√
3/8 = 0.649,
3) m = 4, n = 12, and φ < G =
√
5/4 = 0.559, and
4) m = 5, n = 10, and φ < G = 4
√
2/(5
√
3) = 0.653.
In these cases, ˆk = m, whereas in all other cases, the MTTDL
is maximized by the declustered placement scheme (ˆk = n).
Case 3: m−l = 3. This implies that n/2 ≥ m = l+3 ≥ 4.
Thus, n − 3
>
m − 2 or (n − 3)2/(m − 2)2
>
1.
Also, for m ≥ 4, it holds that
(m−3)(2m−1)
(m−1)(m−2)
> 1. Con-
sequently, 1 <
(n−3)2(m−3)(2m−1)
(m−2)2(m−1)(m−2) ≤
(n−3)2(m−3)(n−1)
(m−1)(m−2)3
=
(m−3)(n−1)n3
(n−3)(m−1)(m−2)3

140
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
It follows from (89) that
l
l+1 ≥
1
2 and
n
m ≥ 2. Conse-
quently, the term in brackets is greater than or equal to 1.
Next, we will show that the product is greater than 1. For
m − l ≥ 4, the product can be written as follows:
m−l
Y
u=1
 n − u
m − u
m−l−u−1
=
m−l−4
Y
u=1
 n − u
m − u
m−l−u−1
m−l
Y
u=m−l−3
 n − u
m − u
m−l−u−1
.
(141)
Clearly, for n > m, the ﬁrst product is greater than or equal
to 1. The second product is greater than 1 because it can be
written as follows:
m−l
Y
u=m−l−3
 n − u
m − u
m−l−u−1
=
 n − (m − l − 3)
m − (m − l − 3)
2
· n − (m − l − 2)
m − (m − l − 2) · m − (m − l)
n − (m − l)
= 1 + (n − m)[l(n − m + l)(n − m + 2l + 8) − 18]
(l + 3)(l + 2)(n − m + l)
(89)(137)
≥
1 + (n − m)[6 (6 + l + 8) − 18]
(l + 3)(l + 2)(n − m + l)
> 1 .
(142)
Inequality (139) is a direct consequence of (140), (141), and
(142).
We deduce from (139) that
RM < l
m = 1 − m − l
m
< 1 − m − l
n
< · · · < 1 − 1
n . (143)
For m−l ≥ 4, according to (43), it holds that MTTDLsym
ˆ
ks =
MTTDLsym
n
and, subsequently, (90) yields
rsym,MTTDL
clus,MTTDL ≈

1
l + 1
m−l (m − 1)!
(l − 1)!
,
min
m φ
l
, 1
m−l
m−l
Y
u=1
 n − u
m − u
m−l−u
min

φ
1 − u
n
, 1

.
(144)
Depending on the value of φ, the following two subcases
are considered:
(a) φ > RM. In this case, it holds that
RM
1− u
n <
φ
1− u
n , for
u = 1, . . . , m−l. Also, it holds from (143) that
RM
1− u
n < 1, for
u = 1, . . . , m − l. Consequently, min

φ
1− u
n , 1

>
RM
1− u
n , for
u = 1, . . . , m − l. Moreover, from (144), and using the fact
that min

φ
1− m−l
m , 1

≤ 1, it follows that
rsym,MTTDL
clus,MTTDL >

1
l + 1
m−l (m − 1)!
(l − 1)!
m−l
Y
u=1
 n − u
m − u
m−l−u
RM
1 − u
n
(138)
=
1 .
(145)
(b) φ ≤ RM. In this case, it follows from (143) that
φ
1− 1
n <
· · · <
φ
1− m−l
n
<
φ
1− m−l
m
=
m φ
l
<
φ
RM ≤ 1. Subsequently,
(144) yields
rsym,MTTDL
clus,MTTDL ≈

1
l + 1
m−l (m − 1)!
(l − 1)!
,m φ
l
m−l
m−l
Y
u=1
 n − u
m − u
m−l−u 
φ
1 − u
n

=

l n
(l + 1) m
m−l
m−l
Y
u=1
 n − u
m − u
m−l−u−1
(138)
=

l
m RM
m−l
(139)
>
1 .
(146)
From the results obtained in the preceding two subcases,
we conclude that, when m − l ≥ 4, MTTDL is maximized by
the declustered placement scheme.
APPENDIX D
OPTIMAL k FOR EAFDL
Proof of Proposition 11.
Depending on the values of m and l, we consider the
following two cases:
Case 1: m − l = 1. In this case, (92) yields
rdeclus,EAFDL
clus,EAFDL
≈
m
n − 1 ·
min

φ
1− 1
m , 1

min

φ
1− 1
n , 1
 .
(147)
It follows from (89) that l+1
l
≤ 2 and m
n ≤ 1
2, with the
equalities holding only when l = 1, m = 2, and n = 4.
Consequently,
(l + 1) m
l n
=
m2
(m − 1) n ≤ 1 ,
(148)
with the equality holding only when l+1 = m = 2 and n = 4.
We deduce from (148) that
m
n ≤ m − 1
m
= 1 − 1
m < 1 − 1
n .
(149)
Depending on the value of φ, the following two subcases
are considered:
(a) φ >
m
n . In this case, it holds that
m
n
1− 1
n
<
φ
1− 1
n .
Also, it holds from (149) that
m
n
1− 1
n
< 1. Consequently,
min

φ
1− 1
n , 1

>
m
n
1− 1
n . Moreover, from (147), and using the
fact that min

φ
1− 1
m , 1

≤ 1, it follows that
rdeclus,EAFDL
clus,EAFDL
<
m
n − 1 ·
1
m
n
1− 1
n
= 1 .
(150)
(b) φ ≤ m
n . In this case, it follows from (149) that
φ
1− 1
n <
φ
1− 1
m ≤
φ
m
n ≤ 1. Subsequently, (147) yields

141
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
rdeclus,EAFDL
clus,EAFDL
≈
m
n − 1 ·
φ
1− 1
m
φ
1− 1
n
=
m2
(m − 1) n ≤ 1 ,
(151)
with the equality holding only when l = 1, m = 2, and n = 4.
In this case, the clustered and declustered placements yield the
same reliability.
From the results obtained in the preceding two subcases,
we conclude that, when m − l = 1, EAFDL is minimized by
the declustered placement scheme.
Case 2: m − l ≥ 2. Let us deﬁne
RE ≜ RE(l, m, n) = l + 1
n
"m−l
Y
u=1
m − u
n − u
m−l−u#
1
m−l
.
(152)
Note that the following inequality holds
 
RE
1 − m−l
m
!m−l
=
m RE
l
m−l
(152)
=
(l + 1) m
l n
m−l m−l
Y
u=1
m − u
n − u
m−l−u
< 1 ,
(153)
because it holds that (l+1) m/(l n) ≤ 1, as shown in Appendix
C, and (m − u)/(n − u) < 1, for u = 1, . . . , m − l − 1, owing
to (89).
We deduce from (153) that
RE < l
m = 1 − m − l
m
< 1 − m − l
n
< · · · < 1 − 1
n . (154)
Depending on the value of φ, the following two subcases
are considered:
(a) φ > RE. In this case, it holds that
RE
1− u
n <
φ
1− u
n , for
u = 1, . . . , m − l. Also, it holds from (154) that
RE
1− u
n < 1 for
u = 1, . . . , m − l. Consequently, min

φ
1− u
n , 1

>
RE
1− u
n , for
u = 1, . . . , m−l. Moreover, from (92), and using the fact that
min

φ
1− m−l
m , 1

≤ 1, it follows that
rdeclus,EAFDL
clus,EAFDL
< (l + 1)m−l (l − 1)!
(m − 1)!
m−l
Y
u=1
m − u
n − u
m−l+1−u  RE
1 − u
n
(152)
=
1 .
(155)
(b) φ ≤ RE. It follows from (154) that
φ
1− 1
n < · · · <
φ
1− m−l
n
<
φ
1− m−l
m
=
m φ
l
≤
φ
RE ≤ 1. Subsequently, (92)
yields
rdeclus,EAFDL
clus,EAFDL
≈ (l + 1)m−l (l − 1)!
(m − 1)!
m φ
l
m−l
m−l
Y
u=1
m − u
n − u
m−l+1−u 
φ
1 − u
n

=
(l + 1) m
l n
m−l
m−l
Y
u=1
m − u
n − u
m−l−u
(152)
=
m RE
l
m−l
(153)
<
1 .
(156)
From the results obtained in the preceding two subcases,
we conclude that, when m − l ≥ 2, EAFDL is minimized by
the declustered placement scheme.
REFERENCES
[1]
I. Iliadis, “Reliability of erasure coded systems under rebuild bandwidth
constraints,” in Proceedings of the 11th International Conference on
Communication Theory, Reliability, and Quality of Service (CTRQ),
Apr. 2018, pp. 1–10.
[2]
D. A. Patterson, G. Gibson, and R. H. Katz, “A case for redundant arrays
of inexpensive disks (RAID),” in Proceedings of the ACM SIGMOD
International Conference on Management of Data, Jun. 1988, pp. 109–
116.
[3]
P. M. Chen, E. K. Lee, G. A. Gibson, R. H. Katz, and D. A. Patterson,
“RAID: High-performance, reliable secondary storage,” ACM Comput.
Surv., vol. 26, no. 2, Jun. 1994, pp. 145–185.
[4]
M. Malhotra and K. S. Trivedi, “Reliability analysis of redundant arrays
of inexpensive disks,” J. Parallel Distrib. Comput., vol. 17, Jan. 1993,
pp. 146–151.
[5]
W. A. Burkhard and J. Menon, “Disk array storage system reliability,”
in Proceedings of the 23rd International Symposium on Fault-Tolerant
Computing, Jun. 1993, pp. 432–441.
[6]
K. S. Trivedi, Probabilistic and Statistics with Reliability, Queueing and
Computer Science Applications, 2nd ed.
New York: Wiley, 2002.
[7]
Q. Xin, E. L. Miller, T. J. E. Schwarz, D. D. E. Long, S. A. Brandt, and
W. Litwin, “Reliability mechanisms for very large storage systems,” in
Proceedings of the 20th IEEE/11th NASA Goddard Conference on Mass
Storage Systems and Technologies (MSST), Apr. 2003, pp. 146–156.
[8]
T. J. E. Schwarz, Q. Xin, E. L. Miller, D. D. E. Long, A. Hospodor,
and S. Ng, “Disk scrubbing in large archival storage systems,” in
Proceedings of the 12th Annual IEEE/ACM International Symposium
on Modeling, Analysis, and Simulation of Computer and Telecommu-
nication Systems (MASCOTS), Oct. 2004, pp. 409–418.
[9]
Q. Lian, W. Chen, and Z. Zhang, “On the impact of replica placement to
the reliability of distributed brick storage systems,” in Proc. 25th IEEE
International Conference on Distributed Computing Systems (ICDCS),
Jun. 2005, pp. 187–196.
[10]
S. Ramabhadran and J. Pasquale, “Analysis of long-running replicated
systems,” in Proc. 25th IEEE International Conference on Computer
Communications (INFOCOM), Apr. 2006, pp. 1–9.
[11]
B. Eckart, X. Chen, X. He, and S. L. Scott, “Failure prediction models
for proactive fault tolerance within storage systems,” in Proceedings
of the 16th Annual IEEE International Symposium on Modeling,
Analysis, and Simulation of Computer and Telecommunication Systems
(MASCOTS), Sep. 2008, pp. 1–8.
[12]
A. Thomasian and M. Blaum, “Higher reliability redundant disk arrays:
Organization, operation, and coding,” ACM Trans. Storage, vol. 5, no. 3,
Nov. 2009, pp. 1–59.
[13]
K. Rao, J. L. Hafner, and R. A. Golding, “Reliability for networked
storage nodes,” IEEE Trans. Dependable Secure Comput., vol. 8, no. 3,
May 2011, pp. 404–418.

142
International Journal on Advances in Networks and Services, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/networks_and_services/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[14]
I. Iliadis, R. Haas, X.-Y. Hu, and E. Eleftheriou, “Disk scrubbing versus
intradisk redundancy for RAID storage systems,” ACM Trans. Storage,
vol. 7, no. 2, Jul. 2011, pp. 1–42.
[15]
V. Venkatesan, I. Iliadis, C. Fragouli, and R. Urbanke, “Reliability of
clustered vs. declustered replica placement in data storage systems,” in
Proceedings of the 19th Annual IEEE/ACM International Symposium
on Modeling, Analysis, and Simulation of Computer and Telecommu-
nication Systems (MASCOTS), Jul. 2011, pp. 307–317.
[16]
V. Venkatesan, I. Iliadis, and R. Haas, “Reliability of data storage
systems under network rebuild bandwidth constraints,” in Proceedings
of the 20th Annual IEEE International Symposium on Modeling,
Analysis, and Simulation of Computer and Telecommunication Systems
(MASCOTS), Aug. 2012, pp. 189–197.
[17]
V. Venkatesan and I. Iliadis, “A general reliability model for data
storage systems,” in Proceedings of the 9th International Conference
on Quantitative Evaluation of Systems (QEST), Sep. 2012, pp. 209–
219.
[18]
J.-F. Pˆaris, T. J. E. Schwarz, A. Amer, and D. D. E. Long, “Highly
reliable two-dimensional RAID arrays for archival storage,” in Pro-
ceedings of the 31st IEEE International Performance Computing and
Communications Conference (IPCCC), Dec. 2012, pp. 324–331.
[19]
V. Venkatesan and I. Iliadis, “Effect of codeword placement on the
reliability of erasure coded data storage systems,” in Proceedings of the
10th International Conference on Quantitative Evaluation of Systems
(QEST), Sep. 2013, pp. 241–257.
[20]
I. Iliadis and V. Venkatesan, “An efﬁcient method for reliability evalu-
ation of data storage systems,” in Proceedings of the 8th International
Conference on Communication Theory, Reliability, and Quality of
Service (CTRQ), Apr. 2015, pp. 6–12.
[21]
——, “Most probable paths to data loss: An efﬁcient method for
reliability evaluation of data storage systems,” Int’l J. Adv. Syst.
Measur., vol. 8, no. 3&4, Dec. 2015, pp. 178–200.
[22]
S. Caron, F. Giroire, D. Mazauric, J. Monteiro, and S. P´erennes, “P2P
storage systems: Study of different placement policies,” Peer-to-Peer
Networking and Applications, Mar. 2013, pp. 1–17.
[23]
I. Iliadis and V. Venkatesan, “Expected annual fraction of data loss as a
metric for data storage reliability,” in Proceedings of the 22nd Annual
IEEE International Symposium on Modeling, Analysis, and Simulation
of Computer and Telecommunication Systems (MASCOTS), Sep. 2014,
pp. 375–384.
[24]
——, “Reliability assessment of erasure coded systems,” in Proceed-
ings of the 10th International Conference on Communication Theory,
Reliability, and Quality of Service (CTRQ), Apr. 2017, pp. 41–50.
[25]
——, “Reliability evaluation of erasure coded systems,” Int’l J. Adv.
Telecommun., vol. 10, no. 3&4, Dec. 2017, pp. 118–144.
[26]
J. G. Elerath and J. Schindler, “Beyond MTTDL: A closed-form RAID
6 reliability equation,” ACM Trans. Storage, vol. 10, no. 2, Mar. 2014,
pp. 1–21.
[27]
I. Iliadis and V. Venkatesan, “Rebuttal to ‘Beyond MTTDL: A closed-
form RAID-6 reliability equation’,” ACM Trans. Storage, vol. 11, no. 2,
Mar. 2015, pp. 1–10.
[28]
“Amazon
Simple
Storage
Service.”
[Online].
Available:
http://aws.amazon.com/s3/ [retrieved: November 2017]
[29]
D. Borthakur et al., “Apache Hadoop goes realtime at Facebook,”
in Proceedings of the ACM SIGMOD International Conference on
Management of Data, Jun. 2011, pp. 1071–1080.
[30]
R. J. Chansler, “Data availability and durability with the Hadoop
Distributed File System,” ;login: The USENIX Association Newsletter,
vol. 37, no. 1, 2013, pp. 16–22.
[31]
K. Shvachko, H. Kuang, S. Radia, and R. Chansler, “The Hadoop
Distributed File System,” in Proceedings of the 26th IEEE Symposium
on Mass Storage Systems and Technologies (MSST), May 2010, pp.
1–10.
[32]
D. Ford et al., “Availability in globally distributed storage systems,”
in Proceedings of the 9th USENIX Symposium on Operating Systems
Design and Implementation (OSDI), Oct. 2010, pp. 61–74.
[33]
C. Huang et al., “Erasure coding in Windows Azure Storage,” in
Proceedings of the USENIX Annual Technical Conference (ATC), Jun.
2012, pp. 15–26.
[34]
S. Muralidhar et al., “f4: Facebook’s Warm BLOB Storage System,”
in Proceedings of the 11th USENIX Symposium on Operating Systems
Design and Implementation (OSDI), Oct. 2014, pp. 383–397.
[35]
“IBM Cloud Object Storage.” [Online]. Available: www.ibm.com/
cloud-computing/products/storage/object-storage/how-it-works/
[re-
trieved: November 2017]
[36]
K. V. Rashmi, N. B. Shah, D. Gu, H. Kuang, D. Borthakur, and
K. Ramchandran, “A solution to the network challenges of data recovery
in erasure-coded distributed storage systems: A study on the Facebook
warehouse cluster,” in Proceedings of the 5th USENIX Workshop on
Hot Topics in Storage and File Systems (HotStorage), Jun. 2013, pp.
1–5.
[37]
A. G. Dimakis, K. Ramchandran, Y. Wu, and C. Suh, “A survey on
network coding for distributed storage,” Proc. IEEE, vol. 99, no. 3,
Mar. 2011, pp. 476–489.
[38]
M. Zhang, S. Han, and P. P. C. Lee, “A simulation analysis of
reliability in erasure-coded data centers,” in Proceedings of the 36th
IEEE Symposium on Reliable Distributed Systems (SRDS), Sep. 2017,
pp. 144–153.
[39]
J. E. Angus, “On computing MTBF for a k-out-of-n:G repairable
system,” IEEE Trans. Reliability, vol. 37, no. 3, Aug. 1988, pp. 312–
313.
[40]
M. Silberstein, L. Ganesh, Y. Wang, L. Alvisi, and M. Dahlin, “Lazy
means smart: Reducing repair bandwidth costs in erasure-coded dis-
tributed storage,” in Proceedings of the 7th ACM International Systems
and Storage Conference (SYSTOR), Jun. 2014, pp. 15:1–15:7.
[41]
M. Ovsiannikov et al., “The quantcast ﬁle system,” in Proc. 39th Int’l
Conf. on Very Large Data Bases (VLDB), vol. 6, no. 11.
VLDB
Endowment, Aug. 2013, pp. 1092–1101.

