Sink Mobility Strategies for Reliable Data Collection
in Wireless Sensor Networks
Yuki Fujita‚àó, Daichi Kominami‚Ä† and Masayuki Murata‚àó
‚àóGraduate School of Information Science and Technology, Osaka University, Japan
{y-fujita, murata}@ist.osaka-u.ac.jp
‚Ä†Graduate School of Economics, Osaka University, Japan
d-kominami@econ.osaka-u.ac.jp
Abstract‚ÄîThe Internet of Things and machine-to-machine com-
munications will form one of the most important backbones
of our life in the near future. Therefore, more reliability is
required in many wireless sensor network applications, such as
structural health monitoring systems, intruder detection systems,
and search and rescue systems. However, without the assumption
that all sensor nodes can reach a sink node through multi-
hop communication and that the connectivity among all sensor
nodes is stable, it is difÔ¨Åcult to guarantee the reliability of data
collection. In this paper, we focus on controlling the mobility of a
mobile sink and propose two types of mobility strategies to collect
sensing data certainly from all sensor nodes in an observed area.
One strategy is to learn the positions of all isolated networks in
the observed area and the other is to collect sensing data using
the learned positions. Through computer simulations, we show
that the mobile sink with the mobility strategies can collect the
sensing data from all sensor nodes.
Keywords‚ÄìWireless sensor networks, reliable data collection,
mobile sink, controlled mobility.
I.
INTRODUCTION
Supporting assured data collection in wireless sensor net-
works (WSNs) is one of the signiÔ¨Åcant challenges in frequently
changing environments. This is because dynamic changes in
the observed area and loss of reachability to sink nodes
occur in actual situations, which cannot be dealt with through
conventional transport techniques. This promotes network-
level reliable mechanisms for data collection. We focus on
the mobility control for a data collecting node, usually called
a sink node in WSNs, to realize reliable data collection.
Wireless sensor networks, which facilitate the collection of
environmental information, are expected to apply signiÔ¨Åcantly
to various applications, e.g., structural health monitoring of
infrastructures, monitoring of temperature and humidity on a
farm, tracking of animals, etc. [1], [2]. In many cases, WSNs
are composed of many sensor nodes and a few sink nodes,
which operate in a distributed manner and are connected to
each other. Sensor nodes forward their sensing data to one of
the sink nodes through multi-hop wireless communications,
which makes it possible to collect various environmental
information.
In the near future, many machines will be mutually con-
nected and will be quietly embedded in our life space. Thus,
the Internet of Things and machine-to-machine communica-
tions will make WSN techniques more and more signiÔ¨Åcant. In
applications strongly tied to safety and security, the reliability
of data gathering is one of the most important viewpoints.
Data collection is realized under the assumption that all sensor
nodes are reachable by one of the sink nodes through multi-
hop communication. However, this assumption is not always
realistic due to the limitation of the communication range of
nodes, changes of wireless channel conditions, or failures of
sensor nodes. It is inappropriate to allow nodes to directly
communicate with a sink node since sensor nodes have a
limited battery capacity in most WSNs. Also, it is difÔ¨Åcult
to deploy sensor nodes over the observed area with paying
excess attention that all sensor nodes are always reachable to
a sink node.
We focus on a sink node with mobility called a mobile
sink. A mobile sink can achieve both reduction of power
consumption and reachability of every sensor nodes by ap-
proaching each sensor node, receiving data, and carrying it to
the static base station. Many studies have been conducted about
mobile sinks as a solution for power saving, which is one of
the challenging problems in WSNs, such as path planning of
mobile sinks and efÔ¨Åcient data routing algorithms considering
the movement of a mobile sink [3]‚Äì[5]. Mobile sinks from
the viewpoint of reliable data gathering do not have as much
active research.
Controlled mobility is a key idea for maintaining network
connectivity and achieving data reachability for users, where
the mobility of mobile sinks is dynamically controlled from
both inside and outside of networks [6], [7]. We previously
combined controlled mobility with a potential-based routing
mechanism in a wireless sensor network, where periodically
transmitted route information messages lead a mobile sink
toward the static data collecting node (called the target node)
and the mobile sink receives all data from the target node [8].
In this method, a mobile sink can collect data from a net-
work, however, the mobile sink cannot deal with the loss of
reachability to the target node.
In this paper, we propose two mobility strategies for a
mobile sink for realizing reliable data collection. To this end,
we need to manage the following two changes in an observed
area caused by failures, energy depletion, or additions of sensor
nodes. Here, we deÔ¨Åne a sub-network as a set of all sensor
nodes reachable from each other by multi-hop communication.
‚Ä¢
Small changes in a sub-network, which do not increase
58
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

or decrease the number of sub-networks, but cause
changes in route. This occurs mainly due to link
failures and node failures.
‚Ä¢
Large changes in a sub-network, which increase or
decrease the number of networks and also cause
changes in route. This occurs for various reasons that
cause the disconnection of a sub-network, the jointing
of sub-networks, or the deployment of a new sub-
network.
Small changes have been well-studied, however, large
changes have been little considered in existing studies. Thus,
our interests are in how we can collect all data in an observed
area when both types of changes occur. We use the term
reliable data collection as 100% collection of data that are
generated by all sensor nodes in each sub-network. We aim
for reliable data collection by using a mobile sink within an
observed area where both the number and the positions of
sensor nodes are unknown. In these situations, it is a possible
(but not practical) method for a mobile sink to travel all over
the observed area since the mobile sink does not know where
sub-networks are in the observed area. Of course, it takes much
more time for the mobile sink to travel to every nook and
cranny as the observed area gets larger. Therefore, the Ô¨Årst
mobility strategy is conducted at long intervals, where a mobile
sink travels all over the observed area to grasp all positions of
sub-networks and also impassable locations. The other strategy
is to visit all sub-networks and to collect sensing data from
data possessing nodes using learned positions from the Ô¨Årst
strategy.
In principle, it is difÔ¨Åcult to catch an unexpected change
by methods other than the Ô¨Årst strategy, and it requires a lot
of time. Therefore, it is taken repeatedly over a long period.
For the second strategy, we use a clustering technique and all
data in a sub-network are gathered in one or more cluster
heads. Then, a mobile sink just has to visit such cluster
heads to collect data. Note that we assume that cluster heads
change their role back to a non-cluster head periodically for
managing small changes in a sub-network and for achieving
load balancing. Thus, a mobile sink does not always know the
position of a cluster head. The controlled mobility mechanism
proposed in [8] helps a mobile sink approach a cluster head
in each sub-network.
The remainder of this paper is organized as follows.
In Section II, we present the mobility control strategy for
memorizing locations of networks. In Section III, we show
the mobility strategy for collecting sensing data in a network.
Section IV presents simulation results, and Ô¨Ånally, we conclude
our paper in Section V.
II.
MOBILITY STRATEGY FOR MEMORIZING
SUB-NETWORK LOCATIONS
A mobile sink has to periodically check the entire picture
of the observed area, such as the positions of sub-networks and
forbidding places, to determine the path for visiting all sub-
networks. In order to grasp this information, it moves over the
›Ä
›Ä Õ¥
‡µó 
›Ä Õ¥
‡µó 
6HQVRUQRGH
$HGJHRIWKHVTXDUHUHJLRQ

5HSHDWWKLVSDUW

5HDFKWKHDOOFRUQHUV
5HWXUQWR
WKHLQLWLDOSRVLWLRQ
,QLWLDOSRVLWLRQ 
&RPPXQLFDWLRQ
UDQJH
Figure 1. Mobility strategy for detecting all sensor nodes without any
oversight
entire observed area while identifying and memorizing all the
different sub-networks.
In our proposal, a mobile sink moves so that it does not
overlook even one sensor node placed in the observed area.
To begin with, we assume that only a mobile sink has a
positioning device like a global positioning system. A mobile
sink commences to move from a given initial position (e.g., a
base station with charging capability for a mobile sink battery),
which is one of the corners of the pre-deÔ¨Åned square region
including the whole observed area as illustrated in Fig. 1. Then,
the mobile sink goes straight on toward one nearby corner
until it reaches d/2 length short of the corner, where d is the
wireless communication range of the mobile sink and sensor
nodes. Then, it takes a turn toward the other nearby corner,
moves ahead d/2, and again rotates in the same angle and
moves ahead. The mobile sink repeats the same process until
reaching all corners, then it returns to the initial position.
In this strategy, a mobile sink intercepts a message PIn-
foMsg, which all sensor nodes transmit and exchange with
each other for updating route information (described in Sec-
tion III-B in detail). Then, the mobile sink acquires a special
identiÔ¨Åer (ID) contained in that PInfoMsg, which is used to
identify sub-networks.
A mobile sink memorizes or updates a position of sub-
network according to Algorithm 1, where some terms are listed
in Table I. A mobile sink has a table NetTable for storing sub-
network positions, which is updated every time it receives a
PInfoMsg. A NetTable‚Äôs entry is the tuple (netID, position,
RSSI) where netID is an identiÔ¨Åer of a sub-network, position
is the position where the mobile sink received the PInfoMsg,
and RSSI is the received signal strength indication of the
PInfoMsg. A new entry is always registered to the table if
there is no entry whose netID equals one in the PInfoMsg,
and an existing entry is updated if the RSSI of the received
PInfoMsg is greater than an existing one that has the same
netID of the PInfoMsg. This is for ensuring that the mobile
59
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

Algorithm 1 Memorizing the positions of networks associating
with netID by the mobile sink
1: // The mobile sink moves in every corner of the observed
area.
2: repeat
3:
if
intercepts
PInforMsg(i, netIDi, pListi, vListi)
then
4:
if NetTable has no entry with netIDi then
5:
register NetTable(netIDi, pos,PInforMsg.rssi)
6:
else
7:
if PInfoMsg.rssi > entry.rssi then
8:
update NetTable(netIDi, pos,PInforMsg.rssi)
9:
end if
10:
end if
11:
if Statei is CLUSTER(i, 0) then
12:
sends SensingDataRequest to Si
13:
end if
14:
end if
15: until reaches the end of the observed area
TABLE I. NOTATIONS IN OUR PROPOSED METHODS
Notation
Description
Ns
The number of sensor nodes which is initially deployed
Nb
The number of sensor nodes which will get failed
Na
The number of sensor nodes which will be added
Si
The sensor node whose ID is i
ND(Si)
The number of neighbor nodes of Si
Statei
The state of Si which indicates whether Si
belongs to a cluster or not. Statei is either
UNCLUSTER or CLUSTER(i, n)
tSi
The current time of node Si
Tlim
The time limit to search for its neighbor nodes
Tflood
The interval that cluster heads broadcast PInfoMsg
Th
The period that NTable keeps a non-updated entry
netIDi
The ID of the network that Si belongs to
pID
The ID of the potential Ô¨Åeld
myPi
The potential values that Si has
pListi
The set of pID that Si has
vListi
The set of myPi that Si has
sink can obtain more accurate positions of sub-networks. Note
that, when the mobile sink can contact a cluster head in this
mobility strategy, it demands sensing data from the cluster
head by transmitting a message SensingDataRequest.
III.
MOBILITY STRATEGY FOR VISITING ALL CLUSTER
HEADS
In the previous strategy, a mobile sink memorizes the
position of all sub-networks. In order to realize reliable data
collection, the mobile sink has to visit each sub-network,
collect all sensing data in the sub-network, and then move
ahead to another sub-network. One way for collecting all
sensing data in a sub-network is to visit sensor nodes one by
one by memorizing the position of each node in the previous
strategy, which spends memory costs and time costs. In our
proposal, all sub-networks within the observed area have one
or more special nodes that gather sensing data from all sensor
nodes in an individual sub-network, and a mobile sink moves
to and sojourns with them to bring the sensing data to the
initial position. We elect this special node by using a cluster
head election algorithm proposed in [9]. When a mobile sink
enters a sub-network, the mobile sink intercepts and interprets
route information messages exchanged with sensor nodes and
moves in the same direction as data Ô¨Çows, and consequently,
it can visit all cluster heads in the sub-network. After that,
the mobile sink moves ahead in the direction of another sub-
network learned at the previous strategy.
A. Cluster heads election
We elect one or more cluster heads for each sub-network
by using a part of the DEECIC algorithm [9] with minor
modiÔ¨Åcation. The cluster head election algorithm in DEECIC
is described in Algorithm 2 with some terms which are
tabulated in Table I. First, sensor node Si broadcasts an
UpdatePacket to notify its neighbors of its presence at ran-
domly chosen time t (0 < t < Tlim). Then, Si broadcasts
a DegreePacket including ND(Si), which is the number of
received UpdatePackets until Tlim expires, to inform its node
of its degree at t (Tlim ‚â§ t < Tlim + TSi). TSi is given from
TSi = Œ±e1/ND(Si) where Œ± is a constant so that it ensures
0 < TSi ‚â™ Tlim. Sensor node Si waits for receipt of a
StatePacket including the state of a neighbor node, which
notiÔ¨Åes whether the neighbor belongs to any cluster or not.
Here, CLUSTER(i, n) presents that the node Si can reach a
certain cluster head within n hops and CLUSTER(i, 0) means
that node Si is a cluster head. Upon receiving a StatePacket
with CLUSTER(s, n), Si sets Statei to CLUSTER(i, n + 1)
if Statei was UNCLUSTERD or CLUSTER(i, m) where
m is larger than n + 1. Si broadcasts a StatePacket if
n + 1 ‚â§ max n thereafter, which limits the coverage of each
cluster.
When disconnection of a sub-network occurs, there may
be no cluster head in a sub-network. Therefore, this cluster
election is done periodically. Thus, our proposed method can
respond to environmental changes inside a sub-network.
B. Construction and update of potential Ô¨Åelds
We use a potential-based routing protocol [10] for data
collection in each sub-network. The potential-based routing is
known as a resilient routing protocol for environmental varia-
tions. Every node updates its own potential, which is a scalar
value calculated only with local information‚Äîown potential,
neighbors‚Äô potential, and node degrees. It is worth noting that
potential messages exchanged between sensor nodes for data
routing is also utilized for the guidance of a mobile sink toward
elected cluster heads.
For the mobility strategy to visit all cluster heads, every
cluster head constructs one potential Ô¨Åeld that is the shape of
a concave curve whose bottom corresponds to the position
of the cluster head. Thus, multiple potential Ô¨Åelds can be
constructed in each sub-network. Each potential Ô¨Åeld has a
unique identiÔ¨Åer pID that corresponds to an identiÔ¨Åer of the
60
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

Algorithm 2 Selection of cluster heads in a network
1: // all nodes perform following;
2: Statei ‚áê UNCLUSTER
3: t ‚áê random value between 0 and Tlim
4: broadcast UpdatePacket at tSi
5: repeat
6:
if receives a UpdatePacket then
7:
ND(Si) ‚áê ND(Si) + 1
8:
end if
9: until tSi ‚â• Tlim
10: broadcast DegreePacket at t, (Tlim ‚â§ t < Tlim + TSi)
11: repeat
12:
if receive StatePacket with CLUSTER(s, n) node
then
13:
if Statei is UNCLUSTER then
14:
Statei ‚áê CLUSTER(s, n + 1)
15:
else if Statei is CLUSTER(i, m) and m > n + 1
then
16:
Statei ‚áê CLUSTER(s, n + 1)
17:
end if
18:
if n+1 ‚â§ max n then
19:
broadcast StatePacket
20:
end if
21:
end if
22: until tSi ‚â• Tlim + TSi
23: if ND(Si) is larger than all neighbor nodes and Stateiis
UNCLUSTER then
24:
Statei ‚áê CLUSTER(i, 0)
25:
broadcast StatePacket
26: end if
cluster head that is a owner of the potential Ô¨Åeld. The potential-
Ô¨Åeld construction process is given in Algorithm 3 with some
terms tabulated in Table I.
First, cluster head Si initializes netIDi and myPi, and
then broadcasts a PInfoMsg throughout the sub-network (lines
1‚Äì10). A PInfoMsg includes the sender‚Äôs ID (Si), sub-network
ID, multiple potential-Ô¨Åeld IDs (pID), and potential values of
correspondent potential Ô¨Åelds as illustrated in Fig. 2. When
receiving a PInfoMsg, a sensor node updates the NTable,
myPi, and netIDi and broadcasts a new PInfoMsg (lines
11‚Äì44). Here, NTable is a table to store information about
the potential of neighbor nodes, and its entry is composed of
Ô¨Åve attributes (src, networkID, pID, pV alue, time), which
are an ID of the source node (cluster head), a sub-network ID,
a potential-Ô¨Åeld ID, a potential value in the correspondent po-
tential Ô¨Åeld, and the time this entry was registered or updated,
respectively. Si registers or updates an entry of their NTable
when receiving a PInfoMsg and Si removes an old entry that
is not updated for a period Th. After that, Si calculates its own
sub-network ID (netIDi) and potentials (myPi). netIDi is set
to the lowest value among pID registered in its NTable and
myPi is set to an average potential value of its neighbors as
proposed in [10]. Finally, Si updates all myPi and puts them
into a PInfoMsg. After a lapse of Tforward, it broadcasts its
Algorithm 3 Potential Ô¨Åelds construction and update
1: if Statei is CLUSTER(i,0) then
2:
netIDi ‚áê i
3:
myPi[i] ‚áê initial potential
4:
puts i into pListi
5:
puts myPi[i] into vListi
6:
broadcast
PInfoMsg(i, netIDi, pListi, vListi)
per
Tflood
7:
clear pListi, vListi
8: else
9:
netIDi ‚áê NULL
10: end if
11: loop
12:
if receive PInfoMsg(s, netIDs, pLIsts, vLIsts) then
13:
for j = 1 to k do
14:
update the NTable(s, netIDs, pLists[j], vLists[j], tSi)
15:
end for
16:
for all entry in NTable do
17:
if tSi ‚àí entry.time > Th then
18:
remove the entry from NTable
19:
if NTable has no entry then
20:
Statei ‚áê CLUSTER(i, 0)
21:
broadcast StatePacket
22:
else
if
NTable
has
no
entry
whose
entry.netID is netIDi then
23:
if Statei is CLUSTER(i, 0) then
24:
netIDi ‚áê i
25:
else
26:
netIDi ‚áê NULL
27:
end if
28:
end if
29:
end if
30:
end for
31:
for j = 1 to k do
32:
update all myPi[pLists[j]]
33:
end for
34:
if netIDi is NULL or netIDi > netIDs then
35:
netIDi ‚áê netIDs
36:
end if
37:
for j = 1 to k do
38:
puts pLists[j] into pListi
39:
puts myPi[pLists[j]] into vListi
40:
end for
41:
broadcast PInfoMsg(i, netIDi, pListi, vListi) after
Tforward
42:
clear pListi, vListi
43:
end if
44: end loop
own PInfoMsg.
C. Traveling to cluster heads according to potential Ô¨Åelds
Each cluster head has a unique potential Ô¨Åeld and also has
the minimum potential value in its potential Ô¨Åeld. All sensor
nodes forward their sensing data to one of their neighbor nodes
61
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

6KULQNRISRWHQWLDOILHOG‹®‡Æ∫
([SDQVLRQRISRWHQWLDOILHOG‹®‡Æª
0RELOHVLQNILQGVDQHZ
SRWHQWLDOILHOG
‹®‡Æ∫
‹®‡Æª
‹®‡Æº
Figure 4. New potential Ô¨Åeld FB is detected by the mobile sink after
potential Ô¨Åeld FA decreases its potential
6HQVRUQRGH
&OXVWHUKHDG
‹µ‡Øú‡≤≤
‹µ‡Øú‡≤≥
‹µ‡Øú‡≤¥
3RWHQWLDOILHOGRI‹µ‡Øú‡≤≤
3RWHQWLDOILHOGRI‹µ‡Øú‡≤≥
3RWHQWLDOILHOGRI‹µ‡Øú‡≤¥
6HQVRUQRGH‹µ‡ØúKDV
SRWHQWLDOYDOXHV
›â›ï‹≤‡Øú‹µ‡Øú‡≤≤ «° ›â›ï‹≤‡Øú‹µ‡Øú‡≤≥ «° ›â›ï‹≤‡Øú·àæ‹µ‡Øú‡≤¥·àø
3RWHQ
‡Øú
3RWH
3R
6XEQHWZRUN‹∞
6UFQRGH,' ›Ö
1HWZRUN,' ‹∞
›å‹Æ›Ö›è›ê‡Øú ‡µå^‹µ‡Øú‡≤≤‹µ‡Øú‡≤≥‹µ‡Øú‡≤¥`
›í‹Æ›Ö›è›ê‡Øú ‡µå^›â›ï‹≤‡Øú‹µ‡Øú‡≤≤ ›â›ï‹≤‡Øú‹µ‡Øú‡≤≥ ›â›ï‹≤‡Øú·àæ‹µ‡Øú‡≤¥·àø`
‹µ‡ØúEURDGFDVWV3,QIR0VJ
3,QIR0VJ
Figure 2. Example of a situation where Si broadcasts a PInfoMsg
&OXVWHUKHDG
6HQVRUQRGH
3RWHQWLDOILHOG
0RELOHVLQNUHDFKHVDFOXVWHUKHDG
7KHUDLVHRI
SRWHQWLDOYDOXH
‹®‡Æ∫
‹®‡Æª
‹®‡Æº
Figure 3. Increase of a potential value of a cluster head caused by arrival of
the mobile sink
that have a smaller potential value, and then, all sensing data
eventually reach one of the cluster heads. The mobile sink
also utilizes these multiple potential Ô¨Åelds, that is, utilizes
vList in a PInfoMsg transmitted by a sensor node to reach a
cluster head [8]. After the arrival of the mobile sink at a cluster
head, the cluster head gives collected data to the mobile sink
and increases its potential value greatly. This decreases the
priority of the potential Ô¨Åeld of the cluster head compared with
other potential Ô¨Åelds because a sensor node with a ‚Äúsmaller‚Äù
potential value attracts data and the mobile sink as shown in
Fig. 3. After that, the mobile sink can Ô¨Ånd a new potential
Ô¨Åeld and can go to another cluster head as shown in Fig. 4.
When a mobile sink has visited all cluster heads in a sub-
network, the mobile sink goes to an unvisited sub-network.
Then, the mobile sink visits all sub-networks in the order
that it previously visited and memorized them in the manner
explained in Sec. II.
IV.
SIMULATION EVALUATION
In this section, we show that our proposal realizes reliable
data collection even when additions or breakdowns of sensor
nodes occur.
A. Simulation settings
We assume a 1,000 m √ó 1,000 m square region including
the whole observed area and deploy Ns sensor nodes at
uniformly random positions in the observed area. The com-
munication range of a sensor node is represented by a circle
with a radius of 100 m. Sensor nodes observe surrounding
environmental phenomena and create a data packet that in-
cludes sensing data every one hour. Then, they forward the
packet to one of the cluster heads. As an important assumption
underlying reliable data collection, a retransmission algorithm
can attain successful data transmission between two nodes and
each node has sufÔ¨Åcient memory not to drop any data.
In our simulation, randomly chosen Nb sensor nodes will
fail, which causes other nodes to disconnect from the sub-
network. Also, Na sensor nodes will be added at random places
in the observed area. Those failures and additions are taken at
several pre-deÔ¨Åned times.
A mobile sink, whose speed is set to 5 m/s, starts to
move at 0 s and follows one of the proposed two mobility
strategies. The mobility strategy of the mobile sink is being
followed every one hour, and as the mobile sink Ô¨Ånishes one
strategy, it returns to the initial position to charge its battery.
Here, the mobility strategy for learning sub-network positions
is executed every LI hours.
We assume that the mobile sink can pass all the region
of the observed area for evaluating basic performance. As
an evaluation of reliable data collection, we calculate a data
collection ratio (denoted by CR) every hour using (1).
CR = NCD
NED
(1)
Here, NCD and NED mean the number of collected and all
generated data, respectively.
In our simulation, Ns, Nb, and Na are set to 40, 5, and 10,
respectively. Simulation time is set as 604,800 s (i.e., 1 week)
and we performed 30 simulations with different sensor node
positions for each LI (LI = 1, 2, 3, 4, 5).
B. Simulation results
Figure. 5 shows the transition of CR when LI is set to
1 and 5. In this Ô¨Ågure, the Y-axis is the average of CR of
30 simulation trials. Even after node additions and failures
occur, CR recovers from a temporary drop when LI is set to
62
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

 80 
 85 
 90 
 95 
 100 
 105 
 0 
 20 
 40 
 60 
 80 
 100 
 120 
 140 
 160 
Average collection ratio (CR) [%] 
Simulation time [h] 
LI = 1 
LI = 5 
1RGHDGGLWLRQ
1RGHIDLOXUH
Figure 5. The transition of CR where LI = 1 and LI = 5
80
85
90
95
100
300000
350000
400000
450000
500000
Total duration for the movement of the mobile sink [s]
LI = 1
LI = 2
LI = 3
LI = 4
LI = 5
/, 
/, 
/, 
/, 
/, 
300000
350000
400000
450000
500000
80
85
90
95
100
Total duration for the movement of the mobile sink [s]
Time ratio that reliable data collection is achieved [%]
Figure 6. The relation between the reliability of data collection and the
delay for mobility where LI = 1, 2, 3, 4, 5
5. This is because the mobile sink can learn the positions of
new sub-networks every 5 hours. Thus, we Ô¨Ånd that reliable
data collection can be attained by combining the two mobility
strategies. Here, the average of CR remains 100% throughout
the simulation when LI = 1. This is because the mobile sink
always follows the strategy for learning the positions of all
sub-networks.
Figure. 6 shows the relationship between the reliability and
the efÔ¨Åciency of data collection. In this Ô¨Ågure, the X-axis is
the total time that the mobile sink moved except for waiting
time at the initial position, and the Y-axis is the ratio of the
time that the mobile sink can achieve 100% CR to the total
simulation time.
The average durations for movement of the mobile sink
are 438,428 s, 406,360 s, 385,653 s, 373,907 s, and 364,648 s,
and the average time ratios that reliable data collection are
achieved are 0.988, 0.986, 0.960, 0.986, and 0.934 for each
LI = 1, 2, 3, 4, 5, respectively. The more frequent the mobile
sink executes the mobility strategy for learning the sub-
network positions, the more duration is required to acquire
high reliability. Too frequent use of that strategy results in the
redundant movements of the mobile sink in the case where
few changes occur in the observed area. This trade-off relation
between the reliability and the efÔ¨Åciency of data collection has
to be managed with careful consideration of the frequency of
environmental changes in the observed area.
V.
CONCLUSION
In this paper, we present two mobility strategies for a
mobile sink to realize reliable data collection. Our strategy
can deal with a disconnection of a network and additional
deployment of sensor nodes in an observed area. Through
computer simulations, we demonstrate that reliable data col-
lection is achieved by our proposal and show the trade-off
between the reliability and the delay time for data collection.
This trade-off can be adjusted by changing the frequency of the
mobility strategy of the mobile sink for learning the positions
of sub-networks. Our current interests are in the path planning
among sub-networks, and in implementing our proposal in
actual mobile nodes.
REFERENCES
[1]
H. Karl and A. Willing, Protocols and architectures for wireless sensor
networks.
Wiley, Oct. 2007.
[2]
S. V. Deshpande and P. Devale, ‚ÄúRecent trends in using wireless sensor
networks in industrial environment,‚Äù International Journal of Computer
Networking Wireless and Mobile Communication, vol. 3, no. 3, pp. 11‚Äì
20, Aug. 2013.
[3]
J. Luo and J. Hubaux, ‚ÄúJoint sink mobility and routing to maximize the
lifetime of wireless sensor networks: the case of constrained mobility,‚Äù
IEEE/ACM Transactions on Networking, vol. 18, pp. 871‚Äì884, Jun.
2010.
[4]
I. Chatzigiannakis, A. Kinalis, and S. Nikoletseas, ‚ÄúSink mobility pro-
tocols for data collection in wireless sensor networks,‚Äù in Proceedings
of the 4th ACM International Workshop on Mobility Management and
Wireless Access, Oct. 2006, pp. 52‚Äì59.
[5]
Z. Wang, S. Basagni, E. Melachrinoudis, and C. Petrioli, ‚ÄúExploiting
sink mobility for maximizing sensor networks lifetime,‚Äù in Proceed-
ings of the 38th Annual Hawaii International Conference on System
Sciences, Jan. 2005, pp. 287‚Äì295.
[6]
F. Mourad, H. Chehade, H. Snoussi, F. Yalaoui, L. Amodeo, and
C. Richard, ‚ÄúControlled mobility sensor networks for target tracking
using ant colony optimization,‚Äù IEEE Transactions on Mobile Comput-
ing, vol. 11, no. 8, pp. 1261‚Äì1273, Aug. 2012.
[7]
R. Falcon, H. Liu, A. Nayak, and I. Stojmenovic, ‚ÄúControlled straight
mobility and energy-aware routing in robotic wireless sensor networks,‚Äù
in Proceedings of the 2012 IEEE 8th International Conference on
Distributed Computing in Sensor Systems, May 2012, pp. 150‚Äì157.
[8]
S. Toyonaga, Y. Fujita, D. Kominami, and M. Murata, ‚ÄúImplementation
of controlled sink mobility strategies with a gradient Ô¨Åeld in wireless
sensor networks,‚Äù in Proceedings of the 7th International Conference
on Sensor Technologies and Applications, Aug. 2013, pp. 27‚Äì32.
[9]
Z. Liu, Q. Zheng, L. Xue, and X. Guan, ‚ÄúA distributed energy-
efÔ¨Åcient clustering algorithm with improved coverage in wireless sensor
networks,‚Äù Future Generation Computer Systems, vol. 28, no. 5, pp.
780‚Äì790, May 2012.
[10]
D. Kominami, M. Sugano, M. Murata, and T. Hatauchi, ‚ÄúControlled and
self-organized routing for large-scale wireless sensor networks,‚Äù ACM
Transactions on Sensor Networks, vol. 10, p. 13, Nov. 2013.
63
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-391-9
ADAPTIVE 2015 : The Seventh International Conference on Adaptive and Self-Adaptive Systems and Applications

