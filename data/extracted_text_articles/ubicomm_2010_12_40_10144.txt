A One-Shot Dynamic Optimization Methodology for Wireless Sensor Networks
Arslan Munir and Ann Gordon-Ross
Department of Electrical and Computer Engineering
University of Florida, Gainesville, Florida 32611
Email: amunir@uﬂ.edu, ann@chrec.org
Susan Lysecky and Roman Lysecky
Department of Electrical and Computer Engineering
University of Arizona, Tucson, Arizona 85721
Email: {slysecky, rlysecky}@ece.arizona.edu
Abstract—Wireless
sensor
networks
(WSNs),
consisting
of autonomous sensor nodes, have emerged as ubiquitous
networks
which
span
diverse
application
domains
(e.g.,
health care, logistics, defense) each with varying application
requirements
(e.g.,
lifetime,
throughput).
Sensor
nodes
possess tunable parameters (e.g., processor voltage, sensing
frequency), which enable platform specialization for particular
application requirements. WSN application design can be
daunting for application developers, which are oftentimes not
trained engineers (e.g., biologists, agriculturists) who wish to
utilize the sensor-based systems within their given domain.
Dynamic optimizations enable sensor-based platforms to tune
parameters in-situ to automatically determine an operating
state. However, rapidly changing application behavior and
environmental stimuli necessitate a lightweight and highly
responsive dynamic optimization methodology. In this paper,
we propose One-Shot – a lightweight dynamic optimization
methodology that determines initial tunable parameter settings
to give a high-quality operating state in One-Shot for time-
critical and highly constrained applications. Results reveal that
One-Shot solution is within 5.92% of the optimal solution on
average. To assist dynamic optimizations in determining an
operating state, we propose an application metric estimation
model to establish a relationship between application metrics
(e.g., lifetime) and sensor-based platform parameters.
Keywords-Wireless sensor networks; dynamic optimization;
application metric estimation
I. INTRODUCTION AND MOTIVATION
Wireless sensor networks (WSNs) consist of spatially
distributed
autonomous
sensor
nodes
that
observe
a
phenomenon
(environment,
target,
etc.).
WSNs
are
becoming ubiquitous due to their proliferation in diverse
application domains (e.g., defense, health care, logistics)
each with varying application requirements. For example,
a security/defense system may have a high throughput
requirement whereas an ambient conditions monitoring
application may be more sensitive to lifetime. This diversity
makes WSN design challenging using commercial-off-the-
shelf (COTS) sensor nodes.
COTS sensor nodes are mass-produced to optimize for
cost and are not specialized for any particular application.
Furthermore, WSN application developers oftentimes are
not trained engineers, but rather biologists, teachers, or
agriculturists who wish to utilize the sensor-based systems
within their given domain. Fortunately, many COTS sensor
nodes possess tunable parameters (e.g., processor voltage
and frequency, sensing frequency) whose values may be
tuned for a speciﬁc application. Faced with an overwhelming
number of tunable parameter choices, WSN design may be a
daunting task for non-experts and necessitates an automated
parameter tuning process for assistance.
Parameter optimization is the process of assigning
appropriate (optimal or near-optimal) values to tunable
parameters
either
statically
or
dynamically
to
meet
application
requirements.
Static
optimizations
assign
parameter
values
at
deployment
and
these
values
remain ﬁxed during a sensor node’s lifetime. Accurate
prediction/simulation of environmental stimuli is challenging
and applications with changing environmental stimuli do
not beneﬁt from static optimizations. Dynamic optimizations
assign parameter values during runtime and reassign/change
these values in accordance with changing environmental
stimuli, thus enabling closer adherence to application
requirements.
There exists much research in the area of dynamic
optimizations (e.g., [1][2][3][4]), but most previous work
targets the memory (cache) or processor in computer
systems. Little work exists on WSN dynamic optimization,
which presents additional challenges due to a WSN’s
unique design space, energy constraints, and operating
environment. Shenoy et al. [5] presented proﬁling methods
for dynamically monitoring sensor-based platforms and
analyzed the associated network trafﬁc and energy, but did
not explore dynamic optimizations. In prior work, Munir
et al. [6] proposed a Markov Decision Process (MDP)-
based methodology as a ﬁrst step towards WSN dynamic
optimization, but this methodology required excessive
computational resources for larger design spaces. Wang et
al. [7] proposed an energy efﬁcient optimization method
for target tracking applications that consisted of dynamic
awakening and an optimal sensing scheme. Khanna et al.
[8] proposed a genetic algorithm for secure and dynamic
deployment of resource-constrained multi-hop WSNs. Some
previous works [9][10] explored WSN dynamic voltage and
frequency scaling (DVFS) for dynamic optimization, but
DVFS only considered two sensor node tunable parameters
(processor voltage and frequency).
In this paper, we explore a ﬁne-grained design space
for sensor-based platforms with many tunable parameters
287
UBICOMM 2010 : The Fourth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-100-7

to more closely meet application requirements (Gordon-
Ross et al. [11] showed that ﬁner-grained design spaces
provide interesting design alternatives and result in increased
beneﬁts in the cache subsystem). The exploration of a
ﬁne-grained design space coupled with limited battery
reserves and rapidly changing application requirements and
environmental stimuli necessitates a lightweight and highly
responsive dynamic optimization methodology.
We
propose
One-Shot
–
a
lightweight
dynamic
optimization
methodology
that
determines
appropriate
initial tunable parameter values to give a good quality
operating state (tunable parameter value settings) in One-
Shot with minimal design exploration for highly constrained
applications. Results reveal that the One-Shot operating
state is within 5.92% of the optimal solution (obtained
from exhaustive search) averaged over several different
application domains and design spaces. To assist dynamic
optimizations in determining an operating state, we for
the ﬁrst time, to the best of our knowledge, propose an
application metric estimation model, which estimates high-
level metrics (lifetime, throughput, and reliability) from
sensor-based platform parameters (e.g., processor voltage
and frequency, sensing frequency, transceiver transmission
power,
etc.).
The
dynamic
optimization
methodology
leverages this estimation model while comparing different
operating states for optimization purposes.
II. DYNAMIC OPTIMIZATION METHODOLOGY
In this section, we give an overview of One-Shot and
associated algorithm. We also formulate the state space and
objective function for One-Shot.
A. Overview
Fig. 1
depicts our One-Shot dynamic optimization
methodology
for
WSNs.
WSN
designers
evaluate
application requirements and capture these requirements as
high-level application metrics (e.g., lifetime, throughput,
reliability) and associated weight factors. The weight factors
signify the weightage/importance of each application metric
with respect to each other. One-Shot leverages an application
metric estimation model to determine application metric
values offered by an operating state.
Fig.
1
shows
the
per-node
One-Shot
process
(encompassed by the dashed circle), which is orchestrated
by the dynamic optimization controller. The dynamic
optimization
controller
invokes
One-Shot
wherein
the
sensor node operating state is directly determined using
an intelligent tunable parameter value setting selection
methodology (i.e., in One-Shot). One-Shot also determines
an
exploration
order
(ascending
or
descending)
for
the tunable parameters. This exploration order can be
leveraged by an online optimization algorithm to provide
improvements over the One-Shot solution by further design
space exploration and is the focus of our future work. This
Figure 1. One-Shot dynamic optimization methodology for wireless sensor
networks.
exploration order is critical in reducing the number of states
explored by the online optimization algorithm. The sensor
node moves directly to the operating state speciﬁed by One-
Shot. A dynamic proﬁler records proﬁling statistics (e.g.,
remaining battery energy, wireless channel condition) given
the current operating state and environmental stimuli and
passes these proﬁling statistics to the dynamic optimization
controller.
The
dynamic
optimization
controller
processes
the
proﬁling statistics to determine if the current operating
state meets the application requirements. If the application
requirements
are
not
met,
the
dynamic
optimization
controller
reinvokes
One-Shot
to
determine
the
new
operating state. This feedback process continues to ensure
the selection of an appropriate operating state to better meet
application requirements.
B. State Space
The state space S
for One-Shot given N
tunable
parameters is deﬁned as:
S = P1 × P2 × · · · × PN
(1)
where Pi denotes the state space for tunable parameter
i, ∀ i ∈ {1, 2, . . ., N} and × denotes the Cartesian product.
Each tunable parameter Pi consists of n values:
Pi = {pi1, pi2, pi3, . . . , pin}
:
|Pi| = n
(2)
where |Pi| denotes the tunable parameter Pi’s state space
cardinality (the number of tunable values in Pi). S is a set of
n-tuples (each n-tuple represents a sensor node state) formed
by taking one tunable parameter value from each tunable
parameter. A single n-tuple s ∈ S is given as:
s
=
(p1y, p2y, . . . , pNy) : piy ∈ Pi,
∀ i ∈ {1, 2, . . ., N}, y ∈ {1, 2, . . ., n}
(3)
We point out that some n-tuples in S may not be feasible
(such as invalid combinations of processor voltage and
frequency) and can be treated as do not care tuples.
288
UBICOMM 2010 : The Fourth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-100-7

C. Optimization Objection Function
The sensor node dynamic optimization problem can be
formulated as an unconstrained optimization problem:
max f(s) =
m
X
k=1
ωkfk(s)
s.t.
s ∈ S
ωk ≥ 0,
k = 1, 2, . . ., m.
ωk ≤ 1,
k = 1, 2, . . ., m.
m
X
k=1
ωk = 1,
(4)
where f(s) denotes the objective function characterizing
application metrics and weight factors. fk(s) and ωk in
(4) denote the objective function and weight factor for the
kth application metric, respectively, given that there are m
application metrics. Each state s ∈ S has an associated
objective function value and the optimization goal is to
determine a state that gives the maximum (optimal) objective
function value f opt(s) where f opt(s) indicates the best
possible adherence to the application requirements given the
design space S.
For our dynamic optimization methodology, we consider
three application metrics (m = 3), which are lifetime,
throughput, and reliability, each with piecewise linear
objective functions. A piecewise linear objective function
captures the desirable and acceptable ranges of a particular
application metric. For example, for a particular application,
a lifetime metric may have an acceptable minimum value
of 40 days and reliability may be a more important metric
than the lifetime. The objective function delineates this
inter-metric relative importance and attainable application
metric values. Even though we consider piecewise linear
objective functions, our methodology works well for any
other objective function characterization (e.g., linear, non-
linear).
D. One-Shot Dynamic Optimization Algorithm
In this subsection, we describe associated algorithm
for One-Shot. The algorithm determines initial tunable
parameter value settings and exploration order (ascending
or descending).
Algorithm 1 describes One-Shot’s algorithm to determine
initial tunable parameter value settings and exploration
order. The algorithm takes as input the objective function
f(s), the number of tunable parameters N, the number
of values for each tunable parameter n, the number of
application metrics m, and P where P represents a vector
containing the tunable parameters, P = {P1, P2, . . . , PN}.
For each application metric k, the algorithm calculates
vectors P k
0
and P k
d
(where d denotes the exploration
direction (ascending or descending)), which store the initial
value settings and exploration order, respectively, for the
Input: f(s), N, n, m, P
Output: Initial tunable parameter value settings and exploration
order
for k ← 1 to m do
1
for Pi ← P1 to PN do
2
fk
pi1 ← k-metric objective function value when
3
parameter setting is {Pi = pi1, Pj = Pj0, ∀ i ̸= j} ;
fk
pin ← k-metric objective function value when
4
parameter setting is {Pi = pin, Pj = Pj0, ∀ i ̸= j} ;
δfk
Pi ← fk
pin − fk
pi1 ;
5
if δfk
Pi ≥ 0 then
6
explore Pi in descending order ;
7
P k
d [i] ← descending ;
8
P k
0 [i] ← pk
in ;
9
else
10
explore Pi in ascending order ;
11
P k
d [i] ← ascending ;
12
P k
0 [i] ← pk
i1 ;
13
end
14
end
15
16 end
return P k
d , P k
0 , ∀ k ∈ {1, . . ., m}
Algorithm 1: One-shot dynamic optimization algorithm.
tunable parameters. The algorithm determines f k
pi1 and f k
pin
(the kth application metric objective function values) where
the parameter being explored Pi is assigned its ﬁrst pi1
and last pin tunable values, respectively, and the rest of the
tunable parameters Pj, ∀ j ̸= i are assigned initial values
(lines 3 - 4). δf k
Pi stores the difference between f k
pin and
f k
pi1 . δf k
Pi ≥ 0 means that pin results in a greater (or equal
when δf k
Pi = 0) objective function value as compared to pi1
for parameter Pi (i.e., the objective function value decreases
as the parameter value decreases). To reduce the number of
states explored while considering that an online optimization
algorithm (e.g., greedy-based algorithm) will typically stop
exploring a tunable parameter if a tunable parameter’s value
yields a comparatively lower (or equal) objective function
value, Pi’s exploration order must be descending (lines 6 -
8). The algorithm assigns pin as the initial value of Pi
for the kth application metric (line 9). If δf k
Pi < 0, the
algorithm assigns the exploration order as ascending for Pi
and pi1 as the initial value setting of Pi (lines 11 - 13). This
δf k
Pi calculation procedure is repeated for all m application
metrics and all N tunable parameters (lines 1 - 16).
III. APPLICATION METRIC ESTIMATION MODEL
In
this
section,
we
propose an
application
metric
estimation model leveraged by One-Shot. This estimation
model estimates high-level application metrics (lifetime,
throughput, reliability) from sensor node parameters (e.g.,
processor voltage and frequency, transceiver voltage, etc.).
For brevity, we describe only the estimation model’s key
elements.
289
UBICOMM 2010 : The Fourth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-100-7

A. Lifetime Estimation
Lifetime of a sensor node is deﬁned as the time duration
between the deployment time and the time before which
the sensor node fails to perform the assigned task due
to sensor node failure. The sensor failure due to battery
energy depletion is normally taken into account for lifetime
estimation. The sensor node typically contains AA alkaline
batteries whose energy depletes gradually as the sensor node
consumes energy during operation. The critical factors in
determining sensor node lifetime are battery energy and
energy consumption during operation.
The sensor node lifetime in days Ls can be estimated as:
Ls =
Eb
Ec × 24
(5)
where Eb denotes the sensor node’s battery energy (Joules)
and Ec denotes the sensor node’s energy consumption per
hour.
We
model
Ec
as
the
sum
of
processing
energy,
communication energy, and sensing energy:
Ec = Eproc + Ecom + Esen (J)
(6)
where Eproc, Ecom, and Esen denote processing energy per
hour, communication energy per hour, and sensing energy
per hour, respectively.
The processing energy accounts for the energy consumed
in processing the sensed data by the sensor node’s processor.
We assume that the sensor node’s processor operates in
two modes: active mode and idle mode [12]. We point out
that although we only consider active and idle modes, a
processor operating in other sleep modes apart from idle
mode (e.g., power-down, power-save, standby, etc.) can also
be incorporated in our model. Eproc is given by:
Eproc = Ea
proc + Ei
proc
(7)
where Ea
proc and Ei
proc denote the processor’s energy
consumption per hour in active mode and idle mode,
respectively.
The sensor nodes communicate with each other (e.g.,
send packets containing the sensed data), which consumes
communication energy. The communication energy is the
sum of transmission, receive, and idle energy for a sensor
node’s transceiver:
Ecom = Etx
trans + Erx
trans + Ei
trans
(8)
where Etx
trans, Erx
trans, and Ei
trans denote the transceiver’s
transmission energy per hour, receive energy per hour, and
idle energy per hour, respectively.
The energy consumption due to sensing the observed
phenomenon is termed as sensing energy. The sensing
energy
mainly
depends
upon
the
sensing
(sampling)
frequency and the number of sensors attached to the sensor
board (e.g., the MTS400 sensor board [13] has Sensirion
SHT1x temperature and humidity sensors [14]). The sensors
consume energy while taking sensing measurements and
switch to the idle mode for energy conservation while not
sensing. Esen is given by:
Esen = Em
sen + Ei
sen
(9)
where Em
sen denotes the sensing measurement energy per
hour and Ei
sen denotes the sensing idle energy per hour.
B. Throughput Estimation
In the context of dynamic optimizations, throughput can
be interpreted relative to the state (tunable parameter
value
settings)
that
deliver
the
maximum
quality
(rate) sensing process, processing, and transmission to
observe a phenomenon while minimizing the cost (energy
consumption). Three processes contribute to the throughput
for sensor nodes: sensing, processing, and communication.
The throughput interpretation may vary depending upon
the WSN application design as these throughputs can have
different relative importance for different applications. The
aggregate throughput R (typically measured in bits/second)
can be considered as a weighted sum of constituent
throughputs:
R = ωsRsen+ωpRproc+ωcRcom : ωs+ωp+ωc = 1 (10)
where
Rsen,
Rproc,
and
Rcom
denote
the
sensing
throughput, processing throughput, and communication
throughput, respectively. ωs,
ωp,
and
ωc
denote
the
weight factors for sensing, processing, and communication
throughput, respectively.
The sensing throughput is the throughput due to sensing
activity and measures the sensing bits sampled per second.
Rsen is given by:
Rsen = Fs · Rb
sen
(11)
where Fs and Rb
sen denote sensing frequency and sensing
resolution bits, respectively.
The processing throughput is the throughput due to
the processor’s processing of sensed measurements and
measures the bits processed per second. Rproc is given by:
Rproc = Fp/N b
(12)
where Fp and N b denote processor frequency and the
number of processor instructions to process one bit,
respectively.
The communication throughput Rcom results from the
transfer of data packets over the wireless channel and is
given by:
Rcom = P eff
s
× 8/tpkt
tx
(13)
where tpkt
tx denotes the time to transmit one packet and P eff
s
denotes the effective packet size excluding the packet header
overhead.
290
UBICOMM 2010 : The Fourth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-100-7

C. Reliability Estimation
The reliability metric measures the number of packets
transferred reliably (i.e., error free packet transmission)
over the wireless channel. Accurate reliability estimation
is
challenging
because
the
various
factors
involved
change dynamically, such as network topology, number of
neighboring sensor nodes, wireless channel fading, sensor
network trafﬁc, packet size, etc. The two main factors
that affect reliability are transceiver transmission power
Ptx and receiver sensitivity. For example, the AT86RF230
transceiver [15] has a receiver sensitivity of -101 dBm with
corresponding packet error rate (PER) ≤ 1% for additive
white Gaussian noise (AWGN) channel with physical service
data unit (PSDU) equal to 20 bytes. Reliability can be
estimated using Friis free space transmission equation [16]
for different Ptx values, distance between transmitting
and receiving sensor nodes, and fading models (e.g.,
shadowing fading model). Reliability values can be assigned
corresponding to Ptx values such that the higher Ptx values
give higher reliability. However, more accurate reliability
estimation requires proﬁling statistics for the number of
packets transmitted and the number of packets received.
IV. EXPERIMENTAL RESULTS
A. Experimental Setup
We base our experimental setup on the Crossbow IRIS
mote platform [17], which has a battery capacity of 2000
mA-h with two AA alkaline batteries. The IRIS mote
platform integrates an Atmel ATmega1281 microcontroller
[12], an Atmel AT-86RF230 low power 2.4 GHz transceiver
[15], an MTS400 sensor board [13] with Sensirion SHT1x
temperature and humidity sensors [14].
We analyze six tunable parameters: processor voltage
Vp,
processor
frequency
Fp,
sensing
frequency
Fs,
packet size Ps, packet transmission interval Pti, and
transceiver transmission power Ptx. In order to evaluate
our methodology across small and large design spaces, we
consider two design space cardinalities (number of states in
the design space): |S| = 729 and |S| = 31, 104 (|S| = 729
is a subset of |S| = 31, 104). The tunable parameters for
|S| = 31, 104 are Vp = {1.8, 2.7, 3.3, 4, 4.5, 5} (volts), Fp
= {2, 4, 6, 8, 12, 16} (MHz) [12], Fs = {0.2, 0.5, 1, 2, 3,
4} (samples per second) [14], Ps = {32, 41, 56, 64, 100,
127} (bytes), Pti = {10, 30, 60, 300, 600, 1200} (seconds),
and Ptx = {-17, -3, 1, 3} (dBm) [15]. All state space tuples
are feasible for |S| = 729, whereas |S| = 31, 104 contains
7,779 infeasible state space tuples (e.g., all Vp and Fp pairs
are not feasible).
We model three application domains (a security/defense
system (S/D), a health care application (HC), and an ambient
conditions monitoring application (AC)) to evaluate the
robustness of One-Shot across different applications. We
assign objective function parameter values such as minimum
and maximum values of application metrics and their
associated weight factors considering typical application
requirements [18].
In order to evaluate One-Shot’s solution quality, we
compare the solution from One-Shot’s initial parameter
settings I with the solutions obtained from the following
four potential initial parameter value settings (although any
feasible n-tuple s ∈ S can be taken as the initial parameter
settings): I1 assigns the ﬁrst parameter value for each
tunable parameter (i.e., I1 = pi1, ∀ i ∈ {1, 2, . . ., N}); I2
assigns the last parameter value for each tunable parameter
(i.e., I2 = pin,
∀ i ∈ {1, 2, . . ., N}); I3 assigns the
middle parameter value for each tunable parameter (i.e.,
I3 = ⌊pin/2⌋, ∀ i ∈ {1, 2, . . ., N}); I4 assigns a random
value for each tunable parameter (i.e., I4 = piq : q =
rand() % n, ∀ i ∈ {1, 2, . . ., N}).
B. Results
We implemented One-Shot in C++. We compare our
results with four different initial parameter arrangements
(Section IV-A) and normalize the objective function value
corresponding to the operating state attained by One-Shot
with respect to the optimal solution obtained using an
exhaustive search. We compare the relative complexity
of
One-Shot
with
two
other
dynamic
optimization
methodologies.
1) Percentage Improvements over other Initial Parameter
Settings:
Table I depicts the percentage improvements
attained by One-Shot parameter settings I over other
parameter settings for different application domains. We
observe that some arbitrary settings may give a comparable
solution for a particular application domain, application
metric weight factors, and design space cardinality, but
that arbitrary setting would not scale to other application
domains, application metric weight factors, and design space
cardinalities. For example, I1 achieves the same solution
quality as of I for AC, but yields 73.27% and 147.87%
lower quality solutions than I for HC and S/D, respectively,
for |S| = 31, 104. Furthermore, I1 yields a 51.85% lower
quality solution than I for AC when |S| = 729. The average
percentage improvement attained by I over all application
domains and design spaces is 44.79%. In summary, results
reveal that on average I gives a solution within 5.92% of
the optimal solution obtained from exhaustive search.
2) Comparison with Greedy- and SA-based Dynamic
Optimization Methodologies: In order to investigate the
effectiveness of One-Shot, we compare the One-Shot
solution’s quality (indicated by the attained objective
function value) with two
other dynamic optimization
methodologies, which leverage SA-based and greedy-based
(denoted by GDasc where asc stands for ascending order of
parameter exploration) design space exploration. We assign
initial parameter value settings for greedy and SA-based
methodologies as I1 and I4, respectively. For brevity we
291
UBICOMM 2010 : The Fourth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-100-7

Table I
PERCENTAGE IMPROVEMENTS ATTAINED BY I OVER OTHER INITIAL PARAMETER SETTINGS FOR |S| = 729 AND |S| = 31, 104.
−
|S| = 729
|S| = 31, 104
Application Domain
I1
I2
I3
I4
I1
I2
I3
I4
Security/Defense System (S/D)
154.9%
10.25%
56.62%
29.18%
147.87%
0.318%
9.72%
91.88%
Health Care (HC)
77.6%
6.66%
30.73%
10.86%
73.27%
0.267%
9.62%
45.17%
Ambient Conditions Monitoring (AC)
51.85%
6.17%
20.39%
6.85%
0%
75.5%
50.97%
108.31%
1 
2 
3 
4 
5 
6 
7 
8 
9 
10
11
12
50
100
400
0  
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1  
Number of States Explored
Normalized Objective Function
 
 
One−Shot
GDasc
SA
Figure 2.
Objective function value normalized to the optimal solution for
S/D where ωl = 0.25, ωt = 0.35, ωr = 0.4, |S| = 729.
1 
2 
3 
4 
5 
6 
7 
8 
9 
10
11
12
50
100
400
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Number of States Explored
Normalized Objective Function
 
 
One−Shot
GDasc
SA
Figure 3.
Objective function value normalized to the optimal solution for
HC where ωl = 0.25, ωt = 0.35, ωr = 0.4, |S| = 31, 104.
present results for I1 and I4, but results for I2 and I3
revealed similar trends.
Fig. 2 shows the objective function value normalized to
the optimal solution versus the number of states explored for
One-Shot, GDasc, and SA algorithms for S/D for |S| = 729.
One-Shot’s solution is within 1.8% of the optimal solution.
The ﬁgure shows that GDasc and SA explore 11 states
(1.51% of the design space) and 10 states (1.37% of the
design space), respectively, to attain an equivalent or better
quality solution than the One-Shot solution. Although greedy
and SA explore few states to reach a comparable solution
as that of One-Shot, One-Shot is suitable when design
space exploration is not an option due to an extremely
large design space and/or extremely stringent computational,
memory, and timing constraints. These results reveal that
other arbitrary initial value settings do not provide a good
quality operating state and necessitate additional design
space exploration to provide a good quality operating state.
Fig. 3 shows the objective function value normalized to
1 
2 
3 
4 
5 
6 
7 
8 
9 
10
11
12
50
100
400
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Number of States Explored
Normalized Objective Function
 
 
One−Shot
GDasc
SA
Figure 4.
Objective function value normalized to the optimal solution for
AC where ωl = 0.4, ωt = 0.5, ωr = 0.1, |S| = 729.
the optimal solution versus number of states explored for
HC for |S| = 31, 104. One-shot’s solution is within 1.5% of
the optimal solution. The ﬁgure shows that GDasc converges
to a lower quality solution than One-Shot’s solution after
exploring 8 states (0.026% of the design space) and SA
explores 6 states (0.019% of the design space) to yield
a better quality solution than One-shot’s solution. These
results reveal that the greedy exploration of parameters may
not necessarily attain a better quality solution than One-Shot.
Fig. 4 shows the objective function value normalized
to the optimal solution versus number of states explored
for AC for |S| = 729. One-Shot solution is within 7.7%
of the optimal solution. The ﬁgure shows that GDasc and
SA converge to an equivalent or better quality solution
than One-Shot solution after exploring 4 states (0.549%
of the design space) and 10 states (1.37% of the design
space), respectively. These results show that greedy and SA
can provide improved results over One-Shot, but require
additional state exploration.
3) Computational Complexity: To verify that One-Shot
(Section II) is lightweight, we compared the data memory
requirements and execution time of One-Shot with greedy-
and SA-based dynamic optimization methodologies.
The data memory analysis revealed that One-Shot requires
only 150, 188, 248, and 416 bytes for (number of tunable
parameters N, number of application metrics m) equal
to (3, 2), (3, 3), (6, 3), and (6, 6), respectively. Greedy
requires 458, 528, 574, 870, and 886 bytes, whereas SA
requires 514, 582, 624, 920, and 936 bytes of storage
for |S| = 8, 81, 729, 31104, 46656, respectively. The data
memory analysis shows that SA has comparatively larger
memory requirements than greedy. Our analysis reveals
that the data memory requirements for One-Shot increases
292
UBICOMM 2010 : The Fourth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-100-7

linearly as the number of tunable parameters and the
number of application metrics increases. The data memory
requirements for greedy and SA increases linearly as the
number of tunable parameters and tunable values (and thus
the design space) increases. The data memory analysis
veriﬁes that although One-Shot, greedy, and SA have
low data memory requirements (on the order of hundreds
of bytes), One-Shot requires 203.94% and 457.94% less
memory on average as compared to greedy and SA,
respectively.
We measured the execution time for One-Shot, greedy,
and SA
averaged over 10,000 runs (to
smooth any
discrepancies in execution time due to operating system
overheads) on an Intel Xeon CPU running at 2.66 GHz [19]
using the Linux/Unix time command [20]. We scaled the
execution time to the Atmel ATmega1281 microcontroller
[12] running at 8 MHz. Although microcontrollers have
different instruction set architectures and scaling does not
provide 100% accuracy, scaling enables relative comparisons
and provides reasonable runtime estimates. Results showed
that One-Shot required 1.66 ms both for |S| = 729 and
|S| = 31, 104. Greedy explored 10 states and required 0.887
ms and 1.33 ms on average to converge to the solution for
|S| = 729 and |S| = 31, 104, respectively. SA took 2.76 ms
and 2.88 ms to explore the ﬁrst 10 states (to provide a fair
comparison with greedy) for |S| = 729 and |S| = 31, 104,
respectively. The execution time analysis revealed that
our dynamic optimization methodologies required execution
times on the order of milliseconds, and One-Shot required
18.325% less execution time on average as compared to
greedy and SA. One-Shot required 66.26% and 73.49% less
execution time than SA when |S| = 729 and |S| = 31, 104,
respectively. These results indicate that the design space
cardinality affects the execution time linearly for greedy
and SA whereas One-Shot’s execution time is affected
negligibly by the design space cardinality and hence One-
Shot’s advantage increases as the design space cardinality
increases.
V. CONCLUSIONS AND FUTURE WORK
In this paper, we proposed One-Shot – a dynamic
optimization methodology for highly-constrained WSNs that
provides a high-quality operation state using intelligent
initial tunable parameter value settings. We also proposed
an application metric estimation model to estimate high-
level metrics from sensor node parameters. This estimation
model
was
leveraged
by
One-Shot
and
provided
a
prototype model for application metric estimation. To
evaluate the effectiveness of initial parameter settings,
we compared One-Shot’s solution quality with four other
typical initial parameter settings. Results revealed that
the percentage improvement attained by One-Shot over
other initial parameter settings was as high as 154.9%
and within 5.92% of the optimal solution. Computational
complexity analysis revealed that One-Shot used 203.94%
and 457.94% less memory and required 18.325% less
execution time on average as compared to greedy- and
SA-based methodologies. Execution time and data memory
analysis conﬁrmed that One-Shot is lightweight and suitable
for time-critical or highly constrained applications.
Future work includes incorporating proﬁling statistics into
One-Shot to provide feedback with respect to changing
environmental stimuli.
ACKNOWLEDGMENTS
This work was supported by the National Science
Foundation (CNS-0834080). Any opinions, ﬁndings, and
conclusions or recommendations expressed in this material
are those of the author(s) and do not necessarily reﬂect the
views of the National Science Foundation.
REFERENCES
[1] K. Hazelwood and M. Smith, “Managing Bounded Code Caches in Dynamic
Binary Optimization Systems,” ACM Trans. on Architecture and Code Opti-
mization, vol. 3, no. 3, pp. 263–294, Sep. 2006.
[2] S. Hu, M. Valluri, and L. John, “Effective Management of Multiple Conﬁg-
urable Units using Dynamic Optimization,” ACM Trans. on Architecture and
Code Optimization, vol. 3, no. 4, pp. 477–501, Dec. 2006.
[3] S. Patel and S. Lumetta, “rePLay: A Hardware Framework for Dynamic
Optimization,” IEEE Trans. on Computers, vol. 50, no. 6, pp. 590–608, June
2001.
[4] C. Zhang, F. Vahid, and R. Lysecky, “A Self-Tuning Cache Architecture for
Embedded Systems,” ACM Trans. on Embedded Computing Systems, vol. 3,
no. 2, pp. 407–425, May 2004.
[5] A. Shenoy, J. Hiner, S. Lysecky, R. Lysecky, and A. Gordon-Ross, “Evaluation
of Dynamic Proﬁling Methodologies for Optimization of Sensor Networks,”
IEEE Embedded Systems Letters, vol. 2, no. 1, pp. 10–13, Mar. 2010.
[6] A. Munir and A. Gordon-Ross, “An MDP-based Application Oriented Opti-
mal Policy for Wireless Sensor Networks,” in Proc. ACM CODES+ISSS’09,
October 2009.
[7] X. Wang and et al., “Distributed Energy Optimization for Target Tracking in
Wireless Sensor Networks,” IEEE Trans. on Mobile Computing, vol. 9, no. 1,
pp. 73–86, Jan. 2009.
[8] R. Khanna, H. Liu, and H.-H. Chen, “Dynamic Optimization of Secure Mobile
Sensor Networks: A Genetic Algorithm,” in Proc. IEEE ICC’07, June 2007.
[9] R. Min, T. Furrer, and A. Chandrakasan, “Dynamic Voltage Scaling Techniques
for Distributed Microsensor Networks,” in Proc. IEEE WVLSI’00, April 2000.
[10] L. Yuan and G. Qu, “Design Space Exploration for Energy-Efﬁcient Secure
Sensor Network,” in Proc. IEEE ASAP’02, July 2002.
[11] A. Gordon-Ross, F. Vahid, and N. Dutt, “Fast Conﬁgurable-Cache Tuning With
a Uniﬁed Second-Level Cache,” IEEE Trans. on Very Large Scale Integration
(VLSI) Systems, vol. 17, no. 1, pp. 80–91, Jan. 2009.
[12] Atmel, “ATMEL ATmega1281 Microcontroller with 256K Bytes In-System
Programmable Flash,” 2010. [Online]. Available: http://www.atmel.com/dyn/
resources/prod documents/2549S.pdf
[13] Crossbow, “MTS/MDA Sensor Board Users Manual,” July 2010. [Online].
Available: http://www.xbow.com/
[14] Sensirion, “Datasheet SHT1x (SHT10, SHT11, SHT15) Humidity and Tem-
perature Sensor,” July 2010. [Online]. Available: http://www.sensirion.com/
[15] Atmel,
“ATMEL
AT86RF230
Low
Power
2.4
GHz
Transceiver
for
ZigBee,
IEEE
802.15.4,
6LoWPAN,
RF4CE
and
ISM
Applications,”
July 2010. [Online]. Available: http://www.atmel.com/dyn/resources/prod
documents/doc5131.pdf
[16] H. Friis, “A Note on a Simple Transmission Formula,” Proc. IRE, vol. 34, p.
254, 1946.
[17] Crossbow, “Crossbow IRIS Datasheet,” July 2010. [Online]. Available: http:
//www.xbow.com/
[18] I. Akyildiz and et al., “Wireless Sensor Networks: A Survey,” Elsevier
Computer Networks, vol. 38, no. 4, pp. 393–422, Mar. 2002.
[19] “Intel
Xeon Processor
E5430,” July
2010. [Online].
Available: http://
processorﬁnder.intel.com/details.aspx?sSpec=SLANU
[20] “Linux Man Pages,” July 2010. [Online]. Available: http://linux.die.net/man/
293
UBICOMM 2010 : The Fourth International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies
Copyright (c) IARIA, 2010               ISBN: 978-1-61208-100-7

