A Practical Method for the Reachability Analysis of Real-Time Systems Modelled as
Timed Automata
Abdeslam En-Nouaary and Rachida Dssouli
ECE Department, Concordia University
Montreal, Canada
{ennouaar,dssouli}@ece.concordia.ca
Abstract—Real-time systems (RTSs) interact with their en-
vironment under time constraints.
Such constraints are so
critical because any deviation from the speciﬁed deadlines
might have severe consequences on both the human lives and
the environment. To develop reliable RTSs, formal methods
should be used along the development life cycle. Veriﬁcation is
one of these formal methods, which aims at ensuring that the
system is correct before its deployment. This paper presents a
new veriﬁcation method for the reachability analysis of real-
time systems modelled as timed automata (TA) [1]. The paper
basically addresses two main issues: are all the transitions of
the system executable? Are all the locations reachable from
the initial location of the system? In order to answer these
questions, our method uses a metric that gives the minimum
delay between any state and all the transitions leaving that
state.
Keywords-Real-Time systems, Formal Methods, Timed Au-
tomata, Veriﬁcation, Reachability Analysis.
I. INTRODUCTION
Over the past two decades, many researchers have been
investigating the veriﬁcation and validation of real-time
systems with different backgrounds. As a result, several
veriﬁcation methods have been devised to make sure that
the system functions properly before its deployment. These
veriﬁcation techniques attempt to check if the speciﬁcation
of the system satisﬁes some desirable functional and
performance properties. All the veriﬁcation and validation
techniques rely on the use of formal models to describe the
behaviour of the systems being investigated (see for instance
[2], [3], [4], [5], [6], [7], [8], [9]). In the case of real-time
systems, timed automata model [1] is intensively used by
researchers to develop veriﬁcation and testing techniques.
Although, existing veriﬁcation methods and tools (see for
instance [2], [3], [4], [5]) provide successful results for
RTSs, most of them suffer from the state explosion problem
and are a bit complicated to use. This is mainly due to
the fact that most of the proposed techniques are based
on either the region graph [1] or the zone graph [10] as
semantics for timed automata. So, the need for practical
veriﬁcation and validation methods still exists.
In this paper, we present a new method for the reachability
analysis of RTSs modelled as timed automata.
We are
basically addressing two main issues: are all the transitions
of the system executable? Are all the locations reachable
from the initial location of the system? In order to answer
these questions, our method uses a metric that gives the
minimum delay between any state and all the transitions
leaving that state.
Our method presents two advantages.
On the one hand, it automatically calculates on the ﬂy the
paths that ensure the reachability of the transitions and
locations. On the other hand, it avoids the costly operation
of constructing the region graph of the timed automata.
The remainder of this paper is organized as follows.
Section 2 presents the timed automata model and its related
concepts. Section 3 introduces our contributions. Section 4
concludes the paper and presents future work.
II. BACKGROUND
This section presents the deﬁnitions and concepts required
for introducing our method. We basically present the timed
automata model and the related theoretical results illustrated
with simple examples.
Deﬁnition 1: Timed Automata (TA)
A TA A is a 5−tuple (Σ, L, l0, C, T ), where :
• Σ is a ﬁnite set of inputs and output messages. In this
paper, inputs begin with ”?” while outputs start with
”!”.
• L is a ﬁnite set of locations.
A location represents
the ”status” of the system after the execution of a
transition.
The term location is used instead of the
term ”state”’ because the latter is used to deﬁne the
operational semantics of the TA.
• l0 ∈ L is the initial location where the execution of the
TA starts.
• C is a ﬁnite set of clocks, all initialized to zero in l0.
A clock is a time variable that counts how much time
has elapsed since the clock was (re-)initialized to zero.
• T ⊆ L×Σ×Φ(C)×P(C)×L is the set of transitions,
where Φ(C) and P(C) denote the set of clock guards
and the power set of C, respectively.
A transition in a TA, denoted by t : l
m,G,R
−→ l′, consists of
a source location l (i.e., source(t) = l), an input or output
287
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

message m, a clock guard (or time constraint) G, which
should hold to execute the transition, a subset of clocks R
to be reset when the transition is ﬁred, and a destination
location l′ (i.e., destination(t) = l′).
Each clock in R
(R ⊆ C) is used to record, when not reinitialized to zero,
how much time has elapsed since the execution of the
transition. Such clocks are mainly used to set clock guards
between the transition where they are reset and future
transitions.
A sequence of consecutive transitions that starts at a
location l and ends at a location l′ is called a path from l
to l′; we write path(l, l′) = t1.t2...tn, where ti ∈ T for
1 ≤ i ≤ n, and source(t1) = l, destination(tn) = l′
and source(ti) = destination(ti−1) for 2 ≤ i ≤ n.
Since paths in TA are made of transitions with clock
guards that could be conﬂicting (i.e., they cannot be
satisﬁed by the same values of clocks) one can easily see
that a path might not be executable.
Hence, ﬁnding an
executable path from one location to another requires, as
explained later on in this paper, a systematic approach
and a deeper investigation as to how messages and clock
values should be chosen to ﬁre the transitions of the system.
We assume that the transitions in a TA are instantaneous
(i.e., they don’t take time to execute).
Also, the clock
guards of the transitions are supposed to be conjunctions
of atomic formulas of the form (b1 op1 x op2 b2), where
x ∈ C, (op1, op2) ∈ {<, ≤, =}, and b1 and b2 are
natural numbers.
Multiple clocks are used in the TA to
express time constraints between more than two transitions.
Each clock, x ∈ C, in a TA takes real number values
and has a bounded domain [0, Bx] ∪ {∞}, as stated
by Springintveld et.
al.
[11], where Bx is the largest
integer constant appearing in the time constraints over
clock x in the automaton.
This means that each clock
x is relevant only under the integer constant Bx, and
all the values of x greater than Bx are represented by
∞; Hence, we write : ∀ϵ > 0, Bx+ϵ = ∞ and ∞+ϵ = ∞.
For a clock x and a clock guard G of a transition in a TA,
we deﬁne the projection of G over x, written Proj(G, x), by
the condition (b1 op1 x op2 b2) in G, obtained by removing
the conditions over all the clocks except x; if clock x is not
involved in G then Proj(G, x) = true.
Example 1: Figure 1 shows a TA for a speciﬁcation of
a simple telephone system. The system waits for the user
to hang up, get the dial tone and dial two digits Digit1
and Digit2; then the system issues the output Connect, to
indicate that the connection has been established and the user
can start talking. At the end, the user lifts the phone to allow
the system to go back to its initial location. The behaviour
of the system is subject to several time constraints. On the
one hand, the user should type the ﬁrst digit 1 to 3 time-
Figure 1.
An Example of TA.
units after getting the tone and the second digit no more
than 2 time-units after the ﬁrst digit; the dialling operation
(from getting the tone until dialing the last digit) should not
exceed 5 time-units. On the other hand, the system must
respond with the signal T one within 1 time-unit after the
user hangs up, and with Connect within 1 time-unit after
the last digit has been typed. Whenever the time constraint
of an input is not respected, the system times out, issues an
error message and goes back to its initial location.
The TA model introduced thus far is an abstract model
because it does not explain the execution of the system
it describes.
The executions, also called the operational
semantics or the region graph of the TA, can be informally
stated as follows.
The TA starts at its initial location
with all clocks initialized to zero.
Then, the values of
the clocks increase at the same speed and measure the
amount of time elapsed since the last (re-)initialization.
At any time, the TA can execute a transition l
m,G,R
−→
l′
if the input/output message m takes place, its current
location is l, and the values of its clocks satisfy the
clock guard G.
After this transition, all the clocks in
R are reset and the TA changes its location to l′.
To
formalize the operational semantics of the TA, we need to
deﬁne the concepts of clock valuations and states for the TA.
Deﬁnition 2: Clock valuations
Let A = (Σ, L, l0, C, T ) be a n−clocks TA (i.e., an TA with
n clocks), R≥0 be the set of non-negative real numbers.
• A clock valuation of A (or over C) is a function v :
C → [R≥0 ∪ {∞}]n, which assigns a positive value
to each clock x ∈ C.
A clock valuation is simply
the binding of clocks to their actual values. In this
paper, a clock valuation is represented by a vector
(vx1, vx2, .., vxn), where v(xi) = vxi is the value of
clock xi, 1 ≤ i ≤ n. The set of all clock valuations of
A is referred to by V (C).
• For any clock valuation v ∈ V (C) and any non-
negative real number d, v + d is a clock valuation that
assigns the value v(x) + d to each clock x ∈ C. v + d
288
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

is the clock valuation reached from v by letting time
elapse by d time units.
• For any clock valuation v ∈ V (C) and any subset of
clocks R ⊆ C, [R := 0]v is a clock valuation that
assigns the value 0 to each clock x ∈ R and v(x) to
any other clock (i.e., y ∈ C and y /∈ R. [R := 0]v
is the clock valuation obtained from v by resetting the
clocks in R when a transition l
m,G,R
−→ l′ is executed.
• A clock valuation v ∈ V (C) satisﬁes the clock guard
G of a transition l
m,G,R
−→ l′, denoted by v |= G, if and
only if G holds under v.
Informally speaking, a clock valuation is an interpretation
of clocks, which allows us to know at any time the value of
each clock used in the TA. In other words, a clock valuation
can be used to determine how much time has elapsed since
the execution of each transition that has last reinitialized a
clock. The combination of a clock valuation and a location
deﬁnes a state of the TA. The formal deﬁnition of such
states follows.
Deﬁnition 3: States of the TA
Let A = (Σ, L, l0, C, T ) be a TA.
• A state of A is a pair (l, v) consisting of a location
l ∈ L and a clock valuation v ∈ V (C). Intuitively, a
state of A is a conﬁguration that indicates the current
location of A and the current value of each clock used
in A.
• The initial state of A is the pair (l0, v0), where v0(x) =
0 for each clock x ∈ C. Intuitively, the initial state
of A is the conﬁguration of A in the beginning of its
execution (i.e., the location is l0 and all clocks are set
to 0 as stated in Deﬁnition 1).
• The set of states of A is denoted by S(A).
Example 2: To illustrate the concepts of clock valuations
and states, let us consider again the TA of Figure 1. The
number of clocks in this TA is 2, namely clocks x and
y.
So, a clock valuation, here, consists of assigning a
non-negative real number or ∞ to each of the clocks x
and y. Examples of such clock valuations are v0 = (0, 0),
v1 = ( 1
4, 1
4) and v2 = ( 1
2, 3
2). The set of the states of this
TA is the set of all the pairs obtained by combining the
locations and the clock valuations of the TA. Examples of
such states are s0 = (l0, v0), s1 = (l1, v1) and s2 = (l3, v2),
where l0, l1, and l3 are the locations of the TA, and v0,
v1, and v2 are the clock valuations explained in this example.
Formally, the operational semantics of a TA is described
by a state machine M = (S, s0, A, T ), where S is the set of
states of the TA, s0 is the initial state, A is the set of actions,
and T is the set of transitions. The actions of M are made
up of the input and output messages of the TA as well as the
time delays (i.e., A = Σ∪[R≥0 ∪ {∞}]n). Hence, there are
two categories of transitions in M: The explicit transitions
on input and output messages, and the implicit transitions
on time delays. The explicit transitions are obtained from
the transitions of the TA and they describe the interactions
of the system with its environment. The explicit transitions
do not contain time constraints because the clock valuations
of their source states do satisfy their clock guards. On the
other hand, the delay transitions describe the progression of
time but they do not appear in the transitions of the TA.
The operational semantics of timed automata helps us deﬁne
the concepts of traces for real-time systems as follows. A
trace for a real-time system is a sequence of input and
output messages as well as time delays that starts at the
initial state of the system and ends at one of its reachable
state. It basically reﬂects an execution of the system on
some input and output messages when the clock guards
of the corresponding transitions are satisﬁed by the values
of the clocks upon the occurrence of the messages.
For
instance, the trace ?m1. 1
2.?m2.3.!m3 means that when the
system starts its execution it immediately accepts the input
message m1, waits 1
2 time-unit before accepting the input
m2, and then waits 3 time-units before responding with an
output message m3.
III. OUR METHOD FOR THE REACHABILITY ANALYSIS
OF TIMED AUTOMATA
This section introduces our method for the reachability
analysis of real-time systems modelled as timed automata.
The two main issues dealt with in this paper are:
the
reachability of the locations from the initial location of
the system and the executability of the transitions of the
system. The objective of the former issue is to check if every
location of the system is reachable from its initial location.
However, the objective of the latter issue is to check if every
transition of the system is executable.
To address these
issues, we propose a metric that determines the minimum
delay between each state and each of its outgoing transitions.
We also present an algorithm to implement the metric in
order to decide the reachability issues automatically. The
minimum delay between a state and a transition represents
the minimum waiting time required at the state in order to
execute the transition. It basically reﬂects the point of time
right after the execution of the transition was impossible (i.e.,
as soon as the transition becomes executable). Formally, the
minimum delay between a state s = (l, v) and a transition
t = l
m,G,R
−→
l′, written delaymin(s, t), is calculated as
follows:
delaymin(s, t)
=
Maxx∈C{0, delaymin(v(x), φ(x))},
where:
• φ(x) = Proj(G, x) is the projection of the transition’s
guard over the clock x, as explained in Section II,
• v(x) is the value of the clock x at state s, and
• delaymin(v(x), φ(x)) is the minimum waiting time at
state s for clock x to satisfy its time constraint φ(x):
289
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

delaymin(v(x), φ(x)) =











m1 − v(x) + ϵ if φ(x) is
(m1 < x ≤ m2)
m1 − v(x) if φ(x) is
(x = m1) or (m1 ≤ x ≤ m2)
0 if φ(x) is true
ϵ is a small positive real value chosen by the designer.
It is a parameter, which helps him/her specify how
far from the lower bound of the open clock guard the
transition should be executed.
Example 3: Let us consider again the telephone system of
Figure 1 and suppose that the designer chooses epsilon = 1
4.
For the states s0 = (l0, (0, 0)) and s1 = (l2, ( 1
4, 1
4)), and the
transitions t1 and t3, we have:
• delaymin(s0, t1) = Max{0, delaymin(0, true), delaymin
(0, true)} = Max{0, 0, 0} = 0.
• delaymin(s1, t3) = Max{0, delaymin( 1
4, 1 < x <
3), delaymin( 1
4, 0 < y < 5)} = Max{0, 1
2, 0} = 1
2.
Now, we explain how we address the reachability is-
sues aforementioned.
To deal with the reachability of
the locations of the system, we proceed as follows.
Let
A = (Σ, L, l0, C, T ) be a TA and l be a location of A (i.e.,
l ∈ L). l is said to be reachable from the initial location
of the TA if and only if there exists an executable path,
path(l0, l), from l0 to l in A.
There are at least three
different ways to ﬁnd an executable path from the initial
location l0 to another location l in the TA:
• The ﬁrst method consists of ﬁrst extracting all the paths
from l0 to l and then choosing the shortest one (i.e.,
the path with the least number of transitions).
• The second method consists of, as the ﬁrst method,
extracting all the paths from l0 to l and then choosing
randomly one of them.
• The third method consists of extracting on the ﬂy only
one path from l0 to l according to some metrics that
minimize either the number of the transitions in the
path or the time it takes to execute the path.
The ﬁrst two methods have the disadvantage of being
costly because they have to extract all the paths from l0
to l.
Moreover, the chosen path (either the shortest one
or the randomly selected one) might not be executable
because of the conﬂicting clock guards of its transitions
and hence the resulting path could be useless. The third
method is less costly than the two others because it does
not rely on the extraction of all the paths from l0 to l.
However, if the minimization adopted is with regard to the
number of the transitions in the selected path then we will
have no guarantee about the executability of the path, all
as for the ﬁrst and the second methods. Hence, the best
way to choose and ensure an executable path from l0 to l
is to extract it on the ﬂy by minimizing the time it takes
to execute the path. This can be done by using the metric
delaymin() introduced so far.
More precisely, to get an
executable path(l0, l), we have to start at the initial state
(l0, v0) and calculate the minimum time delay to execute
each transition leaving l0 and decide which one should be
added to the path. Then, we compute the resulting states
and repeat the process on the new states until we reach l.
Similarly, to address the executability of a transition we
have to ﬁnd an executable path from the initial location to the
source location of the transition, and use the minimum time
delay in order to calculate at least one time point that makes
the transition executable from the last reached state from the
path. In order to ensure an executable path from l0 to the
source location of the transition, we follow the same process
described previously when dealing with the reachability of
the locations of the TA. Regarding the time point that makes
the transition executable, we calculate it using the minimum
time delay between the last reached state in the path for
the transition, and the transition being checked. Formally
speaking, let A = (Σ, L, l0, C, T ) be a TA and t = l
m,G,R
−→ l′
be a transition of A. t is said to be executable if and only
if:
• source(t) is reachable from the initial location l0 and
the resulting state is s = (source(t), v), and
• (v + delaymin(s, t)) satisﬁes the clock guard of t (i.e.,
(v + delaymin(s, t)) |= G).
It should also be noted that a location l is reachable if
and only if there exists t ∈ T such that destination(t) = l
and t is executable. Likewise, if a location l is not reachable
then all the transitions leaving l are non-executable (i.e.,
for all t ∈ T such that source(t) = l the transition t is
non-executable).
The algorithm used to check the reachability of the
locations and transitions of the TA is shown below. The
algorithm takes as input the TA and returns a Boolean
value for each location and each transition that says
whether or not the location (respectively the transition) is
reachable (respectively executable). The algorithm starts by
calculating the initial state of the TA and initializing all
the variables to be used, namely RS (the set of reachable
states) and HS (the set of the handled states among RS).
Then, it goes through all the states in RS and handles all
the outgoing transitions from each of these states. Indeed,
for each reachable state, the algorithm checks all of the
outgoing transitions from the location of the state and
veriﬁes if they are executable by calculating the minimum
delay between the state and each of the transitions. If the
clock guard of a transition is satisﬁed by the clock valuation
of the current state plus the minimum delay calculated
previously then the transition (respectively its destination
290
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

location) is marked as being executable (respectively
reachable), and the resulting state is calculated and added
to RS if it is not already there.
When the algorithm
terminates the handling of all the reachable states (i.e., all
the states in RS), it goes through all the locations and
transitions to check if they have been marked so far. If a
location has not been marked then the location is declared
unreachable. Likewise, if a transition has not been marked
then the transition is declared non-executable. It should be
noted that the algorithm does not construct the region graph
[1] of the TA but calculates on the ﬂy only one state for
each transition in the TA. That state is obtained using the
metric delaymin(s, t) introduced in the beginning of this
section. Hence, the proposed approach has the advantage
of being scalable and rapid compared to existing methods
that are based on the construction of either the region graph
[1] or the zone graph [10] of the TA. We implemented the
algorithm in Java and promising results are obtained for
speciﬁcations with different sizes. The presentation of the
tool and the analysis of the experimentation results are left
for a future publication.
Algorithm 1: Our Algorithm for the Reachability Anal-
ysis of a TA.
ReachabilityAnalysis(INPUT: TA)
s0 ← (l0
A, v0) // (v0(x) = 0 for every clock x in the
TA).
RS ← s0. // RS is the set of reachable states of the
TA.
HS ← ∅. // HS is the set of handled states of the TA.
while (RS ̸= HS) do
Pick one state (s : (l, v) ∈ RS) not yet processed.
Add s to HS.
foreach (transition t : l
m,G,R
−→ l′ in the TA) do
Calculate δ = delaymin(s, t).
if ((v + δ) |= G) then
Add the state (l′, [R := 0](v + δ)) to RS if
not yet there.
Mark the location l′ and the transition t in
the TA as they are reached.
foreach (location l ∈ L) do
if (l is not marked) then
l is not reachable
foreach (transition t ∈ T ) do
if (t is not marked) then
t is not executable
The complexity of the algorithm is Θ(|L| × |T |), where
|L| is the number of locations and |T | is the number of
transitions.
Indeed, the algorithm goes through all the
reachable states whose number is at most equal to |L|×|T |.
Each reachable state is handled only once and requires the
processing of only the transitions leaving the location of
the state. By adding up the number of these iterations we
get an order of Θ(|L| × |T |).
Example 4: Let us consider again the telephone system
of Figure 1.
By applying our algorithm, with ϵ =
1
4,
we get the results shown in Figure 2.
The ﬁrst table
gives for each location if it is reachable or not while the
second table determines for each transition if it is exe-
cutable or not. When a location (respectively, a transition)
is reachable (respectively executable) the tables show one
of the traces that make it possible.
By examining the
results in Figure 2, one can easily see that all the locations
(respectively all the transitions) of the system modelled in
Figure 1 are reachable (respectively executable). For each
reachable location, the corresponding trace is obtained by
extracting an executable path from the initial location to
the location. Similarly, for each executable transition the
corresponding trace is obtained by extracting an executable
path from the initial location to the source location of the
transition plus the time delay and the message to execute
the transition.
The executability of any path is ensured
based on the metric delaymin(), introduced so far.
For
instance, the location l4 is reachable and the transition
t4 : l3
?Digit3,0<x<2∧0<y<5,{x}
−→
l4 is executable because
the trace ?HangUp.1.!T one. 5
4.?Digit1. 1
4.?Digit2 makes
it possible for the system to move from its initial state
(l0, (0, 0)) to (l4, (0, 3
2)); the corresponding executable path
then is t1.t2.t3.t4.
Example 5: Let us now change the speciﬁcation of Figure
1 by changing the clock guards of the transitions t3 t4 and t8
to ((2 < x < 3)∧(0 < y < 3)), ((2 < x < 3)∧(0 < y < 3))
and (x = 3), respectively. Is it really easy to guess the
reachability analysis of the new system? It is not that simple!
By applying our algorithm, with ϵ = 1
4, we can see that the
transitions t4, t5, t9, t10 and t11 are non-executable, and the
locations l4 and l5 are non-reachable. Let us say why. The
minimum executable path to reach the location l3 (the source
location of the transition t4) is t1.t2.t3 and the corresponding
trace is ?HangUp.1.!T one. 9
4.?Digit1.
Hence, the state
that should be considered to execute the transition t4 is
s4 = (l3, (0, 9
4)), which gives delaymin(s4, t4) = 9
4. But,
by adding 9
4 to (0, 9
4) (i.e., the clock valuation of s4) we
obtain the clock valuation ( 9
4, 18
4 ) that does not satisfy the
clock guard ((2 < x < 3) ∧ (0 < y < 3)) (i.e., the clock
guard of t4).
Hence, the transition t4 is non-executable
and since t4 is the unique transition between l3 and l4
then the location l4 is not reachable.
Consequently, all
the transitions leaving l4 are non-executable, namely the
transition t5. Since t5 is the unique transition between l4 and
l5 then the location l5 is not reachable and all the transitions
leaving l5 become non-executable, namely t9, t10 and t11.
291
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

Loc.
Reach.
Corresponding Trace
(Y/N)
l0
Y
ϵ (the empty sequence)
l1
Y
?HangUp
l2
Y
?HangUp.1.!Tone
l3
Y
?HangUp.1.!Tone. 5
4.?Digit1
l4
Y
?HangUp.1.!Tone. 5
4.?Digit1. 1
4 .?Digit2
l5
Y
?HangUp.1.!Tone. 5
4.?Digit1. 1
4 .?Digit2.1
.!Connect
Trans.
Exec.
Corresponding Trace
(Y/N)
t1
Y
?HangUp
t2
Y
?HangUp.1.!Tone
t3
Y
?HangUp.1.!Tone. 5
4.?Digit1
t4
Y
?HangUp.1.!Tone. 5
4.?Digit1. 1
4.?Digit2
t5
Y
?HangUp.1.!Tone. 5
4.?Digit1. 1
4.?Digit2.1
.!Connect
t6
Y
?HangUp.1.!Tone.3.!Error
t7
Y
?HangUp.1.!Tone.5.!Error
t8
Y
?HangUp.1.!Tone. 5
4.?Digit1.2.!Error
t9
Y
?HangUp.1.!Tone. 5
4.?Digit1. 1
4.?Digit2.1
.!Connect. 1
4.?Talk
t10
Y
?HangUp.1.!Tone. 5
4.?Digit1. 1
4.?Digit2.1
.!Connect.4.!Error
t11
Y
?HangUp.1.!Tone. 5
4.?Digit1. 1
4.?Digit2.1
.!Connect.?Drop
Figure 2.
The Reachability Results for the TA in Figure 1.
IV. CONCLUSION
We presented in this paper a new veriﬁcation method for
the reachability analysis of real-time systems modelled as
timed automata. Our method addresses the reachability of
the locations and transitions of the system by calculating a
trace that allows the system to go from its initial state to
the location or transition being investigated. To this end,
the method uses a metric that gives the minimum delay
between any state and all the transitions leaving that state.
Our method has at least two advantages. On the one hand,
it automatically calculates on the ﬂy the paths that ensure
the reachability of the transitions and locations.
On the
other hand, it avoids the costly operation of constructing
the region graph of the TA, which makes the method more
scalable than the others. To help us quantify precisely the
gain of the method with respect to existing methods, we
implemented the method to conduct more experimentation
on TA speciﬁcations with different sizes. The tool and the
analysis of the experimentation results will be discussed in
a future paper.
We are currently working on two extensions of the
proposed method.
On the one hand, we would like to
make it incremental to adjust to successive evolutions of
the speciﬁcation either when designing the system the ﬁrst
time or later when maintaining the system. On the other
hand, we are investigating the possibility of adopting the
incremental method to the area of testing real-time systems
modelled as TA.
REFERENCES
[1] R. Alur and D. Dill. A Theory of Timed Automata. Theo-
retical Computer Science, 126:183–235, 1994.
[2] C. Daws, A. Olivero, S. Tripakis, and S. Yovine.
The
tool Kronos. In R. Alur, T.A. Henzinger, and E.D. Sontag,
editors, Hybrid Systems III, volume 1066 of Lecture Notes in
Computer Science, pages –. Springer-Verlag, 1995.
[3] J. Bengtsson, K.G. Larsen, F. Larsson, P. Pettersson, and
W. Yi. UPPAAL - a tool suite for automatic veriﬁcation of
real-time systems. In 4th. DIMACS Workshop on Veriﬁcation
and Control of Hybrid Systems, New Brunswick, New Jersey,
October 1995.
[4] T.A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine.
Symbolic model checking for real-time systems. Information
and Computation, 111:193–244, 1994.
[5] K.G. Larsen, P. Pettersson, and W. Yi.
Model-checking
for real-time systems.
In Proceedings of Fundamentals of
Computation Theory, pages –, Dresden, Germany, August
1995.
[6] Osmane Kon´e, Patrice Laurencot, and Richard Castanet.
On the Fly Test Generation for Real-Time Protocols.
In
International Conference on Computer Communications and
Networks, Lafayette, Louisiana, USA, pages 378–387, 1998.
[7] Brian Nielsen and Arne Skou. Automated Test Generation
from Timed Automata. In 5th International Symposium on
Formal Techniques in Real-Time and Fault Tolerant Systems
FTRTFT’98, Lyngby, Denmark, pages 59–77, September
1998.
[8] A. En-Nouaary, R. Dssouli, and F. Khendek.
Timed Wp-
Method: Testing Real-Time Systems. IEEE Transactions on
Software Engineering, 28(11):1023–1038, November 2002.
[9] A. En-Nouaary. A Scalable Method for Testing Real-Time
Systems.
Software Quality Journal, Springer, 16(1):3–22,
March 2008.
[10] R. Alur, C. Courcoubetis, N. Halbwachs, D. Dill, and
H. Wong-Toi.
Minimization of Timed Transition Systems.
pages 340–354, 1992.
[11] J. Springintveld and F. Vaandrager.
Minimizable Timed
Automata. In B. Jonsson and J. Parrow, editors, Proceedings
of the 4th International School and Symposium on Formal
Techniques in Real Time and Fault Tolerant Systems, Uppsala,
Sweden, volume 1135 of Lecture Notes in Computer Science.
Springer-Verlag, 1996.
292
ICSEA 2011 : The Sixth International Conference on Software Engineering Advances
Copyright (c) IARIA, 2011.     ISBN: 978-1-61208-165-6

