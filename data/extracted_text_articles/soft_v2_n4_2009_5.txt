Multi-level Security in Wireless Sensor Networks
Faruk Bagci and Theo Ungerer
Institute of Computer Science
University of Augsburg
Augsburg, Germany
{Bagci, Ungerer}@Informatik.Uni-Augsburg.DE
Nader Bagherzadeh
Department of Electrical Engineering and Computer Science
University of California
Irvine, USA
nader@uci.edu
Abstract—As the potential range of applications for sensor
networks expands, the need for security mechanisms grows.
Security relevant problems are limited mostly to areas such as
key distribution and cryptographic algorithms, due to severe
resource constraints in wireless sensor networks. Even if it
is not possible to cover all threats, a security architecture
for sensor networks should provide mechanisms on several
levels, in order to maximize the obstacles for attackers. This
paper presents SecSens, an architecture that provides basic
security components for wireless sensor networks on multiple
system levels. Since robust and strong security features require
powerful nodes, SecSens uses a heterogeneous sensor network.
In addition to a large number of simple (cheap) sensor nodes
providing the actual sensor tasks, there are a few powerful
nodes (cluster nodes) that implement the required security
features. The basic component of SecSens offers authenticated
broadcasts to allow recipients to authenticate the sender of
a message. On the basis of this basic component, SecSens
provides a key management, used for exchange of secret keys
among nodes. In order to bind nodes to their neighborhood,
keys and their owners are linked together. This ensures a
certain grade of location relationship. To protect the Sensor
network against routing attacks, SecSens includes a proba-
bilistic multi-path routing protocol, which supports the key
management and the authenticated broadcasts. SecSens also
provides functions to detect forged sensor data by verifying
data reports en-route. In order to evaluate the efﬁciency of
our security architecture, we simulated different sizes of sensor
networks. Furthermore, SecSens is successfully evaluated in a
real test environment with two different kinds of sensor boards.
Keywords-wireless sensor network; security architecture; key
management; energy efﬁciency; multi-path routing; en-route
ﬁltering
I. INTRODUCTION
Wireless Sensor Networks (WSN) have emerged as a new
information-gathering paradigm based on the collaborative
efforts of a large number of self-organized sensing nodes.
These networks form the basis for many types of smart
environments such as smart hospitals, intelligent battleﬁelds,
earthquake response systems, and learning environments. A
set of applications, such as biomedicine, hazardous environ-
ment exploration, environmental monitoring, military track-
ing and reconnaissance surveillance, are the key motivations
for the recent research efforts in this area [7] [9].
Different from traditional networks, sensor networks do
impose a set of new limitations for the protocols designed
for this type of networks [10]. Devices in sensor networks
have a much smaller memory, constrained energy supply,
less process and communication bandwidth. Topologies of
the sensor networks are constantly changing due to a
high node failure rate, occasional shutdown and abrupt
communication interferences. Because of the nature of the
applications supported, sensor networks need to be densely
deployed and have anywhere from hundred to thousands
of sensing devices, which are orders of magnitude larger
than traditional ad hoc mobile networks. In addition, energy
conservation becomes the center of focus because of the
limited battery capacity and the difﬁculty of recharge in the
hostile environment. With fundamental difference between
traditional networks and sensor networks, it is not appropri-
ate and probably inefﬁcient to port previous solutions for ad
hoc networks into sensor networks with only incremental
modiﬁcations. For instance, the sheer number of sensor
nodes makes ﬂooding-based standard routing schemes for
ad hoc networks undesirable [4].
Because of the steady increase in applications, security
requirements for sensor networks have received more at-
tention. Areas such as health or safety critical industrial
facilities offer very good use for sensor networks, on the
other hand, they also demand high safety standards to be
observed. A security architecture can never cover all types
of threats simultaneously. The application determines, which
attack vectors are probable in current scenarios, and how at-
tractive collected and processed data could be for a potential
intruder. In particular, denial-of-service attacks at network
level, require special and expensive countermeasures. A
comprehensive security architecture can increase protection
and number of blocked attacks, but on the other hand,
hardware costs and thus cost per sensor board increases,
which is not always desirable. It also may increase energy
requirements of sensor nodes signiﬁcantly due to several
successive protocols. This extra effort can, however, reduce
considerably the life-time of individual sensor boards.
Not every sensor network pays an attack with enormous
resources required to access its data, or to block it. In
most cases, a combination of multiple protocols can conﬁne
349
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

a wide range of threats. Therefore a good compromise
between cost and protection is often not a full defense
against all attacks, instead it is preferable to maximize the
obstacles for attackers. Many attackers resile if they have to
increase extremely costs to break a security architecture.
Regarding sensor networks, following basic requirements
exist for the security concept:
• Conﬁdentiality: Conﬁdentiality means that informa-
tion remain secret to unauthorized parties. Therefore
sensor nodes must protect transferred data against ille-
gal access.
• Authenticity: A node must always verify the authen-
ticity of received messages. In particular, authenticity
ensures that messages are really sent by the stated
source.
• Integrity: Received data can be changed during trans-
mission by failures or intent. Integrity should recognize
these manipulations.
• Timeliness: The timeliness of data ensures that re-
ceived information is up-to-date. An attacker should not
be able to send old data (repeatedly).
• Scalability: Especially key management in large sensor
networks can cause signiﬁcant burden. Therefore the
security architecture should consider also scalability.
• Availability: The sensor network should be robust and
fault-tolerant, i.e. compromising individual node should
not affect security of the entire network. On the other
hand, the effort for security must not impair actual tasks
of the sensor network, e.g., by long delays.
• Compromise: A complete protection can not be en-
sured by any security architecture. Hence it must take
the worst-case scenario into account, in which parts of
the network are compromised. The aim should be a
veriﬁcation of data in order to prevent insider attacks,
or at least to limit them locally.
• Self-organization: Characteristic for sensor networks
is their capacity for self-organization. This should be
considered by the security concept, especially in rela-
tion to key management and join/loss of nodes in the
network.
• Accessibility: In order to decrease transfer costs, in-
termediate nodes on a path to the base station should
aggregate and process received sensor data (in-network-
processing/ aggregation). This implies, however, suit-
able access to secured data. By contrast, access must
be minimized as far as possible to limit possible impact
of compromised nodes.
• Energy-efﬁciency: To provide a certain life-time and
to prevent attacks on depletion of energy resources,
energy-efﬁciency plays an important role in security
architecture that should be taken into account.
This paper describes SecSens a security architecture for
wireless sensor networks that fulﬁlls above mentioned re-
quirements [1]. SecSens focuses mainly on a robust and
secure routing protocol and protection against data manipu-
lation. The next section describes related security approaches
for sensor networks. Section III introduces the SecSens
architecture and its security features. SecSens is successfully
evaluated in a simulator and a real test environment with
two different kinds of sensor boards. Section IV describes
the evaluation results. The paper ends with the conclusion.
II. RELATED WORK
SecSens focuses basically on three security aspects: key
management, secure routing, and veriﬁcation of sensor data.
This section describes related approaches that are relevant
for each aspect and can be used in wireless sensor networks.
Critical factor in key management is secure and efﬁcient
distribution of keys to sensor nodes. Because of limited
resources in sensor networks usually symmetric keys are
used. Symmetric encryption requires that both communicat-
ing nodes know the same secret key.
Key Management: [2] presents secure key distribution
techniques for sensor networks. In particular, two approaches
are described: single network-wide key and pair-wise shared
key. The simplest method of key distribution is to pre-load a
single network-wide key onto all nodes before deployment.
Storage cost is minimal because each node has to store
only one key. Unfortunately this approach provides sufﬁcient
security only if all nodes are protected against physical force.
But this usually does not apply to low cost sensor nodes. The
pair-wise shared key approach requires that every node in the
sensor network shares a unique symmetric key with every
other node. Hence, in a network of n nodes there are a total
of
n
2

unique keys, whereas each node has to store n − 1
keys. The storage cost is proportional to the total number of
nodes in the network. Therefore, the pairwise key scheme
does not scale well for large sensor networks.
In [8] a security protocol for sensor networks called
SPINS was presented for hierarchical sensor networks with
one or more trustworthy base stations. SPINS consists of
two parts: a secure network encryption protocol (SNEP)
and authenticated broadcasts (µTESLA). Each sensor node
receives on a secure channel an individual, symmetric
master key, which is only known by the base station and
the node. Using this master key the sensor node is able
to generate all keys. The disadvantage of SNEP is that
secure communication can be built only between a base
station and nodes, and it is not possible to protect the
communication in or between clusters. The second part of
SPINS is µTESLA that provides sending of authenticated
broadcasts. For symmetric encryption, sender and receiver
must share the same secret. Consequently, a compromised
receiver is able to act as a designated sender by transferring
forged messages to all receivers. µTESLA uses delayed
disclosure of symmetric keys for generating an asymmetry
between sender and receiver. This approach requires weak
350
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

time synchronization of sender and receiver in order to
achieve time shifted key disclosure. Storage cost increases
because each node has to buffer packets which it can only
verify after receiving the key in the future time-slots. Also,
this causes new possibilities for DoS-attacks. An attacker
can force a buffer overﬂow by sending planned broadcasts.
Furthermore µTESLA leads to scalability problems, which
are described in [6].
An important aspect for sensor networks is that different
communication patterns exist requiring different security
steps. [13] suggests an adjusted key distribution for different
security requirements. For this reason, four different kinds
of keys are used. The individual key is similar to the
master key of SPINS. The second kind of key is a pair-
wise shared key, which is generated in the initial phase for
each known neighbor. Furthermore, the nodes have a cluster
key for secure communication between cluster members.
The last key is the group key that is used for secure
broadcasting. This approach provides more ﬂexibility but
contains a security risk during the initial key distribution
phase.
Secure Routing: Compromised sensor nodes can inﬂu-
ence a sensor network, especially by manipulating of routing
information. In order to minimize the impact, [3] suggests
intrusion tolerant routing in wireless sensor networks called
INSENS. The goal is to provide a working network even if
parts of it are inﬁltrated. INSENS contains two phases: route
discovery and data forwarding. In the ﬁrst phase, the base
station sends out a broadcast to build routes to each node.
After receiving the route request, the nodes send a list of
all known neighbors back to the base station. For the last
step, the base station generates several disjoint paths to each
node and sends this routing information back to all network
members. Based on this routing table, the nodes can forward
data to the base station (data forwarding phase). INSENS
prevents the network against most outsider attacks and even
insider attacks remain locally. But the dependance on the
base station suggests a single point of failure. Furthermore,
the route discovery phase is extremely energy inefﬁcient.
Another approach for secure routing called ARRIVE is
presented in [5]. The routing algorithm tries to send packets
over different paths based on probability. Also, nodes in
ARRIVE listen passively to communication among neigh-
bors. In case of detected failures, other nodes can forward
the packet on behalf of its neighbor. ARRIVE works with
smaller routing tables, but the chosen path is not always op-
timal. Furthermore, ARRIVE does not provide authenticated
broadcasts, that provides a mechanism for manipulation of
routing information.
Veriﬁcation of Sensor Data: Each individual sensor
node is potential target for attackers. Using compromised
nodes, an attacker can directly inﬂuence the sensor network
by inﬁltrating false reports of network sensor data. This
kind of attack is called fabrication report attack. These
fake reports can reach the base station, if they remain
undetected, where they can trigger off false alarms. Also
this causes high consumption of bandwidth and energy.
En-route ﬁltering attempts to verify reports on the way
from sending node to the base station. The goal is to
detect and discard false reports earlier. [14] describes an
interleaved hop-by-hop authentication scheme for ﬁltering
of injected false data. This algorithm recognizes inﬁltrated
reports by a deterministic process, as long as no more than
t nodes are compromised. The sensors build clusters with a
minimum of t+1 nodes, where each group chooses a cluster
head C. Only the cluster heads can send collected events
in the form of reports to the base station. These reports
include additionally to the actual event t + 1 independent
conﬁrmations of the respective parties, in order to verify the
authenticity of the report. Each intermediate node checks the
report on the way to the base station (En-route ﬁltering).
Unfortunately, this approach uses single path routing to the
base station providing several security risks. A statistical en-
route ﬁltering is presented in [12] that enhances the approach
above by using probabilistic algorithms. Each node chooses
randomly a number of keys from a partition of a global key
pool. Because of the probabilistic distribution of keys, any
node can verify with a certain probability a report before it is
forwarded. In this manner, [12] supports multi-path routing.
But in both approaches, an attacker can create any report,
once it has compromised at least t nodes. [11] attempts
to solve this problem by binding keys to the location of
nodes. The sensor area is divided into cells of width c,
whereas each cell contains several keys. The nodes receive
a location-bound key for each sensing cell. This approach
bounds reports to their original location.
III. SECSENS - SECURITY ARCHITECTURE FOR
WIRELESS SENSOR NETWORKS
The sensor network in SecSens consists of clusters, each
containing simple sensor nodes ui and one powerful sensor
node v that acts as a cluster-head. Sensor nodes ui connect
directly to the cluster-head, because routing in clusters is
not necessary. Sensor nodes can be a member of several
clusters. Cluster-heads again build together an inter-cluster
network, that is used to transfer messages to base stations.
It is assumed that sensor nodes have a ﬁxed position, once
they are attached to a location. SecSens works with multiple
base stations to avoid the risk of single-point-of-failure (see
Figure 1).
The security architecture of SecSens combines several
security approaches in order to provide high protection.
Basically SecSens contains four components, which interact
with each other: authenticated broadcasts, key management,
routing, and en-route ﬁltering.
351
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

Base station
Cluster head
Marked Cluster heads
Simple sensor nodes
Cluster
Inter-cluster network
Figure 1.
Basic sensor network architecture
A. Authenticated Broadcasts
Authenticated broadcasts ensure that the stated sender
is identiﬁed as the true sender. Symmetric approaches use
a shared key to generate a message authentication code
(MAC). In case of only one receiver, the sender is clearly
identiﬁed. But if there are multiple receivers with the same
shared key, this approach for authentication is not applicable.
Potentially each receiver could be the sender. To solve this
problem, there must exist an asymmetry between sender and
receiver.
SecSens provides two authenticated broadcasts: broad-
casts from base stations, and broadcasts in clusters. It is
assumed that base stations are trustworthy and can not
be inﬁltrated. In order to generate an asymmetry, SecSens
uses key chains. Each packet contains a key. To decrypt a
previous packet, a node has to wait for the key of next packet
(Figure 2).
t
Figure 2.
Key chain approach
The base station generates a key chain Kb
0 . . . Kb
n with
sufﬁcient number of keys using a publicly known one-way
function F, so that for i ∈ {0, . . . , n − 1} is:
Kb
i = F(Kb
i+1)
(1)
Each node knows that the ﬁrst key in the chain is

i, Kb
i

with i = 0. Therefore, Kb
0 is public and Kb
1 is the ﬁrst
non-disclosed key. Keys can be used only once. In order
to broadcast a message M, the base station calculates the
corresponding MAC using the next non-disclosed key Kb
i
and sends it together with used key index to all its neighbors:
BS → ∗ :
i, MACKb
i (M)
(2)
A receiving node u checks, if it has already received a
MAC for the stated index, before storing the MAC and index
i into the MAC buffer. Consequently node u accepts only
one MAC per key index. If i is a new index and u is a cluster-
head, it forwards the message to all its neighbors. In this
way, it is efﬁciently distributed over the inter-cluster network
to all sensor nodes. After a maximum time T all sensor
nodes know the MAC together with its key index. Sensor
nodes can not manipulate the MAC, because the base station
has not yet disclosed Kb
i at this time. Time Tp describes a
dynamically adaptable system parameter. The base station
can set Tp depending on the network size, whereas T <
Tp. After expiration of Tp, the base station sends the actual
message M besides the disclosed key data

i, Kb
i

to all
neighbors:
BS → ∗ :
M,

i, Kb
i

(3)
Sensor node u can now verify Kb
i using a previous
disclosed key Kb
i−1. If it does not have Kb
i−1, it can verify
the current key through recursively performing Equation 1
with previous keys. To prevent DoS-attacks, the new key
must not be older than Gmax generations. If Kb
i is ﬁnally
352
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

veriﬁed, node u makes new key data

i, Kb
i

effective.
Subsequently, u can check message M using MACKb
i (M)
and index i. It is important that the index for MAC and key
are the same.
The concept of authenticated broadcasts for base stations
has a disadvantage, if it is used for local authenticated broad-
casts between clusters, because of the delayed disclosure of
keys. However, all receivers of a message in a cluster can be
reached after a single hop. This fact can be used to simplify
the concept, in order to avoid time delays. The cluster-head
generates a key chain Kb
0 . . . Kb
n using a publicly known
function F (see Figure 2). All cluster members receive
the ﬁrst key Kb
0 over a secure connection using pair-wise
shared keys known only by cluster-head and respective node.
Cluster-head v uses for each local authenticated broadcast a
key Kb
i , which is not yet disclosed. It sends the message M
together with the key data:
v → ∗ :
M, Kb
i
(4)
Cluster nodes can verify Kb
i and the message M using
previously disclosed keys. With this the sender is authen-
ticated as cluster-head, because only the cluster-head can
know Kb
i , that was not public until current message. On the
other hand, no intermediate node can manipulate the mes-
sage M, because all potential receivers of M are reachable
with only one hop.
B. Key Management
Sensor nodes basically distrust each other. To build trust
between two or more nodes, a shared secret in the form
of keys is needed. However, neighborhood and relations
between sensor nodes are not known before. Therefore,
nodes must build trust during life-time, more strictly in the
initial phase. For security reasons, a sensor node should
join a network only once. In this critical phase, it can
establish shared keys with its neighbors. Since this procedure
is performed only once, the node is binding itself to the
location. Furthermore, sensor nodes can communicate at sev-
eral levels, that is cluster- or network-wide. Consequently,
SecSens uses several kinds of keys to fulﬁll different security
requirements.
Activation: In the initial phase, a sensor node needs an
initial key KI. This key is stored only on a speciﬁc activation
node, which does not take part for usual networking tasks.
The basic idea is that sensor nodes can not install themselves
independently. Instead a trustworthy employee, who own the
activation node, establishes sensors. In order to add a set of
sensor nodes, the base station stores a randomly generated
master key KA, timer TA, initial key KI, and current group
key Kg onto the activation node A. Using master key KA,
the base station can generate for each sensor node u a
personal activation key Ka
u based on the node ID.
Ka
u = FKA(u)
(5)
All key material and other security critical data is stored
only in RAM of A. TA determines period of validity for
the master key. After expiration of this time, the activation
node deletes KA and all critical data. Each sensor node u has
a unique ID and a personal activation key Ka
u. In order to
activate sensor node u, the activation node A has to be in the
communication range. For security reasons, the radio power
of A is kept low, to ensure physical proximity. After turning
on for the ﬁrst time, sensor node u broadcasts periodically its
plain ID and the ID encrypted with the personal key with the
same low radio power. Activation node A can easily verify
the ID, because it knows the master key KA. As the next
step, A encrypts with personal key of u the initial key KI,
group key Kg, and data X that was given by base station.
Finally, A sends encrypted message to sensor node u:
u → A :
u, MACKa
u(u)
(6)
A → u :
{KI, Kg, X}Ka
u
(7)
After receiving all key material, sensor node u is activated
and it deletes the personal activation key.
Group keys:
The group key Kg is used by the base
station to secure network-wide communication. An attacker,
who compromises a node, can also access the group key. In
order to update Kg, the base station broadcasts ﬁrst a list
of known compromised nodes {x1, ..., xm} to all sensor
nodes. Additionally, it sends a veriﬁcation key FKg′(0),
whereas Kg′ is a new randomly generated group key, and F
a publicly known one-way function. FKg′(0) is used later
to verify the new group key Kg′.
BS → ∗ :
i, MACKb
i ({x1, . . . , xm} ||FKg′(0)) (8)
BS → ∗ :
{x1, . . . , xm} , FKg′(0),

i, Kb
i

(9)
The base station uses an authenticated broadcast with key
Kb
i and index i that is not disclosed yet. After receiving
key Kb
i and successfully verifying the above message (see
section III-A), sensor nodes delete all pair-wise shared keys
or cluster-keys with compromised node xi. Cluster-heads
additionally update their cluster-keys and inform other non-
compromised cluster-heads about new cluster-key. After-
wards, all sensor nodes store veriﬁcation key FKg′(0). As a
second step, the base station publishes new group key Kg′.
Therefore, it encrypts the group key using its cluster-key
Kc
BS and transfers the message to all direct neighbors. The
neighbors can verify Kg′ using veriﬁcation key FKg′(0) and
store afterwards the new group key.
BS → ∗ :
{Kg′}Kc
BS
(10)
353
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

If receiver u is a cluster-head, it forwards new group key
Kg′ encrypted by its own cluster key Kc
u. Consequently,
the new group key Kg′ is forwarded over the inter-cluster
network to all sensor nodes. Since cluster-heads updated
their cluster keys before, the compromised nodes do not
receive the new group key. This procedure is periodically
repeated by base stations to prevent the network against
attacks. If there are no new known compromised nodes, the
transferred list is empty.
Pair-wise shared keys:
For secure communication be-
tween sensor nodes, pair-wise shared keys are used. A new
cluster-head exchanges a pair-wise key with all neighbors.
Simple sensor nodes communicate only over cluster-head,
therefore, they need only a shared key with their cluster-
head. Using the initial key KI each node u generates a
personal master key Kp
u based on its ID. In order to establish
a pair-wise shared key with its neighbor v, node u needs
the ID of v. For this reason u broadcasts a HELLO-message
containing its ID. If v decides to establish secure connection
with new node u, it answers with an acknowledgment
containing its own ID.
u → ∗ :
u
(11)
v → u :
v, MACKp
v (u||v)
(12)
The additional MAC authenticates the acknowledgement
of v, because u can calculate master key Kp
v of v using initial
key KI. Node u does not need to authenticate itself, because
the succeeding message exchange veriﬁes the identity of u.
The pair-wise shared key Kp
uv can be calculated by both
nodes without new message exchange:
Kp
uv = FKp
v (u)
(13)
After expiration of time TI the nodes delete initial key
KI and all personal master keys of its neighbors received
during initialization. Only own master key is stored for
future pair-wise keys with new sensor nodes. The annulment
of compromised pair-wise keys is efﬁciently realized by
deletion of corresponding keys.
Cluster keys:
Sensor nodes transfer information to all
other cluster members using the cluster key without encrypt-
ing the message for each receiver separately. This approach
allows in-network-processing and passive participation of
sensor nodes within a cluster. Cluster-head u generates
randomly cluster key Kc
u, if u joins a network or if u updates
cluster key because of compromised nodes. Each cluster
member v1, . . . , vm receives new cluster key Kc
u, whereas
u encrypts cluster key using pair-wise shared keys Kp
uvi for
i ∈ {1, . . . , m}:
u → vi :
{Kc
u}Kp
uvi
(14)
Only sensor node vi can decrypt cluster key and store
it. If an additional sensor nodes v joins the network, it
establishes a new pair-wise shared key with cluster-head.
In this case it also gets the current cluster key. If a cluster
member is compromised, cluster-head annuls cluster key Kc
u
and distributes new key Kc
u
′ as described above, without
sending it to the compromised nodes.
Report of event E
Cluster ID
Event ID
Event E
Verification
Verification keys of members
Key ID
MAC with 
en-route key
MAC with 
location key
Figure 3.
Report content
C. Routing
To prevent attacks on routing level or restrict them locally,
SecSens provides a secure routing protocol. Simple sensors
in SecSens do not need routing capability, because they
exclusively communicate with the cluster-head. Therefore,
routing is used only within the inter-cluster network built
by cluster-heads. The routing algorithm has two phases:
initialization and the actual routing. In the initialization
phase each node gets a level using breadth ﬁrst search that
determines the distance to base station in hops. Since base
station has level 0, its direct neighbors have level 1. The base
station uses an authenticated broadcast including its ID BSu,
a non-disclosed key Kb
i , and key index i to authenticate an
initialization.
BS → ∗ :
i, MACKb
i (BSu)
(15)
BS → ∗ :
BSu,

i, Kb
i

(16)
Cluster-heads can identify from authenticated messages,
which base station wants to update routing information.
After reception of initialization, cluster-heads have time T
to modify their routing tables. After expiration of T, further
changes are not allowed. Cluster-heads set their level on
L = ∞ after reception of the message (see Equation 16).
The breadth ﬁrst search can now begin. Starting from the
base station, the level values are locally broadcasted by
cluster-heads. To prevent outsider-attacks each cluster-head
u uses key Kb
i , that will be published later, and its cluster
key Kc
u to generate an encrypted message containing ID and
level value Lu:
u → ∗ :
{u||Lu}Kcu , Kb
i
(17)
354
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

A cluster-head v updates its level to Lv = Lu + 1,
if Lv > Lu + 1. It also stores level of u. After level
update, v forwards its level value to its neighbors in the
same way. Each base station triggers its own initialization
without disturbing ongoing updates of others. The cluster-
heads manage a routing table for each base station.
SecSens uses probabilistic multi-path routing based on the
level values to forward messages from cluster-heads on the
way to the corresponding base station. Cluster-heads build
up a trust matrix, where each transmission to its neighbors
is recorded. Based on this trust information and current
level, cluster-heads calculate a probability value and write
it into the packet header. This value is used to decide in
which direction the packet has to be send. Each cluster-
head modiﬁes the probability value and sends the message
over the most trustworthy route. Since this could lead to the
problem that a packet stays at the same level while making
a round-trip, the weight of upper level increases with each
hop. This ensures that packet transfer goes in the direction
of the base station.
Furthermore, SecSens provides passive participation, i.e.
sensor nodes listen to packet transmissions of their neigh-
bors. If cluster-head u detects a packet addressed to its
neighbor v, and recognizes that v is not forwarding the mes-
sage, u takes responsibility with a certain (low) probability.
Also, if u assumes that v forwards the message to a non-
existent node, u takes care of transferring.
D. En-route Filtering
Attacks like report fabrication or false data injection
threaten the network by manipulating and inﬁltrating sensor
data. SecSens prevents such threats using en-route ﬁltering
extending approach of [12]. Cluster-heads generate data
reports containing sensor information of cluster members
for sending them to base stations. These reports are veri-
ﬁed during transfer through the inter-cluster network (see
Figure 3).
En-route ﬁltering consists of three phases: key generation,
report generation, and veriﬁcation.
Key generation: SecSens provides a global pool contain-
ing N en-route keys

Ke
0, . . . , Ke
N−1
	
. The keys Ke
i are
subdivided in n partitions with each m keys. Each sensor
node generates all en-route keys in the initial phase using
one-way function F and chooses randomly a partition j
where it ﬁnally draws k < m keys from set j:
∀i ∈ {0, . . . , N − 1} : Ke
i = FKe
M (i)
(18)
At least base stations can detect all fault reports, because
they have global view of the key pool. Based on the same
partition j, each node calculates in a similar way location
key Kl
C,j for all its clusters that it senses as a member.
Sensor nodes bind themselves locally to actual cluster by
the location key. After the initial phase nodes delete all
remaining unused keys.
Report generation: If a cluster-head wants to generate
a report, it collects sensor data from all its cluster members.
Sensor nodes belonging to same cluster report events (sensor
data) collectively by generating MACs based on their en-
route keys, whereas keys must be chosen from different
partitions. These multiple MACs collectively act as the proof
that a report is legitimate. Finally, the cluster-head forwards
the report to the base station over the inter-cluster network.
Veriﬁcation of reports: A cluster-head receiving a report
checks, if it has one of the keys, that were used to generate
the MACs in the report. With a certain probability, it will
be able to verify the correctness of MACs. A report with
an insufﬁcient number of MACs will not be forwarded. A
compromised node has keys from one partition and can
generate MACs of one category only. Since keys and indices
of distinct partitions must be present in a legitimate report,
the compromised node has to forge the other key indices and
corresponding MACs. This can be easily detected by cluster-
heads possessing these keys. If cluster-head has none of the
keys and number of MACs is correct, it forwards report to
the next cluster-head. Even if a forged report receives a base
station, it can be detected, because base stations know all
used keys.
IV. EVALUATION
To evaluate the efﬁciency of our security architecture
we implemented a simulation tool where it is possible to
establish different sizes of sensor networks. Figure 4 shows
the GUI of the SecSens simulator. The aim was to measure
energy consumption and throughput of security mechanisms.
SecSens simulator provides the possibility to change param-
eters like network size, node density, and number of cluster
heads or cluster members. After initializing the network
we performed several attacks and examined the network
stability.
Denial-of-Service attacks are the most common threats in
a network. SecSens limits the effect of DoS attacks to a
local area compensating high node failures. When a node
failure is detected, SecSens tries to send the message over
an alternative route. Figure 5 shows the delivery rate of
messages in dependance to node failure varying the distance
between failure location and receiver. We simulated here a
sensor network with 10.000 nodes. If the center of failure
is near to message receiver (5 hops), SecSens ﬁnds enough
alternative routes to achieve %50 delivery rate considering
number of 100 failed nodes. Increasing the distance means
that the failure center comes near to the message sender
blocking most alternative routes.
Insider attacks aim to manipulate behavior of the sensor
network by inﬁltrating false sensor data. SecSens uses data
reports to secure the delivery. In order to generate a new
report, a node needs ﬁve veriﬁcation keys from ﬁve different
neighboring nodes. If an attacker wants to send a false
report, he has to compromise several nodes to access the
355
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

Kapitel 5. Implementierung
52
Abbildung 5.1.: Die Software in der Abbildung simuliert im laufenden Prozess 20.000 Knoten
respektive 3.332 Cluster und vier Basisstationen in einer 400 x 100 großen
Simulation. F¨ur eine bessere Analyse lassen sich die einzelnen Knoten farblich
markieren, um ihren Zustand zu visualisieren. Die blauen Ringe in der Abbil-
dung visualisieren das ¨Ubertragen von Paketen (Der Sender liegt im Ringzen-
trum).
und das Zusammenspiel der einzelnen Knoten und auf h¨oherer Ebene der Cluster simulie-
ren zu k¨onnen. F¨ur eine bessere Trennung zwischen der eigentlichen SADS-Implementierung
und zus¨atzlich ben¨otigten Komponenten wie dem Simulator, ist das System in vier Module
untergliedert. Das Basismodul stellt die eigentliche Simulations-Engine dar, welche ein Sensor-
netz simulieren kann und Schnittstellen f¨ur die SADS-Implementierung bereitstellt. Auf der
Simulations-Engine setzt als zweites Modul die SADS-Implementierung f¨ur den Simulator auf.
Daneben ist der im Hintergrund arbeitende Server, mit welchem alle Basisstationen verbun-
den sind, in ein eigenes Modul ausgegliedert. Dieses Server-Modul kann anschließend auch als
Schnittstelle f¨ur die Basisstation auf der realen Hardware dienen. Abschließend stellt das vierte
Modul die Visualisierung und UI-Schnittstelle f¨ur den Benutzer bereit.
Figure 4.
SecSens Simulation Tool
# of node failures
delivery rate
5 hops
10 hops
15 hops
20 hops
Figure 5.
Message delivery rate after DoS attacks
veriﬁcation keys (see previous section). Alternatively, he can
forge missing keys. Figure 6 illustrates the rate of detected
false reports in dependance of the distance between sender
and receiver. As you can see in the results, the detection rate
increases with more forged keys. Already after ten hops,
SecSens can refuse %90 of false reports containing four
forged keys.
The detection rate on intermediate nodes is directly de-
pendent on the size N of the global key pool and number
k of locally stored en-route keys (see previous section).
With increasing number of en-route keys, the probability
of an intermediate node to hold the same en-route key rises.
Figure 7 shows the simulation results for using different
numbers of en-route keys. As expected, the detection rate for
false reports rises with increasing number of locally stored
keys. On the other hand, the ratio k/N should not be too
high, since a compromised node would irrevocably disclose
# of hops
refused reports
1 forged key
2 forged keys
3 forged keys
4 forged keys
Figure 6.
Rate of refused reports in reference to distance
a part of the global key pool.
# of hops
refused reports
25 en-route keys
50 en-route keys
75 en-route keys
Figure 7.
Inﬂuence of local stored en-route keys
In order to show the feasibility of SecSens on real environ-
356
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

ments, we established a testbed with different kinds of sensor
nodes: ESB 430/1 and MSB-430 of Freie University Berlin
(see Figure 8). Both sensor boards have the TI MSP430
microcontroller.
Figure 8.
Sensor boards: ESB 430/1 and MSB-430
ESB 430/1 contains 60 KB ﬂash memory and 2 KB
RAM, whereas MSB-430 has 55 KB ﬂash memory and
5 KB RAM. Because of the larger RAM, MSB-430 was
used as cluster-head. We used four cluster-heads managing
each four sensor nodes that were all ESB boards, making
20 nodes alltogether. Two PCs act as base stations. We
could successfully perform all stages of SecSens which were
described before.
Authenticated broadcast
Key management
Multi-path routing
En-route filtering
Figure 9.
Memory map of SecSens security components
In order to use memory effectively, SecSens stores fre-
quently changing data in RAM and relatively static data
in EEPROM. Table I describes memory consumption of
cluster-heads and sensor nodes. The most memory space is
used for key management. Figure 9 shows the memory map
of SecSens security components.
In the initial phase, energy consumption is comparatively
high. For establishing the network and distribution of keys,
cluster-heads consume in average 2.6Ws energy, whereas
sensor nodes need only 0.2Ws (see Table II).
Energy consumption for sending reports depends on the
reference
fanout 1
fanout 2
fanout 3
fanout 4
sender level
energy consumption in Ws
Figure 10.
Consumed energy for reporting
sender level
energy consumption in Ws
reference
fanout 1
fanout 2
fanout 3
fanout 4
Figure 11.
Energy consumption of single cluster head in reference to
sender level
distance between cluster-head and the base station. We
established in a second test a network with up to 20 cluster-
heads placed in a line side by side. The last cluster-head
received level 20, which means that it needs 20 hops to
reach the base station. We measured the energy consumption
for sending reports from different levels. The multi-path
routing ensures a robust transmission, but sending duplicated
reference
fanout 1
fanout 2
fanout 3
fanout 4
passive participation
energy consumption in Ws
Figure 12.
Energy consumption with passive participation
packets
data
energy
sensor node
15
0,2 KB
0,2 Ws
cluster-head
142
4,1 KB
2,6 Ws
Table II
COSTS IN INITIAL PHASE
357
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

AB
KM
MPR
EF
total
cluster-head: RAM
434 B
9 B
710 B
41 B
1194 B
cluster-head: EEPROM
800 B
2440 B
252 B
981 B
4473 B
sensor node: RAM
54 B
9 B
0 B
0 B
63 B
sensor node: EEPROM
0 B
92 B
0 B
537 B
629 B
Table I
SECSENS MEMORY REQUIREMENTS, (AB) - AUTHENTICATED BROADCASTS, (KM) - KEY MANAGEMENT, (MPR) - MULTI-PATH ROUTING, (EF) -
EN-ROUTE FILTERING
packets from several routes (fanout) increases the energy
consumption. Figure 10 shows consumed total energy in
the sensor network for reports using no fanout (reference)
or multiple fanouts. On ﬁgure 11 you can see the average
energy consumption of a single cluster head in reference
to the sender level. It is interesting to mention that energy
consumption for sending four packets increases by only
%200 instead of %400 as would be expected. The reason lies
in the good balance of load in sending multi-path messages.
As mentioned above, nodes can listen to packet trans-
mission of neighbors and can take the responsibility for
forwarding with a certain probability in case of detected
failures. Figure 12 describes the energy results for passive
participation with different probabilities. Increasing passive
participation naturally leads to higher energy consumption,
because of the additional message delivery.
V. CONCLUSION
This paper presented SecSens, a multi-level security ar-
chitecture for wireless sensor networks. SecSens combines
several security approaches on different system levels in
order to provide high protection. SecSens contains four
components, which interact with each other: authenticated
broadcasts, key management, routing, and en-route ﬁltering.
We implemented a simulation tool, where huge network
sizes can be established. Evaluation results show that Sec-
Sens can resist DoS and insider attacks limiting failures to
a local area. Inﬁltrated false sensor data can be refused with
a high probability. We also demonstrated the feasibility of
SecSens by building a real sensor network environment with
two different kinds of sensor boards.
REFERENCES
[1] Faruk Bagci, Theo Ungerer, and Nader Bagherzadeh. SecSens
- Security Architecture for Wireless Sensor Networks.
In
The Third International Conference on Sensor Technologies
and Applications (SENSORCOMM ’09), Athens, Greece, June
2009.
[2] Haowen Chan, Adrian Perrig, and Dawn Song. Key distribu-
tion techniques for sensor networks. pages 277–303, 2004.
[3] Jing Deng, Richard Han, and Shivakant Mishra.
Insens:
Intrusion-tolerant routing for wireless sensor networks. Com-
puter Communications, 29(2):216–230, 2006.
[4] P. Downey and R. Cardell-Oliver. Evaluating the Impact of
Limited Resource on the Performance of Flooding in Wireless
Sensor Networks. In Proceedings of the 2004 international
Conference on Dependable Systems and Networks, Washing-
ton, DC, USA, June 2004.
[5] Chris Karlof, Yaping Li, and Joe Polastre. Arrive: Algorithm
for robust routing in volatile environments. Technical Report
UCB/CSD-03-1233, University of California at Berkeley,
May 2002.
[6] Donggang Liu and Peng Ning. Multilevel µtesla: Broadcast
authentication for distributed sensor networks.
Trans. on
Embedded Computing Sys., 3(4):800–836, 2004.
[7] A. Mainwaring, J. Polastre, R. Szewczyk, D. Culler, and
J. Anderson. Wireless Sensor Networks for Habitat Moni-
toring. In ACM International Workshop on Wireless Sensor
Networks and Applications (WSNA’02), Atlanta, GA, USA,
September 2002.
[8] Adrian Perrig, Robert Szewczyk, J. D. Tygar, Victor Wen,
and David E. Culler.
Spins: Security protocols for sensor
networks. Wireless Networks, 8(5):521–534, 2002.
[9] G. J. Pottie and W. J. Kaiser. Wireless integrated network
sensors. Communications of the ACM, 43(5):51–58, 2000.
[10] R. Verdone and C. Buratti. Modelling for Wireless Sensor
Network Protocol Design.
In International Workshop on
Wireless Ad-hoc Networks (IWWAN 2005), London, United
Kingdom, May 2005.
[11] Hao Yang, Fan Ye, Yuan Yuan, Songwu Lu, and William Ar-
baugh. Toward resilient security in wireless sensor networks.
In MobiHoc ’05: Proceedings of the 6th ACM international
symposium on Mobile ad hoc networking and computing,
pages 34–45, New York, NY, USA, 2005. ACM Press.
[12] Fan Ye, Haiyun Luo, Songwu Lu, and Lixia Zhang. Statistical
en-route ﬁltering of injected false data in sensor networks.
IEEE Jounal on Selected Areas in Communications, Special
Issue on Self-organizing Distributed Collaborative Sensor
Networks, 23(4):839–850, April 2005.
[13] Sencun Zhu, Sanjeev Setia, and Sushil Jajodia. Leap: efﬁcient
security mechanisms for large-scale distributed sensor net-
works. In CCS ’03: Proceedings of the 10th ACM conference
on Computer and communications security, pages 62–72,
New York, NY, USA, 2003. ACM Press.
[14] Sencun Zhu, Sanjeev Setia, Sushil Jajodia, and Peng Ning. An
interleaved hop-by-hop authentication scheme for ﬁltering of
injected false data in sensor networks. 2004 IEEE Symposium
on Security and Privacy, 00:259–271, 2004.
358
International Journal on Advances in Software, vol 2 no 4, year 2009, http://www.iariajournals.org/software/

