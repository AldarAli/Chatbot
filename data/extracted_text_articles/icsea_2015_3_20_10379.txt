Verifying and Constructing Abstract TLA Speciﬁcations: Application to the Veriﬁcation
of C programs
Amira Methni∗, Matthieu Lemerre†, Belgacem Ben Hedia†, Serge Haddad‡ and Kamel Barkaoui∗
∗CNAM, CEDRIC, 292 rue Saint Martin, Paris Cedex 03, France
Email: ﬁrst.last@cnam.fr
†CEA, LIST, Centre de Saclay, PC172, 91191, Gif-sur-Yvette, France
Email: matthieu.lemerre@cea.fr, belgacem.ben-hedia@cea.fr
‡LSV, ENS Cachan, CNRS & INRIA, France
Email: haddad@lsv.ens-cachan.fr
Abstract—One approach to verify the correctness of a system is
to prove that it implements an executable (speciﬁcation) model
whose correctness is more obvious. Here, we deﬁne a kind of
automata whose state is the product of values of multiple variables
that we name State Transition System (STS). We deﬁne the
semantics of TLA+ (speciﬁcation language of the Temporal Logic
of Actions) constructs using STSs, in particular the notions of
TLA+ models, data hiding, and implication between models. We
implement these concepts and prove their usefulness by applying
them to the veriﬁcation of C programs against abstract (TLA+
or STS) models and properties.
Keywords–Temporal Logic of Actions; formal speciﬁcation;
model-checking; C programs; reﬁnement mapping.
I.
INTRODUCTION
As software systems become large and error-prone, formal
veriﬁcation methods become an essential key concept to ensure
their correctness. Model Checking [1] provides an automated
technique to check and detect errors in computer programs. But
despite its promise, the veriﬁcation process may be complex
due to the size of these systems. One useful technique to
reduce the complexity of veriﬁcation process is abstraction.
Generally, an abstract model specify “what” the system do
while the concrete model describes “how”. The idea is to map
the concrete set of states to a smaller set of states resulting in
an approximation of the system with respect to the property
of interest. We say that the concrete model implements the
abstract one. Verifying the abstract model is generally more
efﬁcient than verifying properties of the original.
a) Contributions: We deﬁne an operational semantics
of a TLA speciﬁcation in terms of automata, that we called
State Transition System (STS). We remind the concepts of
implementation relation and reﬁnement mapping in TLA+ that
we formalize in terms of relations between STSs. The reﬁne-
ment between speciﬁcations can be checked with the TLC
model checker. Veriﬁed properties on the abstract speciﬁcation
can thus be deduced in the concrete speciﬁcation. A way
to abstract details of the concrete speciﬁcation is to hide its
irrelevant variables. TLA+ can express data hiding, but TLC
can’t support this type of construct. So, we have implemented
the notion of data hiding by constructing a STS that we call
“quotient STS”, which is constructed by extending the TLC
model checker. In order to let the quotient STS be analyzed
by existing tools, we extend the TLC model checker to produce
an LTS that can be checked by the CADP toolkit. We apply the
mentioned concepts on C programs using our tool C2TLA+.
Preliminary results show the importance of using an abstract
model to reduce the complexity of veriﬁcation.
b) Outline: The remainder of the paper is structured as
follows. We give an overview of TLA+ and its operational
semantics in Section 2. Section 3 reminds the concepts of
reﬁnement mapping and the implementation relation between
speciﬁcations and describe a way to construct the quotient
STS. In Section 4, we apply these concepts to verify the
correctness of the C implementation with respect to their
speciﬁcation and we report some preliminary experimental
results obtained. We discuss related work in Section 5. Section
6 concludes and presents future research directions.
II.
AN OPERATIONAL SEMANTICS FOR TLA
SPECIFICATION
In this section, we explain some basics concerning the
syntax and the semantics of TLA [2]. Then, we describe the
operational semantics of TLA using a STS.
A. Overview of TLA+
TLA+ is a formal speciﬁcation language based on the TLA
[3] for the description of reactive and distributed systems. TLA
itself is a variant of linear-time temporal logic. The semantics
of TLA is deﬁned in terms of states. A state is a mapping from
variables to values. A state function is a nonboolean expression
built from constants, variables and constant operators, that
maps each state to a value. For example, y + 3 is a state
function from a state s to three plus the value that s assigns to
the variable y. An action is a boolean expression containing
constants, variables and primed variables (adorned with “′”
operator). Unprimed variables refer to variable values in the
actual state and primed variables refer to their values in the
next-state. Thus, an action represents a relation between an old
state and a new state. For example, x = y′ + 2 is an action
asserting that the value of x in the old state is two greater that
the value of y in the new state. A state predicate (or predicate
for short) is an action with no primed variables.
Syntactically, TLA formulas are built up from actions and
predicates using boolean operators (¬ and ∧ and others that
can be derived from these two), quantiﬁcation over logical
variables (∀, ∃), the operators ′ and the unary temporal operator
□ (always) of linear-time temporal logic [4].
The expression [A]vars where A is an action and vars the
tuple of all system variables, is deﬁned as A ∨ (vars′
=
56
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

vars). It states that either A holds between the current and
the next state or the values of vars remain unchanged when
passing to the next state. For any action A, the state predicate
Enabled(A) describes whether the action A can be executed
in the current state s, i.e., there exists some state t such that
s −→ t is an A step.
To specify a system in TLA, one describes its allowed
behaviors. A behavior is an inﬁnite sequence of states that
represents a conceivable execution of the system. The system
speciﬁcation can be given by the temporal formula Φ deﬁned
as a conjunction of the form:
Φ
∆= Init ∧ □[Next]vars ∧ F
(1)
Where, Init is the predicate describing all legal initial
states, Next is the next-state action deﬁning all possible
transitions between states and F is a conjunction of fairness
assumptions about the execution of actions. However, other
forms of speciﬁcation are possible and can occasionally be
useful.
A TLA formula is true or false on a behavior, which is
a sequence of states. Let σ = ⟨s0, s1, . . .⟩ be a behavior. σ
satisﬁes Spec iff Init is true of the ﬁrst state s0 and every
state that satisﬁes Next or a “stuttering step” that leaves all
variables unchanged.
B. State Transition System
In TLA, the behavior of a system is modeled as an
inﬁnite sequence of states. The operational semantics of a TLA
speciﬁcation can be given in terms of a STS, which is easier
to work with than sets of sequences.
Φ
∆=
∧ (x = 0 ∧ y = 0)
∧ □ [
∧
x ′ = (x + 1)%4
∧
y′ = x ÷ 2
]⟨x,y⟩
(a) TLA speciﬁcation
(b) The STS of Φ
Figure 1. The operational semantics of a TLA speciﬁcation
Deﬁnition 1: A STS is a 3-tuple T = (Q, I, δ) given by
-
a ﬁnite set of states Q,
-
a set I ⊆ Q of initial states,
-
a transition relation δ ⊆ Q × Q.
Figure 1 shows a TLA speciﬁcation and its corresponding
STS TΦ = (QΦ, IΦ, δΦ) which encodes all its possible behav-
iors (÷ symbol denotes integer division). The speciﬁcation Φ
is translated into TΦ as follows:
-
TΦ has initial state(s) IΦ speciﬁed by the predicate
x = 0 ∧ y = 0,
-
every state s ∈ QΦ corresponds to a valuation of the
state function ⟨x, y⟩,
-
each transition t ∈ δΦ corresponds to satisfying the
predicate [x ′ = (x + 1)%4 ∧ y′ = x ÷ 2]⟨x,y⟩.
III.
REFINEMENT AND ABSTRACTION OF TLA
SPECIFICATIONS
A way to reduce the veriﬁcation task is to deﬁne an abstract
model as a speciﬁcation, and then relate behaviors of the ab-
stract model to those of the implementation. Properties checked
on the abstract model can be deduced on the concrete one.
We use concrete model to refer to high-level speciﬁcation and
abstract model to refer to low-level speciﬁcation. This section
describes the semantics of reﬁnement between a high-level and
a low-level TLA+ speciﬁcation. Then, we present a way to
automatically construct a reduced model, which abstracts the
detailed behavior of the concrete TLA+ speciﬁcation.
A. Reﬁnement Mapping
Abadi and Lamport [5] described that a high-level speci-
ﬁcation Ψ implements a low-level speciﬁcation Φ iff for each
behavior of Ψ, there is a behavior of Φ with the same sequence
of externally visible states, allowing stuttering, e .g., if the
state Φ does not change during a ﬁnite number of steps. This
implementation relation is proved by deﬁning a reﬁnement
mapping between speciﬁcations.
Let Ψ and Φ be two TLA speciﬁcations, x1, . . . , xm and
y1, . . . , yn the variables occurring in the speciﬁcations Ψ
and Φ respectively. A (concrete) speciﬁcation Ψ implements
an abstract speciﬁcation Φ if Ψ ⇒ Φ. The proof of this
implication consists in deﬁning state functions ¯y1, . . . , ¯yn in
terms of the variables y1, . . . , yn and prove that Ψ ⇒ ¯Φ, where
¯Φ denotes the formula Φ obtained by substituting ¯yi for the
free occurrences of yi, for all i.
The set of state functions ¯y1, . . . , ¯yn is called a reﬁnement
mapping. The “barred variable” ¯yi is the state function with
which Ψ implements the variable yi of Φ. So, if σ is the
behavior s1 → s2 → s3 . . . of Ψ, we deﬁne the behavior ¯σ to
be ¯s1 → ¯s2 → ¯s3 . . . We say that Ψ implements Φ under this
reﬁnement mapping iff, for each behavior σ satisfying Ψ, the
behavior ¯σ is a behavior of Φ.
B. Implementation Relation and Property Preservation
The proof Ψ ⇒ Φ under a reﬁnement mapping is sufﬁcient
to verify that Ψ implements Φ [5]. The key to the implication
relation is that TLA allows to write only formula that are
insensitive to stuttering, i.e., given a TLA formula Φ and
two stuttering equivalent runs σ and σ′, Φ holds along σ
if and only if it holds along σ′ [3]. This implementation
relation between TLA speciﬁcations can be viewed as a weak
simulation relation between its corresponding STSs.
Deﬁnition 2: Let
TΨ
=
(QΨ, IΨ, δΨ)
and
TΦ
=
(QΦ, IΦ, δΦ) denote two STSs. A simulation R relation from
QΨ to QΦ is a function that satisﬁes the following conditions:
•
∀s ∈ IΨ, R(s) ⊆ IΦ (initial states are mapped to
initial states),
57
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

•
For
each
state
pairs
(s1, s2) ∈ δΨ,
(R(s1), R(s2)) ∈ δΦ (state transitions are mapped
into state transitions or stuttering steps).
If a lower-level speciﬁcation, expressed by a TLA formula
Ψ, implements an abstract speciﬁcation Φ, Ψ preserves all
TLA properties of Φ if and only if for every formula φ, if
Φ ⇒ φ is valid, then so is Ψ ⇒ φ. This is true if Ψ ⇒ Φ.
C. Data Hiding in TLA
A very useful form of data abstraction is variable hiding,
which refers to providing only essential information to the
outside world and hiding not needed information. In TLA, it is
possible to hide some variables using the existential quantiﬁer
∃∃∃∃∃∃ (which differs from the quantiﬁer of predicate logic). The
formula ∃∃∃∃∃∃ x : Φ asserts that it doesn’t matter what the actual
values of x are, but there are some values x can assume for
which Φ holds. The meaning of ∃∃∃∃∃∃ is deﬁned by (2). The
formula σ ∼x τ is deﬁned to be true iff σ can be obtained
from τ (or vice-versa) by adding and/or removing stuttering
steps and changing the values of x. Thus, the (2) is true for a
behavior σ iff Φ is true for some behavior τ such that σ ∼x τ
is true.
σ |= ∃∃∃∃∃∃ x : Φ
∆= ∃ behavior(σ ∼x τ) ∧ (τ |= Φ)
(2)
The temporal formula (3) describes a speciﬁcation Φ where
v is the list of all relevant state variables and x is the list of
internal (hidden) variables.
Φ
∆= ∃∃∃∃∃∃ x : Init ∧ [Next]v ∧ L
(3)
The existential operator is a very simple and useful way
in which the system is described as a black box. However, in
practice, the TLC model checker cannot handle the TLA hiding
operator. In what follows, we present a way to implement
data hiding by constructing a quotient STS from a TLA
speciﬁcation.
D. Computing a Quotient STS
Figure 2. Constructing the quotient STS using the reﬁnement mapping
¯y
∆= y
Given a concrete STS T = (Q, I, δ) describing a TLA
speciﬁcation, one can obtain an abstraction of T , a small STS
that we call quotient STS and which is obtained by quotienting
the states Q under a reﬁnement mapping γ.
Figure 2 shows a STS resulting from adding a reﬁnement
mapping ¯y
∆= y in all states of the concrete STS. The quotient
STS (at the right side of the ﬁgure) is constructed by collapsing
all states related under the relation γ into the same state. Let
T /γ = (Q/γ, I/γ, δ/γ) be the quotient STS of T = (Q, I, δ)
1: procedure QUOTIENTSTS
2:
Qγ ← γ(I)
3:
NotSeen ← {s′ ∈ Q | s ∈ Q and (s, s′) ∈ δ}
4:
while NotSeen ̸= {} do
5:
for ∀q ∈ NotSeen do
6:
if γ(q) /∈ Qγ then
7:
Qγ ← Q/γ ∪ {γ(q)}
8:
δ/γ = δ/γ ∪ {(γ(q), γ(q′)) | (q, q′) ∈ δ}
9:
NotSeen = NotSeen \ {q}
10:
end if
11:
end for
12:
end while
13: end procedure
Figure 3. Construction algorithm of the quotient STS
under the reﬁnement mapping γ. The algorithm of constructing
T /γ is given in Figure 3.
We extend the implementation of TLC to produce the
quotient STS “on-the ﬂy” when the TLC model checker
computes the state space of a speciﬁcation. In fact, TLC makes
efﬁcient use of disk. It doesn’t keep all states in memory which
is the limiting factor of the explicit other model checkers.
Instead, it stores just ﬁngerprints of states, which is a 64-bit
number generated by a “hashing” function. So, the probability
that two states have the same ﬁngerprint is 2−64 which is a
very small number. So, the quotient STS is generated with the
same ﬁngerprint collision probability and without exploding
the memory.
E. Translating a STS into a Labelled Transition System
In order to use existing tools to check properties on a
STS, we transform the quotient STS into a Labelled Transition
System (LTS), that we call quotient LTS.
Deﬁnition 3: A LTS is 4-tuple T = ⟨Q, L, δ, s0⟩, where:
•
Q is the set of states,
•
L is the set of action labels,
•
δ is the transition relation (a subset of Q × L × Q),
•
and s0 is the initial state.
A transition (s1, l, s2) of δ, indicates that the system can move
from state s1 to state s2 by performing action labelled by l.
c) Property preservation:
The equivalence between
checking a property given in LTL\x (Linear Temporal Logic
without the “next operator”) on the quotient LTS and checking
it on the original LTS is ensured by the preservation.
Proposition 1: Let ϕ be an LTL\x formula, let TΦ and TΨ
be two STSs such that TΨ ⇒ TΦ. If TΦ |= ϕ then TΨ |= ϕ.
F. Usefulness of the Quotient LTS
The quotient LTS abstracts away the details of the concrete
speciﬁcation. Its main advantage is its small size. As proper-
ties are preserved between the concrete speciﬁcation and its
corresponding quotient STS, model checking properties can
be done on the quotient LTS directly, which is a simple task.
The quotient LTS is generated once and can be used to verify
different properties (modulo the reﬁnement mapping).
To express and check properties on the quotient STS, we
use the CADP [6] toolkit. For this, we ﬁrst adapt the label
58
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

Figure 4. Veriﬁcation ﬂow of C programs
names such that LTS can be parsed by the CADP tools. Then,
we express properties in the Model Checking Language (MCL)
[7] language, the property speciﬁcation language of CADP that
can be veriﬁed by its associated model checker.
IV.
APPLICATION OF C PROGRAMS
In this section, we implement the concept of reﬁnement
between TLA+ speciﬁcations and the quotient LTS on C pro-
grams. Figure 4 illustrates the veriﬁcation ﬂow of C programs.
We use our tool C2TLA+ [8] to translate C programs into
(a concrete) TLA+ speciﬁcation. This latter can be checked
directly against a set of properties, or against an abstract
speciﬁcation by deﬁning the reﬁnement mapping and the
implementation relation between the concrete and the abstract
speciﬁcations. Properties can be expressed in TLA to be
veriﬁed using the TLC model checker. The quotient LTS is
generated, and MCL properties can be veriﬁed by the CADP
model checker.
In what follows, we brieﬂy present how we specify the
semantics of C in TLA+. We apply the described notions by
considering the example of the dining philosophers. Finally,
we assess the usefulness of using abstraction by giving results
of properties veriﬁcation using TLC and the CADP model
checker.
A. TLA+ speciﬁcation of a C program
C2TLA+ [8] generates a TLA+ speciﬁcation that describes
the behavior of the C program as a closed system according
to a set of translation rules. A concurrent program consists in
a set of C functions. In C2TLA+, concurrency is modeled by
considering all possible interleaving of sequences of operations
called processes (corresponding to threads in C). Each step of
the complete speciﬁcation is attributed to exactly one process.
The C program is deﬁned by a TLA formula in the form of
(1). For more detailed information about the translation from
C to TLA+, please refer to our previous work [8].
B. Illustrating Example
As an example, we consider the classic dining philosophers
problem. One possible solution to this problem is the one that
appears in Tanenbaum’s popular operating systems textbook
[9],, given in Figure 5.
In
the
implementation
of
this
solution,
the
global
semaphore mutex provides mutual exclusion for execution
#define N 4
#define THINKING 0
#define HUNGRY 1
#define EATING 2
#define LEFT(i) (i+N-1)%N
#define RIGHT(i) (i+1)%N
typedef int semaphore;
int state[N];
semaphore mutex;
semaphore sem[N];
void philosopher(int i)
{ while (1) {
think();
take_forks(i);
eat();
put_forks(i); }
}
void take_forks(int i) {
P(&mutex);
state[i] = HUNGRY;
test(i);
V(&mutex);
P(&sem[i]);}
void put_forks(i)
{
P(&mutex);
state[i] = THINKING;
test(LEFT(i));
test(RIGHT(i));
V(&mutex);
}
void test(i)
{
if (state[i] = HUNGRY
&& state[LEFT(i)]!=
EATING
&& state[RIGHT(i)]
!= EATING)
{
state[i] = EATING;
V(&sem[i]);
}
}
Figure 5. Tanenbaum’s solution for the dining philosophers
of critical sections and the semaphore sem[i] ensures syn-
chronization. The latters perform P() to acquire a lock and
V() to release it, using ”Compare-and-swap“ primitive.
C. Reﬁnement of Speciﬁcations
d) Abstract speciﬁcation of the dining philosophers:
We deﬁne a coarse-grained representation of the dining
philosopher, illustrated by Figure 6 that captures the aspects
of the system that interest us without giving all the details of
its internal structure.
In order to check liveness properties, we consider that
the philosopher cannot starve waiting for a fork, i.e., no
philosopher is eating forever. This assumption is stated by the
formula Fairness, where WFvars(A) denotes weak fairness
on action A and the symbol ♦ denotes the temporal operator
eventually.
59
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

MODULE Abstract philosophers
EXTENDS Naturals, TLC
CONSTANT N
VARIABLES phil state, forks
vars
∆= ⟨phil state, forks⟩
fork available(i)
∆= forks[i] = N
fork acquire(p, i)
∆= forks′ = [forks EXCEPT ![p] = i]
forks release(p)
∆=
forks′ = [forks EXCEPT ![p] = N , ![(p + 1)%N ] = N ]
fork release(p)
∆= forks′ = [forks EXCEPT ![p] = N ]
LEFT(p)
∆= (p + 1)
RIGHT(i)
∆= IF (i = 0) THEN (N − 1) ELSE (i − 1)
think(ph)
∆=
∧ phil state[ph] = “think”
∧ fork available(LEFT(ph))
∧ fork acquire((LEFT(ph), ph)
∧ phil state′ = [phil state EXCEPT ![ph] = “hungry”]
hungry(ph)
∆=
∧ phil state[ph] = “hungry”
∧ IF (fork available(ph))
THEN
∧ fork acquire(ph, ph)
∧ phil state′ = [phil state EXCEPT ![ph] = “eat”]
ELSE
∧ fork release(LEFT(ph))
∧ phil state′ = [phil state EXCEPT ![ph] = “think”]
eat(ph)
∆= ∧ phil state[ph] = “eat”
∧ forks release(ph)
∧ phil state′ = [phil state EXCEPT ![ph] = “think”]
Init
∆= ∧ phil state = [i ∈ (0 . . (N − 1)) 7→ “think”]
∧ forks = [i ∈ (0 . . (N − 1)) 7→ N ]
Spec
∆= Init ∧ □[∃ i ∈ 0 . . (N − 1) :
think(ph) ∨ hungry(ph) ∨ eat(ph)]vars
∧ Fairness
Figure 6. Abstract TLA+ version of the dining philosophers
Fairness
∆=
∧ ∀ i ∈ (0 . . N − 1) : WFvars(hungry(i)) ∧ WFvars(eat(i))
∧ ∀ i ∈ (0 . . N − 1) : □♦(ENABLED ⟨think(i)⟩vars)
=⇒ (□♦⟨eat(i)⟩vars)
e) Specifying the reﬁnement relation: To check that
the concrete speciﬁcation generated by C2TLA+, implements
the abstract version of the dining philosophers, we deﬁne the
reﬁnement relation as shown in Figure 7. In this section, we
don’t illustrate the translation of the C code, as the translation
rules are described in our previous work [8].
The implementation relation is an implication formula
Spec ⇒ Abstract instance!Spec.
D. Expressing properties
An interesting property that the implementation should
hold is that the critical sections are protected with the primi-
tives P() and V(). This property can be simply expressed in
TLA+ (on the abstract speciﬁcation) as follows:
MODULE reﬁnement deﬁnition
EXTENDS Concrete philosophers
philNum
∆= load(“unused”, Addr N )
get val(addr, oﬀ )
∆=
load(“unused”, [loc 7→ addr.loc, oﬀs 7→ addr.oﬀs + oﬀ ]).val
refmap(addr)
∆=
[i ∈ (0 . . philNum) 7→
LET val
∆= get val(addr state, i)
IN
IF val = 0 THEN “think”
ELSE IF val = 1 THEN “hungry”
ELSE “eat” ]
Abstract instance
∆= INSTANCE Asbtract philosophers WITH
N ← philNum,
phil state ← refmap(Addr state)
Spec =⇒ Abstract instance !Spec
Figure 7. Deﬁnition of reﬁnement relation between abstract and concrete
TLA+ speciﬁcations of the dining philosophers
mutual exclusion
∆=
∀ i ∈ (0 . . (N − 1)) : (phil state[i] = “eat”) =⇒
(phil state[LEFT(i)] ̸= “eat” ∧ phil state[RIGHT(i)] ̸= “eat”)
The dining philosophers problem captures many aspects of
liveness. Among liveness properties of the dining philosophers
is starvation-freedom and deadlock freedom that we expressed
in TLA+ as follows:
NoStarvation
∆= ∀ i ∈ (0 . . (N − 1)) :
□((phil state[i] = “hungry”) =⇒ ♦(phil state[i] = “eat”))
DeadlockFree
∆=
□((∀ i ∈ (0 . . (N − 1)) : (phil state[i] = “hungry”)) =⇒
(∀ i ∈ (0 . . (N − 1)) : ♦(phil state[i] = “eat”)))
E. Veriﬁcation results and comparison
We check that the concrete TLA+ speciﬁcation (generated
by C2TLA+) implements the abstract TLA+ speciﬁcation
(given in Figure 7). We also check the set of properties on
these two speciﬁcations. We extract the quotient LTS from
the concrete speciﬁcation that we checked against the set
of properties that we express in MCL. Table I shows the
number of states and the veriﬁcation time of the concrete
and the abstract speciﬁcations using TLC, and the numbers
of states, transitions and the time veriﬁcation of the quotient
LTS using CADP model checker. Experiments were carried
on an Intel Core Pentium i7-2760QM with 8 cores (2.40GHz
each) machine, with 8Gb of RAM memory. For 5 philosophers,
the state space of the concrete TLA speciﬁcation exceeds 113
millions states and its veriﬁcation takes more than 10 hours to
check the properties.
For the same number of philosophers, the abstract TLA
speciﬁcation generates 82 states and properties were checked
in only 1 minute using TLC. On the other hand, the quotient
LTS generated 47 states and its veriﬁcation time is 42s. Due to
the preservation properties, we can deduce that all the veriﬁed
properties on the abstract TLA speciﬁcation or on the quotient
LTS are veriﬁed on the concrete speciﬁcation. The use of
60
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

TABLE I. RUNTIMES OF MODEL CHECKING
Philos
Veriﬁcation using TLC
Veriﬁcation using CADP
Concrete Spec.
Abstract Spec.
Quotient LTS
States
Time(s)
States
Time(s)
States
Time(s)
3
395K
157
14
15
14
12
4
27.285K
1.080
32
23
20
20
5
113.285K
>36.000
82
64
47
42
abstraction reduces considerably the complexity of veriﬁcation
of C implementations.
When TLC reports that a transition violates the imple-
mentation formula Spec ⇒ Abstract instance!Spec, there
is an error either in the concrete speciﬁcation, the abstract
speciﬁcation, or the reﬁnement mapping function. The trace
given by TLC can help to determine which one of those is the
case. We use our tool to translate this trace in C and get the
C execution sequence that leads to the error.
V.
RELATED WORK
Predicate abstraction [10] is a technique to abstract a
program so that only the information about the given predicates
are preserved. This technique is being used in SLAM [11],
BLAST [12] and MAGIC [13]. Their approach has been
shown to be very effective on speciﬁc application domains
such as device drivers programming. SLAM uses symbolic
algorithms, while BLAST is an on-the-ﬂy reachability analysis
tool. The Magic tool use LTS a speciﬁcation formalism, and
weak simulation as a notion of conformance of a system and
its abstract speciﬁcation.
These tools are applied to C programs and use automated
theorem prover to construct the abstraction of the C program.
The difﬁculty of these reﬁnement-based approaches is that
performing a reﬁnement proofs between an abstract and a
reﬁned model require non trivial human effort and expertise
in theorem proving to get the prover to discharge the proof
obligations. SLAM cannot deal with concurrency, BLAST
cannot handle recursion.
Besides predicate abstraction, several veriﬁcation tech-
niques for C programs have been proposed. CBMC [14]
is a bounded model checker for ANSI C programs which
translates a program into a propositional formula (in Static
Single Assignment form), which is then fed to a SAT solver
to check its satisﬁability. CBMC explores program behavior
exhaustively but only up to a given depth.
Compared to previous related works that use an over-
approximation of the code implementation which is sound,
our approach is based on constructing an executable abstract
model, that can be expressed using TLA+ or by constructing
the quotient LTS. Moreover, TLA+ is a logic that can express
safety and liveness properties unlike SLAM, BLAST and
CBMC which have limited support for concurrent properties
as they only check safety properties.
VI.
CONCLUSION AND FUTURE WORK
We have deﬁned an operational semantics of a TLA+
speciﬁcation in terms of a STSs. We redeﬁned the semantics
of reﬁnement between a high-level (concrete) and a low-level
(abstract) TLA+ speciﬁcations using STSs and we illustrated
a way to automatically construct a quotient STS from the
concrete speciﬁcation by extending the TLC model checker.
We applied all these notions for verifying C programs. Exper-
imental results show that verifying properties on the abstract
model reduces considerably the complexity of the veriﬁcation
process.
As future work, we plan to extend this work on several
interesting directions. We would like to generate TLA+ and
MCL properties from the ACSL [15] speciﬁcation language
used in Frama-C. We envisage to beneﬁt from Frama-C
analysis of shared variables by several processes to generate
TLA+ code with less interleaving between the processes, to
reduce the state space. Finally, we aim to use the TLA+
proof system [16] to prove reﬁnement between a concrete and
abstract speciﬁcations.
REFERENCES
[1]
E. M. Clarke, Jr., O. Grumberg, and D. A. Peled, Model checking.
Cambridge, MA, USA: MIT Press, 1999.
[2]
L. Lamport, Specifying Systems, The TLA+ Language and Tools for
Hardware and Software Engineers.
Addison-Wesley, 2002.
[3]
L. Leslie, “The Temporal Logic of Actions,” ACM Trans. Program.
Lang. Syst., vol. 16, no. 3, 1994, pp. 872–923.
[4]
Z. Manna and A. Pnueli, The Temporal Logic of Reactive and Concur-
rent Systems.
New York, NY, USA: Springer-Verlag New York, Inc.,
1992.
[5]
M. Abadi and L. Lamport, “The Existence of Reﬁnement Mappings,”
Theor. Comput. Sci., vol. 82, no. 2, 1991, pp. 253–284.
[6]
H. Garavel, F. Lang, R. Mateescu, and W. Serwe, “CADP 2011: a
toolbox for the construction and analysis of distributed processes,” In-
ternational Journal on Software Tools for Technology Transfer, vol. 15,
no. 2, 2013, pp. 89–107.
[7]
R. Mateescu and D. Thivolle, “A Model Checking Language for Con-
current Value-Passing Systems,” in Proceedings of the 15th International
Symposium on Formal Methods.
Berlin, Heidelberg: Springer-Verlag,
2008, pp. 148–164.
[8]
A. Methni, M. Lemerre, B. Ben Hedia, S. Haddad, and K. Barkaoui,
“Specifying and Verifying Concurrent C Programs with TLA+,” in
Formal Techniques for Safety-Critical Systems, C. Artho and P. C.
lveczky, Eds.
Springer, 2015, vol. 476, pp. 206–222.
[9]
A. S. Tanenbaum, Modern Operating Systems, 3rd ed.
Upper Saddle
River, NJ, USA: Prentice Hall Press, 2007.
[10]
S. Graf and H. Sa¨ıdi, “Construction of Abstract State Graphs with PVS,”
in Proceedings of the 9th International Conference on Computer Aided
Veriﬁcation.
London, UK, UK: Springer-Verlag, 1997, pp. 72–83.
[11]
T. Ball, R. Majumdar, T. Millstein, and S. K. Rajamani, “Automatic
predicate abstraction of c programs,” in Proceedings of the ACM
SIGPLAN 2001 conference on Programming language design and
implementation, ser. PLDI ’01. New York, USA: ACM, 2001, pp. 203–
213. [Online]. Available: http://doi.acm.org/10.1145/378795.378846
[12]
T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre, “Software
Veriﬁcation with BLAST.”
Springer, 2003, pp. 235–239.
[13]
S. Chaki, E. M. Clarke, A. Groce, S. Jha, and H. Veith, “Modular
Veriﬁcation of Software Components in C,” IEEE Trans. Software Eng.,
vol. 30, no. 6, 2004, pp. 388–402.
[14]
E. Clarke, D. Kroening, and F. Lerda, “A Tool for Checking ANSI-
C Programs,” in TACAS, K. Jensen and A. Podelski, Eds., vol. 2988.
Springer, 2004, pp. 168–176.
[15]
P. Baudin, J.-C. Filliˆatre, C. March´e, B. Monate, Y. Moy, and V. Pre-
vosto, ACSL: ANSI/ISO C Speciﬁcation Language, version 1.4, 2009,
[retrieved: October, 2015].
[16]
D. Cousineau, D. Doligez, L. Lamport, S. Merz, D. Ricketts, and
H. Vanzetto, “TLA+ Proofs,” in 18th International Symposium on
Formal Methods - FM 2012, D. Giannakopoulou and D. M´ery, Eds.,
vol. 7436.
Paris, France: Springer, 2012, pp. 147–154.
61
Copyright (c) IARIA, 2015.     ISBN:  978-1-61208-438-1
ICSEA 2015 : The Tenth International Conference on Software Engineering Advances

