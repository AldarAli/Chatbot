142
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
Encoding Subsystem Codes
Pradeep Sarvepalli
Department of Physics and Astronomy
University of British Columbia
Vancouver, BC V6T 1Z1, Canada
Email: pradeep@phas.ubc.ca
Andreas Klappenecker
Department of Computer Science and Engineering
Texas A&M University
College Station, TX 77843, USA
Email: klappi@cse.tamu.edu
Abstract— Encoding quantum codes is an important com-
ponent of quantum error correction and of relevance in some
cryptographic protocols such as entanglement distillation and
quantum secret sharing. In this paper, we investigate the encoding
of subsystem codes and propose efﬁcient encoding methods for
them. We show that encoding of subsystem codes can be reduced
to encoding of a related stabilizer code making it possible to use
the known results on encoding of stabilizer codes. Along the way
we also show how Clifford codes can be encoded. We present
two systematic methods to encode subsystem codes and suggest
optimizations for lower complexity. These encoding schemes can
tolerate initialization errors on the so-called gauge qubits. This
tolerance can be traded for reduced encoding complexity.
Index Terms—Clifford codes; encoding; quantum codes; sta-
bilizer codes; subsystem codes;
I. INTRODUCTION
Though originally conceived to protect quantum information
in the context of quantum computation, quantum codes have
found important applications in other areas such as quantum
cryptography and have strong connections with many cryp-
tographic protocols such as entanglement distillation [4], key
distribution [35] and secret sharing [9], [14]. A secret sharing
scheme, for instance, could be viewed as a quantum error
correcting code and the method of generating the shares and
the subsequent reconstruction procedures are directly related
to the encoding and decoding of the associated quantum code.
Compared to decoding, the problem of efﬁcient encoding
has received less attention from the research community. Our
interest in this paper is the encoding of subsystem codes, for
two reasons. Firstly, because of their importance in quantum
error correction and because this topic has not received a
comprehensive treatment in the literature before. Secondly,
subsystem codes generalize some of the cryptographic pro-
tocols based on standard error correcting codes [26] and
the results of this paper will be potentially useful in such
protocols.
In most error correction paradigms such as the stabilizer
codes [5]–[7], [11]–[13], [25], one protects the information by
encoding into a subspace Q of H, the system Hilbert space of
n qubits or more generally qudits, i.e., q-level systems, thus
H ∼= Cqn. We refer to Q as code subspace or codespace; Q
induces a decomposition of Hilbert space as H = Q ⊕ Q⊥,
where Q⊥ is the complement of Q. If dim Q = qk and the
code can detect errors on d−1 qudits or fewer, then we denote
this code as an [[n, k, d]]q code.
Subsystem codes, or operator quantum error correcting
codes as they are also called, generalize the standard notion of
protecting by encoding into subspaces of the system Hilbert
space, see [3], [24], [28], [29]. In this case the subspace Q
can be factored into a tensor product of two subspaces, thus
H = (A ⊗ B) ⊕ Q⊥. Only the subsystem A carries the
information to be protected, while the auxiliary subsystem B
does not and it is referred to as the gauge subsystem. The
gauge subsystem could, in some cases, lead to a simpliﬁcation
of the error recovery schemes. If dim A = qk, dim B = qr
and the code can detect all errors on d−1 qudits or less, then
we say it is an [[n, k, r, d]]q subsystem code. Such a code is
said to encode k qudits with r gauge qudits.
We pause to clarify the terminology of gauge qudits. These
are not as the name might suggest a new type of qudits. Let us
elaborate a little further. In the standard error correction model,
every input state is encoded to a unique state. On the other
hand, in the subsystem model we do not have such a unique
map between input states and the corresponding encoded
states. Instead every input state is identiﬁed with a unique
subspace, but the state itself can be mapped to any state within
the subspace. These degrees of freedom are what we equate
with the gauge qudits. If the subspace is qr-dimensional, then
we say that the subsystem code has r gauge qudits, although
one might prefer to use the term gauge degrees of freedom.
The terminology is not entirely unjustiﬁed though, as we can
exchange these degrees of freedom for encoding more qudits,
see for instance [2].
The development of subsystem codes was motivated to a
great extent by the search for efﬁcient error recovery schemes.
Subsequent research has demonstrated that indeed in some
cases these codes afford simpler recovery schemes that led to
an improvement in the threshold for fault tolerant quantum
computation [1].
Our ﬁrst result is that encoding of a subsystem code can be
reduced to the encoding of a related stabilizer code, thereby
making use of the previous theory on encoding stabilizer codes
[8], [13], [16]. We shall prove this in two steps. We begin
by showing that Clifford codes [20] can be encoded using
the same methods used for stabilizer codes. Subsequently,
we shall show how these methods can be adapted to encode
Clifford subsystem codes. Since subsystem codes subsume
stabilizer codes, noiseless subsystems and decoherence free
subspaces, these results imply that we can essentially use the

143
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
same methods to encode all these codes. In fact, while the
exact details were not provided, Poulin suggested in [33] that
encoding of subsystem codes can be achieved by Clifford
unitaries. Our treatment is comprehensive and gives proofs
for all the claims.
Our second result is more pragmatic in nature and is con-
cerned with actual circuits for encoding. It is partly motivated
by the idea that just as subsystem codes can potentially lead
to simpler error recovery schemes, they can also simplify
the encoding process, though perhaps not as dramatically.
These simpliﬁcations have not been investigated thoroughly,
neither have the gains in encoding been fully characterized.
Essentially, these gains are in two forms. In the encoded state
there need not exist a one to one correspondence between
the gauge qubits and the physical qubits. However, prior to
encoding such a correspondence exists. We can exploit this
identiﬁcation between the gauge degrees of freedom and the
physical qubits before encoding to tolerate errors on the gauge
qubits, a fact which was recognized in [33]. Alternatively,
we can optimize the encoding circuits by eliminating certain
encoding operations. The encoding operations that are saved
correspond to the encoded operators on the gauge qubits. This
is a slightly subtle point and will become clear later. We argue
that optimizing the encoding circuit for the latter is much more
beneﬁcial than simply allowing for random initialization of
gauge qubits.
It must be noted that our encoding schemes are quite general
in that we do not tailor our encoding schemes to any speciﬁc
noise process. We assume that the code construction has al-
ready taken the noise process into account while designing the
code. At this point, we are not concerned with the code design
but with the the implementation of the code or more precisely,
implementation of a speciﬁc task with respect to code namely,
encoding. We do assume that the noise process is local, i.e.,
independent on each qudit. Although, error correction is not
primarily the objective of encoding per se, we do show that
in case of subsystem codes, the encoding schemes can offer
a signiﬁcant beneﬁt viz., they can tolerate initialization errors
on some qubits, namely the gauge qubits. These qubits can be
completely corrupted. The results presented here could perhaps
be optimized for a speciﬁc noise process to get additional
beneﬁts but we do not investigate these possibilities.
This paper is structured as follows. In Section II we give
a brief sketch of the representation theoretic framework of
quantum codes, for the beneﬁt of readers who are not familiar
with this approach. We then deal with the problem of encoding
in its most general setting in Section III, where we make
no reference to the alphabet of the codes. Subsequently, in
Section IV we address in detail the differences that arise
in encoding into a subspace versus a subsystem. In Sec-
tions V and VI, we give two different methods to encode the
subsystem codes.
Notation. We shall denote a ﬁnite ﬁeld with q elements
by Fq. Following standard convention we use [[n, k, d]]q for
stabilizer codes and [[n, k, r, d]]q for subsystem codes. The
inner product of two characters of a group N, say χ and θ,
is deﬁned as (χ, θ)N = 1/|N| P
n∈N χ(n)θ(n−1). We shall
denote the center of a group N by Z(N). Given a subgroup
N ≤ E, we shall denote the centralizer of N in E by CE(N).
Given a matrix A, we consider another matrix B obtained
from A by column permutation π as being equivalent to A
and denote this by B =π A. In other words, B can be
obtained from A after applying a permutation π. Often we
shall represent the basis of a group by the rows of a matrix.
In this case we regard another basis obtained by any row
operations or permutations as being equivalent and by a slight
abuse of notation continue to denote B =π A. The commutator
of two operators A, B is deﬁned as [A, B] = AB − BA.
We note that this paper is an expanded version of [34]. It
addresses in more detail the differences between encoding into
a subspace and subsystem, additionally it includes alternative
methods to encode subsystem codes and discusses further
variations.
II. QUANTUM CODES FROM A REPRESENTATION
THEORETIC PERSPECTIVE
In part of the paper we lean heavily on a representation
theoretic framework of quantum codes. So we sketch the
relevant ideas of this framework for those readers unfamiliar
with this approach, postponing some of the mathematical
details to the appropriate juncture in the paper; interested
readers can ﬁnd further details in [22], [23] and [20]. For an
introduction to quantum error correction in general we refer
the readers to [10], [15], [18], [30], [31]. An introduction to
subsystem codes can be found in [27], [33], while interested
readers are referred to [21], [24], [28], [29], [32].
Recall that quantum states are unit vectors in the Hilbert
space H, which is a qn-dimensional complex vector space.
Protecting a set of quantum states implies that we are required
to protect the subspace spanned by them because, typically,
quantum algorithms manipulate not just a set of logical states
but also their complex superpositions. So quite naturally the
computational space is a vector space. We designate this space
to be protected as the codespace, Q. While there are important
differences, just as in classical error correction, redundancy is
a key ingredient of quantum error correction. Consequently,
the codespace cannot be the entire Hilbert space, if it were,
then every state would be a valid state and we would not know
if that state had been corrupted by noise or not. Put differently,
this means that the codespace Q is a proper subspace of H.
If the dimension of Q is qk, we denote this as an [[n, k]]q
quantum code.
Errors are simply operators on H, in other words they are
elements of the matrix algebra of qn ×qn matrices. It sufﬁces
to consider only a basis for this matrix algebra; this basis is
called the error basis and denoted as E. It is convenient to work
with an orthonormal basis, assuming a suitable deﬁnition of
the inner product between the matrix elements. The group of
operators generated by the elements of E is called the error
group and denoted as E. Knill [23] introduced the concept of
nice error basis which is an orthonormal error basis with these
additional restrictions: (a) it contains contains the identity, (b)

144
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
its elements are unitary operators, and (c) the product of any
two basis elements is another basis element up to a scalar
multiple. The motivation for these particular conditions can
be found in [23].
A nice error basis induces a group called the abstract error
group, which we denote by E. The abstract error group is
isomorphic to the error group E. Additionally, the elements
of E can be indexed by elements of E/Z(E), therefore
E/Z(E) is called the index group. Furthermore, E is a faithful,
irreducible unitary representation of E.
The error basis formulation, although abstract, is quite
useful in that we can construct and study codes using the
machinery of group theory and representations. The connec-
tion with codes is as follows. A quantum code is a “suitably
deﬁned eigenspace” of the operators of a subgroup of E.
Let G be a subgroup of E. If G is an abelian group that
does not contain Z(E), then the codespace is deﬁned as the
“joint eigenspace” of all the operators in G. These codes are
precisely the stabilizer codes in the sense of Gottesman [12].
et al [5]. Knill [22] considered quantum codes derived from
normal subgroups of E which are not necessarily abelian; these
codes, called Clifford codes, are the objects underlying our
study in this paper. In this case, the codespace is deﬁned in
a slightly more complex manner involving the characters of
the representation of E. The codespace is an eigenspace of
each operator in G, but the eigenvalues may now vary from
operator to operator.
As we mentioned earlier subsystem codes are quantum
codes which afford a tensor product decomposition of the
codespace. Clifford codes turn out to have a tensor product
decomposition which makes them a natural candidate for
constructing the subsystem codes, (thereby prompting our
study of Clifford codes in this paper). This decomposition is
related to the representation and the characters of the abstract
error group. Precise construction of subsystem codes from
Clifford codes can be found in [21].
It is not possible to correct all errors that occur on the code
space. We usually attempt to correct those errors that are most
likely to occur. Assume that the code corrects a set of errors
in A. Then it also corrects the linear span of those errors.
Therefore, it sufﬁces to correct only a basis of errors. An error
basis of the state space of n qudits is a tensor product of the
error basis on a single quantum system. One can therefore
meaningfully speak of a local error model where we assume
that the errors on each qudit are independent. We can quantify
the error correcting capabilities of the code in terms of the
errors the code can correct or equivalently in terms of the
errors it can detect. If the code can detect errors on any d − 1
or fewer quantum systems we say that the code has a distance
d.
From the point of view of code construction, for optimal
performance, one should take into account the source and
characteristics of noise. In the absence of exact knowledge
about the noise characteristics it is common to assume a
pessimistic noise model. The noise model affects the choice
of the code and in this paper we assume that the code has
been constructed factoring the noise model.
III. ENCODING CLIFFORD CODES
In this section, we show that a Clifford code can be encoded
using its stabilizer and therefore the methods used for encoding
stabilizer codes are applicable. We brieﬂy recapitulate some
facts about Clifford subsystem codes, see [21] for more details.
Let E be an abstract error group, i.e., it is a ﬁnite group with
a faithful irreducible unitary representation ρ of degree |E :
Z(E)|1/2. Denote by φ, the irreducible character afforded by
ρ. Let N be a normal subgroup of E. Further, let χ be an
irreducible character χ of N such that (φN, χ)N > 0, where
φN is the restriction of φ to N.
Deﬁnition 1 (Clifford code). The Clifford code deﬁned by
(E, ρ, N, χ) is the image of the orthogonal projector
P = χ(1)
|N|
X
n∈N
χ(n−1)ρ(n).
(1)
Under certain conditions we can construct a subsystem code
from the Clifford code. In particular when the index group, i.e.,
E/Z(E) is abelian and CE(Z(N)) = LN, the Clifford code
C has a tensor product decomposition1 as Q = A ⊗ B, where
B is an irreducible CN-module and A is an irreducible CL-
module. In this case we can encode information only into the
subsystem A, while the co-subsystem B provides additional
protection. When encoded this way we say Q is a Clifford
subsystem code. The normal subgroup N consists of all errors
in E that act trivially on A. It is also called the gauge group
of the subsystem code. Our main goal will be to show how
to encode into the subsystem A. The dimensions of A and
B can be computed using [21, Theorems 2,4] but, since we
are interested in encoding we focus on the projectors for the
Clifford code and the subsystem code and not so much on the
parameters of the codes themselves.
An alternate projector for a Clifford code with data
(E, ρ, N, χ) can be deﬁned in terms of Z(N), the center of
N. This projector is given as, see [20, Theorem 6] for proof,
P ′ =
1
|Z(N)|
X
n∈Z(N)
ϕ(n−1)ρ(n),
(2)
where ϕ is an irreducible (linear) character of Z(N), that
satisﬁes (χ ↓ Z(N))(x) = χ(1)ϕ(x), where (χ ↓ Z(N))(x)
is the restriction of χ to Z(N). In this case Q can be thought
of as a stabilizer code in the sense of [5], i.e.,
ρ(m) |ψ⟩ = ϕ(m) |ψ⟩ for any m in Z(N).
(3)
We pause to mention that stabilizer codes can be viewed in
two equivalent ways. We could view them as the joint +1-
eigenspaces of an abelian subgroup of the error group, this is
the sense in which stabilizer codes are deﬁned by Gottesman
[12]. Alternatively, we could augment this subgroup by the
center of the error group to deﬁne the code, as in [5]. In
1Strictly speaking the equality should be replaced by an isomorphism.

145
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
the latter case the codespace is not anymore the joint +1-
eigenspace of the operators of the subgroup. We account for
the varying eigenvalues by a character of the subgroup.
Our goal is to use the stabilizer of Q for encoding and as
a ﬁrst step we will show that it can be computed from Z(N).
The usefulness of such a projector is that it obviates the need
to know the character ϕ.
Lemma 2. Let (E, ρ, N, χ) be the data of a Clifford code
and ϕ an irreducible character of Z(N), the center of N,
satisfying (χ ↓ Z(N))(x) = χ(1)ϕ(x). Let e be the exponent
of E and let e divide |Z(E)|. Then for all n in Z(N), ϕ(n) ∈
{ζk | ζ = ej2πk/e, 0 ≤ k < e}. Further, if Z(E) ≤ N, then
for any n ∈ Z(N), we have ϕ(n−1)ρ(n) ∈ ρ(Z(N)).
Proof: First we note that the irreducibilty of ρ implies
that for any z in Z(E) we have ρ(z) = ωI for some
ω ∈ C by Schur’s lemma, (or see [17, Prop. 9.14, pg. 84]).
The assumption that ρ is also faithful implies that Z(E) is
cyclic, [17, Prop. 9.16, pg. 85] and e divides |Z(E)| forces
|Z(E)| = e; consequently, ω ∈ {ζk | 0 ≤ k < e} where
ζ = ej2π/e. Since ρ is faithful ρ(Z(E)) = {ζlI | 0 ≤ l < e}.
Secondly, we observe that ϕ is an irreducible additive character
of Z(N) (an abelian group with exponent at most e) which
implies that we must have ϕ(n) = ζl for some 0 ≤ l < e.
From these observations with the fact ρ is faithful, we infer
that ϕ(n−1)I = ζlI = ρ(z) for some 0 ≤ l < e and
z ∈ Z(E). Since Z(E) ≤ N, it follows that Z(E) ≤ Z(N)
and ϕ(n−1)ρ(n) = ρ(zn) is in ρ(Z(N)).
Theorem
3. Let Q be a Clifford code with the data
(E, ρ, N, χ) and ϕ an irreducible character of Z(N) satis-
fying (χ ↓ Z(N))(x) = χ(1)ϕ(x). Let E and N be as in
Lemma 2 and
S =

ϕ(n−1)ρ(n) | n ∈ Z(N)
	
;
P = 1
|S|
X
s∈S
s.
(4)
Then S is the stabilizer of Q and Im P = Q.
Proof: We will show this in a series of steps.
1) First we will show that S ≤ ρ(Z). By Lemma 2 we know
that ϕ(n−1)ρ(n) is in ρ(Z), therefore S ⊆ ρ(Z). Let
Z = Z(N), for short. For any two elements n1, n2 ∈ Z,
we have s1 = ϕ(n−1
1 )ρ(n1), s2 = ϕ(n−1
2 )ρ(n2) ∈ S and
we can verify that s−1
1 s2 = ϕ(n1)ρ(n−1
1 )ϕ(n−1
2 )ρ(n2) =
ϕ(n−1
2 n1)ρ(n−1
1 n2) ∈ S, as ρ(n−1
1 n2) is in ρ(Z). Hence
S ≤ ρ(Z).
2) Now we show that S ﬁxes Q. Let s ∈ S and |ψ⟩ ∈ Q. Then
s = ϕ(n−1)ρ(n) for some n ∈ Z. The action of s on |ψ⟩
is given as s |ψ⟩ = ϕ(n−1)ρ(n) |ψ⟩ = ϕ(n−1)ϕ(n) |ψ⟩ =
|ψ⟩, in other words S ﬁxes Q.
3) Next, we show that |S|
=
|Z|/|Z(E)|. If two ele-
ments n1 and n2 in Z map to the same element in
S, then ϕ(n−1
1 )ρ(n1) = ϕ(n−1
2 )ρ(n2), that is ρ(n2) =
ϕ(n−1
1 n2)ρ(n1). By Lemma 2, it follows that ρ(n2) =
ζlρ(n1) for some 0 ≤ l < e. Since ρ(Z(E)) = {ζlI | 0 ≤
k < e} and ρ is faithful, we must have n2 = zn1 for some
z ∈ Z(E). Thus, |S| = |Z|/|Z(E)|.
4) Let T be a transversal of Z(E) in Z, then every element
in Z can be written as zt for some z ∈ Z(E) and t ∈ T.
From step 3) we can see that all elements in a coset of
Z(E) in Z map to the same element in S, therefore,
S = {ϕ(t−1)ρ(t) | t ∈ T}.
Recall that a projector for Q is also given by
P ′
=
1
|Z|
X
n∈Z
ϕ(n−1)ρ(n),
=
1
|Z|
X
t∈T
X
z∈Z(E)
ϕ((zt)−1)ρ(zt).
But we know from step 3) that if z
∈ Z(E), then
ϕ(n−1)ρ(n) = ϕ((zn)−1)ρ(zn). So we can simplify P ′
as
P ′
=
1
|Z|
X
t∈T
X
z∈Z(E)
ϕ(t−1)ρ(t),
=
|Z(E)|
|Z|
X
t∈T
ϕ(t−1)ρ(t) = 1
|S|
X
s∈S
s = P.
Thus the projector deﬁned by S is precisely the same as
P ′ and P is also a projector for Q.
From step 3) it is clear that S ∩ Z(E) = {1} and by [19,
Lemma 10], S is a closed subgroup of E. By [19, Lemma 9],
Im P = Q is a stabilizer code. Hence S is the stabilizer of
Q.
The essence of Theorem 3 is that if one were to ignore the
underlying structure of the subspace that is associated to a
Clifford code, then it can be also identiﬁed with a stabilizer
code.
Corollary 4. Let Q be an [[n, k, r, d]]q Clifford subsystem code
and S its stabilizer. Let
P = 1
|S|
X
s∈S
s.
(5)
Then P is a projector for the subsystem code, ı.e., Q = Im P.
Proof:
By
[21,
Theorem
4]2,
we
know
that
an
[[n, k, r, d]]q Clifford subsystem code is derived from a Clif-
ford code with data (E, ρ, N, χ). Since as subspaces the
Clifford code and subsystem code are identical, by Theorem 3
we conclude that the projector deﬁned from the stabilizer of
the subspace is also a projector for the subsystem code.
Theorem 3 shows that any Clifford code can be encoded
using its stabilizer. As to encoding a subsystem code, while
Corollary 4 shows that there exists a projector that can be
deﬁned from its stabilizer, it is not clear how to use it so that
one respects the subsystem structure during encoding. More
precisely, how do we use the projector deﬁned in Corollary 4
to encode into the information carrying subsystem A and not
the gauge subsystem. This will be the focus of the next section.
2Though [21, Theorem 4] assumes that E is an extraspecial p-group it also
holds with the error groups with the conditions we have in Lemma 2 and
Theorem 3.

146
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
IV. ENCODING INTO SUBSPACES VERSUS ENCODING INTO
SUBSYSTEMS
For ease of presentation and clarity henceforth we will
focus on binary codes, though the results can be extended
to nonbinary alphabet using methods similar to stabilizer
codes, see [16]. We brieﬂy review some of the relevant
background and point out the differences in encoding into
subspaces and subsystems. Before we get into the details we
reiterate that the result obtained in the previous section with
respect to encoding for arbitrary alphabet does not yet give
us explicit circuits for subsystem codes, such that they respect
the subsystem structure of the code. This section prepares the
way to giving those circuits for binary subsystem codes, by
highlighting the differences that must be accounted for when
one is encoding a stabilizer code as against a subsystem code.
The results on binary subsystem codes in Sections VI and V
give a concrete expression to the abstract result obtained in
Section III. Additionally, they also discuss how subsystem
encoding can exploit the freedom provided by the gauge qubits
to either tolerate initialization errors or reduce complexity.
A. Encoding Stabilizer Codes
We shall now brieﬂy, review the standard form encoding of
stabilizer codes, due to Cleve and Gottesman, see [8], [13].
Recall the Pauli matrix operators
X =
 0
1
1
0

, Z =
 1
0
0
−1

, Y =
 0
−i
i
0

= iXZ.
Let Pn be the Pauli group on n qubits. An element element
e = icXa1Zb1 ⊗ · · · ⊗ XanZbn in Pn, can be mapped to F2n
2
by τ : Pn → F2n
2
as
τ(e) = (a1, . . . , an|b1, . . . , bn).
(6)
Given an [[n, k, d]]2 code with stabilizer S, we can associate
to S (and therefore to the code), a matrix in F(n−k)×2n
2
obtained by taking the image of any set of its generators
under the mapping τ. We shall refer to this matrix as the
stabilizer matrix. We shall refer to the stabilizer as well as any
set of generators as the stabilizer. Additionally, because of the
mapping τ, we shall refer to the stabilizer matrix or any matrix
obtained from it by row reduction or column permutations
also as the stabilizer. The stabilizer matrix can be put in the
so-called “standard form”, [8], [13], see also Lemma 6. This
form also allows us to compute the encoded operators for the
stabilizer code. Recall that the encoded operators allow us to
perform computations on the encoded data without having to
decode the data and then compute.
Deﬁnition 5 (Encoded operators). Given a [[n, k, d]]2 stabi-
lizer code with stabilizer S, let Xi, Zi for 1 ≤ i ≤ k be a set
of 2k linearly independent operators in CPn(S) \ SZ(Pn).
The set of operators {Xi, Zi | 1 ≤ i ≤ k} are said to be
encoded operators for the code if they satisfy the following
requirements.
i) [Xi, Xj] = 0
ii) [Zi, Zj] = 0
iii) [Xi, Zj] = 2δijXiZi
The operators Xi and Zj are referred to as encoded
or logical X and Z operators on the ith and jth logical
qubits, respectively. The choice of which of the 2k linearly
independent elements of CPn(S) \ SZ(Pn) we choose to call
encoded X operators and Z operators is arbitrary; as long
as the generators satisfy the conditions above, any choice
is valid. Different choices lead to different sets of encoded
logical states; alternatively, a different orthonormal basis for
the codespace. Often, as in Lemma 6 below, we refer to the
binary representations of the encoded operators also as the
encoded operators.
Lemma 6 (Standard form of stabilizer matrix [8], [13]). Up
to a permutation π, the stabilizer matrix of an [[n, k, d]]2 code
can be put in the following form,
S =π
 Is′
A1
A2
B
0
C
0
0
0
D
In−k−s′
E

,
(7)
while the associated encoded operators can be derived as

Z
X

=π
 0
0
0
At
2
0
Ik
0
Et
Ik
Ct
0
0

.
(8)
Remark 7. Encoding using essentially same ideas is possible
even if the identity matrices (Is′ in the stabilizer matrix or Ik
in the encoded operators) are replaced by upper triangular
matrices.
The standard form of the stabilizer matrix prompts us to
distinguish between two types of the generators for the stabi-
lizer as they affect the encoding in different ways (although it
can be shown that they are of equivalent complexity).
Deﬁnition
8
(Primary generators). A generator Gi
=
(a1, . . . , an|b1, . . . , bn) with at least one nonzero ai is called
a primary generator.
In other words, primary generators contain at least one X or
Y operator on some qubit. As we shall see in Lemma 10, the
primary generators determine to a large extent the complexity
of the encoding circuit along with the encoded X operators.
The operators X are also called seed generators and they also
ﬁgure in the encoding circuit. The encoded Z operators do
not.
Deﬁnition 9 (Secondary generators). A generator of the form
(0, . . . , 0|b1, . . . , bn) is called secondary generator.
In the standard form encoding, the complexity of the en-
coded X operators is determined by the secondary generators.
Therefore they indirectly contribute3 to the complexity of
encoding.
We mentioned earlier that different choices of the encoded
operators amounts to choosing different orthonormal basis for
the codespace. However, the choice in Lemma 6 is particularly
suitable for encoding. We can represent our input in the form
3Indirect because the submatrix E, ﬁgures in both the secondary generators,
see equation (7), and also the encoded X operators, see equation (8).

147
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
|0⟩⊗n−k
|α1 . . . αk⟩ which allows us to make the identiﬁcation
that |0⟩⊗n
is mapped to
0

, the logical all zero code word.
This state is precisely the state stabilized by the stabilizer
generators and logical Z operators, (which in Lemma 6 can be
seen to be consisting of only Z operators). Given the stabilizer
matrix in the standard form and the encoded operators as in
Lemma 6, the encoding circuit is given as follows.
Lemma 10 (Standard form encoding of stabilizer codes [8],
[13]). Let S be the stabilizer matrix of an [[n, k, d]]2 stabilizer
code in the standard form, i.e., as in equation (7). Let Gj
denote the jth primary generator of S and Xl denote the lth
encoded X operator as in equation (8). Then Gj is in the
form4
(0, . . . , 0, aj = 1, . . . , an|b1, . . . , bs′, 0, . . . , 0, bn−k+1, . . . , bn),
while Xl is in the form
(0, . . . , 0, cs′+1, . . . , cn−k0, . . . , 0, cn−k+l, 0, . . . , 0|d1, . . . , dn),
where dm
= 0 for m ≥ s′ + 1. Let P
= diag(1, i)
and σ(al, bl) = (−i)alblXalZbl. To encode the stabilizer
code we implement the circuits corresponding to each of the
primary generators and the encoded operators. as shown in
Figure 1. The generator Gj is implemented after Gj+1. The
encoded operators precede the primary generators in their
implementation but we can implement Xl before or after
Xl+1.
To encode a stabilizer code, we ﬁrst put the stabilizer matrix
in the standard form, then implement the seed generators, i.e.,
the encoded X operators, followed by the primary generators
j = s′ to j = 1 as per Lemma 10. The complexity of encoding
the jth primary generator is at most n−j two qubit gates and
two single qubit gates. The complexity of encoding an encoded
operator is at most n − k − s′ CNOT gates. This means the
complexity of standard form encoding is upper bounded by
O(n(n − k)) gates.
B. Encoding Subsystem Codes
Theorem 3 shows that in order to encode Clifford codes we
can use a projector derived from the underlying stabilizer to
project onto the codespace. But in case of Clifford subsystem
codes we know that Q = A ⊗ B and the information is to
be actually encoded in A. Hence, it is not sufﬁcient to merely
project onto Q, we must also show that we encode into A
when we encode using the projector deﬁned in Corollary 4.
Let us clarify what we mean by encoding the information in
A and not in B. Suppose that P maps |0⟩ to |ψ⟩A ⊗ |0⟩B and
|1⟩ to |ψ⟩A ⊗ |1⟩B. Then the information is actually encoded
into B. Since the gauge group acts nontrivially on B, this
particular encoding does not protect information. Of course a
subsystem code should not encode (only) into B, but we have
to show that the projector deﬁned by Ps does not do that.
4We allow some freedom in the primary generators, in that instead of Is′
in equation (7), we allow it be an upper triangular matrix also.
|0⟩1
. . .
...
. . .
|0⟩i
. . .
H
•
P bi
|0⟩j+1
. . .
σ(aj+1, bj+1)
...
. . .
...
|0⟩s′
. . .
σ(as′, bs′)
|0⟩s′+1
Xcs′+1
. . .
σ(as′+1, bs′+1)
...
...
. . .
...
|0⟩n−k
Xcn−k
. . .
σ(an−k, bn−k)
|ψ1⟩
. . .
σ(an−k+1, bn−k+1)
...
. . .
...
|ψl⟩
•
. . .
σ(an−k+l, bn−k+l)
...
. . .
...
_ _ _ _

























_ _ _ _
|ψk⟩
. . .
σ(an, bn)
|
{z
}
Xl
Gj
Fig. 1.
Building blocks for standard form encoding of stabilizer codes.
We need the following result on the structure of the gauge
group and the encoded operators of a subsystem code. Poulin
[32] proved a useful result on the structure of the gauge group
and the encoded operators of the subsystem code. But ﬁrst a
little notation. A basis for Pn is Xi, Zi, 1 ≤ i ≤ n, where Xi
and Zi are given as
Xi =
n
O
j=1
Xδij
and
Zi =
n
O
j=1
Zδij.
They satisfy the relations [Xi, Xj] = 0 = [Zi, Zj]; [Xi, Zj] =
2δijXiZj. However, we can choose other generating sets
{xi, zi | 1 ≤ i ≤ n} for Pn that satisfy similar commutation
relations, i.e., [xi, xj] = 0 = [zi, zj] and [xi, zj] = 2δijxizj.
These operators may act nontrivially on many qubits. We often
refer to the pair of operators xi, zi that satisfy the commutation
relations similar to the Pauli operators as a hyperbolic pair.
Given an [[n, k, r, d]] code we could view the state space of
the physical n qubits as that of n virtual qubits on which
these xi, zi act as X and Z operators. In particular k of
these virtual qubits are the logical qubits and r of them
gauge qubits. The usefulness of these operators is that we
can specify the structure of the stabilizer, the gauge group

148
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
and the encoded operators. The following lemma makes this
speciﬁcation precise.
Lemma 11. Let Q be an [[n, k, r, d]]2 subsystem code with
gauge group, G and stabilizer S. Denote the encoded op-
erators by Xi, Zi, 1 ≤ i ≤ k, where [Xi, Xj] = 0 =
[Zi, Zj]; [Xi, Zj] = 2δijXiZj. Then there exist operators
{xi, zi ∈ Pn | 1 ≤ i ≤ n} such that
i) S = ⟨z1, z2, . . . , zs⟩,
ii) G = ⟨S, zs+1, xs+1, . . . , zs+r, xs+r, Z(Pn)⟩,
iii) CPn(S) = ⟨G, X1, Z1, . . . , . . . , Xk, Zk⟩,
iv) Xi = xs+r+i and Zi = zs+r+i, 1 ≤ i ≤ k,
where [zi, zj] = [xi, xj] = 0; [xi, zi] = 2δijxizi. Further, S
deﬁnes an [[n, k + r]] stabilizer code encoding into the same
space as the subsystem code and its encoded operators are
given by {xs+1, zs+1, . . . , xs+r, zs+r, X1, Z1, . . . , Xk, Zk}
Proof: See [32] for proof on the structure of the groups.
Let Q = A ⊗ B, then dim A = 2k and dim B = 2r. From
Corollary 4 we know that the projector deﬁned by S also
projects onto Q (which is 2k+r-dimensional) and therefore it
deﬁnes an [[n, k + r]] stabilizer code. From the deﬁnition of
the operators xi, zi and Xi, Zi and the fact that CPn(S) =
⟨S, xs+1, zs+1, . . . , xs+r, zs+rX1, Z1, . . . , Xk, Zk, Z(Pn)⟩
we see that xi, zi, for s + 1 ≤ i ≤ r act like encoded
operators on the gauge qubits, while Xi, Zi continue to be
the encoded operators on the information qubits. Together
they exhaust the set of 2(k + r) encoded operators of the
[[n, k + r]] stabilizer code.
We observe that the logical operators of the subsystem code
are also logical operators for the underlying stabilizer code.
So if the stabilizer code and the subsystem code have the same
logical all zero state, then Lemma 11 suggests that in order
to encode the subsystem code, we can treat it as stabilizer
code and use the same techniques to encode. If the logical
all zero code word was the same for both the codes, then
because they have the same logical operators we can encode
any given input to the same logical state in both cases. Using
linearity we could then encode any arbitrary state. Encoding
the all zero state seems to be the key. Now, even in the case of
the stabilizer codes, there is no unique all zero logical state.
There are many possible choices. Given the encoded operators
it is easy to deﬁne the logical all zero state as the following
deﬁnition shows:
Deﬁnition 12. A logical all zero state of an [[n, k, r, d]]
subsystem code is any state that is ﬁxed by its stabilizer and
k logical Z operators.
This deﬁnition is valid in case of stabilizer codes also. This
deﬁnition might appear a little circular. After all, we seem
to have assumed the deﬁnition of the logical Z operators.
Actually, this is a legitimate deﬁnition because, depending
on the choice of our logical operators, we can have many
choices of the logical all zero state. In case of the subsystem
codes, this deﬁnition implies that the logical all zero state is
ﬁxed by n − r operators, consequently it can be any state in
that 2r-dimensional subspace. If we consider the [[n, k + r]]
stabilizer code that is associated to the subsystem code, then
its logical zero is additionally ﬁxed by r more operators. So
any logical zero of the stabilizer code is also a logical all
zero state of the subsystem code. It follows that if we know
how to encode the stabilizer code’s logical all zero, we know
how to encode the subsystem code. We are interested in more
than merely encoding the subsystem code of course. We also
want to leverage the gauge qubits to simplify and/or make the
encoding process more robust. Perhaps a few examples will
clarify the ideas.
C. Illustrative Examples
Consider the following [[4, 1, 1, 2]]2 subsystem code, with
the gauge group G, stabilizer S and encoded operators given
by L.
S
=
 X
X
X
X
Z
Z
Z
Z

=
 z1
z2

,
G
=


X
X
X
X
Z
Z
Z
Z
I
X
I
X
I
I
Z
Z

 =


z1
z2
x3
z3

 .
The encoded operators of this code are given by
L
=

I
I
X
X
I
Z
I
Z

=

X1
Z1

.
The associated [[4, 2]] stabilizer code has the following en-
coded operators.
T
=


I
X
I
X
I
I
X
X
I
I
Z
Z
I
Z
I
Z

 =


x3
X1
z3
Z1

 .
It will be observed that the encoded X operators of [[4, 2]] are
in a form convenient for encoding. We treat the [[4, 1, 1, 2]]
code as [[4, 2]] code and encode it as in Figure 2. The gauge
qubits are permitted to be in any state.
|0⟩
H
•
|g⟩
•


|ψ⟩
•


|0⟩






Fig. 2.
Encoding the [[4, 1, 1, 2]] code (Gauge qubits can be in any state).
Assuming g = a |0⟩ + b |1⟩, the logical states up to a
normalizing constant are
0

=
a(|0000⟩ + |1111⟩) + b(|0101⟩ + |1010⟩),
1

=
a(|0011⟩ + |1100⟩) + b(|0110⟩ + |1001⟩).
It can be easily veriﬁed that S stabilizes the above state and
while the gauge group acts in a nontrivial fashion, the resulting
states are still orthogonal. In this example we have encoded
as if we were encoding the [[4, 2]] code. Prior to encoding

149
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
the gauge qubits can be identiﬁed with physical qubits. After
the encoding however such a correspondence between the
physical qubits and gauge qubits does not necessarily exist in a
nontrivial subsystem code. Since the encoded operators of the
subsystem code are also encoded operators for the stabilizer
code, we are guaranteed that the information is not encoded
into the gauge subsystem.
As the state of gauge qubits is of no consequence, we can
initialize them to any state. Alternatively, if we initialized them
to zero, we can simplify the circuit as shown in Figure 3.
|0⟩
H
•
|0⟩


|ψ⟩
•


|0⟩




Fig. 3.
Encoding the [[4, 1, 1, 2]] code (Gauge qubits initialized to zero).
The encoded states in this case are (again, the normalization
factors are ignored)
0

=
|0000⟩ + |1111⟩ ,
1

=
|0011⟩ + |1100⟩ .
The beneﬁt with respect to the previous version is that at the
cost of initializing the gauge qubits, we have been able to
get rid of all the encoded operators associated with them.
This seems to be a better option than randomly initializing
the gauge qubits. Because it is certainly easier to prepare
them in a known state like |0⟩, rather than implement a
series of controlled gates depending on the encoded operators
associated with those qubits.
At this point we might ask if it is possible to get both the
beneﬁts of random initialization of the gauge qubits as well
as avoid implementing the encoded operators associated with
them. To answer this question let us look a little more closely
at the previous two encoding circuits for the subsystem codes.
We can see from them that it will not work in general. Let us
see why. If we initialize the gauge qubit to |1⟩ instead of |0⟩
in the encoding given in Figure 3, then the encoded state is
0

=
|0100⟩ + |1011⟩ ,
1

=
|0111⟩ + |1000⟩ .
Both these states are not stabilized by S, indicating that these
states are not in the code space.
In general, an encoding circuit where it is simultaneously
possible initialize the gauge qubits to random states and also
avoid the encoded operators is likely to be having more
complex primary generators. For instance, let us consider the
following [[4, 1, 1, 2]] subsystem code:
S
=
 X
Z
Z
X
Z
X
X
Z

=
 z1
z2

,
G
=


X
Z
Z
X
Z
X
X
Z
Z
I
X
I
I
Z
Z
I

 =


z1
z2
x3
z3

 .
The encoded operators of this code are given by
L
=
 I
Z
I
X
Z
I
I
Z

=
 X1
Z1

.
The associated [[4, 2]] stabilizer code has the following en-
coded operators.
T
=


Z
I
X
I
I
Z
I
X
I
Z
Z
I
Z
I
I
Z

 =


x3
X1
z3
Z1

 .
The encoding circuit for this code is given by
|0⟩
H
•
|0⟩
H
•
Z
|g⟩
X
Z
|ψ⟩
Z
X
Fig. 4.
Encoding [[4, 1, 1, 2]] code (Encoded operators for the gauge qubits
are trivial and gauge qubits can be initialized to random states).
In this particular case, the gauge qubits (as well as the
information qubits) do not require any additional encoding
circuitry. In this case we can initialize the gauge qubits to
any state we want. But, the reader would have observed we
did not altogether end up with a simpler circuit. The primary
generators are two as against one and the complexity of the
encoded operators has been shifted to them. So even though
we were able to get rid of the encoded operator on the gauge
qubit and also get the beneﬁt of initializing it to a random state,
this is still more complex compared to either of encoders in
Figures 2 and 3. Our contention is that it is better to initialize
the gague qubits to zero state and not implement the encoded
operators associated to them.
V. ENCODING SUBSYSTEM CODES BY STANDARD FORM
METHOD
The previous two examples might lead us to conclude that
we can take the stabilizer of the given subsystem code and
form the encoded operators by reducing the stablizer to its
standard form and encode as if it were a stabilizer code.
However, there are certain subtle points to be kept in mind.
When we form the encoded operators we get k + r encoded
operators; we cannot from the stabilizer alone conclude which
are the encoded operators on the information qubits and which
on the gauge qubits. Put differently, these operators belong

150
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
to the space CPn(S) \ S = GCPn(G) \ SZ(Pn). It is not
guaranteed that they are entirely in CPn(G), i.e., we cannot
say if they act as encoded operators on the logical qubits. This
implies that in general all these operators act nontrivially on
both A and B. Consequently, we must be careful in choosing
the encoded operators and the gauge group must be taken into
account.
We give two slightly different methods for encoding subsys-
tem codes. The difference between the two methods is subtle.
Both methods require the gauge qubits to be initialized to
zero. In the second method (see Algorithm 2) however, we can
avoid the encoded operators associated to them. Under certain
circumstances, we can also permit initialization to random
states. In both algorithms 1 and 2 we assume the same notation
as in Lemma 11.
Algorithm 1 Encoding subsystem codes–Standard form
Require: Stabilizer, S
=
⟨z1, . . . , zn−k−r⟩ and gauge
group, G = ⟨S, xs+1, zs+1, . . . , xs+r, zs+r, Z(Pn)⟩ of the
[[n, k, r, d]] subsystem code.
Ensure: [xi, xj] = [zi, zj] = 0; [xi, zj] = 2xiziδij
1: Form SA = ⟨S, zs+1, . . . , zs+r⟩, where s = n − k − r
2: Compute the standard form of SA as per Lemma 6
SA =π
 Is′
A1
A2
B
0
C
0
0
0
D
Is+r−s′
E

3: Compute the encoded operators X1, . . . , Xk as
 Z
X

=π
 0
0
0
At
2
0
Ik
0
Et
Ik
Ct
0
0

4: Encode using the primary generators of SA and Xi as
encoded operators, see Lemma 10; all the other (n − k)
qubits are initialized to |0⟩.
Correctness of Algorithm 1. Since stabilizer SA ≥ S, the
space stabilized by SA is a subspace of the A⊗B, the subspace
stabilized by S. As |SA|/|S| = 2r, the dimension of the
subspace stabilized by SA is 2k+r/2r = 2k. Additionally,
the generators zs+1, . . . , zs+r act trivially on A. The encoded
operators as computed in the algorithm act nontrivially on A
and give 2k orthogonal states; thus we are assured that the
information is encoded into A.
Let us encode the [[9, 1, 4, 3]] Bacon-Shor code [3] using
the method just proposed. The stabilizer and the gauge group
are given5 by
S
=


X
X
X
X
X
X
X
X
X
X
X
X
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z

 ,
5We do not show the identity.
G
=


X
X
X
X
X
X
X
X
X
X
X
X
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
X
X
X
X
X
X
X
X
Z
Z
Z
Z
Z
Z
Z
Z


=


S
Gx
Gz

 .
Let us form SA by augmenting S with Gz. Then
SA
=


X
X
X
X
X
X
X
X
X
X
X
X
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z


.
The encoded X and Z operators are X7X8X9 and Z1Z4Z7,
respectively. After putting SA in the standard form, and
encoder for this code is given in Figure 5.
|0⟩
H
•
|0⟩


|0⟩


|0⟩
H
•
|0⟩


|0⟩


|0⟩






|0⟩






|ψ⟩
•




Fig. 5.
Encoder for the [[9, 1, 4, 3]] code. This is also an encoder for the
[[9, 1, 3]] code
If on the other hand we had formed SA by adding Gx
instead, then SA would have been
SA =


X
X
X
X
X
X
X
X
X
X
X
X
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z
Z


.

151
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
The encoded operators remain the same. In this case the
encoding circuit is given in Figure 6.
|0⟩
H
•
|0⟩
H
•
|0⟩
H
•
|0⟩
H
•
|0⟩
H
•
|0⟩
H
•
|0⟩






|0⟩






|ψ⟩
•




Fig. 6.
Encoder for the [[9, 1, 4, 3]] code with fewer CNOT gates.
The circuit in Figure 6 has fewer CNOT gates, though the
number of single qubit gates has increased. Since we expect
the implementation of the CNOT gate to be more complex
than the H gate, this might be a better choice. If on the other
hand we interchanged the encoded X and Z operators, we
could end up with a simpler circuit, see Figure 7, equivalent
to the one proposed by Shor for the [[9, 1, 3]] code.
In any case, this demonstrates that by exploiting the gauge
qubits one can ﬁnd ways to reduce the complexity of encoding
circuit.
The gauge qubits provide a great degree of freedom in
encoding. We consider the following variant on standard form
encoding, where we try to minimize the the number of primary
generators. This is not guaranteed to reduce the overall com-
plexity, since that is determined by both the primary generators
and the encoded operators. Fewer primary generators might
usually imply encoded operators with larger complexity. In
fact we have already seen, that in the case of [[9, 1, 4, 3]]2 code
|0⟩


|0⟩


|0⟩


|0⟩


|0⟩


|0⟩


|0⟩


H
•
•
|0⟩


H
•
•
|ψ⟩
•
H
•
•
Fig. 7.
Encoder for an equivalent [[9, 1, 4, 3]] code (logical X and Z
interchanged).
that a larger number of primary generators does not necessarily
imply higher complexity. However, it has the potential for
lower complexity.
Algorithm 2 Encoding subsystem codes–Standard form
Require: Stabilizer, S
=
⟨z1, . . . , zn−k−r⟩ and gauge
group, G = ⟨S, xs+1, zs+1, . . . , xs+r, zs+r, Z(Pn)⟩ of the
[[n, k, r, d]] subsystem code.
Ensure: [xi, xj] = [zi, zj] = 0; [xi, zj] = 2xiziδij
1: Compute the standard form of S as per Lemma 6
S =π1

Is′
A1
A2
B
0
C
0
0
0
D
Is−s′
E

2: Form SA = ⟨S, zs+1, . . . , zs+r⟩, where s = n − k − r
3: Compute the standard form of SA as per Lemma 6
SA =π2

Il
F1
F2
G1
0
G2
0
0
0
D′
Is+r−l
H

4: Compute the encoded operators X1, . . . , Xk as
 Z
X

=π2
 0
0
0
F t
2
0
Ik
0
Ht
Ik
Gt
2
0
0

5: Encode using the primary generators of S and Xi as en-
coded operators, accounting for π1 and π2, see Lemma 10;
all the other (n − k) qubits are initialized to |0⟩.
The main difference in the second method comes in lines 1
and 5. We encode using the primary generators of the stabilizer
of the subsystem code instead of the augmented stabilizer. The
encoded operators however remain the same as before.
Correctness of Algorithm 2. The correctness of this method
lies in the observation we made earlier (see discussion fol-
lowing Deﬁnition 12), that any logical all zero state of the
stabilizer code is also a logical all zero of the subsystem
code and the fact that both share the encoded operators on
the encoded qubits.
Remark 13. The permutation π2 in Algorithm 2 can be
restricted to the last n − s′ columns, since while adjoining
the additional r generators to S, we could take it to be in the
standard form.
The encoded operators are given modulo the elements of the
gauge group as in Algorithm 1, which implies that the their
action might be nontrivial on the gauge qubits. The beneﬁt of
the second method is when S and SA have different number of
primary generators. The following aspects of both the methods
are worth highlighting.
1) The gauge qubits must be initialized to |0⟩ in both methods.
2) In Algorithm 1, the number of primary generators of S
and SA can be different leading to a potential increase in
complexity compared to encoding with S.
3) In both methods, the encoded operators as computed are
modulo SA. Consequently, the encoded operators might act
nontrivially on the gauge qubits.

152
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
VI. ENCODING SUBSYSTEM CODES BY CONJUGATION
METHOD
The other beneﬁt of subsystem codes is the random ini-
tialization of the gauge qubits. We now give circuits where
we can encode the subsystem codes to realize this beneﬁt.
But instead of using the standard form method we will use
the conjugation method proposed by Grassl et al., [16] for
stabilizer codes. After brieﬂy reviewing this method we shall
show how it can be modiﬁed for encoding subsystem codes.
The conjugation encoding method can be understood as
follows. It is based on the idea that the Clifford group
acts transitively on the Pauli error group. Therefore, we can
transform the stabilizer of an arbitrary [[n, k, d]] code to
the trivial stabilizer given by ⟨Z1, . . . , Zn−k⟩. Additionally,
we can also transform the encoded operators Xi, Zi to
Xn−k+i, Zn−k+i for 1 ≤ i ≤ k. Put differently, we transform
the stabilizer matrix of any [[n, k, d]] stabilizer code into the
matrix (00|In−k0). The associated encoded X and Z operators
are given by (0Ik|00) and (00|0Ik) respectively. For a code
with this stabilizer matrix the encoding is trivial. We simply
map |ψ⟩ to |0⟩⊗n−k
|ψ⟩. Here we give a sketch of the method
for the binary case, the reader can refer to [16] for details.
Assume that the stabilizer matrix is given by S. Then
we shall transform it into (00|In−k0) using the following
sequence of operations.
(X|Z) 7→ (In−k0|0) 7→ (00|In−k0).
(9)
This can be accomplished through the action of H =
 1
1
1 −1

,
P
= [ 1 0
0 i ] and CNOT gates on the Pauli group under
conjugation. The H gate acting on the ith qubit on (a|b) =
(a1, . . . , an|b1, . . . , bn) transforms it as
(a|b)
Hi
7→ (a1, . . . , bi, . . . , an|b1, . . . , ai, . . . , bn).
(10)
These modiﬁed entries have been highlighted for conve-
nience. The phase gate P
on the ith qubit transforms
(a1, . . . , an|b1, . . . , bn) as
(a|b)
Pi
7→ (a1, . . . , ai, . . . , an|b1, . . . , ai + bi, . . . , bn).
(11)
We denote the CNOT gate with the control on the ith qubit
and the target on the jth qubit by CNOTi,j. The action of the
CNOTi,j gate on (a1, . . . , an|b1, . . . , bn) is to transform it to
(a1, . . . , aj−1, aj + ai, . . . , an|b1, . . . , bi−1, bi + bj, . . . , bn).
Note that the jth entry is changed in the X part while the ith
entry is changed in the Z part. For example, consider
(1, 0, 0, 1, 0|0, 1, 1, 0, 0)
CNOT1,4
7→
(1, 0, 0, 0, 0|0, 1, 1, 0, 0),
(1, 0, 0, 1, 0|0, 1, 1, 1, 0)
CNOT1,4
7→
(1, 0, 0, 0, 0|1, 1, 1, 1, 0).
Based on the action of these three gates we have the following
lemmas to transform error operators.
Lemma 14. Assume that we have a error operator of the form
(a1, . . . , an|b1, . . . , bn). Then we apply the following gates on
the ith qubit to transform the stabilizer, transforming (ai, bi)
to (α, β) as per the following table.
(ai, bi)
Gate
(α, β)
(0,0)
I
(0,0)
(0,1)
H
(1,0)
(1,0)
I
(1,0)
(1,1)
P
(1,0)
Let ¯x denote 1 + x mod 2, then the transformation to
(a′
1, . . . , a′
n|0, . . . , 0) is achieved by
n
O
i=1
H¯aibiP aibi.
For
example,
consider
the
following
generator
(1, 0, 0, 1, 0|0, 1, 1, 1, 0).
This
can
be
transformed
to
(1, 1, 1, 1, 0|0, 0, 0, 0, 0)
by
the
application
of
I ⊗ H ⊗ H ⊗ P ⊗ I.
Lemma
15. Let e be an error operator of the form
(a1, . . . , ai = 1, . . . , an|0, . . . , 0). Then e can be transformed
to (0, . . . , 0, ai = 1, 0, . . . , 0|0, . . . , 0) by
n
Y
j=1,i̸=j

CNOTi,jaj .
As an example consider (1, 1, 1, 1, 0|0, 0, 0, 0, 0), this can
be transformed to (0, 1, 0, 0, 0|0, 0, 0, 0, 0) by
CNOT2,1 · CNOT2,3 · CNOT2,4.
The ﬁrst step involves making the Z portion of the stabilizer
matrix all zeros. This is achieved by single qubit operations
consisting of H and P performed on each row one by one.
Note that we must also modify the other rows of the
stabilizer matrix according to the action of the gates applied.
Once we have a row of stabilizer matrix in the form
(a|0), where a is nonozero we can transform it to the form
(0, . . . , 0, ai = 1, 0, . . . , 0|0) by using CNOT gates. Thus it
is easy to transform (X|Z) to (In−k0|0) using CNOT, P and
H gates. The ﬁnal transformation to (0|In−k0) is achieved
by using H gates on the ﬁrst n − k qubits. At this point the
stabilizer matrix has been transformed to a trivial stabilizer
matrix which stabilizes the state |0⟩⊗n−k
|ψ⟩. The encoded
operators are (0Ik|0) and (0|0Ik). Let T be the sequence of
gates applied to transform the stabilizer matrix to the trivial
stabilizer matrix. Then T applied in the reverse order to
|0⟩⊗n−k
|ψ⟩ gives the encoding circuit for the stabilizer code.
Now we shall use the conjugation method to encode the
subsystem codes. The main difference with respect to [16]
is that instead of considering just the stabilizer we need to
consider the entire gauge group. Let the gauge group be
G = ⟨S, GZ, GX, Z(Pn)⟩, where GZ = ⟨zs+1, . . . , zs+r⟩,
and GX = ⟨xs+1, . . . , xs+r⟩. The idea is to transform the
gauge group as follows.
G =


S
GZ
GX

 7→


0
0
0
Is
0
0
0
0
0
0
Ir
0
0
Ir
0
0
0
0

 .
(12)

153
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
At this point the gauge group has been transformed to a group
with trivial stabilizer and trivial encoded operators for the
gauge qubits and the encoded qubits. The sequence of gates
required to achieve this transformation in the reverse order
will encode the state |0⟩⊗s
|φ⟩ |ψ⟩. The state |φ⟩ corresponds
to the gauge qubits and it can be initialized to any state, while
|ψ⟩ corresponds to the input.
Algorithm 3 Encoding subsystem codes–Conjugation method
Require: Gauge group G of the [[n, k, r, d]] subsystem code.
G = ⟨S, GZ, GX, Z(Pn)⟩, where S = {z1, . . . , zn−k−r},
GZ = {zs+1, . . . , zs+r}, and GX = {xs+1, . . . , xs+r}.
Ensure: [xi, xj] = [zi, zj] = 0; [xi, zj] = 2xiziδij
1: Assume that G is in the form G =


S
GZ
GX

.
2: for all i = 1 to s + r do
3:
Transform zi to z′
i = (a1, . . . , ai = 1, . . . , an|0) using
Lemma 14
4:
Transform
z′
i
to
(0, . . . , ai
=
1, . . . , 0|0)
using
Lemma 15
5:
For i ≤ s perform Gaussian elimination on column i
for rows j > i
6: end for
7: Apply H gate on each qubit i = 1 to i = s + r
8: for all i = s + 1 to s + r do
9:
Transform xi to x′
i
=
(a1, . . . , an|0, . . . , 0) using
Lemma 14
10:
Transform x′
i
to (0, . . . , ai
=
1, . . . , 0|0) using
Lemma 15
11:
Perform Gaussian elimination on column i for rows j >
i
12: end for
In the above algorithm, we assume that whenever a row of G
is transformed according to Lemma 14 or 15, all the other rows
are also transformed according to the transformation applied.
The lines 8–12 are essentially responsible for the tolerance to
initialization errors on the gauge qubits.
Correctness of Algorithm 3. The correctness of the algorithm
is straightforward. As G has full rank of n − k + r, for each
row of G, we will be able to ﬁnd some nonzero pair (a, b) so
that the transformation of S and GZ to (Is+r0|0) (lines 2–6)
can be achieved. After line 7, when S and GZ are in the form
(0|Is+r0), the rows in GX are in the form
 0
A
B
0
C
D 
.
(13)
The ﬁrst n−k−r columns of the (transformed) GX are all zero
because they must commute with (0|Is0), the elements of the
transformed stabilizer, while the remaining zero columns are
due to Gaussian elimination. The submatrix A must have rank
r, otherwise at this point one of the rows of GX commutes
with all the rows of GZ and the condition that there are r
hyperbolic pairs is violated. In fact we must have A = Ir.
Therefore it is possible to transform equation (13) to the form
(0Ir0|0). Thus Algorithm 3 transforms G to the form given
in equation (12). The encoded operators for this gauge group
are clearly (0Ik|0) and (0|0Ik). The transformations in reverse
order encode the subsystem code.We conclude with a simple
example that illustrates the process.
Example. Consider the following [[4, 1, 1, 2]] code. Let the
gauge group G, stabilizer S be given as
S
=
 X
X
X
X
Z
Z
Z
Z

=
 z1
z2

,
G
=


X
X
X
X
Z
Z
Z
Z
I
I
Z
Z
I
X
I
X

 =


z1
z2
x3
z3

 .
In matrix form G can be written as
G
=


1
1
1
1
0
0
0
0
0
0
0
0
1
1
1
1
0
0
0
0
0
0
1
1
0
1
0
1
0
0
0
0

 .
The
transformations
consisting
of
T1
=
CNOT1,2CNOT1,3CNOT1,4 followed by T2 = I ⊗H ⊗H ⊗H
maps G to
T1
7→


1
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
1
1
0
1
0
1
0
0
0
0


T2
7→


1
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
1
0
1

 .
Now transform the second row using T3 = CNOT2,3CNOT2,4.
Then transform using T4 = CNOT4,3. We get
T3
7→


1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
1


T4
7→


1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1

 .
Applying T5 = H ⊗ H ⊗ I ⊗ H gives us
T5
7→


0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1

 .
We could have chosen T5 = H ⊗H ⊗I ⊗I, since the effect of
H on the fourth qubit is trivial. The complete circuit is given
in Figure 8.
The algorithm guarantees (due to lines 8–12) that just prior
to encoding the gauge qubits can be identiﬁed with physical
qubits. Since we do not care about the state of the gauge
qubits, we can tolerate arbitrary errors on the physical qubits

154
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
|0⟩
H
•
|0⟩
H
•
H


|ψ⟩




H


|g⟩
H
•


H


Fig. 8.
Encoding [[4, 1, 1, 2]] code by conjugation method.
at this point. In the present case |g⟩. By switching the target
and control qubits of the CNOT gates in T3 and T4 we can
show that this circuit is equivalent to circuit shown in Figure 9.
|0⟩
H
•
|0⟩






|ψ⟩
H
•
•


|g⟩


•


_ _ _ _







_ _ _ _
Fig. 9.
Encoding [[4, 1, 1, 2]] code by conjugation method.
It is instructive to compare the circuit in Figure 9 with
the one given earlier in Figure 2. The dotted lines show the
additional circuitry. Since the gauge qubit can be initialized
to any state, we can initialize |g⟩ to |0⟩, which then gives the
following logical states for the code.
0

=
|0000⟩ + |1111⟩ + |0011⟩ + |1100⟩ ,
(14)
1

=
|0000⟩ + |1111⟩ − |0011⟩ − |1100⟩ .
(15)
It will be observed that IIXX acts as the logical Z operator
while IZIZ acts as the logical X operator. We could ﬂip
these logical operators by absorbing the H gate into |ψ⟩. If
we additionally initialize |g⟩ to |0⟩, we will see that the two
CNOT gates on the second qubit can be removed. The circuit
then simpliﬁes to the circuit shown in Figure 10.
|0⟩
H
•
|0⟩


|ψ⟩
•


|0⟩




Fig. 10.
Encoding [[4, 1, 1, 2]] code by conjugation method – optimized.
This is precisely, the same circuit that we had arrived earlier
in Figure 3 using the standard form method. The preceding
example provides additional evidence in the direction that it
is better to initialize the gauge qubits to zero and avoid the
encoding operators on them.
Two important optimizations are possible in Algorithm 3.
Firstly, we could choose to initialize the gauge qubits to all
zero and then we could dispense with the lines 8–12. Secondly,
we could also dispense with line 4 for s + 1 ≤ i ≤ s + r
when the gauge qubits are initialized to all zero. The ﬁrst
optimization trades off random initialization with all zero
initialization. The second one will lead to a further reduction
in CNOT gates.
VII. SUMMARY
We now brieﬂy summarize the main results of this paper.
The recent activity in subsystem codes was motivated to a
great extent by the promise of efﬁcient error recovery schemes.
A largely neglected aspect in the study of subsystem codes was
that of encoding schemes for these codes. In this paper we
have argued that subsystem codes afford beneﬁts in this area
as well that are worth studying. Given a subsystem code, one is
concerned with how to encode the bare quantum information.
We showed here that there are some beneﬁts to be gained,
namely, that some of the qubits are resistant to noise even in
an unencoded stage. We then showed that this tolerance can
be traded for reduced complexity.
Speciﬁcally, we showed ﬁrst that subsystem codes can be
encoded using the techniques used for stabilizer codes. In
the process, we also showed how to encode Clifford codes,
a class of codes that generalize the stabilizer codes and
which are useful in the construction of subsystem codes. We
then focussed on giving explicit encoding circuits for the
binary subsystem codes. In particular, we have considered
two methods for encoding stabilizer codes—the standard form
method and the conjugation method. Both these methods can
be easily generalized to the nonbinary codes.
We also showed the gauge degrees of freedom can be
exploited to tolerate initialization errors on some qubits or
a reduced complexity of encoding. While the standard form
method explored here required us to initialize the gauge qubits
to zero, it admits two variants and seems to have the potential
for lower complexity; the exact gains being determined by
the actual codes under consideration. The conjugation method
allows us to initialize the gauge qubits to any state. The
disadvantage seems to be the increased complexity of encod-
ing. It must be emphasized that the standard form method
is equivalent to the conjugation method and it is certainly
possible to use this method to encode subsystem codes so that
the gauge qubits can be initialized to arbitrary states. However,
it appears to be a little more cumbersome and for this reason
we have not investigated this possibility in this paper.
Stabilizer codes can also be encoded using teleportation. We
expect that gauge qubits can be exploited even in this method
to reduce its complexity. It would be interesting to investigate
fault tolerant encoding schemes for subsystem codes exploiting
the gauge qubits.
ACKNOWLEDGMENT
We thank Markus Grassl for very helpful discussions. We
also thank the referees for their comments which helped
improve the presentation of the paper. This research was
supported by NSF CAREER award CCF 0347310 and NSF

155
International Journal on Advances in Security, vol 2 no 2&3, year 2009, http://www.iariajournals.org/security/
grant CCF 0622201. P.S. was also supported by grants from
NSERC, MITACS and CIFAR.
REFERENCES
[1] P. Aliferis and A. W. Cross. Sub-system fault tolerance with the bacon-
shor code. quant-ph/0610063, 2006.
[2] S. A. Aly, A. Klappenecker, and P. K. Sarvepalli. Subsystem codes. In
Forty-Fourth Annual Allerton Conference on Communication, Control,
and Computing, Illinois, USA, 2006.
[3] D. Bacon.
Operator quantum error correcting subsystems for self-
correcting quantum memories. Phys. Rev. A, 73(012340), 2006.
[4] C.H. Bennett, D.P. DiVincenzo, J.A. Smolin, and W.K. Wootters. Mixed
state entanglement and quantum error correction. Physical Review A,
54:3824–3851, 1996.
[5] A.R. Calderbank, E.M. Rains, P.W. Shor, and N.J.A. Sloane. Quantum
error correction via codes over GF(4).
IEEE Trans. Inform. Theory,
44:1369–1387, 1998.
[6] H. Chen. Some good quantum error-correcting codes from algebraic-
geometric codes. IEEE Trans. Inform. Theory, 47:2059–2061, 2001.
[7] H. Chen, S. Ling, and C. Xing. Asymptotically good quantum codes
exceeding the Ashikhmin-Litsyn-Tsfasman bound. IEEE Trans. Inform.
Theory, 47:2055–2058, 2001.
[8] R. Cleve and D. Gottesman. Efﬁcient computations of encodings for
quantum error correction. Phys. Rev. A, 56(1):76–82, 1997.
[9] R. Cleve, D. Gottesman, and H.-K. Lo. How to share a quantum secret.
Phys. Rev. Lett., 83(3):648–651, 1999.
[10] K. Feng.
Quantum error-correcting codes.
In Coding Theory and
Cryptology, pages 91–142. World Scientiﬁc, 2002.
[11] K. Feng, S. Ling, and C. Xing. Asymptotic bounds on quantum codes
from algebraic geometric codes. IEEE Trans. Inform. Theory, 52(3):986–
991, 2006.
[12] D. Gottesman. A class of quantum error-correcting codes saturating the
quantum Hamming bound. Phys. Rev. A, 54:1862–1868, 1996.
[13] D. Gottesman. Stabilizer codes and quantum error correction. Caltech
Ph. D. Thesis, eprint: quant-ph/9705052, 1997.
[14] D. Gottesman.
Theory of quantum secret sharing.
Phys. Rev. A,
61(042311), 2000.
[15] D. Gottesman. An introduction to quantum error correction and fault-
tolerant quantum computation. arXiv:0904.2557, 2009.
[16] M. Grassl, M. R¨otteler, and T. Beth. Efﬁcient quantum circuits for non-
qubit quantum error-correcting codes. Internat. J. Found. Comput. Sci.,
14(5):757–775, 2003.
[17] G. James and M. Liebeck. Representations and Characters of Groups.
Cambridge University Press, Cambridge, 2001.
[18] K. Julia. Approaches to quantum error correction. quant-ph/0612185,
2006.
[19] A. Ketkar, A. Klappenecker, S. Kumar, and P.K. Sarvepalli.
Nonbi-
nary stabilizer codes over ﬁnite ﬁelds.
IEEE Trans. Inform. Theory,
52(11):4892–4914, 2006.
[20] A. Klappenecker and M. R¨otteler. Beyond stabilizer codes II: Clifford
codes. IEEE Trans. Inform. Theory, 48(8):2396–2399, 2002.
[21] A. Klappenecker and P. K. Sarvepalli. Clifford code constructions of
operator quantum error-correcting codes. IEEE Trans. Inform. Theory,
54(12):5760–5765, 2008.
[22] E. Knill. Group representations, error bases and quantum codes. Los
Alamos National Laboratory Report LAUR-96-2807, 1996.
[23] E. Knill. Non-binary unitary error bases and quantum codes. Los Alamos
National Laboratory Report LAUR-96-2717, 1996.
[24] E. Knill.
On protected realizations of quantum information.
Eprint:
quant-ph/0603252, 2006.
[25] E. Knill and R. Laﬂamme. A theory of quantum error–correcting codes.
Physical Review A, 55(2):900–911, 1997.
[26] D. Kretschmann, D. W. Kribs, and R. W. Spekkens. Complementarity of
private and correctable subsystems in quantum cryptography and error
correction. Phys. Rev. A, 78:032330, 2008.
[27] D. W. Kribs. A brief introduction to operator quantum error correction.
Contemporary Mathematics, American Mathematical Society, 414:27–
34, 2005. Eprint: math/0506491.
[28] D. W. Kribs, R. Laﬂamme, and D. Poulin.
Uniﬁed and generalized
approach to quantum error correction.
Phys. Rev. Lett., 94(180501),
2005.
[29] D. W. Kribs, R. Laﬂamme, D. Poulin, and M. Lesosky.
Operator
quantum error correction. Eprint: quant-ph/0504189, 2005.
[30] W.J. Martin. A physics-free introduction to quantum error correcting
codes. Util. Math., pages 133–158, 2004.
[31] M. A. Nielsen and I. L. Chuang. Quantum Computation and Quantum
Information. Cambridge University Press, Cambridge, 2000.
[32] D. Poulin. Stabilizer formalism for operator quantum error correction.
Phys. Rev. Lett., 95(230504), 2005.
[33] D. Poulin. Operator quantum error correction: An overview. [Online]
http://www.physique.usherbrooke.ca/˜dpoulin/
Documents/OQEC.pdf,
2006.
[34] P. K. Sarvepalli and A. Klappenecker. Encoding subsystem codes with
and without noisy gauge qubits.
In Proc. of the Third International
Conference on Quantum, Nano and Micro Technologies, pages 48–53,
2009.
[35] P. Shor and J. Preskill. Simple proof of security of the BB84 quantum
key distribution protocol. Phys. Rev. Lett., 85(441), 2000.

