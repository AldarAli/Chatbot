239
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Safety by Construction: Well-behaved Scalable Systems
Peter Ochsenschläger∗ and Roland Rieke∗†
∗Fraunhofer Institute for Secure Information Technology SIT, Darmstadt, Germany
†Philipps-Universität Marburg, Germany
Email: peter-ochsenschlaeger@t-online.de, roland.rieke@sit.fraunhofer.de
Abstract—This paper presents a formal framework
that provides construction principles for well-behaved
scalable systems, such that starting with a prototype
system satisfying a desired safety property result in
a scalable system satisfying a corresponding safety
property, called scalable safety property. With respect
to diﬀerent aspects of scalability, the focus of this
work is on property preserving structural scalability.
At that, we consider systems composed of a varying
set of individual components where individual com-
ponents of the same type behave in the same manner,
which is characteristic for the type. The respective
properties can rely on speciﬁc component types and
a speciﬁc number of individual components but not
on the speciﬁc individuality of the components. Well-
behaved scalable systems are characterised by those
systems, which fulﬁl such a kind of property if already
one prototype system (depending on the property)
fulﬁls that property. Suﬃcient conditions to specify
a certain kind of basic well-behaved scalable systems
are given and it is shown, how to construct more com-
plex systems by the composition of several synchro-
nisation conditions. Scalable safety properties can be
used to express privacy policies as well as security
and dependability requirements. It is demonstrated,
how the parameterised problem of verifying such a
property is reduced to a ﬁnite state problem for well-
behaved scalable systems. The formal framework for
well-behaved scalable systems is developed in terms
of preﬁx closed formal languages and alphabetic lan-
guage homomorphisms.
Keywords-uniformly parameterised systems, mono-
tonic
parameterised
systems,
behaviour-abstraction,
self-similarity of behaviour, privacy policies, scalable
safety properties.
I. Introduction
This article is based on [1], where the concept of
well-behaved scalable systems has been introduced. It
is extended by extensive proofs of the theorems and
the deﬁnition of scalable safety properties as well as
their veriﬁcation for well-behaved scalable systems. This
is illustrated by a complex example, where several
synchronisation conditions are composed.
Scalability is a desirable property of systems. However,
the term scalability is often not clearly deﬁned and thus
it is diﬃcult to characterise and understand systems
with respect to their scalability properties [2]. In [3],
four aspects of scalability are considered, i.e., load
scalability, space scalability, space-time scalability, and
structural scalability. In this paper, we focus on structural
scalability, which is “the ability of a system to expand in
a chosen dimension without major modiﬁcations to its
architecture” [3]. Examples of systems that need to be
highly scalable comprise grid computing architectures and
cloud computing platforms [4], [5]. Usually, such systems
consist of few diﬀerent types of components and for each
such type a varying set of individual components exists.
Component types can be deﬁned in such a granularity
that individual components of the same type behave in
the same manner, which is characteristic for the type. For
example, a client-server system that is scalable consists
of the component types client and server and several sets
of individual clients as well as several sets of individual
servers. Let us now call a choice of sets of individual
components an admissible choice of individual component
sets, iﬀ for each component type exactly one set of
individual components of that type is chosen. Then,
a “scalable system” can be considered as a family of
systems, whose elements are systems composed of a
speciﬁc admissible choice of individual component sets.
For safety critical systems as well as for business
critical systems, assuring the correctness is imperative.
Formally, the dynamic behaviour of a discrete system
can be described by the set of its possible sequences of
actions. This way to model the behaviour is important,
because it enables the deﬁnition of safety requirements
as well as the veriﬁcation of such properties, because for
these purposes sequences of actions of the system have to
be considered [6], [7], [8]. For short, we often will use the
term system instead of systems behaviour if it does not
generate confusions. With this focus, scalable systems
are families of system behaviours, which are indexed by
admissible choices of individual component sets. We call
such families parameterised systems. In this paper, we
deﬁne well-behaved scalable systems as a special class of
parameterised systems and develop construction princi-
ples for such systems. The main goal for this deﬁnition
is to achieve that well-behaved scalable systems fulﬁl
certain kind of safety properties if already one prototype
system (depending on the property) fulﬁls that property
(cf. Section IV). To this end, construction principles for
well-behaved scalable systems are design principles for

240
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
veriﬁability [9]. We give an example that demonstrates
the signiﬁcance of self-similarity for veriﬁcation purposes
and show that for well-behaved scalable systems scalable
safety properties can be veriﬁed by ﬁnite state methods.
The main content of the paper can basically be
divided into three parts. Besides the basic deﬁnitions,
the ﬁrst part (Section III and Section IV) comprises a
characterisation of the systems under consideration and
their fundamental properties. The second part (Section V
and Section VI, enriched by the appendix) provides the
formal framework for the construction of well-behaved
systems. The last part (Section VII) provides a generic
veriﬁcation scheme for scalable safety properties and
presents an example for its application. Concluding
remarks and further research directions are given in
Section VIII.
II. Related Work
Considering the behaviour-veriﬁcation aspect, which
is one of our motivations to formally deﬁne well-behaved
scalable systems, there are some other approaches to be
mentioned. An extension to the Murϕ veriﬁer to verify
systems with replicated identical components through a
new data type called RepetitiveID is presented in [10].
The veriﬁcation is performed by explicit state enumera-
tion in an abstract state space where states do not record
the exact numbers of components. A typical application
area of this tool are cache coherence protocols. The aim of
[11] is an abstraction method through symmetry, which
works also when using variables holding references to
other processes. In [12], a methodology for constructing
abstractions and reﬁning them by analysing counter-
examples is presented. The method combines abstraction,
model-checking and deductive veriﬁcation. A technique
for automatic veriﬁcation of parameterised systems based
on process algebra CCS [13] and the logic modal mu-
calculus [14] is presented in [15]. This technique views
processes as property transformers and is based on
computing the limit of a sequence of mu-calculus [14]
formulas generated by these transformers. The above-
mentioned approaches demonstrate that ﬁnite state
methods combined with deductive methods can be ap-
plied to analyse parameterised systems. The approaches
diﬀer in varying amounts of user intervention and their
range of application. A survey of approaches to combine
model checking and theorem proving methods is given
in [16]. Far reaching results in verifying parameterised
systems by model checking of corresponding abstract
systems are given in [17], [18]. It is well known that the
general veriﬁcation problem for parameterised systems is
undecidable [19], [20]. To handle that problem, we present
(a) a formal framework to specify parameterised systems
in a restricted manner, and (b) construction principles
for well-behaved scalable systems.
III. Characterisation of Scalable Systems
The behaviour L of a discrete system can be formally
described by the set of its possible sequences of actions.
Therefore, L ⊂ Σ∗ holds where Σ is the set of all actions
of the system, and Σ∗ (free monoid over Σ) is the set of
all ﬁnite sequences of elements of Σ, including the empty
sequence denoted by ε. This terminology originates from
the theory of formal languages [21], where Σ is called the
alphabet (not necessarily ﬁnite), the elements of Σ are
called letters, the elements of Σ∗ are referred to as words
and the subsets of Σ∗ as formal languages. Words can be
composed: if u and v are words, then uv is also a word.
This operation is called the concatenation; especially
εu = uε = u. A word u is called a preﬁx of a word v
if there is a word x such that v = ux. The set of all
preﬁxes of a word u is denoted by pre(u); ε ∈ pre(u)
holds for every word u. Formal languages, which describe
system behaviour, have the characteristic that pre(u) ⊂ L
holds for every word u ∈ L. Such languages are called
preﬁx closed. System behaviour is thus described by
preﬁx closed formal languages. Diﬀerent formal models
of the same system are partially ordered with respect to
diﬀerent levels of abstraction. Formally, abstractions are
described by alphabetic language homomorphisms. These
are mappings h∗ : Σ∗ −→ Σ′∗ with h∗(xy) = h∗(x)h∗(y),
h∗(ε) = ε and h∗(Σ) ⊂ Σ′ ∪ {ε}. So, they are uniquely
deﬁned by corresponding mappings h : Σ −→ Σ′ ∪{ε}. In
the following, we denote both the mapping h and the
homomorphism h∗ by h. We consider a lot of alphabetic
language homomorphisms. So, for simplicity we tacitly
assume that a mapping between free monoids is an
alphabetic language homomorphism if nothing contrary
is stated. We now introduce a guiding example.
Example 1. A server answers requests of a family of
clients. The actions of the server are considered in the
following. We assume with respect to each client that a
request will be answered before a new request from this
client is accepted. If the family of clients consists of only
one client, then the automaton in Fig. 1(a) describes the
system behaviour S ⊂ Σ∗, where Σ = {a,b}, the label a
depicts the request, and b depicts the response.
b
a
1
2
(a) Actions at a server
with respect to a client
b1
a2
b2
a1
a2
b1
a1
b2
0
2
1
3
(b) Two clients served concurrently
by one server
Figure 1.
Scalable client-server system
Example 2. Fig. 1(b) now describes the system behaviour
S{1,2} ⊂ Σ∗
{1,2} for two clients 1 and 2, under the

241
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
assumption that the server handles the requests of diﬀerent
clients non-restricted concurrently.
For a parameter set I and i ∈ I let Σ{i} denote pairwise
disjoint copies of Σ. The elements of Σ{i} are denoted by
ai and ΣI := S
i∈I
Σ{i}, where Σ{j} ∩ Σ{k} = ∅ for j ̸= k.
The index i describes the bijection a ↔ ai for a ∈ Σ and
ai ∈ Σ{i}.
Example 3. For ∅ ̸= I ⊂ N with ﬁnite I, let now SI ⊂ Σ∗
I
denote the system behaviour with respect to the client set
I. For each i ∈ N S{i} is isomorphic to S, and SI consists
of the non-restricted concurrent run of all S{i} with i ∈ I.
It holds SI′ ⊂ SI for I′ ⊂ I.
Let I1 denote the set of all ﬁnite non-empty subsets
of N (the set of all possible clients). Then, the family
(SI)I∈I1 is an example of a monotonic parameterised
system.
If the example is extended to consider several servers,
which are depicted by natural numbers, then, e.g.,
I2 := {˚I × ˆI ⊂ N×N|˚I ̸= ∅ ̸= ˆI, with ˚I, ˆI ﬁnite}
is a suitable parameter structure.
I2 used in the example above shows how the component
structure of a system can be expressed by a parameter
structure using Cartesian products of individual compo-
nent sets. The following Deﬁnition 1 abstracts from the
intuition of a component structure.
Deﬁnition 1 (parameter structure). Let N be a count-
able (inﬁnite) set and ∅ ̸= I ⊂ P(N)\{∅}. I is called a
parameter structure based on N.
For scalable systems it is obvious to assume that
enlarging the individual component sets does not reduce
the corresponding system behaviour. More precisely: let
I and K be two arbitrary admissible choices of individual
component sets, where each individual component set in
I is a subset of the corresponding individual component
set in K. If SI and SK are the corresponding systems’
behaviours, then SI is a subset of SK. Families of systems
with this property we call monotonic parameterised
systems. The following deﬁnition formalises monotonic
parameterised systems.
Deﬁnition 2 (monotonic parameterised system). Let I
be a parameter structure. For each I ∈ I let LI ⊂ Σ∗
I be
a preﬁx closed language. If LI′ ⊂ LI for each I,I′ ∈ I
with I′ ⊂ I, then (LI)I∈I is a monotonic parameterised
system.
As we assume that individual components of the
same type behave in the same manner, SI and SK are
isomorphic (equal up to the names of the individual
components), if I and K have the same cardinality. This
property we call uniform parameterisation. With these
notions we deﬁne scalable systems as uniformly monotonic
parameterised systems. Monotonic parameterised systems,
in which isomorphic subsets of parameter values describe
isomorphic subsystems, we call uniformly monotonic
parameterised systems.
Deﬁnition 3 (isomorphism structure). Let I be a
parameter structure, I,K ∈ I, and ι : I → K a bijection,
then let ιI
K : Σ∗
I → Σ∗
K the isomorphism deﬁned by
ιI
K(ai) := aι(i) for ai ∈ ΣI.
For each I,K ∈ I let B(I,K) ⊂ KI a set (possibly
empty) of bijections. BI := (B(I,K))(I,K)∈I×I is called
an isomorphism structure for I.
Deﬁnition 4 (scalable system). Let (LI)I∈I a mono-
tonic parameterised system and BI = (B(I,K))(I,K)∈I×I
an isomorphism structure for I.
(LI)I∈I is called uniformly monotonic parameterised
with respect to BI iﬀ
LK = ιI
K(LI) for each I,K ∈ I and each ι ∈ B(I,K).
Uniformly monotonic parameterised systems for short
are called scalable systems.
Example 4. Let I = I2.
B2(˚I × ˆI,˚
K × ˆK) := {ι ∈ (˚
K × ˆK)(˚
I×ˆI) |it exist bijections
˚ι : ˚I → ˚
K and ˆι : ˆI → ˆK with ι((r,s)) = (˚ι(r),ˆι(s))
for each (r,s) ∈ (˚I × ˆI)}
for ˚I × ˆI ∈ I2 and ˚
K × ˆK ∈ I2 deﬁnes an isomorphism
structure B2
I2.
IV. Well-behaved Scalable Systems
To motivate our formalisation of well-behaved, we
consider a typical security requirement of a scalable client-
server system: Whenever two diﬀerent clients cooperate
with the same server then certain critical sections of the
cooperation of one client with the server must not overlap
with critical sections of the cooperation of the other client
with the same server. If for example both clients want
to use the same resource of the server for conﬁdential
purposes, then the allocation of the resource to one of the
clients has to be completely separated from the allocation
of this resource to the other client. More generally, the
concurrent cooperation of one server with several clients
has to be restricted by certain synchronisation conditions
to prevent, for example, undesired race conditions.
According to this example, we focus on properties,
which rely on speciﬁc component types and a speciﬁc
number of individual components for these component
types but not on the speciﬁc individuality of the indi-
vidual components. Now, we want to achieve that a well

242
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
behaved scalable system fulﬁls such a kind of property if
already one prototype system (depending on the property)
fulﬁls that property. In our example, a prototype system
consists of two speciﬁc clients and one speciﬁc server.
To formalise this desire, we consider arbitrary I and K
as in the deﬁnition of monotonic parameterised system.
Then we look at SK from an abstracting point of
view, where only actions corresponding to the individual
components of I are considered. If the smaller subsystem
SI behaves like the abstracted view of SK, then we
call this property self-similarity or more precisely self-
similarity of scalable systems, to distinguish our notion
from geometric oriented notions [22] and organisational
aspects [23] of self-similarity. In [7], it is shown that
self-similar uniformly monotonic parameterised systems
have the above desired property. Therefore, we deﬁne
well-behaved scalable systems as self-similar uniformly
monotonic parameterised systems. We now formally look
at LI from an abstracting point of view concerning
a subset I′ ⊂ I. The corresponding abstractions are
formalised by the homomorphisms ΠI
I′ : Σ∗
I → Σ∗
I′.
Deﬁnition 5 (self-similar monotonic parameterised sys-
tem). For I′ ⊂ I let ΠI
I′ : Σ∗
I → Σ∗
I′ with
ΠI
I′(ai) =
 ai |
ai ∈ ΣI′
ε |
ai ∈ ΣI \ΣI′.
A monotonic parameterised system (LI)I∈I is called self-
similar iﬀ ΠI
I′(LI) = LI′ for each I,I′ ∈ I with I′ ⊂ I.
Deﬁnition 6 (well-behaved scalable system). Self-
similar scalable systems for short are called well-behaved
scalable systems.
A fundamental construction principle for systems
satisfying several constraints is intersection of system
behaviours. This emphasises the importance of the
following theorem.
Theorem 1 (intersection theorem). Let I be a parameter
structure, BI an isomorphism structure for I, and T ̸= ∅.
i) Let (Lt
I)I∈I for each t ∈ T be a monotonic param-
eterised system, then ( T
t∈T
Lt
I)I∈I is a monotonic
parameterised system.
ii) Let (Lt
I)I∈I for each t ∈ T be a scalable system with
respect to BI, then ( T
t∈T
Lt
I)I∈I is a scalable system
with respect to BI.
iii) Let (Lt
I)I∈I for each t ∈ T be a self-similar mono-
tonic parameterised system, then ( T
t∈T
Lt
I)I∈I is a
self-similar monotonic parameterised system.
Proof of Theorem 1 (i)–(iii):
Proof of (i): Let (Lt
I)I∈I a monotonic parameterised
system for each t ∈ T, then Lt
I′ ⊂ Lt
I for t ∈ T, I,I′ ∈ I,
and I′ ⊂ I. This implies
\
t∈T
Lt
I′ ⊂
\
t∈T
Lt
I,
and thus (i).
Proof of (ii): Let (Lt
I)I∈I an scalable system with
respect to (B(I,K))(I,K)∈I×I for each t ∈ T, then
ιI
K(Lt
I) = Lt
K for t ∈ T, I, K ∈ I, and ι ∈ B(I,K).
Because all ιI
K are isomorphisms,
ιI
K(
\
t∈T
Lt
I) =
\
t∈T
ιI
K(Lt
I) =
\
t∈T
Lt
K,
which proves (ii).
Proof of (iii): Let (Lt
I)I∈I a self-similar monotonic
parameterised system for each t ∈ T. For I,I′ ∈ I with
I′ ⊂ I holds
ΠI
I′(
\
t∈T
Lt
I) ⊂
\
t∈T
ΠI
I′(Lt
I) =
\
t∈T
Lt
I′ ⊂
\
t∈T
Lt
I.
(1)
Because T
t∈T
Lt
I′ ⊂ Σ∗
I′ holds
ΠI
I′(
\
t∈T
Lt
I′) =
\
t∈T
Lt
I′.
Together with the second inclusion from (1) it follows
\
t∈T
Lt
I′ ⊂ ΠI
I′(
\
t∈T
Lt
I).
Because of the ﬁrst part of (1) now holds
ΠI
I′(
\
t∈T
Lt
I) =
\
t∈T
Lt
I′,
which proves (iii).
Weak additional assumptions for well-behaved scalable
systems imply that such systems are characterised by
parametrisation of one well-deﬁned minimal prototype
system. More precisely:
Deﬁnition 7 (minimal prototype system). Let I be a
parameter structure based on N. For I ∈ I and n ∈ N let
τ I
n : Σ∗
I → Σ∗ the homomorphisms given by
τ I
n(ai) =
 a |
ai ∈ ΣI∩{n}
ε |
ai ∈ ΣI\{n}
.
For a singleton index set {n}, τ {n}
n
: Σ∗
{n} → Σ∗ is an
isomorphism and for each n ∈ I ∈ I holds
ΠI
{n} = (τ {n}
n
)−1 ◦τ I
n.
(2)
If now (LI)I∈I is a well-behaved scalable system with
respect to (B(I,K))(I,K)∈I×I with {n} ∈ I for n ∈ I ∈ I
and B(I,K) ̸= ∅ for all singleton I and K, then because
of (2) holds
LI ⊂
\
n∈I
(τ I
n)−1(L) for each I ∈ I,

243
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
where L = τ {n}
n
(L{n}) for each n ∈ S
I∈I
I.
L is called the minimal prototype system of (LI)I∈I.
Deﬁnition 8 (behaviour-family ( ˙L(L)I)I∈I generated
by the minimal prototype system L and the parameter
structure I). Let ∅ ̸= L ⊂ Σ∗ be preﬁx closed, I a
parameter structure, and
˙L(L)I :=
\
i∈I
(τ I
i )−1(L) for I ∈ I.
The systems ˙L(L)I consist of the “non-restricted con-
current run” of all systems (τ {i}
i
)−1(L) ⊂ Σ∗
{i} with i ∈ I.
Because τ {i}
i
: Σ∗
{i} → Σ∗ are isomorphisms, (τ {i}
i
)−1(L)
are pairwise disjoint copies of L.
Theorem 2 (simplest well-behaved scalable systems).
( ˙L(L)I)I∈I is a well-behaved scalable system with respect
to each isomorphism structure for I based on N and
˙L(L)I =
\
i∈N
(τ I
i )−1(L) for each I ∈ I.
The proof of this theorem is given in the appendix.
V. Construction of Well-behaved Systems by
Restriction of Concurrency
Now, we show how to construct well-behaved systems
by restricting concurrency in the behaviour-family
˙L.
In Example 3, holds SI = ˙L(S)I for I ∈ I1. If, in the
given example, the server needs speciﬁc resources for the
processing of a request, then - on account of restricted
resources - an non-restricted concurrent processing of
requests is not possible. Thus, restrictions of concurrency
in terms of synchronisation conditions are necessary. One
possible but very strong restriction is the requirement
that the server handles the requests of diﬀerent clients in
the same way as it handles the requests of a single client,
namely, on the request follows the response and vice
versa. This synchronisation condition can be formalised
with the help of S and the homomorphisms ΘI as shown
in the following example.
Example 5. Restriction of concurrency on account
of restricted resources: one “task” after another. All
behaviours with respect to i ∈ I inﬂuence each other. Let
¯SI := SI ∩(ΘI)−1(S) =
\
i∈I
(τ I
i )−1(S)∩(ΘI)−1(S)
for I ∈ I1, where generally, for each index set I, ΘI :
Σ∗
I → Σ∗ is deﬁned by ΘI(ai) := a, for i ∈ I and a ∈ Σ.
From the automaton in Fig. 1(b), it is evident that
¯S{1,2} will be accepted by the automaton in Fig. 2(a).
Given an arbitrary I ∈ I1, then ¯SI is accepted by an
automaton with state set {0} ∪ I and state transition
relation given by Fig. 2(b) for each i ∈ I.
b1
b2
a1
a2
0
2
1
(a) Automaton accepting ¯S{1,2}
bi
ai
0
i
(b) Automaton accepting ¯SI
Figure 2.
Automata accepting ¯S{1,2} and ¯SI
From this automaton, it is evident that ( ¯SI)I∈I1 is
a well-behaved scalable system, with respect to each
isomorphism structure BI1 for I1.
Example 6. A restriction of concurrency in the extended
example where a family of servers is involved is more
complicated than in the case of ( ¯SI)I∈I1. The reason
for that is that in the simple example the restriction of
concurrency can be formalised by a restricting inﬂuence
of the actions with respect to all parameter values (i.e.,
the entire ΣI). When considering the restriction of
concurrency in the extended example, the actions inﬂuence
each other only with respect to the parameter values, which
are bound to the same server.
Let the ﬁrst component of the elements from N×N in
the parameter structure I2 denote the server, then the
actions from Σ{r}×ˆI inﬂuence each other for given r ∈ ˚I
with ˚I × ˆI ∈ I and thus restrict the concurrency.
For the formalisation of this restriction of concurrency,
we now consider the general case of monotonic param-
eterised systems ( ˙L(L)I)I∈I. As already observed in
(2), for each well-behaved scalable system (LI)I∈I there
exists (under weak preconditions) a system ( ˙L(L)I)I∈I
with LI ⊂ ˙L(L)I for each I ∈ I, where L = τ {n}
n
(L{n})
for each n ∈ I ∈ I. Moreover, in context of Deﬁnition 8
it was observed that ˙L(L)I consists of the non-restricted
concurrent run of pairwise disjoint copies of L.
In conjunction, this shows that an adequate restriction
of concurrency in ( ˙L(L)I)I∈I can lead to the construction
of well-behaved scalable systems. Therefore, the restrict-
ing inﬂuence of actions with respect to speciﬁc parameter
values described above shall now be formalised.
Deﬁnition 9 (inﬂuence structure). Let T ̸= ∅ and I a
parameter structure. For each I ∈ I and t ∈ T a sphere
of inﬂuence is speciﬁed by E(t,I) ⊂ I. The family
EI = (E(t,I))(t,I)∈T ×I
is called inﬂuence structure for I indexed by T.
The non-restricted concurrent run of the pairwise
disjoint copies of L will now be restricted in the following
way: For each t ∈ T the runs of all copies k with k ∈ E(t,I)
inﬂuence each other independently of the speciﬁc values
of k ∈ E(t,I). With respect to our extended example
(several servers) with I2, the spheres of inﬂuence E(t,I)

244
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
are generalisations of the sets {r} × ˆI, where I = ˚I × ˆI
and t = (r,s) ∈ ˚I × ˆI.
Generally, for each t ∈ T the intersection
˙L(L)I ∩(τ I
E(t,I))−1(V )
(3)
formalises the restriction of the non-restricted concurrent
run of the copies of L within
˙L(L)I by the mutual
inﬂuence of each element of E(t,I).
Deﬁnition 10 (behaviour of inﬂuence and inﬂuence
homomorphisms). In (3), the behaviour of inﬂuence V
is a preﬁx closed language V ⊂ Σ∗, and for I,I′ ⊂ N the
homomorphism τ I
I′ : Σ∗
I → Σ∗ is deﬁned by:
τ I
I′(ai) =
 a |
ai ∈ ΣI∩I′
ε |
ai ∈ ΣI\I′
.
The homomorphisms τ I
E(t,I) are called the inﬂuence
homomorphisms of EI.
Deﬁnition 11 (behaviour-family (L(L,EI,V )I)I∈I gen-
erated by the minimal prototype system L, the inﬂuence
structure EI, and the behaviour of inﬂuence V ). Because
the restriction (3) shall hold for all t ∈ T, the restricted
systems L(L,EI,V )I are deﬁned by the preﬁx closed
languages
L(L,EI,V )I := ˙L(L)I ∩
\
t∈T
(τ I
E(t,I))−1(V ) for I ∈ I.
Deﬁnition 11 shows how synchronisation requirements
for the systems ˙L(L)I can be formalised by inﬂuence
structures and behaviour of inﬂuence in a very general
manner. Since, similar to the well-behaved scalable
systems ( ˙L(L)I)I∈I, in the systems (L(L,EI,V )I)I∈I
each L(L,EI,V ){i} shall be isomorphic to L for each
{i} ∈ I, V ⊃ L has to be assumed. Therefore, in general
we assume for systems (L(L,EI,V )I)I∈I that V ⊃ L ̸= ∅.
Note that τ I
I′ are generalisations of τ I
n and ΘI, because
τ I
n = τ I
{n} and ΘI = τ I
I = τ I
N
for each I ⊂ N and n ∈ N.
Further
requirements,
which
assure
that
(L(L,EI,V )I)I∈I are well-behaved scalable systems, will
now be given with respect to EI, BI, L and V . Assuming
T = N and ε ∈ V the scalability property is assured by
the following technical requirements for EI and BI:
Theorem 3 (construction condition for scalable sys-
tems). Let I be a parameter structure based on N,
EI = (E(n,I))(n,I)∈N×I be an inﬂuence structure for
I, and let BI = (B(I,I′))(I,I′)∈I×I be an isomorphism
structure for I. Let ε ∈ V ⊂ Σ∗,for each I ∈ I and n ∈
N let E(n,I) = ∅, or it exists an in ∈ I with E(n,I) =
E(in,I), and for each (I,I′) ∈ I ×I,ι ∈ B(I,I′) and i ∈
I holds
ι(E(i,I)) = E(ι(i),I′).
Let E(t,I′) = E(t,I) ∩ I′ for each t ∈ T and I,I′ ∈
I,I′ ⊂ I. Then (L(L,EI,V )I)I∈I is a scalable system
with respect to BI and
L(L,EI,V )I = ˙L(L)I ∩
\
n∈I
(τ I
E(n,I))−1(V )).
The proof of this theorem is given in the appendix.
Example 7. Let I be a parameter structure based on N,
and for I ∈ I let ¯E(i,I) := I for i ∈ N.
¯EI := ( ¯E(i,I))(i,I)∈N×I satisﬁes the assumptions
of Theorem 3 for each isomorphism structure BI. (4)
It
holds
(ΘI)−1(V ) = (τ I
¯
E(i,I))−1(V ) for each i ∈
N,I ∈ I, and V ⊂ Σ∗.
Therefore, L(L, ¯EI,V )I = ˙L(L)I ∩(ΘI)−1(V ) for I ∈ I.
Especially, ¯SI = L(S, ¯EI1,S)I for each I ∈ I1.
Example 8. For the parameter structure I2, and for
˚I × ˆI ∈ I2 let
E2((˚n, ˆn),˚I × ˆI) :=
 {˚n}× ˆI |
˚n ∈ ˚I
∅ |
˚n ∈ N\˚I
.
E2
I2 := (E2((˚n, ˆn),˚I × ˆI))((˚n,ˆn),˚
I×ˆI)∈(N×N)×I2
(5)
satisﬁes the assumptions of Theorem 3 for the isomor-
phism structure B2
I2.
(L(S,E2
I2,S)I)I∈I2 is the formalisation of the extended
example (several servers) with restricted concurrency.
In order to extend Theorem 3 with respect to self-
similarity, an additional assumption is necessary. This is
demonstrated by the following counter-example.
Example 9. Let G ⊂ {a,b,c}∗ the preﬁx closed language,
which is accepted by the automaton Fig. 3(a). Let H ⊂
{a,b,c}∗ the preﬁx closed language, which is accepted
by the automaton in Fig. 3(b). It holds ∅ ̸= G ⊂ H but
(L(G, ¯EI1,H)I)I∈I1 is not self-similar, e.g.,
Π{1,2,3}
{2,3} (L(G, ¯EI1,H){1,2,3}) ̸= (L(G, ¯EI1,H){2,3}
because
a1b1a2a3 ∈ L(G, ¯EI1,H){1,2,3},
and hence
a2a3 ∈ Π{1,2,3}
{2,3} (L(G, ¯EI1,H){1,2,3}),
but
a2a3 /∈ (L(G, ¯EI1,H){2,3}.
Deﬁnition 12 (closed under shuﬄe projection). Let
L,V ⊂ Σ∗. V is closed under shuﬄe projection with respect
to L, iﬀ
ΠN
K[(
\
n∈N
(τ N
n )−1(L))∩(ΘN)−1(V )] ⊂ (ΘN)−1(V )
(6)

245
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
c
a
b
1
3
2
(a) Automaton accepting G
c
b
b
b
c
a
c
c
a
a
c
1
3
2
5
4
7
6
9
8
(b) Automaton accepting H
Figure 3.
Counterexample
for each subset ∅ ̸= K ⊂ N. We abbreviate this by
SP(L,V ).
Remark 1. It can be shown that in SP(L,V ) N can be
replaced by each countable inﬁnite set.
Remark 2. If L and V are preﬁx closed with ∅ ̸= L ⊂ V ,
then it is easy to show that SP(L,V ) follows from self-
similarity of (L(L, ¯EI1,V )I)I∈I1.
With Deﬁnition 12 we are now able to formulate
our main result for constructing well-behaved scalable
systems deﬁned by a single synchronisation condition.
Theorem 4 (construction condition for well-behaved
scalable systems). By the assumptions of Theorem 3
together with SP(L,V )
(L(L,EI,V )I)I∈I
is a well-behaved scalable system.
The proof of this theorem is given in the appendix.
Example 10. For k ∈ N let the preﬁx closed language
Fk ⊂ {a,b}∗ be deﬁned by the automaton in Fig. 4(a).
b
a
b
a
0
k-1
1
k
(a) Automaton for Fk ⊂ {a,b}∗
ac
as
bc
bs
0
2
1
3
(b) One client, one server
Figure 4.
Automata at diﬀerent abstraction levels
With respect to Example 1, F1 = S holds. It can
be shown that SP(S,Fk) holds for each k ∈ N. With
Theorem 4 now, by
(4) and
(5) especially, the sys-
tems (L(L, ¯EI1,Fk)I)I∈I1 and (L(L,E2
I2,Fk)I)I∈I2 are
uniformly monotonic parameterised and self-similar.
These are the two cases of the guiding example where the
concurrency of the execution of requests is bounded by k.
Theorem 4 is the main result for constructing well-
behaved scalable systems deﬁned by a single synchronisa-
tion condition. The following section shows how this result
together with the Intersection Theorem can be used for
constructing more complex well-behaved scalable systems
deﬁned by the combination of several synchronisation
conditions, as for example well-behaved scalable systems
consisting of several component types.
VI. Well-behaved Scalable Systems Generated
by a Family of Influence Structures
Up to now, the examples were considered at an
abstraction level, which takes into account only the
actions of the server (or the servers, depending on the
choice of the parameter structure).
Example 11. For a ﬁner abstraction level, which addi-
tionally takes into account the actions of the clients, a
ﬁner alphabet, e.g., ˇΣ = {ac,bc,as,bs} and a preﬁx closed
language ˇS ⊂ ˇΣ∗ is needed, which, e.g., is deﬁned by the
automaton in Fig. 4(b).
In general, a ﬁner relation for system speciﬁcations at
diﬀerent abstraction levels can be deﬁned by alphabetic
language homomorphisms.
Deﬁnition 13 (abstractions). In general, let ˇL ⊂ ˇΣ∗ and
L ⊂ Σ∗ be preﬁx closed languages. We call ˇL ﬁner than
L or L coarser than ˇL iﬀ an alphabetic homomorphism
ν : ˇΣ∗ → Σ∗ exists with ν(ˇL) = L.
For each parameter structure I and I ∈ I ν deﬁnes
an homomorphism νI : ˇΣ∗
I → Σ∗
I by νI(ai) := (ν(a))i for
a ∈ ˇΣ and i ∈ I, where (ε)i := ε.
Let now EI be an inﬂuence structure for I indexed by
N, which is the base of I, and let ∅ ̸= L ⊂ V ⊂ Σ∗ be
preﬁx closed. (L(L,EI,V )I)I∈I induces a restriction of
the concurrency in ( ˙L(ˇL)I)I by the intersections
˙L(ˇL)I ∩(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )] for each I ∈ I. (7)
If ˇτ I
I′ : ˇΣ∗
I → ˇΣ∗ is deﬁned analogously to τ I
I′ for I,I′ ⊂
N by
ˇτ I
I′(ai) =
 a |
a ∈ ˇΣ and i ∈ I ∩I′
ε |
a ∈ ˇΣ and i ∈ I \I′
,
then holds τ I
I′ ◦νI = ν ◦ ˇτ I
I′. From this it follows that
(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )] =
\
t∈N
(ˇτ I
E(t,I))−1(ν−1(V ))
and therewith
˙L(ˇL)I ∩(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )] = L(ˇL,EI,ν−1(V ))I
(8)
for each I ∈ I. Notice that ∅ ̸= ˇL ⊂ ν−1(V ) ⊂ ˇΣ∗ is preﬁx
closed. So if (L(L,EI,V )I)I∈I fulﬁls the assumptions of
Theorem 3, then this holds for (L(ˇL,EI,ν−1(V ))I)I∈I
as well and the system
( ˙L(ˇL)I ∩(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )])I∈I,
(9)

246
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
which is deﬁned by the intersections (7), is a scalable
system. The following general theorem can be used to
prove self-similarity of such systems.
Theorem 5 (inverse abstraction theorem). Let ϕ : Σ∗ →
Φ∗ be an alphabetic homomorphism and W,X ⊂ Φ∗, then
SP(W,X) implies SP(ϕ−1(W),ϕ−1(X)).
Proof of Theorem 5:
Let K be a non-empty set. Each alphabetic homomor-
phism ϕ : Σ∗ → Φ∗ deﬁnes a homomorphism ϕK : Σ∗
K →
Φ∗
K by
ϕK(an) := (ϕ(a))n for an ∈ ΣK, where (ε)n = ε.
If ¯τ K
n : Φ∗
K → Φ and ¯ΘK : Φ∗
K → Φ are deﬁned analogous
to τ K
n and ΘK, then
ϕ◦τ K
n = ¯τ K
n ◦ϕK, and ϕ◦ΘK = ¯ΘK ◦ϕK.
(10)
Let now N be an inﬁnite countable set. Because of
(10), for W,X ⊂ Φ∗
(
\
n∈N
(τ N
n )−1(ϕ−1(W)))∩(ΘN)−1(ϕ−1(X))
= (ϕN)−1[(
\
n∈N
(¯τ N
n )−1(W))∩(¯ΘN)−1(X)].
(11)
Because of ϕK(w) = ϕN(w) for w ∈ Σ∗
K ⊂ Σ∗
N and
∅ ̸= K ⊂ N
(ϕK)−1(Z) ⊂ (ϕN)−1(Z) for Z ⊂ Φ∗
K.
(12)
If now SP(W,X), and
ΠN
K[(ϕN)−1(Y )] = (ϕK)−1(¯ΠN
K[Y ])
(13)
for Y ⊂ Φ∗
N and ∅ ̸= K ⊂ N, where ¯ΠN
K : Φ∗
N → Φ∗
K is
deﬁned analogous to ΠN
K, then follows (with (10) - (13))
ΠN
K[(
\
n∈N
(τ N
n )−1(ϕ−1(W)))∩(ΘN)−1(ϕ−1(X))]
= (ϕK)−1(¯ΠN
K[(
\
n∈N
(¯τ N
n )−1(W))∩(¯ΘN)−1(X)])
⊂ (ϕK)−1((¯ΘN)−1(X)) ⊂ (ϕN)−1((¯ΘN)−1(X))
= (ΘN)−1(ϕ−1(X)).
(14)
With (14)
SP(ϕ−1(W),ϕ−1(X)) follows from SP(W,X),
(15)
if (13) holds.
It remains to show (13). For the proof of (13) it is
suﬃcient to prove
ΠN
K((ϕN)−1(y)) = (ϕK)−1(¯ΠN
K(y))
(16)
for each y ∈ Φ∗
N, because of
ΠN
K((ϕN)−1(Y ) =
[
y∈Y
ΠN
K((ϕN)−1(y))
and
(ϕK)−1(¯ΠN
K(Y )) =
[
y∈Y
(ϕK)−1(¯ΠN
K(y)).
Here, for f : A → B and b ∈ B we use the convention
f−1(b) = f−1({b}).
With Y = {y} (16) is also necessary for (13), and so
it is equivalent to (13).
Deﬁnition 14 ((general) projection). For arbitrary
alphabets ∆ and ∆′ with ∆′ ⊂ ∆ general projections
π∆
∆′ : ∆∗ → ∆′∗ are deﬁned by
π∆
∆′(a) :=
 a |
a ∈ ∆′
ε |
a ∈ ∆\∆′ .
(17)
In this terminology the projections
ΠN
K : Σ∗
N → Σ∗
K and ¯ΠN
K : Φ∗
N → Φ∗
K
considered until now are special cases, which we call
parameter-projections. It holds
ΠN
K = πΣN
ΣK and ¯ΠN
K = πΦN
ΦK .
(18)
Because of the diﬀerent notations, in general we just
use the term projection for both cases.
We now consider the equation (16) for the special case,
where ϕ : Σ∗ → Φ∗ is a projection, that is ϕ = πΣ
Φ with
Φ ⊂ Σ. In this case also ϕN : Σ∗
N → Φ∗
N is a projection,
with
ϕN = πΣN
ΦN .
(19)
Lemma 1 (projection-lemma).
Let ∆ be an alphabet, ∆′ ⊂ ∆, Γ ⊂ ∆ and Γ′ = ∆′ ∩ Γ,
then
π∆
∆′((π∆
Γ )−1(y)) = (π∆′
Γ′ )−1(π∆
∆′(y))
for each y ∈ Γ∗.
Proof: Let y ∈ Γ∗. We show
π∆′
Γ′ (π∆
∆′(z)) = π∆
∆′(y) for each z ∈ (π∆
Γ )−1(y)
(20)
and we show that
for each u ∈ (π∆′
Γ′ )−1(π∆
∆′(y)) there exists a
v ∈ (π∆
Γ )−1(y) such that π∆
∆′(v) = u.
(21)
From (20) it follows that
π∆
∆′((π∆
Γ )−1(y)) ⊂ (π∆′
Γ′ )−1(π∆
∆′(y))
and from (21) it follows that
(π∆′
Γ′ )−1(π∆
∆′(y)) ⊂ π∆
∆′((π∆
Γ )−1(y)),
which in turn proves Lemma 1.
Proof of (20): By deﬁnition of π∆
Γ , π∆′
Γ′ and π∆
∆′ follows
π∆′
Γ′ (π∆
∆′(z)) = π∆
∆′(π∆
Γ (z))

247
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
for each z ∈ ∆∗ and therewith (20).
Proof of (21) by induction on y ∈ Γ∗:
Induction base. Let y = ε, then u ∈ (∆′ \ Γ′)∗ for each
u ∈ (π∆′
Γ′ )−1(π∆
∆′(y)). From this follows
π∆
∆′(v) = u with v := u ∈ (π∆
Γ )−1(ε).
Induction step. Let y = ˚yˆy with ˚y ∈ Γ∗ and ˆy ∈ Γ.
Case 1: ˆy ∈ Γ\Γ′ = Γ∩(∆\∆′)
Then
(π∆′
Γ′ )−1(π∆
∆′(y)) = (π∆′
Γ′ )−1(π∆
∆′(˚y)).
By
induction
hypothesis
then
for
each
u ∈ (π∆′
Γ′ )−1(π∆
∆′(y)) it exists ˚v ∈ (π∆
Γ )−1(˚y) such
that π∆
∆′(˚v) = u.
With v :=˚vˆy holds π∆
Γ (˚vˆy) = ˚yˆy = y and hence
v ∈ (π∆
Γ )−1(y) and π∆
∆′(v) = π∆
∆′(˚v) = u.
Case 2: ˆy ∈ Γ′ ⊂ ∆′
Then
π∆
∆′(y)
=
π∆
∆′(˚y)ˆy.
Therefore,
each
u ∈ (π∆′
Γ′ )−1(π∆
∆′(y)) can be departed into u = ˚uˆyˆu with
˚u ∈ (π∆′
Γ′ )−1(π∆
∆′(˚y)) and ˆu ∈ (∆′ \Γ′)∗.
By induction hypothesis then exists ˚v ∈ (π∆
Γ )−1(˚y) such
that π∆
∆′(˚v) = ˚u.
With v :=˚vˆyˆu holds π∆
Γ (˚vˆyˆu) = ˚yˆy = y and hence
v ∈ (π∆
Γ )−1(y) and π∆
∆′(v) = π∆
∆′(˚v)ˆyˆu = ˚uˆyˆu = u.
This completes the proof of (21).
For y ∈ Γ∗ holds
π∆
∆′(y) = πΓ
∆′∩Γ(y) = πΓ
Γ′(y).
Therewith, from Lemma 1 follows
π∆
∆′((π∆
Γ )−1(y)) = (π∆′
Γ′ )−1(πΓ
Γ′(y)) for each y ∈ Γ∗.
(22)
For ∅ ̸= K ⊂ N,Φ ⊂ Σ,∆ := ΣN,∆′ := ΣK, and Γ := ΦN
holds Γ′ = ∆′ ∩Γ = ΦK.
Assuming ϕ = πΣ
Φ, which implies ϕK = πΣK
ΦK , then from
(22) (with (18) and (19)), follows
ΠN
K((ϕN)−1(y)) = (ϕK)−1(¯ΠN
K(y))
for y ∈ Φ∗
N, and so (16). With this,
premise (13) is fulﬁlled for (15), when ϕ is a projection,
(23)
which proves Theorem 5 for projections.
Deﬁnition 15 (strictly alphabetic homomorphism). Let
Σ, Φ alphabets, and ϕ : Σ∗ → Φ∗ a homomorphism. Then
ϕ is called alphabetic, if ϕ(Σ) ⊂ Φ∪{ε}, and ϕ is called
strictly alphabetic, if ϕ(Σ) ⊂ Φ.
Each alphabetic homomorphism ϕ : Σ∗ → Φ∗ is the
composition of a projection with a strictly alphabetic
homomorphism, more precisely,
ϕ = ϕS ◦πΣ
ϕ−1(Φ)∩Σ,
(24)
where ϕS : (ϕ−1(Φ)∩Σ)∗ → Φ∗ is the strictly alphabetic
homomorphism deﬁned by
ϕS(a) := ϕ(a) for a ∈ ϕ−1(Φ)∩Σ.
For W,X ⊂ Φ∗ and ϕ : Σ∗ → Φ∗ alphabetic (24) implies
ϕ−1(W) =(πΣ
ϕ−1(Φ)∩Σ)−1((ϕS)−1(W)) and
ϕ−1(X) =(πΣ
ϕ−1(Φ)∩Σ)−1((ϕS)−1(X)).
(25)
Now with (23) and (25) it remains to prove Theorem 5
for strictly alphabetic homomorphisms. This will be done
by Lemma 2, which proves (16) for strictly alphabetic
homomorphisms.
Lemma 2. Let ϕ : Σ∗ → Φ∗ be a strictly alphabetic
homomorphism, then for all y ∈ Φ∗
N and ∅ ̸= K ⊂ N
holds
ΠN
K((ϕN)−1(y)) = (ϕK)−1(¯ΠN
K(y)).
Proof: Proof by induction on y.
Induction basis: y = ε
Because ϕN is strictly alphabetic
(ϕN)−1(ε) = {ε} and so ΠN
K((ϕN)−1(ε)) = {ε}.
For the same reason
(ϕK)−1(¯ΠN
K(ε)) = (ϕK)−1(ε) = {ε}.
Induction step: Let y = y′at with at ∈ ΦN, where a ∈ Φ
and t ∈ N. Because ϕN is alphabetic, it holds
(ϕN)−1(y′at) = ((ϕN)−1(y′))((ϕN)−1(at)),
and so
ΠN
K((ϕN)−1(y′at)) = ΠN
K((ϕN)−1(y′))ΠN
K((ϕN)−1(at)).
Also holds
(ϕK)−1(¯ΠN
K(y′at)) = (ϕK)−1(¯ΠN
K(y′))(ϕK)−1(¯ΠN
K(at)).
According to the induction hypothesis, it holds
ΠN
K((ϕN)−1(y′)) = (ϕK)−1(¯ΠN
K(y′)).
Therefore, it remains to show
ΠN
K((ϕN)−1(at)) = (ϕK)−1(¯ΠN
K(at)).
Case 1: t /∈ K
Because ϕN is strictly alphabetic, it holds (ϕN)−1(at) ⊂
Σ{t}, so
ΠN
K((ϕN)−1(at)) = {ε}.
Additionally holds ¯ΠN
K(at) = ε, and therewith
(ϕK)−1(¯ΠN
K(at)) = {ε},
because ϕK is strictly alphabetic.
Case 2: t ∈ K
Because ϕN is strictly alphabetic, it holds
(ϕN)−1(at) = {bt ∈ Σ{t}|ϕ(b) = a},

248
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
and therewith
ΠN
K((ϕN)−1(at)) = {bt ∈ Σ{t}|ϕ(b) = a}.
¯ΠN
K(at) = at and therewith
(ϕK)−1(¯ΠN
K(at)) = {bt ∈ Σ{t}|ϕ(b) = a},
because ϕK is strictly alphabetic. This completes the
proof of Lemma 2.
This completes the proof of Theorem 5.
Generally,
by
(6),
SP(ν−1(L),ν−1(V ))
implies
SP(X,ν−1(V ))
for
each
X ⊂ ν−1(L).
Especially
SP(ˇL,ν−1(V )) is implied by SP(L,V ) on account of
Theorem 5. So, by Theorem 5, if (L(L,EI,V )I)I∈I fulﬁls
the assumptions of Theorem 4, then
(L(ˇL,EI,ν−1(V ))I)I∈I
= ( ˙L(ˇL)I ∩(νI)−1[
\
t∈N
(τ I
E(t,I))−1(V )])I∈I
(26)
is a well-behaved scalable system.
The intersections in (7) formalise restriction of con-
currency in ( ˙L(ˇL)I)I∈I under one speciﬁc aspect (one
speciﬁc synchronisation condition), which is given by
ν, EI, and V . Restriction of concurrency under several
aspects (several synchronisation conditions) is formalised
by the intersections
˙L(ˇL)I ∩
\
r∈R
(νI
r )−1[
\
t∈N
(τ I
Er(t,I))−1(Vr)]
(27)
for each I ∈ I based on N, R ̸= ∅ is the index set of the
aspects. The family of aspects restricting concurrency is
given by
• a family (νr)r∈R of alphabetic homomorphisms νr :
ˇΣ∗ → Σ(r)∗ for r ∈ R,
• a family (Er
I)r∈R of inﬂuence structures Er
I =
(Er(t,I))(t,I)∈N×I indexed by N for r ∈ R, and
• a family (Vr)r∈R of inﬂuence behaviours Vr ⊂ Σ(r)∗
for r ∈ R.
From (8) it follows now
˙L(ˇL)I ∩
\
r∈R
(νI
r )−1[
\
t∈N
(τ I
Er(t,I))−1(Vr)]
=
\
r∈R
L(ˇL,Er
I,ν−1
r
(Vr))I
for each I ∈ I. Because of the intersection theorem, the
uniform monotonic parameterisation and self-similarity
of the system
( ˙L(ˇL)I ∩
\
r∈R
(νI
r )−1[
\
t∈N
(τ I
Er(t,I))−1(Vr)])I∈I
can be inferred from respective properties of the systems
(L(ˇL,Er
I,ν−1
r
(Vr))I)I∈I for each r ∈ R.
Using (9) and (26), this requires the veriﬁcation of
the assumptions of Theorem 4 for
(L(νr(ˇL),Er
I,Vr)I)I∈I for each r ∈ R.
(28)
If I is based on N =×
k∈K
Nk, where K is a ﬁnite set and
each Nk is countable, then along the lines of I2, a param-
eter structure IK can be deﬁned for this domain. Such
IK ﬁt for systems consisting of ﬁnitely many component
types. Each subset K′ ⊂ K with ∅ ̸= K′ ̸= K deﬁnes a
bijection between N and (×
k∈K′
Nk) × ( ×
k∈K\K′
Nk). By
this bijection, for each of these K′ an inﬂuence structure
EK′
IK is deﬁned like E2
I2 that satisﬁes the assumptions
of Theorem 3 with respect to an isomorphism structure
BK
IK deﬁned like E2
I2.
VII. Scalable Safety Properties
We will now give an example that demonstrates the
signiﬁcance of self-similarity for veriﬁcation purposes and
then present a generic veriﬁcation scheme for scalable
safety properties.
Example 12. We consider a system of servers, each
of them managing a resource, and clients, which want
to use these resources. We assume that as a means to
enforce a given privacy policy a server has to manage
its resource in such a way that no client may access this
resource during it is in use by another client (privacy
requirement). This may be required to ensure anonymity
in such a way that clients and their actions on a resource
cannot be linked by an observer.
We formalise this system at an abstract level, where
a client may perform the actions ac (send a request),
bc (receive a permission) and cc (send a free-message),
and a server may perform the corresponding actions as
(receive a request), bs (send a permission) and cs (receive
a free-message). The automaton L depicted in Fig. 5
describes the cooperation of one client and one server.
cc
cs
as
cs
as
ac
bc
cs
ac
bs
1
3
2
5
4
7
6
8
Figure 5.
Automaton L
We now formalise the parameterised cooperation
(CJ)J∈I according to the description in Section VI.
CJ = ˙L(ˇL)J ∩
\
r∈R
(νJ
r )−1[
\
t∈N
(τ J
Er(t,J))−1(Vr)].

249
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Because (CJ)J∈I involves several clients as well as
several servers, let I := I2, N := N×N, and BI := B2
I2,
where the ﬁrst component refers to the client and the
second component refers to the server. Now ˇL is the preﬁx
closed language that is accepted by the automaton L.
For the examined example we assume that both clients
and servers are subject to constaints with respect to
processing several cooperations. Thus, two aspects of
constaints are considered, therefore: R := {c,s}, Σ(c) :=
{ac,bc,cc}, Σ(s) := {as,bs,cs}, ˇΣ = Σ(c) ·∪Σ(s), νc : ˇΣ∗ →
Σ(c)∗ with
νc(x) :=
 x |
x ∈ Σ(c)
ε |
x ∈ Σ(s) ,
and νs : ˇΣ∗ → Σ(s)∗ with
νs(x) :=
 x |
x ∈ Σ(s)
ε |
x ∈ Σ(c)
.
νc(ˇL) and νs(ˇL) now describe the behaviour of a client
respectively a server in the cooperation of a client with
a server. νc(ˇL) and νs(ˇL) are accepted by the automata
in Fig. 6(a) and Fig. 6(b).
cc
ac
bc
1
3
2
(a) Automaton accepting νc(ˇL)
cs
as
cs
bs
as
1
3
2
4
(b) Automaton accepting νs(ˇL)
Figure 6.
Client and server behaviour in the cooperation
These automata show that in νc(ˇL) the “phase” acbccc
can happen repeatedly and in νs(ˇL) two instances of the
“phase” asbscs can run partly concurrently.
We now assume that this restriction of concurrency
shall also hold for the parameterised system. This re-
striction is then given by the deﬁnitions Vc := νc(ˇL)
and Vs := νs(ˇL) with an appropriate choice of inﬂuence
structures.
Because for each client respectively server all coopera-
tions with all servers respectively clients inﬂuence each
other, let now according to Example 8, for I × K ∈ I2
and (i,k) ∈ N×N:
Ec((i,k),I ×K) :=
 {i}×K |
i ∈ I
∅ |
i ∈ N\I
,
Es((i,k),I ×K) :=
 I ×{k} |
k ∈ K
∅ |
k ∈ N\K
,
Ec
I2 := (Ec((i,k),I ×K))((i,k),I×K)∈(N×N)×I2, and
Es
I2 := (Es((i,k),I ×K))((i,k),I×K)∈(N×N)×I2.
As in Example 8, both inﬂuence structures satisfy the
assumptions of Theorem 3 for the isomorphism struc-
ture B2
I2. Therefore, (L(νc(ˇL),Ec
I2,νc(ˇL))J)J∈I2 and
(L(νs(ˇL),Es
I2,νs(ˇL))J)J∈I2 are scalable systems. Because
of (28) now (CJ)J∈I2 is a well-behaved scalable system
if SP(νc(ˇL),νc(ˇL)) and SP(νs(ˇL),νs(ˇL)) hold.
In [24], suﬃcient conditions are given for a property
equivalent to SP(U,V ). These can be proven for both
examples. A comprehensive and more general method
for veriﬁcation of SP(U,V ) is subject of a forthcoming
paper.
Considering bc as the begin action and cc as the end
action with respect to accessing a resource, the privacy
requirement for each CJ with J = I × K ∈ I2 can be
formalised by the following condition (29).
Let i,i′ ∈ I, i ̸= i′, k ∈ K and
µI×K
<i,i′,k> : Σ∗
I×K → {bc
(i,k),cc
(i,k),bc
(i′,k)}∗ with
µI×K
<i,i′,k>(x) :=
(
x | x ∈ {bc(i,k),cc(i,k),bc(i′,k)}
ε | x ∈ ΣI×K \{bc(i,k),cc(i,k),bc(i′,k)}.
Condition: For each i,i′ ∈ I, i ̸= i′ and k ∈ K holds
µI×K
<i,i′,k>(CI×K)∩Σ∗
{i,i′}×{k}bc
(i,k)bc
(i′,k) = ∅.
(29)
For i,i′ ∈ I, i ̸= i′, and k ∈ K let
ρ<i,i′,k> : Σ∗
{i,i′}×{k} → {bc
(i,k),cc
(i,k),bc
(i′,k)}∗
be deﬁned by
ρ<i,i′,k>(x) :=



x | x ∈ {bc(i,k),cc(i,k),bc(i′,k)}
ε | x ∈ Σ{i,i′}×{k} \{bc(i,k),cc(i,k),
bc(i′,k)}
,
then
µI×K
<i,i′,k> = ρ<i,i′,k> ◦ΠI×K
{i,i′}×{k}.
Hence,
µI×K
<i,i′,k>(CI×K) = ρ<i,i′,k>(C{i,i′}×{k})
(30)
because (CI×K)I×K∈I2 is a well-behaved scalable system.
Let
ι<i,i′,k> : Σ∗
{i,i′}×{k} → Σ∗
{1,2}×{1}
be the isomorphism deﬁned by
ι<i,i′,k>(x) :=









(τ {1}×{1}
(1,1)
)−1(τ {i}×{k}
(i,k)
(x)) | x ∈
Σ{i}×{k}
(τ {2}×{1}
(2,1)
)−1(τ {i′}×{k}
(i′,k)
(x)) | x ∈
Σ{i′}×{k}
.
Then
ι<i,i′,k> ∈ {ι{i,i′}×{k}
{1,2}×{k}|ι ∈ B2({i,i′}×{k},{1,2}×{1})}
(cf. Example 4), and therefore
ι<i,i′,k>(C{i,i′}×{k}) = C{1,2}×{1},
(31)
because (CI×K)I×K∈I2 is a scalable system.

250
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
cc(1,1)
bc(1,1)
bc(2,1)
1
2
(a) Minimal automaton
of ρ<1,2,1>(C{1,2}×{1})
cs
as
cs
as
bs
as
1
3
2
4
(b) Automaton accepting ν′
s(ˇL)
Figure 8.
Minimal automaton and counter example
Now, by (30), (31), and
ρ<i,i′,k> = ι−1
<i,i′,k> ◦ρ<1,2,1> ◦ι<i,i′,k>,
CI×K fulﬁls the privacy requirement (29) for each I ×K ⊂
I2 iﬀ
ρ<1,2,1>(C{1,2}×{1})∩Σ∗
{1,2}×{1}bc
(1,1)bc
(2,1) = ∅.
(32)
This can be veriﬁed by checking the automaton of
C{1,2}×{1} that consists of 36 states (see Fig. 7). The
actions of interest with regard to the privacy requirement,
namely bc and cc, are depicted by solid lines. For example,
after the begin action bc(1,1) connecting states 7 → 11
a respective end action cc(1,1) is either directly possible
(see 11 → 15) or after an intermediate action (see 11 → 16)
or two intermediate actions (see 11 → 16 → 23).
The minimal automaton of ρ<1,2,1>(C{1,2}×{1}) is
shown in Fig. 8(a), which implies (32).
On the contrary, let C′
I×K be deﬁned as CI×K but with
V ′
s instead of Vs, where V ′
s is deﬁned by the automaton of
Fig. 8(b). Then (C′
I×K)I×K∈I2 is not self-similar because
ac
(1,1)ac
(2,1)ac
(3,1)as
(1,1)bs
(1,1)as
(2,1)as
(3,1)bs
(2,1)bc
(1,1)
bc
(2,1) ∈ C′
{1,2,3}×{1}, and so
ac
(1,1)ac
(2,1)as
(1,1)bs
(1,1)as
(2,1)bs
(2,1)bc
(1,1)bc
(2,1)
∈ Π{1,2,3}{1}
{1,2}{1} (C′
{1,2,3}×{1})
but
ac
(1,1)ac
(2,1)as
(1,1)bs
(1,1)as
(2,1)bs
(2,1)bc
(1,1)bc
(2,1)
/∈ C′
{1,2}×{1}.
The same action sequence shows that C′
{1,2,3}×{1} does
not fulﬁl the privacy requirement.
The privacy requirement of the example is a typical
safety property [25]. These properties describe that
“nothing forbidden happens”. They can be formalised by a
set F of forbidden action sequences. So a system LJ ⊂ Σ∗
J
satisﬁes a safety property FJ ⊂ Σ∗
J iﬀ LJ ∩FJ = ∅.
In our example, the privacy requirement (29) is for-
malised by
Fp
I×K =
[
i,i′∈I,i̸=i′
k∈K
(µI×K
<i,i′,k>)−1(Σ∗
{i,i′}×{k}bc
(i,k)bc
(i′,k))
=
[
i,i′∈I,i̸=i′
k∈K
(ΠI×K
{i,i′}×{k})−1(ι−1
<i,i′,k>[ρ−1
<1,2,1>
(Σ∗
{1,2}×{1}bc
(1,1)bc
(2,1))])
because of
µI×K
<i,i′,k> = ι−1
<i,i′,k> ◦ρ<1,2,1> ◦ι<i,i′,k> ◦ΠI×K
{i,i′}×{k}
and
ι<i,i′,k>(Σ∗
{i,i′}×{k}bc
(i,k)bc
(i′,k))
= Σ∗
{1,2}×{1}bc
(1,1)bc
(2,1).
As
{({i,i′}×{k},ι−1
<i,i′,k>) | i,i′ ∈ I,i ̸= i′, and k ∈ K}
= {(I′ ×K′,ι{1,2}×{1}
I′×K′
) | I′ ×K′ ⊂ I ×K and
ι ∈ B2({1,2}×{1},I′ ×K′)}
it follows
Fp
I×K =
[
I′×K′⊂I×K
ι∈B2({1,2}×{1},I′×K′)
(ΠI×K
I′×K′)−1(ι{1,2}×{1}
I′×K′
(F p))
(33)
with
F p := ρ−1
<1,2,1>(Σ∗
{1,2}×{1}bc
(1,1)bc
(2,1)).
The representation (33) can be generalised for arbitrary
parameter structures I and corresponding isomorphism
structures BI = (B(J,J′))(J,J′)∈I×I:
Let ¯J ∈ I and ¯F ⊂ Σ∗
¯
J, then for each J ∈ I let
F
¯
F
J :=
[
J′∈I,J′⊂J,ι∈B( ¯
J,J′)
(ΠJ
J′)−1(ι
¯
J
J′( ¯F)).
(34)
Now by the same argument as in our privacy example,
we get
Theorem 6. Let (LJ)J⊂I be a well-behaved scalable
system, and let ¯F ⊂ Σ∗
¯
J with ¯J ∈ I, then
LJ ∩F
¯
F
J = ∅ for each J ∈ I iﬀ L ¯
J ∩F
¯
F
¯
J = ∅.
(35)
If L ¯
J and ¯F are regular subsets of Σ∗
¯
J, then (35) can
be checked by ﬁnite state methods [21].
If (LJ)J⊂I is deﬁned as in (27) the regularity of ˇL and
of Vr for each r ∈ R and ﬁniteness of R and ¯J implies
regularity of L ¯
J.
For ﬁnite sets J, ¯J ∈ I with #(J) < #( ¯J), where #
denotes the cardinality of a set, holds F ¯
F
J = ∅, because
of B( ¯J,J′) = ∅ for each J′ ∈ J with J′ ∈ I. Therefore,

251
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
ac(2,1)
ac(1,1)
as(1,1)
cs(2,1)
cs(1,1)
ac(2,1)
as(2,1)
cs(2,1)
cs(2,1)
ac(2,1)
cs(2,1)
ac(2,1)
ac(1,1)
as(1,1)
cs(1,1)
as(2,1)
cs(1,1)
as(1,1)
cs(1,1)
bc(1,1)
bs(1,1)
as(2,1)
bc(1,1)
ac(2,1)
cs(2,1)
cs(2,1)
cc(2,1)
cs(2,1)
as(1,1)
ac(2,1)
bs(1,1)
as(2,1)
cc(1,1)
cc(2,1)
cs(1,1)
ac(2,1)
bc(2,1)
as(2,1)
as(1,1)
ac(2,1)
ac(1,1)
cc(1,1)
ac(2,1)
bs(2,1)
ac(2,1)
bc(1,1)
cs(1,1)
ac(1,1)
ac(1,1)
ac(1,1)
ac(1,1)
bc(2,1)
cs(1,1)
ac(1,1)
as(1,1)
as(2,1)
cc(2,1)
cs(2,1)
cs(1,1)
ac(2,1)
ac(1,1)
bc(2,1)
as(1,1)
as(2,1)
cc(1,1)
as(2,1)
bs(2,1)
as(1,1)
ac(1,1)
ac(1,1)
24
25
26
27
20
21
22
23
28
29
1
3
2
5
4
7
6
9
8
11
10
13
12
15
14
17
16
33
18
31
30
36
35
34
19
32
Figure 7.
Automaton of C{1,2}×{1}
it makes sense to consider safety properties deﬁned by
ﬁnite unions of sets as deﬁned in (35).
Deﬁnition 16 (Scalable safety properties).
Let I be a parameter structure, BI = (B(J,J′))(J,J′)∈I×I
a corresponding isomorphism structure, T a ﬁnite set,
and ¯Ft ⊂ Σ∗
¯
Jt with ¯Jt ∈ I for each t ∈ T, then (FJ)J∈I
with FJ := S
t∈T
F
¯
Ft
J
is called a scalable safety property.
Corollary
1. For a well-behaved scalable system
(LJ)J∈I the parameterised problem of verifying a scalable
safety property is reduced to ﬁnite many ﬁnite state
problems if the corresponding L ¯
Jt and ¯Ft are regular
languages.
VIII. Conclusions and Further Work
Structural scalability of a system in terms of the ability
to compose a system using a varying number of identical
components of a few given types is a desired property that
is analysed in this work. For safety critical systems as well
as for business critical systems, assuring the correctness of
systems composed in such a way is imperative. Thus, the
focus of this paper is on property preserving structural
scalability.
This motivates the formal deﬁnition of well-behaved
scalable systems, which starts with a prototype system
that fulﬁls a desired safety property and then “embeds”
this prototype system in a scalable system. When this
scalable system is constructed according to the methods
given in this paper, then corresponding safety properties
are fulﬁlled by any instance of the scalable system. In
other words, it is shown that for well-behaved scalable
systems a wide class of safety properties can be veriﬁed
by ﬁnite state methods.
For this purpose, a formal framework is presented
that can be utilised to construct well-behaved scalable
systems in terms of preﬁx closed formal languages and
alphabetic language homomorphisms. The basic parts
of that framework are formalisations of parameter struc-
tures, inﬂuence structures and isomorphisms structures.
Together with so-called prototype systems and behaviours
of inﬂuence these structures formally deﬁne scalable
systems, if certain conditions are fulﬁlled. With respect

252
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
to such scalable systems, the focus is on properties,
which rely on speciﬁc component types and a speciﬁc
number of individual components for these component
types but not on the speciﬁc individuality a component.
Well-behaved scalable systems are characterised by those
systems, which fulﬁl such a kind of property if already one
prototype system (depending on the property) fulﬁls that
property. Self-similar scalable systems have this desired
property. A suﬃcient condition for such self-similarity is
given in terms of prototype systems and behaviours of
inﬂuence. A deeper analysis of this condition is subject
of a forthcoming paper of the authors.
Usually, behaviour properties of systems are divided
into two classes: safety and liveness properties [25].
Intuitively, a safety property stipulates that “some-
thing bad does not happen” and a liveness property
stipulates that “something good eventually happens”.
To extend this veriﬁcation approach to reliability or
general liveness properties, additional assumptions for
well-behaved scalable systems have to be established. In
[26], such assumptions have been developed for uniformly
parametrised two-sided cooperations. To generalise these
ideas to a wider class of well-behaved scalable systems is
subject of further work.
Acknowledgement
Research reported in this publication was supported by
the German Federal Ministry of Education and Research
in the context of the project ACCEPT (ID 01BY1206D).
References
[1] P. Ochsenschläger and R. Rieke, “Construction principles
for well-behaved scalable systems,” in ICONS 2014, The
Ninth International Conference on Systems, February 23
- 27, 2014 - Nice, France.
IARIA, 2014, pp. 32–39.
[2] L. Duboc, D. S. Rosenblum, and T. Wicks, “A framework
for modelling and analysis of software systems scalability,”
in Proceedings of the 28th International Conference on
Software Engineering, ser. ICSE ’06.
New York, NY,
USA: ACM, 2006, pp. 949–952.
[3] A. B. Bondi, “Characteristics of scalability and their
impact on performance,” in Workshop on Software and
Performance, 2000, pp. 195–203.
[4] S. Bullock and D. Cliﬀ, “Complexity and emergent
behaviour in ICT systems,” Hewlett-Packard Labs, Tech.
Rep. HP-2004-187, 2004.
[5] J.
Weinman,
“Axiomatic
cloud
theory,”
http://www.joeweinman.com/Resources/Joe_
Weinman_Axiomatic_Cloud_Theory.pdf,
July
2011, [retrieved: Nov, 2014].
[6] P. Zegzhda, D. Zegzhda, and A. Nikolskiy, “Using graph
theory for cloud system security modeling,” in Computer
Network Security, ser. LNCS, I. Kotenko and V. Skormin,
Eds.
Springer, 2012, vol. 7531, pp. 309–318.
[7] P. Ochsenschläger and R. Rieke, “Security properties
of self-similar uniformly parameterised systems of coop-
erations,” in Parallel, Distributed and Network-Based
Processing (PDP), 2011 19th Euromicro International
Conference on, 2011, pp. 640–645.
[8] S. Schneider, “Security properties and CSP,” in IEEE
Symposium on Security and Privacy.
IEEE Computer
Society, 1996, pp. 174–187.
[9] A. Avizienis, J.-C. Laprie, B. Randell, and C. E.
Landwehr, “Basic concepts and taxonomy of dependable
and secure computing,” IEEE Trans. Dependable Sec.
Comput., vol. 1, no. 1, pp. 11–33, 2004.
[10] C. N. Ip and D. L. Dill, “Verifying systems with replicated
components in murϕ,” Formal Methods in System Design,
vol. 14, no. 3, pp. 273–310, 1999.
[11] F. Derepas and P. Gastin, “Model checking systems of
replicated processes with SPIN,” in Proceedings of the
8th International SPIN Workshop on Model Checking
Software (SPIN’01), ser. LNCS, M. B. Dwyer, Ed., vol.
2057.
Toronto, Canada: Springer, 2001, pp. 235–251.
[12] Y. Lakhnech, S. Bensalem, S. Berezin, and S. Owre,
“Incremental veriﬁcation by abstraction,” in TACAS, ser.
Lecture Notes in Computer Science, T. Margaria and
W. Yi, Eds., vol. 2031.
Springer, 2001, pp. 98–112.
[13] R. Milner, Communication and Concurrency, ser. Inter-
national Series in Computer Science.
NY: Prentice Hall,
1989.
[14] J. C. Bradﬁeld, “Introduction to modal and temporal
mu-calculi (abstract),” in CONCUR, ser. Lecture Notes
in Computer Science, L. Brim, P. Jancar, M. Kretínský,
and A. Kucera, Eds., vol. 2421.
Springer, 2002, p. 98.
[15] S. Basu and C. R. Ramakrishnan, “Compositional anal-
ysis for veriﬁcation of parameterized systems,” Theor.
Comput. Sci., vol. 354, no. 2, pp. 211–229, 2006.
[16] T. E. Uribe, “Combinations of model checking and
theorem proving,” in FroCoS ’00: Proceedings of the
Third International Workshop on Frontiers of Combining
Systems.
London, UK: Springer, 2000, pp. 151–170.
[17] E. M. Clarke, M. Talupur, and H. Veith, “Environment
abstraction for parameterized veriﬁcation,” in VMCAI,
ser. Lecture Notes in Computer Science, E. A. Emerson
and K. S. Namjoshi, Eds., vol. 3855.
Springer, 2006, pp.
126–141.
[18] M. Talupur, “Abstraction techniques for parameterized
veriﬁcation,” Ph.D. dissertation, Computer Science De-
partment, Carnegie Mellon University, 2006, CMU-CS-
06-169.
[19] K. R. Apt and D. C. Kozen, “Limits for automatic veri-
ﬁcation of ﬁnite-state concurrent systems,” Inf. Process.
Lett., vol. 22, no. 6, pp. 307–309, May 1986.
[20] I. Suzuki, “Proving properties of a ring of ﬁnite-state
machines,” Inf. Process. Lett., vol. 28, no. 4, pp. 213–214,
Jul. 1988.
[21] J. Sakarovitch, Elements of Automata Theory.
Cam-
bridge University Press, 2009.
[22] K. Falconer, Fractal Geometry: Mathematical Founda-
tions and Applications.
Wiley, 2003.
[23] N. Agoulmine, Autonomic Network Management Princi-
ples: From Concepts to Applications.
Elsevier Science,
2010.

253
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
[24] P.
Ochsenschläger
and
R.
Rieke,
“Uniform
parameterisation
of
phase
based
cooperations,”
http://sit.sit.fraunhofer.de/smv/publications,
Fraunhofer SIT, Tech. Rep. SIT-TR-2010/1, 2010,
[retrieved: Nov, 2014].
[25] B. Alpern and F. B. Schneider, “Deﬁning liveness,”
Information Processing Letters, vol. 21, no. 4, pp. 181–
185, October 1985.
[26] P. Ochsenschläger and R. Rieke, “Reliability aspects
of uniformly parameterised cooperations,” in ICONS
2012, The Seventh International Conference on Systems,
Reunion Island.
IARIA, 2012, pp. 25–34.
Appendix
Theorem 2 (simplest well-behaved scalable systems).
( ˙L(L)I)I∈I is a well-behaved scalable system with respect
to each isomorphism structure for I based on N and
˙L(L)I =
\
i∈N
(τ I
i )−1(L) for each I ∈ I.
The proof of Theorem 2 will be given in context of
inﬂuence structures because it consists of special cases of
more general results on inﬂuence structures (see (59)).
Further
requirements,
which
assure
that
(L(L,EI,V )I)I∈I are well-behaved scalable systems, will
be given with respect to EI, BI, L and V . This will be
prepared by some lemmata.
Lemma 3. Let EI := (E(t,I))(t,I)∈T ×I be an inﬂuence
structure for I indexed by T, and let V ⊂ Σ∗. If
E(t,I′) = E(t,I)∩I′
(36)
for each t ∈ T and I,I′ ∈ I I′ ⊂ I, then
((τE(t,I))−1(V ))I∈I
is a monotonic parameterised system for each t ∈ T, and
by the intersection theorem
(
\
t∈T
(τE(t,I))−1(V ))I∈I
is a monotonic parameterised system.
Proof: Let I ∈ I and t ∈ T. From the deﬁnitions
of inﬂuence homomorphisms and inﬂuence structures it
follows
τ I
E(t,I)(ai) =
 a |
ai ∈ ΣE(t,I)
ε |
ai ∈ ΣI \ΣE(t,I)
.
For I′ ⊂ I, I′ ∈ I and ai ∈ ΣI′ then because of (36)
τ I
E(t,I)(ai) =
 a |
ai ∈ ΣE(t,I) ∩ΣI′
ε |
ai ∈ ΣI′ ∩ΣI \ΣE(t,I)
=
 a |
ai ∈ ΣE(t,I′)
ε |
ai ∈ ΣI′ \(ΣE(t,I) ∩ΣI′)
=
 a |
ai ∈ ΣE(t,I′)
ε |
ai ∈ ΣI′ \ΣE(t,I′)
= τ I′
E(t,I′)(ai),
and therefore
(τ I′
E(t,I′))−1(V ) ⊂ (τ I
E(t,I))−1(V ) for V ⊂ Σ∗.
So,
((τ I
E(t,I))−1(V ))I∈I
is a monotonic parameterised system for each t ∈ T.
Example 13. Let I be a parameter structure based on
N. For I ∈ I and i ∈ N let:
˙E(i,I) :=
 {i} |
i ∈ I
∅ |
i ∈ N \I
.
By the deﬁnition of parameter structure N ̸= ∅. So
˙EI := ( ˙E(i,I))(i,I)∈N×I
deﬁnes an inﬂuence structure for I indexed by N. ˙EI
satisﬁes (36) and by τ I
i = τ I
{i} τ I
i = τ I
˙E(i,I) for i ∈ N and
I ∈ I.
Now by Lemma 3 for V ⊂ Σ∗
((τ I
i )−1(V ))I∈I is a monotonic parameterised system
(37)
for each i ∈ N.
For this special inﬂuence structure ˙EI a stronger result
can be obtained.
Lemma 4. Let I be a parameter structure based on N
and ε ∈ L ⊂ Σ∗. Then
((τ I
i )−1(L))I∈I
is a self-similar monotonic parameterised system for each
i ∈ N, and by the intersection theorem
(
\
i∈N
(τ I
i )−1(L))I∈I
is a self-similar monotonic parameterised system.
Proof: On account of (37)
ΠI
I′((τ I
i )−1(L)) = (τ I′
i )−1(L)
has to be shown for I,I′ ∈ I, I′ ⊂ I, and i ∈ N.
(37) implies (τ I′
i )−1(L) ⊂ (τ I
i )−1(L) and therefore,
(τ I′
i )−1(L) = ΠI
I′((τ I′
i )−1(L)) ⊂ ΠI
I′((τ I
i )−1(L)). (38)
It remains to show ΠI
I′((τ I
i )−1(L)) ⊂ (τ I′
i )−1(L).
Case 1. i /∈ I′
Because of ε ∈ L and τ I′
i (w) = ε for i /∈ I′ and w ∈ Σ∗
I′
it holds (τ I′
i )−1(L) = Σ∗
I′ and so
ΠI
I′((τ I
i )−1(L)) ⊂ (τ I′
i )−1(L) for i /∈ I′.
(39)
Case 2. i ∈ I′
From deﬁnitions of ΠI
I′,τ I
i and τ I′
i
follows
τ I
i = τ I′
i ◦ΠI
I′ for i ∈ I′.
(40)

254
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
For x ∈ ΠI
I′((τ I
i )−1(L)) exists y ∈ Σ∗
I with τ I
i (y) ∈ L
and x = ΠI
I′(y). Because of (40) holds
τ I′
i (x) = τ I′
i (ΠI
I′(y)) = τ I
i (y) ∈ L,
hence, x ∈ (τ I′
i )−1(L). Therefore,
ΠI
I′((τ I
i )−1(L)) ⊂ (τ I′
i )−1(L) for i ∈ I′.
(41)
Because of (39), (41) and (38) holds
ΠI
I′((τ I
i )−1(L)) = (τ I′
i )−1(L)
for I,I′ ∈ I, I′ ⊂ I and i ∈ N.
Intersections of system behaviours play an important
role concerning uniformity of parameterisation. Therefore,
some general properties of intersections of families of sets
will be presented.
Let T be a set. A family f = (ft)t∈T with ft ∈ F for
each t ∈ T is formally equivalent to a function f : T → F
with ft := f(t).
Let M be a set. A family f = (ft)t∈T with ft ∈ F =
P(M) for each t ∈ T is called a family of subsets of M.
Let now T ̸= ∅ and f a family of subsets of M. The
intersection T
t∈T
ft is deﬁned by
\
t∈T
ft = {m ∈ M|m ∈ ft for each t ∈ T}.
(42)
If f = g ◦h with h : T → H and g : H → F then
\
t∈T
f(t) =
\
x∈h(T )
g(x).
(43)
If especially f = h and g is the identity on F, then from
(43) follows
\
t∈T
f(t) =
\
x∈f(T )
x.
For a second family of sets f′ : T ′ → F with f′(T ′) =
f(T) follows then
\
t∈T
f(t) =
\
t′∈T ′
f(t′).
In the following we will use family and function
notations side by side.
Let f = (ft)t∈T a family of sets with f : T → F = P(M).
If T = ˚
T ∪ ˆT with ˚
T ̸= ∅ and f( ˆT) = {M}, then from (42)
follows
\
t∈T
f(t) =
\
t∈˚
T
f(t).
(44)
Let EI = (E(t,I))(t,I)∈T ×I be an inﬂuence structure
for I indexed by T.
For each I ∈ I a family of sets
EI(I) := (E(t,I))t∈T
with E(t,I) = EI(I)(t) ∈ P(I) is deﬁned, and it holds
EI(I) : T → P(I).
From (43) it follows (with h = EI(I))
\
t∈T
(τ I
E(t,I))−1(V ) =
\
x∈EI(I)(T )
(τ I
x)−1(V )
(45)
for each V ⊂ Σ∗ and I ∈ I.
For each I ∈ I holds τ I
∅ (w) = ε for each w ∈ Σ∗
I. It
follows,
(τ I
∅ )−1(V ) = Σ∗
I if ε ∈ V ⊂ Σ∗.
(46)
Because of (43), (44), (45), and (46)
\
t∈T
(τ I
E(t,I))−1(V ) =
\
x∈EI(I)(TI)
(τ I
x)−1(V )
=
\
t∈TI
(τ I
E(t,I))−1(V )
(47)
for each TI with ∅ ̸= TI ⊂ T and EI(I)(T)\EI(I)(TI) ∈
{∅,{∅}} and ε ∈ V ⊂ Σ∗.
Each bijection ι : I → I′ deﬁnes another bijection ˘ι :
P(I) → P(I′) by
˘ι(x) := {ι(y) ∈ I′|y ∈ x} for each x ∈ P(I).
Lemma 5. Let EI = (E(t,I))(t,I)∈T ×I be an inﬂu-
ence structure for I indexed by T, and let BI =
(B(I,I′))(I,I′)∈I×I be an isomorphism structure for I.
Let
ε ∈ V ⊂ Σ∗, and let (TK)K∈I be a family
with ∅ ̸= TK ⊂ T and
EI(K)(T)\EI(K)(TK) ∈ {∅,{∅}} for each K ∈ I,
such that ˘ι(EI(I)(TI)) = EI(I′)(TI′)
for each (I,I′) ∈ I ×I and ι ∈ B(I,I′),
(48)
then
\
t∈T
(τ I
E(t,I))−1(V ) =
\
t∈TI
(τ I
E(t,I))−1(V )
(49)
for each I ∈ I, and
ιI
I′[
\
t∈T
(τ I
E(t,I))−1(V )] =
\
t∈T
(τ I′
E(t,I′))−1(V )
(50)
for each (I,I′) ∈ I ×I and ι ∈ B(I,I′).
Proof of (49): Because of (47) from assumption (48)
directly follows (49).
For the proof of (50) the following property of the
homomorphisms τ I
K is needed:
Let ι : I → I′ a bijection and K ⊂ I, then τ I′
ι(K) ◦ιI
I′ =
τ I
K and so
τ I′
ι(K) = τ I
K ◦(ιI
I′)−1.
(51)
Proof of (51):

255
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
The elements of ΣI are of the form ai with i ∈ I and
a ∈ Σ. For these elements holds
τ I
K(ai) =

a |
i ∈ K
ε |
i ∈ I \K
=
 a |
ι(i) ∈ ι(K)
ε |
ι(i) ∈ I′ \ι(K)
= τ I′
ι(K)(aι(i)) = τ I′
ι(K)(ιI
I′(ai)),
which proves (51).
Proof of (50): Because of (47) and (51)
ιI
I′[
\
t∈T
(τ I
E(t,I))−1(V )]
= ιI
I′[
\
x∈EI(I)(TI)
(τ I
x)−1(V )]
= ((ιI
I′)−1)−1[
\
x∈EI(I)(TI)
(τ I
x)−1(V )]
=
\
x∈EI(I)(TI)
((ιI
I′)−1)−1[(τ I
x)−1(V )]
=
\
x∈EI(I)(TI)
(τ I
x ◦(ιI
I′)−1)−1(V )
=
\
x∈EI(I)(TI)
(τ I′
ι(x))−1(V )
=
\
x∈EI(I)(TI)
(τ I′
˘ι(x))−1(V ).
(52)
From (43) (with h = ˘ι) and the assumption (48) follows
\
x∈EI(I)(TI)
(τ I′
˘ι(x))−1(V ) =
\
x′∈˘ι(EI(I)(TI))
(τ I′
x′ )−1(V )
=
\
x′∈EI(I′)(T ′
I)
(τ I′
x′ )−1(V ).
Furthermore, from (47) follows
\
x′∈EI(I′)(T ′
I)
(τ I′
x′ )−1(V ) =
\
t∈T
(τ I′
E(t,I′))−1(V ).
(53)
(52) - (53) prove (50).
The case T = N, where I is based on N, allows a
simpler suﬃcient condition for (49) and (50).
Lemma 6. Let I be a parameter structure based on N,
EI = (E(n,I))(n,I)∈N×I be an inﬂuence structure for
I, and let BI = (B(I,I′))(I,I′)∈I×I be an isomorphism
structure for I.
Let ε ∈ V ⊂ Σ∗,
(54a)
for each I ∈ I and n ∈ N let E(n,I) = ∅,
or it exists an in ∈ I with E(n,I) = E(in,I), and
(54b)
for each (I,I′) ∈ I ×I,ι ∈ B(I,I′) and i ∈ I holds
ι(E(i,I)) = E(ι(i),I′).
(54c)
Then
\
n∈N
(τ I
E(n,I))−1(V ) =
\
n∈I
(τ I
E(n,I))−1(V )
for each I ∈ I, and
ιI
I′[
\
n∈N
(τ I
E(n,I))−1(V )] =
\
n∈N
(τ I′
E(n,I′))−1(V )
for each (I,I′) ∈ I ×I and ι ∈ B(I,I′).
Proof: From (54b) follows EI(I)(N) = EI(I)(I) or
EI(I)(N) = EI(I)(I) ·∪{∅}, so
EI(I)(N)\EI(I)(I) ∈ {∅,{∅}} for each I ∈ I.
(55)
From (54c) follows
˘ι(EI(I)(I)) ⊂ EI(I′)(I′).
(56)
Because ι : I → I′ is a bijection, for each i′ ∈ I′ exists
an i ∈ I with ι(i) = i′. Because of (54c) holds ˘ι(E(i,I)) =
E(i′,I′), where E(i,I) ∈ EI(I)(I). From this follows
EI(I′)(I′) ⊂ ˘ι(EI(I)(I)).
(57)
Because of (55) - (57), with T = N and (TI)I∈I = (I)I∈I,
(54a)−(54c) implies (48).
Example
14
(Example
13
(continued)).
Let
I
be a parameter structure based on N
and BI =
(B(I,I′))(I,I′)∈I×I be an isomorphism structure for I.
Then ˙EI satisﬁes (54b) and (54c).
So for ε ∈ L ⊂ Σ∗ Lemma 6 implies
\
n∈N
(τ I
n)−1(L) =
\
n∈I
(τ I
n)−1(L) for each I ∈ I and
ιI
I′[
\
n∈N
(τ I
n)−1(L)] =
\
n∈N
(τ I′
n )−1(L)
(58)
for each (I,I′) ∈ I ×I and ι ∈ B(I,I′).
Now Lemma 4 together with (58) proves Theorem 2.
(59)
Because of τ I
n = τ I
˙E(n,I) for I ∈ I and n ∈ N, (58)
and the deﬁnitions of ( ˙L(L)I)I∈I and (L(L,EI,V )I)I∈I
imply
˙L(L)I =
\
n∈I
(τ I
n)−1(L) =
\
n∈I
(τ I
n)−1(L)∩
\
n∈I
(τ I
n)−1(V )
= ˙L(L)I ∩
\
n∈N
(τ I
n)−1(V )
= ˙L(L)I ∩
\
n∈N
(τ I
˙E(n,I))−1(V )
= L(L, ˙EI,V )I
(60)
for I ∈ I and V ⊃ L.

256
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
(60) gives a representation of ( ˙L(L)I)I∈I in terms of
(L(L,EI,V )I)I∈I.
For the following theorems please remember that by
the general deﬁnition of L(L,EI,V )I it is assumed that
∅ ̸= L ⊂ V and L,V are preﬁx closed. This implies ε ∈
L ⊂ V .
Lemma 7. Let I be a parameter structure, EI an inﬂu-
ence structure for I indexed by T and BI an isomorphism
structure for I.
Assuming (36) and (48), then
(L(L,EI,V )I)I∈I
is a scalable systems with respect to BI. It holds
L(L,EI,V )I = ˙L(L)I ∩
\
n∈TI
(τ I
E(n,I))−1(V )
for each I ∈ I.
Proof: By Theorem 2, ( ˙L(L)I)I∈I is a scalable
system with respect to BI. By Lemma 3 and 5 (50)
(
\
t∈T
(τ I
E(t,I))−1(V ))I∈I
is a scalable system with respect to BI too. Now part (ii)
of the intersection theorem proves (L(L,EI,V )I)I∈I to
be a scalable system with respect to BI. Lemma 5 (49)
completes the proof of Lemma 7.
Using Lemma 6 instead of Lemma 5 proves the
following.
Theorem 3 (construction condition for scalable systems).
By the assumptions of Lemma 6 and (36) with T = N,
(L(L,EI,V )I)I∈I is a scalable system with respect to BI.
It holds
L(L,EI,V )I = ˙L(L)I ∩
\
n∈I
(τ I
E(n,I))−1(V )).
Remark 3. It can be shown that in SP(L,V ) N can be
replaced by each countable inﬁnite set.
More precisely, let N′ be another set and ι : N → N′ a
bijection. ιN
N′ : Σ∗
N → Σ∗
N′ is the isomorphism deﬁned as
in the deﬁnition of isomorphism structure. It now holds
ΘN = ΘN′ ◦ιN
N′ and τ N
n = τ N′
ι(n) ◦ιN
N′
(61)
for each n ∈ N. Furthermore,
ιN
N′ ◦ΠN
K = ΠN′
ι(K) ◦ιN
N′
(62)
for each K ⊂ N. From (61) and commutativity of inter-
section now
(
\
n∈N
(τ N
n )−1(L))∩(ΘN)−1(V ) =
= (ιN
N′)−1[(
\
n∈N
(τ N′
ι(n))−1(L))∩(ΘN′)−1(V )]
= (ιN
N′)−1[(
\
n′∈N′
(τ N′
n′ )−1(L))∩(ΘN′)−1(V )].
(63)
By (62),
ΠN
K ◦(ιN
N′)−1 = (ιN
N′)−1 ◦ΠN′
ι(K).
(64)
Because of (63) and (64)
ΠN
K[(
\
n∈N
(τ N
n )−1(L))∩(ΘN)−1(V )] =
= (ιN
N′)−1(ΠN′
ι(K)[(
\
n′∈N′
(τ N′
n′ )−1(L))∩(ΘN′)−1(V )]).
From
ΠN
K[(
\
n∈N
(τ N
n )−1(L))∩(ΘN)−1(V )] ⊂ (ΘN)−1(V )
now follows
ΠN′
ι(K)[(
\
n′∈N′
(τ N′
n′ )−1(L))∩(ΘN′)−1(V )]
⊂ ιN
N′((ΘN)−1(V )).
(65)
Because of (61) ΘN ◦(ιN
N′)−1 = ΘN′ and so
(ΘN′)−1(V ) = ιN
N′((ΘN)−1(V )).
Therefore, from (65) follows
ΠN′
ι(K)[(
\
n′∈N′
(τ N′
n′ )−1(L))∩(ΘN′)−1(V )] ⊂ (ΘN′)−1(V ).
Because for each ∅ ̸= K′ ⊂ N′ it exists an ∅ ̸= K ⊂ N
with K′ = ι(K), by SP(L,V ), we get for each ∅ ̸= K ⊂ N
a corresponding inclusion with N′ replacing N and K′
for K.
Lemma 8. The assumptions of Lemma 3 and Lemma 4
together with SP(L,V ) imply that (X(L,V,t)I)I∈I with
X(L,V,t)I :=
\
n∈N
(τ I
n)−1(L)∩(τ I
E(t,I))−1(V )
is a self-similar monotonic parameterised system for each
t ∈ T.
Proof:
By
Lemma
3
and
Lemma
4,
((τ I
E(t,I))−1(V ))I∈I
and
( T
n∈N
(τ I
n)−1(L))I∈I
are
monotonic parameterised systems. So by the intersection

257
International Journal on Advances in Systems and Measurements, vol 7 no 3 & 4, year 2014, http://www.iariajournals.org/systems_and_measurements/
2014, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
theorem (X(L,V,t)I)I∈I is a monotonic parameterised
system for each t ∈ T. Therefore,
X(L,V,t)I′ = ΠI
I′(X(L,V,t)I′) ⊂ ΠI
I′(X(L,V,t)I)
for each I,I′ ∈ I with I′ ⊂ I. So the proof of self-similarity
can be reduced to the proof of
ΠI
I′(X(L,V,t)I) ⊂ X(L,V,t)I′
(66)
for each t ∈ T and I,I′ ∈ I with I′ ⊂ I.
Because by Lemma 4
(
\
n∈N
(τ I
n)−1(L))I∈I
is self-similar, it holds
ΠI
I′(X(L,V,t)I) ⊂ ΠI
I′(
\
n∈N
(τ I
n)−1(L)) =
\
n∈N
(τ I
n)−1(L).
So the proof of (66) can be reduced to the proof of
ΠI
I′[
\
n∈N
(τ I
n)−1(L)∩(τ I
E(t,I))−1(V )] ⊂ (τ I′
E(t,I′))−1(V )
(67)
for each t ∈ T and I,I′ ∈ I with I′ ⊂ I.
For each
w ∈ (
\
n∈N
(τ I
n)−1(L))∩(τ I
E(t,I))−1(V )
exists a r ∈ N and ui ∈ Σ∗
E(t,I) for 1 ≤ i ≤ r and vi ∈
Σ∗
I\E(t,I) for 1 ≤ i ≤ r with w = u1v1u2v2 ...urvr. Note
that Σ∅ := ∅ and ∅∗ = {ε}. Because u1u2 ...ur ∈ Σ∗
E(t,I)
and v1v2 ...vr ∈ Σ∗
I\E(t,I) holds
ΘN(u1u2 ...ur) = τ I
E(t,I)(u1u2 ...ur)
= τ I
E(t,I)(w) ∈ V.
(68)
With the same argumentation holds
τ N
n (u1u2 ...ur) = τ I
n(u1u2 ...ur) = τ I
n(w) ∈ L
(69)
for n ∈ E(t,I) and
τ N
n (u1u2 ...ur) = ε ∈ L
(70)
for n ∈ N \E(t,I). With (68) - (70) now
u1u2 ...ur ∈ (
\
n∈N
(τ N
n )−1(L))∩(ΘN)−1(V ),
and on behalf of precondition SP(L,V ) holds
ΠN
I′(u1u2 ...ur) =ΠE(t,I)
I′∩E(t,I)(u1u2 ...ur)
∈ Σ∗
I′∩E(t,I) ∩(ΘN)−1(V ).
(71)
Furthermore,
ΠI
I′(w) =ΠI
I′(u1v1u2v2 ...urvr)
=ΠE(t,I)
I′∩E(t,I)(u1)ΠI\E(t,I)
I′\E(t,I)(v1)...
ΠE(t,I)
I′∩E(t,I)(ur)ΠI\E(t,I)
I′\E(t,I)(vr).
(72)
Because of (36), E(t,I′) ⊂ E(t,I) and so I′ \E(t,I) ⊂
I′ \E(t,I′) and thus
τ I′
E(t,I′)(ΠI\E(t,I)
I′\E(t,I))(vi) = ε
for 1 ≤ i ≤ r. With (36) and (72) it follows
τ I′
E(t,I′)(ΠI
I′(w)) = τ I′
E(t,I′)(ΠE(t,I)
E(t,I′)(u1 ...ur)).
(73)
Because τ I′
E(t,I′)(x) = ΘN(x) for each x ∈ Σ∗
E(t,I′) now
on behalf of (73), (36), and (71)
τ I′
E(t,I′)(ΠI
I′(w)) = ΘN(ΠE(t,I)
E(t,I′)(u1 ...ur)) ∈ V,
and thus
ΠI
I′(w) ∈ (τ I′
E(t,I′))−1(V ).
This proves (67) and completes the proof of Lemma 8.
Because of the idempotence of intersection
\
n∈N
(τ I
n)−1(L)∩
\
t∈T
(τ I
E(t,I))−1(V )
=
\
t∈T
[
\
n∈N
(τ I
n)−1(L)∩(τ I
E(t,I))−1(V )].
Now the intersection theorem and Lemma 8 imply
Lemma 9. If SP(L,V ), then by the assumptions of
Lemma 3 and 4
[
\
n∈N
(τ I
n)−1(L)∩
\
t∈T
(τ I
E(t,I))−1(V )]I∈I
is a self-similar monotonic parameterised system.
Combining Lemma 9 with Lemma 7 or Theorem 3
imply
Theorem 4 (construction condition for well-behaved
scalable systems). By the assumptions of Lemma 7 or
Theorem 3 together with SP(L,V )
(L(L,EI,V )I)I∈I
is a well-behaved scalable system.

