Extendable Dialog Script Description Language
for Natural Language User Interfaces
Kiyoshi Nitta
Yahoo Japan Research
Tokyo, Japan
Email: knitta@yahoo-corp.jp
Abstract—Natural language user interfaces are expected to
be useful and provide a friendly atmosphere for human users
working with intelligent human-computer interaction systems.
Building correct and consistent large-scale script data for such
interfaces requires large costs for construction and maintenance.
Scripts written by many end-users in thoroughly ﬂexible script
languages might be a practical solution to this problem. We pro-
pose a dialog script description language and its framework. Two
versions of script execution engines have been developed in C++
and Erlang programming languages. An example dialog script
processed by one of these engines shows that a script editing
function can be successfully represented by the script language.
Because the script language has self-extending ﬂexibility and
ability to represent several versions of scripting languages, it
increases the opportunity for end-users to accumulate and share
a large amount of script data.
Index Terms—natural language user interface; conversational
agent; chat bot; chatter-bot; ontology extension
I. INTRODUCTION
Constructing large-scale dialog script databases is one of
the most critical issues for building practical natural language
user interfaces that interact with users via typed text messages
or voice utterances. Two major approaches can be considered
to perform the task. The ﬁrst approach is to apply machine
learning technology to user operation or conversation logs
for constructing dialog scripts. While the machine learning
approach has an advantage in constructing large-scale scripts
for reducing editorial operations of human staff, it might be
difﬁcult to achieve high precision adequateness of automati-
cally generated scripts. The second approach is to accumulate
dialog scripts created by many individual users. Script editing
through natural language user interfaces might allow users to
create their own dialog scripts. Because each user may have
different preferences for editing scripts, such interfaces should
be ﬂexibly customized to maximize the opportunity.
With the second approach, we should address two technical
challenges to operate a service in which many users safely
customize natural language user interfaces for editing dialog
scripts:
• dialog script languages and engines that are ﬂexible
for extending their description capability and modifying
scripts by some types of script executions,
• load regulation methods for handling large-scale conver-
sational transactions of many users.
We devised a knowledge representation framework [1] on
which ﬂexible dialog script languages can be represented. We
developed several versions of ﬂexible dialog script languages
called Graphical Language for Dialog Scripts (GLDS) and two
versions of GLDS execution engines coded in C++ and Erlang
programming languages. In this paper, we explain a GLDS
that address the ﬁrst challenge by using the framework that
can ﬂexibly extend ontology. GLDS and its engines provide
language elements that can modify operating dialog scripts.
The Erlang version of the dialog script execution engine
address the second challenge by using the parallel processing
capability of Erlang language; however, this will be addressed
in another study.
The main contributions of this paper can be summarized as
follows:
• design of a ﬂexible dialog script language (GLDS),
• implementation of GLDS execution engines, and
• evaluation of conversational operations for modifying
dialog scripts.
The rest of this paper is organized as follows. Section II
introduces the devised framework, execution engine algorithm,
and GLDS dialog script language designed using the frame-
work. Section III explains a self extendable example dialog
script successfully executed using a system developed using
the framework. Section IV describes the self-extending ﬂexi-
bility and ability of representing several versions of scripting
languages. In Section V, several relevant studies on natu-
ral language user interface systems, graph-based knowledge
representation methods, and semantic web technologies are
summarized. This paper is concluded in Section VI.
II. GLDS FRAMEWORK
The framework described in this section consists of a data
structure having basic semantics of dialog scripts and a dialog
script execution engine that interprets the semantics. The data
structure offers an extensible basis for GLDS. Dialog scripts
executed by the engine are represented by GLDS dialog scripts
based on this data structure.
A. Graph Structure and Semantics
The data structure of the framework is based on an aug-
mented directed graph ADG(E) [1] that permits edges to
69
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-269-1
INTELLI 2013 : The Second International Conference on Intelligent Systems and Applications

connect to other edges as well as vertexes.
Ev
=
{e(es, ed)|es = null, ed = null}
(1)
Ehoe
=
{e(es, ed)|es ∈ E, ed = null}
(2)
Etoe
=
{e(es, ed)|es = null, ed ∈ E}
(3)
Ee
=
{e(es, ed)|es, ed ∈ E}
(4)
E
=
Ev ∪ Ehoe ∪ Etoe ∪ Ee
(5)
Here, e means an element. Element e has a binomial structure
(es, ed), which is either an element of set E or an empty
element null. An element of Ev is called a vertex and an
element of Ee is called an edge. An element of Ehoe ∪ Etoe
is called an open edge. Element set E is the union of sets of
vertexes, edges, and open edges.
The semantics of the framework consists of three layers. The
bottom layer semantics gives the meaning of the relationship
to the edge set. If an element e(es, ed) is an edge, then e
expresses the relationship from element es (source) to ele-
ment ed (destination). The ADG-based data structure permits
element ed to become an edge. That is, edge e can express
the relationship to edge element ed.
The middle layer semantics gives the class-instance struc-
ture by deﬁning a vertex set Eapriori.
Eapriori = {vclass, vins} ⊂ Ev
(6)
The vertex vclass means that its instance elements are classes,
and vertex vins means that its instance edges are instance
relations. Consider the following element sets:
Eii
=
{e(vins, ed)|∃ed ∈ E}
(7)
Eins
=
{e|∃eii(vins, e) ∈ Eii} ⊂ Ee
(8)
Eclass
=
{e|∃ei(vclass, e) ∈ Eins} ⊂ Ev
(9)
Element set Eii includes all edges starting from the a priori
vertex vins. Each element e(vins, ed) ∈ Eii means that its
destination element ed is an instance relation. Edge set Eins
includes all these instance relation edges. Set Eins is called an
instance relation set. Each instance relation edge e(ec, ed) ∈
Eins means that its source vertex ec is a class and that its
destination ed is an instance of the class. Vertex set Eclass
contains instance vertexes of the class vclass and is called
a class set. Any set tuple (Eins, Eclass) should satisfy the
following condition:
∀ei(ec, e) ∈ Eins, ∃ec ∈ Eclass
(10)
The top-level layer semantics deﬁnes the meaning of some
vertex elements in class set Eclass. Consider the following
instance element set ins(ec) for an arbitrary class vertex ec ∈
Eclass:
ins(ec) = {e|∃ei(ec, e) ∈ Eins} ⊂ E
(11)
Each element of set ins(ec) inherits the meaning from class
ec. All functional deﬁnitions are combined to each element of
class set Eclass. Dialog scripts based on the framework are
TABLE I
CLASS DEFINITIONS REQUIRED BY DIALOG SCRIPT TRACER (DST)
class
type
meaning
SRL
vertex
root of dialog script
SRK
vertex
matching keyword
REL
edge
transitional relation
RM
vertex
reply message
SEL
vertex
select action
represented by the instance data of these classes. The data set
is expressed as Edata:
Edata =
[
ec∈Eclass
ins(ec)
(12)
The data structure part of the framework is denoted as
ADGF :
ADGF = (Eapriori, Eii, Eins, Eclass, Edata)
(13)
In this graph structure, every element of the sets, except for
Eapriori and Eii, has at least one edge that connects from a
semantically deﬁned vertex to the element. This characteristic
ensures that the meanings of all elements can always be
resolved by checking source nodes of incoming instance edges.
B. Dialog Script Tracer
Dialog scripts are executed by a dialog controller called a
dialog script tracer (DST). It requires the deﬁnitions of the
classes in Table I. The ‘class’ column lists the mnemonic
symbols of these classes, the ‘type’ column lists the vertex
or edge type of the instance element of each class, and the
‘meaning’ column gives brief semantic explanations of these
classes.
These classes are represented as class vertexes in the graph
structure of the framework.
Eclass = {csrl, csrk, crel, crm, csel}
(14)
Dialog
scripts
are
expressed
by
instance
elements
Isrl, Isrk, Irel, Irm, and Isel, where
Isrl = ins(csrl), Isrk = ins(csrk), Irel = ins(crel),
Irm = ins(crm), Isel = ins(csel)
(15)
There is no class of which an instance element can become
both types.
Isrl, Isrk, Irm, Isel
⊆
Ev ∩ Edata
(16)
Irel
⊆
Ee ∩ Edata
(17)
Only one instance element of the SRL class must be
registered in a dialog script. When a new conversational
session starts, the DST sets its context status to the vertex
element. The DST can set its context status to one of the
vertex set Vcontext in an executing dialog script.
Isrl
=
{root}
(18)
Vcontext
=
Isrl ∪ Isel
(19)
70
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-269-1
INTELLI 2013 : The Second International Conference on Intelligent Systems and Applications

csrl
csrk
crel
crm
sel
c
vclass
vins
m1
1
k
4
k
3
k
2
k
m4
m3
m2
s1
root
Fig. 1. Simple example of DST-consistent dialog script
At least one instance element of the SRK class must be
connected to each element of Vcontext using REL instance
elements. When the context status is vc and the DST receives
a user input message, the DST attempts to ﬁnd a vc-related
SRK instance element whose label matches the input message.
∀vc ∈ Vcontext, ∃k ∈ Isrk, ∃r(vc, k) ∈ Irel
(20)
At least one instance element of action type classes must
be connected to each element of SRK.
∀k ∈ Isrk, ∃a ∈ Vaction, ∃r(k, a) ∈ Irel
(21)
where
Vaction = Irm ∪ Isel
(22)
When an SRK instance element k is found to be a matched
keyword, the DST randomly selects an action instance element
a and executes it. If the element a is an instance of the RM
class, the DST replies to the user with the text label of a and
sets the context to root. If element a is an instance of the SEL
class, the DST sets the context to a.
A simple example dialog script that can be executed by the
DST is shown in Fig. 1. The dashed lines represent instance
relations corresponding edge elements Eins. Some are omitted
for simplifying the diagram, e.g., relations between csrk and
k2 or crm and m2. In this example, Vcontext = {root, s1} and
TABLE II
SOME DEFINED CLASSES IN GLDS
class
type
meaning
1
SM
edge
selection message relation
2
WCK
vertex
match a wild card keyword
CFM
vertex
conﬁrm an element
CFA
vertex
conﬁrm an array
FMT
edge
format a relation
NOP
vertex
no operation (dummy)
SVC
vertex
save the context
SLS
vertex
save the last selection
SLR
vertex
save the last reply
SVT
vertex
save a token
QUI
vertex
quit
3
SUC
edge
success attribute
FAI
edge
failure attribute
IMM
edge
immediate attribute
4
VAR
edge
ﬁrst argument
VR2
edge
second argument
VR3
edge
third argument
5
CTX
edge
variable (context)
LSK
edge
variable (last selected keyword)
LRP
edge
variable (last reply)
MSG
edge
variable (message)
6
LET
vertex
set literal
COP
vertex
copy
ISN
vertex
check null
CLR
vertex
clear
7
CSMS
vertex
search selection message
CSMD
vertex
delete selection message
CSMP
vertex
replace selection message
Vaction = {s1, m1, m2, m3, m4}. The diagram illustrates that
the DST processes elements in Isrk and Vaction alternatively.
C. Graphical Language for Dialog Scripts
The meanings of dialog scripts are resolved through the
meanings of all the elements in vertex set Eclass of the
framework data structure explained in Subsection II-A. We
added class vertexes required by dialog scripts for describing
practical conversational applications. Their meanings are writ-
ten in program codes, which are almost separated from DST
implementations. Their major classes are listed in TABLE II.
Classes are divided into seven categories: 1) those required
to implement simple replies, 2) those accessing functions of
the dialog controller, 3) those modifying transitional relations,
4) those specifying variable arguments, 5) those identifying
variable entities, 6) those operating on variables, and 7) those
accessing the data structure of the GLDS framework. Due to
the space limitation of this paper, detailed description of each
class is omitted. Some are explained in Section III.
III. EXAMPLE
GLDS dialog scripts can be modiﬁed through the execution
of another GLDS dialog script that uses action instances
to modify the data structure of the GLDS framework. An
example of such a GLDS dialog script is shown in Fig. 2.
The script modiﬁes a selection message of an existing script.
The selection messages are replied to the user when the DST
change its context.
71
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-269-1
INTELLI 2013 : The Second International Conference on Intelligent Systems and Applications

f
i
i
s
NOP1
QUI1
SVC
<CTX>
1
m
wld1
i
CSMS
<MSG>
<CTX>
<LRP>
i
f
i
CFM1
i
s
m 2
m 3
m 4
NOP2
<CTX>
sra
QUI2
m 5
m 6
NOP3
i
srn1
1
sry
str
kw
<LRP>
CFM 2
m 7
<LRP>
str
<LRP>
sry 2
CFM3
m 8
sry 3
CSMD
<CTX>
m 9
m 10
s
f
(sra)
srn2
<MSG>
str
<LRP>
<CTX>
<MSG>
SVT1
SVT2
NOP4
m 11
wld2
m 13
NOP5
srn3
CFM4
m 12
CSMP
sry 4
m 14
i
i
v
sm
sm
sm
v
v3
v
v2
v
sm
fmt
v
sm
sm
v
v
sm
fmt
v
v2
sm
v
v
sm
fmt
sm
sm
v
v2
v3
sm
sm
Fig. 2. Example GLDS dialog script for changing selection message
TABLE III
STRING DATA OF SCRIPT FOR CHANGING A SELECTION MESSAGE
symbol
class
string
kw
SRK
change selection message
str
RM
selection message: ‘%s’
sryx
SRK
yes
srnx
SRK
no
sra
SRK
abandon
m1
RM
Move to any context.
m2
RM
Specify a selection message to
change.
m3
RM
No matching selection message
found.
m4
RM
Do you want to change this
selection message?
m5
RM
Abandon changing the selection
message.
m6
RM
Specify a selection message
again.
m7
RM
Do you want to delete it?
m8
RM
Really delete?
m9
RM
Deleted.
m10
RM
Could not delete the last
selection message.
m11
RM
Specify a new selection message.
m12
RM
Do you want to replace the
selection message with this?
m13
RM
Specify a new selection message
again.
m14
RM
Replaced.
Instance edges and vertexes are represented by arrows and
large circles in the diagram. A label consisting of capital letters
in a circle indicates that the labeled vertex is an instance of
the class whose name is indicated by the label. The number
sufﬁx of such a label identiﬁes an instance from among those
of the same class. A capital-letter label surrounded by angle
brackets indicates that the vertex is a class vertex. This notation
is used to represent variable references. A label consisting of
lowercase letters in a circle indicates a vertex bound with string
data (see TABLE III), except that the label “wld” indicates an
instance vertex of the WCK class (see TABLE II), which is
not bound with any string data.
String labels aligned with arrows indicate to which class
each edge instance belongs. An arrow with no string label
represents an instance edge of the transitional relation (REL)
class. An arrow with the label “sm” represents an instance
edge of the selection message relation (SM) class. An arrow
with the label “v”, “v2”, or “v3” represents an instance edge
of the argument variable relation (VAR, VR2, or VR3) class.
An arrow with the label “fmt” represents an instance edge of
the format relation (FMT) class. A small circle surrounding
the characters “s”, “f”, or “i” indicates that the aligned edge
has success, failure, or immediate attributes, respectively.
Fig. 3 shows an example of a dialog between a user (U)
and the system (A) executing the script depicted in Fig. 2. It is
assumed that the dialog began during the execution of another
script. When kw string (see TABLE III) is detected, DST
execution engine process SVC vertex that saves the current
context pointer into variable <CTX>. Because this script
72
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-269-1
INTELLI 2013 : The Second International Conference on Intelligent Systems and Applications

U:
Change selection message
A:
Specify a selection message to change.
U:
Source
A:
Do you want to change this selection message?
selection message: ‘source?’
yes, no, abandon.
U:
Yes
A:
Do you want to delete it?
yes, no, abandon.
U:
No
A:
Specify a new selection message.
U:
What source do you have in mind?
A:
Do you want to replace the selection message with this?
selection message: ‘What source do you have in mind?’
yes, no, abandon.
U:
Yes
A:
Replaced.
Fig. 3. Example of dialog when changing selection message
was invoked during the execution of another script, the SVC
process succeeds. DST follows the edge having immediate
and success attributes, processes NOP1 and m2 that replies
m2 string to the user, and waits for user input. DST accepts
any user input string, because wld1 is connected to NOP1 by
a REL edge. Then DST proceeds to process SVT1 that saves
the user input string into variable <MSG>. Vertex CSMS
searches a RM vertex that is connected from the vertex stored
in variable <CTX> and has a text label matching the string
stored in variable <MSG>. If the search task is succeeded, it
stores the result into variable <LRP>. The explanations for
the rest processes are omitted because of the space limitation
of this paper.
IV. DISCUSSION
GLDS has been developed by extending script description
language speciﬁcations. We experimented with at least three
internal versions: GLDS0, GLDS1, and GLDS2. The basic
ﬁnite-state-based dialog scripts are represented by GLDS0,
which contains the class vertexes in Equation (14). We ex-
tended GLDS0 to GLDS1 for representing dialog scripts
that have script editing functions. GLDS1 contains action
classes, each of which performs a set of complex operations
for a speciﬁc script editing task. GLDS1 provides a safe
environment in which inconsistent dialog scripts cannot be
generated by any script editing operation. However, GLDS1
must append class deﬁnitions with executable codes when a
user requires new editing tasks. After such classes have been
developed, we found that they can be represented by GLDS
graphs connecting more reduced granularity of commonly
reusable functions. We extended GLDS1 to GLDS2 by
reducing complex classes to simple classes. Each GLDS1-
introduced class can be replaced by an adequate combination
graph structure using GLDS2-introduced classes. Some of
these classes are listed in TABLE II. The ‘changing a selection
message’ example explained in Section III and depicted in Fig.
2 is written in GLDS2, which permits the representation of
dialog scripts that may generate inconsistent dialog scripts due
to their executions. This problem should be resolved in future
studies.
The polymorphic framework holds executable script data
written in these three GLDS versions. This makes it easier
for the developer to try a new script description language
even if the amount of accumulated legacy script data is huge.
Our experimental system even permits the execution of dialog
scripts that connect different versions of GLDS class instances.
Although there is not enough space to show concrete examples
in this paper, we can note that this beneﬁt is derived by
the graph structure design. As explained in Section II, the
graph structure maintains an element set Eclass that deﬁnes
a kind of ontology giving the semantics of each dialog script
element. The class set Eclass can be extended by just adding
classes that have new meanings, when a new version of
GLDS is introduced. Therefore, no conﬂict occurs by resolving
semantics of script elements, even if they are instances of
different versions of GLDS classes.
The change selection message script example shown in Fig.
2 modiﬁed another GLDS dialog script through a conversation
between the user and the system. It shows that GLDS and its
framework provides a script modiﬁcation function. We also
implemented a GLDS dialog script that dynamically generates
GLDS graph data and executes them. Although this was not
efﬁcient, it might be a solution to the problem of ﬁnite-
state-based dialog control methods requiring a huge amount
of scripts to achieve the conversational ﬂexibility that can
be provided using frame-based methods [2]. GLDS and its
framework offer a kind of programming environment rather
than a built-in customization language. Its speciﬁcations can
increase in tandem with extensions of the system.
While the modiﬁcation made by the change selection mes-
sage script was applied to element set Edata, it is possible to
modify element set Eclass. If a class is created dynamically
and its semantics deﬁned, it means that the GLDS speciﬁca-
tions are dynamically extended. A serious limitation of the
current dialog script execution engines is that the semantics
of classes is deﬁned only by code written in a programming
language (C++ or Erlang). Rich variations of Eclass elements
and a synthetic deﬁnition feature of an extended GLDS will
overcome this restriction in the future. We hope to imple-
ment frame-based and agent-based dialog controllers [2] that
cooperatively work with existing and extended DST/GLDS
speciﬁcations. We believe that this infrastructure might help
in the development of Minsky’s emotional models [3] by
using different types of dialog controllers and a polymorphic
application of the knowledge model.
V. RELATED WORK
Many natural language user interface systems have been
developed. The earliest system, Weizenbaum’s ELIZA [4], was
reported in 1966. It was equipped with a reply function that
repeated user messages with suitable pronouns substituted for
73
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-269-1
INTELLI 2013 : The Second International Conference on Intelligent Systems and Applications

pronouns. To some degree, it gave users the impression they
were conversing with a human psychiatrist. Colby’s PARRY
[5] acted as a psychiatric patient, and it was not required
to reply with answers that were correct for its users. This
showed that it is possible to implement a natural language user
interface system that cannot be distinguished from a human
psychiatric patient. The CONVERSE agent [5] integrated a
commercial parser, query interface for accessing a parse tree,
large-scale natural language resources like Wordnet, and other
natural language processing technologies commonly available
in 1997. It achieved a high percentage of completion, and won
the 1997 annual medal of the Loebner prize [6]. Wallace’s AL-
ICE (http://alicebot.org/articles/wallace/dont.html [retrieved:
February 2013]) promoted the XML-based script description
language AIML. Wallace developed the AIML processor and
the ALICE subset knowledge data in the AIML format as
open source resources, and several chat bots [7], [8] have
subsequently been developed based on these ALICE resources.
ALICE has won the annual medal of the Loebner prize three
times. While AIML provides one of the most customizable
notations for natural language user interfaces, dialog scripts
can only be authorized manually or externally. GLDS and its
execution engines provide a dialog script notation, which has
an ability to express the dialog scripts for authorizing other
dialog scripts.
A semantic network is a well known graph structure hav-
ing speciﬁc semantics. Grifﬁth [9] deﬁned it universally by
dividing the net into a conveying net and an abstract net.
The conveying semantic network corresponds to the whole
data structure ADGF that represents the expression system.
The abstract semantic network corresponds to the element set
Edata that represents the meanings of graph data. Grifﬁth
had no intention of extending the description capability of
the abstract net, which is often the case, because semantic
networks are used in natural language processing, where the
semantics is considered to be stable. GLDS and its framework
uses the net to represent dialog scripts, so we extended the
net to be as extensible and ﬂexible as an augmented semantic
network [1].
Graph-based network data are commonly distributed using
the resource description framework (RDF), which is a fun-
damental component of Semantic Web technology. In prin-
ciple, ADG graph data can be expressed by the RDF. It is
additionally required to provide a semantic basis like our
GLDS framework to express GLDS script data using the RDF.
The OWL Web Ontology Language can provide such a basis
that partially represents the GLDS semantics. GLDS scripts
expressed by OWL are convenient to port. It becomes more
convenient to assume syntactical consistency if the scripts are
expressed by OWL-DL, which is a subset of OWL, and can
be processed by description logic (DL) [10] inference engines.
Ontology extending issues are discussed in the linked data
community [11] and large-scale ontology development [12].
Results of these studies might be used to improve the design
of our framework.
VI. CONCLUSION AND FUTURE WORK
To advance the research being done on natural language
user interface systems, we have focused on methodologies that
enable dialog script execution engines to preserve the con-
sistency of their dialog scripts while using different types of
dialog control methods simultaneously. We have also focused
on technologies for implementing script editing functions by
dialog scripts. We proposed and implemented a script de-
scription language (GLDS) and its framework that meet these
requirements. We developed two versions of GLDS execution
engines. A GLDS dialog script example was presented to show
that a script editing function can be represented by GLDS2
and executed successfully. Because GLDS and its engines have
self-extending ﬂexibility and ability to execute several versions
of scripting languages, they increase the opportunity for end-
users to accumulate and share a large amount of script data.
This framework has afﬁnity for RDF-represented knowledge
bases that increase their content rapidly via the semantic
web and linked data activities. Integrating such knowledge
bases and dialog scripts to increase the intelligence of natural
language user interfaces is left for future work.
REFERENCES
[1] K. Nitta, “Building an autopoietic knowledge structure for natural
language conversational agents,” in RuleML ’08: Proceedings of the
International Symposium on Rule Representation, Interchange and Rea-
soning on the Web.
Berlin, Heidelberg: Springer-Verlag, 2008, pp.
211–218.
[2] M. F. McTear, “Spoken dialogue technology: enabling the conversational
user interface,” ACM Comput. Surv., vol. 34, no. 1, 2002, pp. 90–169.
[3] M. Minsky, The Emotion Machine: Commonsense Thinking, Artiﬁcial
Intelligence, and the Future of the Human Mind.
Simon & Schuster,
2006.
[4] J. Weizenbaum, “ELIZA — a computer program for the study of natural
language communication between man and machine,” Commun. ACM,
vol. 9, no. 1, 1966, pp. 36–45.
[5] Y. Wilks, Machine Conversations.
Norwell, MA, USA: Kluwer
Academic Publishers, 1999.
[6] H. G. Loebner, “In response,” Commun. ACM, vol. 37, no. 6, 1994, pp.
79–82.
[7] A. M. Galvao, F. A. Barros, A. M. M. Neves, and G. L. Ramalho,
“Persona-aiml: An architecture developing chatterbots with personality,”
in AAMAS ’04: Proceedings of the Third International Joint Conference
on Autonomous Agents and Multiagent Systems.
Washington, DC,
USA: IEEE Computer Society, 2004, pp. 1266–1267.
[8] G. O. Sing, K. W. Wong, C. C. Fung, and A. Depickere, “Towards a more
natural and intelligent interface with embodied conversation agent,”
in CyberGames ’06: Proceedings of the 2006 international conference
on Game research and development.
Murdoch University, Australia,
Australia: Murdoch University, 2006, pp. 177–183.
[9] R. L. Grifﬁth, “Three principles of representation for semantic net-
works,” ACM Trans. Database Syst., vol. 7, no. 3, 1982, pp. 417–442.
[10] F. Baader, D. Calvanese, D. L. McGuinness, D. Nardi, and P. F. Patel-
Schneider, Eds., The description logic handbook: theory, implementa-
tion, and applications.
New York, NY, USA: Cambridge University
Press, 2003.
[11] C. Bizer, T. Heath, K. Idehen, and T. Berners-Lee, “Linked data on the
web (ldow2008),” in Proceedings of the 17th international conference
on World Wide Web, ser. WWW ’08.
New York, NY, USA: ACM,
2008, pp. 1265–1266.
[12] J. Hoffart, F. M. Suchanek, K. Berberich, E. Lewis-Kelham, G. de Melo,
and G. Weikum, “Yago2: exploring and querying world knowledge in
time, space, context, and many languages,” in Proceedings of the 20th
international conference companion on World wide web, ser. WWW
’11.
New York, NY, USA: ACM, 2011, pp. 229–232.
74
Copyright (c) IARIA, 2013.     ISBN:  978-1-61208-269-1
INTELLI 2013 : The Second International Conference on Intelligent Systems and Applications

