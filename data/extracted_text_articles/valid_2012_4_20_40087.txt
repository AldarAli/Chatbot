Diagnosability Analysis for Self-observed
Distributed Discrete Event Systems
Lina YE and Philippe DAGUE
Univ Paris-Sud, LRI, CNRS
Email: lina.ye@lri.fr, philippe.dague@lri.fr
Abstract—Diagnosability is a crucial property that determines,
at design stage, how accurate any diagnosis algorithm can be
on a partially observable system and, thus, has a signiﬁcant
impact on the performance and reliability of complex systems.
Most existing approaches assumed that observable events in the
system are globally observed. But, sometimes, it is not possible
to obtain global information. Thus, a recent work has proposed
a new framework to check diagnosability in a system where each
component can only observe its own observable events to keep
the internal structure private in terms of observations. However,
the authors implicitly assume that local paths in components
can be exhaustively enumerated, which is not true in a general
case where there are embedded cycles. In this paper, we get
some new results about diagnosability in such a system, i.e.,
what we call joint diagnosability in a self-observed distributed
system. First, we prove the undecidability of joint diagnosability
with unobservable communication events by reducing Post’s
Correspondence Problem to an observation problem. Then, we
propose an algorithm to check a sufﬁcient but not necessary
condition of joint diagnosability. Finally, we brieﬂy discuss about
the decidable case with observable communication events.
Index Terms—diagnosis; joint diagnosability; ﬁnite state ma-
chine.
I. INTRODUCTION
Over the latest decades, with more performance require-
ments imposed on the complex systems, they are subject to
more errors. However, it is unrealistic to detect faults manually
for such systems. Automated diagnosis mechanisms are thus
required for large distributed applications. Generally speaking,
diagnosis reasoning aims at detecting possible faults explain-
ing the observations. The efﬁciency of diagnosis reasoning
depends on system diagnosability, which is a crucial property
that determines at design stage how accurate any diagnosis
algorithm can be on a partially observable system. The systems
we discuss here are Discrete Event Systems (DES).
Some existing works analyzed diagnosability in a central-
ized way ([1], [2], etc.), i.e., a monolithic model of a given sys-
tem is hypothesized, which is unrealistic due to combinatorial
explosion of state space. This is why very recently distributed
approaches began to be investigated ([3], [4], etc.), relying
on local objects. However, all these approaches assumed that
observable events in the system are globally observed. But
sometimes it is not possible to obtain global information. Then,
Ye et al. [5] has proposed a new framework to check diagnos-
ability in a system where each component can only observe its
own observable events to keep the internal structure private in
terms of observations. However, the authors implicitly assume
that local paths can be exhaustively enumerated, which is not
true in a general case where there are embedded cycles. In this
paper, we generalize this work to get some new results about
the diagnosability of what we call self-observed distributed
systems, where observable events can only be observed by
their own component.
We make several contributions in this paper. First, we extend
diagnosability of globally observed systems to what we call
joint diagnosability of self-observed systems and then to prove
its undecidability with unobservable communication events.
Secondly, we propose an algorithm for testing a sufﬁcient
condition, where we obtain pairs of local trajectories in the
faulty component, such that for each pair only one trajectory
contains the fault but both have the same observations, and
then check their global consistency through two phases. We
provide the proof that it is a sufﬁcient condition and point
out why it is not necessary. Thirdly, the decidable case where
communication events are observable is discussed.
II. PRELIMINARIES
In this section, we model self-observed distributed DES and
then recall joint diagnosability features [5].
We consider a self-observed distributed DES composed of a
set of components {G1, G2,..., Gn} that communicate by com-
munication events, where each component can only observe
its own observable events. Such a system is modeled by a set
of ﬁnite state machines (FSM), each one representing the local
model of one component. The local model of a component Gi
is a FSM, denoted by Gi = (Qi, Σi, δi, q0
i ), where Qi is the
set of states; Σi is the set of events; δi ⊆ Qi×Σi×Qi is the set
of transitions; and q0
i is the initial state. The set of events Σi is
partitioned into four subsets: Σio, the set of locally observable
events that can be observed only by their own component Gi;
Σiu, the set of unobservable normal events; Σif , the set of
unobservable fault events; and Σic, the set of communication
events shared by at least one other component, which are the
only shared events between components. Figure 1 depicts a
self-observed distributed system with two components: G1
(left) and G2 (right), where the events Oi denote locally
observable events, the event F denotes an unobservable fault
event, the events Ui denote unobservable normal events and
the events Ci denote communication events.
We denote the synchronized FSM of components G1, ..., Gn
by ∥(G1, ..., Gn), where the synchronized events are the
shared events between components and any one of them
93
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

X0
X1
X2
X3
X4
X5
O1
C1
O1
F
U1
O2
O1
C2
O2
Y0
Y2
Y3
Y4
O3
O3
C1
O4
O5
C2
X6
C2
Y1
U2
Fig. 1.
A system with two components G1 (left) and G2 (right).
always occurs simultaneously in all components that deﬁne it.
The global model of the entire system is implicitly deﬁned as
the synchronized FSM of all components based on their shared
events, i.e., communication events. However, the global model
will not be calculated since in a self-observed distributed
system, the global occurrence order of observable events is
not accessible. In the following, we call subsystem of G
the synchronization of a subset of components of G, i.e.,
∥(Gs1, ..., Gsm), where {s1, ...sm} ⊆ {1, ...n}. One compo-
nent or the entire system can be considered as a subsystem.
Given a system model G = (Q, Σ, δ, q0), the set of words
produced by the FSM G is a preﬁx-closed language L(G)
that describes the normal and faulty behaviors of the system.
Formally, L(G) = {s ∈ Σ∗|∃q ∈ Q, (q0, s, q) ∈ δ}, where the
transition δ has been extended from events to words. In the
following, we call a word of L(G) also a trajectory in the sys-
tem G and a sequence q0σ0q1σ1... a path in G, where σ0σ1...
is a trajectory and for all i, we have (qi, σi, qi+1) ∈ δ. Given
s ∈ L(G), we denote the post-language of L(G) after s by
L(G)/s and denote the projection of s to observable events of
G (resp. Gi) by P(s) (resp. Pi(s)). We adopt the assumption
in [3], i.e., the projection of the global language on each local
model is observable live, i.e., there is no unobservable cycle
in any component. For the sake of simplicity, our approach is
shown for only one fault, which can be extended to the case
with multiple faults by running one time for each fault. Next
we rephrase reconstructibility introduced in [7].
Deﬁnition 1: (Reconstructibility). Given a system G that is
composed of several subsystems, i.e., G = ∥(Gs1, ..., Gsm),
a set of trajectories in these subsystems is said to be recon-
structible with respect to G if it is obtained by projection on
this set of subsystems of a trajectory in G.
If there is no common communication event between two
subsystems, then any trajectory in one subsystem and any one
in the other subsystem are reconstructible.
For the sake of consistency, now we rename what is called
cooperative diagnosability in [5] as joint diagnosability. We
denote a trajectory ending with the fault f by sf.
Deﬁnition 2: (Joint diagnosability). A fault f is jointly
diagnosable in a self-observed distributed system G with
components {G1, ...Gn}, iff
∃k ∈ N, ∀sf ∈ L(G), ∀t ∈ L(G)/sf, (∀i ∈
{1, ..., n}, |Pi(t)| ≥ k)⇒ (∀p ∈ L(G)
(∀i ∈ {1, ..., n}, Pi(p) = Pi(sf.t)) ⇒ f ∈ p).
Joint diagnosability of f means that for each faulty trajectory
sf in G, for each extension t with enough locally observable
events in all components, every trajectory p in G that is
equivalent to sf.t for local observations in each component
should contain in it f. In other words, the fault can be detected
after ﬁnite non bounded trajectory prolongation in at least
S0
O1
C2
SFK+1
C1
SFK
CK
F
C1
Z1
C2
Z2
CK
ZK
S1
S2
SK
SK+1
O1
O1
C1
C2
CK
C1
V1
C2
V2
CK
VK
T0
T1
O2
T2
A2
TK+1
A1
TK
AK
TK+2
O2
A1
C1
A2
C2
AK
CK
S 1
F
SF2
SFK+2
SK+2
Fig. 2. A system with two components G1 (top) and G2 (bottom) for proving
undecidability of joint diagnosability.
one component. In a self-observed system, we call a pair of
trajectories p and p′ satisfying the three conditions a (global)
indeterminate pair: 1) p contains f and p′ does not; 2) p
has arbitrarily long local observations in all components after
the occurrence of f; 3) ∀i ∈ {1, ..., n}, Pi(p) = Pi(p′). Here
arbitrarily long local observations can be considered as inﬁnite
local observations. Now we have the following theorem [5].
Theorem 1: Given a self-observed distributed system G, a
fault f is jointly diagnosable in G iff there is no (global)
indeterminate pair in G.
III. UNDECIDABLE CASE
To discuss about joint diagnosability, we consider two cases:
communication events being unobservable and observable. We
ﬁrst consider the general case, i.e., communication events
being unobservable.
Theorem 1 implies that checking joint diagnosability boils
down to check the existence of indeterminate pairs that
witnesses non joint diagnosability. Inspired from [6], where
undecidability of joint observability is proved by reducing
the Post’s Correspondence Problem (PCP) to an observation
problem, we discuss ﬁrst about whether joint diagnosability is
decidable or not.
For the sake of simplicity, we give now a simpliﬁed proof
for undecidability of joint diagnosability.
Theorem 2: Given a self-observed distributed system where
communication events are unobservable, checking joint diag-
nosability of a given fault is undecidable.
Proof:
1) PCP: given a ﬁnite alphabet Σ, two sets of words
v1, v2, ..., vk and z1, z2, ..., zk over Σ, then a solution to PCP is
a sequence of indices (im)1≤m≤n with n ≥ 1 and 1 ≤ im ≤ k
for all m such that vi1vi2...vin = zi1zi2...zin.
2) Now consider the example depicted in Figure 2, where
the system is composed of two components G1 and G2. In
G1, each one of V i, i ∈ {1, ..., k}, and each one of Zi, i ∈
{1, ..., k}, denotes a sequence of observable events all different
from O1, C1, ..., Ck are unobservable communication events,
F denotes a fault event and O1 is an observable event. In G2,
each one of Ai, i ∈ {1, ..., k}, denotes an observable event dif-
ferent from O2, C1, ..., Ck are unobservable communication
events and O2 is an observable event. Then the observations
in G1 can be described as V i1V i2...V inO1∗ without fault or
94
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

Zi1Zi2...ZinO1∗ with fault, where ∀ij, j ∈ {1, ..., n}, ij ∈
{1, ..., k}. In G2, the observations are Ai1Ai2...AinO2∗. In
this system, the occurrence of the fault can be conﬁrmed by
the observation of O1.
3) Without the observation of O1, the local observations are
wO1+ for G1 and Ai1Ai2...AinO2∗ for G2, where w =
V i1V i2...V in when there is no fault or w = Zi1Zi2...Zin
when there is a fault. Clearly, if PCP has a solution, i.e.,
∃(im)1≤m≤n such that V i1V i2...V in = Zi1Zi2...Zin, we
have two trajectories p and p′ such that the observations of p in
G1 are V i1V i2...V inO1+, which is a trajectory without fault,
while the observations of p′ in G1 are Zi1Zi2...ZinO1+,
which is a trajectory with a fault. And both p and p′ have
the same observations for G2, i.e., Ai1Ai2...AinO2∗. Thus
we get that p and p′ have the same observations for both G1
and G2, i.e., V i1V i2...V inO1+=Zi1Zi2...ZinO1+ for G1
and Ai1Ai2...AinO2∗ for G2, then the fault is not jointly
diagnosable.
4)
On
the
other
hand,
if
the
fault
is
not
jointly
diagnosable,
then
we
obtain
at
least
one
indetermi-
nate
pair,
denoted
by
p
and
p′
such
that
the
pro-
jection
of
p
on
G1
is
Ci1V i1Ci2V i2...CinV inO1∗,
on G2
is Ai1Ci1Ai2Ci2...AinCinO2∗
and that of
p′
on
G1
is
Cj1Zj1Cj2Zj2...CjmZjmFO1∗
and
on
G2
is Aj1Cj1Aj2Cj2...AjmCjmO2∗. From the fact that p
and
p′
have
the
same
observations
for
G2,
we
get
Ai1Ai2...AinO2∗ = Aj1Aj2...AjmO2∗ and thus we have
m = n and i1 = j1, ..., in = jn. And then from the same
observations of p and p′ on G1, we get V i1V i2...V inO1∗ =
Zi1Zi2...ZinO1∗, i.e., V i1V i2...V in = Zi1Zi2...Zin, which
means that there is a solution for PCP.
5) The above proves that the existence of a solution for PCP
is equivalent to that of a fault being not jointly diagnosable.
Since PCP is an undecidable problem, then checking joint
diagnosability is undecidable.
There are two major differences between joint diagnosabil-
ity in our framework and joint observability in [6]. One is that
the former assumes that local observers are attached to local
components that are synchronized by common communication
events to get a global model while the latter separates arbi-
trarily the observable events in the global model into several
sets. The other one is that joint diagnosability consists in
separating inﬁnite trajectories while joint observability consists
in separating ﬁnite ones. Thus, if any communication event
is assumed to be unobservable, joint diagnosability checking
boils down to inﬁnite PCP. But this one has also been proved
to be undecidable [8], which gives the result.
IV. SUFFICIENT ALGORITHM
We have proved that joint diagnosability with unobservable
communication events is undecidable. We can nevertheless
propose an algorithm to test a sufﬁcient condition, which is
still quite useful in some circumstances. We ﬁrst construct the
local diagnoser from a given local model to show fault infor-
mation for any local trajectory. Then, we show how to build a
structure called local twin plant to obtain original information
about indeterminate pairs (also called local indeterminate pairs
in the following), based on the local diagnoser. The next step
is to check the global consistency, i.e., to check whether the
local indeterminate pairs can be extended into (global) indeter-
minate pairs, whose existence testiﬁes non joint diagnosability.
Actually, our algorithm remains trivially applicable when the
assumption of unobservability of communication events is
partially relaxed, i.e., in the most general case where some
communication events are observable and others unobservable.
A. Original diagnosability information
To check the existence of indeterminate pairs, in the dis-
tributed framework, we use the structure called local twin
plant deﬁned in [2]. In particular, the considered fault is
assumed to only occur in one component, denoted by Gf.
Then the local twin plant for Gf contains original information
of indeterminate pairs: actually this twin plant is a FSM that
compares every pair of local trajectories to search for the pairs
with the same arbitrarily long local observations, but exactly
one of the two containing a fault, which are local indeterminate
pairs. First, we deﬁne delay closure operation with respect to
a subset Σd of Σ to preserve only the information about the
events in Σd.
Deﬁnition 3: (Delay
Closure).
Given
a
FSM
G
=
(Q, Σ, δ, q0), its delay closure with respect to Σd ⊆ Σ is
∁Σd(G) = (Q, Σd, δd, q0) where (q, σ, q′) ∈ δd iff ∃s ∈
(Σ\Σd)∗, (q, sσ, q′) ∈ δ.
We now describe how to construct the local diagnoser of a
given component, based on which we build the local twin
plant. Given a local model, we get a modiﬁed one by attaching
fault label, denoted by l ∈ {N, F}, where N for normal and F
for fault, to each state. In other words, before the occurrence
of the fault, each state is labeled with label N and, after its
occurrence, with label F.
Deﬁnition 4: (Local diagnoser). Given a local model Gi, its
local diagnoser Di is obtained by operating the delay closure
with respect to the set of communication events and observable
events on the modiﬁed model: Di = ∁Σio∪Σic(Gm
i ), where
Gm
i
is the modiﬁed version of Gi.
Based on the local diagnoser, the corresponding local twin
plant is obtained by synchronizing the local diagnoser with
itself based on the locally observable events, allowing one to
obtain all pairs of local trajectories with the same observations
to search for local indeterminate pairs. To simplify this syn-
chronization, the two identical local diagnosers, denoted by
Dl
i (left instance) and Dr
i (right instance), can be reduced as
follows: Dl
i is obtained by retaining only paths with at least
one fault cycle and Dr
i is obtained by retaining only paths with
at least one non-fault cycle. This reduction keeps all original
diagnosability information since what we are interested in are
only local indeterminate pairs. However, this reduction is only
applicable for the local diagnoser of the faulty component
Gf; for other components, the local twin plant is obtained
by synchronizing the non reduced left instance and the non
reduced right instance since there is no fault information. Since
this synchronization is based on observable events Σio, the
95
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

X0 N
X4 N
X2 N
X1 N
X3 F
O1
L:C1
O1
O1
O2
L:C2
X0 N
X1 N
X5 N
X3 N
O1
O1
R:C2
R:C1
O2
X0 N
X0 N
X0 N
X1 N
X4 N
X5 N
X2 N
X5 N
X2 N
X3 N
X3 F
X3 N
X1 N
X0 N
X2 N
X5 N
X2 N
X3 N
X3 F
X3 N
O1
O1
R:C1
L:C2
R:C2
R:C2
L:C1
O2
O1
O1
O1
Fig. 3.
Two reduced instances of the diagnoser for G1 (top) and part of the
corresponding local twin plant (bottom).
non-synchronized events are distinguished by the preﬁx L or
R: in Dl
i (Dr
i ), each communication event c ∈ Σic from Di is
renamed by L : c (R : c). The names of all locally observable
events are left unchanged.
Deﬁnition 5: (Local twin plant). Given a local diagnoser
Di for the component Gi, the corresponding local twin plant
is a FSM, denoted by Ti = Dl
i∥Dr
i , where the synchronized
events are locally observable events in Gi.
Each state of a local twin plant is a pair of local diagnoser
states providing two possible diagnoses with the same local
observations. Given a twin plant state ((ql, ll)(qr, lr)), if the
considered fault f ∈ ll ∪ lr but f /∈ ll ∩ lr, which means that
the occurrence of f is not certain up to this state, then this state
is called an ambiguous state with respect to the fault f. An
ambiguous state cycle is a cycle containing only ambiguous
states. In a local twin plant, if a path contains an ambiguous
state cycle with at least one locally observable event, then
it is called a local indeterminate path, which corresponds
to a local indeterminate pair. Note that local indeterminate
paths contain original diagnosability information and can be
obtained only in the local twin plant of the component Gf.
If a local indeterminate pair can be extended into a global
indeterminate pair, then we say that its corresponding local
indeterminate path is globally consistent. Figure 3 shows the
left and right instances of the local diagnoser for the faulty
component G1 of Figure 1 (top) as well as a part of the
corresponding local twin plant (bottom). Clearly, in the local
twin plant, we have local indeterminate paths since they have
ambiguous state cycles with observable events.
B. Global consistency checking
Joint diagnosability veriﬁcation consists in checking the
existence of globally consistent local indeterminate paths,
whose existence proves non joint diagnosability. To do this, we
have to check the global consistency of the corresponding left
trajectories of the local indeterminate paths in the local twin
plants as well as that of their corresponding right trajectories,
shortly called left consistency checking and right consistency
checking.
Deﬁnition 6: (Left
(Right)
consistent
plant).
Given
a
subsystem GS composed of components Gi1, ..., Gim and
their corresponding local twin plants Ti1, ..., Tim, to obtain a
left (right) consistent plant with respect to the subsystem GS,
denoted by T l
f (T r
f ), we perform the following two steps:
1) Distinguish right (left) communication events between
local twin plants by renaming them with the preﬁx of
component ID. For example, R:C2 (L:C2) in the local twin
plant of G2 is renamed as G2:R:C2 (G2:L:C2).
X0 N
X0 N
X0 N
X1 N
X4 N
X5 N
X2 N
X5 N
X2 N
X3 N
X3 F
X3 N
X1 N
X0 N
X2 N
X5 N
X2 N
X3 N
X3 F
X3 N
O1
O1
G1:R:C1
L:C2
G1:R:C2
G1:R:C2
L:C1
O2
O1
O1
O1
Y0 N
Y0 N
Y3 N
Y0 N
Y2 N
Y1 N
Y2 N
Y2 N
Y4 N
Y4 N
Y2 N
Y4 N
L:C1
O5
G2:R:C2
O4
O3
L:C2
O5
Z0
Z1
Z2
Z3
Z4
Z5
Z6
Z7
Z8
Z9
Z10
Z11
Z12
Z13
L:C1
O1
O3
G1:R:C2
O5
O1
O1
L:C2
O4
O2
G1:R:C1
G1:R:C2
G2:R:C2
O5
O1, O5
O5
O1, O5
Fig. 4.
Part of the renamed local twin plants for G1 and G2 (top) and part
of the left consistent plant T l
f (bottom).
2) Synchronize the renamed local twin plants with the
synchronized
events
being
the
common
left
(right)
communication events, which works because observable
events do not intersect between components and non-
synchronized
right
(left)
communication
events
are
distinguished by the preﬁx of component ID.
From deﬁnition 1, we know that in the left (right) consistent
plant with respect to a subsystem GS, each path p corresponds
to a set of paths pi1, ..., pim in the local twin plants of all
components in GS such that the set of left (right) trajectories
of pi1, ..., pim are reconstructible with respect to GS. For our
example, the bottom part of Figure 4 shows a part of the left
consistent plant T l
f, which is obtained by synchronizing the
renamed local twin plant of G1 and that of G2 (top part of
Figure 4) based on the common left communication events.
C. Algorithm
Algorithm 1 presents the procedure to verify a sufﬁcient
condition of joint diagnosability. As shown in the pseudo-
code, algorithm 1 performs as follows. Given the input as
the set of component models, the fault F that may occur
in the component Gf, we initialize the parameters as empty,
i.e., Gl
S (Gr
S), the subsystem for the left (right) consistency
checking. The procedure of the algorithm can be separated
into two parts: left consistency checking (line 3-12) and right
consistency checking (line 13-24).
Left consistency checking begins with the local twin plant
construction of Gf, the subsystem Gl
S being now Gf (line
3-4). When both the left consistent plant T l
f with respect to
the current left subsystem Gl
S and DirectCC(G, Gl
S) are not
empty (line 5), where DirectCC(G, Gl
S) is the set of directly
connected components to Gl
S (a directly connected component
being one sharing at least one common communication event
with the subsystem), the algorithm repeatedly performs the
following steps to further check left consistency.
1) Select one directly connected component Gi to the subsys-
tem Gl
S and construct its local twin plant Ti (line 6-7).
2) Synchronize T l
f with Ti to obtain left consistent plant for
this extended subsystem based on common left communication
events (line 8). To do this, non-synchronized right communica-
tion events are distinguished by the preﬁx of component ID.
3) Update the subsystem Gl
S by adding Gi and reduce the
newly obtained T l
f by retaining only paths with ambiguous
state cycles containing observable events for all components
in Gl
S (line 9-10).
96
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

Algorithm 1 Sufﬁcient algorithm
1: INPUT: the system model G = (G1, ..., Gn); the fault F
and the faulty component Gf
2: Initializations: Gl
S ← ∅ (subsystem for left consistency
checking); Gr
S ← ∅ (subsystem for right consistency
checking)
3: T l
f ← ConstructLTP(Gf)
4: Gl
S ← Gf
5: while T l
f ̸= ∅ and DirectCC(G, Gl
S) ̸= ∅ do
6:
Gi ← SelectDirectCC(G, Gl
S)
7:
Ti ← ConstructLTP(Gi)
8:
T l
f ← T l
f∥Ti
9:
Gl
S ← Add(Gl
S, Gi)
10:
T l
f ← RetainConsisPaths(T l
f)
11: if T l
f = ∅ then
12:
return ”F is jointly diagnosable in G”
13: else
14:
T r
f ← AbstractRight(Gf, T l
f)
15:
Gr
S ← Gf
16:
while T r
f ̸= ∅ and Gl
S ̸= Gr
S do
17:
Gi ← SelectDirectCC(Gl
S, Gr
S)
18:
T r
f ← T r
f ∥AbstractRight(Gi, T l
f)
19:
Gr
S ← Add(Gr
S, Gi)
20:
T r
f ← RetainConsisPaths(T r
f )
21:
if T r
f = ∅ then
22:
return ”F is jointly diagnosable in G”
23:
else
24:
return ”Joint diagnosability cannot be determined”
If the left consistent plant T l
f is empty, then there is no
local indeterminate path that corresponds to a set of paths
in the local twin plants of all components in the subsystem
such that their left trajectories are reconstructible (deﬁnition
1), which implies the non existence of a globally consistent
local indeterminate path. In this case joint diagnosability
information is returned (line 11-12). Otherwise, if T l
f is not
empty (line 13), then we proceed to check right consistency of
the corresponding paths in T l
f that have been already veriﬁed
to be left consistent in the whole system.
Right consistency checking begins with the function
AbstractRight(Gf, T l
f) (line 14), which performs delay
closure with respect to right communication events and ob-
servable events of Gf. Then the subsystem Gr
S is assigned
as Gf (line 15). When the right consistent plant T r
f for the
current right subsystem Gr
S is not empty and Gl
S ̸= Gr
S (line
16), we repeatedly perform the following steps to check right
consistency in an extended subsystem (since left consistency
checking does explore all connected components, for right
consistency checking we only consider the subsystem Gl
S
instead of the whole system).
1) Select a directly connected component Gi to Gr
S from Gl
S
(line 17).
2) Perform the function AbstractRight(Gi, T l
f), which has
been described as above, and then synchronize with T r
f based
on the common right communication events (line 18). To do
this, we rename the right communication events by removing
the preﬁx of component ID, e.g., Gi:R:C2 renamed as R:C2.
3) Update the subsystem Gr
S by adding Gi and reduce the
newly obtained T r
f by retaining only paths with ambiguous
state cycles containing observable events for all components
in Gr
S (line 19-20).
If the right consistent plant T r
f is empty, then there is no
local indeterminate path that corresponds to a set of paths
in the local twin plants such that their left trajectories and
right trajectories are reconstructible respectively, i.e., there is
no globally consistent local indeterminate path. In this case,
the algorithm returns joint diagnosability information (line
21-22). Otherwise, if T r
f is not empty, we cannot determine
whether the fault is jointly diagnosable or not. Then the
algorithm returns indetermination information (line 23-24). In
other words, empty left consistent plant T l
f or empty right
consistent plant T r
f is a sufﬁcient condition but not a necessary
condition of joint diagnosability.
Theorem 3: In algorithm 1, if the left consistent plant T l
f or
the right consistent plant T r
f is empty, then the fault is jointly
diagnosable, but the reverse is not true.
Proof: :
(⇒) Suppose that T l
f or T r
f is empty and that the fault
is not jointly diagnosable. From non joint diagnosability,
it follows that there exists at least one globally consistent
local indeterminate path. Since global consistency of a local
indeterminate path implies both left consistency and right
consistency, from algorithm 1 we know that, after left and
right consistency checking, this local indeterminate path must
correspond to a path both in T l
f and in T r
f . Thus neither T l
f
nor T r
f is empty, which contradicts the assumption.
(⇍) Now we explain why non emptiness of both T l
f and
T r
f does not necessarily imply that the fault is not jointly
diagnosable. Suppose that T l
f is not empty and that it contains
two paths, denoted by ρ1 and ρ2, corresponding to two
local indeterminate paths. ρ1 corresponds to a set of paths
ρ1
i , 1 ≤ i ≤ n in the local twin plants of all components
and ρ2 corresponds to a set of paths ρ2
i , 1 ≤ i ≤ n in all
local twin plants. Now suppose that the right trajectories of
the set of paths ρ1
i , 1 ≤ i ≤ n are not reconstructible and the
same for that of the set of paths ρ2
i , 1 ≤ i ≤ n. It follows
that the two local indeterminate paths cannot be extended into
global indeterminate pairs and thus are not globally consistent.
Then we further suppose that the right trajectories of the set
of paths ρ1
1, ..., ρ1
n−1, ρ2
n are reconstructible or the same for
the set of paths ρ2
1, ..., ρ2
n−1, ρ1
n. In this case, from algorithm
1, it follows that ﬁnally the right consistent plant T r
f is not
empty. Now both T l
f and T r
f are not empty but there is no
globally consistent local indeterminate paths, i.e., the fault is
jointly diagnosable.
Now, we illustrate on our example the fact that the
condition is not necessary. The top part of Figure 5 shows
the results of performing delay closure with respect to
right communication events and observable events both for
97
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

Z0
Z2
Z4
Z6
Z7
Z8
Z11
Z13
O1
G1:R:C2
O1
O2
G1:R:C1
G1:R:C2
O1
O1
Z0
Z3
Z5
Z9
Z12
O3
O5
O4
G2:R:C2
O5
O5
O1
Z0
Z0
Z2
Z0
Z2
Z9
Z4
Z12
O1
O4
R:C2
Z6
Z12
O1
O5
O1,O5
Fig. 5.
FSM after delay closure on the left consistent plant (Figure 4) for
G1 and G2 (top) and part of the right consistent plant (bottom).
G1 and G2 on the left consistent plant depicted in Figure
4. Then, to check right consistency, we rename again the
right communication events by removing the component
ID such that they can be synchronized. The bottom part of
Figure 5 shows a part of the right consistent plant, which
is not empty. Now, both left and right consistent plants are
not empty, but this does not imply the existence of global
indeterminate pairs that witnesses non joint diagnosability.
Actually, the part of the left consistent plant depicted here
corresponds to two local indeterminate pairs in G1 with
their corresponding left consistent pairs in G2, i.e., one local
indeterminate pair is ((C1.O1.F.O1∗), (O1.C2.O1∗)) in G1
with its left consistent pair ((C1.O3.O5∗), (O3.U2.O5∗))
in
G2
and
the
other
local
indeterminate
pair
is
((O2.U1.C2.F.O1∗), (C1.O2.C2.O1∗))
in
G1
with
its
left
consistent
pair
((O4.C2.O5∗), (O4.C2.O5∗))
in
G2.
While
the
right
consistent
plant
shown
here
corresponds to one local indeterminate pair in G1, which is
((C1.O1.F.O1∗), (O1.C2.O1∗)), with its right consistent
pair in G2, i.e., ((O4.C2.O5∗), (O4.C2.O5∗)). Thus, we
can see that the same local indeterminate pair does not
correspond to the same consistent pair in G2 in the left
consistent plant and in the right consistent plant, which means
that this local indeterminate pair cannot be extended into a
global indeterminate pair. Our algorithm gives indeterminate
information for joint diagnosable systems that satisfy the
following condition: for any set of paths including one path
in the local twin plant of each non faulty component and one
local indeterminate path in that for faulty component, if they
are left consistent and right consistent respectively, then their
corresponding local trajectories in the components cannot
constitute an indeterminate pair through synchronization. Our
illustrated example is quite tricky to show the possibility of
indeterminate decision given by our algorithm for a joint
diagnosable system. However, in reality, a system satisfying
the above condition is quite rare and thus this algorithm can
be applicable for a large number of complex systems.
V. DECIDABLE CASE
We have proved the undecidability of joint diagnosability
with unobservable communication events. If we assume their
observability, then this problem becomes decidable. Because
when any communication event is observable, in the local twin
plant, we obtain all pairs of local trajectories with the same
observations, including the same observable communication
events. Thus, each path in the local twin plant corresponds to
a pair of local trajectories with the same sequence of com-
munication events. It follows that, during global consistency
checking, the separate checkings for left and right consistency
becomes now only one checking. While in algorithm 1, the
checking into two separate phases is the reason why it gives
only a sufﬁcient but not necessary condition. Actually, the ob-
servability of communication events makes joint diagnosability
equivalent to classical diagnosability since only one checking
for global consistency implies the same global occurrence
order of observations for global indeterminate pairs.
VI. CONCLUSION AND FUTURE WORK
In this paper, we consider self-observed distributed systems
where observable events can only be observed by their own
component and thus the distributed and private (w.r.t. obser-
vation) nature of real systems is taken into account. Then, we
prove the undecidability of joint diagnosability checking when
communication events are unobservable, before proposing an
algorithm to test a sufﬁcient condition. We start from local
indeterminate paths and then we check both in sequence left
consistency and right consistency. Due to the observation-
privacy, the global occurrence order of observable events
between different components is not known, which is taken
into account through constructing left and right consistent
plants separately. For computational complexity, as distributed
diagnosability approaches with globally observable events,
in the worst case, our algorithm has polynomial complexity
in the number of system states and exponential complexity
in the number of system components. But our approach is
more autonomous thanks to distributed observations. Then we
brieﬂy discuss the decidable case where communication events
are observable. There is a gap between these two cases as the
unobservable case is undecidable and the observable case is
decidable. Next interesting work is to investigate where is the
frontier between the two cases, i.e., to study the decidability of
joint diagnosability for partial observability of communication
events.
REFERENCES
[1] M. Sampath, R. Sengupta, S. Lafortune, K. Sinnamohideen, and
D. Teneketzis, “Diagnosability of discrete event systems,” in IEEE
Transactions on Automatic Control, 1995, pp. 40(9):1555–1575.
[2] S. Jiang, Z. Huang, V. Chandra, and R. Kumar, “A polynomial time algo-
rithm for diagnosability of discrete event systems,” in IEEE Transactions
on Automatic Control, 2001, pp. 46(8):1318–1321.
[3] Y. Pencol´e, “Diagnosability analysis of distributed discrete event sys-
tems,” in Proceedings of 16th European Conference on Articiﬁal Intelli-
gence ECAI’04, Valencia, Spain, August 2004, pp. 43–47.
[4] A. Schumann and Y. Pencol´e, “Scalable diagnosability checking of event-
driven systems,” in Proceedings of 20th International Joint Conference
on Artiﬁcial Intelligence IJCAI-07, Hyderabad, India, 2007, pp. 575–580.
[5] L. Ye and P. Dague, “Diagnosability analysis of discrete event systems
with autonomous components,” in Proceedings of 19th European Confer-
ence on Artiﬁcial Intelligence ECAI-10, Lisbon, Portugal, August 2010,
pp. 105–110.
[6] S. Tripakis, “Undecidable problems of decentralized observation and
control,” in 40th IEEE Conference on Decision and Control, Orlando,
Florida, December.
[7] R. Cori and Y. M´etivier, “Recognizable subsets of some partially abelian
monoids,” Theoretical Computer Science, vol. 35, pp. 179–189, 1985.
[8] V. Halava and T. Harju, “Undecidability of inﬁnite post correspondence
problem for instances of size 9,” Theoretical Informatics and Applica-
tions, vol. 40, pp. 551–557, 2006.
98
Copyright (c) IARIA, 2012.     ISBN:  978-1-61208-233-2
VALID 2012 : The Fourth International Conference on Advances in System Testing and Validation Lifecycle

