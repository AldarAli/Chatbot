227
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Versatile but Precise Semantics for Logic-Labelled Finite State Machines
Callum McColl
Vladimir Estivill-Castro
René Hexel
School of Information and Communication Technology
Griﬃth University, Nathan QLD 4111, Australia
callum.mccoll@griffithuni.edu.au
v.estivill-castro@griffith.edu.au
r.hexel@griffith.edu.au
Abstract—Logic-Labeled
Finite
State
Machines
(LLFSMs)
oﬀer
model-driven
software
development
(MDSD) while enabling correctness at a high level
due
to
their
well-deﬁned
semantics
that
enables
testing
as
well
as
formal
veriﬁcation.
While
this
combination of the three elements (MDSD, validation,
and veriﬁcation) results in more reliable behaviour of
software components, semantics is severely constrained
in several areas. Here, we oﬀer a framework that
allows ﬂexibility in execution semantics to suit speciﬁc
domains while maintaining rigour and the capability
to generate Kripke structures for formal veriﬁcation or
to execute corresponding monitoring or testing LLFSMs
for validation in a test-driven development framework.
Through the use of modern constructs that extend
the object-oriented paradigm, the framework is able
to deﬁne a set of semantics that enables versatile
approaches to LLFSM deﬁnition and execution, as well
as enabling functional programming constructs. This
vastly increases the versatility and usefulness of LLFSMs,
making them more adaptable to diﬀerent domains,
without sacriﬁcing the beneﬁts of executable models
and the ability to perform formal veriﬁcation.
Keywords–Logic-labelled
ﬁnite-state
machines;
Model-Driven
Engineering;
Real-Time
Systems;
Veriﬁcation; Validation.
I.
Introduction
We argue here that it should be possible to rapidly
and eﬃciently conﬁgure the semantics and Logic-Labelled
Finite State Machines (LLFSMs) constructs to provide de-
velopers with the freedom to adapt or tailor the system se-
mantics to their particular scenario. This paper shows that
we can enable such versatility. We provide the capacity to
instantiate new scheduling semantics with incarnations of
template methods and classes, while retaining the capacity
to generate corresponding Kripke structures for formal ver-
iﬁcation. The generated Kripke structures can be formally
veriﬁed with standard tools [1], such as NuSMV.
By following a limited, precise semantics that is based
on a synchronous concurrency model, LLFSM enable the de-
sign of software that can achieve high levels of complexity
and sophistication while guaranteeing deterministic exe-
cution and facilitating formal veriﬁcation [2]. The LLFSM
semantics speciﬁes precisely when variables (aﬀected by
sensors outside the system) are inspected as well as the
particular points in the execution of the software where
snapshots of the environment variables are taken [3].
However, this constrains the semantics of the executable
model to one speciﬁc frequency and pace, which limits
the expressiveness of the designer in a way that may not
be well-suited for a speciﬁc robotic or embedded target
system.
Therefore, our new framework removes the need to
adhere to the strict semantics currently implemented in
tools such as clfsm [3]. Importantly, we demonstrate that
maintain the ability to perform formal veriﬁcation. To this
end, we illustrate two areas, where we create abstractions
to the LLFSM semantics and show how instantiation of these
abstractions into concrete derivations maintain the ability
to perform formal veriﬁcation. We extend swiftfsm [4], a
framework for LLFSMs written in Swift, enabling formal
veriﬁcation, while allowing developers more freedom to
design, adapt and create new LLFSM models that suit
particular, application-speciﬁc use cases.
II.
Logic-Labelled Finite State Machines
Finite state machines are ubiquitous models of sys-
tem behaviour. Variants of ﬁnite-state machines appear
in many system modelling languages, most prominently
SysML [5] and UML [6], [7], [8]. Despite their widespread
use and penetration in model-driven software development,
the semantics of SysML [5] and UML [9] are ambiguous [10]
and restricted versions are oﬀered to create executable
models [11], real-time systems [12] or enable formal veriﬁ-
cation [13], [14]. Moreover, languages such as SysML and
UML have historically adopted the event-driven form of
ﬁnite-state machines inspired by Harel’s STATEMATE.
Unfortunately, event-driven systems cannot oﬀer a simple
semantics, as the possibility of concurrent event arrivals
(e.g., from the environment or other components), can
create unintended complexities emerging from subsystem
interaction. This issue is intrinsic to these types of ma-
chines, where a system is modelled as being in a ﬁnite
set S of states, and where transitions ‘immediately’ ﬁre
upon arrival of an event (more complexity usually re-
sults as event handling can itself ﬁre a series of resulting
events). The mathematical model of instantaneous (zero-
time) transition is rapidly discarded because “the software
actually consumes time when processing those events” [8,
Page 50].
An example of the event-driven approach is the Spec-
iﬁcation and Description Language (SDL) fomalised by
the ITU-T [15]. SDL allows the modelling of reactive
systems 1, and with SDL-RT [16], an extension to SDL,
1Later we highlight the distinction between event-driven systems,
reactive systems, and real-time system

228
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
the notation aims at modelling of real-time systems. SDL
(and SDL-RT) model a system as a set of asynchronously
executing ﬁnite state machines called processes. Each pro-
cess can communicate through the use of signals which
constitute communication channels between processes. A
sender does not wait for an acknowledgement from the
receiver and the receiver places the signal on a queue where
it remains until it is able to handle the event.
Each process may be listening for external events, i.e.,
events that are generated from other processes or the
environment. Lamport [17] demonstrated the fundamental
composability limitations of event-driven systems. Event-
driven systems are designed for the best or the average
case, but can result in unbounded delays or message queue
sizes in the worst case, resulting in devastating conse-
quences for real-time systems. This is because the execu-
tion of the process is completely dependent on the ordering
and timing of events that the process has no control over.
In extreme situations, such as an event shower, this leads to
race conditions resulting in non-deterministic behaviour.
To avoid running out of memory, event queues used to store
events often are of a ﬁxed size. During an event shower,
such a queue can reach capacity, thus resulting in events
being missed. This can therefore lead to ambiguous and
nuanced behaviour, that is diﬃcult to reproduce, as the
process could potentially be in a state which it is waiting
for events that have now gone undetected.
An event shower also has the added problem of making
the time it takes to react to an event non-deterministic.
The reason for this is that (under the standard run-till
completion semantics [6], [8]) the system must process
all events in the queue before reacting to future events.
When a new event happens, the current queue size can
hold a few or a large number of disparate events, making
it all but impossible to predict how long the new event
will be in the queue until it can be dealt with. Most
notations, such as UML, SysML, and even SDL, compound
this problem by allowing processes to generate new events
as part of the transition actions: “A transition performs
a sequence of actions. During a transition, the data of an
agent is possibly manipulated and signals possibly output
(depending on the content of the transition).” [18, p. 53].
That is, the ﬁring of a transition triggers further events
“instantaneously” and “simultaneously”; again, violating
the ideal mathematical model that “as close as they might
be in time, events are never simultaneous” [8, Page 50].
Therefore, an event shower, rather than been avoided
by the notation, can, in fact, be fostered by the modelling
language and caused by the composition of, individually
benign subsystems; thus, placing a huge burden on system
designers as they must now anticipate subsystem interac-
tions, including how all possible combinations of events
could inﬂuence the execution of the system. It quickly
becomes impossible to discern how the combinations of all
executing process contribute to the execution and timing
of a particular sub-system. The solution is to move a way
from the event-triggered paradigm entirely.
Complementary to event-driven fsms, LLFSMs model
a system as being in a ﬁnite set S of states. As before,
each state (s ∈ S) represents a possible situation that the
system may ﬁnd itself in. But here it is more explicit that,
while in that state, the LLFSM will execute some actions.
S
onEntry
a
state
e
(a) Diagram for Entry Actions.
OnEntry S
a
S
state
true
e
(b) Diagram providing semantics for Entry Actions.
Figure 1. Equivalence Wagner et al. [19] Entry Actions in terms
of states without sections and transitions.
The system also moves from state to state by means of
transitions. However, in sharp contrast with the event-
driven approach, each transition is predicated by a logical
expression (those familiar with UML would ﬁnd this as
restricting the labels of transitions to only using guards;
and such models have been named procedural [8]). States
are executable states. A state machine is not waiting for
events to happen and reacting to them. Instead, it keeps
executing its current state sc, and at a precise point in the
execution within its own sphere of control, the expressions
labelling the associated transitions are evaluated. If one
of these expressions evaluates to true, the system moves
to the target state of the transition, updating the current
state. Each LLFSM has a state designated as the initial
state (s0 ∈ S), representing the state at the point when
execution commences.
Each state contains a set of executable actions. These
actions are executed at speciﬁc times and under certain
conditions. For example Wagner et al. deﬁne four distinct
types of actions [19]:
1)
Entry Actions: Executed when the system ﬁrst
enters a state.
2)
Exit Actions: Executed when the system leaves
the state.
3)
Transition Actions: Executed when the system
is transitioning between states.
4)
Input Actions: Executed when an input satis-
ﬁes a particular condition. These actions can be
independent of the state.
We use Wagner et al. to illustrate the ﬁrst point of why
a general framework is of interest. We suggest that the
fundamental execution cycle is the very simple notion of
two states between a transition: a source state ss and
target state st. The distinction of an Entry Action a is
merely semantic sugar for the removal of an extra state.
We illustrate this in Figure 1. Wagner et al.’s Entry
Actions [19] are essentially a pre-state to the state s.
Figure 1a is the construct that actually has the semantics
of Figure 1b. This is important, because if the expression
e in Figure 1 is also true, it becomes very clear that the
action a will be performed at least once, even if execution
exits state s immediately (we note that ambiguities of this

229
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
type were already identiﬁed in standards such as SCXML).
The proper speciﬁcation of semantics becomes even
more important when the actions in a state access a set of
variables that aﬀect subsequent actions and transitions.
That is, the attached Boolean expressions (as we men-
tioned, in UML and OMT these are named guards) involve
variables. The ﬁrst issue is the scope of the variables and
the second issue is that of potential race conditions that
could be generated due to these variables being shared in
some way. Common cases of variables that are shared are
the variables where sensors record a status of the environ-
ment. Thus, while the software is executing, the value of
a sensor variable may change, without the software being
able to control or inﬂuence the timing of these changes.
Similarly, control variables for eﬀectors are shared. The
software modelled by LLFSMs may set a control variable
and the driver of the eﬀector reads such a variable to act.
The clfsm [3] implementation of LLFSMs provides three
levels of scope for variables.
1)
External Variables: Variables external to the
system from the perspective of the software, usu-
ally corresponding to the sensors and eﬀectors.
They may change at any point in time.
2)
FSM Local Variables: These are variables that
are shared between all states within a single
LLFSM.
3)
State Local Variables: These are variables that
are local to a state.
Naturally, one can specify more variants. For example,
why not have variables that are shared between all the
LLFSMs of a system, but not sensors and eﬀectors? Why
not have variables whose scope is even more local than that
of a state, e.g., only local to the OnEntry section? These
examples illustrate the need for a ﬂexible approach to
extending the possibilities of LLFSM constructs. This need
inspires the framework proposed in the present paper.
III.
Protocol Oriented Design
Protocols in Swift are a reﬁnement of an object-oriented
construct that enables a developer to deﬁne the intent
or semantics of a type without necessarily providing a
concrete implementation. In this respect, protocols are
similar to Java interfaces; a type that implements (or
conforms to) a protocol enters into a contract, where the
conforming type must implement the constraints imposed
by the protocol. The advantage is that any type that
conforms to the protocol conforms to the same set of
semantics as any other type that also conforms to the same
protocol. This enables the use of either type interchange-
ably. In this sense, protocols are a way to enforce semantic
constraints. They enable the modelling of individual pieces
of the software without the burden of deﬁning how each
piece is implemented. This creates loose coupling between
types as a type may depend on a protocol (or rather
the semantics which are deﬁned within the protocol) and
any type which conforms to the protocol may provide the
necessary implementation.
Unlike interfaces, however, Swift takes this idea further
with protocol extensions, providing a mechanism of aspect-
oriented programming. This enables conforming types to
receive default implementations. In other words, a con-
forming type may receive some or all of its implementation
for free, based on the contracts provided by protocols
alone. This is not to be confused with standard class
inheritance. Standard class inheritance imposes a strict
implementation hierarchy and close coupling on inherited
types. An implementation within a class may depend on
private members or other strict types, an implementation
received by a protocol extension simply models how vari-
ables and functions in the protocol can be leveraged to
provide a default implementation. Importantly, a protocol
extension depends only on the contract it and other pro-
tocols provide, and only on the public interface provided
by these protocols.
However, the true power of a protocol extension is with
conditional extensions. A conditional extension enables
the developer to deﬁne rules on which conforming types
receive which default implementation (if any). This way,
the protocol extension can also be restrictive so that only
types that conform to a speciﬁc set of protocols may receive
the implementation.
Consider
the
example
in
Figure
2,
showing
the
Collection protocol that contains a generic parameter
Element. In Swift, a generic parameter on a protocol
is known as an associated type. This protocol models a
collection that contains zero or more elements. Element
represents the type of the elements within the collection.
Two concrete implementations conform to this protocol:
Array and Set. These behave diﬀerently: Set only contains
unique elements, while Array may contain duplicates.
Swift models equality operations in the Equatable pro-
tocol. This protocol deﬁnes that conforming types must
provide == and != functions. A protocol extension can
be created on the Collection protocol which provides a
default implementation for the == and != functions. These
functions compare all the elements within two collections
to ﬁnd if they are equal, assuming that the individual
elements within the collections can be compared. This is
shown in Extension 1.
Extension 1. Extend Collection where Element is
Equatable:
function == (lhs: Collection, rhs: Collection)
for le in lhs, re in rhs
if le != re
return false
end
end
return true
end
function != (lhs: Collection, rhs: Collection)
return !(lhs == rhs)
end
Examples:
nums := [1, 2, 3]
nums == nums // Ok
people := [Person(), Person(), Person()]
people == people // Person is not Equatable

230
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Now all types that conform to Collection (Array,
Set) are able to use equality operators, assuming that the
elements within the collections are able to be compared.
«protocol»
Collection<Element>
Array<Element>
Set<Element>
Figure 2. Collections Hierarchy
We use protocols and protocol extensions extensively
in swiftfsm to deﬁne rules on how certain things must
be implemented. This way, the developer is constrained
to semantics that enable veriﬁcation and model checking
without otherwise restricting the language.
The swiftfsm framework minimises the possibility of
creating a semantics whose tools for composition result in
combinatorial explosion. For example, nesting in UML’s
statecharts is what enables the modelling of larger systems;
however “the Cartesian product machine is used as the
interlingua semantics of statecharts” [8, Page 63]. On
the other hand, we shall not restrict expressivity so that
only trivial systems can be modelled. We want to remain
Turing complete although all properties of some executable
models would not be veriﬁable (such as the famous Halting
problem). The challenge is to enable developers to tailor
the semantics to their most eﬀective constructs while
retaining small Kripke structures veriﬁable by standard
tools.
IV.
Modelling States and Transitions
We are now ready to present our ﬁrst abstraction: the
type used for transitions. To introduce the idea, consider
the following scenario, where allowing developers to create
custom semantics leads to more robust designs. Let’s focus
on a state A (Fig. 3). The clfsm semantics [2] explicitly
speciﬁes that the onEntry action will execute once and
only once for each state, after which the sequence of
transitions will be evaluated in the order a, then b. If
the associated expression (not shown) evaluates to true,
the corresponding transition will ﬁre and the state will
execute its onExit action. If none of the transitions ﬁre, the
Internal action will be run. In either case, the execution
token passes to the next LLFSM in the arrangement.
Importantly, with this restricted semantics, it is not
possible to implement an atLeastOnce semantics for the
Internal action without adding another state. If transitions
a or b cause a state transition, (in the clfsm seman-
tics [2]), then the Internal action will never execute. If
this functionality is required, a pattern similar to Figure 4
needs to be implemented. Note that this involves creat-
ing two states and copying (duplicating) implementation,
obstructing factorisation and creating the danger of intro-
ducing failures. Both a1 and a3 need to be copied into
the new state A0 in order to implement the atLeastOnce
semantics. State A1 is almost the same as the original state
A. This becomes arduous to maintain and modify as the
A
onEntry
a1()
onExit
a2()
internal
a3()
B
C
a
|
Figure 3. A simple scenario
A0
onEntry
a1()
onExit
a3()
internal
A1
onEntry
onExit
a2()
internal
a3()
B
C
a
|
Figure 4. Implementing “atLeastOnce” semantics in clfsm
A
onEntry
a1()
onExit
a2()
atLeastOnce
a3()
B
C
a
|
Figure 5. Implementing “atLeastOnce” semantics in swiftfsm
developer must keep the A0 actions in sync with the A1
actions.
With swiftfsm, we overcome this problem by allowing
developers to deﬁne custom state types that represent such
a semantics. The result is shown in Figure 5. As can be
seen, the ﬁgure demonstrates how a developer may deﬁne
the new atLeastOnce action. While this approach may
seem unnecessary to apply in such a simple case, it does
show the added expressiveness of the semantics which the
developer may choose to employ.
Nothing is stopping the developer from creating further
changes to the semantics of how states execute. Ideas
such as transition actions (actions which are triggered
when speciﬁc transitions are taken) become possible. The
ability to create more complicated models which could
utilise ideas such as state clustering or hierarchies of state
machines is also viable now that a developer has the
ability to proactively deﬁne the state models that they
are working with. This allows the developer to tailor the
tool-set to the problem they are trying to solve. Most
importantly we can achieve all of this, while maintaining
a strong type hierarchy and veriﬁable semantics as shown
in Section VII.
The design of custom state types is achieved using
a protocol hierarchy. Figure 6 demonstrates how this
protocol hierarchy can be used to deﬁne the clfsm se-

231
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
mantics. First, we present the protocol at the top of
the hierarchy: Identifiable. Instances of types con-
forming Identifiable are able to be distinguished from
each other. This is achieved using the name ﬁeld. Every
unique instance is required to have a unique name. The
Identifiable protocol conforms to the Equatable proto-
col, allowing equality checks by comparing the names of
the two instances.
The
next
protocols
are
StateType
and
Transitionable.
These
are
the
protocols
that
are
responsible
for
representing
states
and
transitions.
Because of the wide breadth of state models, swiftfsm
only assumes that a state has a unique name. therefore,
swiftfsm deﬁnes the StateType protocol only containing
that name (which is inherited from Identifiable). The
developer has complete freedom to deﬁne any number
of phase actions that make up a state. This is done
by deﬁning another protocol. For the clfsm semantics,
this is encapsulated within the CLFSMActions protocol.
Each action that a state may perform is represented as a
member function of the protocol.
The swiftfsm framework does not even assume that
a state can transition. This is a separate requirement,
modelled as a separate protocol. The Transitionable
protocol adds a sequence of transitions to conforming
states. All transitions contain
1)
a predicate function that, when it evaluates to
true, represents a situation where the LLFSM will
transition; and
2)
a target state the LLFSM will transition to.
The type of the transition predicate function is deﬁned as:
StateContext → Boolean
This abstracts a state context type that encapsulates all
(and only) the necessary variables that inﬂuence the eval-
uation of the predicate function. In this way, a transition
function can access the necessary variables through its
source state. This is an important concept when generating
the corresponding Kripke structure of an executable model
in order to perform formal veriﬁcation. We proﬁt and
explicitly use referential transparency for the generation of
Kripke structures. That is, transitions emanating from a
state will be evaluated with a ﬁxed state context variation
that has no further dependencies or side-eﬀects.
This allows for an important optimisation. Typically,
an LLFSM state corresponds to several Kripke states, be-
cause of
•
state sections (e.g., onEntry, onExit, Internal,
atLeastOnce, etc.), and
•
the potential semantics of snapshotting external
variables between these state sections.
However, our semantics recognises that external variables
that are not involved in a transition will not need to create
a new transition evaluation context. Therefore, the above
transition type is side-eﬀect free and removes the need
to consider all possible combinations of external variables
outside those appearing in the transaction.
The traditional conceptualisation of the class of transi-
tions is that transitions have a source and a target state.
Such a conceptualisation complicates the optimisation we
just mentioned, as the transition is in a static relation-
ship with its source state (typically implemented as a
reference). Our approach does not need to change the
source state of a transition in an LLFSM to create the
Kripke states for sections. Our framework only updates the
possible changes to the external variables of relevance, and
submits the State with this new context for evaluation to
the transition. Importantly, this means that the evaluation
of any transition is referentially transparent, as it is a
pure function with explicit inputs and outputs and no
side-eﬀects. The Kripke structure generated in this way
is guaranteed to obtain the eﬀect of evaluation of the
transition without possible side eﬀects inﬂuencing the
transition as all the variables are in the context attached
to the state.
Notice
that
CLFSMState
does
not
contain
an
addTransition function. This is provided by a default
implementation shown in Extension 2
Extension 2. Extend StateType where Self is
Transitionable:
function addTransition(t: _TransitionType ...)
transitions := transitions ∪ t
end
V.
Modelling Logic-Labelled Finite State
Machines
The ability to create custom LLFSM semantics can be
beneﬁcial. Within the conﬁnes of the clfsm semantics,
an LLFSM is capable of being suspended, restarted or
stopped. The LLFSM is also responsible for executing states.
While this semantics is expressive, it can be somewhat
restrictive. For example, why not make it possible to allow
an LLFSM to control a given set of LLFSMs in a master/slave
relationship? This would make it possible to create strict
LLFSM hierarchies which form a tree structure. This is
quite diﬀerent from the LLFSM hierarchies described in the
literature [20] that does not enforce any hierarchy and
allows any LLFSM to control any other LLFSM. Our stricter
approach here helps ensure clarity and safety.
The way in which swiftfsm models LLFSMs allows the
developer to deﬁne custom semantics is again achieved
using a protocol hierarchy (Figure 7). The LLFSM protocol
hierarchy, while more complex, follows the same methods
we employed to create the state semantics hierarchy. A
base protocol is used and further features are added using
separate protocols.
We ﬁrst present the simplest protocol StateContainer.
This protocol contains no members, instead it simply
deﬁnes the
StateType associated type. This associated
type must be deﬁned to allow conforming types to refer
to a single StateType type. That is to say, types that
are conforming to StateContainer are manipulating or
interacting with a single type of state in some way.
The ﬁrst protocol which conforms to StateContainer
is FiniteStateMachineType. This protocol represents an
LLFSM. However, similar to how the StateType protocol
made no assumptions about the actions contained within
a state, the FiniteStateMachineType protocol makes

232
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
«protocol»
Equatable
«protocol»
Identifiable
+name: String
«protocol»
StateType
«protocol»
Transitionable< TransitionType: TransitionType>
+transitions: [ TransitionType] { get set }
+addTransition( TransitionType ...)
«protocol»
TransitionType<Source, Target>
+target: Target
+canTransition(source: Source): Bool
CLFSMState
+name: String
+transitions: [StateTransition<CLFSMState>]
+onEntry()
+onExit()
+internal()
CLFSMActions
+onEntry()
+onExit()
+internal()
StateTransition<State: StateType>
+target: State
+canTransition(source: State): Bool
Figure 6. Deﬁning The clfsm State Semantics
no assumptions on what the LLFSM model may do. The
FiniteStateMachineType protocol does not even assume
that it will execute a state. This is modelled by the
StateExecuter protocol.
We now introduce a new abstraction over the original
concept of an LLFSM ringlet [2]. A ringlet deﬁnes how the
sections within a state are executed, and more speciﬁcally,
how and in what order each action is executed. We propose
to view ringlets as pure functions that take a state and
return the next state to execute. Therefore, we have them
as objects of the following type.
State → State.
If a new state is returned, then the LLFSM has transitioned.
By modelling a ringlet in this fashion, we enable devel-
opers to create custom ringlets that determine how their
states are executed. To illustrate the adaptability of this
approach, it is also possible to create diﬀerent ringlets
that execute the same set of states in diﬀerent ways.
Importantly, the execution of the state becomes orthogonal
to the deﬁnition of the state.
However, in practice it is common that a ringlet may
require to modify state information. To this end, the
swiftfsm framework provides the Ringlet protocol, which
deﬁnes an execute function. If we look at previous seman-
tics for LLFSMs, and in particular to the semantics oﬀered
by the clfsm compiler, we can see that the ringlet only
executes the onEntry section when the previously executed
state does not equal the state currently being executed (in
particular, if a state has a transition to itself, this is a
legal construct, but if the transaction executes, in clfsm
this does not re-run the onEntry section). If a developer
wishes to extend the semantics that all arriving transitions
(including self-transitions) cause the onEntry section to
execute, our framework here allows the creation of a
CLFSMRinglet that contains a previousState member
variable that the execute function refers to and manages
when executing the current state. That is we are using the
Method pattern, and the developer supplies the method
that deﬁnes the speciﬁc ringlet to sequence sections of a
state.
The StateExecuter protocol (in combination with
IncrementalExecuter) provides a next function. This
function is responsible for executing the current state.
However, if the LLFSM contains a ringlet, then the
next
function
may
delegate
the
execution
of
the
state
to
the
ringlet.
This
functionality
is
encapsu-
lated in the StateExecuterDelegator protocol that
deﬁnes a StateExecuter, which contains a Ringlet.
FiniteStateMachineType provides a default implemen-
tation
for
the
next
function
when
conforming
to
StateExecuterDelegator. This is shown in Extension 3.
A similar pattern is followed for providing the re-
maining features of the LLFSM. In this sense, a feature is
modelled as a protocol, and further protocols are created
to enable default implementations. A further example is
with the Restartable protocol. This protocol provides a
restart function which, when called, should restart the
LLFSM so that the initial state becomes the current state.
Extension
3.
Extend
FiniteStateMachineType
where Self is StateExecuterDelegator and
Self is PreviousStateContainer and
StateType = RingletType. StateType:
function next()
temp := ringlet.execute(currentState)
previousState := currentState
currentState := temp
end
However, recall that the clfsm semantics state that
the onEntry action is only executed if the previous
state does not equal the current state. If the LLFSM
was truly to restart, then the previous state should also
reset to its initial value. This way, there does not ex-
ist a situation where the LLFSM does not execute the
onEntry action. To provide the default implementation

233
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
«protocol»
Equatable
«protocol»
Identifiable
+name: String
«protocol»
FiniteStateMachineType
+initialState:
StateType
«protocol»
StateContainer< StateType: StateType>
«protocol»
IncrementalExecuter
+next()
«protocol»
StateExecuter
+currentState:
StateType
«protocol»
StateExecuterDelegator<RingletType: Ringlet>
+ringlet: RingletType
«protocol»
Ringlet
+execute(state:
StateType):
StateType
«protocol»
PreviousStateContainer
+previousState:
StateType
«protocol»
OptimizedStateExecuter
+initialPreviousState:
StateType
«protocol»
ExitableStateExecuter
+exitState:
StateType
«protocol»
Exitable
+exit()
«protocol»
Finishable
+hasFinished: Bool
«protocol»
SuspendableStateExecuter
+suspendedState:
StateType
+suspendState:
StateType
«protocol»
Suspendable
+isSuspended: Bool
+suspend()
«protocol»
Resumeable
+resume()
«protocol»
ResumeableStateExecuter
«protocol»
Restartable
+restart()
FiniteStateMachine<R: Ringlet>
+currentState: R. StateType
+exitState: R. StateType
+initialPreviousState: R. StateType
+initialState: R. StateType
+name: String
+previousState: R. StateType
+ringlet: R
+suspendedState: R. StateType
+suspendState: R. StateType
Figure 7. The LLFSM Protocol Hierarchy
for a restart function, the FiniteStateMachineType pro-
tocol requires that there should also exist a conformance
to OptimizedStateExecuter. This protocol enables an
initialPreviousState member which represents the ﬁrst
previous state. With this, a default implementation for the
restart function is now possible. The restart function
eﬀectively sets the current state and the previous state to
their initial values.
To put everything together, the FiniteStateMachine
type implements the default model in swiftfsm. This
implements the same semantics as clfsm. Notice, however,
that the FiniteStateMachine type does not need to
provide any function implementations, as the type receives
its entire implementation from protocol extensions.
VI.
Scheduling
Because LLFSM are not event-driven, they are scheduled
using a round robin scheduler. We provide such scheduling
as the default in the framework swiftfsm. Therefore,
a single ringlet, for the current state of each LLFSM, is
executed in a sequential fashion. This creates concurrent
execution in a predictable manner reducing state explosion
for formal veriﬁcation. The sequential execution avoids
thread management and avoids complexities associated
with parallel execution, (there are essentially no critical
sections or mutual exclusion challenges). Because of the
sequential scheduling, we have a deterministic execution
of an arrangement of the LLFSMs, thus when the Kripke
structure is created for the entire arrangement, we have a

234
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
smaller Kripke model (a smaller NuSMV input ﬁle) that
with unconstrained concurrency of event-driven systems.
By preventing side-eﬀects (as shown in the previous Sec-
tion), we further reduce the size of the Kripke structure
enhancing the feasibility of performing model checking.
Furthermore, swiftfsm uses a stricter snapshot seman-
tics when executing the ringlets. A snapshot is taken of
the external variables before the ringlet is executed. The
state then uses the snapshot when executing actions and
evaluating transitions (recall our execution context). Only
once the ringlet has ﬁnished executing, any modiﬁcations
appear visible externally (e.g., to the environment). This
deﬁnes the granularity at which the system is reactive
to changes observable by sensors in the environment and
does not need to make a dangerous assumption of well-
behaved environments and that the software always runs
faster than any external part of the system. Compare
this with many formal veriﬁcation approaches that only
work with ideal event-driven systems, that do not exist
in practice. We detach from such ideal conceptions that
“events consume no time: they are zero time episodes ” [8,
Page 50] and “as close as they might be in time, events are
never simultaneous” [8, Page 50] because even in UML it is
extremely easy to create an event for which there would be
several listeners whose response would be the generation
of an event (creating simultaneous events). Or admitting
upon further analysis that “the software actually consumes
time when processing those events” [8, Page 50]. Thus,
we avoid approaches where extended ﬁnite-state machines
handling of external variables is simply assumed to be
irrelevant: “During a macrostep, the values of the inputs
do not change and no new external events may arrive;
in other words, the system is assumed to be inﬁnitely
faster than the environment” [21, p. 172]. Alternatively,
the environment is assumed to be well-behaved, so that
it sends the input the software requires at the right time,
forming “a closed model corresponding to the complete
mathematical simulation of the pair formed by the software
controller and the environment” [22, p. 89]. We also do not
follow the simplistic approach that assumes any external
stimulus (change of external variables) will not happen
until all internal changes take place “giving priority to
internal actions over external actions” [23].
We argue that the speciﬁcation of when a snapshot
is taken deﬁnes the level of atomicity of the sections
within the state run by the ringlet with respect to the
external variables. This becomes particularly important
when performing formal veriﬁcation.
VII.
Formal Verification
If one strictly follows the derivation of Kripke struc-
tures
from
the
artefact
of
sequential
program
con-
structs [24], the corresponding Kripke states would not
only be the boundaries of sections of LLFSM states, but ev-
ery assignment and operation in those sections correspond
to extended FSMs, containing programming language state-
ments (e.g., in Swift). The sequential execution of LLFSMs
and its default snapshot semantics enables more succinct
Kripke structures, where the delicate point is the handling
of the external variables [25], [26]. Nevertheless, as we
mentioned, such a default semantics requires recording
all of the variables inﬂuencing the execution before and
after every state section in order to generate the Kripke
structure [25]. For consistency, we conﬁgured a version of
swiftfsm that followed such an approach [4].
These earlier approaches relied on the ringlet itself
to record variables, inﬂuencing the execution of a state.
However, a more succinct approach can be used and a
further optimisation can be made. Since the swiftfsm
framework not only uses a sequential scheduling similar to
clfsm, but a ringlet’s execution is atomic with respect to
the external variables, ringlet execution can now be treated
as a black box.
Consequently, a snapshot should only be taken of the
variables before and after the entire ringlet for a state’s
execution. This variation also prevents statements being
executed that make modiﬁcation to variables that are not
reﬂected in the ﬁnal context for the next Kripke state. For
example, a state may make changes to an external variable
during an onEntry section that is cancelled by a further
modiﬁcation in the onExit section. Since no eﬀect of this
will occur during the state’s execution, as we now identify
a Kripke state before and after an entire ringlet execution,
interim changes are not reﬂected in the resulting Kripke
structure.
Importantly, we argue that this is a beneﬁt, not a
problem! In swiftfsm, the statements within sections of
the state operate within a context derived from a snapshot
of the external variables, which gets taken precisely when
the state is scheduled. There is absolutely no way that
any modiﬁcation could (nor should) aﬀect the environment
until the snapshot is saved. External variables are updated
precisely once when the ringlet has ﬁnished executing.
Similarly, since swiftfsm uses sequential scheduling, there
is no way for the modiﬁcation of non-external variables
to have side-eﬀects and inﬂuence the execution of other
machines, because the semantics is equivalent to a single
thread. The only important record for the construction of
the Kripke states (to be part of the Kripke structure or
veriﬁcation) is the context (of the variables) before and
after each ringlet is executed.
To demonstrate the approach for creating a Kripke
structure, consider the Incrementing LLFSM shown in Fig-
ure 8. This LLFSM is responsible for incrementing a counter
by one. When the value of the counter reaches a non-
zero number,the LLFSM transitions to the Exit accepting
state. However, this LLFSM provides two boolean external
variables, each representing the state of a button in the
environment. When both buttons are pushed, the LLFSM
transitions to the Exit state regardless of the value of the
counter.
Using the round-robin sequential scheduler requires
that a snapshot be taken before and after a state is
executed. This is represented in the Kripke structure. An
execution of a state results in several nodes. Firstly, taking
a snapshot will result in a node being created for each
combination of external variables. For the Incrementing
LLFSM, this will result in a total of 4 nodes. However, the
advantage with swiftfsm is, as stated previously, treating
the execution of a ringlet as an atomic action. Each 4
nodes that represent the reading of a snapshot will each
transition to a single node. We therefore classify each node
within the Kripke structure as an R (read) node or a W
(write) node. R nodes represent the state of the system

235
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Increment
var count: Int = 0
onEntry
onExit
internal
count += 1
Exit
onEntry
onExit
internal
External Variables
var button1Pushed: Bool
var button2Pushed: Bool
button1Pushed &&
button2Pushed
count >= 1
|
Figure 8. The Incrementing LLFSM
Increment.count = 0
button1Pushed = false
button2Pushed = false
pc = Increment.R
Increment.count = 0
button1Pushed = true
button2Pushed = false
pc = Increment.R
Increment.count = 0
button1Pushed = false
button2Pushed = true
pc = Increment.R
Increment.count = 0
button1Pushed = true
button2Pushed = true
pc = Increment.R
Increment.count = 1
button1Pushed = false
button2Pushed = false
pc = Increment.W
Increment.count = 1
button1Pushed = true
button2Pushed = false
pc = Increment.W
Increment.count = 1
button1Pushed = false
button2Pushed = true
pc = Increment.W
Increment.count = 0
button1Pushed = true
button2Pushed = true
pc = Increment.W
Figure 9. Executing the initial ringlet of the Incrementing LLFSM
before a ringlet has been executed, whereas the W nodes
represent the state of the system after the ringlet has
ﬁnished executing. When executing using the round-robin
scheduler, a single ringlet execution will result in multiple
R nodes each leading to a single W node. This is shown
in Figure 9.
VIII.
Microwave Case Study
We present a case study where we simplify the model of
a microwave oven, a ubiquitous example in the software en-
gineering literature of behaviour modelling through states
and transitions [27].
This model has been extensively
studied in formal veriﬁcation [24, p. 39], as the safety
feature of disable cooking when the door is open is analogous
to the requirement that a radiation machine should have
a halt-sensor [28, p. 2]. Software models for microwave
behaviour are widely discussed [29], [30], [31], [32], [33],
[34]). Figure 10 shows the standard executable model
with LLFSMs. While this model is transparent and formal
veriﬁcation establishes requirements, the full machinery of
Kripke states for each of the three state-sections is not
required (note that all Internal sections are empty and the
only onExit section that is used is in the timer LLFSM, in
state 3 to Add 1 Minute). Moreover, the model would also
be simpliﬁed if the timeLeft variable were to be removed
by making it equivalent to the condition 0<currentTime.
With respect to the requirements speciﬁed in Myers and
Dromey [34, p. 27, Table 1] or in Shlaer and Mellor [30,
p. 36] the behaviour of such a simpliﬁcation is irrelevant.
But, for model checking, removing the Boolean variable
timeLeft alone would half the number of Kripke states
(and the corresponding size of the NuSMV ﬁle where
formal veriﬁcation is conducted is thus halved). By re-
moving the state sections, the number of Kripke states
would be halved again. Thus, it would be advantageous to
derive LLFSMs, where states have no onExit nor Internal
actions.
The new model would globally replace timeLeft by
0<currentTime. All declarations of extern timeLeft dis-
appear from all LLFSMs. Thus, the timer machine changes
to Figure 11. This change results in slightly diﬀerent
behaviour. With the executable model of Figure 10, when
the button is pressed for the ﬁrst time and not released,
nothing would happen. Now, when the button is pressed
for the ﬁrst time and not released, if the door is closed,
cooking will commence and the light will go on. As long
as the button is pressed and not released such cooking
with the light on will continue and the timer will not be
decremented. This behaviour does exist in a slightly similar
form in Figure 10, but only happens from the second
time onwards. That is, the user must press the button;
upon releasing the button, cooking starts and the light
turns on. If the user presses and holds the button now
that cooking has started, it also blocks timing counting
down. Again, we do not consider this subtle diﬀerence in
behaviour relevant as it is never identiﬁed in the require-
ments (Figure 12 illustrates the concurrent execution of the
arrangement of LLFSMs and documents their state changes
for a use-case). However, the variation simpliﬁes the Kripke
structure radically for more eﬃcient formal veriﬁcation of
the requirements. With our framework, the designers can
easily alternate between the two executable models, and
conduct model checking on both.
A further optimisation can be made when considering
how swiftfsm currently handles the snapshots of external
variables. Recall that a snapshot is taken before the ringlet
executes, and then saved back to the environment once the
ringlet has ﬁnished executing. By changing these semantics
to a per-schedule cycle, as opposed to a per-ringlet cycle,
we can further minimise the number of Kripke States
that are generated. Taking the microwave as an example,
instead of taking a snapshot of the external variables before
executing each state, we instead take a single snapshot of
the environment for each execution of one schedule over the
arrangement of LLFSMs. Each LLFSM would therefore share
the same snapshot and any modiﬁcations made to the
snapshot will only be saved once all LLFSMs have executed
their current state.
This has a drastic impact to the number of Kripke
States that are generated for the Kripke Structure. Con-
sider all possible combinations of a snapshot of the external
variables. The microwave uses three Boolean variables,
therefore this results in 23 = 8 possible combinations.
There are normally four snapshots taken per schedule cycle
as there are four LLFSMs executing and a snapshot is
taken when a ringlet in each LLFSM is executed. Therefore,
there are 234 = 4096 possible combinations of snapshots
per schedule cycle. When taking a single snapshot at the
start of the schedule cycle, the result is 231 = 8 possi-
ble combinations of snapshots. Removing the timeLeft
variable further reduces this to 221 = 4 combinations of

236
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
Check
onEntry
microwave_status.timeLeft = 0 < currentTime
onExit
internal
Decrement 1 Minute
onEntry
currentTime -= 1
onExit
internal
Add 1 Minute
onEntry
currentTime += 1
onExit
microwave_status.timeLeft = true
internal
FSM Variables
var currentTime: UInt8 = 0
External Variables
var microwave_status: wb_microwave_status
currentTime > 0
&& !microwave_status.doorOpen
&& microwave_status.timeLeft
&& clock.after(60)
true
microwave_status.buttonPushed
&& !microwave_status.doorOpen
&& currentTime < 15
!microwave_status.buttonPushed
(a) A 3-state machine for the timer.
On
onEntry
sound = true
onExit
internal
Off
onEntry
sound = false
onExit
internal
Armed
onEntry
onExit
internal
FSM Variables
var sound: Bool = false
microwave_status.timeLeft
!microwave_status.timeLeft
clock.after(2)
(b) A 3-state machine for controlling the bell.
FSM Variables
var motor: Bool = false
Not Cooking
onEntry
motor = false
onExit
internal
Cooking
onEntry
motor = true
onExit
internal
!microwave_status.doorOpen
&& microwave_status.timeLeft
microwave_status.doorOpen
|| !microwave_status.timeLeft
(c) A 2-state machine for controlling the cooking
engine.
FSM Variables
var light: Bool = false
Off
onEntry
light = false
onExit
internal
On
onEntry
light = true
onExit
internal
microwave_status.doorOpen
|| microwave_status.timeLeft
!microwave_status.doorOpen
&& !microwave_status.timeLeft
(d) A 2-state machine for the light.
Figure 10. Complete model of one-minute microwave.
Check
onEntry
Decrement 1 Minute
onEntry
currentTime -= 1
Add 1 Minute
onEntry
currentTime += 1
currentTime > 0
&& !microwave_status.doorOpen
&& clock.after(60)
true
microwave_status.buttonPushed
&& !microwave_status.doorOpen
&& currentTime < 15
!microwave_status.buttonPushed
Figure 11. Simpliﬁed timer with onEntry sections only.
snapshots per schedule cycle, a reduction by three orders
of magnitude.
To demonstrate the eﬀect that limiting the snapshots
has on the Kripke structure size, we provide a git repos-
itory which contains the Kripke structures in several for-
mats for the Incrementing LLFSM and the one-minute
microwave LLFSMs. When following the original semantics
(those where a snapshot of the external variables is taken
and saved before and after each ringlet execution) the
Kripke structure for the microwave contains 369 260 nodes.
By using a single snapshot semantics where a snapshot
is taken per schedule cycle, the Kripke structure for the
microwave contains 60 674 nodes. A massive reduction.
The Kripke structures can be located at https://github.
com/mipalgu/VersatileKripkeStructures.
IX.
Conclusion
In software engineering, there is a prevalence for mod-
elling using UML state charts (which is a derivation of
Harel’s State Charts [35]) and which are event-driven.
Moreover, Sommerville [27], states that “state models are
often used to describe real-time systems” [27, p. 544], citing
UML. We note that Sommerville also uses a microwave to
illustrate how FSMs model the behaviour of systems [27,
p. 136]. Because of these associations among systems that
respond to stimuli, it is important to clarify the terminol-
ogy regarding what constitutes an event-driven system, a
reactive system and more importantly, a real-time system.
Reactive-systems are responsive systems without much
processing, as opposed to deliberative systems (which
reason, plan, learn) [36].
We refer to an event-driven system as one typically
based on a software architecture built around stimuli-
driven call-backs, a subscribe mechanism and listeners that
enact such call-backs (very much as GUIs are composed for
desktops today). Reacting to stimuli in this way implies
uncontrolled concurrency (e.g., using separate threads or
event queues). Event-driven programming is also illustra-
tive of this mechanism that follows the inversion of control
(IoC) design principle; call-backs are custom code only

237
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
On
Off
State
State
Off
State
Not Cooking
State
Check
State
Decrement_1_Minute
State
Loop: !doorOpen && timeLeft
Cooking
State
Armed
On
Cooking
State
State
Not Cooking
State
State
Check
State
Decrement_1_Minute
State
Loop: !doorOpen && timeLeft
Check
State
Add_1_Minute
State
Check
State
Add_1_Minute
State
Off
State
On
Off
State
State
Not Cooking
State
Check
State
Decrement_1_Minute
State
Loop: !doorOpen && timeLeft
Armed
On
State
State
Off
State
Off
State
Check
State
Not Cooking
State
Cooking
State
LLFSM :light
LLFSM:bell
LLFSM:engine
LLFSM:timer
:User
Microwave Runs One Minute And Paused Once
!timeLeft
!doorOpen
doorOpen
!buttonPushed
timeLeft
buttonPushed
!buttonPushed
!timeLeft
buttonPushed
timeLeft
!doorOpen
Figure 12. States transitions in a sequence diagram for the use case
of running the microwave for one minute and a pause in another
minute.
concerned with the handling of events, whereas the event
loop and dispatch of events/messages is handled by the
framework or the runtime environment. This application
of the “Hollywood Principle: Don’t call us, we’ll call you”,
while very productive in several contexts (we already
mention GUI applications), has serious limitations for real-
time applications. We insist that fundamental (mathemati-
cally supported assertions) have long being established [17]
regarding the limitations of event-driven systems. The
counterpart to event-driven systems are time-triggered
systems.
Real-time systems are required to meet time-deadlines
in response to stimuli [37]. Therefore, although closely
related, these terms are not the same, and in this pa-
per, we argue (supported by the work of Lamport [17])
that there are many solid reasons why real-time systems
may be better served by time-triggered systems and pre-
determined schedules, rather than the unbounded delays
that may occur in event-driven systems.
There is nothing wrong with using a loosely deﬁned
semantics in visual and textual notations (in particular the
event-driven state charts of UML) when communicating
the main ideas of software designs to stakeholders [38].
However, advocates of model-driven software development
(MDSD) argue that software developers shall mostly work
with models and that UML is the programming lan-
guage [39]. However, in this scenario the UML has short-
comings. For example, the relevance of MDSD to the
synthesis of behaviour intended for embedded systems has
been strongly emphasised [40]; particularly stressing that
UML state charts are the prevalent diagrammatic tool
for behaviour. But, for instance, modelling behaviour for
FPGAs has consistently avoided the event-driven approach
of UML state charts: Wood et al. [40] reviewed earlier
attempts to generate VHDL from UML and found that
either 1) translation was incomplete (aimed at simulation
and not hardware synthesis), 2) covered a tiny subset of
UML’s state chart notation or 3) were far from following
closely an MDSD methodology. Wood et al. [40] attempt
to directly deﬁne a model transformation semantics (from
the syntactic construct of UML state charts to the VHDL
code) also ran into issues; in particular, the asynchronous
nature of UML was replaced by synchronous speciﬁcation
in VHDL [40, Page 1362] (other semantic changes are also
listed [40, Page 1364], as well as a table of unsupported
features [40, Table 11]). Wood et al. [40] removed the
run-until-completion semantics of UML requiring designs
where all the consequences of an event must terminate
by the next clock click [40]. They eliminated events from
labelling transitions, and now a Boolean expression of
the form event has happened (that pool the state of an
input signal) replaces each instance of an event. Thus,
their UML models allow only guards that monitor signals
(they enforce a system of syntactic priorities in case several
signals become true in nesting state charts, but for each
model, transitions must cover all cases and be mutually
exclusive). Thus, we have another scenario where LLFSMs
are being used with precise but particular semantics.
The work presented in this paper illustrates how
LLFSMs can be used as executable models. Moreover, we
argue that their deterministic execution and veriﬁability
is more suitable for real-time systems than systems where
threads proliferate.
In this paper, we have introduced
a ﬂexible semantic model for logic-labelled ﬁnite-state
machines. Compared to traditional event-driven state ma-
chines and LLFSMs, our approach allows redeﬁning while
retaining precision of the semantics of executable mod-
els [6], [7], Our framework allows high-level, executable
models, which are less error-prone and eliminate dupli-
cation. Moreover, we have shown these semantics can be
modelled in a referentially transparent way that creates
simpler Kripke structures, allowing formal veriﬁcation of
our executable models, that is orders of magnitudes faster
for the same model than previous approaches.

238
International Journal on Advances in Software, vol 11 no 3 & 4, year 2018, http://www.iariajournals.org/software/
2018, © Copyright by authors, Published under agreement with IARIA - www.iaria.org
References
[1]
C. McColl, V. Estivill-Castro, and R. Hexel, “An oo and
functional framework for versatile semantics of logic-labelled
ﬁnite state machines,” in The Twelfth International Conference
on Software Engineering Advances, ICSEA 17, J. Lavazza,
R. Oberhauser, R. Koci, and S. Clyde, Eds.
IARIA, October
8th-12th 2017, pp. 238–243.
[2]
V. Estivill-Castro and R. Hexel, “Arrangements of ﬁnite-state
machines - semantics, simulation, and model checking,” in
MODELSWARD, S. Hammoudi, L. F. Pires, J. Filipe, and
R. C. das Neves, Eds.
SciTePress, 2013, pp. 182–189.
[3]
V. Estivill-Castro, R. Hexel, and C. Lusty, “High performance
relaying of C++11 objects across processes and logic-labeled
ﬁnite-state machines,” in Simulation, Modeling, and Program-
ming for Autonomous Robots: 4th International Conference,
SIMPAR 2014.
Springer International Publishing, October
20th-23rd 2014, pp. 182–194.
[4]
C. McColl, “swiftfsm - A Finite State Machines Scheduler,”
Honours Thesis, Griﬃth University, 170 Kessels Rd, Nathan
QLD, 4111, Australia, 10 2016.
[5]
S. Friedenthal, A. Moore, and R. Steiner, A Practical Guide to
SysML: The systems Modeling Language.
San Mateo, CA:
Morgan Kaufmann Publishers, 2009.
[6]
M. Samek, Practical UML Statecharts in C/C++, Second
Edition: Event-Driven Programming for Embedded Systems.
Newton, MA, USA: Newnes, 2008.
[7]
D. Pilone and N. Pitman, UML 2.0 in a Nutshell.
O’Reilly
Media, Inc., 2005.
[8]
D. Drusinsky, Modeling and Veriﬁcation Using UML State-
charts: A Working Guide to Reactive System Design, Runtime
Monitoring and Execution-based Model Checking.
Newnes,
2006.
[9]
M. Fowler, UML Distilled: A Brief Guide to the Standard
Object Modeling Language, 3rd ed.
Boston, MA, USA:
Addison-Wesley Longman Publishing Co., Inc., 2003.
[10]
R. Rumpe, “Executable modeling with UML – a vision or
a nightmare? –,” in Issues and Trends of Information Tech-
nology Management in Contemporary Associations Volume 1,
M. Khosrowpour, Ed.
Idea Group Publishing, May 19th-22nd
2002, pp. 697–701.
[11]
S. J. Mellor and M. Balcer, Executable UML: A foundation
for model-driven architecture.
Reading, MA: Addison-Wesley
Publishing Co., 2002.
[12]
B. P. Douglass, Real Time UML: Advances in the UML for
Real-Time Systems (3rd Edition).
Redwood City, CA, USA:
Addison Wesley Longman Publishing Co., Inc., 2004.
[13]
A. Krupp, O. Lundkvist, T. Schattkowsky, and C. Snook, “The
adaptive cruise controller case study — visualisation, valida-
tion, and temporal veriﬁcation,” in UML-B Speciﬁcation for
Proven Embedded Systems Design, J. Mermet, Ed.
Springer
US, 2004, pp. 199–210.
[14]
B. Selic and S. Grard, Modeling and Analysis of Real-Time
and Embedded Systems with UML and MARTE: Developing
Cyber-Physical Systems, 1st ed.
San Francisco, CA, USA:
Morgan Kaufmann Publishers Inc., 2013.
[15]
Recommendation ITU-T Z.100: Speciﬁcation and Descrip-
tion
Language
–
Overview
of
SDL-2010,
International
Telecommunication Union, April 2016. [Online]. Available:
https://www.itu.int/rec/T-REC-Z.100-201604-I/en
[16]
Speciﬁcation and description language - real time. [Online].
Available: http://www.sdl-rt.org/
[17]
L. Lamport, “Using time instead of timeout for fault-tolerant
distributed systems,” ACM Transactions on Programming Lan-
guages and Systems, vol. 6, 1984, pp. 254–280.
[18]
Recommendation ITU-T Z.101: Speciﬁcation and Description
Language – Basic SDL–2010, International Telecommunication
Union, April 2016. [Online]. Available: https://www.itu.int/
rec/T-REC-Z.101-201604-I/en
[19]
F. Wagner, R. Schmuki, T. Wagner, and P. Wolstenholme,
Modeling Software with Finite State Machines: A Practical
Approach.
6000 Broken Sound Parkway NW, Boca Raton,
FL 33487-2742: CRC Press Taylor & Francis Group, 2006.
[20]
V. Estivill-Castro and R. Hexel, “Veriﬁable parameterised be-
haviour models for robotic and embedded systems,” in Interna-
tional Conference on Model-Driven Engineering and Software
Development, MODELSWARD 2018, vol. 1.
SCITEPRESS
Science and Technology Publications, January 22nd-24th 2018,
pp. 364–371.
[21]
W. Chan, R. J. Anderson, P. Beame, D. Notkin, D. H. Jones,
and W. E. Warner, “Optimizing symbolic model checking for
statecharts,” IEEE Trans. Softw. Eng., vol. 27, no. 2, Feb. 2001,
pp. 170–190.
[22]
J.-R. Abrial, Modeling in Event-B - System and Software
Engineering.
Cambridge University Press, 2010.
[23]
L. Grunske, K. Winter, N. Yatapanage, S. Zafar, and P. A.
Lindsay, “Experience with fault injection experiments for
FMEA,” Software, Practice and Experience, vol. 41, no. 11,
2011, pp. 1233–1258.
[24]
E. M. Clarke, O. Grumberg, and D. Peled, Model checking.
MIT Press, 2001.
[25]
V. Estivill-Castro and D. A. Rosenblueth, Model Checking of
Transition-Labeled Finite-State Machines.
Berlin, Heidelberg:
Springer Berlin Heidelberg, 2011, pp. 61–73.
[26]
V. Estivill-Castro, R. Hexel, and D. A. Rosenblueth, “Eﬃcient
modelling of embedded software systems and their formal veriﬁ-
cation,” in 19th Asia-Paciﬁc Software Engineering Conference,
vol. 1, Dec 2012, pp. 428–433.
[27]
I. Sommerville, Software engineering (9th ed.).
Boston, MA,
USA: Addison-Wesley Longman Publishing Co., Inc., 2010.
[28]
C. Baier and J.-P. Katoen, Principles of model checking.
MIT
Press, 2008.
[29]
S. J. Mellor, “Embedded systems in UML,” OMG White paper,
2007, www.omg.org/news/whitepapers/ label: “We can gener-
ate Systems Today” Retrieved: April 2017.
[30]
S. Shlaer and S. J. Mellor, Object lifecycles : modeling the world
in states.
Englewood Cliﬀs, N.J.: Yourdon Press, 1992.
[31]
F. Wagner, R. Schmuki, T. Wagner, and P. Wolstenholme,
Modeling Software with Finite State Machines: A Practical
Approach.
NY: CRC Press, 2006.
[32]
L. Wen and R. G. Dromey, “From requirements change to
design change: A formal path,” in 2nd International Conference
on Software Engineering and Formal Methods (SEFM 2004).
Beijing, China: IEEE Computer Society, 28-30 September 2004,
pp. 104–113.
[33]
R. G. Dromey and D. Powell, “Early requirements defect de-
tection,” TickIT Journal, vol. 4Q05, 2005, pp. 3–13.
[34]
T. Myers and R. G. Dromey, “From requirements to embedded
software - formalising the key steps,” in 20th Australian Soft-
ware Engineering Conference (ASWEC). Gold Cost, Australia:
IEEE Computer Society, 14-17 April 2009, pp. 23–33.
[35]
D. Harel and M. Politi, Modeling Reactive Systems with Stat-
echarts: The Statemate Approach.
New York, NY, USA:
McGraw-Hill, Inc., 1998.
[36]
R. C. Arkin, Behavior-Based Robotics.
Cambridge, Mass.:
MIT Press, 1998.
[37]
H. Kopetz, Real-Time Systems - Design Principles for Dis-
tributed Embedded Applications, 2nd ed., ser. Real-Time Sys-
tems Series.
Berlin: Springer, 2011.
[38]
W. J. Dzidek, E. Arisholm, and L. C. Briand, “A realistic em-
pirical evaluation of the costs and beneﬁts of UML in software
maintenance,” IEEE Trans. Softw. Eng., vol. 34, no. 3, May
2008, pp. 407–432.
[39]
B. Selic, “The pragmatics of model-driven development,” IEEE
Software, vol. 20, no. 5, Sept 2003, pp. 19–25.
[40]
S. K. Wood, D. H. Akehurst, O. Uzenkov, W. G. J. Howells,
and K. D. McDonald-Maier, “A model-driven development
approach to mapping UML state diagrams to synthesizable
VHDL,” IEEE Transactions on Computers, vol. 57, no. 10, Oct
2008, pp. 1357–1371.

